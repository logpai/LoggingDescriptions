static void createSolrFixtures() throws Exception {	solrHttpsRunner = JettySolrFactory.createJettyTestFixture(true);	httpsPort = solrHttpsRunner.getLocalPort();	
started https test server 

========================= camel sample_13988 =========================

public void onApplicationEvent(ApplicationEvent event) {	for (EventEndpoint endpoint : endpoints) {	try {	endpoint.onApplicationEvent(event);	} catch (Exception e) {	
error on application event this exception will be ignored 

========================= camel sample_16323 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<StubComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.stub.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.stub.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_879 =========================

if (getISeriesEndpoint().getType() == Jt400Type.PGM) {	pgmCall = new ProgramCall(iSeries);	} else {	pgmCall = new ServiceProgramCall(iSeries);	((ServiceProgramCall)pgmCall).setProcedureName(getISeriesEndpoint().getProcedureName());	((ServiceProgramCall)pgmCall).setReturnValueFormat(ServiceProgramCall.NO_RETURN_VALUE);	}	pgmCall.setProgram(commandStr);	pgmCall.setParameterList(parameterList);	if (LOG.isDebugEnabled()) {	
starting to call pgm in host authentication with the user 

pgmCall = new ServiceProgramCall(iSeries);	((ServiceProgramCall)pgmCall).setProcedureName(getISeriesEndpoint().getProcedureName());	((ServiceProgramCall)pgmCall).setReturnValueFormat(ServiceProgramCall.NO_RETURN_VALUE);	}	pgmCall.setProgram(commandStr);	pgmCall.setParameterList(parameterList);	if (LOG.isDebugEnabled()) {	}	boolean result = pgmCall.run();	if (LOG.isTraceEnabled()) {	
executed pgm in host success 

AS400DataType typeConverter;	if (getISeriesEndpoint().getFormat() == Jt400Configuration.Format.binary) {	typeConverter = new AS400ByteArray(length);	} else {	typeConverter = new AS400Text(length, iSeries);	}	inputData = typeConverter.toBytes(param);	}	}	if (input && output) {	
parameter is both input and output 

inputData = typeConverter.toBytes(param);	}	}	if (input && output) {	if (getISeriesEndpoint().getType() == Jt400Type.PGM) {	parameterList[i] = new ProgramParameter(inputData, length);	} else {	parameterList[i] = new ProgramParameter(ProgramParameter.PASS_BY_REFERENCE, inputData, length);	}	} else if (input) {	
parameter is input 

}	} else if (input) {	if (inputData != null) {	parameterList[i] = new ProgramParameter(inputData);	} else {	parameterList[i] = new ProgramParameter();	parameterList[i].setParameterType(ProgramParameter.PASS_BY_REFERENCE);	parameterList[i].setNullParameter(true);	}	} else {	
parameter is output 

protected void doStart() throws Exception {	if (iSeries == null) {	iSeries = getISeriesEndpoint().getSystem();	}	if (!iSeries.isConnected(AS400.COMMAND)) {	
connecting to 

protected void doStop() throws Exception {	if (iSeries != null) {	
releasing connection to 

========================= camel sample_16773 =========================

public void process(Exchange exchange) throws Exception {	
processing exchange in camel 

public void process(Exchange exchange) throws Exception {	BindingOperationInfo boi = (BindingOperationInfo)exchange.getProperty(BindingOperationInfo.class.getName());	if (boi != null) {	
boi isunwrapped 

public void process(Exchange exchange) throws Exception {	BindingOperationInfo boi = (BindingOperationInfo)exchange.getProperty(BindingOperationInfo.class.getName());	if (boi != null) {	}	GetPerson person =  exchange.getIn().getBody(GetPerson.class);	String personId = person.getPersonId();	GetPersonResponse response = new GetPersonResponse();	if (personId == null || personId.length() == 0) {	
person id so throwing exception 

org.apache.camel.non_wrapper.types.UnknownPersonFault personFault = new org.apache.camel.non_wrapper.types.UnknownPersonFault();	personFault.setPersonId("");	org.apache.camel.non_wrapper.UnknownPersonFault fault = new org.apache.camel.non_wrapper.UnknownPersonFault("Get the null value of person name", personFault);	exchange.getOut().setFault(true);	exchange.getOut().setBody(fault);	return;	}	response.setPersonId(personId);	response.setName("Bonjour");	response.setSsn("123");	
setting bonjour as the response 

========================= camel sample_7960 =========================

public FreemarkerEndpoint findOrCreateEndpoint(String uri, String newResourceUri) {	String newUri = uri.replace(getResourceUri(), newResourceUri);	
getting endpoint with uri 

protected void onExchange(Exchange exchange) throws Exception {	String path = getResourceUri();	ObjectHelper.notNull(configuration, "configuration");	ObjectHelper.notNull(path, "resourceUri");	String newResourceUri = exchange.getIn().getHeader(FreemarkerConstants.FREEMARKER_RESOURCE_URI, String.class);	if (newResourceUri != null) {	exchange.getIn().removeHeader(FreemarkerConstants.FREEMARKER_RESOURCE_URI);	
set to creating new endpoint to handle exchange 

if (content != null) {	reader = new StringReader(content);	exchange.getIn().removeHeader(FreemarkerConstants.FREEMARKER_TEMPLATE);	}	Object dataModel = exchange.getIn().getHeader(FreemarkerConstants.FREEMARKER_DATA_MODEL, Object.class);	if (dataModel == null) {	dataModel = ExchangeHelper.createVariableMap(exchange);	}	Template template;	if (reader != null) {	
freemarker is evaluating template read from header using context 

exchange.getIn().removeHeader(FreemarkerConstants.FREEMARKER_TEMPLATE);	}	Object dataModel = exchange.getIn().getHeader(FreemarkerConstants.FREEMARKER_DATA_MODEL, Object.class);	if (dataModel == null) {	dataModel = ExchangeHelper.createVariableMap(exchange);	}	Template template;	if (reader != null) {	template = new Template("temp", reader, new Configuration());	} else {	
freemarker is evaluating using context 

========================= camel sample_9092 =========================

public void testListEndpoints() throws Exception {	template.sendBody("browse:foo", body1);	template.sendBody("browse:foo", body2);	Collection<Endpoint> list = context.getEndpoints();	assertEquals("number of endpoints", 2, list.size());	for (Endpoint endpoint : list) {	List<Exchange> exchanges = ((BrowseEndpoint) endpoint).getExchanges();	
has 

========================= camel sample_3535 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<ExchangePropertyLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.exchangeproperty.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.exchangeproperty.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_896 =========================

public void onInit(Route route) {	ensureElectionIsCreated(route);	
route managed by setting route autostartup flag to false 

private void startAllStoppedRoutes() {	try {	lock.lock();	if (!suspendedRoutes.isEmpty()) {	if (log.isDebugEnabled()) {	
route s have been stopped previously by policy restarting 

private void startAllStoppedRoutes() {	try {	lock.lock();	if (!suspendedRoutes.isEmpty()) {	if (log.isDebugEnabled()) {	}	for (Route suspended : suspendedRoutes) {	
starting route 

========================= camel sample_12675 =========================

public void init(CamelContext camelContext, NettyServerBootstrapConfiguration configuration, ChannelPipelineFactory pipelineFactory) {	super.init(camelContext, configuration, pipelineFactory);	this.port = configuration.getPort();	this.bootstrapConfiguration = configuration;	
bootstrapfactory on port is using bootstrap configuration 

public void addConsumer(NettyConsumer consumer) {	if (compatibleCheck) {	if (bootstrapConfiguration != consumer.getConfiguration() && !bootstrapConfiguration.compatible(consumer.getConfiguration())) {	throw new IllegalArgumentException("Bootstrap configuration must be identical when adding additional consumer: " + consumer.getEndpoint() + " on same port: " + port + ".\n  Existing " + bootstrapConfiguration.toStringBootstrapConfiguration() + "\n       New " + consumer.getConfiguration().toStringBootstrapConfiguration());	}	}	if (LOG.isDebugEnabled()) {	NettyHttpConsumer httpConsumer = (NettyHttpConsumer) consumer;	
bootstrapfactory on port is adding consumer with context path 

public void removeConsumer(NettyConsumer consumer) {	if (LOG.isDebugEnabled()) {	NettyHttpConsumer httpConsumer = (NettyHttpConsumer) consumer;	
bootstrapfactory on port is removing consumer with context path 

protected void doStart() throws Exception {	
bootstrapfactory on port is starting 

public void stop() throws Exception {	int consumers = channelFactory.consumers();	if (consumers == 0) {	
bootstrapfactory on port is stopping 

public void stop() throws Exception {	int consumers = channelFactory.consumers();	if (consumers == 0) {	super.stop();	} else {	
bootstrapfactory on port has registered consumers so cannot stop yet 

========================= camel sample_8379 =========================

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyNettyTest.java"));	MethodSource<JavaClassSource> method = CamelJavaParserHelper.findConfigureMethod(clazz);	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	
consumer 

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyNettyTest.java"));	MethodSource<JavaClassSource> method = CamelJavaParserHelper.findConfigureMethod(clazz);	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	}	Assert.assertEquals("netty-http:http: Assert.assertEquals("netty-http:http: list = CamelJavaParserHelper.parseCamelProducerUris(method, true, true);	for (ParserResult result : list) {	
producer 

========================= camel sample_195 =========================

} else if (obj instanceof String) {	return Bytes.toBytes((String) obj);	} else {	ByteArrayOutputStream baos = new ByteArrayOutputStream();	ObjectOutputStream oos = null;	try {	oos = new ObjectOutputStream(baos);	oos.writeObject(obj);	return baos.toByteArray();	} catch (IOException e) {	
error while serializing object null will be used 

public Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {	try {	return classLoader.loadClass(desc.getName());	} catch (Exception e) {	}	return super.resolveClass(desc);	}	};	result = ois.readObject();	} catch (IOException e) {	
error while deserializing object null will be used 

try {	return classLoader.loadClass(desc.getName());	} catch (Exception e) {	}	return super.resolveClass(desc);	}	};	result = ois.readObject();	} catch (IOException e) {	} catch (ClassNotFoundException e) {	
could not find class while deserializing object null will be used 

========================= camel sample_14522 =========================

public ManagementStrategy create(CamelContext context, boolean disableJMX) {	ManagementStrategy answer;	if (disableJMX || Boolean.getBoolean(JmxSystemPropertyKeys.DISABLED)) {	answer = new DefaultManagementStrategy(context);	} else {	try {	answer = new ManagedManagementStrategy(context, new DefaultManagementAgent(context));	context.getLifecycleStrategies().add(0, new DefaultManagementLifecycleStrategy(context));	} catch (Exception e) {	
cannot create jmx lifecycle strategy will fallback and disable jmx 

========================= camel sample_4589 =========================

public void testSearchTimelineWithStaticQuery() throws Exception {	template.sendBody(null);	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.assertIsSatisfied();	List<Exchange> tweets = mock.getExchanges();	for (Exchange e : tweets) {	
tweet 

public void testSearchTimelineWithDynamicQuery() throws Exception {	templateHeader.sendBodyAndHeader(null, TwitterConstants.TWITTER_KEYWORDS, "java");	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.assertIsSatisfied();	List<Exchange> tweets = mock.getExchanges();	for (Exchange e : tweets) {	
tweet 

public void testSearchTimelineWithDynamicQuerySinceId() throws Exception {	Map<String, Object> headers = new HashMap<String, Object>();	headers.put(TwitterConstants.TWITTER_KEYWORDS, "java");	headers.put(TwitterConstants.TWITTER_SINCEID, new Long(258347905419730944L));	templateHeader.sendBodyAndHeaders(null, headers);	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.assertIsSatisfied();	List<Exchange> tweets = mock.getExchanges();	for (Exchange e : tweets) {	
tweet 

public void testDoubleSearchKeepingOld() throws Exception {	templateDouble.sendBodyAndHeader(null, TwitterConstants.TWITTER_KEYWORDS, "java");	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.assertIsSatisfied();	List<Exchange> tweets = mock.getExchanges();	for (Exchange e : tweets) {	
tweet 

========================= camel sample_14172 =========================

public void start() {	if (nexusUrl == null || nexusUrl.isEmpty()) {	
nexus service not found indexing nexus is not enabled 

public void start() {	if (nexusUrl == null || nexusUrl.isEmpty()) {	return;	}	if (!started.compareAndSet(false, true)) {	
nexusrepository is already started 

public void start() {	if (nexusUrl == null || nexusUrl.isEmpty()) {	return;	}	if (!started.compareAndSet(false, true)) {	return;	}	
starting nexusrepository to scan every seconds 

public void start() {	if (nexusUrl == null || nexusUrl.isEmpty()) {	return;	}	if (!started.compareAndSet(false, true)) {	return;	}	executorService = Executors.newScheduledThreadPool(1);	executorService.scheduleWithFixedDelay(() -> {	try {	
indexing nexus start 

}	if (!started.compareAndSet(false, true)) {	return;	}	executorService = Executors.newScheduledThreadPool(1);	executorService.scheduleWithFixedDelay(() -> {	try {	indexNexus();	} catch (Throwable e) {	if (e.getMessage().contains("UnknownHostException")) {	
error indexing nexus due unknown hosts 

if (!started.compareAndSet(false, true)) {	return;	}	executorService = Executors.newScheduledThreadPool(1);	executorService.scheduleWithFixedDelay(() -> {	try {	indexNexus();	} catch (Throwable e) {	if (e.getMessage().contains("UnknownHostException")) {	} else {	
error indexing nexus due 

}	executorService = Executors.newScheduledThreadPool(1);	executorService.scheduleWithFixedDelay(() -> {	try {	indexNexus();	} catch (Throwable e) {	if (e.getMessage().contains("UnknownHostException")) {	} else {	}	} finally {	
indexing nexus end 

public void stop() {	
stopping nexusrepository 

String g = getNodeText(node.getChildNodes(), "groupId");	String a = getNodeText(node.getChildNodes(), "artifactId");	String v = getNodeText(node.getChildNodes(), "version");	String l = getNodeText(node.getChildNodes(), "artifactLink");	if (g != null & a != null & v != null & l != null) {	NexusArtifactDto dto = new NexusArtifactDto();	dto.setGroupId(g);	dto.setArtifactId(a);	dto.setVersion(v);	dto.setArtifactLink(l);	
found 

========================= camel sample_316 =========================

public void execute() throws MojoExecutionException, MojoFailureException {	if (killAfter != -1) {	
warning killafter is now deprecated do you need it please comment on mexec 

getLog().debug(msg);	}	IsolatedThreadGroup threadGroup = new IsolatedThreadGroup(mainClass /* name */);	Thread bootstrapThread = new Thread(threadGroup, new Runnable() {	public void run() {	try {	Method main = Thread.currentThread().getContextClassLoader().loadClass(mainClass) .getMethod("main", String[].class);	main.invoke(null, new Object[] {arguments});	} catch (Exception e) {	getLog().error("*************************************");	
error occurred while running main from 

getLog().error("*************************************");	Thread.currentThread().getThreadGroup().uncaughtException(Thread.currentThread(), e);	}	}	}, mainClass + ".main()");	bootstrapThread.setContextClassLoader(getClassLoader());	setSystemProperties();	bootstrapThread.start();	joinNonDaemonThreads(threadGroup);	if (keepAlive) {	
warning keepalive is now deprecated and obsolete do you need it please comment on mexec 

bootstrapThread.start();	joinNonDaemonThreads(threadGroup);	if (keepAlive) {	waitFor(0);	}	if (cleanupDaemonThreads) {	terminateThreads(threadGroup);	try {	threadGroup.destroy();	} catch (IllegalThreadStateException e) {	
couldn t destroy thread group 

}	boolean doLog = false;	synchronized (this) {	if (uncaughtException == null) {	uncaughtException = throwable;	} else {	doLog = true;	}	}	if (doLog) {	
an additional exception was thrown 

private void joinThread(Thread thread, long timeoutMsecs) {	try {	
joining on thread 

private void joinThread(Thread thread, long timeoutMsecs) {	try {	thread.join(timeoutMsecs);	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	
interrupted while joining against thread 

private void joinThread(Thread thread, long timeoutMsecs) {	try {	thread.join(timeoutMsecs);	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	}	if (thread.isAlive()) {	
thread was interrupted but is still alive after waiting at least msecs 

private void terminateThreads(ThreadGroup threadGroup) {	long startTime = System.currentTimeMillis();	Set<Thread> uncooperativeThreads = new HashSet<Thread>();	for (Collection<Thread> threads = getActiveThreads(threadGroup); !threads.isEmpty(); threads = getActiveThreads(threadGroup), threads .removeAll(uncooperativeThreads)) {	for (Thread thread : threads) {	
interrupting thread 

}	long timeout = daemonThreadJoinTimeout - (System.currentTimeMillis() - startTime);	if (timeout > 0) {	joinThread(thread, timeout);	}	if (!thread.isAlive()) {	continue;	}	uncooperativeThreads.add(thread);	if (stopUnresponsiveDaemonThreads) {	
thread will be thread stop ed 

if (timeout > 0) {	joinThread(thread, timeout);	}	if (!thread.isAlive()) {	continue;	}	uncooperativeThreads.add(thread);	if (stopUnresponsiveDaemonThreads) {	thread.stop();	} else {	
thread will linger despite being asked to die via interruption 

continue;	}	uncooperativeThreads.add(thread);	if (stopUnresponsiveDaemonThreads) {	thread.stop();	} else {	}	}	}	if (!uncooperativeThreads.isEmpty()) {	
note thread s did not finish despite being asked to via interruption this is not a problem with exec java it is a problem with the running code although not serious it should be remedied 

}	}	}	if (!uncooperativeThreads.isEmpty()) {	} else {	int activeCount = threadGroup.activeCount();	if (activeCount != 0) {	Thread[] threadsArray = new Thread[1];	threadGroup.enumerate(threadsArray);	if (getLog().isDebugEnabled()) {	
strange thread s still active in the group such as 

private void addRelevantPluginDependenciesToClasspath(List<URL> path) throws MojoExecutionException {	if (hasCommandlineArgs()) {	arguments = parseCommandlineArgs();	}	try {	Iterator<Artifact> iter = this.determineRelevantPluginDependencies().iterator();	while (iter.hasNext()) {	Artifact classPathElement = iter.next();	
adding plugin dependency artifact to classpath 

private void addRelevantProjectDependenciesToClasspath(List<URL> path) throws MojoExecutionException {	if (this.includeProjectDependencies) {	try {	
project dependencies will be included 

private void addRelevantProjectDependenciesToClasspath(List<URL> path) throws MojoExecutionException {	if (this.includeProjectDependencies) {	try {	URL mainClasses = new File(project.getBuild().getOutputDirectory()).toURI().toURL();	
adding to classpath 

private void addRelevantProjectDependenciesToClasspath(List<URL> path) throws MojoExecutionException {	if (this.includeProjectDependencies) {	try {	URL mainClasses = new File(project.getBuild().getOutputDirectory()).toURI().toURL();	path.add(mainClasses);	Set<Artifact> dependencies = CastUtils.cast(project.getArtifacts());	dependencies.addAll(getAllNonTestScopedDependencies());	Iterator<Artifact> iter = dependencies.iterator();	while (iter.hasNext()) {	Artifact classPathElement = iter.next();	
adding project dependency artifact to classpath 

Artifact classPathElement = iter.next();	File file = classPathElement.getFile();	if (file != null) {	path.add(file.toURI().toURL());	}	}	} catch (MalformedURLException e) {	throw new MojoExecutionException("Error during setting up classpath", e);	}	} else {	
project dependencies will be excluded 

private Set<Artifact> determineRelevantPluginDependencies() throws MojoExecutionException {	Set<Artifact> relevantDependencies;	if (this.includePluginDependencies) {	if (this.executableDependency == null) {	
all plugin dependencies will be included 

private Set<Artifact> determineRelevantPluginDependencies() throws MojoExecutionException {	Set<Artifact> relevantDependencies;	if (this.includePluginDependencies) {	if (this.executableDependency == null) {	relevantDependencies = new HashSet<Artifact>(this.pluginDependencies);	} else {	
selected plugin dependencies will be included 

if (this.includePluginDependencies) {	if (this.executableDependency == null) {	relevantDependencies = new HashSet<Artifact>(this.pluginDependencies);	} else {	Artifact executableArtifact = this.findExecutableArtifact();	Artifact executablePomArtifact = this.getExecutablePomArtifact(executableArtifact);	relevantDependencies = this.resolveExecutableDependencies(executablePomArtifact);	}	} else {	relevantDependencies = Collections.emptySet();	
plugin dependencies will be excluded 

private void waitFor(long millis) {	Object lock = new Object();	synchronized (lock) {	try {	lock.wait(millis);	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	
spuriously interrupted while waiting for ms 

========================= camel sample_73 =========================

public void testHttpProxy() throws Exception {	
sending messages to a http endpoint which is proxied bridged 

public void testHttpProxy() throws Exception {	StopWatch watch = new StopWatch();	for (int i = 0; i < size; i++) {	String out = template.requestBody("http: assertEquals("Bye " + i, out);	}	
time taken 

========================= camel sample_10977 =========================

protected void debugBefore(Exchange exchange, Processor processor, ProcessorDefinition<?> definition, String id, String shortName) {	
before with body 

========================= camel sample_11665 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<VelocityComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.velocity.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.velocity.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_984 =========================

public static List<PGPPublicKey> findPublicKeys(List<String> useridParts, boolean forEncryption, PGPPublicKeyRingCollection pgpPublicKeyringCollection) {	List<PGPPublicKey> result = new ArrayList<PGPPublicKey>(useridParts.size());	for (Iterator<PGPPublicKeyRing> keyRingIter = pgpPublicKeyringCollection.getKeyRings(); keyRingIter.hasNext();) {	PGPPublicKeyRing keyRing = keyRingIter.next();	PGPPublicKey primaryKey = keyRing.getPublicKey();	String[] foundKeyUserIdForUserIdPart = findFirstKeyUserIdContainingOneOfTheParts(useridParts, primaryKey);	if (foundKeyUserIdForUserIdPart == null) {	
no user id found in primary key with key id containing one of the parts 

public static List<PGPPublicKey> findPublicKeys(List<String> useridParts, boolean forEncryption, PGPPublicKeyRingCollection pgpPublicKeyringCollection) {	List<PGPPublicKey> result = new ArrayList<PGPPublicKey>(useridParts.size());	for (Iterator<PGPPublicKeyRing> keyRingIter = pgpPublicKeyringCollection.getKeyRings(); keyRingIter.hasNext();) {	PGPPublicKeyRing keyRing = keyRingIter.next();	PGPPublicKey primaryKey = keyRing.getPublicKey();	String[] foundKeyUserIdForUserIdPart = findFirstKeyUserIdContainingOneOfTheParts(useridParts, primaryKey);	if (foundKeyUserIdForUserIdPart == null) {	continue;	}	
user id found in primary key with key id containing one of the parts 

PGPPublicKey primaryKey = keyRing.getPublicKey();	String[] foundKeyUserIdForUserIdPart = findFirstKeyUserIdContainingOneOfTheParts(useridParts, primaryKey);	if (foundKeyUserIdForUserIdPart == null) {	continue;	}	foundKeyUserIdForUserIdPart[0], primaryKey.getKeyID(), useridParts });	for (Iterator<PGPPublicKey> keyIter = keyRing.getPublicKeys(); keyIter.hasNext();) {	PGPPublicKey key = keyIter.next();	if (forEncryption) {	if (isEncryptionKey(key)) {	
public encryption key with key user id and key id added to the encryption keys 

}	foundKeyUserIdForUserIdPart[0], primaryKey.getKeyID(), useridParts });	for (Iterator<PGPPublicKey> keyIter = keyRing.getPublicKeys(); keyIter.hasNext();) {	PGPPublicKey key = keyIter.next();	if (forEncryption) {	if (isEncryptionKey(key)) {	result.add(key);	}	} else if (!forEncryption && isSignatureKey(key)) {	result.add(key);	
public key with key user id and key id added to the signing keys 

private static boolean isEncryptionKey(PGPPublicKey key) {	if (!key.isEncryptionKey()) {	return false;	}	Boolean hasEncryptionKeyFlags = hasOneOfExpectedKeyFlags(key, new int[] {KeyFlags.ENCRYPT_COMMS, KeyFlags.ENCRYPT_STORAGE });	if (hasEncryptionKeyFlags != null && !hasEncryptionKeyFlags) {	
public key with key key id found for specified user id but this key will not be used for the encryption because its key flags are not encryption key flags 

public static List<PGPSecretKeyAndPrivateKeyAndUserId> findSecretKeysWithPrivateKeyAndUserId(Map<String, String> sigKeyUserId2Password, String provider, PGPSecretKeyRingCollection pgpSec) throws PGPException {	List<PGPSecretKeyAndPrivateKeyAndUserId> result = new ArrayList<PGPSecretKeyAndPrivateKeyAndUserId>(sigKeyUserId2Password.size());	for (Iterator<?> i = pgpSec.getKeyRings(); i.hasNext();) {	Object data = i.next();	if (data instanceof PGPSecretKeyRing) {	PGPSecretKeyRing keyring = (PGPSecretKeyRing) data;	PGPSecretKey primaryKey = keyring.getSecretKey();	List<String> useridParts = new ArrayList<String>(sigKeyUserId2Password.keySet());	String[] foundKeyUserIdForUserIdPart = findFirstKeyUserIdContainingOneOfTheParts(useridParts, primaryKey.getPublicKey());	if (foundKeyUserIdForUserIdPart == null) {	
no user id found in primary key with key id containing one of the parts 

for (Iterator<?> i = pgpSec.getKeyRings(); i.hasNext();) {	Object data = i.next();	if (data instanceof PGPSecretKeyRing) {	PGPSecretKeyRing keyring = (PGPSecretKeyRing) data;	PGPSecretKey primaryKey = keyring.getSecretKey();	List<String> useridParts = new ArrayList<String>(sigKeyUserId2Password.keySet());	String[] foundKeyUserIdForUserIdPart = findFirstKeyUserIdContainingOneOfTheParts(useridParts, primaryKey.getPublicKey());	if (foundKeyUserIdForUserIdPart == null) {	continue;	}	
user id found in primary key with key id containing one of the parts 

if (foundKeyUserIdForUserIdPart == null) {	continue;	}	foundKeyUserIdForUserIdPart[0], primaryKey.getKeyID(), useridParts });	for (Iterator<PGPSecretKey> iterKey = keyring.getSecretKeys(); iterKey.hasNext();) {	PGPSecretKey secKey = iterKey.next();	if (isSigningKey(secKey)) {	PGPPrivateKey privateKey = secKey.extractPrivateKey(new JcePBESecretKeyDecryptorBuilder().setProvider(provider) .build(sigKeyUserId2Password.get(foundKeyUserIdForUserIdPart[1]).toCharArray()));	if (privateKey != null) {	result.add(new PGPSecretKeyAndPrivateKeyAndUserId(secKey, privateKey, foundKeyUserIdForUserIdPart[0]));	
private key with user id and key id added to the signing keys 

private static boolean isSigningKey(PGPSecretKey secKey) {	if (!secKey.isSigningKey()) {	return false;	}	Boolean hasSigningKeyFlag = hasOneOfExpectedKeyFlags(secKey.getPublicKey(), new int[] {KeyFlags.SIGN_DATA });	if (hasSigningKeyFlag != null && !hasSigningKeyFlag) {	
secret key with key id found for specified user id part but this key will not be used for signing because of its key flags 

public static PGPPublicKey getPublicKeyWithKeyIdAndUserID(long keyId, List<String> userIdParts, PGPPublicKeyRingCollection publicKeyringCollection) throws PGPException {	PGPPublicKeyRing publicKeyring = publicKeyringCollection.getPublicKeyRing(keyId);	if (publicKeyring == null) {	
no public key found for key id 

private static boolean isAllowedKey(List<String> allowedUserIds, Iterator<String> verifyingPublicKeyUserIds) {	if (allowedUserIds == null || allowedUserIds.isEmpty()) {	return true;	}	String keyUserId = null;	for (; verifyingPublicKeyUserIds.hasNext();) {	keyUserId = verifyingPublicKeyUserIds.next();	for (String userid : allowedUserIds) {	if (keyUserId != null && keyUserId.contains(userid)) {	
public key with user id fulfills the user id restriction 

}	String keyUserId = null;	for (; verifyingPublicKeyUserIds.hasNext();) {	keyUserId = verifyingPublicKeyUserIds.next();	for (String userid : allowedUserIds) {	if (keyUserId != null && keyUserId.contains(userid)) {	return true;	}	}	}	
public key with user id does not fulfill the user id restriction 

========================= camel sample_9180 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() {	from("direct:start") .to("sjms:queue:test.queue?transacted=true") .process( new Processor() {	public void process(Exchange exchange) throws Exception {	if (exchange.getIn().getHeader("isfailed", Boolean.class)) {	
we failed should roll back 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() {	from("direct:start") .to("sjms:queue:test.queue?transacted=true") .process( new Processor() {	public void process(Exchange exchange) throws Exception {	if (exchange.getIn().getHeader("isfailed", Boolean.class)) {	exchange.getOut().setFault(true);	} else {	
we passed should commit 

========================= camel sample_12337 =========================

public synchronized void readFrom(Socket socket) throws MllpSocketException, SocketTimeoutException {	
entering readfrom 

}	} catch (SocketTimeoutException timeoutEx) {	throw timeoutEx;	} catch (IOException ioEx) {	final String exceptionMessage = "Exception encountered reading Socket";	resetSocket(socket, exceptionMessage);	throw new MllpSocketException(exceptionMessage, ioEx);	} finally {	if (size() > 0 && !hasCompleteEnvelope()) {	if (!hasEndOfData() && hasEndOfBlock() && endOfBlockIndex < size() - 1) {	
readfrom exiting with partial payload 

final String exceptionMessage = "Exception encountered reading Socket";	resetSocket(socket, exceptionMessage);	throw new MllpSocketException(exceptionMessage, ioEx);	} finally {	if (size() > 0 && !hasCompleteEnvelope()) {	if (!hasEndOfData() && hasEndOfBlock() && endOfBlockIndex < size() - 1) {	}	}	}	} else {	
socket is invalid no data read 

resetSocket(socket, exceptionMessage);	throw new MllpSocketException(exceptionMessage, ioEx);	} finally {	if (size() > 0 && !hasCompleteEnvelope()) {	if (!hasEndOfData() && hasEndOfBlock() && endOfBlockIndex < size() - 1) {	}	}	}	} else {	}	
exiting readfrom 

public synchronized void writeTo(Socket socket) throws MllpSocketException {	
entering writeto 

socketOutputStream.write(buffer, 0, availableByteCount);	socketOutputStream.write(MllpProtocolConstants.PAYLOAD_TERMINATOR);	}	socketOutputStream.flush();	} catch (IOException ioEx) {	final String exceptionMessage = "Exception encountered writing Socket";	resetSocket(socket, exceptionMessage);	throw new MllpSocketException(exceptionMessage, ioEx);	}	} else {	
ignoring call to writeto byte payload mllp payload is null or empty 

}	socketOutputStream.flush();	} catch (IOException ioEx) {	final String exceptionMessage = "Exception encountered writing Socket";	resetSocket(socket, exceptionMessage);	throw new MllpSocketException(exceptionMessage, ioEx);	}	} else {	}	} else {	
socket is invalid no data written 

socketOutputStream.flush();	} catch (IOException ioEx) {	final String exceptionMessage = "Exception encountered writing Socket";	resetSocket(socket, exceptionMessage);	throw new MllpSocketException(exceptionMessage, ioEx);	}	} else {	}	} else {	}	
exiting writeto 

public synchronized String toHl7String(String charsetName) {	String hl7String = null;	if (hasCompleteEnvelope()) {	int offset = hasStartOfBlock() ? startOfBlockIndex + 1 : 1;	int length = hasEndOfBlock() ? endOfBlockIndex - offset : availableByteCount - startOfBlockIndex - 1;	if (length > 0) {	try {	hl7String = new String(buffer, offset, length, charsetName);	} catch (UnsupportedEncodingException unsupportedEncodingEx) {	
failed to create string using charset falling back to default charset 

========================= camel sample_13875 =========================

public void process(final Exchange exchange) throws Exception {	final SMSMessage smsMessage = exchange.getIn().getMandatoryBody(SMSMessage.class);	
validating smsmessage instance provided 

final SMSMessage smsMessage = exchange.getIn().getMandatoryBody(SMSMessage.class);	final Set<ConstraintViolation<SMSMessage>> constraintViolations = getValidator().validate(smsMessage);	if (constraintViolations.size() > 0) {	final StringBuffer msg = new StringBuffer();	for (final ConstraintViolation<SMSMessage> cv : constraintViolations) {	msg.append(String.format("- Invalid value for %s: %s", cv.getPropertyPath().toString(), cv.getMessage()));	}	log.debug(msg.toString());	throw new InvalidPayloadRuntimeException(exchange, SMSMessage.class);	}	
smsmessage instance is valid 

final Set<ConstraintViolation<SMSMessage>> constraintViolations = getValidator().validate(smsMessage);	if (constraintViolations.size() > 0) {	final StringBuffer msg = new StringBuffer();	for (final ConstraintViolation<SMSMessage> cv : constraintViolations) {	msg.append(String.format("- Invalid value for %s: %s", cv.getPropertyPath().toString(), cv.getMessage()));	}	log.debug(msg.toString());	throw new InvalidPayloadRuntimeException(exchange, SMSMessage.class);	}	final CMMessage cmMessage = new CMMessage(smsMessage.getPhoneNumber(), smsMessage.getMessage());	
cmmessage instance build from valid smsmessage instance 

for (final ConstraintViolation<SMSMessage> cv : constraintViolations) {	msg.append(String.format("- Invalid value for %s: %s", cv.getPropertyPath().toString(), cv.getMessage()));	}	log.debug(msg.toString());	throw new InvalidPayloadRuntimeException(exchange, SMSMessage.class);	}	final CMMessage cmMessage = new CMMessage(smsMessage.getPhoneNumber(), smsMessage.getMessage());	if (smsMessage.getFrom() == null || smsMessage.getFrom().isEmpty()) {	String df = getConfiguration().getDefaultFrom();	cmMessage.setSender(df);	
dynamic sender is set to default dynamic sender 

throw new InvalidPayloadRuntimeException(exchange, SMSMessage.class);	}	final CMMessage cmMessage = new CMMessage(smsMessage.getPhoneNumber(), smsMessage.getMessage());	if (smsMessage.getFrom() == null || smsMessage.getFrom().isEmpty()) {	String df = getConfiguration().getDefaultFrom();	cmMessage.setSender(df);	}	cmMessage.setIdAsString(smsMessage.getId());	cmMessage.setUnicodeAndMultipart(getConfiguration().getDefaultMaxNumberOfParts());	sender.send(cmMessage);	
request accepted by cm host 

protected void doStart() throws Exception {	
starting cmproducer 

protected void doStart() throws Exception {	final CMConfiguration configuration = getConfiguration();	if (configuration.isTestConnectionOnStartup()) {	try {	
checking connection 

protected void doStart() throws Exception {	final CMConfiguration configuration = getConfiguration();	if (configuration.isTestConnectionOnStartup()) {	try {	HttpClientBuilder.create().build().execute(new HttpHead(getEndpoint().getCMUrl()));	
connection to ok 

protected void doStart() throws Exception {	final CMConfiguration configuration = getConfiguration();	if (configuration.isTestConnectionOnStartup()) {	try {	HttpClientBuilder.create().build().execute(new HttpHead(getEndpoint().getCMUrl()));	} catch (final Exception e) {	throw new HostUnavailableException(String.format("Connection to %s: NOT AVAILABLE", getEndpoint().getCMUrl()), e);	}	}	super.doStart();	
cmproducer started 

========================= camel sample_12788 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SnmpComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.snmp.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.snmp.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_438 =========================

protected void setUp() throws Exception {	utf = "ABC\u00e6".getBytes("utf-8");	iso = "ABC\u00e6".getBytes("iso-8859-1");	deleteDirectory("target/charset");	createDirectory("target/charset/input");	
utf utf 

protected void setUp() throws Exception {	utf = "ABC\u00e6".getBytes("utf-8");	iso = "ABC\u00e6".getBytes("iso-8859-1");	deleteDirectory("target/charset");	createDirectory("target/charset/input");	
iso iso 

protected void setUp() throws Exception {	utf = "ABC\u00e6".getBytes("utf-8");	iso = "ABC\u00e6".getBytes("iso-8859-1");	deleteDirectory("target/charset");	createDirectory("target/charset/input");	for (byte b : utf) {	
utf byte 

protected void setUp() throws Exception {	utf = "ABC\u00e6".getBytes("utf-8");	iso = "ABC\u00e6".getBytes("iso-8859-1");	deleteDirectory("target/charset");	createDirectory("target/charset/input");	for (byte b : utf) {	}	for (byte b : iso) {	
iso byte 

========================= camel sample_3098 =========================

public void testInvokingSimpleServerWithParams() throws Exception {	Exchange senderExchange = new DefaultExchange(context, ExchangePattern.InOut);	final List<String> params = new ArrayList<String>();	params.add(TEST_MESSAGE);	senderExchange.getIn().setBody(params);	senderExchange.getIn().setHeader(CxfConstants.OPERATION_NAME, ECHO_OPERATION);	Exchange exchange = template.send("direct:EndpointA", senderExchange);	org.apache.camel.Message out = exchange.getOut();	MessageContentsList result = (MessageContentsList)out.getBody();	
received output text 

========================= camel sample_7872 =========================

break;	}	} else {	any = true;	if (anySpoolRules) {	break;	}	}	}	boolean answer = anySpoolRules ? any : all;	
should spool cache 

public StreamCache cache(Exchange exchange) {	Message message = exchange.hasOut() ? exchange.getOut() : exchange.getIn();	StreamCache cache = message.getBody(StreamCache.class);	if (cache != null) {	if (LOG.isTraceEnabled()) {	
cached stream to memory spool 

if (LOG.isTraceEnabled()) {	}	if (statistics.isStatisticsEnabled()) {	try {	if (cache.inMemory()) {	statistics.updateMemory(cache.length());	} else {	statistics.updateSpool(cache.length());	}	} catch (Exception e) {	
error updating cache statistics this exception is ignored 

protected void doStart() throws Exception {	if (!enabled) {	
streamcaching is not enabled 

}	if (chiper != null) {	warn = true;	this.spoolChiper = chiper;	}	if (dir != null) {	warn = true;	this.spoolDirectory = camelContext.getTypeConverter().convertTo(File.class, dir);	}	if (warn) {	
configuring of streamcaching using camelcontext properties is deprecated use streamcachingstrategy instead 

String name = resolveSpoolDirectory(spoolDirectoryName);	if (name != null) {	spoolDirectory = new File(name);	spoolDirectoryName = null;	} else {	throw new IllegalStateException("Cannot resolve spool directory from pattern: " + spoolDirectoryName);	}	}	if (spoolDirectory.exists()) {	if (spoolDirectory.isDirectory()) {	
using spool directory 

if (name != null) {	spoolDirectory = new File(name);	spoolDirectoryName = null;	} else {	throw new IllegalStateException("Cannot resolve spool directory from pattern: " + spoolDirectoryName);	}	}	if (spoolDirectory.exists()) {	if (spoolDirectory.isDirectory()) {	} else {	
spool directory is not a directory this may cause problems spooling to disk for the stream caching 

throw new IllegalStateException("Cannot resolve spool directory from pattern: " + spoolDirectoryName);	}	}	if (spoolDirectory.exists()) {	if (spoolDirectory.isDirectory()) {	} else {	}	} else {	boolean created = spoolDirectory.mkdirs();	if (!created) {	
cannot create spool directory this may cause problems spooling to disk for the stream caching 

}	}	if (spoolDirectory.exists()) {	if (spoolDirectory.isDirectory()) {	} else {	}	} else {	boolean created = spoolDirectory.mkdirs();	if (!created) {	} else {	
created spool directory 

if (spoolThreshold > 0) {	spoolRules.add(new FixedThresholdSpoolRule());	}	if (spoolUsedHeapMemoryThreshold > 0) {	if (spoolUsedHeapMemoryLimit == null) {	spoolUsedHeapMemoryLimit = SpoolUsedHeapMemoryLimit.Max;	}	spoolRules.add(new UsedHeapMemorySpoolRule(spoolUsedHeapMemoryLimit));	}	}	
streamcaching configuration 

spoolRules.add(new FixedThresholdSpoolRule());	}	if (spoolUsedHeapMemoryThreshold > 0) {	if (spoolUsedHeapMemoryLimit == null) {	spoolUsedHeapMemoryLimit = SpoolUsedHeapMemoryLimit.Max;	}	spoolRules.add(new UsedHeapMemorySpoolRule(spoolUsedHeapMemoryLimit));	}	}	if (spoolDirectory != null) {	
streamcaching in use with spool directory and rules 

}	if (spoolUsedHeapMemoryThreshold > 0) {	if (spoolUsedHeapMemoryLimit == null) {	spoolUsedHeapMemoryLimit = SpoolUsedHeapMemoryLimit.Max;	}	spoolRules.add(new UsedHeapMemorySpoolRule(spoolUsedHeapMemoryLimit));	}	}	if (spoolDirectory != null) {	} else {	
streamcaching in use with rules 

protected void doStop() throws Exception {	if (spoolThreshold > 0 & spoolDirectory != null  && isRemoveSpoolDirectoryWhenStopping()) {	
removing spool directory 

protected void doStop() throws Exception {	if (spoolThreshold > 0 & spoolDirectory != null  && isRemoveSpoolDirectoryWhenStopping()) {	FileUtil.removeDir(spoolDirectory);	}	if (LOG.isDebugEnabled() && statistics.isStatisticsEnabled()) {	
stopping streamcachingstrategy with statistics 

public boolean shouldSpoolCache(long length) {	if (spoolThreshold > 0 && length > spoolThreshold) {	
should spool cache fixed threshold true 

double upper = limit == SpoolUsedHeapMemoryLimit.Committed ? heapUsage.getHeapMemoryUsage().getCommitted() : heapUsage.getHeapMemoryUsage().getMax();	double calc = (used / upper) * 100;	int percentage = (int) calc;	if (LOG.isTraceEnabled()) {	long u = heapUsage.getHeapMemoryUsage().getUsed();	long c = heapUsage.getHeapMemoryUsage().getCommitted();	long m = heapUsage.getHeapMemoryUsage().getMax();	LOG.trace("Heap memory: [used={}M ({}%), committed={}M, max={}M]", new Object[]{u >> 20, percentage, c >> 20, m >> 20});	}	if (percentage > spoolUsedHeapMemoryThreshold) {	
should spool cache heap memory threshold true 

========================= camel sample_4024 =========================

protected CamelContext createCamelContext() throws Exception {	if (isPlatform("windows")) {	return super.createCamelContext();	}	CamelContext answer = super.createCamelContext();	RubyCamel.setCamelContext(answer);	RubyCamel.clearRoutes();	runScript(scriptName);	List<RouteBuilder> list = RubyCamel.getRoutes();	
found route builders 

========================= camel sample_14575 =========================

protected void doStart() throws Exception {	super.doStart();	if (folder == null) {	return;	}	File dir = new File(folder);	if (dir.exists() && dir.isDirectory()) {	
starting reloadstrategy to watch directory 

if (clazz != null) {	WatchEvent.Modifier[] modifiers = clazz.getEnumConstants();	for (WatchEvent.Modifier mod : modifiers) {	if ("HIGH".equals(mod.name())) {	modifier = mod;	break;	}	}	}	if (modifier != null) {	
on mac os x the jdk watchservice is slow by default so enabling sensitivitywatcheventmodifier high as workaround 

WatchEvent.Modifier[] modifiers = clazz.getEnumConstants();	for (WatchEvent.Modifier mod : modifiers) {	if ("HIGH".equals(mod.name())) {	modifier = mod;	break;	}	}	}	if (modifier != null) {	} else {	
on mac os x the jdk watchservice is slow and it may take up till seconds to notice file changes 

public void run() {	
reloadstrategy is starting watching folder 

public void run() {	while (isStarting() || isRunAllowed()) {	running = true;	WatchKey key;	try {	
reloadstrategy is polling for file changes in directory 

Path pathToReload = null;	if (isRecursive) {	pathToReload = folderKeys.get(key);	} else {	pathToReload = folder;	}	for (WatchEvent<?> event : key.pollEvents()) {	WatchEvent<Path> we = (WatchEvent<Path>) event;	Path path = we.context();	String name = pathToReload.resolve(path).toAbsolutePath().toFile().getAbsolutePath();	
modified created file 

if (isRecursive) {	pathToReload = folderKeys.get(key);	} else {	pathToReload = folder;	}	for (WatchEvent<?> event : key.pollEvents()) {	WatchEvent<Path> we = (WatchEvent<Path>) event;	Path path = we.context();	String name = pathToReload.resolve(path).toAbsolutePath().toFile().getAbsolutePath();	if (name.toLowerCase(Locale.US).endsWith(".xml")) {	
modified created xml file 

for (WatchEvent<?> event : key.pollEvents()) {	WatchEvent<Path> we = (WatchEvent<Path>) event;	Path path = we.context();	String name = pathToReload.resolve(path).toAbsolutePath().toFile().getAbsolutePath();	if (name.toLowerCase(Locale.US).endsWith(".xml")) {	try {	FileInputStream fis = new FileInputStream(name);	onReloadXml(getCamelContext(), name, fis);	IOHelper.close(fis);	} catch (Exception e) {	
error reloading routes from file due this exception is ignored 

}	}	}	boolean valid = key.reset();	if (!valid) {	break;	}	}	}	running = false;	
reloadstrategy is stopping watching folder 

========================= camel sample_4161 =========================

public void doStart() throws Exception {	if (groupInterval != null) {	ObjectHelper.notNull(camelContext, "CamelContext", this);	logSchedulerService = camelContext.getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "ThroughputLogger");	Runnable scheduledLogTask = new ScheduledLogTask();	
scheduling throughput log to run every millis 

public void run() {	if (!camelContext.getStatus().isStarted()) {	
throughputlogger cannot start because camelcontext has not been started yet 

========================= camel sample_4531 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<EhcacheComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ehcache.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ehcache.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_654 =========================

StringBuilder sb = new StringBuilder();	for (char ch : hostName.toCharArray()) {	if (ch < 127) {	sb.append(ch);	} else {	changed = true;	}	}	if (changed) {	String newHost = sb.toString();	
sanitized hostname from to 

========================= camel sample_3962 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("seda:start") .to("log:foo") .to("log:bar") .to("log:baz") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	try {	throw new IllegalArgumentException("Forced to dump stacktrace");	} catch (Exception e) {	e.fillInStackTrace();	
there are lines in the stacktrace 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("seda:start") .to("log:foo") .to("log:bar") .to("log:baz") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	try {	throw new IllegalArgumentException("Forced to dump stacktrace");	} catch (Exception e) {	e.fillInStackTrace();	
dump stacktrace to log 

========================= camel sample_2220 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ClassComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.class.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.class.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_838 =========================

public void testSedaQueue() throws Exception {	final CountDownLatch latch = new CountDownLatch(1);	CamelContext context = new DefaultCamelContext();	context.addRoutes(new RouteBuilder() {	public void configure() {	from("seda:test.a").to("seda:test.b");	from("seda:test.b").process(new Processor() {	public void process(Exchange e) {	
received exchange 

public void testThatShowsEndpointResolutionIsNotConsistent() throws Exception {	final CountDownLatch latch = new CountDownLatch(1);	CamelContext context = new DefaultCamelContext();	context.addRoutes(new RouteBuilder() {	public void configure() {	from("seda:test.a").to("seda:test.b");	from("seda:test.b").process(new Processor() {	public void process(Exchange e) {	
received exchange 

========================= camel sample_3431 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SnsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-sns.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-sns.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1119 =========================

public void shutdown() throws Exception {	
stopping 

public void shutdown() throws Exception {	controlledContext.stop();	
stopped 

========================= camel sample_12634 =========================

public Processor wrapProcessorInInterceptors(final CamelContext context, final ProcessorDefinition<?> definition, final Processor target, final Processor nextTarget) throws Exception {	if (definition instanceof RecipientListDefinition<?>) {	final DelegateAsyncProcessor delegateAsyncProcessor = new DelegateAsyncProcessor() {	public boolean process(final Exchange exchange, final AsyncCallback callback) {	
i m doing someting 

public Processor wrapProcessorInInterceptors(final CamelContext context, final ProcessorDefinition<?> definition, final Processor target, final Processor nextTarget) throws Exception {	if (definition instanceof RecipientListDefinition<?>) {	final DelegateAsyncProcessor delegateAsyncProcessor = new DelegateAsyncProcessor() {	public boolean process(final Exchange exchange, final AsyncCallback callback) {	return super.process(exchange, new AsyncCallback() {	public void done(final boolean doneSync) {	
i m done 

========================= camel sample_3827 =========================

if (EndpointHelper.isReferenceParameter(value)) {	String name = value.substring(1);	Object o = CamelContextHelper.mandatoryLookup(camelContext, name);	serverBootstrap.option(option, o);	} else {	serverBootstrap.option(option, value);	}	}	}	serverBootstrap.childHandler(pipelineFactory);	
created serverbootstrap 

if (EndpointHelper.isReferenceParameter(value)) {	String name = value.substring(1);	Object o = CamelContextHelper.mandatoryLookup(camelContext, name);	serverBootstrap.option(option, o);	} else {	serverBootstrap.option(option, value);	}	}	}	serverBootstrap.childHandler(pipelineFactory);	
serverbootstrap binding to 

protected void stopServerBootstrap() {	
serverbootstrap unbinding from 

protected void stopServerBootstrap() {	
closing channels 

========================= camel sample_10259 =========================

private void getFunction(AWSLambda lambdaClient, Exchange exchange) {	GetFunctionResult result;	try {	result = lambdaClient.getFunction(new GetFunctionRequest().withFunctionName(getConfiguration().getFunction()));	} catch (AmazonServiceException ase) {	
getfunction command returned the error code 

private void deleteFunction(AWSLambda lambdaClient, Exchange exchange) {	DeleteFunctionResult result;	try {	result = lambdaClient.deleteFunction(new DeleteFunctionRequest().withFunctionName(getConfiguration().getFunction()));	} catch (AmazonServiceException ase) {	
deletefunction command returned the error code 

private void listFunctions(AWSLambda lambdaClient, Exchange exchange) {	ListFunctionsResult result;	try {	result = lambdaClient.listFunctions();	} catch (AmazonServiceException ase) {	
listfunctions command returned the error code 

private void invokeFunction(AWSLambda lambdaClient, Exchange exchange) {	InvokeResult result;	try {	InvokeRequest request = new InvokeRequest() .withFunctionName(getConfiguration().getFunction()) .withPayload(exchange.getIn().getBody(String.class));	result = lambdaClient.invoke(request);	} catch (AmazonServiceException ase) {	
invokefunction command returned the error code 

if (securityGroupIds != null) {	vpcConfig.withSecurityGroupIds(securityGroupIds);	}	if (subnetIds != null) {	vpcConfig.withSubnetIds(subnetIds);	}	request.withVpcConfig(vpcConfig);	}	result = lambdaClient.createFunction(request);	} catch (AmazonServiceException ase) {	
createfunction command returned the error code 

if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(LambdaConstants.SDK_CLIENT_EXECUTION_TIMEOUT))) {	Integer timeout = exchange.getIn().getHeader(LambdaConstants.SDK_CLIENT_EXECUTION_TIMEOUT, Integer.class);	request.withSdkClientExecutionTimeout(timeout);	}	if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(LambdaConstants.SDK_REQUEST_TIMEOUT))) {	Integer timeout = exchange.getIn().getHeader(LambdaConstants.SDK_REQUEST_TIMEOUT, Integer.class);	request.withSdkRequestTimeout(timeout);	}	result = lambdaClient.updateFunctionCode(request);	} catch (AmazonServiceException ase) {	
updatefunction command returned the error code 

========================= camel sample_8768 =========================

public void sleep(long redeliveryDelay) throws InterruptedException {	
sleeping for millis until attempting redelivery 

========================= camel sample_4462 =========================

public boolean process(Exchange exchange, AsyncCallback callback) {	try {	throw new IllegalArgumentException("Forced to dump stacktrace");	} catch (Exception e) {	e.fillInStackTrace();	
there are lines in the stacktrace 

public boolean process(Exchange exchange, AsyncCallback callback) {	try {	throw new IllegalArgumentException("Forced to dump stacktrace");	} catch (Exception e) {	e.fillInStackTrace();	
dump stacktrace to log 

========================= camel sample_1660 =========================

public boolean register(HealthCheck check) {	boolean result = checks.add(check);	if (result) {	if (check instanceof CamelContextAware) {	((CamelContextAware) check).setCamelContext(camelContext);	}	
healthcheck with id successfully registered 

public boolean unregister(HealthCheck check) {	boolean result = checks.remove(check);	if (result) {	
healthcheck with id successfully un registered 

public boolean addRepository(HealthCheckRepository repository) {	boolean result = repositories.add(repository);	if (result) {	if (repository instanceof CamelContextAware) {	((CamelContextAware) repository).setCamelContext(getCamelContext());	
healthcheckrepository successfully registered 

public boolean removeRepository(HealthCheckRepository repository) {	boolean result = repositories.remove(repository);	if (result) {	
healthcheckrepository with successfully un registered 

========================= camel sample_4032 =========================

private StatusLine sendRoomMessage(String room, Exchange exchange) throws IOException, InvalidPayloadException {	String urlPath = String.format(getConfig().withAuthToken(HipchatApiConstants.URI_PATH_ROOM_NOTIFY), room);	String backGroundColor = exchange.getIn().getHeader(HipchatConstants.MESSAGE_BACKGROUND_COLOR, String.class);	Map<String, String> jsonParam = getCommonHttpPostParam(exchange);	if (backGroundColor != null) {	jsonParam.put(HipchatApiConstants.API_MESSAGE_COLOR, backGroundColor);	}	
sending message to room 

private StatusLine sendRoomMessage(String room, Exchange exchange) throws IOException, InvalidPayloadException {	String urlPath = String.format(getConfig().withAuthToken(HipchatApiConstants.URI_PATH_ROOM_NOTIFY), room);	String backGroundColor = exchange.getIn().getHeader(HipchatConstants.MESSAGE_BACKGROUND_COLOR, String.class);	Map<String, String> jsonParam = getCommonHttpPostParam(exchange);	if (backGroundColor != null) {	jsonParam.put(HipchatApiConstants.API_MESSAGE_COLOR, backGroundColor);	}	StatusLine statusLine = post(encodeHttpURI(urlPath), jsonParam);	
response status for send room message 

private StatusLine sendUserMessage(String user, Exchange exchange) throws IOException, InvalidPayloadException {	String urlPath = String.format(getConfig().withAuthToken(HipchatApiConstants.URI_PATH_USER_MESSAGE), user);	Map<String, String> jsonParam = getCommonHttpPostParam(exchange);	
sending message to user 

private StatusLine sendUserMessage(String user, Exchange exchange) throws IOException, InvalidPayloadException {	String urlPath = String.format(getConfig().withAuthToken(HipchatApiConstants.URI_PATH_USER_MESSAGE), user);	Map<String, String> jsonParam = getCommonHttpPostParam(exchange);	StatusLine statusLine = post(urlPath, jsonParam);	
response status for send user message 

========================= camel sample_11331 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<NovaComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.openstack-nova.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.openstack-nova.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1230 =========================

int endIndex = queryString.indexOf('&', startIndex);	if (endIndex == -1) {	endIndex = queryString.length() - 1;	}	final String strSince = queryString.substring(startIndex, endIndex);	try {	this.sinceTime = URLDecoder.decode(strSince, "UTF-8");	} catch (UnsupportedEncodingException e) {	throw new RuntimeCamelException(String.format("Error decoding %s.since with value %s due to: %s", READING_PREFIX, strSince, e.getMessage()), e);	}	
using supplied property since value 

endIndex = queryString.length() - 1;	}	final String strSince = queryString.substring(startIndex, endIndex);	try {	this.sinceTime = URLDecoder.decode(strSince, "UTF-8");	} catch (UnsupportedEncodingException e) {	throw new RuntimeCamelException(String.format("Error decoding %s.since with value %s due to: %s", READING_PREFIX, strSince, e.getMessage()), e);	}	}	if (queryString.contains("until=")) {	
overriding configured property until 

argNames.addAll(FacebookPropertiesHelper.getEndpointPropertyNames(endpoint.getConfiguration()));	argNames.add(READING_PROPERTY);	final String[] argNamesArray = argNames.toArray(new String[argNames.size()]);	List<FacebookMethodsType> filteredMethods = filterMethods( endpoint.getCandidates(), MatchType.SUPER_SET, argNamesArray);	if (filteredMethods.isEmpty()) {	throw new IllegalArgumentException( String.format("Missing properties for %s, need one or more from %s", endpoint.getMethod(), getMissingProperties(endpoint.getMethod(), endpoint.getNameStyle(), argNames)));	} else if (filteredMethods.size() == 1) {	result = filteredMethods.get(0);	} else {	result = getHighestPriorityMethod(filteredMethods);	
using highest priority method from methods 

========================= camel sample_9600 =========================

return;	}	context.addRoutes(new RouteBuilder() {	public void configure() {	from("netty4:tcp: .process(new Processor() {	public void process(Exchange exchange) throws Exception {	SSLSession session = exchange.getIn().getHeader(NettyConstants.NETTY_SSL_SESSION, SSLSession.class);	if (session != null) {	javax.security.cert.X509Certificate cert = session.getPeerCertificateChain()[0];	Principal principal = cert.getSubjectDN();	
client cert subjectdn 

========================= camel sample_10170 =========================

afterPropertiesSet();	RemoteFileConsumer<T> consumer = buildConsumer(processor);	if (isDelete() && getMove() != null) {	throw new IllegalArgumentException("You cannot both set delete=true and move options");	}	if (isNoop() && !isIdempotentSet()) {	log.info("Endpoint is configured with noop=true so forcing endpoint to be idempotent as well");	setIdempotent(true);	}	if (isIdempotentSet() && isIdempotent() && idempotentRepository == null) {	
using default memory based idempotent repository with cache max size 

public PollingConsumer createPollingConsumer() throws Exception {	if (log.isDebugEnabled()) {	
creating genericfilepollingconsumer with queuesize blockwhenfull blocktimeout 

========================= camel sample_15372 =========================

public boolean isValid(CacheManager cacheManager, String cacheName, String key) {	
cache name 

public boolean isValid(CacheManager cacheManager, String cacheName, String key) {	if (!cacheManager.cacheExists(cacheName)) {	
no existing cache found with name please ensure a cache is first instantiated using a cache consumer or cache producer replacement will not be performed since the cache does not presently exist 

public boolean isValid(CacheManager cacheManager, String cacheName, String key) {	if (!cacheManager.cacheExists(cacheName)) {	return false;	}	
found an existing cache 

public boolean isValid(CacheManager cacheManager, String cacheName, String key) {	if (!cacheManager.cacheExists(cacheName)) {	return false;	}	if (LOG.isTraceEnabled()) {	
cache currently contains elements 

public boolean isValid(CacheManager cacheManager, String cacheName, String key) {	if (!cacheManager.cacheExists(cacheName)) {	return false;	}	if (LOG.isTraceEnabled()) {	}	Ehcache cache = cacheManager.getCache(cacheName);	if (!cache.isKeyInCache(key)) {	
no key with name presently exists in the cache it is also possible that the key may have expired in the cache replacement will not be performed until an appropriate key value pair is added to or found in the cache 

========================= camel sample_10520 =========================

protected void doStart() throws Exception {	super.doStart();	if (endpoint.getDelay() >= 0) {	task = new TimerTask() {	private final AtomicLong counter = new AtomicLong();	public void run() {	if (!isTaskRunAllowed()) {	
run now allowed for timer 

public void run() {	if (!isTaskRunAllowed()) {	return;	}	try {	long count = counter.incrementAndGet();	boolean fire = endpoint.getRepeatCount() <= 0 || count <= endpoint.getRepeatCount();	if (fire) {	sendTimerExchange(count);	} else {	
cancelling timer as repeat count limit reached after counts 

}	try {	long count = counter.incrementAndGet();	boolean fire = endpoint.getRepeatCount() <= 0 || count <= endpoint.getRepeatCount();	if (fire) {	sendTimerExchange(count);	} else {	cancel();	}	} catch (Throwable e) {	
error processing exchange this exception will be ignored to let the timer be able to trigger again 

protected void sendTimerExchange(long counter) {	final Exchange exchange = endpoint.createExchange();	exchange.setProperty(Exchange.TIMER_COUNTER, counter);	exchange.setProperty(Exchange.TIMER_NAME, endpoint.getTimerName());	exchange.setProperty(Exchange.TIMER_TIME, endpoint.getTime());	exchange.setProperty(Exchange.TIMER_PERIOD, endpoint.getPeriod());	Date now = new Date();	exchange.setProperty(Exchange.TIMER_FIRED_TIME, now);	exchange.getIn().setHeader("firedTime", now);	if (LOG.isTraceEnabled()) {	
timer is firing count 

========================= camel sample_4874 =========================

private static void doGetBlob(CloudBlob client, Exchange exchange, BlobServiceConfiguration cfg) throws Exception {	BlobServiceUtil.configureCloudBlobForRead(client, cfg);	BlobServiceRequestOptions opts = getRequestOptions(exchange);	
getting a blob from exchange 

========================= camel sample_9968 =========================

protected RouteBuilder createRouteBuilder() {	mllpClient.setMllpHost("localhost");	mllpClient.setMllpPort(AvailablePortFinder.getNextAvailable());	return new RouteBuilder() {	public void configure() throws Exception {	String routeId = "mllp-test-receiver-route";	onException(MllpInvalidMessageException.class) .to(invalid);	
mllp mllpclient getmllphost mllpclient getmllpport connect timeout response timeout validatepayload requireendofdata routeid routeid log logginglevel info routeid message to complete 

public void testOpenMllpEnvelopeWithReset() throws Exception {	expectedCompleteCount = 4;	expectedInvalidCount = 1;	setExpectedCounts();	NotifyBuilder notify1 = new NotifyBuilder(context).whenDone(2).create();	NotifyBuilder notify2 = new NotifyBuilder(context).whenDone(5).create();	mllpClient.connect();	mllpClient.setSoTimeout(10000);	
sending test message 

public void testOpenMllpEnvelopeWithReset() throws Exception {	expectedCompleteCount = 4;	expectedInvalidCount = 1;	setExpectedCounts();	NotifyBuilder notify1 = new NotifyBuilder(context).whenDone(2).create();	NotifyBuilder notify2 = new NotifyBuilder(context).whenDone(5).create();	mllpClient.connect();	mllpClient.setSoTimeout(10000);	String acknowledgement1 = mllpClient.sendMessageAndWaitForAcknowledgement(Hl7TestMessageGenerator.generateMessage(1));	
sending test message 

expectedCompleteCount = 4;	expectedInvalidCount = 1;	setExpectedCounts();	NotifyBuilder notify1 = new NotifyBuilder(context).whenDone(2).create();	NotifyBuilder notify2 = new NotifyBuilder(context).whenDone(5).create();	mllpClient.connect();	mllpClient.setSoTimeout(10000);	String acknowledgement1 = mllpClient.sendMessageAndWaitForAcknowledgement(Hl7TestMessageGenerator.generateMessage(1));	String acknowledgement2 = mllpClient.sendMessageAndWaitForAcknowledgement(Hl7TestMessageGenerator.generateMessage(2));	assertTrue("First two normal exchanges did not complete", notify1.matches(RESPONSE_TIMEOUT, TimeUnit.MILLISECONDS));	
sending test message 

mllpClient.connect();	mllpClient.setSoTimeout(10000);	String acknowledgement1 = mllpClient.sendMessageAndWaitForAcknowledgement(Hl7TestMessageGenerator.generateMessage(1));	String acknowledgement2 = mllpClient.sendMessageAndWaitForAcknowledgement(Hl7TestMessageGenerator.generateMessage(2));	assertTrue("First two normal exchanges did not complete", notify1.matches(RESPONSE_TIMEOUT, TimeUnit.MILLISECONDS));	mllpClient.setSendEndOfBlock(false);	mllpClient.setSendEndOfData(false);	try {	mllpClient.sendMessageAndWaitForAcknowledgement(Hl7TestMessageGenerator.generateMessage(3));	} catch (MllpJUnitResourceException resourceEx) {	
expected exception reading response 

assertTrue("First two normal exchanges did not complete", notify1.matches(RESPONSE_TIMEOUT, TimeUnit.MILLISECONDS));	mllpClient.setSendEndOfBlock(false);	mllpClient.setSendEndOfData(false);	try {	mllpClient.sendMessageAndWaitForAcknowledgement(Hl7TestMessageGenerator.generateMessage(3));	} catch (MllpJUnitResourceException resourceEx) {	}	mllpClient.disconnect();	Thread.sleep(1000);	mllpClient.connect();	
sending test message 

try {	mllpClient.sendMessageAndWaitForAcknowledgement(Hl7TestMessageGenerator.generateMessage(3));	} catch (MllpJUnitResourceException resourceEx) {	}	mllpClient.disconnect();	Thread.sleep(1000);	mllpClient.connect();	mllpClient.setSendEndOfBlock(true);	mllpClient.setSendEndOfData(true);	String acknowledgement4 = mllpClient.sendMessageAndWaitForAcknowledgement(Hl7TestMessageGenerator.generateMessage(4));	
sending test message 

public abstract void testNthMessageContainingEmbeddedStartOfBlock() throws Exception;	protected void runNthMessageContainingEmbeddedStartOfBlock() throws Exception {	int messageCount = 10;	expectedCompleteCount = messageCount - expectedInvalidCount;	setExpectedCounts();	for (int i = 0; i < messageCount; ++i) {	String message = (i == (messageCount / 2)) ? Hl7TestMessageGenerator.generateMessage(i + 1).replaceFirst("EVN", "EVN" + MllpProtocolConstants.START_OF_BLOCK) : Hl7TestMessageGenerator.generateMessage(i + 1);	
sending message 

========================= camel sample_13834 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<GroovyLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.groovy.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.groovy.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_496 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	errorHandler(defaultErrorHandler().maximumRedeliveries(5).redeliveryDelay(10000).asyncDelayedRedelivery());	from("seda:start") .to("log:before") .to("mock:before") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	
processing at attempt 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	errorHandler(defaultErrorHandler().maximumRedeliveries(5).redeliveryDelay(10000).asyncDelayedRedelivery());	from("seda:start") .to("log:before") .to("mock:before") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String body = exchange.getIn().getBody(String.class);	if (body.contains("World")) {	if (++attempt <= 2) {	
processing failed will thrown an exception 

errorHandler(defaultErrorHandler().maximumRedeliveries(5).redeliveryDelay(10000).asyncDelayedRedelivery());	from("seda:start") .to("log:before") .to("mock:before") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String body = exchange.getIn().getBody(String.class);	if (body.contains("World")) {	if (++attempt <= 2) {	throw new IllegalArgumentException("Damn");	}	}	exchange.getIn().setBody("Hello " + body);	
processing at attempt complete 

========================= camel sample_2627 =========================

public String sayHello(String name) {	
invoked sayhello with 

========================= camel sample_8416 =========================

} else {	resultEntries.put(atmosPath, AtmosResultCode.OK);	}	} catch (Exception ex) {	resultEntries.put(atmosPath, AtmosResultCode.KO);	} finally {	result.setResultEntries(resultEntries);	}	return result;	} else {	
uploading a dir 

resultEntries = new HashMap<String, AtmosResultCode>(listFiles.size());	for (File file : listFiles) {	String absPath = file.getAbsolutePath();	int indexRemainingPath = localPath.length();	if (!localPath.endsWith("/")) {	indexRemainingPath += 1;	}	String remainingPath = absPath.substring(indexRemainingPath);	atmosPath = atmosPath + remainingPath;	try {	
uploading to 

private void downloadFilesInFolder(String atmosPath, Map<String, ByteArrayOutputStream> resultEntries) throws AtmosException {	ObjectPath atmosEntry = new ObjectPath(atmosPath);	if (AtmosAPIFacade.client.getSystemMetadata(atmosEntry) == null) {	throw new AtmosException(atmosPath + " does not exist or cannot obtain metadata");	}	if (!atmosEntry.isDirectory()) {	
downloading a single file 

downloadSingleFile(atmosPath, resultEntries);	return;	}	ListDirectoryRequest listRequest = new ListDirectoryRequest().path(atmosEntry);	AtmosAPIFacade.client.listDirectory(listRequest);	for (DirectoryEntry entry : AtmosAPIFacade.client.listDirectory(listRequest).getEntries()) {	if (!entry.isDirectory()) {	try {	downloadSingleFile(atmosEntry.getPath().concat(entry.getFilename()), resultEntries);	} catch (AtmosException e) {	
cannot download from 

ByteArrayOutputStream baos = new ByteArrayOutputStream();	byte[] content = null;	try {	content = AtmosAPIFacade.client.readObject(new ObjectPath(path), byte[].class);	baos.write(content);	} catch (IOException e) {	throw new AtmosException(path + " cannot obtain a stream", e);	}	if (content != null) {	resultEntries.put(path, baos);	
downloaded path size 

========================= camel sample_7219 =========================

});	main.start();	List<CamelContext> contextList = main.getCamelContexts();	assertNotNull(contextList);	assertEquals("size", 1, contextList.size());	CamelContext camelContext = contextList.get(0);	MockEndpoint endpoint = camelContext.getEndpoint("mock:results", MockEndpoint.class);	endpoint.expectedMinimumMessageCount(2);	endpoint.assertIsSatisfied();	List<Exchange> list = endpoint.getReceivedExchanges();	
received 

========================= camel sample_16159 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<WsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ahc-ws.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ahc-ws.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1267 =========================

public void run() {	Map<String, Object> headers = new HashMap<String, Object>();	String arguments = "foo";	headers.put(ScriptBuilder.ARGUMENTS, arguments);	sendBody("direct:start", "hello", headers);	}	});	}	assertMockEndpointsSatisfied();	long delta = System.currentTimeMillis() - start;	
processing the request tooks ms 

========================= camel sample_11223 =========================

protected void doStart() throws Exception {	super.doStart();	if (reporter == null) {	reporter = createReporter();	}	
expecting messages 

========================= camel sample_4823 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<EtcdComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.etcd.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.etcd.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_615 =========================

return null;	}	String existingGitUrl = (String) dto.get("gitUrl");	if (existingGitUrl == null || !existingGitUrl.equals(gitUrl)) {	dto.put("gitUrl", gitUrl);	File file = new File(classesDirectory, "camel-connector.json");	mapper.writerWithDefaultPrettyPrinter().writeValue(file, dto);	File root = classesDirectory.getParentFile().getParentFile();	File sourceFile = new File(root, "src/main/resources/camel-connector.json");	if (sourceFile.exists()) {	
updating giturl to in 

period.put("name", "schedulerPeriod");	period.put("kind", "parameter");	period.put("displayName", "Period");	period.put("group", "consumer");	period.put("type", "integer");	period.put("javaType", "long");	period.put("deprecated", "false");	period.put("secret", "false");	period.put("defaultValue", "1000");	period.put("description", "Delay in milli seconds between scheduling (executing)");	
connector is using scheduler timer 

if (is != null) {	List<String> schema = FileHelper.loadFile(is);	is.close();	File out = new File(classesDirectory, "camel-component-schema.json");	FileOutputStream fos = new FileOutputStream(out, false);	for (String line : schema) {	fos.write(line.getBytes());	fos.write("\n".getBytes());	}	fos.close();	
embedded camel component schema json file for camel component 

ObjectMapper mapper = new ObjectMapper();	Map dto = mapper.readValue(file, Map.class);	if (version != null) {	String existingVersion = (String) dto.get(qualifier);	if (existingVersion == null || !existingVersion.equals(version)) {	dto.put(qualifier, version);	mapper.writerWithDefaultPrettyPrinter().writeValue(file, dto);	File root = classesDirectory.getParentFile().getParentFile();	file = new File(root, "src/main/resources/camel-connector.json");	if (file.exists()) {	
updating to in 

========================= camel sample_65 =========================

runWithTransaction(runnable, true);	} catch (Throwable e) {	rollback = true;	throw e;	} finally {	try {	if (rollback) {	rollback(false);	}	} catch (Exception e) {	
could not do rollback of outer transaction 

} finally {	try {	if (rollback) {	rollback(false);	}	} catch (Exception e) {	}	try {	resumeTransaction(suspendedTransaction);	} catch (Exception e) {	
could not resume outer transaction 

========================= camel sample_9856 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SesComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-ses.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-ses.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1135 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<HttpComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.http4.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.http4.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_951 =========================

vertxOptions.setClustered(true);	}	if (port > 0) {	vertxOptions.setClusterPort(port);	vertxOptions.setClustered(true);	}	}	createdVertx = true;	final CountDownLatch latch = new CountDownLatch(1);	if (vertxOptions.isClustered()) {	
creating clustered vertx 

vertxOptions.setClusterPort(port);	vertxOptions.setClustered(true);	}	}	createdVertx = true;	final CountDownLatch latch = new CountDownLatch(1);	if (vertxOptions.isClustered()) {	vertxFactory.clusteredVertx(vertxOptions, new Handler<AsyncResult<Vertx>>() {	public void handle(AsyncResult<Vertx> event) {	if (event.cause() != null) {	
error creating clustered vertx due 

}	}	createdVertx = true;	final CountDownLatch latch = new CountDownLatch(1);	if (vertxOptions.isClustered()) {	vertxFactory.clusteredVertx(vertxOptions, new Handler<AsyncResult<Vertx>>() {	public void handle(AsyncResult<Vertx> event) {	if (event.cause() != null) {	} else if (event.succeeded()) {	vertx = event.result();	
eventbus is ready 

vertxFactory.clusteredVertx(vertxOptions, new Handler<AsyncResult<Vertx>>() {	public void handle(AsyncResult<Vertx> event) {	if (event.cause() != null) {	} else if (event.succeeded()) {	vertx = event.result();	}	latch.countDown();	}	});	} else {	
creating non clustered vertx 

public void handle(AsyncResult<Vertx> event) {	if (event.cause() != null) {	} else if (event.succeeded()) {	vertx = event.result();	}	latch.countDown();	}	});	} else {	vertx = vertxFactory.vertx();	
eventbus is ready 

vertx = event.result();	}	latch.countDown();	}	});	} else {	vertx = vertxFactory.vertx();	latch.countDown();	}	if (latch.getCount() > 0) {	
waiting for eventbus to be ready using sec as timeout 

}	});	} else {	vertx = vertxFactory.vertx();	latch.countDown();	}	if (latch.getCount() > 0) {	latch.await(timeout, TimeUnit.SECONDS);	}	} else {	
using vert x instance set on the component level 

protected void doStop() throws Exception {	super.doStop();	if (createdVertx && vertx != null) {	
stopping vertx 

========================= camel sample_11521 =========================

public Exchange add(final CamelContext camelContext, final String correlationId, final Exchange exchange) {	return transactionTemplate.execute(new TransactionCallback<Exchange>() {	public Exchange doInTransaction(TransactionStatus status) {	Exchange result = null;	final String key = correlationId;	try {	
adding exchange with key 

public Exchange get(final CamelContext camelContext, final String correlationId) {	final String key = correlationId;	Exchange result = get(key, getRepositoryName(), camelContext);	
getting key 

public void remove(final CamelContext camelContext, final String correlationId, final Exchange exchange) {	transactionTemplate.execute(new TransactionCallbackWithoutResult() {	protected void doInTransactionWithoutResult(TransactionStatus status) {	final String key = correlationId;	final String confirmKey = exchange.getExchangeId();	try {	
removing key 

public void confirm(final CamelContext camelContext, final String exchangeId) {	transactionTemplate.execute(new TransactionCallbackWithoutResult() {	protected void doInTransactionWithoutResult(TransactionStatus status) {	
confirming exchangeid 

protected Set<String> getKeys(final String repositoryName) {	return transactionTemplateReadOnly.execute(new TransactionCallback<LinkedHashSet<String>>() {	public LinkedHashSet<String> doInTransaction(TransactionStatus status) {	List<String> keys = jdbcTemplate.query("SELECT " + ID + " FROM " + repositoryName, new RowMapper<String>() {	public String mapRow(ResultSet rs, int rowNum) throws SQLException {	String id = rs.getString(ID);	
getkey 

public Exchange recover(CamelContext camelContext, String exchangeId) {	final String key = exchangeId;	Exchange answer = get(key, getRepositoryNameCompleted(), camelContext);	
recovering exchangeid 

protected void doStart() throws Exception {	ObjectHelper.notNull(repositoryName, "RepositoryName");	ObjectHelper.notNull(transactionManager, "TransactionManager");	ObjectHelper.notNull(dataSource, "DataSource");	int current = getKeys().size();	int completed = scan(null).size();	if (current > 0) {	
on startup there are aggregate exchanges not completed in repository 

protected void doStart() throws Exception {	ObjectHelper.notNull(repositoryName, "RepositoryName");	ObjectHelper.notNull(transactionManager, "TransactionManager");	ObjectHelper.notNull(dataSource, "DataSource");	int current = getKeys().size();	int completed = scan(null).size();	if (current > 0) {	} else {	
on startup there are no existing aggregate exchanges not completed in repository 

protected void doStart() throws Exception {	ObjectHelper.notNull(repositoryName, "RepositoryName");	ObjectHelper.notNull(transactionManager, "TransactionManager");	ObjectHelper.notNull(dataSource, "DataSource");	int current = getKeys().size();	int completed = scan(null).size();	if (current > 0) {	} else {	}	if (completed > 0) {	
on startup there are completed exchanges to be recovered in repository 

ObjectHelper.notNull(repositoryName, "RepositoryName");	ObjectHelper.notNull(transactionManager, "TransactionManager");	ObjectHelper.notNull(dataSource, "DataSource");	int current = getKeys().size();	int completed = scan(null).size();	if (current > 0) {	} else {	}	if (completed > 0) {	} else {	
on startup there are no completed exchanges to be recovered in repository 

========================= camel sample_9010 =========================

public void testGetRecentReports() throws Exception {	final List recentReports = template().requestBody("direct:getRecentReports", null, List.class);	assertNotNull("getRecentReports", recentReports);	assertFalse("getRecentReports empty", recentReports.isEmpty());	
getrecentreports 

public void testReport(String reportName) throws Exception {	
testing report 

public void testReport(String reportName) throws Exception {	final QueryRecordsReport reports = template().requestBody("direct:queryReport", "SELECT Id FROM Report WHERE DeveloperName='" + reportName + "'", QueryRecordsReport.class);	assertNotNull("query", reports);	final List<Report> reportsRecords = reports.getRecords();	assertFalse("Report not found", reportsRecords.isEmpty());	final String testReportId = reportsRecords.get(0).getId();	assertNotNull(testReportId);	final ReportDescription reportDescription = template().requestBody("direct:getReportDescription", testReportId, ReportDescription.class);	assertNotNull("getReportDescriptions", reportDescription);	
getreportdescriptions 

assertNotNull("query", reports);	final List<Report> reportsRecords = reports.getRecords();	assertFalse("Report not found", reportsRecords.isEmpty());	final String testReportId = reportsRecords.get(0).getId();	assertNotNull(testReportId);	final ReportDescription reportDescription = template().requestBody("direct:getReportDescription", testReportId, ReportDescription.class);	assertNotNull("getReportDescriptions", reportDescription);	final ReportMetadata testReportMetadata = reportDescription.getReportMetadata();	SyncReportResults reportResults = template().requestBodyAndHeader("direct:executeSyncReport", testReportId, SalesforceEndpointConfig.INCLUDE_DETAILS, Boolean.TRUE, SyncReportResults.class);	assertNotNull("executeSyncReport", reportResults);	
executesyncreport 

headers.put(SalesforceEndpointConfig.INCLUDE_DETAILS, Boolean.FALSE);	Object body;	if (!bodyMetadata) {	headers.put(SalesforceEndpointConfig.REPORT_METADATA, testReportMetadata);	body = testReportId;	} else {	body = testReportMetadata;	}	reportResults = template().requestBodyAndHeaders("direct:executeSyncReport", body, headers, SyncReportResults.class);	assertNotNull("executeSyncReport with metadata", reportResults);	
executesyncreport with metadata 

if (!bodyMetadata) {	headers.put(SalesforceEndpointConfig.REPORT_METADATA, testReportMetadata);	body = testReportId;	} else {	body = testReportMetadata;	}	reportResults = template().requestBodyAndHeaders("direct:executeSyncReport", body, headers, SyncReportResults.class);	assertNotNull("executeSyncReport with metadata", reportResults);	ReportInstance reportInstance = template().requestBodyAndHeader("direct:executeAsyncReport", testReportId, SalesforceEndpointConfig.INCLUDE_DETAILS, true, ReportInstance.class);	assertNotNull("executeAsyncReport", reportInstance);	
executeasyncreport 

if (!bodyMetadata) {	headers.put(SalesforceEndpointConfig.REPORT_METADATA, testReportMetadata);	body = testReportId;	bodyMetadata = true;	} else {	body = testReportMetadata;	bodyMetadata = false;	}	reportInstance = template().requestBodyAndHeaders("direct:executeAsyncReport", body, headers, ReportInstance.class);	assertNotNull("executeAsyncReport with metadata", reportInstance);	
executeasyncreport with metadata 

} else {	body = testReportMetadata;	bodyMetadata = false;	}	reportInstance = template().requestBodyAndHeaders("direct:executeAsyncReport", body, headers, ReportInstance.class);	assertNotNull("executeAsyncReport with metadata", reportInstance);	final String testReportInstanceId = reportInstance.getId();	final List reportInstances = template().requestBody("direct:getReportInstances", testReportId, List.class);	assertNotNull("getReportInstances", reportInstances);	assertFalse("getReportInstances empty", reportInstances.isEmpty());	
getreportinstances 

if (!done) {	Thread.sleep(RETRY_DELAY);	if (++tries > REPORT_RESULT_RETRIES) {	final long retrySeconds = TimeUnit.SECONDS.convert(tries * RETRY_DELAY, TimeUnit.MILLISECONDS);	fail("Async report result not available in " + retrySeconds + " seconds");	}	}	}	assertNotNull("getReportResults", asyncReportResults);	assertEquals("getReportResults status", ReportStatusEnum.Success, asyncReportResults.getAttributes().getStatus());	
getreportresults 

if (++tries > REPORT_RESULT_RETRIES) {	final long retrySeconds = TimeUnit.SECONDS.convert(tries * RETRY_DELAY, TimeUnit.MILLISECONDS);	fail("Async report result not available in " + retrySeconds + " seconds");	}	}	}	assertNotNull("getReportResults", asyncReportResults);	assertEquals("getReportResults status", ReportStatusEnum.Success, asyncReportResults.getAttributes().getStatus());	String convertResults = template.requestBody("direct:convertResults", asyncReportResults, String.class);	assertNotNull("default convertResults", convertResults);	
default options 

========================= camel sample_14689 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KubernetesPersistentVolumesComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-persistent-volumes.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-persistent-volumes.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_547 =========================

protected void doStart() throws Exception {	super.doStart();	this.value = getAtomixEndpoint() .getAtomix() .getValue( resourceName, new DistributedValue.Config(getAtomixEndpoint().getConfiguration().getResourceOptions(resourceName)), new DistributedValue.Options(getAtomixEndpoint().getConfiguration().getResourceConfig(resourceName))) .join();	
subscribe to events for queue 

========================= camel sample_10330 =========================

final String[] argTypes = typeArgs.split(",");	boolean ignore = false;	final int nTypes = argTypes.length;	int i = 0;	for (String argType : argTypes) {	try {	parameterizedType.append(getCanonicalName(getProjectClassLoader().loadClass(argType)));	} catch (ClassNotFoundException e) {	try {	if (log.isDebugEnabled()) {	
could not load trying to load java lang 

int i = 0;	for (String argType : argTypes) {	try {	parameterizedType.append(getCanonicalName(getProjectClassLoader().loadClass(argType)));	} catch (ClassNotFoundException e) {	try {	if (log.isDebugEnabled()) {	}	parameterizedType.append( getCanonicalName(getProjectClassLoader().loadClass("java.lang." + argType)));	} catch (ClassNotFoundException e1) {	
ignoring type parameters for argument unable to load parametric type argument 

========================= camel sample_117 =========================

protected FtpServerFactory createFtpServerFactory() throws Exception {	try {	return doCreateFtpServerFactory();	} catch (Exception e) {	NoSuchAlgorithmException nsae = ObjectHelper.getException(NoSuchAlgorithmException.class, e);	if (nsae != null) {	String name = System.getProperty("os.name");	String message = nsae.getMessage();	
is not avail on this platform testing is skipped real cause 

========================= camel sample_15098 =========================

protected void doGetServiceAccount(Exchange exchange, String operation) throws Exception {	ServiceAccount sa = null;	String saName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SERVICE_ACCOUNT_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(saName)) {	
get a specific service account require specify a service account name 

protected void doGetServiceAccount(Exchange exchange, String operation) throws Exception {	ServiceAccount sa = null;	String saName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SERVICE_ACCOUNT_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(saName)) {	throw new IllegalArgumentException( "Get a specific Service Account require specify a Service Account name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
get a specific service account require specify a namespace name 

protected void doCreateServiceAccount(Exchange exchange, String operation) throws Exception {	ServiceAccount sa = null;	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	ServiceAccount saToCreate = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SERVICE_ACCOUNT, ServiceAccount.class);	if (ObjectHelper.isEmpty(namespaceName)) {	
create a specific service account require specify a namespace name 

protected void doCreateServiceAccount(Exchange exchange, String operation) throws Exception {	ServiceAccount sa = null;	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	ServiceAccount saToCreate = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SERVICE_ACCOUNT, ServiceAccount.class);	if (ObjectHelper.isEmpty(namespaceName)) {	throw new IllegalArgumentException( "Create a specific Service Account require specify a namespace name");	}	if (ObjectHelper.isEmpty(saToCreate)) {	
create a specific service account require specify a service account bean 

protected void doDeleteServiceAccount(Exchange exchange, String operation) throws Exception {	String saName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SERVICE_ACCOUNT_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(saName)) {	
delete a specific service account require specify a service account name 

protected void doDeleteServiceAccount(Exchange exchange, String operation) throws Exception {	String saName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SERVICE_ACCOUNT_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(saName)) {	throw new IllegalArgumentException( "Delete a specific Service Account require specify a Service Account name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
delete a specific service account require specify a namespace name 

========================= camel sample_13265 =========================

protected void doStop() throws Exception {	super.doStop();	
stopping kubernetes services consumer 

========================= camel sample_13320 =========================

Integer keyId = exchange.getIn().getHeader(DigitalOceanHeaders.ID, Integer.class);	String fingerprint = exchange.getIn().getHeader(DigitalOceanHeaders.KEY_FINGERPRINT, String.class);	Key key;	if (ObjectHelper.isNotEmpty(keyId)) {	key = getEndpoint().getDigitalOceanClient().getKeyInfo(keyId);	} else if (ObjectHelper.isNotEmpty(fingerprint)) {	key = getEndpoint().getDigitalOceanClient().getKeyInfo(fingerprint);	} else {	throw new IllegalArgumentException(DigitalOceanHeaders.ID + " or " + DigitalOceanHeaders.KEY_FINGERPRINT + " must be specified");	}	
key 

private void getKeys(Exchange exchange) throws Exception {	Keys keys = getEndpoint().getDigitalOceanClient().getAvailableKeys(configuration.getPage());	
all keys page 

Integer keyId = exchange.getIn().getHeader(DigitalOceanHeaders.ID, Integer.class);	String fingerprint = exchange.getIn().getHeader(DigitalOceanHeaders.KEY_FINGERPRINT, String.class);	Delete delete;	if (ObjectHelper.isNotEmpty(keyId)) {	delete = getEndpoint().getDigitalOceanClient().deleteKey(keyId);	} else if (ObjectHelper.isNotEmpty(fingerprint)) {	delete = getEndpoint().getDigitalOceanClient().deleteKey(fingerprint);	} else {	throw new IllegalArgumentException(DigitalOceanHeaders.ID + " or " + DigitalOceanHeaders.KEY_FINGERPRINT + " must be specified");	}	
delete key 

} else {	key.setName(name);	}	String publicKey = exchange.getIn().getHeader(DigitalOceanHeaders.KEY_PUBLIC_KEY, String.class);	if (ObjectHelper.isEmpty(publicKey)) {	throw new IllegalArgumentException(DigitalOceanHeaders.KEY_PUBLIC_KEY + " must be specified");	} else {	key.setPublicKey(publicKey);	}	key = getEndpoint().getDigitalOceanClient().createKey(key);	
key created 

if (ObjectHelper.isEmpty(name)) {	throw new IllegalArgumentException(DigitalOceanHeaders.NAME + " must be specified");	}	if (ObjectHelper.isNotEmpty(keyId)) {	key = getEndpoint().getDigitalOceanClient().updateKey(keyId, name);	} else if (ObjectHelper.isNotEmpty(fingerprint)) {	key = getEndpoint().getDigitalOceanClient().updateKey(fingerprint, name);	} else {	throw new IllegalArgumentException(DigitalOceanHeaders.ID + " or " + DigitalOceanHeaders.KEY_FINGERPRINT + " must be specified");	}	
update key 

========================= camel sample_8894 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<FileLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.file.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.file.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_906 =========================

public PullRequestStateProducer(GitHubEndpoint endpoint) throws Exception {	super(endpoint);	Registry registry = endpoint.getCamelContext().getRegistry();	Object service = registry.lookupByName(GitHubConstants.GITHUB_COMMIT_SERVICE);	if (service != null) {	
using commitservice found in registry 

========================= camel sample_14261 =========================

public void testRead() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	final Edm metadata = (Edm)requestBodyAndHeaders("direct: assertNotNull(metadata);	assertEquals(1, metadata.getSchemas().size());	final ClientServiceDocument document = (ClientServiceDocument)requestBodyAndHeaders("direct: assertNotNull(document);	assertTrue(document.getEntitySets().size() > 1);	
service document has entity sets 

public void testCreateUpdateDelete() throws Exception {	final ClientEntity clientEntity = createEntity();	ClientEntity entity = requestBody("direct: assertNotNull(entity);	assertEquals("Lewis", entity.getProperty("FirstName").getValue().toString());	assertEquals("", entity.getProperty("MiddleName").getValue().toString());	clientEntity.getProperties().add(objFactory.newPrimitiveProperty("MiddleName", objFactory.newPrimitiveValueBuilder().buildString("Lewis")));	HttpStatusCode status = requestBody("direct: assertNotNull("Update status", status);	assertEquals("Update status", HttpStatusCode.NO_CONTENT.getStatusCode(), status.getStatusCode());	
update entity status 

public void testCreateUpdateDelete() throws Exception {	final ClientEntity clientEntity = createEntity();	ClientEntity entity = requestBody("direct: assertNotNull(entity);	assertEquals("Lewis", entity.getProperty("FirstName").getValue().toString());	assertEquals("", entity.getProperty("MiddleName").getValue().toString());	clientEntity.getProperties().add(objFactory.newPrimitiveProperty("MiddleName", objFactory.newPrimitiveValueBuilder().buildString("Lewis")));	HttpStatusCode status = requestBody("direct: assertNotNull("Update status", status);	assertEquals("Update status", HttpStatusCode.NO_CONTENT.getStatusCode(), status.getStatusCode());	status = requestBody("direct: assertNotNull("Delete status", status);	assertEquals("Delete status", HttpStatusCode.NO_CONTENT.getStatusCode(), status.getStatusCode());	
delete status 

public void testCreateUpdateDeleteFromJson() throws Exception {	ClientEntity entity = requestBody("direct: assertNotNull(entity);	assertEquals("Lewis", entity.getProperty("FirstName").getValue().toString());	assertEquals("Black", entity.getProperty("LastName").getValue().toString());	assertEquals("lewisblack", entity.getProperty("UserName").getValue().toString());	assertEquals("", entity.getProperty("MiddleName").getValue().toString());	HttpStatusCode status = requestBody("direct: assertNotNull("Update status", status);	assertEquals("Update status", HttpStatusCode.NO_CONTENT.getStatusCode(), status.getStatusCode());	
update entity status 

public void testCreateUpdateDeleteFromJson() throws Exception {	ClientEntity entity = requestBody("direct: assertNotNull(entity);	assertEquals("Lewis", entity.getProperty("FirstName").getValue().toString());	assertEquals("Black", entity.getProperty("LastName").getValue().toString());	assertEquals("lewisblack", entity.getProperty("UserName").getValue().toString());	assertEquals("", entity.getProperty("MiddleName").getValue().toString());	HttpStatusCode status = requestBody("direct: assertNotNull("Update status", status);	assertEquals("Update status", HttpStatusCode.NO_CONTENT.getStatusCode(), status.getStatusCode());	status = requestBody("direct: assertNotNull("Delete status", status);	assertEquals("Delete status", HttpStatusCode.NO_CONTENT.getStatusCode(), status.getStatusCode());	
delete status 

ClientEntity clientEntity = createEntity();	batchParts.add(Olingo4BatchChangeRequest.resourcePath(PEOPLE).resourceUri(TEST_SERVICE_BASE_URL).contentId(TEST_CREATE_RESOURCE_CONTENT_ID).operation(Operation.CREATE) .body(clientEntity).build());	clientEntity.getProperties().add(objFactory.newPrimitiveProperty("MiddleName", objFactory.newPrimitiveValueBuilder().buildString("Lewis")));	batchParts.add(Olingo4BatchChangeRequest.resourcePath(TEST_CREATE_PEOPLE).resourceUri(TEST_SERVICE_BASE_URL).contentId(TEST_UPDATE_RESOURCE_CONTENT_ID) .operation(Operation.UPDATE).body(clientEntity).build());	batchParts.add(Olingo4BatchChangeRequest.resourcePath(TEST_CREATE_PEOPLE).resourceUri(TEST_SERVICE_BASE_URL).operation(Operation.DELETE).build());	batchParts.add(Olingo4BatchQueryRequest.resourcePath(TEST_CREATE_PEOPLE).resourceUri(TEST_SERVICE_BASE_URL).build());	final List<Olingo4BatchResponse> responseParts = requestBody("direct: assertNotNull("Batch response", responseParts);	assertEquals("Batch responses expected", 8, responseParts.size());	final Edm edm = (Edm)responseParts.get(0).getBody();	assertNotNull(edm);	
edm entity sets 

clientEntity.getProperties().add(objFactory.newPrimitiveProperty("MiddleName", objFactory.newPrimitiveValueBuilder().buildString("Lewis")));	batchParts.add(Olingo4BatchChangeRequest.resourcePath(TEST_CREATE_PEOPLE).resourceUri(TEST_SERVICE_BASE_URL).contentId(TEST_UPDATE_RESOURCE_CONTENT_ID) .operation(Operation.UPDATE).body(clientEntity).build());	batchParts.add(Olingo4BatchChangeRequest.resourcePath(TEST_CREATE_PEOPLE).resourceUri(TEST_SERVICE_BASE_URL).operation(Operation.DELETE).build());	batchParts.add(Olingo4BatchQueryRequest.resourcePath(TEST_CREATE_PEOPLE).resourceUri(TEST_SERVICE_BASE_URL).build());	final List<Olingo4BatchResponse> responseParts = requestBody("direct: assertNotNull("Batch response", responseParts);	assertEquals("Batch responses expected", 8, responseParts.size());	final Edm edm = (Edm)responseParts.get(0).getBody();	assertNotNull(edm);	ClientEntitySet entitySet = (ClientEntitySet)responseParts.get(1).getBody();	assertNotNull(entitySet);	
read entities 

batchParts.add(Olingo4BatchChangeRequest.resourcePath(TEST_CREATE_PEOPLE).resourceUri(TEST_SERVICE_BASE_URL).operation(Operation.DELETE).build());	batchParts.add(Olingo4BatchQueryRequest.resourcePath(TEST_CREATE_PEOPLE).resourceUri(TEST_SERVICE_BASE_URL).build());	final List<Olingo4BatchResponse> responseParts = requestBody("direct: assertNotNull("Batch response", responseParts);	assertEquals("Batch responses expected", 8, responseParts.size());	final Edm edm = (Edm)responseParts.get(0).getBody();	assertNotNull(edm);	ClientEntitySet entitySet = (ClientEntitySet)responseParts.get(1).getBody();	assertNotNull(entitySet);	clientEntity = (ClientEntity)responseParts.get(2).getBody();	assertNotNull(clientEntity);	
read entiry properties 

ClientEntitySet entitySet = (ClientEntitySet)responseParts.get(1).getBody();	assertNotNull(entitySet);	clientEntity = (ClientEntity)responseParts.get(2).getBody();	assertNotNull(clientEntity);	ClientEntitySet entitySetWithTop = (ClientEntitySet)responseParts.get(3).getBody();	assertNotNull(entitySetWithTop);	assertEquals(5, entitySetWithTop.getEntities().size());	LOG.info("Read entities with $top=5: {}", entitySet.getEntities());	clientEntity = (ClientEntity)responseParts.get(4).getBody();	assertNotNull(clientEntity);	
created entity 

clientEntity = (ClientEntity)responseParts.get(2).getBody();	assertNotNull(clientEntity);	ClientEntitySet entitySetWithTop = (ClientEntitySet)responseParts.get(3).getBody();	assertNotNull(entitySetWithTop);	assertEquals(5, entitySetWithTop.getEntities().size());	LOG.info("Read entities with $top=5: {}", entitySet.getEntities());	clientEntity = (ClientEntity)responseParts.get(4).getBody();	assertNotNull(clientEntity);	int statusCode = responseParts.get(5).getStatusCode();	assertEquals(HttpStatusCode.NO_CONTENT.getStatusCode(), statusCode);	
update mdiddlename status 

ClientEntitySet entitySetWithTop = (ClientEntitySet)responseParts.get(3).getBody();	assertNotNull(entitySetWithTop);	assertEquals(5, entitySetWithTop.getEntities().size());	LOG.info("Read entities with $top=5: {}", entitySet.getEntities());	clientEntity = (ClientEntity)responseParts.get(4).getBody();	assertNotNull(clientEntity);	int statusCode = responseParts.get(5).getStatusCode();	assertEquals(HttpStatusCode.NO_CONTENT.getStatusCode(), statusCode);	statusCode = responseParts.get(6).getStatusCode();	assertEquals(HttpStatusCode.NO_CONTENT.getStatusCode(), statusCode);	
delete entity status 

LOG.info("Read entities with $top=5: {}", entitySet.getEntities());	clientEntity = (ClientEntity)responseParts.get(4).getBody();	assertNotNull(clientEntity);	int statusCode = responseParts.get(5).getStatusCode();	assertEquals(HttpStatusCode.NO_CONTENT.getStatusCode(), statusCode);	statusCode = responseParts.get(6).getStatusCode();	assertEquals(HttpStatusCode.NO_CONTENT.getStatusCode(), statusCode);	assertEquals(HttpStatusCode.NOT_FOUND.getStatusCode(), responseParts.get(7).getStatusCode());	final ODataError error = (ODataError)responseParts.get(7).getBody();	assertNotNull(error);	
read deleted entity error 

========================= camel sample_15470 =========================

private void verifyTheRecivedEmail(String expectString) throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.assertIsSatisfied();	Exchange out = mock.assertExchangeReceived(0);	ByteArrayOutputStream baos = new ByteArrayOutputStream(((MailMessage)out.getIn()).getMessage().getSize());	((MailMessage)out.getIn()).getMessage().writeTo(baos);	String dumpedMessage = baos.toString();	assertTrue("There should have the " + expectString, dumpedMessage.indexOf(expectString) > 0);	
multipart alternative 

========================= camel sample_11825 =========================

xmlReader = sfactory.newSAXParser().getXMLReader();	}	}	if (xmlReader == null) {	if (xmlReaderPool == null) {	xmlReaderPool = new XMLReaderPool(createSAXParserFactory());	}	xmlReader = xmlReaderPool.createXMLReader();	}	} catch (Exception ex) {	
cannot create the saxparser xmlreader due to 

List<String> features = new ArrayList<String>();	for (Map.Entry<Object, Object> prop : properties.entrySet()) {	String key = (String) prop.getKey();	if (key.startsWith(XmlConverter.DOCUMENT_BUILDER_FACTORY_FEATURE)) {	String uri = ObjectHelper.after(key, ":");	Boolean value = Boolean.valueOf((String)prop.getValue());	try {	factory.setFeature(uri, value);	features.add("feature " + uri + " value " + value);	} catch (ParserConfigurationException e) {	
documentbuilderfactory doesn t support the feature with value due to 

}	}	if (features.size() > 0) {	StringBuilder featureString = new StringBuilder();	for (String feature : features) {	if (featureString.length() != 0) {	featureString.append(", ");	}	featureString.append(feature);	}	
documentbuilderfactory has been set with features 

========================= camel sample_4225 =========================

} else {	reply = outputChannel;	if (reply == null) {	throw new IllegalArgumentException("OutputChannel has not been configured on " + getEndpoint());	}	}	if (reply == null) {	throw new IllegalArgumentException("Cannot resolve ReplyChannel from message: " + siInMessage);	}	org.springframework.messaging.Message<?> siOutMessage = SpringIntegrationBinding.storeToSpringIntegrationMessage(exchange.getOut());	
sending to replychannel 

========================= camel sample_11126 =========================

if (userMap != null) {	tokenPolicies.add(OpcUaServerConfig.USER_TOKEN_POLICY_USERNAME);	}	this.serverConfig.setUserTokenPolicies(tokenPolicies);	}	if (this.bindAddresses != null) {	this.serverConfig.setBindAddresses(new ArrayList<>(this.bindAddresses));	}	if (this.certificateValidator != null) {	final CertificateValidator validator = this.certificateValidator.get();	
using validator 

this.serverConfig.setUserTokenPolicies(tokenPolicies);	}	if (this.bindAddresses != null) {	this.serverConfig.setBindAddresses(new ArrayList<>(this.bindAddresses));	}	if (this.certificateValidator != null) {	final CertificateValidator validator = this.certificateValidator.get();	if (validator instanceof Closeable) {	runOnStop(() -> {	try {	
closing 

if (this.bindAddresses != null) {	this.serverConfig.setBindAddresses(new ArrayList<>(this.bindAddresses));	}	if (this.certificateValidator != null) {	final CertificateValidator validator = this.certificateValidator.get();	if (validator instanceof Closeable) {	runOnStop(() -> {	try {	((Closeable)validator).close();	} catch (final IOException e) {	
failed to close 

protected void doStop() throws Exception {	this.server.shutdown();	super.doStop();	this.runOnStop.forEach(runnable -> {	try {	runnable.run();	} catch (final Exception e) {	
failed to run on stop 

========================= camel sample_17271 =========================

public static void assertInMessageBodyEquals(Exchange exchange, Object expected) throws InvalidPayloadException {	assertNotNull("Should have a response exchange!", exchange);	Object actual;	if (expected == null) {	actual = exchange.getIn().getMandatoryBody();	assertEquals("in body of: " + exchange, expected, actual);	} else {	actual = exchange.getIn().getMandatoryBody(expected.getClass());	}	assertEquals("in body of: " + exchange, expected, actual);	
received response with in 

public static void assertOutMessageBodyEquals(Exchange exchange, Object expected) throws InvalidPayloadException {	assertNotNull("Should have a response exchange!", exchange);	Object actual;	if (expected == null) {	actual = exchange.getOut().getMandatoryBody();	assertEquals("output body of: " + exchange, expected, actual);	} else {	actual = exchange.getOut().getMandatoryBody(expected.getClass());	}	assertEquals("output body of: " + exchange, expected, actual);	
received response with out 

public static Object assertExpression(Expression expression, Exchange exchange, Object expected) {	Object value;	if (expected != null) {	value = expression.evaluate(exchange, expected.getClass());	} else {	value = expression.evaluate(exchange, Object.class);	}	
evaluated expression on exchange result 

public static void assertPredicateDoesNotMatch(Predicate predicate, Exchange exchange) {	try {	PredicateAssertHelper.assertMatches(predicate, "Predicate should match: ", exchange);	} catch (AssertionError e) {	
caught expected assertion error 

public static boolean assertPredicate(final Predicate predicate, Exchange exchange, boolean expected) {	if (expected) {	PredicateAssertHelper.assertMatches(predicate, "Predicate failed: ", exchange);	}	boolean value = predicate.matches(exchange);	
evaluated predicate on exchange result 

return;	}	if (file.isDirectory()) {	File[] files = file.listFiles();	for (File child : files) {	recursivelyDeleteDirectory(child);	}	}	boolean success = file.delete();	if (!success) {	
deletion of file failed 

========================= camel sample_6832 =========================

public Object extractBodyFromJms(Exchange exchange, Message message) {	try {	if (LOG.isTraceEnabled()) {	
extracting body using a custom messageconverter from jms message 

public Object extractBodyFromJms(Exchange exchange, Message message) {	try {	if (LOG.isTraceEnabled()) {	}	return endpoint.getMessageConverter().fromMessage(message);	}	if (!mapJmsMessage) {	
option map jms message is false so using jms message as body 

public Object extractBodyFromJms(Exchange exchange, Message message) {	try {	if (LOG.isTraceEnabled()) {	}	return endpoint.getMessageConverter().fromMessage(message);	}	if (!mapJmsMessage) {	return message;	}	if (message instanceof ObjectMessage) {	
extracting body as a objectmessage from jms message 

ObjectMessage objectMessage = (ObjectMessage)message;	Object payload = objectMessage.getObject();	if (payload instanceof DefaultExchangeHolder) {	DefaultExchangeHolder holder = (DefaultExchangeHolder) payload;	DefaultExchangeHolder.unmarshal(exchange, holder);	return exchange.getIn().getBody();	} else {	return objectMessage.getObject();	}	} else if (message instanceof TextMessage) {	
extracting body as a textmessage from jms message 

DefaultExchangeHolder holder = (DefaultExchangeHolder) payload;	DefaultExchangeHolder.unmarshal(exchange, holder);	return exchange.getIn().getBody();	} else {	return objectMessage.getObject();	}	} else if (message instanceof TextMessage) {	TextMessage textMessage = (TextMessage)message;	return textMessage.getText();	} else if (message instanceof MapMessage) {	
extracting body as a mapmessage from jms message 

return exchange.getIn().getBody();	} else {	return objectMessage.getObject();	}	} else if (message instanceof TextMessage) {	TextMessage textMessage = (TextMessage)message;	return textMessage.getText();	} else if (message instanceof MapMessage) {	return createMapFromMapMessage((MapMessage)message);	} else if (message instanceof BytesMessage) {	
extracting body as a bytesmessage from jms message 

return objectMessage.getObject();	}	} else if (message instanceof TextMessage) {	TextMessage textMessage = (TextMessage)message;	return textMessage.getText();	} else if (message instanceof MapMessage) {	return createMapFromMapMessage((MapMessage)message);	} else if (message instanceof BytesMessage) {	return createByteArrayFromBytesMessage((BytesMessage)message);	} else if (message instanceof StreamMessage) {	
extracting body as a streammessage from jms message 

protected byte[] createByteArrayFromBytesMessage(BytesMessage message) throws JMSException {	if (message.getBodyLength() > Integer.MAX_VALUE) {	
length of bytesmessage is too long 

answer = answer instanceof ObjectMessage ? answer : null;	} else if (type == JmsMessageType.Stream) {	answer = answer instanceof StreamMessage ? answer : null;	}	}	}	}	}	if (answer == null) {	if (cause != null) {	
will create jmsmessage with caused exception 

JmsMessageHelper.setJMSReplyTo(jmsMessage, replyTo);	} else if (headerName.equals("JMSType")) {	jmsMessage.setJMSType(ExchangeHelper.convertToType(exchange, String.class, headerValue));	} else if (headerName.equals("JMSPriority")) {	jmsMessage.setJMSPriority(ExchangeHelper.convertToType(exchange, Integer.class, headerValue));	} else if (headerName.equals("JMSDeliveryMode")) {	JmsMessageHelper.setJMSDeliveryMode(exchange, jmsMessage, headerValue);	} else if (headerName.equals("JMSExpiration")) {	jmsMessage.setJMSExpiration(ExchangeHelper.convertToType(exchange, Long.class, headerValue));	} else {	
ignoring jms header with value 

} else if (headerName.equals("JMSExpiration")) {	jmsMessage.setJMSExpiration(ExchangeHelper.convertToType(exchange, Long.class, headerValue));	} else {	}	} else if (shouldOutputHeader(headerName, headerValue, exchange)) {	Object value = getValidJMSHeaderValue(headerName, headerValue);	if (value != null) {	String key = jmsJmsKeyFormatStrategy.encodeKey(headerName);	JmsMessageHelper.setProperty(jmsMessage, key, value);	} else if (LOG.isDebugEnabled()) {	
ignoring non primitive header of class with value 

protected Message createJmsMessage(Exception cause, Session session) throws JMSException {	
using jmsmessagetype 

JmsMessageType type = null;	if (endpoint != null && endpoint.isTransferExchange()) {	LOG.trace("Option transferExchange=true so we use JmsMessageType: Object");	Serializable holder = DefaultExchangeHolder.marshal(exchange);	Message answer = session.createObjectMessage(holder);	answer.setJMSDeliveryMode(Message.DEFAULT_DELIVERY_MODE);	return answer;	}	if (endpoint != null && endpoint.getMessageConverter() != null) {	if (LOG.isTraceEnabled()) {	
creating jmsmessage using a custom messageconverter with body 

if (headers.containsKey(JmsConstants.JMS_MESSAGE_TYPE)) {	type = context.getTypeConverter().convertTo(JmsMessageType.class, headers.get(JmsConstants.JMS_MESSAGE_TYPE));	} else if (endpoint != null && endpoint.getConfiguration().getJmsMessageType() != null) {	type = endpoint.getConfiguration().getJmsMessageType();	} else {	type = getJMSMessageTypeForBody(exchange, body, headers, session, context);	if (type != null) {	if (body == null && !allowNullBody) {	throw new JMSException("Cannot send message as message body is null, and option allowNullBody is false.");	}	
using jmsmessagetype 

throw new JMSException("Cannot send message as message body is null, and option allowNullBody is false.");	}	Message answer = createJmsMessageForType(exchange, body, headers, session, context, type);	answer.setJMSDeliveryMode(Message.DEFAULT_DELIVERY_MODE);	return answer;	}	if (body == null && !allowNullBody) {	throw new JMSException("Cannot send message as message body is null, and option allowNullBody is false.");	}	if (body != null && LOG.isWarnEnabled()) {	
cannot determine specific jmsmessage type to use from body class will use generic jmsmessage body class if you want to send a pojo then your class might need to implement java io serializable or you can force a specific type by setting the jmsmessagetype option on the jms endpoint 

========================= camel sample_12423 =========================

public Object postProcessBeforeInitialization(Object bean, String beanName) throws Exception {	
camel bean processing before initialization for bean 

public Object postProcessBeforeInitialization(Object bean, String beanName) throws Exception {	if (!canPostProcessBean(bean, beanName)) {	return bean;	}	injectFields(bean, beanName);	injectMethods(bean, beanName);	if (bean instanceof CamelContextAware && canSetCamelContext(bean, beanName)) {	CamelContextAware contextAware = (CamelContextAware)bean;	CamelContext context = getOrLookupCamelContext();	if (context == null) {	
no camelcontext defined yet so cannot inject into bean 

public Object postProcessAfterInitialization(Object bean, String beanName) throws Exception {	
camel bean processing after initialization for bean 

protected boolean canSetCamelContext(Object bean, String beanName) {	if (bean instanceof CamelContextAware) {	CamelContextAware camelContextAware = (CamelContextAware) bean;	CamelContext context = camelContextAware.getCamelContext();	if (context != null) {	
camelcontext already set on bean with id will keep existing camelcontext on bean 

public void setterInjection(Method method, Object bean, String beanName, String endpointUri, String endpointRef, String endpointProperty) {	Class<?>[] parameterTypes = method.getParameterTypes();	if (parameterTypes != null) {	if (parameterTypes.length != 1) {	
ignoring badly annotated method for injection due to incorrect number of parameters 

public void setterPropertyInjection(Method method, String propertyValue, String propertyDefaultValue, Object bean, String beanName) {	Class<?>[] parameterTypes = method.getParameterTypes();	if (parameterTypes != null) {	if (parameterTypes.length != 1) {	
ignoring badly annotated method for injection due to incorrect number of parameters 

public void setterBeanInjection(Method method, String name, Object bean, String beanName) {	Class<?>[] parameterTypes = method.getParameterTypes();	if (parameterTypes != null) {	if (parameterTypes.length != 1) {	
ignoring badly annotated method for injection due to incorrect number of parameters 

========================= camel sample_4049 =========================

if (config.getApiContextPath() != null) {	boolean hasRestApi = false;	for (RouteDefinition route : camelContext.getRouteDefinitions()) {	FromDefinition from = route.getInputs().get(0);	if (from.getUri() != null && from.getUri().startsWith("rest-api:")) {	hasRestApi = true;	}	}	if (!hasRestApi) {	RouteDefinition route = RestDefinition.asRouteApiDefinition(camelContext, config);	
adding routeid as rest api route 

========================= camel sample_5658 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<IrcComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.irc.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.irc.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_443 =========================

public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {	for (Callback callback : callbacks) {	
callback 

public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {	for (Callback callback : callbacks) {	if (callback instanceof PasswordCallback) {	PasswordCallback pc = (PasswordCallback) callback;	
setting password on callback 

public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {	for (Callback callback : callbacks) {	if (callback instanceof PasswordCallback) {	PasswordCallback pc = (PasswordCallback) callback;	pc.setPassword(principal.getPassword().toCharArray());	} else if (callback instanceof NameCallback) {	NameCallback nc = (NameCallback) callback;	
setting username on callback 

========================= camel sample_8355 =========================

DefaultCamelContext context = new DefaultCamelContext();	final CountDownLatch logoutLatch = new CountDownLatch(1);	RouteBuilder routes = new RouteBuilder() {	public void configure() throws Exception {	from("quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:TRADER->MARKET"). filter(PredicateBuilder.and( header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.AdminMessageSent), header(QuickfixjEndpoint.MESSAGE_TYPE_KEY).isEqualTo(MsgType.LOGON))). bean(new CredentialInjector("PASSWORD"));	from("quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:TRADER->MARKET"). filter(header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.SessionLogoff)). bean(new CountDownLatchDecrementer("logout", logoutLatch));	from("quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:MARKET->TRADER"). filter(PredicateBuilder.and( header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.AdminMessageReceived), header(QuickfixjEndpoint.MESSAGE_TYPE_KEY).isEqualTo(MsgType.LOGON))). bean(new LogonAuthenticator());	}	};	context.addRoutes(routes);	
starting camel context 

from("quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:TRADER->MARKET"). filter(header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.SessionLogoff)). bean(new CountDownLatchDecrementer("logout", logoutLatch));	from("quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:MARKET->TRADER"). filter(PredicateBuilder.and( header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.AdminMessageReceived), header(QuickfixjEndpoint.MESSAGE_TYPE_KEY).isEqualTo(MsgType.LOGON))). bean(new LogonAuthenticator());	}	};	context.addRoutes(routes);	context.start();	if (!logoutLatch.await(5L, TimeUnit.SECONDS)) {	throw new IllegalStateException("Logout was not received");	}	context.stop();	
example complete 

public void inject(Exchange exchange) throws CamelExchangeException {	
injecting password into outgoing logon message 

========================= camel sample_10664 =========================

public OperationResult<Boolean> getResult() {	try {	connection.delete(node, version);	if (LOG.isDebugEnabled()) {	if (LOG.isTraceEnabled()) {	
set data of node s 

public OperationResult<Boolean> getResult() {	try {	connection.delete(node, version);	if (LOG.isDebugEnabled()) {	if (LOG.isTraceEnabled()) {	} else {	
set data of node s 

========================= camel sample_12659 =========================

public void process(Exchange exchange) throws Exception {	Exchange result;	if ((((RouteboxDirectEndpoint)getRouteboxEndpoint()).getConsumer() == null) && (getRouteboxEndpoint().getConfig().isSendToConsumer())) {	throw new CamelExchangeException("No consumers available on endpoint: " + getRouteboxEndpoint(), exchange);	} else {	
dispatching to inner route 

public boolean process(Exchange exchange, final AsyncCallback callback) {	boolean flag = true;	if ((((RouteboxDirectEndpoint)getRouteboxEndpoint()).getConsumer() == null) && ((getRouteboxEndpoint()).getConfig().isSendToConsumer())) {	exchange.setException(new CamelExchangeException("No consumers available on endpoint: " + getRouteboxEndpoint(), exchange));	callback.done(true);	flag = true;	} else {	try {	
dispatching to inner route 

========================= camel sample_14627 =========================

private void safeCloseResultSet() {	try {	resultSet.close();	} catch (SQLException e) {	
error by closing result set 

private void safeCloseStatement() {	try {	statement.close();	} catch (SQLException e) {	
error by closing statement 

private void safeCloseConnection() {	try {	connection.close();	} catch (SQLException e) {	
error by closing connection 

========================= camel sample_9051 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<BeanComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.bean.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.bean.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_855 =========================

private void commitOutputMessage() throws IOException {	ExchangePattern pattern;	if (isOneWay) {	pattern = ExchangePattern.InOnly;	} else {	pattern = ExchangePattern.InOut;	}	
send the message to endpoint 

if (isOneWay) {	pattern = ExchangePattern.InOnly;	} else {	pattern = ExchangePattern.InOut;	}	final org.apache.camel.Exchange exchange = this.producer.createExchange(pattern);	exchange.setProperty(Exchange.TO_ENDPOINT, this.targetCamelEndpointUri);	CachedOutputStream outputStream = (CachedOutputStream) outMessage.getContent(OutputStream.class);	CxfHeaderHelper.propagateCxfToCamel(this.headerFilterStrategy, outMessage, exchange.getIn(), exchange);	exchange.getIn().setBody(outputStream.getInputStream());	
template sending request 

} else {	WorkQueueManager mgr = outMessage.getExchange().get(Bus.class) .getExtension(WorkQueueManager.class);	AutomaticWorkQueue qu = mgr.getNamedWorkQueue("camel-cxf-conduit");	if (qu == null) {	qu = mgr.getAutomaticWorkQueue();	}	qu.execute(runnable);	}	} catch (RejectedExecutionException rex) {	if (!hasLoggedAsyncWarning) {	
executor rejected background task to retrieve the response suggest increasing the workqueue settings 

AutomaticWorkQueue qu = mgr.getNamedWorkQueue("camel-cxf-conduit");	if (qu == null) {	qu = mgr.getAutomaticWorkQueue();	}	qu.execute(runnable);	}	} catch (RejectedExecutionException rex) {	if (!hasLoggedAsyncWarning) {	hasLoggedAsyncWarning = true;	}	
executor rejected background task to retrieve the response running on current thread 

========================= camel sample_6577 =========================

public void process(Exchange exchange) throws Exception {	String command = ExchangeHelper.getMandatoryHeader(exchange, NetWeaverConstants.COMMAND, String.class);	Exchange httpExchange = getEndpoint().createExchange();	httpExchange.getIn().setHeader(Exchange.HTTP_PATH, command);	if (getEndpoint().isJson()) {	httpExchange.getIn().setHeader("Accept", "application/json");	}	
calling sap net weaver with command 

protected void doStart() throws Exception {	String url = getEndpoint().getUrl() + "?authUsername=" + getEndpoint().getUsername() + "&authPassword=" + getEndpoint().getPassword() + "&authMethod=Basic";	if (log.isInfoEnabled()) {	
creating netweaverproducer using url 

========================= camel sample_16860 =========================

public static void main(String[] args) throws Exception {	
about to run splunk camel integration 

========================= camel sample_17772 =========================

account.setFirstName("James");	account.setLastName("Strachan");	account.setEmailAddress("TryGuessing@gmail.com");	template.sendBody("direct:start", account);	assertMockEndpointsSatisfied();	List<?> body = template.requestBody("ibatis:selectAllAccounts?statementType=QueryForList", null, List.class);	assertEquals("Wrong size: " + body, 1, body.size());	Account actual = assertIsInstanceOf(Account.class, body.get(0));	assertEquals("Account.getFirstName()", "James", actual.getFirstName());	assertEquals("Account.getLastName()", "Strachan", actual.getLastName());	
found 

========================= camel sample_17288 =========================

public void start(BundleContext bundleContext) throws Exception {	try {	this.bundleContext = bundleContext;	
initializing bundle 

Configuration camelKuraConfig = configurationAdmin.getConfiguration(camelXmlRoutesPid());	if (camelKuraConfig != null && camelKuraConfig.getProperties() != null) {	Object routePropertyValue = camelKuraConfig.getProperties().get(camelXmlRoutesProperty());	if (routePropertyValue != null) {	InputStream routesXml = new ByteArrayInputStream(routePropertyValue.toString().getBytes());	RoutesDefinition loadedRoutes = camelContext.loadRoutesDefinition(routesXml);	camelContext.addRouteDefinitions(loadedRoutes.getRoutes());	}	}	beforeStart(camelContext);	
about to start camel kura router 

if (routePropertyValue != null) {	InputStream routesXml = new ByteArrayInputStream(routePropertyValue.toString().getBytes());	RoutesDefinition loadedRoutes = camelContext.loadRoutesDefinition(routesXml);	camelContext.addRouteDefinitions(loadedRoutes.getRoutes());	}	}	beforeStart(camelContext);	camelContext.start();	producerTemplate = camelContext.createProducerTemplate();	consumerTemplate = camelContext.createConsumerTemplate();	
bundle started 

public void stop(BundleContext bundleContext) throws Exception {	
stopping bundle 

public void stop(BundleContext bundleContext) throws Exception {	camelContext.stop();	
bundle stopped 

public void configure() throws Exception {	
no programmatic routes configuration found 

protected void beforeStart(CamelContext camelContext) {	
empty kurarouter camelcontext before start configuration skipping 

========================= camel sample_12989 =========================

public void testSendingToProcessorEndpoint() throws Exception {	ProcessorStub processor = getMandatoryBean(ProcessorStub.class, "myProcessor");	template.sendBody("myProcessor", body);	List<Exchange> list = processor.getExchanges();	assertEquals("Received exchange list: " + list, 1, list.size());	
found exchanges 

public void testSendingToNonExistentEndpoint() throws Exception {	String uri = "unknownEndpoint";	Endpoint endpoint = context.getEndpoint(uri);	assertNull("Should not have found an endpoint! Was: " + endpoint, endpoint);	try {	template.sendBody(uri, body);	fail("We should have failed as this is a bad endpoint URI");	} catch (NoSuchEndpointException e) {	
caught expected exception 

========================= camel sample_16163 =========================

if (endpoint.isBridgeEndpoint()) {	exchange.setProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.TRUE);	exchange.getIn().getHeaders().remove("host");	}	RequestBuilder builder = new RequestBuilder();	URI uri;	try {	String url = AhcHelper.createURL(exchange, endpoint);	uri = AhcHelper.createURI(exchange, url, endpoint);	url = uri.toASCIIString();	
setting url 

URI uri;	try {	String url = AhcHelper.createURL(exchange, endpoint);	uri = AhcHelper.createURI(exchange, url, endpoint);	url = uri.toASCIIString();	builder.setUrl(url);	} catch (Exception e) {	throw new CamelExchangeException("Error creating URL", exchange, e);	}	String method = extractMethod(exchange);	
setting method 

body = new InputStreamBodyGenerator(is);	}	}	} catch (UnsupportedEncodingException e) {	throw new CamelExchangeException("Error creating BodyGenerator from message body", exchange, e);	} catch (IOException e) {	throw new CamelExchangeException("Error serializing message body", exchange, e);	}	}	if (body != null) {	
setting body 

} catch (UnsupportedEncodingException e) {	throw new CamelExchangeException("Error creating BodyGenerator from message body", exchange, e);	} catch (IOException e) {	throw new CamelExchangeException("Error serializing message body", exchange, e);	}	}	if (body != null) {	builder.setBody(body);	}	if (charset != null) {	
setting body charset 

} catch (IOException e) {	throw new CamelExchangeException("Error serializing message body", exchange, e);	}	}	if (body != null) {	builder.setBody(body);	}	if (charset != null) {	builder.setCharset(Charset.forName(charset));	}	
setting content type 

========================= camel sample_16499 =========================

public void testXslt() throws InterruptedException {	template.setDefaultEndpointUri("direct:xslt");	execute(1000);	resetMock(count);	StopWatch watch = new StopWatch();	execute(count);	assertMockEndpointsSatisfied();	
ran tests in ms 

========================= camel sample_6432 =========================

private DirectConsumer awaitConsumer() throws InterruptedException {	DirectConsumer answer = null;	StopWatch watch = new StopWatch();	boolean done = false;	while (!done) {	Thread.sleep(500);	if (LOG.isDebugEnabled()) {	
waited for consumer to be ready 

========================= camel sample_4771 =========================

}	if (close == null) {	close = exchange.getProperty(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);	}	boolean disconnect = consumer.getConfiguration().isDisconnect();	if (close != null) {	disconnect = close;	}	if (disconnect) {	if (LOG.isTraceEnabled()) {	
closing channel when complete at address 

========================= camel sample_10263 =========================

public void execute() {	BatchDeleteAttributesRequest request = new BatchDeleteAttributesRequest() .withDomainName(determineDomainName()) .withItems(determineDeletableItems());	
sending request for exchange 

public void execute() {	BatchDeleteAttributesRequest request = new BatchDeleteAttributesRequest() .withDomainName(determineDomainName()) .withItems(determineDeletableItems());	this.sdbClient.batchDeleteAttributes(request);	
request sent 

========================= camel sample_8752 =========================

String projectId = properties.getProperty("pubsub.projectId");	String topic = properties.getProperty("pubsub.topic");	String subscriptionName = properties.getProperty("pubsub.subscription");	String topicFullName = String.format("projects/%s/topics/%s", projectId, topic);	String subscriptionFullName = String.format("projects/%s/subscriptions/%s", projectId, subscriptionName);	Pubsub pubsub = PubsubUtil .createConnectionFactory(properties) .getDefaultClient();	try {	pubsub.projects() .topics() .create(topicFullName, new Topic()) .execute();	} catch (GoogleJsonResponseException e) {	if (409 == e.getStatusCode()) {	
topic already exist 

if (409 == e.getStatusCode()) {	} else {	throw e;	}	}	try {	Subscription subscription = new Subscription() .setTopic(topicFullName) .setAckDeadlineSeconds(ackDeadlineSeconds);	pubsub.projects() .subscriptions() .create(subscriptionFullName, subscription) .execute();	} catch (GoogleJsonResponseException e) {	if (409 == e.getStatusCode()) {	
subscription already exist 

========================= camel sample_17549 =========================

public void dispose(T context) {	super.dispose(context);	if (!context.getStatus().isStopped()) {	
camel cdi is stopping camel context 

========================= camel sample_9905 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KubernetesNamespacesComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-namespaces.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-namespaces.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_551 =========================

public void testQueryLifecycle(ContentType contentType) throws Exception {	
testing query lifecycle with content 

JobInfo jobInfo = new JobInfo();	jobInfo.setOperation(OperationEnum.QUERY);	jobInfo.setContentType(contentType);	jobInfo.setObject(Merchandise__c.class.getSimpleName());	jobInfo = createJob(jobInfo);	BatchInfo batchInfo = template().requestBody("direct:createBatchQuery", jobInfo, BatchInfo.class);	assertNotNull("Null batch query", batchInfo);	assertNotNull("Null batch query id", batchInfo.getId());	InputStream requestStream = template().requestBody("direct:getRequest", batchInfo, InputStream.class);	assertNotNull("Null batch request", requestStream);	
waiting for query batch to finish 

jobInfo = createJob(jobInfo);	BatchInfo batchInfo = template().requestBody("direct:createBatchQuery", jobInfo, BatchInfo.class);	assertNotNull("Null batch query", batchInfo);	assertNotNull("Null batch query id", batchInfo.getId());	InputStream requestStream = template().requestBody("direct:getRequest", batchInfo, InputStream.class);	assertNotNull("Null batch request", requestStream);	while (!batchProcessed(batchInfo)) {	Thread.sleep(5000);	batchInfo = getBatchInfo(batchInfo);	}	
query finished with state 

========================= camel sample_14735 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<HazelcastReplicatedmapComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-replicatedmap.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-replicatedmap.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_678 =========================

if (allowSimple) {	Matcher matcher = SIMPLE_PATTERN.matcher(expression);	if (matcher.find()) {	hasSimple = true;	}	}	if (hasSimple) {	this.path = null;	} else {	this.path = JsonPath.compile(expression);	
compiled static jsonpath 

public Object read(Exchange exchange) throws Exception {	Object answer;	if (path == null) {	Expression exp = exchange.getContext().resolveLanguage("simple").createExpression(expression);	String text = exp.evaluate(exchange, String.class);	JsonPath path = JsonPath.compile(text);	
compiled dynamic jsonpath 

JsonPath path = JsonPath.compile(text);	answer = doRead(path, exchange);	} else {	answer = doRead(path, exchange);	}	if (writeAsString) {	if (!initJsonAdapter) {	doInitAdapter(exchange);	}	if (adapter == null) {	
cannot writeasstring as adapter cannot be initialized 

private Object doRead(JsonPath path, Exchange exchange) throws IOException, CamelExchangeException {	Object json = headerName != null ? exchange.getIn().getHeader(headerName) : exchange.getIn().getBody();	if (json instanceof InputStream) {	return readWithInputStream(path, exchange);	} else if (json instanceof GenericFile) {	
jsonpath is read as generic file 

if (json instanceof InputStream) {	return readWithInputStream(path, exchange);	} else if (json instanceof GenericFile) {	GenericFile<?> genericFile = (GenericFile<?>) json;	if (genericFile.getCharset() != null) {	InputStream inputStream = new FileInputStream((File) genericFile.getFile());	return path.read(inputStream, genericFile.getCharset(), configuration);	}	}	if (json instanceof String) {	
jsonpath is read as string 

GenericFile<?> genericFile = (GenericFile<?>) json;	if (genericFile.getCharset() != null) {	InputStream inputStream = new FileInputStream((File) genericFile.getFile());	return path.read(inputStream, genericFile.getCharset(), configuration);	}	}	if (json instanceof String) {	String str = (String) json;	return path.read(str, configuration);	} else if (json instanceof Map) {	
jsonpath is read as map 

return path.read(inputStream, genericFile.getCharset(), configuration);	}	}	if (json instanceof String) {	String str = (String) json;	return path.read(str, configuration);	} else if (json instanceof Map) {	Map map = (Map) json;	return path.read(map, configuration);	} else if (json instanceof List) {	
jsonpath is read as list 

private Object readWithInputStream(JsonPath path, Exchange exchange) throws IOException {	Object json = headerName != null ? exchange.getIn().getHeader(headerName) : exchange.getIn().getBody();	
jsonpath is read as inputstream 

private Object readWithAdapter(JsonPath path, Exchange exchange) {	Object json = headerName != null ? exchange.getIn().getHeader(headerName) : exchange.getIn().getBody();	
jsonpath is read with adapter 

private Object readWithAdapter(JsonPath path, Exchange exchange) {	Object json = headerName != null ? exchange.getIn().getHeader(headerName) : exchange.getIn().getBody();	doInitAdapter(exchange);	if (adapter != null) {	
attempting to use jacksonjsonadapter 

private Object readWithAdapter(JsonPath path, Exchange exchange) {	Object json = headerName != null ? exchange.getIn().getHeader(headerName) : exchange.getIn().getBody();	doInitAdapter(exchange);	if (adapter != null) {	Map map = adapter.readValue(json, exchange);	if (map != null) {	if (LOG.isDebugEnabled()) {	
jacksonjsonadapter converted object from to java util map 

private void doInitAdapter(Exchange exchange) {	if (!initJsonAdapter) {	try {	
attempting to enable jacksonjsonadapter by resolving from classpath 

private void doInitAdapter(Exchange exchange) {	if (!initJsonAdapter) {	try {	Class<?> clazz = exchange.getContext().getClassResolver().resolveClass(JACKSON_JSON_ADAPTER);	if (clazz != null) {	Object obj = exchange.getContext().getInjector().newInstance(clazz);	if (obj instanceof JsonPathAdapter) {	adapter = (JsonPathAdapter) obj;	adapter.init(exchange.getContext());	
jacksonjsonadapter found on classpath and enabled for camel jsonpath 

========================= camel sample_16972 =========================

public void testXml() throws Exception {	InputStream is = new FileInputStream("src/test/resources/org/apache/camel/parser/xml/myroutes.xml");	String key = "_camelContext1/cbr-route/_from1";	Element element = CamelXmlHelper.getSelectedCamelElementNode(key, is);	assertNotNull("Could not find Element for key " + key, element);	
found element 

========================= camel sample_228 =========================

public String noParamOperation() {	
processing no param 

========================= camel sample_7761 =========================

protected JAXBContext createContext() throws JAXBException {	if (contextPath != null) {	ClassLoader cl = camelContext.getApplicationContextClassLoader();	if (cl != null) {	
creating jaxbcontext with contextpath and applicationcontextclassloader 

protected JAXBContext createContext() throws JAXBException {	if (contextPath != null) {	ClassLoader cl = camelContext.getApplicationContextClassLoader();	if (cl != null) {	return JAXBContext.newInstance(contextPath, cl);	} else {	
creating jaxbcontext with contextpath 

protected JAXBContext createContext() throws JAXBException {	if (contextPath != null) {	ClassLoader cl = camelContext.getApplicationContextClassLoader();	if (cl != null) {	return JAXBContext.newInstance(contextPath, cl);	} else {	return JAXBContext.newInstance(contextPath);	}	} else {	
creating jaxbcontext 

========================= camel sample_13789 =========================

protected void setUp() throws Exception {	utf = "ABC\u00e6".getBytes("utf-8");	iso = "ABC\u00e6".getBytes("iso-8859-1");	deleteDirectory("target/charset");	createDirectory("target/charset/input");	
utf utf 

protected void setUp() throws Exception {	utf = "ABC\u00e6".getBytes("utf-8");	iso = "ABC\u00e6".getBytes("iso-8859-1");	deleteDirectory("target/charset");	createDirectory("target/charset/input");	
iso iso 

protected void setUp() throws Exception {	utf = "ABC\u00e6".getBytes("utf-8");	iso = "ABC\u00e6".getBytes("iso-8859-1");	deleteDirectory("target/charset");	createDirectory("target/charset/input");	for (byte b : utf) {	
utf byte 

protected void setUp() throws Exception {	utf = "ABC\u00e6".getBytes("utf-8");	iso = "ABC\u00e6".getBytes("iso-8859-1");	deleteDirectory("target/charset");	createDirectory("target/charset/input");	for (byte b : utf) {	}	for (byte b : iso) {	
iso byte 

File file = new File("target/charset/output.txt");	assertTrue("File should exist", file.exists());	InputStream fis = Files.newInputStream(Paths.get(file.getAbsolutePath()));	byte[] buffer = new byte[100];	int len = fis.read(buffer);	assertTrue("Should read data: " + len, len != -1);	byte[] data = new byte[len];	System.arraycopy(buffer, 0, data, 0, len);	fis.close();	for (byte b : data) {	
loaded byte 

========================= camel sample_2975 =========================

private void doSendMessages(int messageCount) throws Exception {	
sending messages 

switch (i % 3) {	case 0: template.sendBody("seda:foo", XMLTEST1);	break;	case 1: template.sendBody("seda:foo", XMLTEST2);	break;	case 2: template.sendBody("seda:foo", XMLTEST3);	break;	default: break;	}	}	
sent messages in ms 

case 0: template.sendBody("seda:foo", XMLTEST1);	break;	case 1: template.sendBody("seda:foo", XMLTEST2);	break;	case 2: template.sendBody("seda:foo", XMLTEST3);	break;	default: break;	}	}	assertMockEndpointsSatisfied();	
processed messages in ms 

========================= camel sample_3667 =========================

public void testLoadTestJdbcAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.setResultWaitTime(50 * 1000);	
staring to send messages 

public void testLoadTestJdbcAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.setResultWaitTime(50 * 1000);	for (int i = 0; i < SIZE; i++) {	final int value = 1;	char id = 'A';	
sending with id 

public void testLoadTestJdbcAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.setResultWaitTime(50 * 1000);	for (int i = 0; i < SIZE; i++) {	final int value = 1;	char id = 'A';	template.sendBodyAndHeader("seda:start?size=" + SIZE, value, "id", "" + id);	}	
sending all message done now waiting for aggregation to complete 

========================= camel sample_8928 =========================

public void validate(Message message, DataType type) throws ValidationException {	Object body = message.getBody();	
validating message body 

========================= camel sample_17725 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<HazelcastMultimapComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-multimap.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-multimap.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_697 =========================

sslContext.setSSLContext(getServerSSLContext());	brokerService.setSslContext(sslContext);	brokerService.addConnector("stomp+ssl: } else {	brokerService.addConnector("stomp: }	brokerService.start();	brokerService.waitUntilStarted();	super.setUp();	canTest = true;	} catch (Exception e) {	System.err.println("Cannot test due " + e.getMessage() + " more details in the log");	
cannot test due 

========================= camel sample_16513 =========================

public void testPerformance() {	ActiveMQUuidGenerator uuidGenerator = new ActiveMQUuidGenerator();	StopWatch watch = new StopWatch();	
first id 

public void testPerformance() {	ActiveMQUuidGenerator uuidGenerator = new ActiveMQUuidGenerator();	StopWatch watch = new StopWatch();	for (int i = 0; i < 500000; i++) {	uuidGenerator.generateUuid();	}	
last id 

public void testPerformance() {	ActiveMQUuidGenerator uuidGenerator = new ActiveMQUuidGenerator();	StopWatch watch = new StopWatch();	for (int i = 0; i < 500000; i++) {	uuidGenerator.generateUuid();	}	
took 

========================= camel sample_1292 =========================

public boolean process(Exchange exchange, AsyncCallback callback) {	try {	Message message = exchange.getIn();	DockerClient client = DockerClientFactory.getDockerClient(component, configuration, message);	DockerOperation operation = configuration.getOperation();	Object result = null;	switch (operation) {	case BUILD_IMAGE: result = executeBuildImageRequest(client, message).exec(new BuildImageResultCallback() {	public void onNext(BuildResponseItem item) {	
build image callback 

}	});	if (result != null) {	String imageId = ((BuildImageResultCallback)result).awaitImageId();	((BuildImageResultCallback)result).close();	result = imageId;	}	break;	case PULL_IMAGE: result = executePullImageRequest(client, message).exec(new PullImageResultCallback() {	public void onNext(PullResponseItem item) {	
pull image callback 

super.onNext(item);	}	});	if (result != null) {	result = ((PullImageResultCallback)result).awaitCompletion();	((PullImageResultCallback)result).close();	}	break;	case PUSH_IMAGE: result = executePushImageRequest(client, message).exec(new PushImageResultCallback() {	public void onNext(PushResponseItem item) {	
push image callback 

super.onNext(item);	}	});	if (result != null) {	result = ((PushImageResultCallback)result).awaitCompletion();	((PushImageResultCallback)result).close();	}	break;	case ATTACH_CONTAINER: result = executeAttachContainerRequest(client, message).exec(new AttachContainerResultCallback() {	public void onNext(Frame item) {	
attach container callback 

super.onNext(item);	}	});	if (result != null) {	result = ((AttachContainerResultCallback)result).awaitCompletion();	((AttachContainerResultCallback)result).close();	}	break;	case LOG_CONTAINER: result = executeLogContainerRequest(client, message).exec(new LogContainerResultCallback() {	public void onNext(Frame item) {	
log container callback 

super.onNext(item);	}	});	if (result != null) {	result = ((LogContainerResultCallback)result).awaitCompletion();	((LogContainerResultCallback)result).close();	}	break;	case WAIT_CONTAINER: result = executeWaitContainerRequest(client, message).exec(new WaitContainerResultCallback() {	public void onNext(WaitResponse item) {	
wait contanier callback 

}	});	if (result != null) {	Integer statusCode = ((WaitContainerResultCallback)result).awaitStatusCode();	((WaitContainerResultCallback)result).close();	result = statusCode;	}	break;	case EXEC_START: result = executeExecStartRequest(client, message).exec(new ExecStartResultCallback() {	public void onNext(Frame item) {	
exec start callback 

private BuildImageCmd executeBuildImageRequest(DockerClient client, Message message) throws DockerException {	
executing docker build image request 

private PullImageCmd executePullImageRequest(DockerClient client, Message message) {	
executing docker pull image request 

private PushImageCmd executePushImageRequest(DockerClient client, Message message) {	
executing docker push image request 

private AttachContainerCmd executeAttachContainerRequest(DockerClient client, Message message) {	
executing docker attach container request 

private WaitContainerCmd executeWaitContainerRequest(DockerClient client, Message message) {	
executing docker wait container request 

private ExecStartCmd executeExecStartRequest(DockerClient client, Message message) {	
executing docker exec create request 

========================= camel sample_6557 =========================

public void testSearchTimelineWithStaticQuery() throws Exception {	template.sendBody(null);	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.assertIsSatisfied();	List<Exchange> tweets = mock.getExchanges();	for (Exchange e : tweets) {	
tweet 

public void testSearchTimelineWithDynamicQuery() throws Exception {	templateHeader.sendBodyAndHeader(null, TwitterConstants.TWITTER_KEYWORDS, "java");	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.assertIsSatisfied();	List<Exchange> tweets = mock.getExchanges();	for (Exchange e : tweets) {	
tweet 

public void testSearchTimelineWithDynamicQuerySinceId() throws Exception {	Map<String, Object> headers = new HashMap<String, Object>();	headers.put(TwitterConstants.TWITTER_KEYWORDS, "java");	headers.put(TwitterConstants.TWITTER_SINCEID, new Long(258347905419730944L));	templateHeader.sendBodyAndHeaders(null, headers);	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.assertIsSatisfied();	List<Exchange> tweets = mock.getExchanges();	for (Exchange e : tweets) {	
tweet 

public void testDoubleSearchKeepingOld() throws Exception {	templateDouble.sendBodyAndHeader(null, TwitterConstants.TWITTER_KEYWORDS, "java");	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.assertIsSatisfied();	List<Exchange> tweets = mock.getExchanges();	for (Exchange e : tweets) {	
tweet 

========================= camel sample_14191 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() {	from(directIn) .to("seda:seda");	
seda seda Async to sendresult 

========================= camel sample_9358 =========================

public void invoke(Object pojo, Exchange exchange) {	try {	
invoking method with args 

public void invoke(Object pojo, Exchange exchange) {	try {	Object response = getMethod().invoke(pojo, getArgs());	
got response 

========================= camel sample_4839 =========================

public void afterTestMethod(TestContext testContext) throws Exception {	StopWatch watch = threadStopWatch.get();	if (watch != null) {	long time = watch.stop();	Logger log = LoggerFactory.getLogger(testContext.getTestClass());	log.info("********************************************************************************");	
testing done 

public void afterTestMethod(TestContext testContext) throws Exception {	StopWatch watch = threadStopWatch.get();	if (watch != null) {	long time = watch.stop();	Logger log = LoggerFactory.getLogger(testContext.getTestClass());	log.info("********************************************************************************");	
took millis 

========================= camel sample_10582 =========================

public void afterPropertiesSet() throws Exception {	if (Strings.isNullOrEmpty(loggerId)) {	log = LoggerFactory.getLogger(this.getClass().getName());	} else {	log = LoggerFactory.getLogger(loggerId);	}	pubsub = getConnectionFactory().getDefaultClient();	
credential file location 

public void afterPropertiesSet() throws Exception {	if (Strings.isNullOrEmpty(loggerId)) {	log = LoggerFactory.getLogger(this.getClass().getName());	} else {	log = LoggerFactory.getLogger(loggerId);	}	pubsub = getConnectionFactory().getDefaultClient();	
project id 

public void afterPropertiesSet() throws Exception {	if (Strings.isNullOrEmpty(loggerId)) {	log = LoggerFactory.getLogger(this.getClass().getName());	} else {	log = LoggerFactory.getLogger(loggerId);	}	pubsub = getConnectionFactory().getDefaultClient();	
destination name 

========================= camel sample_17247 =========================

protected void marshalInternal(InputStream is, OutputStream os, Exchange exchange) throws Exception {	CMSSignedDataStreamGenerator gen = new CMSSignedDataStreamGenerator();	if (config.getSigner().isEmpty()) {	throw new CryptoCmsException("No signer information configured");	}	for (SignerInfo signer : config.getSigner()) {	
signer info 

throw new CryptoCmsInvalidKeyException("The private key of the signer information  '" + signer + "' does not fit to the specified signature algorithm '" + signer.getSignatureAlgorithm(exchange) + "': " + e.getMessage(), e);	}	JcaSignerInfoGeneratorBuilder signerBuilder = new JcaSignerInfoGeneratorBuilder(new JcaDigestCalculatorProviderBuilder().setProvider(BouncyCastleProvider.PROVIDER_NAME) .build());	signerBuilder.setSignedAttributeGenerator(signer.getSignedAttributeGenerator(exchange)).setUnsignedAttributeGenerator(signer.getUnsignedAttributeGenerator(exchange));	gen.addSignerInfoGenerator(signerBuilder.build(contentSigner, signerCert));	List<Certificate> certificateList = new ArrayList<Certificate>();	for (Certificate cert : signer.getCertificateChain(exchange)) {	if (!certificateList.contains(cert)) {	certificateList.add(cert);	gen.addCertificate(new X509CertificateHolder(cert.getEncoded()));	
certificate added to signed data certificate list 

gen.addCertificate(new X509CertificateHolder(cert.getEncoded()));	}	}	}	OutputStream sigOut = gen.open(os, config.getIncludeContent());	try {	IOHelper.copyAndCloseInput(is, sigOut);	} finally {	IOHelper.close(sigOut);	}	
cms signed data generation successful 

========================= camel sample_11540 =========================

protected void doStart() throws Exception {	super.doStart();	String topic = getEndpoint().getTopic();	getEndpoint().getClient().subscribe(topic, getEndpoint().getQos());	getEndpoint().getClient().setCallback(new MqttCallbackExtended() {	public void connectComplete(boolean reconnect, String serverURI) {	if (reconnect) {	try {	getEndpoint().getClient().subscribe(topic, getEndpoint().getQos());	} catch (MqttException e) {	
mqtt resubscribe failed 

getEndpoint().getClient().setCallback(new MqttCallbackExtended() {	public void connectComplete(boolean reconnect, String serverURI) {	if (reconnect) {	try {	getEndpoint().getClient().subscribe(topic, getEndpoint().getQos());	} catch (MqttException e) {	}	}	}	public void connectionLost(Throwable cause) {	
mqtt broker connection lost due 

if (reconnect) {	try {	getEndpoint().getClient().subscribe(topic, getEndpoint().getQos());	} catch (MqttException e) {	}	}	}	public void connectionLost(Throwable cause) {	}	public void messageArrived(String topic, MqttMessage message) throws Exception {	
message arrived on topic 

public void connectionLost(Throwable cause) {	}	public void messageArrived(String topic, MqttMessage message) throws Exception {	Exchange exchange = getEndpoint().createExchange(message, topic);	getAsyncProcessor().process(exchange, new AsyncCallback() {	public void done(boolean doneSync) {	}	});	}	public void deliveryComplete(IMqttDeliveryToken token) {	
delivery complete token 

========================= camel sample_9071 =========================

private DataFormat getDataFormat(String name, CamelContext context, boolean create) {	
finding dataformat 

========================= camel sample_13087 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<VmComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.vm.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.vm.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_875 =========================

if (getEndpoint().getHttpClientParameters() != null) {	String timeout = (String)getEndpoint().getHttpClientParameters().get("timeout");	if (timeout != null) {	httpExchange.setTimeout(new Long(timeout));	}	String supportRedirect = (String)getEndpoint().getHttpClientParameters().get("supportRedirect");	if (supportRedirect != null) {	httpExchange.setSupportRedirect(Boolean.valueOf(supportRedirect));	}	}	
using url with method 

if (getEndpoint().isConnectionClose()) {	httpExchange.addRequestHeader("Connection", "close");	}	if (getEndpoint().isPreserveHostHeader()) {	String hostHeader = exchange.getIn().getHeader("Host", String.class);	if (hostHeader != null) {	httpExchange.addRequestHeader("Host", hostHeader);	}	}	if (LOG.isDebugEnabled()) {	
sending http request to 

protected void doStart() throws Exception {	if (!sharedClient && client != null) {	client.start();	Object tp = getClientThreadPool();	if (tp instanceof LifeCycle) {	
starting client thread pool 

protected void doStop() throws Exception {	super.doStop();	if (!sharedClient && client != null) {	client.stop();	Object tp = getClientThreadPool();	if (tp instanceof LifeCycle) {	
stopping client thread pool 

========================= camel sample_17494 =========================

public void messageReceived(ChannelHandlerContext ctx, MessageEvent messageEvent) throws Exception {	HttpRequest request = (HttpRequest) messageEvent.getMessage();	
message received 

public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {	HttpServerChannelHandler handler = (HttpServerChannelHandler) ctx.getAttachment();	if (handler != null) {	handler.exceptionCaught(ctx, e);	} else {	if (e.getCause() instanceof ClosedChannelException) {	
channel already closed ignoring this exception 

public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {	HttpServerChannelHandler handler = (HttpServerChannelHandler) ctx.getAttachment();	if (handler != null) {	handler.exceptionCaught(ctx, e);	} else {	if (e.getCause() instanceof ClosedChannelException) {	return;	} else {	if ("Broken pipe".equals(e.getCause().getMessage())) {	
channel pipe is broken closing channel now 

HttpServerChannelHandler handler = (HttpServerChannelHandler) ctx.getAttachment();	if (handler != null) {	handler.exceptionCaught(ctx, e);	} else {	if (e.getCause() instanceof ClosedChannelException) {	return;	} else {	if ("Broken pipe".equals(e.getCause().getMessage())) {	ctx.getChannel().close();	} else {	
httpserverchannelhandler is not found as attachment to handle exception send back to the client 

========================= camel sample_8375 =========================

private void initInsertStatement() {	Insert insert = generateInsert(table, getAllColumns(), false, ttl);	insert = applyConsistencyLevel(insert, writeConsistencyLevel);	
generated insert 

public Exchange add(CamelContext camelContext, String key, Exchange exchange) {	final Object[] idValues = getPKValues(key);	
inserting key exchange 

protected void initSelectStatement() {	Select select = generateSelect(table, getAllColumns(), pkColumns);	select = applyConsistencyLevel(select, readConsistencyLevel);	
generated select 

public Exchange get(CamelContext camelContext, String key) {	Object[] pkValues = getPKValues(key);	
selecting key 

private void initDeleteIfIdStatement() {	Delete delete = generateDelete(table, pkColumns, false);	Delete.Conditions deleteIf = delete.onlyIf(eq(exchangeIdColumn, bindMarker()));	deleteIf = applyConsistencyLevel(deleteIf, writeConsistencyLevel);	
generated delete if id 

public void confirm(CamelContext camelContext, String exchangeId) {	String keyColumn = getKeyColumn();	
selecting ids 

public void confirm(CamelContext camelContext, String exchangeId) {	String keyColumn = getKeyColumn();	List<Row> rows = selectKeyIds();	for (Row row : rows) {	if (row.getString(exchangeIdColumn).equals(exchangeId)) {	String key = row.getString(keyColumn);	Object[] cqlParams = append(getPKValues(key), exchangeId);	
deleting if id 

private void initDeleteStatement() {	Delete delete = generateDelete(table, pkColumns, false);	delete = applyConsistencyLevel(delete, writeConsistencyLevel);	
generated delete 

public void remove(CamelContext camelContext, String key, Exchange exchange) {	Object[] idValues = getPKValues(key);	
deleting key 

private void initSelectKeyIdStatement() {	Select select = generateSelect(table, new String[]{getKeyColumn(), exchangeIdColumn}, pkColumns, pkColumns.length - 1);	select = applyConsistencyLevel(select, readConsistencyLevel);	
generated select keys 

protected List<Row> selectKeyIds() {	
selecting keys 

========================= camel sample_15446 =========================

public void testDefaultPrefixInRootElementWithCopyTransformer() throws Exception {	TransformerFactory trf = TransformerFactory.newInstance();	ByteArrayOutputStream baos = new ByteArrayOutputStream();	XMLStreamReader reader = context.getTypeConverter().mandatoryConvertTo(XMLStreamReader.class, new StringReader(TEST_XML));	Exchange exchange = new DefaultExchange(context);	exchange.setProperty(Exchange.CHARSET_NAME, UTF_8.toString());	XMLStreamWriter writer = context.getTypeConverter().mandatoryConvertTo(XMLStreamWriter.class, exchange, baos);	StAX2SAXSource staxSource = new StAX2SAXSource(reader);	StreamSource templateSource = new StreamSource(getClass().getResourceAsStream("/xslt/common/copy.xsl"));	Transformer transformer = trf.newTransformer(templateSource);	
used transformer 

========================= camel sample_1504 =========================

public CamelSpringBootApplicationController(final ApplicationContext applicationContext, final CamelContext camelContext) {	this.main = new Main() {	protected ProducerTemplate findOrCreateCamelTemplate() {	return applicationContext.getBean(ProducerTemplate.class);	}	protected Map<String, CamelContext> getCamelContextMap() {	return Collections.singletonMap("camelContext", camelContext);	}	protected void doStop() throws Exception {	
controller is shutting down camelcontext 

public void run() {	
controller is starting and waiting for spring boot to stop or jvm to terminate 

public void run() {	try {	main.run();	
waiting for camelcontext to complete shutdown 

public void run() {	try {	main.run();	latch.await();	} catch (Exception e) {	throw new RuntimeException(e);	}	
camelcontext shutdown complete 

========================= camel sample_13438 =========================

public PullRequestFilesProducer(GitHubEndpoint endpoint) throws Exception {	super(endpoint);	Registry registry = endpoint.getCamelContext().getRegistry();	Object service = registry.lookupByName(GitHubConstants.GITHUB_PULL_REQUEST_SERVICE);	if (service != null) {	
using pullrequestservice found in registry 

========================= camel sample_14257 =========================

public void populateCxfRequestFromExchange( org.apache.cxf.message.Exchange cxfExchange, Exchange camelExchange, Map<String, Object> requestContext) {	Map<String, Object> camelHeaders = camelExchange.getIn().getHeaders();	extractInvocationContextFromCamel(camelExchange, camelHeaders, requestContext, Client.REQUEST_CONTEXT);	propagateHeadersFromCamelToCxf(camelExchange, camelHeaders, cxfExchange, requestContext);	String overrideAddress = camelExchange.getIn().getHeader(Exchange.DESTINATION_OVERRIDE_URL, String.class);	if (overrideAddress != null) {	
client address is overridden by header to value 

public void populateExchangeFromCxfResponse(Exchange camelExchange, org.apache.cxf.message.Exchange cxfExchange, Map<String, Object> responseContext) {	Message cxfMessage = cxfExchange.getInMessage();	if (cxfMessage == null) {	return;	}	
populate exchange from cxf response message 

LOG.trace("Set IN header: {}={}", CxfConstants.OPERATION_NAMESPACE, boi.getName().getNamespaceURI());	LOG.trace("Set IN header: {}={}", CxfConstants.OPERATION_NAME, boi.getName().getLocalPart());	}	} else if (method != null) {	camelExchange.getIn().setHeader(CxfConstants.OPERATION_NAME, method.getName());	if (LOG.isTraceEnabled()) {	LOG.trace("Set IN header: {}={}", CxfConstants.OPERATION_NAME, method.getName());	}	}	camelExchange.setPattern(mep);	
set exchange mep 

public void populateCxfResponseFromExchange(Exchange camelExchange, org.apache.cxf.message.Exchange cxfExchange) {	if (cxfExchange.isOneWay()) {	return;	}	Map<String, Object> responseContext = new HashMap<String, Object>();	org.apache.camel.Message response;	if (camelExchange.getPattern().isOutCapable()) {	if (camelExchange.hasOut()) {	response = camelExchange.getOut();	
get the response from the out message 

if (cxfExchange.isOneWay()) {	return;	}	Map<String, Object> responseContext = new HashMap<String, Object>();	org.apache.camel.Message response;	if (camelExchange.getPattern().isOutCapable()) {	if (camelExchange.hasOut()) {	response = camelExchange.getOut();	} else {	response = camelExchange.getIn();	
get the response from the in message as a fallback 

Map<String, Object> responseContext = new HashMap<String, Object>();	org.apache.camel.Message response;	if (camelExchange.getPattern().isOutCapable()) {	if (camelExchange.hasOut()) {	response = camelExchange.getOut();	} else {	response = camelExchange.getIn();	}	} else {	response = camelExchange.getIn();	
get the response from the in message 

CxfHeaderHelper.copyHttpHeadersFromCxfToCamel(headerFilterStrategy, cxfMessage, camelMessage, exchange);	if (cxfHeaders != null) {	for (Map.Entry<String, List<String>> entry : cxfHeaders.entrySet()) {	if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), entry.getValue(), exchange)) {	if ("Content-Type".compareToIgnoreCase(entry.getKey()) == 0 && entry.getValue().get(0) != null && entry.getValue().get(0).startsWith("multipart/related")) {	DataFormat dataFormat = exchange.getProperty(CxfConstants.DATA_FORMAT_PROPERTY, DataFormat.class);	if (dataFormat.equals(DataFormat.RAW)) {	camelHeaders.put(entry.getKey(), getContentTypeString(entry.getValue()));	} else {	String contentType = replaceMultiPartContentType(entry.getValue().get(0));	
find the multi part conent type and replace it with 

transportHeaders.putAll(h);	}	}	Map<String, List<String>> headers = CastUtils.cast((Map<?, ?>)camelHeaders.get(Message.PROTOCOL_HEADERS));	if (headers != null) {	transportHeaders.putAll(headers);	}	DataFormat dataFormat = camelExchange.getProperty(CxfConstants.DATA_FORMAT_PROPERTY, DataFormat.class);	for (Map.Entry<String, Object> entry : camelHeaders.entrySet()) {	if (Message.RESPONSE_CODE.equals(entry.getKey()) || Exchange.HTTP_RESPONSE_CODE.equals(entry.getKey())) {	
propagate to cxf header value 

if (headers != null) {	transportHeaders.putAll(headers);	}	DataFormat dataFormat = camelExchange.getProperty(CxfConstants.DATA_FORMAT_PROPERTY, DataFormat.class);	for (Map.Entry<String, Object> entry : camelHeaders.entrySet()) {	if (Message.RESPONSE_CODE.equals(entry.getKey()) || Exchange.HTTP_RESPONSE_CODE.equals(entry.getKey())) {	cxfContext.put(Message.RESPONSE_CODE, entry.getValue());	continue;	}	if (Message.CONTENT_TYPE.equalsIgnoreCase(entry.getKey()) && dataFormat.equals(DataFormat.RAW)) {	
propagate to cxf header value 

continue;	}	if (entry.getKey().equalsIgnoreCase("User-Agent")) {	List<String> listValue = new ArrayList<String>();	listValue.add(entry.getValue().toString());	transportHeaders.put("User-Agent", listValue);	}	if (headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue(), camelExchange)) {	continue;	}	
propagate to cxf header value 

listValue.add(entry.getValue().toString());	transportHeaders.put("User-Agent", listValue);	}	if (headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue(), camelExchange)) {	continue;	}	if (Header.HEADER_LIST.equals(entry.getKey())) {	List<Header> headerList = (List<Header>)entry.getValue();	for (Header header : headerList) {	header.setDirection(Header.Direction.DIRECTION_OUT);	
propagate soap protocol header 

answer.add((Source)part);	}	if (LOG.isTraceEnabled()) {	LOG.trace("Extract body element {}", element == null ? "null" : getXMLString(element));	}	} else if (part instanceof Element) {	addNamespace((Element)part, nsMap);	answer.add(new DOMSource((Element)part));	} else {	if (LOG.isDebugEnabled()) {	
unhandled part type 

private static void changeToOneway(org.apache.cxf.message.Exchange cxfExchange) {	cxfExchange.setOneWay(true);	Object httpresp = cxfExchange.getInMessage().get("HTTP.RESPONSE");	if (httpresp != null) {	try {	Method m = findMethod(httpresp.getClass(), "setStatus", int.class);	if (m != null) {	m.invoke(httpresp, 202);	}	} catch (Exception e) {	
unable to set the http 

========================= camel sample_7983 =========================

private synchronized void getOrRefreshAccessToken() {	if (token == null) {	
generate oauth token 

private synchronized void getOrRefreshAccessToken() {	if (token == null) {	token = OAuthClientUtils.getAccessToken( WebClient.create(configuration.getOauthTokenUrl()), new Consumer( configuration.getOauthClientId(), configuration.getOauthClientSecret()), new ResourceOwnerGrant( configuration.getUserName(), configuration.getPassword()), true );	
oauth token expires in s 

private synchronized void getOrRefreshAccessToken() {	if (token == null) {	token = OAuthClientUtils.getAccessToken( WebClient.create(configuration.getOauthTokenUrl()), new Consumer( configuration.getOauthClientId(), configuration.getOauthClientSecret()), new ResourceOwnerGrant( configuration.getUserName(), configuration.getPassword()), true );	token.setIssuedAt(System.currentTimeMillis());	token.setExpiresIn(TimeUnit.MILLISECONDS.convert(token.getExpiresIn(), TimeUnit.SECONDS));	authString = token.toString();	if (token.getExpiresIn() > 0) {	expireAt = token.getIssuedAt() + token.getExpiresIn();	}	} else if (expireAt > 0 && System.currentTimeMillis() >= expireAt) {	
oauth token is expired refresh it 

if (token == null) {	token = OAuthClientUtils.getAccessToken( WebClient.create(configuration.getOauthTokenUrl()), new Consumer( configuration.getOauthClientId(), configuration.getOauthClientSecret()), new ResourceOwnerGrant( configuration.getUserName(), configuration.getPassword()), true );	token.setIssuedAt(System.currentTimeMillis());	token.setExpiresIn(TimeUnit.MILLISECONDS.convert(token.getExpiresIn(), TimeUnit.SECONDS));	authString = token.toString();	if (token.getExpiresIn() > 0) {	expireAt = token.getIssuedAt() + token.getExpiresIn();	}	} else if (expireAt > 0 && System.currentTimeMillis() >= expireAt) {	token = OAuthClientUtils.refreshAccessToken( WebClient.create(configuration.getOauthTokenUrl()), new Consumer( configuration.getOauthClientId(), configuration.getOauthClientSecret()), token, null, false );	
refreshed oauth token expires in s 

========================= camel sample_13592 =========================

protected boolean canScheduleOrExecute() {	if (queueSize <= 0) {	return true;	}	int size = delegate.getQueue().size();	boolean answer = size < queueSize;	if (LOG.isTraceEnabled()) {	
canscheduleorexecute 

========================= camel sample_4356 =========================

if (exchange.getException(exception) != null) {	answer = true;	break;	}	}	}	if (answer) {	statistics.onHandledFailure(exchange.getException());	}	}	
failed for exchangeid 

public boolean isRunAllowed() {	boolean forceShutdown = camelContext.getShutdownStrategy().forceShutdown(this);	if (forceShutdown) {	
run not allowed as shutdownstrategy is forcing shutting down 

public boolean process(final Exchange exchange, final AsyncCallback callback) {	if (!isRunAllowed()) {	
run not allowed will reject executing exchange 

boolean sync = albp.process(exchange, new CircuitBreakerCallback(exchange, callback));	if (sync) {	boolean failed = hasFailed(exchange);	if (!failed) {	failures.set(0);	} else {	failures.incrementAndGet();	lastFailure = System.currentTimeMillis();	}	} else {	
processing exchangeid is continued being processed asynchronously 

boolean failed = hasFailed(exchange);	if (!failed) {	failures.set(0);	} else {	failures.incrementAndGet();	lastFailure = System.currentTimeMillis();	}	} else {	return false;	}	
processing exchangeid is continued being processed synchronously 

========================= camel sample_4478 =========================

customer.setName("Willem");	exchange.getIn().setBody(customer);	}	});	results = entityManager.createQuery(queryText).getResultList();	assertEquals("Should have results: " + results, 1, results.size());	Customer customer = (Customer)results.get(0);	assertEquals("name property", "Willem", customer.getName());	consumer = endpoint.createConsumer(new Processor() {	public void process(Exchange e) {	
received exchange 

========================= camel sample_14083 =========================

public void setNode(ProcessorDefinition<?> node) {	this.node = node;	
node is now 

========================= camel sample_14579 =========================

public void process(Exchange exchange) throws Exception {	final String msg = exchange.getIn().getBody(String.class);	final String targetChannel = exchange.getIn().getHeader(IrcConstants.IRC_TARGET, String.class);	if (!connection.isConnected()) {	throw new RuntimeCamelException("Lost connection to " + connection.getHost());	}	if (msg != null) {	if (isMessageACommand(msg)) {	
sending command 

public void process(Exchange exchange) throws Exception {	final String msg = exchange.getIn().getBody(String.class);	final String targetChannel = exchange.getIn().getHeader(IrcConstants.IRC_TARGET, String.class);	if (!connection.isConnected()) {	throw new RuntimeCamelException("Lost connection to " + connection.getHost());	}	if (msg != null) {	if (isMessageACommand(msg)) {	connection.send(msg);	} else if (targetChannel != null) {	
sending to message 

if (!connection.isConnected()) {	throw new RuntimeCamelException("Lost connection to " + connection.getHost());	}	if (msg != null) {	if (isMessageACommand(msg)) {	connection.send(msg);	} else if (targetChannel != null) {	connection.doPrivmsg(targetChannel, msg);	} else {	for (IrcChannel channel : endpoint.getConfiguration().getChannels()) {	
sending to message 

protected void doStop() throws Exception {	if (connection != null) {	for (IrcChannel channel : endpoint.getConfiguration().getChannels()) {	
parting 

========================= camel sample_12157 =========================

public boolean rollback(Consumer consumer, Endpoint endpoint, int retryCounter, Exception e) throws Exception {	if (consumer instanceof RemoteFileConsumer) {	RemoteFileConsumer<?> rfc = (RemoteFileConsumer<?>) consumer;	if (rfc.isRunAllowed()) {	
trying to recover by force disconnecting from remote server and re connecting at next poll 

public boolean rollback(Consumer consumer, Endpoint endpoint, int retryCounter, Exception e) throws Exception {	if (consumer instanceof RemoteFileConsumer) {	RemoteFileConsumer<?> rfc = (RemoteFileConsumer<?>) consumer;	if (rfc.isRunAllowed()) {	try {	rfc.forceDisconnect();	} catch (Throwable t) {	
error occurred during force disconnecting from this exception will be ignored 

========================= camel sample_15368 =========================

public void processExpired(ActivityState activityState) throws Exception {	Processor processor = getOverdueAction();	if (processor != null) {	Date now = new Date();	TODO this doesn't work and returns null for some strange reason ProcessInstance instance = activityState.getProcessInstance();	ActivityState secondState = second.getActivityState(instance);	if (secondState == null) {	
could not find the second state process is with first state and the state i was called with was 

ActivityState secondState = second.getActivityState(instance);	if (secondState == null) {	}	ActivityState secondState = activityState;	Date overdue = secondState.getTimeOverdue();	if (now.compareTo(overdue) >= 0) {	Exchange exchange = createExchange();	exchange.getIn().setBody(activityState);	processor.process(exchange);	} else {	
process has not actually expired the time is but the overdue time is 

========================= camel sample_12507 =========================

public void run() {	try {	
waiting for latch 

public void run() {	try {	latch.await();	Thread.sleep(1000);	} catch (Exception e) {	}	
sending late reply 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from(componentName + ":queue:hello").process(new Processor() {	public void process(Exchange exchange) throws Exception {	assertEquals("Hello World", exchange.getIn().getBody());	myReplyTo = exchange.getIn().getHeader("MyReplyQeueue", String.class);	
replyto 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from(componentName + ":queue:hello").process(new Processor() {	public void process(Exchange exchange) throws Exception {	assertEquals("Hello World", exchange.getIn().getBody());	myReplyTo = exchange.getIn().getHeader("MyReplyQeueue", String.class);	
ahh i cannot send a reply someone else must do it 

========================= camel sample_6916 =========================

protected Object evaluateAs(Exchange exchange, QName resultQName) {	XPathExpression xpathExpression = pool.poll();	if (xpathExpression == null) {	
creating new xpathexpression as none was available from pool 

XPathExpression xpathExpression = pool.poll();	if (xpathExpression == null) {	try {	xpathExpression = createXPathExpression();	} catch (XPathExpressionException e) {	throw new InvalidXPathExpression(getText(), e);	} catch (Exception e) {	throw new RuntimeExpressionException("Cannot create xpath expression", e);	}	} else {	
acquired xpathexpression from pool 

}	} else {	}	try {	if (logNamespaces && LOG.isInfoEnabled()) {	logNamespaces(exchange);	}	return doInEvaluateAs(xpathExpression, exchange, resultQName);	} finally {	pool.add(xpathExpression);	
released xpathexpression back to pool 

protected Object doInEvaluateAs(XPathExpression xpathExpression, Exchange exchange, QName resultQName) {	
evaluating exchange as 

} finally {	IOHelper.close(is);	}	if (threadSafety && answer != null && answer instanceof NodeList) {	try {	NodeList list = (NodeList) answer;	boolean threadSafetyNeeded = list.getLength() >= 2;	if (threadSafetyNeeded) {	answer = new ThreadSafeNodeList(list);	if (LOG.isDebugEnabled()) {	
created thread safe result from as 

if (threadSafetyNeeded) {	answer = new ThreadSafeNodeList(list);	if (LOG.isDebugEnabled()) {	}	}	} catch (Exception e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	}	}	if (LOG.isTraceEnabled()) {	
done evaluating exchange as with result 

protected synchronized XPathExpression createXPathExpression() throws XPathExpressionException, XPathFactoryConfigurationException {	try {	start();	} catch (Exception e) {	throw new RuntimeExpressionException("Error starting XPathBuilder", e);	}	XPath xPath = getXPathFactory().newXPath();	if (!logNamespaces && LOG.isTraceEnabled()) {	
creating new xpath expression in pool namespaces on xpath expression 

protected synchronized XPathExpression createXPathExpression() throws XPathExpressionException, XPathFactoryConfigurationException {	try {	start();	} catch (Exception e) {	throw new RuntimeExpressionException("Error starting XPathBuilder", e);	}	XPath xPath = getXPathFactory().newXPath();	if (!logNamespaces && LOG.isTraceEnabled()) {	} else if (logNamespaces && LOG.isInfoEnabled()) {	
creating new xpath expression in pool namespaces on xpath expression 

protected synchronized XPathFactory createXPathFactory() throws XPathFactoryConfigurationException {	if (objectModelUri != null) {	String xpathFactoryClassName = factoryClassName;	if (objectModelUri.equals(SAXON_OBJECT_MODEL_URI) && (xpathFactoryClassName == null || SAXON_FACTORY_CLASS_NAME.equals(xpathFactoryClassName))) {	try {	if (camelContext != null) {	Class<XPathFactory> clazz = camelContext.getClassResolver().resolveClass(SAXON_FACTORY_CLASS_NAME, XPathFactory.class);	if (clazz != null) {	
creating saxon xpathfactory using class 

protected synchronized XPathFactory createXPathFactory() throws XPathFactoryConfigurationException {	if (objectModelUri != null) {	String xpathFactoryClassName = factoryClassName;	if (objectModelUri.equals(SAXON_OBJECT_MODEL_URI) && (xpathFactoryClassName == null || SAXON_FACTORY_CLASS_NAME.equals(xpathFactoryClassName))) {	try {	if (camelContext != null) {	Class<XPathFactory> clazz = camelContext.getClassResolver().resolveClass(SAXON_FACTORY_CLASS_NAME, XPathFactory.class);	if (clazz != null) {	xpathFactory = camelContext.getInjector().newInstance(clazz);	
created saxon xpathfactory 

String xpathFactoryClassName = factoryClassName;	if (objectModelUri.equals(SAXON_OBJECT_MODEL_URI) && (xpathFactoryClassName == null || SAXON_FACTORY_CLASS_NAME.equals(xpathFactoryClassName))) {	try {	if (camelContext != null) {	Class<XPathFactory> clazz = camelContext.getClassResolver().resolveClass(SAXON_FACTORY_CLASS_NAME, XPathFactory.class);	if (clazz != null) {	xpathFactory = camelContext.getInjector().newInstance(clazz);	}	}	} catch (Throwable e) {	
attempted to create saxon xpathfactory by creating a new instance of failed will fallback and create xpathfactory using jdk api this exception is ignored stacktrace in debug logging level 

String xpathFactoryClassName = factoryClassName;	if (objectModelUri.equals(SAXON_OBJECT_MODEL_URI) && (xpathFactoryClassName == null || SAXON_FACTORY_CLASS_NAME.equals(xpathFactoryClassName))) {	try {	if (camelContext != null) {	Class<XPathFactory> clazz = camelContext.getClassResolver().resolveClass(SAXON_FACTORY_CLASS_NAME, XPathFactory.class);	if (clazz != null) {	xpathFactory = camelContext.getInjector().newInstance(clazz);	}	}	} catch (Throwable e) {	
error creating saxon xpathfactory this exception is ignored 

if (camelContext != null) {	Class<XPathFactory> clazz = camelContext.getClassResolver().resolveClass(SAXON_FACTORY_CLASS_NAME, XPathFactory.class);	if (clazz != null) {	xpathFactory = camelContext.getInjector().newInstance(clazz);	}	}	} catch (Throwable e) {	}	}	if (xpathFactory == null) {	
creating xpathfactory from objectmodeluri 

Class<XPathFactory> clazz = camelContext.getClassResolver().resolveClass(SAXON_FACTORY_CLASS_NAME, XPathFactory.class);	if (clazz != null) {	xpathFactory = camelContext.getInjector().newInstance(clazz);	}	}	} catch (Throwable e) {	}	}	if (xpathFactory == null) {	xpathFactory = ObjectHelper.isEmpty(xpathFactoryClassName) ? XPathFactory.newInstance(objectModelUri) : XPathFactory.newInstance(objectModelUri, xpathFactoryClassName, null);	
created xpathfactory from objectmodeluri 

protected static XPathFactory createDefaultXPathFactory() throws XPathFactoryConfigurationException {	XPathFactory factory = null;	Properties properties = System.getProperties();	for (Map.Entry<Object, Object> prop : properties.entrySet()) {	String key = (String) prop.getKey();	if (key.startsWith(XPathFactory.DEFAULT_PROPERTY_NAME)) {	String uri = ObjectHelper.after(key, ":");	if (uri != null) {	factory = XPathFactory.newInstance(uri);	
using system property with value when created default xpathfactory 

String key = (String) prop.getKey();	if (key.startsWith(XPathFactory.DEFAULT_PROPERTY_NAME)) {	String uri = ObjectHelper.after(key, ":");	if (uri != null) {	factory = XPathFactory.newInstance(uri);	}	}	}	if (factory == null) {	factory = XPathFactory.newInstance();	
created default xpathfactory 

========================= camel sample_5639 =========================

public String[] doSomething(String body) {	
received body 

========================= camel sample_15738 =========================

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyFieldMethodCallRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	
consumer 

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyFieldMethodCallRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	}	Assert.assertEquals("netty-http:http: Assert.assertEquals("netty-http:http: list = CamelJavaParserHelper.parseCamelProducerUris(method, true, true);	for (ParserResult result : list) {	
producer 

========================= camel sample_208 =========================

protected boolean doConnect(RemoteFileConfiguration configuration) throws GenericFileOperationFailedException {	
connecting using ftpclient 

protected boolean doConnect(RemoteFileConfiguration configuration) throws GenericFileOperationFailedException {	String host = configuration.getHost();	int port = configuration.getPort();	String username = configuration.getUsername();	String account = ((FtpConfiguration) configuration).getAccount();	if (clientConfig != null) {	
configuring ftpclient with config 

protected boolean doConnect(RemoteFileConfiguration configuration) throws GenericFileOperationFailedException {	String host = configuration.getHost();	int port = configuration.getPort();	String username = configuration.getUsername();	String account = ((FtpConfiguration) configuration).getAccount();	if (clientConfig != null) {	client.configure(clientConfig);	}	if (log.isTraceEnabled()) {	
connecting to using connection timeout 

if (clientConfig != null) {	client.configure(clientConfig);	}	if (log.isTraceEnabled()) {	}	boolean connected = false;	int attempt = 0;	while (!connected) {	try {	if (log.isTraceEnabled() && attempt > 0) {	
reconnect attempt connecting to 

} catch (Exception e) {	if (Thread.currentThread().isInterrupted()) {	throw new GenericFileOperationFailedException("Interrupted during connecting", new InterruptedException("Interrupted during connecting"));	}	GenericFileOperationFailedException failed;	if (e instanceof GenericFileOperationFailedException) {	failed = (GenericFileOperationFailedException) e;	} else {	failed = new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);	}	
cannot connect due 

Thread.sleep(endpoint.getReconnectDelay());	} catch (InterruptedException ie) {	Thread.currentThread().interrupt();	throw new GenericFileOperationFailedException("Interrupted during sleeping", ie);	}	}	}	}	clientActivityListener.onConnected(host);	if (configuration.isPassiveMode()) {	
using passive mode connections 

} catch (IOException e) {	throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);	}	}	}	try {	clientActivityListener.onLogin(host);	boolean login;	if (username != null) {	if (account != null) {	
attempting to login user using password and account 

}	}	}	try {	clientActivityListener.onLogin(host);	boolean login;	if (username != null) {	if (account != null) {	login = client.login(username, configuration.getPassword(), account);	} else {	
attempting to login user using password 

clientActivityListener.onLogin(host);	boolean login;	if (username != null) {	if (account != null) {	login = client.login(username, configuration.getPassword(), account);	} else {	login = client.login(username, configuration.getPassword());	}	} else {	if (account != null) {	
attempting to login anonymous using account 

if (username != null) {	if (account != null) {	login = client.login(username, configuration.getPassword(), account);	} else {	login = client.login(username, configuration.getPassword());	}	} else {	if (account != null) {	login = client.login("anonymous", "", account);	} else {	
attempting to login anonymous 

clientActivityListener.onLoginComplete(host);	client.setFileType(configuration.isBinary() ? FTP.BINARY_FILE_TYPE : FTP.ASCII_FILE_TYPE);	} catch (IOException e) {	throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);	}	if (endpoint.getConfiguration().getSiteCommand() != null) {	Iterator<?> it = ObjectHelper.createIterator(endpoint.getConfiguration().getSiteCommand(), "\n");	while (it.hasNext()) {	Object next = it.next();	String command = endpoint.getCamelContext().getTypeConverter().convertTo(String.class, next);	
site command to send 

protected void doDisconnect() throws GenericFileOperationFailedException {	clientActivityListener.onDisconnecting(endpoint.getConfiguration().remoteServerInformation());	try {	
client logout 

protected void doDisconnect() throws GenericFileOperationFailedException {	clientActivityListener.onDisconnecting(endpoint.getConfiguration().remoteServerInformation());	try {	client.logout();	} catch (IOException e) {	throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);	} finally {	try {	
client disconnect 

public boolean deleteFile(String name) throws GenericFileOperationFailedException {	
deleting file 

if (endpoint.getConfiguration().isStepwise()) {	currentDir = getCurrentDirectory();	target = FileUtil.stripPath(name);	try {	changeCurrentDirectory(FileUtil.onlyPath(name));	} catch (GenericFileOperationFailedException e) {	changeCurrentDirectory(currentDir);	throw e;	}	}	
client deletefile 

public boolean renameFile(String from, String to) throws GenericFileOperationFailedException {	
renaming file to 

public boolean buildDirectory(String directory, boolean absolute) throws GenericFileOperationFailedException {	directory = endpoint.getConfiguration().normalizePath(directory);	
builddirectory 

public boolean buildDirectory(String directory, boolean absolute) throws GenericFileOperationFailedException {	directory = endpoint.getConfiguration().normalizePath(directory);	try {	String originalDirectory = client.printWorkingDirectory();	boolean success;	try {	success = client.changeWorkingDirectory(directory);	if (!success) {	
trying to build remote directory 

public boolean retrieveFile(String name, Exchange exchange, long size) throws GenericFileOperationFailedException {	clientActivityListener.setDownload(true);	clientActivityListener.setRemoteFileName(name);	clientActivityListener.setRemoteFileSize(size);	clientActivityListener.onBeginDownloading(endpoint.getConfiguration().remoteServerInformation(), name);	boolean answer;	try {	
retrievefile 

String remoteName = name;	String currentDir = null;	if (endpoint.getConfiguration().isStepwise()) {	currentDir = getCurrentDirectory();	String path = FileUtil.onlyPath(name);	if (path != null) {	changeCurrentDirectory(path);	}	remoteName = FileUtil.stripPath(name);	}	
client retrievefile 

if (endpoint.getConfiguration().isStepwise()) {	currentDir = getCurrentDirectory();	String path = FileUtil.onlyPath(name);	if (path != null) {	changeCurrentDirectory(path);	}	remoteName = FileUtil.stripPath(name);	}	if (resumeDownload && existingSize > 0) {	clientActivityListener.onResumeDownloading(endpoint.getConfiguration().remoteServerInformation(), name, existingSize);	
client restartoffset 

if (endpoint.getConfiguration().isStepwise()) {	currentDir = getCurrentDirectory();	String path = FileUtil.onlyPath(name);	if (path != null) {	changeCurrentDirectory(path);	}	remoteName = FileUtil.stripPath(name);	}	if (resumeDownload && existingSize > 0) {	clientActivityListener.onResumeDownloading(endpoint.getConfiguration().remoteServerInformation(), name, existingSize);	
resuming download of file at position 

String path = FileUtil.onlyPath(name);	if (path != null) {	changeCurrentDirectory(path);	}	remoteName = FileUtil.stripPath(name);	}	if (resumeDownload && existingSize > 0) {	clientActivityListener.onResumeDownloading(endpoint.getConfiguration().remoteServerInformation(), name, existingSize);	client.setRestartOffset(existingSize);	}	
client retrievefile 

clientActivityListener.onResumeDownloading(endpoint.getConfiguration().remoteServerInformation(), name, existingSize);	client.setRestartOffset(existingSize);	}	result = client.retrieveFile(remoteName, os);	exchange.getIn().setHeader(FtpConstants.FTP_REPLY_CODE, client.getReplyCode());	exchange.getIn().setHeader(FtpConstants.FTP_REPLY_STRING, client.getReplyString());	if (endpoint.getConfiguration().isStepwise()) {	changeCurrentDirectory(currentDir);	}	} catch (IOException e) {	
error occurred during retrieving file to local directory 

client.setRestartOffset(existingSize);	}	result = client.retrieveFile(remoteName, os);	exchange.getIn().setHeader(FtpConstants.FTP_REPLY_CODE, client.getReplyCode());	exchange.getIn().setHeader(FtpConstants.FTP_REPLY_STRING, client.getReplyString());	if (endpoint.getConfiguration().isStepwise()) {	changeCurrentDirectory(currentDir);	}	} catch (IOException e) {	if (!resumeDownload) {	
deleting local work file 

exchange.getIn().setHeader(FtpConstants.FTP_REPLY_CODE, client.getReplyCode());	exchange.getIn().setHeader(FtpConstants.FTP_REPLY_STRING, client.getReplyString());	if (endpoint.getConfiguration().isStepwise()) {	changeCurrentDirectory(currentDir);	}	} catch (IOException e) {	if (!resumeDownload) {	IOHelper.close(os, "retrieve: " + name, log);	boolean deleted = FileUtil.deleteFile(temp);	if (!deleted) {	
error occurred during retrieving file to local directory cannot delete local work file 

if (!resumeDownload) {	IOHelper.close(os, "retrieve: " + name, log);	boolean deleted = FileUtil.deleteFile(temp);	if (!deleted) {	}	}	throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);	} finally {	IOHelper.close(os, "retrieve: " + name, log);	}	
retrieve file to local work file result 

IOHelper.close(os, "retrieve: " + name, log);	boolean deleted = FileUtil.deleteFile(temp);	if (!deleted) {	}	}	throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);	} finally {	IOHelper.close(os, "retrieve: " + name, log);	}	if (result) {	
renaming local in progress file from to 

public boolean storeFile(String name, Exchange exchange, long size) throws GenericFileOperationFailedException {	name = endpoint.getConfiguration().normalizePath(name);	clientActivityListener.setDownload(false);	clientActivityListener.setRemoteFileName(name);	clientActivityListener.setRemoteFileSize(size);	clientActivityListener.onBeginUploading(endpoint.getConfiguration().remoteServerInformation(), name);	
storefile 

private boolean doStoreFile(String name, String targetName, Exchange exchange) throws GenericFileOperationFailedException {	
dostorefile 

private boolean doStoreFile(String name, String targetName, Exchange exchange) throws GenericFileOperationFailedException {	if (endpoint.getFileExist() == GenericFileExist.Ignore || endpoint.getFileExist() == GenericFileExist.Fail || endpoint.getFileExist() == GenericFileExist.Move) {	boolean existFile = existsFile(targetName);	if (existFile && endpoint.getFileExist() == GenericFileExist.Ignore) {	
an existing file already exists ignore and do not override it 

return true;	} else if (existFile && endpoint.getFileExist() == GenericFileExist.Fail) {	throw new GenericFileOperationFailedException("File already exist: " + name + ". Cannot write new file.");	} else if (existFile && endpoint.getFileExist() == GenericFileExist.Move) {	doMoveExistingFile(name, targetName);	}	}	InputStream is = null;	if (exchange.getIn().getBody() == null) {	if (endpoint.isAllowNullBody()) {	
writing empty file 

is = new ByteArrayInputStream(new byte[]{});	} else {	throw new GenericFileOperationFailedException("Cannot write null body to file: " + name);	}	}	try {	if (is == null) {	String charset = endpoint.getCharset();	if (charset != null) {	is = new ByteArrayInputStream(exchange.getIn().getMandatoryBody(String.class).getBytes(charset));	
using inputstream with charset 

if (is == null) {	String charset = endpoint.getCharset();	if (charset != null) {	is = new ByteArrayInputStream(exchange.getIn().getMandatoryBody(String.class).getBytes(charset));	} else {	is = exchange.getIn().getMandatoryBody(InputStream.class);	}	}	final StopWatch watch = new StopWatch();	boolean answer;	
about to store file using stream 

String charset = endpoint.getCharset();	if (charset != null) {	is = new ByteArrayInputStream(exchange.getIn().getMandatoryBody(String.class).getBytes(charset));	} else {	is = exchange.getIn().getMandatoryBody(InputStream.class);	}	}	final StopWatch watch = new StopWatch();	boolean answer;	if (endpoint.getFileExist() == GenericFileExist.Append) {	
client appendfile 

is = new ByteArrayInputStream(exchange.getIn().getMandatoryBody(String.class).getBytes(charset));	} else {	is = exchange.getIn().getMandatoryBody(InputStream.class);	}	}	final StopWatch watch = new StopWatch();	boolean answer;	if (endpoint.getFileExist() == GenericFileExist.Append) {	answer = client.appendFile(targetName, is);	} else {	
client storefile 

}	final StopWatch watch = new StopWatch();	boolean answer;	if (endpoint.getFileExist() == GenericFileExist.Append) {	answer = client.appendFile(targetName, is);	} else {	answer = client.storeFile(targetName, is);	}	if (log.isDebugEnabled()) {	long time = watch.taken();	
took millis to store file and ftp client returned 

} else {	answer = client.storeFile(targetName, is);	}	if (log.isDebugEnabled()) {	long time = watch.taken();	}	exchange.getIn().setHeader(FtpConstants.FTP_REPLY_CODE, client.getReplyCode());	exchange.getIn().setHeader(FtpConstants.FTP_REPLY_STRING, client.getReplyString());	String chmod = endpoint.getConfiguration().getChmod();	if (ObjectHelper.isNotEmpty(chmod)) {	
setting chmod on file 

answer = client.storeFile(targetName, is);	}	if (log.isDebugEnabled()) {	long time = watch.taken();	}	exchange.getIn().setHeader(FtpConstants.FTP_REPLY_CODE, client.getReplyCode());	exchange.getIn().setHeader(FtpConstants.FTP_REPLY_STRING, client.getReplyString());	String chmod = endpoint.getConfiguration().getChmod();	if (ObjectHelper.isNotEmpty(chmod)) {	String command = "chmod " + chmod + " " + targetName;	
client sendsitecommand 

}	if (log.isDebugEnabled()) {	long time = watch.taken();	}	exchange.getIn().setHeader(FtpConstants.FTP_REPLY_CODE, client.getReplyCode());	exchange.getIn().setHeader(FtpConstants.FTP_REPLY_STRING, client.getReplyString());	String chmod = endpoint.getConfiguration().getChmod();	if (ObjectHelper.isNotEmpty(chmod)) {	String command = "chmod " + chmod + " " + targetName;	boolean success = client.sendSiteCommand(command);	
client sendsitecommand successful 

to = endpoint.getConfiguration().normalizePath(to);	if (ObjectHelper.isEmpty(to)) {	throw new GenericFileOperationFailedException("moveExisting evaluated as empty String, cannot move existing file: " + name);	}	String dir = FileUtil.onlyPath(to);	if (dir != null) {	buildDirectory(dir, false);	}	if (existsFile(to)) {	if (endpoint.isEagerDeleteTargetFile()) {	
deleting existing file 

if (!result) {	throw new GenericFileOperationFailedException("Cannot delete file: " + to);	}	} catch (IOException e) {	throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), "Cannot delete file: " + to, e);	}	} else {	throw new GenericFileOperationFailedException("Cannot moved existing file from: " + name + " to: " + to + " as there already exists a file: " + to);	}	}	
moving existing file to 

public boolean existsFile(String name) throws GenericFileOperationFailedException {	
existsfile 

String[] names;	if (directory != null) {	names = client.listNames(directory);	} else {	names = client.listNames();	}	if (names == null) {	return false;	}	for (String existing : names) {	
existing file target file 

protected boolean fastExistsFile(String name) throws GenericFileOperationFailedException {	
fastexistsfile 

public String getCurrentDirectory() throws GenericFileOperationFailedException {	
getcurrentdirectory 

public String getCurrentDirectory() throws GenericFileOperationFailedException {	try {	String answer = client.printWorkingDirectory();	
current dir 

public void changeCurrentDirectory(String path) throws GenericFileOperationFailedException {	
changecurrentdirectory 

private void doChangeDirectory(String path) {	if (path == null || ".".equals(path) || ObjectHelper.isEmpty(path)) {	return;	}	
changing directory 

public List<FTPFile> listFiles() throws GenericFileOperationFailedException {	
listfiles 

public List<FTPFile> listFiles(String path) throws GenericFileOperationFailedException {	
listfiles 

public boolean sendNoop() throws GenericFileOperationFailedException {	
sendNoOp 

public boolean sendSiteCommand(String command) throws GenericFileOperationFailedException {	
sendsitecommand 

private boolean buildDirectoryChunks(String dirName) throws IOException {	final StringBuilder sb = new StringBuilder(dirName.length());	final String[] dirs = dirName.split("/|\\\\");	boolean success = false;	for (String dir : dirs) {	sb.append(dir).append('/');	String directory = endpoint.getConfiguration().normalizePath(sb.toString());	if (!(directory.equals("/") || directory.equals("\\"))) {	
trying to build remote directory by chunk 

========================= camel sample_15387 =========================

public void connect() {	if (managerConnection == null) {	
asterisk connection attempt to username 

public void connect() {	if (managerConnection == null) {	ManagerConnectionFactory factory = new ManagerConnectionFactory(host, username, password);	managerConnection = factory.createManagerConnection();	
asterisk connection established 

public void addListener(ManagerEventListener listener) throws CamelAsteriskException {	if (managerConnection != null) {	managerConnection.addEventListener(listener);	
asterisk added listener 

public void removeListener(ManagerEventListener listener) throws CamelAsteriskException {	if (managerConnection != null) {	managerConnection.removeEventListener(listener);	
asterisk removed listener 

========================= camel sample_12911 =========================

protected void doGetResourceQuota(Exchange exchange, String operation) throws Exception {	ResourceQuota rq = null;	String rqName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_RESOURCES_QUOTA_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(rqName)) {	
get a specific resource quota require specify a resource quota name 

protected void doGetResourceQuota(Exchange exchange, String operation) throws Exception {	ResourceQuota rq = null;	String rqName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_RESOURCES_QUOTA_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(rqName)) {	throw new IllegalArgumentException( "Get a specific Resource Quota require specify a Resource Quota name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
get a specific resource quota require specify a namespace name 

protected void doCreateResourceQuota(Exchange exchange, String operation) throws Exception {	ResourceQuota rq = null;	String rqName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_RESOURCES_QUOTA_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	ResourceQuotaSpec rqSpec = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_RESOURCE_QUOTA_SPEC, ResourceQuotaSpec.class);	if (ObjectHelper.isEmpty(rqName)) {	
create a specific resource quota require specify a resource quota name 

protected void doCreateResourceQuota(Exchange exchange, String operation) throws Exception {	ResourceQuota rq = null;	String rqName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_RESOURCES_QUOTA_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	ResourceQuotaSpec rqSpec = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_RESOURCE_QUOTA_SPEC, ResourceQuotaSpec.class);	if (ObjectHelper.isEmpty(rqName)) {	throw new IllegalArgumentException( "Create a specific resource quota require specify a resource quota name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
create a specific resource quota require specify a namespace name 

String rqName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_RESOURCES_QUOTA_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	ResourceQuotaSpec rqSpec = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_RESOURCE_QUOTA_SPEC, ResourceQuotaSpec.class);	if (ObjectHelper.isEmpty(rqName)) {	throw new IllegalArgumentException( "Create a specific resource quota require specify a resource quota name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	throw new IllegalArgumentException( "Create a specific resource quota require specify a namespace name");	}	if (ObjectHelper.isEmpty(rqSpec)) {	
create a specific resource quota require specify a resource quota spec bean 

protected void doDeleteResourceQuota(Exchange exchange, String operation) throws Exception {	String rqName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_RESOURCES_QUOTA_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(rqName)) {	
delete a specific resource quota require specify a resource quota name 

protected void doDeleteResourceQuota(Exchange exchange, String operation) throws Exception {	String rqName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_RESOURCES_QUOTA_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(rqName)) {	throw new IllegalArgumentException( "Delete a specific resource quota require specify a resource quota name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
delete a specific resource quota require specify a namespace name 

========================= camel sample_13253 =========================

private void verifyTheRecivedEmail(String expectString) throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.assertIsSatisfied();	Exchange out = mock.assertExchangeReceived(0);	ByteArrayOutputStream baos = new ByteArrayOutputStream(((MailMessage)out.getIn()).getMessage().getSize());	((MailMessage)out.getIn()).getMessage().writeTo(baos);	String dumpedMessage = baos.toString();	assertTrue("There should have the " + expectString, dumpedMessage.indexOf(expectString) > 0);	
multipart alternative 

========================= camel sample_11844 =========================

private void executeComponent() throws MojoExecutionException, MojoFailureException {	List<String> componentNames = findComponentNames();	final Set<File> jsonFiles = new TreeSet<File>();	PackageHelper.findJsonFiles(buildDir, jsonFiles, new PackageHelper.CamelComponentsModelFilter());	if (!componentNames.isEmpty()) {	
found components 

updated |= updateAvailableFrom(file, model.getFirstVersion());	boolean hasOptions = model.getComponentOptions().stream().anyMatch(o -> !o.getName().equals("resolvePropertyPlaceholders"));	if (!hasOptions) {	model.getComponentOptions().clear();	}	String options = templateComponentOptions(model);	updated |= updateComponentOptions(file, options);	options = templateEndpointOptions(model);	updated |= updateEndpointOptions(file, options);	if (updated) {	
updated doc file 

boolean hasOptions = model.getComponentOptions().stream().anyMatch(o -> !o.getName().equals("resolvePropertyPlaceholders"));	if (!hasOptions) {	model.getComponentOptions().clear();	}	String options = templateComponentOptions(model);	updated |= updateComponentOptions(file, options);	options = templateEndpointOptions(model);	updated |= updateEndpointOptions(file, options);	if (updated) {	} else if (exists) {	
no changes to doc file 

if (!hasOptions) {	model.getComponentOptions().clear();	}	String options = templateComponentOptions(model);	updated |= updateComponentOptions(file, options);	options = templateEndpointOptions(model);	updated |= updateEndpointOptions(file, options);	if (updated) {	} else if (exists) {	} else {	
no component doc file 

private void executeDataFormat() throws MojoExecutionException, MojoFailureException {	List<String> dataFormatNames = findDataFormatNames();	final Set<File> jsonFiles = new TreeSet<File>();	PackageHelper.findJsonFiles(buildDir, jsonFiles, new PackageHelper.CamelComponentsModelFilter());	if (!dataFormatNames.isEmpty()) {	
found dataformats 

if (deprecated) {	docTitle += " (deprecated)";	}	boolean exists = file.exists();	boolean updated;	updated = updateTitles(file, docTitle);	updated |= updateAvailableFrom(file, model.getFirstVersion());	String options = templateDataFormatOptions(model);	updated |= updateDataFormatOptions(file, options);	if (updated) {	
updated doc file 

docTitle += " (deprecated)";	}	boolean exists = file.exists();	boolean updated;	updated = updateTitles(file, docTitle);	updated |= updateAvailableFrom(file, model.getFirstVersion());	String options = templateDataFormatOptions(model);	updated |= updateDataFormatOptions(file, options);	if (updated) {	} else if (exists) {	
no changes to doc file 

}	boolean exists = file.exists();	boolean updated;	updated = updateTitles(file, docTitle);	updated |= updateAvailableFrom(file, model.getFirstVersion());	String options = templateDataFormatOptions(model);	updated |= updateDataFormatOptions(file, options);	if (updated) {	} else if (exists) {	} else {	
no dataformat doc file 

private void executeLanguage() throws MojoExecutionException, MojoFailureException {	List<String> languageNames = findLanguageNames();	final Set<File> jsonFiles = new TreeSet<File>();	PackageHelper.findJsonFiles(buildDir, jsonFiles, new PackageHelper.CamelComponentsModelFilter());	if (!languageNames.isEmpty()) {	
found languages 

if (deprecated) {	docTitle += " (deprecated)";	}	boolean exists = file.exists();	boolean updated;	updated = updateTitles(file, docTitle);	updated |= updateAvailableFrom(file, model.getFirstVersion());	String options = templateLanguageOptions(model);	updated |= updateLanguageOptions(file, options);	if (updated) {	
updated doc file 

docTitle += " (deprecated)";	}	boolean exists = file.exists();	boolean updated;	updated = updateTitles(file, docTitle);	updated |= updateAvailableFrom(file, model.getFirstVersion());	String options = templateLanguageOptions(model);	updated |= updateLanguageOptions(file, options);	if (updated) {	} else if (exists) {	
no changes to doc file 

}	boolean exists = file.exists();	boolean updated;	updated = updateTitles(file, docTitle);	updated |= updateAvailableFrom(file, model.getFirstVersion());	String options = templateLanguageOptions(model);	updated |= updateLanguageOptions(file, options);	if (updated) {	} else if (exists) {	} else {	
no language doc file 

if (!currentDir.endsWith("camel-core")) {	return;	}	final Set<File> jsonFiles = new TreeSet<File>();	File coreDir = new File(".");	if (coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes/org/apache/camel/model");	PackageHelper.findJsonFiles(target, jsonFiles, new PackageHelper.CamelComponentsModelFilter());	}	if (!jsonFiles.isEmpty()) {	
found eips 

boolean deprecated = model.isDeprecated();	if (deprecated) {	docTitle += " (deprecated)";	}	boolean exists = file.exists();	boolean updated;	updated = updateTitles(file, docTitle);	String options = templateEipOptions(model);	updated |= updateEipOptions(file, options);	if (updated) {	
updated doc file 

if (deprecated) {	docTitle += " (deprecated)";	}	boolean exists = file.exists();	boolean updated;	updated = updateTitles(file, docTitle);	String options = templateEipOptions(model);	updated |= updateEipOptions(file, options);	if (updated) {	} else if (exists) {	
no changes to doc file 

docTitle += " (deprecated)";	}	boolean exists = file.exists();	boolean updated;	updated = updateTitles(file, docTitle);	String options = templateEipOptions(model);	updated |= updateEipOptions(file, options);	if (updated) {	} else if (exists) {	} else {	
no eip doc file 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
cannot find markers in file 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
add the following markers 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
t getlog warn 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
cannot find markers in file 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
add the following markers 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
t getlog warn 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
cannot find markers in file 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
add the following markers 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
t getlog warn 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
cannot find markers in file 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
add the following markers 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
t getlog warn 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
cannot find markers in file 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
add the following markers 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
t getlog warn 

desc = option.getDescription();	if (!desc.endsWith(".")) {	desc = desc + ". Deprecation note: " + option.getDeprecationNote();	} else {	desc = desc + " Deprecation note: " + option.getDeprecationNote();	}	option.setDescription(desc);	}	}	if ("id".equals(option.getName())) {	
skipping option 

desc = option.getDescription();	if (!desc.endsWith(".")) {	desc = desc + ". Deprecation note: " + option.getDeprecationNote();	} else {	desc = desc + " Deprecation note: " + option.getDeprecationNote();	}	option.setDescription(desc);	}	}	if ("id".equals(option.getName()) || "expression".equals(option.getName())) {	
skipping option 

desc = option.getDescription();	if (!desc.endsWith(".")) {	desc = desc + ". Deprecation note: " + option.getDeprecationNote();	} else {	desc = desc + " Deprecation note: " + option.getDeprecationNote();	}	option.setDescription(desc);	}	}	if ("id".equals(option.getName()) || "description".equals(option.getName()) || "expression".equals(option.getName()) || "outputs".equals(option.getName())) {	
skipping option 

========================= camel sample_121 =========================

private void afterBeanDiscovery(@Observes AfterBeanDiscovery abd, BeanManager manager) {	Set<SyntheticBean<?>> extraBeans = new HashSet<>();	for (ImportResource resource : resources) {	XmlCdiBeanFactory factory = XmlCdiBeanFactory.with(manager, environment, this);	for (String path : resource.value()) {	try {	extraBeans.addAll(factory.beansFrom(path));	} catch (NoClassDefFoundError cause) {	if (cause.getMessage().contains("AbstractCamelContextFactoryBean")) {	
importing camel xml requires to have the camel core xml dependency in the classpath 

return;	}	}	eagerBeans.forEach(type -> getReferencesByType(manager, type.getJavaClass(), ANY).toString());	manager.getBeans(Object.class, ANY, STARTUP) .forEach(bean -> getReference(manager, bean.getBeanClass(), bean).toString());	if (configuration.autoStartContexts()) {	for (CamelContext context : contexts) {	if (ServiceStatus.Started.equals(context.getStatus())) {	continue;	}	
camel cdi is starting camel context 

========================= camel sample_9925 =========================

public void mapToMessage(Input input, Message output) throws Exception {	Node node;	boolean removeSignatureElements = false;	if (OUTPUT_NODE_SEARCH_TYPE_DEFAULT.equals(input.getOutputNodeSearchType())) {	
searching for output node via default search 

node = input.getMessageBodyDocument().getDocumentElement();	removeSignatureElements = true;	}	} else if (OUTPUT_NODE_SEARCH_TYPE_ELEMENT_NAME.equals(input.getOutputNodeSearchType())) {	node = getOutputElementViaLocalNameAndNamespace(input);	} else if (OUTPUT_NODE_SEARCH_TYPE_XPATH.equals(input.getOutputNodeSearchType())) {	node = getOutputNodeViaXPath(input);	} else {	throw new XmlSignatureException(String.format("Wrong configuration: The output node search type %s is not supported.", input.getOutputNodeSearchType()));	}	
output node with local name and namespace found 

protected void checkSearchValueNotNull(Input input) throws Exception {	
searching for output element with search value and sarch type 

protected String getSameDocumentReferenceUri(Reference ref) {	String refUri = ref.getURI();	if (refUri == null) {	
ignoring reference which has no uri 

protected String getSameDocumentReferenceUri(Reference ref) {	String refUri = ref.getURI();	if (refUri == null) {	return null;	}	if (!refUri.startsWith("#")) {	
ignoring non same document reference 

========================= camel sample_6783 =========================

private static void run(String id) {	try {	int events = ThreadLocalRandom.current().nextInt(2, 6);	CountDownLatch contextLatch = new CountDownLatch(events);	ConsulClusterService service = new ConsulClusterService();	service.setId("node-" + id);	
http logger info service geturl 

context.setName("context-" + id);	context.addService(service);	context.addRoutes(new RouteBuilder() {	public void configure() throws Exception {	from("timer:consul?delay=1s&period=1s") .routeId("route-" + id) .routePolicy(ClusteredRoutePolicy.forNamespace("my-ns")) .log("From ${routeId}") .process(e -> contextLatch.countDown());	}	});	Thread.sleep(ThreadLocalRandom.current().nextInt(500));	context.start();	contextLatch.await();	
shutting down node 

========================= camel sample_14345 =========================

public int commit(final DefaultSqlEndpoint endpoint, final Exchange exchange, final Object data, final JdbcTemplate jdbcTemplate, final String query) throws Exception {	final String preparedQuery = sqlPrepareStatementStrategy.prepareQuery(query, endpoint.isAllowNamedParameters(), exchange);	return jdbcTemplate.execute(preparedQuery, new PreparedStatementCallback<Integer>() {	public Integer doInPreparedStatement(PreparedStatement ps) throws SQLException {	int expected = ps.getParameterMetaData().getParameterCount();	Iterator<?> iterator = sqlPrepareStatementStrategy.createPopulateIterator(query, preparedQuery, expected, exchange, data);	if (iterator != null) {	sqlPrepareStatementStrategy.populateStatement(ps, iterator, expected);	
execute query 

final String preparedQuery = sqlPrepareStatementStrategy.prepareQuery(query, endpoint.isAllowNamedParameters(), exchange);	return jdbcTemplate.execute(preparedQuery, new PreparedStatementCallback<Integer>() {	public Integer doInPreparedStatement(PreparedStatement ps) throws SQLException {	int expected = ps.getParameterMetaData().getParameterCount();	Iterator<?> iterator = sqlPrepareStatementStrategy.createPopulateIterator(query, preparedQuery, expected, exchange, data);	if (iterator != null) {	sqlPrepareStatementStrategy.populateStatement(ps, iterator, expected);	ps.execute();	int updateCount = ps.getUpdateCount();	if (LOG.isTraceEnabled()) {	
update count 

public int commitBatchComplete(final DefaultSqlEndpoint endpoint, final JdbcTemplate jdbcTemplate, final String query) throws Exception {	final String preparedQuery = sqlPrepareStatementStrategy.prepareQuery(query, endpoint.isAllowNamedParameters(), null);	return jdbcTemplate.execute(preparedQuery, new PreparedStatementCallback<Integer>() {	public Integer doInPreparedStatement(PreparedStatement ps) throws SQLException {	int expected = ps.getParameterMetaData().getParameterCount();	if (expected != 0) {	throw new IllegalArgumentException("Query onConsumeBatchComplete " + query + " cannot have parameters, was " + expected);	}	
execute query 

final String preparedQuery = sqlPrepareStatementStrategy.prepareQuery(query, endpoint.isAllowNamedParameters(), null);	return jdbcTemplate.execute(preparedQuery, new PreparedStatementCallback<Integer>() {	public Integer doInPreparedStatement(PreparedStatement ps) throws SQLException {	int expected = ps.getParameterMetaData().getParameterCount();	if (expected != 0) {	throw new IllegalArgumentException("Query onConsumeBatchComplete " + query + " cannot have parameters, was " + expected);	}	ps.execute();	int updateCount = ps.getUpdateCount();	if (LOG.isTraceEnabled()) {	
update count 

========================= camel sample_9026 =========================

contentType = exchange.getIn().getHeader(CONTENT_TYPE, String.class);	if (contentType == null) {	return stream;	}	try {	ContentType ct = new ContentType(contentType);	if (!ct.match("multipart/*")) {	return stream;	}	} catch (ParseException e) {	
invalid content type ignored 

bos.close();	}	DataHandler dh;	try {	dh = mimeMessage.getDataHandler();	if (dh != null) {	content = dh.getContent();	contentType = dh.getContentType();	}	} catch (MessagingException e) {	
cannot parse message no unmarshalling done 

contentType = bp.getContentType();	if (contentType != null && !DEFAULT_CONTENT_TYPE.equals(contentType)) {	camelMessage.setHeader(CONTENT_TYPE, contentType);	ContentType ct = new ContentType(contentType);	String charset = ct.getParameter("charset");	if (charset != null) {	camelMessage.setHeader(Exchange.CONTENT_ENCODING, MimeUtility.javaCharset(charset));	}	}	} else {	
no mime part found 

========================= camel sample_11901 =========================

public void testList() throws Exception {	File testFile = uploadTestFile();	String fileId = testFile.getId();	final com.google.api.services.drive.model.PropertyList result = requestBody("direct: assertNotNull("list result", result);	
list 

========================= camel sample_15411 =========================

public static void main(String[] args) throws Exception {	
about to run kafka camel integration 

public static void main(String[] args) throws Exception {	CamelContext camelContext = new DefaultCamelContext();	camelContext.addRoutes(new RouteBuilder() {	public void configure() {	PropertiesComponent pc = getContext().getComponent("properties", PropertiesComponent.class);	pc.setLocation("classpath:application.properties");	
about to start route kafka server log 

========================= camel sample_17586 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<HdfsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hdfs.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hdfs.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_434 =========================

public abstract void run(Runnable runnable) throws Throwable;	public Processor wrap(RouteContext routeContext, Processor processor) {	JtaTransactionErrorHandler answer;	ErrorHandlerBuilder builder = (ErrorHandlerBuilder) routeContext.getRoute().getErrorHandlerBuilder();	if (builder instanceof ErrorHandlerBuilderRef) {	ErrorHandlerBuilderRef builderRef = (ErrorHandlerBuilderRef) builder;	String ref = builderRef.getRef();	if (ErrorHandlerBuilderRef.isErrorHandlerBuilderConfigured(ref)) {	
looking up errorhandlerbuilder with ref 

String ref = builderRef.getRef();	if (ErrorHandlerBuilderRef.isErrorHandlerBuilderConfigured(ref)) {	builder = (ErrorHandlerBuilder) ErrorHandlerBuilderRef.lookupErrorHandlerBuilder(routeContext, ref);	}	}	JtaTransactionErrorHandlerBuilder txBuilder;	if ((builder != null) && builder.supportTransacted()) {	if (!(builder instanceof JtaTransactionErrorHandlerBuilder)) {	throw new RuntimeCamelException("The given transactional error handler builder '" + builder + "' is not of type '" + JtaTransactionErrorHandlerBuilder.class.getName() + "' which is required in this environment!");	}	
the errorhandlerbuilder configured is a jtatransactionerrorhandlerbuilder 

builder = (ErrorHandlerBuilder) ErrorHandlerBuilderRef.lookupErrorHandlerBuilder(routeContext, ref);	}	}	JtaTransactionErrorHandlerBuilder txBuilder;	if ((builder != null) && builder.supportTransacted()) {	if (!(builder instanceof JtaTransactionErrorHandlerBuilder)) {	throw new RuntimeCamelException("The given transactional error handler builder '" + builder + "' is not of type '" + JtaTransactionErrorHandlerBuilder.class.getName() + "' which is required in this environment!");	}	txBuilder = (JtaTransactionErrorHandlerBuilder) builder.cloneBuilder();	} else {	
no or no transactional errorhandlerbuilder configured will use default jtatransactionerrorhandlerbuilder settings 

========================= camel sample_9860 =========================

public void testLoadTestLevelDBAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.setResultWaitTime(50 * 1000);	
staring to send messages 

public void testLoadTestLevelDBAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.setResultWaitTime(50 * 1000);	for (int i = 0; i < SIZE; i++) {	final int value = 1;	char id = 'A';	
sending with id 

public void testLoadTestLevelDBAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.setResultWaitTime(50 * 1000);	for (int i = 0; i < SIZE; i++) {	final int value = 1;	char id = 'A';	template.sendBodyAndHeader("seda:start?size=" + SIZE, value, "id", "" + id);	}	
sending all message done now waiting for aggregation to complete 

========================= camel sample_13896 =========================

public Message toCamelMessage(Request request, Exchange exchange, SparkConfiguration configuration) throws Exception {	
tocamelmessage 

public void toSparkResponse(Message message, Response response, SparkConfiguration configuration) throws Exception {	
tosparkresponse 

public void toSparkResponse(Message message, Response response, SparkConfiguration configuration) throws Exception {	boolean failed = message.getExchange().isFailed();	int defaultCode = failed ? 500 : 200;	int code = message.getHeader(Exchange.HTTP_RESPONSE_CODE, defaultCode, int.class);	response.status(code);	
http status code 

String headerValue = tc.convertTo(String.class, it.next());	if (headerValue != null && headerFilterStrategy != null && !headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, message.getExchange())) {	LOG.trace("HTTP-Header: {}={}", key, headerValue);	response.header(key, headerValue);	}	}	}	String contentType = MessageHelper.getContentType(message);	if (contentType != null) {	response.header(Exchange.CONTENT_TYPE, contentType);	
content type 

========================= camel sample_7612 =========================

public void setUp() throws Exception {	log.info("*******************************************************************");	
test 

========================= camel sample_12511 =========================

server = new Server(PORT);	port = PORT;	ServletContextHandler servletContext = new ServletContextHandler(ServletContextHandler.SESSIONS);	servletContext.setSecurityHandler(basicAuth("camel", "camelPass", "Private!"));	servletContext.setContextPath("/");	server.setHandler(servletContext);	servletContext.addServlet(new ServletHolder(new MyHttpServlet()), "/*");	try {	server.start();	} catch (Exception ex) {	
could not start server 

public void stopServer() {	if (server != null) {	try {	server.stop();	} catch (Exception ex) {	
server doesn t stop normal 

========================= camel sample_7242 =========================

public static void main(String[] args) throws Exception {	try {	overrideLoggingConfig();	SpringApplication.run(ITestApplication.class, args);	} catch (Throwable t) {	
error while executing test 

========================= camel sample_6003 =========================

public List<ServiceDefinition> getServices(String name) {	
discovering endpoints from namespace with name 

public List<ServiceDefinition> getServices(String name) {	Endpoints endpoints = client.endpoints().inNamespace(getNamespace()).withName(name).get();	List<ServiceDefinition> result = new ArrayList<>();	if (endpoints != null) {	if (LOG.isDebugEnabled()) {	
found endpoints in namespace for name and portname 

========================= camel sample_13300 =========================

context.addService(service);	context.addRoutePolicyFactory(ClusteredRoutePolicyFactory.forNamespace("my-ns"));	context.addRoutes(new RouteBuilder() {	public void configure() throws Exception {	from("timer:file-lock?delay=1s&period=1s") .routeId("route-" + id) .log("From ${routeId}") .process(e -> contextLatch.countDown());	}	});	Thread.sleep(ThreadLocalRandom.current().nextInt(500));	context.start();	contextLatch.await();	
shutting down node 

========================= camel sample_2943 =========================

if (!getEndpoint().isUsePersist()) {	exchange.getIn().setBody(managedEntity);	}	}	if (getEndpoint().isFlushOnSend()) {	entityManager.flush();	}	return null;	}	private Object save(final Object entity) {	
save 

}	private Object save(final Object entity) {	if (getEndpoint().isUsePersist()) {	entityManager.persist(entity);	return entity;	} else {	return entityManager.merge(entity);	}	}	private Object remove(final Object entity) {	
remove 

========================= camel sample_14095 =========================

protected void doStart() throws Exception {	
starting kafka consumer on topic with breakonfirsterror 

protected void doStop() throws Exception {	
stopping kafka consumer on topic 

public void run() {	boolean first = true;	boolean reConnect = true;	while (reConnect) {	try {	if (!first) {	doInit();	}	} catch (Throwable e) {	
error creating org apache kafka clients consumer kafkaconsumer due 

boolean reConnect = true;	while (reConnect) {	try {	if (!first) {	doInit();	}	} catch (Throwable e) {	}	if (!first) {	long delay = endpoint.getConfiguration().getPollTimeoutMs();	
reconnecting to topic after ms 

protected boolean doRun() {	boolean reConnect = false;	boolean unsubscribing = false;	try {	if (topicPattern != null) {	
subscribing to topic pattern 

protected boolean doRun() {	boolean reConnect = false;	boolean unsubscribing = false;	try {	if (topicPattern != null) {	consumer.subscribe(topicPattern, this);	} else {	
subscribing to topic 

} else {	consumer.subscribe(Arrays.asList(topicName.split(",")));	}	StateRepository<String, String> offsetRepository = endpoint.getConfiguration().getOffsetRepository();	if (offsetRepository != null) {	ConsumerRecords poll = consumer.poll(100);	for (TopicPartition topicPartition : (Set<TopicPartition>) consumer.assignment()) {	String offsetState = offsetRepository.getState(serializeOffsetKey(topicPartition));	if (offsetState != null && !offsetState.isEmpty()) {	long offset = deserializeOffsetValue(offsetState) + 1;	
resuming partition from offset from state 

ConsumerRecords poll = consumer.poll(100);	for (TopicPartition topicPartition : (Set<TopicPartition>) consumer.assignment()) {	String offsetState = offsetRepository.getState(serializeOffsetKey(topicPartition));	if (offsetState != null && !offsetState.isEmpty()) {	long offset = deserializeOffsetValue(offsetState) + 1;	consumer.seek(topicPartition, offset);	} else {	List<ConsumerRecord<Object, Object>> partitionRecords = poll.records(topicPartition);	if (!partitionRecords.isEmpty()) {	long offset = partitionRecords.get(0).offset();	
resuming partition from offset 

} else {	List<ConsumerRecord<Object, Object>> partitionRecords = poll.records(topicPartition);	if (!partitionRecords.isEmpty()) {	long offset = partitionRecords.get(0).offset();	consumer.seek(topicPartition, offset);	}	}	}	} else if (endpoint.getConfiguration().getSeekTo() != null) {	if (endpoint.getConfiguration().getSeekTo().equals("beginning")) {	
is seeking to the beginning on topic 

long offset = partitionRecords.get(0).offset();	consumer.seek(topicPartition, offset);	}	}	}	} else if (endpoint.getConfiguration().getSeekTo() != null) {	if (endpoint.getConfiguration().getSeekTo().equals("beginning")) {	consumer.poll(100);	consumer.seekToBeginning(consumer.assignment());	} else if (endpoint.getConfiguration().getSeekTo().equals("end")) {	
is seeking to the end on topic 

if (endpoint.getConfiguration().getSeekTo().equals("beginning")) {	consumer.poll(100);	consumer.seekToBeginning(consumer.assignment());	} else if (endpoint.getConfiguration().getSeekTo().equals("end")) {	consumer.poll(100);	consumer.seekToEnd(consumer.assignment());	}	}	while (isRunAllowed() && !reConnect && !isStoppingOrStopped() && !isSuspendingOrSuspended()) {	boolean breakOnErrorHit = false;	
polling from topic with timeout 

KafkaManualCommit manual = endpoint.getComponent().getKafkaManualCommitFactory().newInstance(exchange, consumer, topicName, threadId, offsetRepository, partition, partitionLastOffset);	exchange.getIn().setHeader(KafkaConstants.MANUAL_COMMIT, manual);	}	try {	processor.process(exchange);	} catch (Exception e) {	exchange.setException(e);	}	if (exchange.getException() != null) {	if (endpoint.getConfiguration().isBreakOnFirstError()) {	
error during processing from topic will seek consumer to offset and re connect and start polling again 

}	}	}	if (breakOnErrorHit) {	reConnect = true;	}	}	if (!reConnect) {	if (isAutoCommitEnabled()) {	if ("async".equals(endpoint.getConfiguration().getAutoCommitOnStop())) {	
auto commitasync on stop from topic 

}	if (breakOnErrorHit) {	reConnect = true;	}	}	if (!reConnect) {	if (isAutoCommitEnabled()) {	if ("async".equals(endpoint.getConfiguration().getAutoCommitOnStop())) {	consumer.commitAsync();	} else if ("sync".equals(endpoint.getConfiguration().getAutoCommitOnStop())) {	
auto commitsync on stop from topic 

}	if (!reConnect) {	if (isAutoCommitEnabled()) {	if ("async".equals(endpoint.getConfiguration().getAutoCommitOnStop())) {	consumer.commitAsync();	} else if ("sync".equals(endpoint.getConfiguration().getAutoCommitOnStop())) {	consumer.commitSync();	}	}	}	
unsubscribing from topic 

consumer.commitAsync();	} else if ("sync".equals(endpoint.getConfiguration().getAutoCommitOnStop())) {	consumer.commitSync();	}	}	}	unsubscribing = true;	consumer.unsubscribe();	} catch (InterruptException e) {	getExceptionHandler().handleException("Interrupted while consuming " + threadId + " from kafka topic", e);	
unsubscribing from topic 

unsubscribing = true;	consumer.unsubscribe();	} catch (InterruptException e) {	getExceptionHandler().handleException("Interrupted while consuming " + threadId + " from kafka topic", e);	consumer.unsubscribe();	Thread.currentThread().interrupt();	} catch (KafkaException e) {	if (unsubscribing) {	getExceptionHandler().handleException("Error unsubscribing " + threadId + " from kafka topic " + topicName, e);	} else {	
kafkaexception consuming from topic will attempt to re connect on next run 

Thread.currentThread().interrupt();	} catch (KafkaException e) {	if (unsubscribing) {	getExceptionHandler().handleException("Error unsubscribing " + threadId + " from kafka topic " + topicName, e);	} else {	reConnect = true;	}	} catch (Exception e) {	getExceptionHandler().handleException("Error consuming " + threadId + " from kafka topic", e);	} finally {	
closing 

private void commitOffset(StateRepository<String, String> offsetRepository, TopicPartition partition, long partitionLastOffset, boolean forceCommit) {	if (partitionLastOffset != -1) {	if (offsetRepository != null) {	
saving offset repository state from topic with offset 

private void commitOffset(StateRepository<String, String> offsetRepository, TopicPartition partition, long partitionLastOffset, boolean forceCommit) {	if (partitionLastOffset != -1) {	if (offsetRepository != null) {	offsetRepository.setState(serializeOffsetKey(partition), serializeOffsetValue(partitionLastOffset));	} else if (forceCommit) {	
forcing commitsync from topic with offset 

private void commitOffset(StateRepository<String, String> offsetRepository, TopicPartition partition, long partitionLastOffset, boolean forceCommit) {	if (partitionLastOffset != -1) {	if (offsetRepository != null) {	offsetRepository.setState(serializeOffsetKey(partition), serializeOffsetValue(partitionLastOffset));	} else if (forceCommit) {	consumer.commitSync(Collections.singletonMap(partition, new OffsetAndMetadata(partitionLastOffset + 1)));	} else if (endpoint.getConfiguration().isAutoCommitEnable() != null && !endpoint.getConfiguration().isAutoCommitEnable()) {	
auto commitsync from topic with offset 

public void onPartitionsRevoked(Collection<TopicPartition> partitions) {	
onpartitionsrevoked from topic 

public void onPartitionsRevoked(Collection<TopicPartition> partitions) {	StateRepository<String, String> offsetRepository = endpoint.getConfiguration().getOffsetRepository();	if (offsetRepository != null) {	for (TopicPartition partition : partitions) {	long offset = consumer.position(partition);	
saving offset repository state from topic with offset 

public void onPartitionsAssigned(Collection<TopicPartition> partitions) {	
onpartitionsassigned from topic 

public void onPartitionsAssigned(Collection<TopicPartition> partitions) {	StateRepository<String, String> offsetRepository = endpoint.getConfiguration().getOffsetRepository();	if (offsetRepository != null) {	for (TopicPartition partition : partitions) {	String offsetState = offsetRepository.getState(serializeOffsetKey(partition));	if (offsetState != null && !offsetState.isEmpty()) {	long offset = deserializeOffsetValue(offsetState) + 1;	
resuming partition from offset from state 

========================= camel sample_16417 =========================

public void index(Exchange exchange) throws Exception {	
indexing 

private void add(String field, String value, boolean analyzed) throws IOException {	if (LOG.isTraceEnabled()) {	
adding field 

private void add(String field, String value, boolean analyzed) throws IOException {	if (LOG.isTraceEnabled()) {	
value 

private void add(File file) throws IOException {	if (file.canRead()) {	if (file.isDirectory()) {	String[] files = file.list();	if (files != null) {	for (String child : files) {	add(new File(file.getAbsolutePath() + "/" + child));	}	}	} else {	
adding 

if (files != null) {	for (String child : files) {	add(new File(file.getAbsolutePath() + "/" + child));	}	}	} else {	openIndexWriter();	add("path", file.getPath(), false);	add("contents", new String(IOConverter.toByteArray(file)), true);	closeIndexWriter();	
added successfully 

add(new File(file.getAbsolutePath() + "/" + child));	}	}	} else {	openIndexWriter();	add("path", file.getPath(), false);	add("contents", new String(IOConverter.toByteArray(file)), true);	closeIndexWriter();	}	} else {	
directory file could not be read this directory will not be indexed please check permissions and rebuild indexes 

========================= camel sample_6845 =========================

if (ftpClientConfig == null) {	ftpClientConfig = new FTPClientConfig();	}	Map<String, Object> localConfigParameters = new HashMap<String, Object>(ftpClientConfigParameters);	setProperties(ftpClientConfig, localConfigParameters);	}	if (dataTimeout > 0) {	client.setDataTimeout(dataTimeout);	}	if (log.isDebugEnabled()) {	
created ftpclient connecttimeout sotimeout datatimeout buffersize receivedatasocketbuffersize senddatasocketbuffersize 

========================= camel sample_15391 =========================

exp = getEndpoint().getLanguage().createExpression(script);	getEndpoint().setContentResolvedFromResource(true);	if (getEndpoint().isCacheScript()) {	getEndpoint().setExpression(exp);	}	}	Object result;	if (exp != null) {	try {	result = exp.evaluate(exchange, Object.class);	
evaluated expression as with 

========================= camel sample_4878 =========================

public void testQuartz() throws Exception {	resultEndpoint = getMockEndpoint("mock:result");	resultEndpoint.expectedMessageCount(2);	resultEndpoint.message(0).header("triggerName").isEqualTo("myTimerName");	resultEndpoint.message(0).header("triggerGroup").isEqualTo("myGroup");	resultEndpoint.assertIsSatisfied();	List<Exchange> list = resultEndpoint.getReceivedExchanges();	for (Exchange exchange : list) {	Message in = exchange.getIn();	
received with headers 

========================= camel sample_14979 =========================

private void dispatchExchange(Object response) throws CamelException {	
consumer dispatching the received notification along the route 

public void processRequest(RequestEvent requestReceivedEvent) {	Request request = requestReceivedEvent.getRequest();	ServerTransaction serverTransactionId = requestReceivedEvent .getServerTransaction();	String viaBranch = ((ViaHeader)(request.getHeaders(ViaHeader.NAME).next())).getParameter("branch");	
request 

public void processRequest(RequestEvent requestReceivedEvent) {	Request request = requestReceivedEvent.getRequest();	ServerTransaction serverTransactionId = requestReceivedEvent .getServerTransaction();	String viaBranch = ((ViaHeader)(request.getHeaders(ViaHeader.NAME).next())).getParameter("branch");	
server transaction id 

public void processRequest(RequestEvent requestReceivedEvent) {	Request request = requestReceivedEvent.getRequest();	ServerTransaction serverTransactionId = requestReceivedEvent .getServerTransaction();	String viaBranch = ((ViaHeader)(request.getHeaders(ViaHeader.NAME).next())).getParameter("branch");	
received from branch 

public synchronized void processNotify(RequestEvent requestEvent, ServerTransaction serverTransactionId) {	
notification received at subscriber 

public synchronized void processNotify(RequestEvent requestEvent, ServerTransaction serverTransactionId) {	SipProvider provider = (SipProvider) requestEvent.getSource();	Request notify = requestEvent.getRequest();	try {	if (serverTransactionId == null) {	
servertransaction is null creating new server transaction 

Dialog dialog = serverTransactionId.getDialog();	if (dialog != subscriberDialog) {	forkedDialog = dialog;	}	dispatchExchange(notify.getContent());	Response response = sipSubscriber.getConfiguration().getMessageFactory().createResponse(200, notify);	response.addHeader(sipSubscriber.getConfiguration().getContactHeader());	serverTransactionId.sendResponse(response);	SubscriptionStateHeader subscriptionState = (SubscriptionStateHeader) notify .getHeader(SubscriptionStateHeader.NAME);	if (subscriptionState.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED)) {	
subscription state is terminated deleting the current dialog 

}	dispatchExchange(notify.getContent());	Response response = sipSubscriber.getConfiguration().getMessageFactory().createResponse(200, notify);	response.addHeader(sipSubscriber.getConfiguration().getContactHeader());	serverTransactionId.sendResponse(response);	SubscriptionStateHeader subscriptionState = (SubscriptionStateHeader) notify .getHeader(SubscriptionStateHeader.NAME);	if (subscriptionState.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED)) {	dialog.delete();	}	} catch (Exception e) {	
exception thrown during notify processing in the sipsubscriptionlistener 

public void processResponse(ResponseEvent responseReceivedEvent) {	
response received at subscriber 

public void processResponse(ResponseEvent responseReceivedEvent) {	Response response = responseReceivedEvent.getResponse();	Transaction clientTransactionId = responseReceivedEvent.getClientTransaction();	
response received with client transaction id 

public void processResponse(ResponseEvent responseReceivedEvent) {	Response response = responseReceivedEvent.getResponse();	Transaction clientTransactionId = responseReceivedEvent.getClientTransaction();	if (clientTransactionId == null) {	if (LOG.isWarnEnabled()) {	
stray response dropping 

public void processIOException(IOExceptionEvent exceptionEvent) {	if (LOG.isWarnEnabled()) {	
ioexceptionevent received at sip subscription listener 

public void processTransactionTerminated( TransactionTerminatedEvent transactionTerminatedEvent) {	if (LOG.isWarnEnabled()) {	
transactionterminatedevent received at sip subscription listener 

public void processTimeout(javax.sip.TimeoutEvent timeoutEvent) {	if (LOG.isWarnEnabled()) {	
timeoutevent received at sip subscription listener 

========================= camel sample_8508 =========================

public void testJaxrsAsyncRelayRoute() throws Exception {	final Main main = new Main();	try {	main.setApplicationContextUri("org/apache/camel/component/cxf/jaxrs/CxfRsSpringAsyncRelay.xml");	main.start();	Thread t = new Thread(new Runnable() {	public void run() {	try {	JAXRSClientFactory.create("http: .upload(CamelRouteBuilder.class.getResourceAsStream(SAMPLE_CONTENT_PATH), SAMPLE_NAME);	} catch (Exception e) {	
error uploading to http 

========================= camel sample_7887 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<SqlLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.sql.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.sql.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_567 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() {	getContext().setHandleFault(true);	
mock error 

========================= camel sample_2369 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<JCacheComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jcache.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jcache.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_588 =========================

public Optional<CamelClusterMember> getLeader() {	if (leaderSelector == null || isStoppingOrStopped()) {	return Optional.empty();	}	try {	Participant participant = leaderSelector.getLeader();	return ObjectHelper.equal(participant.getId(), localMember.getId()) ? Optional.of(localMember) : Optional.of(new CuratorClusterMember(participant));	} catch (KeeperException.NoNodeException e) {	
failed to get get master because node does not yet exist error 

public List<CamelClusterMember> getMembers() {	if (leaderSelector == null) {	return Collections.emptyList();	}	try {	return leaderSelector.getParticipants() .stream() .map(CuratorClusterMember::new) .collect(Collectors.toList());	} catch (KeeperException.NoNodeException e) {	
failed to get members because node does not yet exist error 

========================= camel sample_12638 =========================

public Consumer createConsumer(CamelContext camelContext, Processor processor, String verb, String basePath, String uriTemplate, String consumes, String produces, RestConfiguration configuration, Map<String, Object> parameters) throws Exception {	RestConfiguration config = configuration;	if (config == null) {	config = getCamelContext().getRestConfiguration("coap", true);	}	if (config.isEnableCORS()) {	
cors configuration will be ignored as cors is not supported by the coap component 

========================= camel sample_16381 =========================

MockEndpoint mockEndpoint = resolveMandatoryEndpoint("mock:results", MockEndpoint.class);	mockEndpoint.expectedMessageCount(1);	template.sendBody("direct:start", null);	mockEndpoint.assertIsSatisfied();	List<Exchange> list = mockEndpoint.getReceivedExchanges();	Exchange exchange = list.get(0);	assertNotNull("exchange", exchange);	Message in = exchange.getIn();	assertNotNull("in", in);	Map<String, Object> headers = in.getHeaders();	
headers 

template.sendBody("direct:start", null);	mockEndpoint.assertIsSatisfied();	List<Exchange> list = mockEndpoint.getReceivedExchanges();	Exchange exchange = list.get(0);	assertNotNull("exchange", exchange);	Message in = exchange.getIn();	assertNotNull("in", in);	Map<String, Object> headers = in.getHeaders();	checkHeaders(headers);	String body = in.getBody(String.class);	
body 

========================= camel sample_12815 =========================

public boolean process(Exchange exchange, AsyncCallback callback) {	try {	Request request = getEndpoint().getBinding().prepareRequest(getEndpoint(), exchange);	
executing request 

public void onThrowable(Throwable t) {	if (log.isTraceEnabled()) {	
onthrowable 

public Exchange onCompleted() throws Exception {	if (log.isTraceEnabled()) {	
oncompleted 

public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {	os.write(bodyPart.getBodyPartBytes());	if (log.isTraceEnabled()) {	
onbodypartreceived bytes 

public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {	if (log.isTraceEnabled()) {	
onstatusreceived 

public State onHeadersReceived(HttpResponseHeaders headers) throws Exception {	if (log.isTraceEnabled()) {	
onheadersreceived 

========================= camel sample_16505 =========================

public void setUp() throws Exception {	log.info("********************************************************************************");	
testing 

private void doSetUp() throws Exception {	
setup test 

}	pattern = isMockEndpointsAndSkip();	if (pattern != null) {	context.addRegisterEndpointCallback(new InterceptSendToMockEndpointStrategy(pattern, true));	}	context.getComponent("properties", PropertiesComponent.class);	postProcessTest();	if (isUseRouteBuilder()) {	RoutesBuilder[] builders = createRouteBuilders();	for (RoutesBuilder builder : builders) {	
using created route builder 

}	context.getComponent("properties", PropertiesComponent.class);	postProcessTest();	if (isUseRouteBuilder()) {	RoutesBuilder[] builders = createRouteBuilders();	for (RoutesBuilder builder : builders) {	context.addRoutes(builder);	}	boolean skip = "true".equalsIgnoreCase(System.getProperty("skipStartingCamelContext"));	if (skip) {	
skipping starting camelcontext as system property skipstartingcamelcontext is set to be true 

context.getComponent("properties", PropertiesComponent.class);	postProcessTest();	if (isUseRouteBuilder()) {	RoutesBuilder[] builders = createRouteBuilders();	for (RoutesBuilder builder : builders) {	context.addRoutes(builder);	}	boolean skip = "true".equalsIgnoreCase(System.getProperty("skipStartingCamelContext"));	if (skip) {	} else if (isUseAdviceWith()) {	
skipping starting camelcontext as isuseadvicewith is set to true 

for (RoutesBuilder builder : builders) {	context.addRoutes(builder);	}	boolean skip = "true".equalsIgnoreCase(System.getProperty("skipStartingCamelContext"));	if (skip) {	} else if (isUseAdviceWith()) {	} else {	startCamelContext();	}	} else {	
using route builder from the created context 

context.addRoutes(builder);	}	boolean skip = "true".equalsIgnoreCase(System.getProperty("skipStartingCamelContext"));	if (skip) {	} else if (isUseAdviceWith()) {	} else {	startCamelContext();	}	} else {	}	
routing rules are 

public void tearDown() throws Exception {	long time = watch.stop();	log.info("********************************************************************************");	
testing done 

public void tearDown() throws Exception {	long time = watch.stop();	log.info("********************************************************************************");	
took millis 

public void tearDown() throws Exception {	long time = watch.stop();	log.info("********************************************************************************");	log.info("********************************************************************************");	if (isCreateCamelContextPerClass()) {	return;	}	
teardown test 

public static void tearDownAfterClass() throws Exception {	INIT.remove();	
teardownafterclass test 

protected Context createJndiContext() throws Exception {	Properties properties = new Properties();	InputStream in = getClass().getClassLoader().getResourceAsStream("jndi.properties");	if (in != null) {	
using jndi properties from classpath root 

========================= camel sample_11690 =========================

protected void sendMessagesTo(String endpointName, int count) throws InterruptedException {	MockEndpoint mockEndpoint = resolveMandatoryEndpoint("mock:results", MockEndpoint.class);	mockEndpoint.expectedMessageCount(count);	for (int i = 0; i < count; i++) {	template.sendBody(endpointName, null);	}	mockEndpoint.assertIsSatisfied();	List<Exchange> list = mockEndpoint.getReceivedExchanges();	for (Exchange exchange : list) {	String body = exchange.getIn().getBody(String.class);	
body 

========================= camel sample_10982 =========================

ObjectHelper.notEmpty(message, "message", this);	Expression exp = routeContext.getCamelContext().resolveLanguage("simple").createExpression(message);	Logger logger = this.getLogger();	if (logger == null && ObjectHelper.isNotEmpty(loggerRef)) {	logger = CamelContextHelper.mandatoryLookup(routeContext.getCamelContext(), loggerRef, Logger.class);	}	if (logger == null) {	Map<String, Logger> availableLoggers = routeContext.lookupByType(Logger.class);	if (availableLoggers.size() == 1) {	logger = availableLoggers.values().iterator().next();	
using custom logger 

Expression exp = routeContext.getCamelContext().resolveLanguage("simple").createExpression(message);	Logger logger = this.getLogger();	if (logger == null && ObjectHelper.isNotEmpty(loggerRef)) {	logger = CamelContextHelper.mandatoryLookup(routeContext.getCamelContext(), loggerRef, Logger.class);	}	if (logger == null) {	Map<String, Logger> availableLoggers = routeContext.lookupByType(Logger.class);	if (availableLoggers.size() == 1) {	logger = availableLoggers.values().iterator().next();	} else if (availableLoggers.size() > 1) {	
more than one instance found in the registry falling back to create logger by name 

if (availableLoggers.size() == 1) {	logger = availableLoggers.values().iterator().next();	} else if (availableLoggers.size() > 1) {	}	}	if (logger == null) {	String name = getLogName();	if (name == null) {	name = routeContext.getCamelContext().getGlobalOption(Exchange.LOG_EIP_NAME);	if (name != null) {	
using logname from camelcontext properties 

}	if (logger == null) {	String name = getLogName();	if (name == null) {	name = routeContext.getCamelContext().getGlobalOption(Exchange.LOG_EIP_NAME);	if (name != null) {	}	}	if (name == null) {	name = routeContext.getRoute().getId();	
logname is not configured using route id as logname 

========================= camel sample_5228 =========================

private void writeSlowFile() throws Exception {	
writing slow file 

private void writeSlowFile() throws Exception {	createDirectory(FTP_ROOT_DIR + "/");	FileOutputStream fos = new FileOutputStream(FTP_ROOT_DIR + "/slowfile.dat", true);	for (int i = 0; i < 20; i++) {	fos.write(("Line " + i + LS).getBytes());	
writing line 

private void writeSlowFile() throws Exception {	createDirectory(FTP_ROOT_DIR + "/");	FileOutputStream fos = new FileOutputStream(FTP_ROOT_DIR + "/slowfile.dat", true);	for (int i = 0; i < 20; i++) {	fos.write(("Line " + i + LS).getBytes());	Thread.sleep(200);	}	fos.flush();	fos.close();	
writing slow file done 

========================= camel sample_15329 =========================

public void execute() throws MojoExecutionException, MojoFailureException {	CamelCatalog catalog = new DefaultCamelCatalog();	catalog.addComponent("activemq", "org.apache.activemq.camel.component.ActiveMQComponent");	catalog.setSuggestionStrategy(new LuceneSuggestionStrategy());	catalog.setVersionManager(new MavenVersionManager());	catalog.enableCache();	String detectedVersion = findCamelVersion(project);	if (detectedVersion != null) {	
detected camel version used in project 

catalog.setSuggestionStrategy(new LuceneSuggestionStrategy());	catalog.setVersionManager(new MavenVersionManager());	catalog.enableCache();	String detectedVersion = findCamelVersion(project);	if (detectedVersion != null) {	}	if (downloadVersion) {	String catalogVersion = catalog.getCatalogVersion();	String version = findCamelVersion(project);	if (version != null && !version.equals(catalogVersion)) {	
downloading camel version 

catalog.enableCache();	String detectedVersion = findCamelVersion(project);	if (detectedVersion != null) {	}	if (downloadVersion) {	String catalogVersion = catalog.getCatalogVersion();	String version = findCamelVersion(project);	if (version != null && !version.equals(catalogVersion)) {	boolean loaded = catalog.loadVersion(version);	if (!loaded) {	
error downloading camel version 

if (downloadVersion) {	String catalogVersion = catalog.getCatalogVersion();	String version = findCamelVersion(project);	if (version != null && !version.equals(catalogVersion)) {	boolean loaded = catalog.loadVersion(version);	if (!loaded) {	}	}	}	if (catalog.getLoadedVersion() != null) {	
validating using downloaded camel version 

String catalogVersion = catalog.getCatalogVersion();	String version = findCamelVersion(project);	if (version != null && !version.equals(catalogVersion)) {	boolean loaded = catalog.loadVersion(version);	if (!loaded) {	}	}	}	if (catalog.getLoadedVersion() != null) {	} else {	
validating using camel version 

RouteBuilderParser.parseRouteBuilderEndpoints(clazz, baseDir, fqn, fileEndpoints, unparsable, includeTest);	RouteBuilderParser.parseRouteBuilderSimpleExpressions(clazz, baseDir, fqn, fileSimpleExpressions);	if (duplicateRouteId) {	RouteBuilderParser.parseRouteBuilderRouteIds(clazz, baseDir, fqn, fileRouteIds);	}	endpoints.addAll(fileEndpoints);	simpleExpressions.addAll(fileSimpleExpressions);	routeIds.addAll(fileRouteIds);	if (logUnparseable && !unparsable.isEmpty()) {	for (String uri : unparsable) {	
cannot parse endpoint uri in java file 

}	endpoints.addAll(fileEndpoints);	simpleExpressions.addAll(fileSimpleExpressions);	routeIds.addAll(fileRouteIds);	if (logUnparseable && !unparsable.isEmpty()) {	for (String uri : unparsable) {	}	}	}	} catch (Exception e) {	
error parsing java file code due 

is.close();	if (duplicateRouteId) {	is = new FileInputStream(file);	XmlRouteParser.parseXmlRouteRouteIds(is, baseDir, fqn, fileRouteIds);	is.close();	}	endpoints.addAll(fileEndpoints);	simpleExpressions.addAll(fileSimpleExpressions);	routeIds.addAll(fileRouteIds);	} catch (Exception e) {	
error parsing xml file code due 

simpleExpressions.addAll(fileSimpleExpressions);	routeIds.addAll(fileRouteIds);	} catch (Exception e) {	}	}	}	int endpointErrors = 0;	int unknownComponents = 0;	int incapableErrors = 0;	for (CamelEndpointDetails detail : endpoints) {	
validating endpoint 

if (endpointErrors > 0) {	getLog().warn(endpointSummary);	} else {	getLog().info(endpointSummary);	}	int simpleErrors = 0;	for (CamelSimpleExpressionDetails detail : simpleExpressions) {	SimpleValidationResult result;	boolean predicate = detail.isPredicate();	if (predicate) {	
validating simple predicate 

} else {	getLog().info(endpointSummary);	}	int simpleErrors = 0;	for (CamelSimpleExpressionDetails detail : simpleExpressions) {	SimpleValidationResult result;	boolean predicate = detail.isPredicate();	if (predicate) {	result = catalog.validateSimplePredicate(detail.getSimple());	} else {	
validating simple expression 

========================= camel sample_69 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<EventComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.spring-event.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.spring-event.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_619 =========================

public void testProcessor() throws Exception {	StopWatch watch = new StopWatch();	for (int i = 0; i < size; i++) {	Object out = template.requestBody("direct:a", "" + i);	assertEquals("Bye " + i, out);	}	
processor took ms 

public void testBean() throws Exception {	StopWatch watch = new StopWatch();	for (int i = 0; i < size; i++) {	Object out = template.requestBody("direct:b", "" + i);	assertEquals("Bye " + i, out);	}	
bean took ms 

========================= camel sample_3313 =========================

private void listBlobs(Exchange exchange) throws Exception {	CloudBlobContainer client = BlobServiceUtil.createBlobContainerClient(getConfiguration());	BlobServiceRequestOptions opts = BlobServiceUtil.getRequestOptions(exchange);	
getting the blob list from the container from exchange 

private void updateBlockBlob(Exchange exchange) throws Exception {	CloudBlockBlob client = BlobServiceUtil.createBlockBlobClient(getConfiguration());	configureCloudBlobForWrite(client);	BlobServiceRequestOptions opts = BlobServiceUtil.getRequestOptions(exchange);	InputStream inputStream = getInputStreamFromExchange(exchange);	
putting a block blob from exchange 

blobBlocks = (List<BlobBlock>)blobBlocks;	} else if (object instanceof BlobBlock) {	blobBlocks = Collections.singletonList((BlobBlock)object);	}	if (blobBlocks == null || blobBlocks.isEmpty()) {	throw new IllegalArgumentException("Illegal storageBlocks payload");	}	CloudBlockBlob client = BlobServiceUtil.createBlockBlobClient(getConfiguration());	configureCloudBlobForWrite(client);	BlobServiceRequestOptions opts = BlobServiceUtil.getRequestOptions(exchange);	
putting a blob from blocks from exchange 

if (object instanceof List) {	blockEntries = (List<BlockEntry>)blockEntries;	} else if (object instanceof BlockEntry) {	blockEntries = Collections.singletonList((BlockEntry)object);	}	if (blockEntries == null || blockEntries.isEmpty()) {	throw new IllegalArgumentException("Illegal commit block list payload");	}	CloudBlockBlob client = BlobServiceUtil.createBlockBlobClient(getConfiguration());	BlobServiceRequestOptions opts = BlobServiceUtil.getRequestOptions(exchange);	
putting a blob block list from exchange 

private void getBlobBlockList(Exchange exchange) throws Exception {	CloudBlockBlob client = BlobServiceUtil.createBlockBlobClient(getConfiguration());	BlobServiceRequestOptions opts = BlobServiceUtil.getRequestOptions(exchange);	
getting the blob block list from exchange 

private void doCreateAppendBlob(CloudAppendBlob client, BlobServiceRequestOptions opts, Exchange exchange) throws Exception {	
creating an append blob from exchange 

private void doCreatePageBlob(CloudPageBlob client, BlobServiceRequestOptions opts, Exchange exchange) throws Exception {	
creating a page blob from exchange 

private void uploadPageBlob(Exchange exchange) throws Exception {	
updating a page blob from exchange 

private void resizePageBlob(Exchange exchange) throws Exception {	
resizing a page blob from exchange 

private void clearPageBlob(Exchange exchange) throws Exception {	
clearing a page blob from exchange 

private void getPageBlobRanges(Exchange exchange) throws Exception {	CloudPageBlob client = BlobServiceUtil.createPageBlobClient(getConfiguration());	BlobServiceUtil.configureCloudBlobForRead(client, getConfiguration());	BlobServiceRequestOptions opts = BlobServiceUtil.getRequestOptions(exchange);	
getting the page blob ranges from exchange 

private void doDeleteBlock(CloudBlob client, Exchange exchange) throws Exception {	
deleting a blob from exchange 

========================= camel sample_9964 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<TwilioComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.twilio.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.twilio.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_530 =========================

public Class<?> loadClass(String className) {	
loading class from classloader 

public URL loadResource(String uri) {	URL answer = null;	ClassLoader cl = Thread.currentThread().getContextClassLoader();	if (cl != null) {	
loading resource from classloader 

========================= camel sample_9437 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SchedulerComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.scheduler.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.scheduler.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_863 =========================

if ((seconds > 59) && foundFlag) {	throw new IllegalArgumentException("Seconds should contain a valid value between 0 and 59: " + source);	}	foundFlag = true;	milliseconds = milliseconds + (1000 * seconds);	}	if (!foundFlag) {	milliseconds = Long.valueOf(source);	}	}	
source milliseconds 

========================= camel sample_4205 =========================

public YqlResponse get(final YqlConfiguration yqlConfiguration) throws Exception {	final URI uri = new URIBuilder() .setScheme(yqlConfiguration.isHttps() ? "https" : "http") .setHost("query.yahooapis.com") .setPath("/v1/public/yql") .setParameters(buildParameters(yqlConfiguration)) .build();	
yql query 

public YqlResponse get(final YqlConfiguration yqlConfiguration) throws Exception {	final URI uri = new URIBuilder() .setScheme(yqlConfiguration.isHttps() ? "https" : "http") .setHost("query.yahooapis.com") .setPath("/v1/public/yql") .setParameters(buildParameters(yqlConfiguration)) .build();	final HttpGet httpget = new HttpGet(uri);	try (final CloseableHttpResponse response = httpClient.execute(httpget)) {	final YqlResponse yqlResponse = YqlResponse.builder() .httpRequest(uri.toString()) .status(response.getStatusLine().getStatusCode()) .body(EntityUtils.toString(response.getEntity())) .build();	
yql response 

========================= camel sample_9067 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<JBPMComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jbpm.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jbpm.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_926 =========================

connectionlessBootstrap.setOption("receiveBufferSizePredictorFactory", new FixedReceiveBufferSizePredictorFactory(configuration.getReceiveBufferSizePredictor()));	}	if (configuration.getBacklog() > 0) {	connectionlessBootstrap.setOption("backlog", configuration.getBacklog());	}	if (configuration.getOptions() != null) {	for (Map.Entry<String, Object> entry : configuration.getOptions().entrySet()) {	connectionlessBootstrap.setOption(entry.getKey(), entry.getValue());	}	}	
created connectionlessbootstrap with options 

}	}	connectionlessBootstrap.setPipelineFactory(pipelineFactory);	InetSocketAddress hostAddress = new InetSocketAddress(configuration.getHost(), configuration.getPort());	IpV4Subnet multicastSubnet = new IpV4Subnet(MULTICAST_SUBNET);	if (multicastSubnet.contains(configuration.getHost())) {	datagramChannel = (DatagramChannel)connectionlessBootstrap.bind(hostAddress);	String networkInterface = configuration.getNetworkInterface() == null ? LOOPBACK_INTERFACE : configuration.getNetworkInterface();	multicastNetworkInterface = NetworkInterface.getByName(networkInterface);	ObjectHelper.notNull(multicastNetworkInterface, "No network interface found for '" + networkInterface + "'.");	
connectionlessbootstrap joining using network interface 

InetSocketAddress hostAddress = new InetSocketAddress(configuration.getHost(), configuration.getPort());	IpV4Subnet multicastSubnet = new IpV4Subnet(MULTICAST_SUBNET);	if (multicastSubnet.contains(configuration.getHost())) {	datagramChannel = (DatagramChannel)connectionlessBootstrap.bind(hostAddress);	String networkInterface = configuration.getNetworkInterface() == null ? LOOPBACK_INTERFACE : configuration.getNetworkInterface();	multicastNetworkInterface = NetworkInterface.getByName(networkInterface);	ObjectHelper.notNull(multicastNetworkInterface, "No network interface found for '" + networkInterface + "'.");	datagramChannel.joinGroup(hostAddress, multicastNetworkInterface).syncUninterruptibly();	allChannels.add(datagramChannel);	} else {	
connectionlessbootstrap binding to 

protected void stopServerBootstrap() {	
connectionlessbootstrap disconnecting from 

protected void stopServerBootstrap() {	
closing channels 

========================= camel sample_6687 =========================

public void testGeoCoder() throws Exception {	GeoCoderEndpoint endpoint = context.getEndpoint( "geocoder:address:current?headersOnly=true&proxyHost=localhost&proxyPort=3128&proxyAuthMethod=Basic&proxyAuthUsername=proxy&proxyAuthPassword=proxy", GeoCoderEndpoint.class);	Geocoder geocoder = endpoint.createGeocoder();	GeocoderRequest req = new GeocoderRequest();	req.setLocation(new LatLng("45.4643", "9.1895"));	GeocodeResponse res = geocoder.geocode(req);	
response 

========================= camel sample_9572 =========================

});	sshd.setPublickeyAuthenticator(new PublickeyAuthenticator() {	public boolean authenticate(String username, PublicKey key, ServerSession session) {	return true;	}	});	try {	sshd.start();	return true;	} catch (IOException e) {	
failed to start ssh server 

protected void setupKnownHosts() {	knownHostsFile = SCP_ROOT_DIR + "/" + KNOWN_HOSTS;	if (!acceptLocalhostConnections) {	return;	}	JSch jsch = new JSch();	try {	
using for known hosts 

}	public boolean promptYesNo(String message) {	return true;	}	public void showMessage(String message) {	}	});	s.connect();	s.disconnect();	} catch (JSchException e) {	
could not add localhost to known hosts 

protected static void traceSecurityProviders() {	for (Provider p : Security.getProviders()) {	for (Service s : p.getServices()) {	
security provider for algorithm 

========================= camel sample_9122 =========================

public void decrement(Exchange exchange) {	
decrementing latch count 

========================= camel sample_10652 =========================

public HttpClientPipelineFactory(NettyHttpProducer nettyProducer) {	this.producer = nettyProducer;	try {	this.sslContext = createSSLContext(producer);	} catch (Exception e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	}	if (sslContext != null) {	
created sslcontext 

public ChannelPipeline getPipeline() throws Exception {	ChannelPipeline pipeline = Channels.pipeline();	SslHandler sslHandler = configureClientSSLOnDemand();	if (sslHandler != null) {	sslHandler.setCloseOnSSLException(true);	
client ssl handler configured and added as an interceptor against the channelpipeline 

List<ChannelHandler> encoders = producer.getConfiguration().getEncoders();	for (int x = 0; x < encoders.size(); x++) {	ChannelHandler encoder = encoders.get(x);	if (encoder instanceof ChannelHandlerFactory) {	encoder = ((ChannelHandlerFactory) encoder).newChannelHandler();	}	pipeline.addLast("encoder-" + x, encoder);	}	if (producer.getConfiguration().getRequestTimeout() > 0) {	if (LOG.isTraceEnabled()) {	
using request timeout millis 

private SSLContext createSSLContext(NettyProducer producer) throws Exception {	NettyConfiguration configuration = producer.getConfiguration();	if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(producer.getContext());	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	
keystorefile is null 

if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(producer.getContext());	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	
truststorefile is null 

}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(producer.getContext());	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	}	if (configuration.getPassphrase().toCharArray() == null) {	
passphrase is null 

========================= camel sample_8363 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<PrinterComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.lpr.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.lpr.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_475 =========================

int tmax = conf.getTmax();	if (message.getHeaders().containsKey(GangliaConstants.METRIC_TMAX)) {	tmax = message.getHeader(GangliaConstants.METRIC_TMAX, Integer.class);	}	int dmax = conf.getDmax();	if (message.getHeaders().containsKey(GangliaConstants.METRIC_DMAX)) {	dmax = message.getHeader(GangliaConstants.METRIC_DMAX, Integer.class);	}	String value = message.getBody(String.class);	if ((value == null || value.length() == 0) && (type == GMetricType.FLOAT || type == GMetricType.DOUBLE)) {	
metric string value was null using nan 

}	int dmax = conf.getDmax();	if (message.getHeaders().containsKey(GangliaConstants.METRIC_DMAX)) {	dmax = message.getHeader(GangliaConstants.METRIC_DMAX, Integer.class);	}	String value = message.getBody(String.class);	if ((value == null || value.length() == 0) && (type == GMetricType.FLOAT || type == GMetricType.DOUBLE)) {	value = "NaN";	}	if (log.isDebugEnabled()) {	
sending metric to ganglia 

if (message.getHeaders().containsKey(GangliaConstants.METRIC_DMAX)) {	dmax = message.getHeader(GangliaConstants.METRIC_DMAX, Integer.class);	}	String value = message.getBody(String.class);	if ((value == null || value.length() == 0) && (type == GMetricType.FLOAT || type == GMetricType.DOUBLE)) {	value = "NaN";	}	if (log.isDebugEnabled()) {	}	publisher.publish(groupName, metricName, value, type, slope, tmax, dmax, units);	
sending metric done 

========================= camel sample_12028 =========================

public void onClose(WebSocket webSocket) {	
closing websocket 

public void onClose(WebSocket webSocket) {	String connectionKey = store.getConnectionKey(webSocket);	sendEventNotification(connectionKey, WebsocketConstants.ONCLOSE_EVENT_TYPE);	store.removeWebSocket(webSocket);	
websocket closed 

public void onError(WebSocket webSocket, WebSocketException t) {	
websocket on error 

public void onOpen(WebSocket webSocket) {	
opening websocket 

public void onOpen(WebSocket webSocket) {	String connectionKey = UUID.randomUUID().toString();	store.addWebSocket(connectionKey, webSocket);	sendEventNotification(connectionKey, WebsocketConstants.ONOPEN_EVENT_TYPE);	
websocket opened 

public List<AtmosphereRequest> onMessage(WebSocket webSocket, String data) {	
processing text message 

public List<AtmosphereRequest> onMessage(WebSocket webSocket, String data) {	String connectionKey = store.getConnectionKey(webSocket);	consumer.sendMessage(connectionKey, data);	
text message sent 

public List<AtmosphereRequest> onMessage(WebSocket webSocket, byte[] data, int offset, int length) {	
processing byte message 

public List<AtmosphereRequest> onMessage(WebSocket webSocket, byte[] data, int offset, int length) {	String connectionKey = store.getConnectionKey(webSocket);	if (length < data.length) {	byte[] rawdata = data;	data = new byte[length];	System.arraycopy(rawdata, offset, data, 0, length);	}	consumer.sendMessage(connectionKey, data);	
byte message sent 

========================= camel sample_10015 =========================

protected RoutesBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	
caught error while performing task reason exception message stacktrace exception stacktrace 

public void process(Exchange exchange) throws Exception {	Exception ex = (Exception)exchange.getProperties().get(Exchange.EXCEPTION_CAUGHT);	
processing caught exception 

public void process(Exchange exchange) throws Exception {	Exception ex = (Exception)exchange.getProperties().get(Exchange.EXCEPTION_CAUGHT);	
attempting redelivery of handled exception with message 

========================= camel sample_8174 =========================

MockEndpoint mockEndpoint = getMockEndpoint("mock:a");	mockEndpoint.expectedBodiesReceived("<b>Hello World</b>");	template.requestBodyAndHeader(uri, new ByteArrayInputStream("This is a test".getBytes()), "Content-Type", "application/xml");	mockEndpoint.assertIsSatisfied();	List<Exchange> list = mockEndpoint.getReceivedExchanges();	Exchange exchange = list.get(0);	assertNotNull("exchange", exchange);	Message in = exchange.getIn();	assertNotNull("in", in);	Map<String, Object> headers = in.getHeaders();	
headers 

========================= camel sample_10916 =========================

public void setBatchSize(int batchSize) {	if (batchSize <= 0) {	
disabling batch size will only be triggered by timeout 

public boolean process(Exchange exchange, AsyncCallback callback) {	try {	if (isBatchConsumer()) {	int size = exchange.getProperty(Exchange.BATCH_SIZE, Integer.class);	if (batchSize != size) {	batchSize = size;	
using batch consumer completion so setting batch size to 

public boolean process(Exchange exchange, AsyncCallback callback) {	try {	if (isBatchConsumer()) {	int size = exchange.getProperty(Exchange.BATCH_SIZE, Integer.class);	if (batchSize != size) {	batchSize = size;	}	}	if (!isValid(exchange)) {	if (isIgnoreInvalidExchanges()) {	
invalid exchange this exchange will be ignored 

public void run() {	queueLock.lock();	try {	do {	try {	if (!exchangeEnqueued.get()) {	
waiting for new exchange to arrive or batchtimeout to occur after ms 

try {	if (!exchangeEnqueued.get()) {	exchangeEnqueuedCondition.await(batchTimeout, TimeUnit.MILLISECONDS);	}	String id = null;	if (!completionPredicateMatched.isEmpty()) {	id = completionPredicateMatched.poll();	}	if (id != null || !exchangeEnqueued.get()) {	if (id != null) {	
collecting exchanges to be aggregated triggered by completion predicate 

if (!exchangeEnqueued.get()) {	exchangeEnqueuedCondition.await(batchTimeout, TimeUnit.MILLISECONDS);	}	String id = null;	if (!completionPredicateMatched.isEmpty()) {	id = completionPredicateMatched.poll();	}	if (id != null || !exchangeEnqueued.get()) {	if (id != null) {	} else {	
collecting exchanges to be aggregated triggered by batch timeout 

}	drainQueueTo(collection, batchSize, id);	} else {	exchangeEnqueued.set(false);	boolean drained = false;	while (isInBatchCompleted(queue.size())) {	drained = true;	drainQueueTo(collection, batchSize, id);	}	if (drained) {	
collecting exchanges to be aggregated triggered by new exchanges received 

public void enqueueExchange(Exchange exchange) {	
received exchange to be batched 

public void enqueueExchange(Exchange exchange) {	queueLock.lock();	try {	if (completionPredicate != null) {	boolean matches = completionPredicate.matches(exchange);	if (matches) {	
exchange matched completion predicate 

private void sendExchanges() throws Exception {	Iterator<Exchange> iter = collection.iterator();	while (iter.hasNext()) {	Exchange exchange = iter.next();	iter.remove();	try {	
sending aggregated exchange 

========================= camel sample_4507 =========================

} else {	boolean singleton = false;	if (pollingConsumer instanceof IsSingleton) {	singleton = ((IsSingleton) pollingConsumer).isSingleton();	}	String key = endpoint.getEndpointUri();	boolean cached = consumers.containsKey(key);	if (!singleton || !cached) {	try {	if (!singleton) {	
released pollingconsumer is stopped as consumer is not singleton 

boolean singleton = false;	if (pollingConsumer instanceof IsSingleton) {	singleton = ((IsSingleton) pollingConsumer).isSingleton();	}	String key = endpoint.getEndpointUri();	boolean cached = consumers.containsKey(key);	if (!singleton || !cached) {	try {	if (!singleton) {	} else {	
released pollingconsumer is stopped as consumer cache is full 

pool.acquire(endpoint);	}	if (answer == null) {	try {	answer = endpoint.createPollingConsumer();	answer.start();	} catch (Throwable e) {	throw new FailedToCreateConsumerException(endpoint, e);	}	if (pooled && answer instanceof ServicePoolAware) {	
adding to producer service pool with key for producer 

throw new FailedToCreateConsumerException(endpoint, e);	}	if (pooled && answer instanceof ServicePoolAware) {	answer = pool.addAndAcquire(endpoint, answer);	} else {	boolean singleton = false;	if (answer instanceof IsSingleton) {	singleton = ((IsSingleton) answer).isSingleton();	}	if (singleton) {	
adding to consumer cache with key for consumer 

if (pooled && answer instanceof ServicePoolAware) {	answer = pool.addAndAcquire(endpoint, answer);	} else {	boolean singleton = false;	if (answer instanceof IsSingleton) {	singleton = ((IsSingleton) answer).isSingleton();	}	if (singleton) {	consumers.put(key, answer);	} else {	
consumer for endpoint is not singleton and thus not added to consumer cache 

========================= camel sample_4157 =========================

protected void doGetPersistentVolumeClaim(Exchange exchange, String operation) throws Exception {	PersistentVolumeClaim pvc = null;	String pvcName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_PERSISTENT_VOLUME_CLAIM_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(pvcName)) {	
get a specific persistent volume claim require specify a persistent volume claim name 

protected void doGetPersistentVolumeClaim(Exchange exchange, String operation) throws Exception {	PersistentVolumeClaim pvc = null;	String pvcName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_PERSISTENT_VOLUME_CLAIM_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(pvcName)) {	throw new IllegalArgumentException( "Get a specific Persistent Volume Claim require specify a Persistent Volume Claim name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
get a specific persistent volume claim require specify a namespace name 

protected void doCreatePersistentVolumeClaim(Exchange exchange, String operation) throws Exception {	PersistentVolumeClaim pvc = null;	String pvcName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_PERSISTENT_VOLUME_CLAIM_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	PersistentVolumeClaimSpec pvcSpec = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_PERSISTENT_VOLUME_CLAIM_SPEC, PersistentVolumeClaimSpec.class);	if (ObjectHelper.isEmpty(pvcName)) {	
create a specific persistent volume claim require specify a persistent volume claim name 

protected void doCreatePersistentVolumeClaim(Exchange exchange, String operation) throws Exception {	PersistentVolumeClaim pvc = null;	String pvcName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_PERSISTENT_VOLUME_CLAIM_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	PersistentVolumeClaimSpec pvcSpec = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_PERSISTENT_VOLUME_CLAIM_SPEC, PersistentVolumeClaimSpec.class);	if (ObjectHelper.isEmpty(pvcName)) {	throw new IllegalArgumentException( "Create a specific Persistent Volume Claim require specify a Persistent Volume Claim name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
create a specific persistent volume claim require specify a namespace name 

String pvcName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_PERSISTENT_VOLUME_CLAIM_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	PersistentVolumeClaimSpec pvcSpec = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_PERSISTENT_VOLUME_CLAIM_SPEC, PersistentVolumeClaimSpec.class);	if (ObjectHelper.isEmpty(pvcName)) {	throw new IllegalArgumentException( "Create a specific Persistent Volume Claim require specify a Persistent Volume Claim name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	throw new IllegalArgumentException( "Create a specific Persistent Volume Claim require specify a namespace name");	}	if (ObjectHelper.isEmpty(pvcSpec)) {	
create a specific persistent volume claim require specify a persistent volume claim spec bean 

protected void doDeletePersistentVolumeClaim(Exchange exchange, String operation) throws Exception {	String pvcName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_PERSISTENT_VOLUME_CLAIM_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(pvcName)) {	
delete a specific persistent volume claim require specify a persistent volume claim name 

protected void doDeletePersistentVolumeClaim(Exchange exchange, String operation) throws Exception {	String pvcName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_PERSISTENT_VOLUME_CLAIM_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(pvcName)) {	throw new IllegalArgumentException( "Delete a specific Persistent Volume Claim require specify a Persistent Volume Claim name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
delete a specific persistent volume claim require specify a namespace name 

========================= camel sample_13269 =========================

protected void doStop() throws Exception {	super.doStop();	
stopping kubernetes namespace consumer 

========================= camel sample_13286 =========================

protected void unknownPropertyName(String name) {	if (isStrictOnParameterNames()) {	throw new InvalidPropertyException(this, name, endpointClass);	} else {	
using parameter on endpoint which does not have a uriparam annotation please add the uriparam annotation to the field 

========================= camel sample_4012 =========================

public void nettyProducerHangsOnTheSecondRequestToTheSocketWhichIsClosed() throws Exception {	new Thread(new Runnable() {	public void run() {	try {	acceptReplyAcceptClose();	acceptReplyAcceptClose();	} catch (IOException e) {	
exception occured 

private void acceptReplyAcceptClose() throws IOException {	byte buf[] = new byte[128];	ServerSocket serverSocket = new ServerSocket(PORT);	Socket soc = serverSocket.accept();	
open socket and accept data 

Socket soc = serverSocket.accept();	try (InputStream is = soc.getInputStream();	OutputStream os = soc.getOutputStream()) {	is.read(buf);	os.write("response\n".getBytes());	is.read(buf);	} finally {	soc.close();	serverSocket.close();	}	
close socket 

========================= camel sample_10150 =========================

public void run() {	
starting to poll for timeout events 

params.put("timeNow", timeNow);	String activityStateQuery = "select x from " + QueryUtils.getTypeName(ActivityState.class) + " x where x.timeOverdue < :timeNow";	List<ActivityState> list = entityManagerTemplate.find(ActivityState.class, activityStateQuery, params);	for (ActivityState activityState : list) {	fireExpiredEvent(activityState);	}	}	});	long timeToSleep = nextPoll - System.currentTimeMillis();	if (timeToSleep > 0) {	
sleeping for millis 

}	});	long timeToSleep = nextPoll - System.currentTimeMillis();	if (timeToSleep > 0) {	try {	Thread.sleep(timeToSleep);	} catch (InterruptedException e) {	}	}	} catch (Exception e) {	
error during running activitymonitorengine this exception is ignored 

protected void fireExpiredEvent(final ActivityState activityState) {	
trying to fire expiration of 

protected void fireExpiredEvent(final ActivityState activityState) {	entityManagerTemplate.execute(new EntityManagerCallback<Object>() {	public Object execute(EntityManager entityManager) throws PersistenceException {	if (isUseLocking()) {	
attempting to lock 

protected void fireExpiredEvent(final ActivityState activityState) {	entityManagerTemplate.execute(new EntityManagerCallback<Object>() {	public Object execute(EntityManager entityManager) throws PersistenceException {	if (isUseLocking()) {	entityManager.lock(activityState, LockModeType.WRITE);	
grabbed lock 

protected void fireExpiredEvent(final ActivityState activityState) {	entityManagerTemplate.execute(new EntityManagerCallback<Object>() {	public Object execute(EntityManager entityManager) throws PersistenceException {	if (isUseLocking()) {	entityManager.lock(activityState, LockModeType.WRITE);	}	try {	rules.processExpired(activityState);	} catch (Exception e) {	
failed to process expiration of reason 

========================= camel sample_12497 =========================

public void testCacheBasedTokenReplacer() throws Exception {	
beginning test testcachebasedtokenreplacer 

in.setBody("Omar Khayyam");	} else if (key.equalsIgnoreCase("number")) {	in.setBody("one");	} else {	in.setBody(quote);	}	}	});	}	resultEndpoint.assertIsSatisfied();	
completed test testcachebasedtokenreplacer 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() {	from("cache: .process(new CacheBasedTokenReplacer("cache: .process(new CacheBasedTokenReplacer("cache: .process(new CacheBasedTokenReplacer("cache: .to("direct:next");	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	String key = (String)exchange.getIn().getHeader(CacheConstants.CACHE_KEY);	Object body = exchange.getIn().getBody();	String data = exchange.getContext().getTypeConverter().convertTo(String.class, body);	if (log.isDebugEnabled()) {	
payload replacement results 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() {	from("cache: .process(new CacheBasedTokenReplacer("cache: .process(new CacheBasedTokenReplacer("cache: .process(new CacheBasedTokenReplacer("cache: .to("direct:next");	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	String key = (String)exchange.getIn().getHeader(CacheConstants.CACHE_KEY);	Object body = exchange.getIn().getBody();	String data = exchange.getContext().getTypeConverter().convertTo(String.class, body);	if (log.isDebugEnabled()) {	
the following payload was replaced from cache 

from("cache: .process(new CacheBasedTokenReplacer("cache: .process(new CacheBasedTokenReplacer("cache: .process(new CacheBasedTokenReplacer("cache: .to("direct:next");	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	String key = (String)exchange.getIn().getHeader(CacheConstants.CACHE_KEY);	Object body = exchange.getIn().getBody();	String data = exchange.getContext().getTypeConverter().convertTo(String.class, body);	if (log.isDebugEnabled()) {	log.debug("key = {}", key);	log.debug("Before Value = {}", quote);	log.debug("After value = {}", data);	
end 

========================= camel sample_10500 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<MongoDbComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mongodb3.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mongodb3.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1093 =========================

public void testLookupOfTypedObject() throws Exception {	Object value = assertLookup("example");	ExampleBean bean = assertIsInstanceOf(ExampleBean.class, value);	assertEquals("Bean.name", "James", bean.getName());	assertEquals("Bean.price", 2.34, bean.getPrice());	
found bean 

========================= camel sample_1569 =========================

public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {	for (Callback callback : callbacks) {	
callback 

public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {	for (Callback callback : callbacks) {	if (callback instanceof PasswordCallback) {	PasswordCallback pc = (PasswordCallback) callback;	
setting password on callback 

public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {	for (Callback callback : callbacks) {	if (callback instanceof PasswordCallback) {	PasswordCallback pc = (PasswordCallback) callback;	pc.setPassword(principal.getPassword().toCharArray());	} else if (callback instanceof NameCallback) {	NameCallback nc = (NameCallback) callback;	
setting username on callback 

========================= camel sample_16657 =========================

public void process(Exchange exchange) {	Object input = exchange.getIn().getBody();	if (input instanceof XOrderResponse) {	
endpoint xorderresponse xml 

public void process(Exchange exchange) {	Object input = exchange.getIn().getBody();	if (input instanceof XOrderResponse) {	exchange.getIn().setBody("<XOrderResponse/>");	} else {	assertEquals("<XOrder/>", input);	
endpoint xml xorder 

========================= camel sample_15581 =========================

public void testThreeMessagesMDC() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceived("Bye Camel", "Bye Camel", "Bye Camel");	
message 

public void testThreeMessagesMDC() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceived("Bye Camel", "Bye Camel", "Bye Camel");	template.sendBody("direct:a", "Hello World");	
message 

public void testThreeMessagesMDC() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceived("Bye Camel", "Bye Camel", "Bye Camel");	template.sendBody("direct:a", "Hello World");	template.sendBody("direct:a", "Hello Camel");	
message 

========================= camel sample_1990 =========================

public void process(Exchange msg) {	
processing msg 

public void process(Exchange msg) {	Map<String, Object> record = msg.getIn().getBody(Map.class);	
processing record 

========================= camel sample_17553 =========================

public void changeFileName(String newName) {	
changing name to 

public void changeFileName(String newName) {	String newFileName = FileUtil.normalizePath(newName);	String newEndpointPath = FileUtil.normalizePath(endpointPath.endsWith("" + File.separatorChar) ? endpointPath : endpointPath + File.separatorChar);	
normalized endpointpath 

public void changeFileName(String newName) {	String newFileName = FileUtil.normalizePath(newName);	String newEndpointPath = FileUtil.normalizePath(endpointPath.endsWith("" + File.separatorChar) ? endpointPath : endpointPath + File.separatorChar);	
normalized newfilename 

}	if (isAbsolute(newFileName)) {	setAbsolute(true);	setAbsoluteFilePath(newFileName);	} else {	setAbsolute(false);	String path = ObjectHelper.isEmpty(endpointPath) ? "" : endpointPath + getFileSeparator();	setAbsoluteFilePath(path + getRelativeFilePath());	}	if (LOG.isTraceEnabled()) {	
filenameonly 

}	if (isAbsolute(newFileName)) {	setAbsolute(true);	setAbsoluteFilePath(newFileName);	} else {	setAbsolute(false);	String path = ObjectHelper.isEmpty(endpointPath) ? "" : endpointPath + getFileSeparator();	setAbsoluteFilePath(path + getRelativeFilePath());	}	if (LOG.isTraceEnabled()) {	
filename 

}	if (isAbsolute(newFileName)) {	setAbsolute(true);	setAbsoluteFilePath(newFileName);	} else {	setAbsolute(false);	String path = ObjectHelper.isEmpty(endpointPath) ? "" : endpointPath + getFileSeparator();	setAbsoluteFilePath(path + getRelativeFilePath());	}	if (LOG.isTraceEnabled()) {	
absolute 

}	if (isAbsolute(newFileName)) {	setAbsolute(true);	setAbsoluteFilePath(newFileName);	} else {	setAbsolute(false);	String path = ObjectHelper.isEmpty(endpointPath) ? "" : endpointPath + getFileSeparator();	setAbsoluteFilePath(path + getRelativeFilePath());	}	if (LOG.isTraceEnabled()) {	
relative path 

}	if (isAbsolute(newFileName)) {	setAbsolute(true);	setAbsoluteFilePath(newFileName);	} else {	setAbsolute(false);	String path = ObjectHelper.isEmpty(endpointPath) ? "" : endpointPath + getFileSeparator();	setAbsoluteFilePath(path + getRelativeFilePath());	}	if (LOG.isTraceEnabled()) {	
absolute path 

}	if (isAbsolute(newFileName)) {	setAbsolute(true);	setAbsoluteFilePath(newFileName);	} else {	setAbsolute(false);	String path = ObjectHelper.isEmpty(endpointPath) ? "" : endpointPath + getFileSeparator();	setAbsoluteFilePath(path + getRelativeFilePath());	}	if (LOG.isTraceEnabled()) {	
name changed to 

========================= camel sample_4784 =========================

public void startScheduler() {	if (futures.size() == 0) {	if (isUseFixedDelay()) {	if (LOG.isDebugEnabled()) {	
scheduling poll fixed delay with initialdelay delay for 

public void startScheduler() {	if (futures.size() == 0) {	if (isUseFixedDelay()) {	if (LOG.isDebugEnabled()) {	}	for (int i = 0; i < concurrentTasks; i++) {	futures.add(scheduledExecutorService.scheduleWithFixedDelay(task, getInitialDelay(), getDelay(), getTimeUnit()));	}	} else {	if (LOG.isDebugEnabled()) {	
scheduling poll fixed rate with initialdelay delay for 

protected void doStop() throws Exception {	if (isSchedulerStarted()) {	
this consumer is stopping so cancelling scheduled task 

========================= camel sample_4100 =========================

public void testOIDPolling() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.assertIsSatisfied();	List<Exchange> oids = mock.getExchanges();	if (LOG.isInfoEnabled()) {	for (Exchange e : oids) {	
oid 

========================= camel sample_8820 =========================

public void invoke() throws Exception {	for (Operation op : operations) {	try {	op.invoke();	if (Thread.currentThread().isInterrupted()) {	
interrupting composite operation 

public void invoke() throws Exception {	for (Operation op : operations) {	try {	op.invoke();	if (Thread.currentThread().isInterrupted()) {	Thread.currentThread().interrupt();	break;	}	} catch (InterruptedException e) {	
interrupting composite operation 

========================= camel sample_9698 =========================

public boolean process(final Exchange exchange, final AsyncCallback callback) {	Operation operation = getOperation(exchange);	
executing operation 

private void doPublish(Exchange exchange, AsyncCallback callback) {	Object body = exchange.getIn().getBody();	if (ObjectHelper.isEmpty(body)) {	throw new RuntimeException("Can not publish empty message");	}	
sending message to channel 

private void doFire(Exchange exchange, AsyncCallback callback) {	Object body = exchange.getIn().getBody();	if (ObjectHelper.isEmpty(body)) {	exchange.setException(new CamelException("Can not fire empty message"));	callback.done(true);	}	
sending message to channel 

private void doGetHistory(Exchange exchange, AsyncCallback callback) {	endpoint.getPubnub() .history() .channel(getChannel(exchange)) .async(new PNCallback<PNHistoryResult>() {	public void onResponse(PNHistoryResult result, PNStatus status) {	
got history message 

private void doSetState(Exchange exchange, AsyncCallback callback) {	Object body = exchange.getIn().getBody();	if (ObjectHelper.isEmpty(body)) {	exchange.setException(new CamelException("Can not publish empty message"));	callback.done(true);	}	
sending setstate to channel 

private void doSetState(Exchange exchange, AsyncCallback callback) {	Object body = exchange.getIn().getBody();	if (ObjectHelper.isEmpty(body)) {	exchange.setException(new CamelException("Can not publish empty message"));	callback.done(true);	}	endpoint.getPubnub() .setPresenceState() .channels(Arrays.asList(getChannel(exchange))) .state(body) .uuid(getUUID(exchange)) .async(new PNCallback<PNSetStateResult>() {	public void onResponse(PNSetStateResult result, PNStatus status) {	
got setstate responsee 

private void doGetState(Exchange exchange, AsyncCallback callback) {	endpoint.getPubnub() .getPresenceState() .channels(Arrays.asList(getChannel(exchange))) .uuid(getUUID(exchange)) .async(new PNCallback<PNGetStateResult>() {	public void onResponse(PNGetStateResult result, PNStatus status) {	
got state 

private void doHereNow(Exchange exchange, AsyncCallback callback) {	endpoint.getPubnub() .hereNow() .channels(Arrays.asList(getChannel(exchange))) .includeState(true) .includeUUIDs(true) .async(new PNCallback<PNHereNowResult>() {	public void onResponse(PNHereNowResult result, PNStatus status) {	
got hernow message 

private void doWhereNow(Exchange exchange, AsyncCallback callback) {	endpoint.getPubnub() .whereNow() .uuid(getUUID(exchange)) .async(new PNCallback<PNWhereNowResult>() {	public void onResponse(PNWhereNowResult result, PNStatus status) {	
got wherenow message 

========================= camel sample_11653 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("jetty:http: from("direct:leak").process(new Processor() {	public void process(Exchange exchange) throws Exception {	
url is url 

========================= camel sample_10941 =========================

context.setName("context-" + id);	context.addService(service);	context.addRoutes(new RouteBuilder() {	public void configure() throws Exception {	from("master:ns:timer:test?delay=1s&period=1s") .routeId("route-" + id) .log("From ${routeId}") .process(e -> contextLatch.countDown());	}	});	Thread.sleep(ThreadLocalRandom.current().nextInt(500));	context.start();	contextLatch.await();	
shutting down node 

========================= camel sample_14451 =========================

public void prepareOnStartup(GenericFileOperations<File> operations, GenericFileEndpoint<File> endpoint) throws Exception {	this.endpoint = endpoint;	
using fileidempotentrepositoryreadlockstrategy on endpoint 

========================= camel sample_4803 =========================

public void addPropertyPlaceholder(String id) {	Object component = container.getComponentInstance(id);	if (component instanceof AbstractPropertyPlaceholder) {	AbstractPropertyPlaceholder placeholder = (AbstractPropertyPlaceholder) component;	placeholders.add(placeholder);	
adding blueprint propertyplaceholder 

public String parseProperty(String key, String value, Properties properties) {	
parsing property key with value 

answer = (String) propertiesComponent.getOverrideProperties().get(key);	}	if (answer == null && key != null) {	for (AbstractPropertyPlaceholder placeholder : placeholders) {	boolean isDefault = false;	if (placeholders.size() > 1) {	if (placeholder instanceof PropertyPlaceholder) {	Map map = ((PropertyPlaceholder) placeholder).getDefaultProperties();	isDefault = map != null && map.containsKey(key);	}	
blueprint property key is part of default properties 

if (placeholders.size() > 1) {	if (placeholder instanceof PropertyPlaceholder) {	Map map = ((PropertyPlaceholder) placeholder).getDefaultProperties();	isDefault = map != null && map.containsKey(key);	}	}	try {	String candidate = (String) ObjectHelper.invokeMethod(method, placeholder, key);	if (candidate != null) {	if (answer == null || !isDefault) {	
blueprint parsed candidate property key as value 

try {	String candidate = (String) ObjectHelper.invokeMethod(method, placeholder, key);	if (candidate != null) {	if (answer == null || !isDefault) {	answer = candidate;	}	}	} catch (Exception ex) {	}	}	
blueprint parsed property key as value 

}	}	} catch (Exception ex) {	}	}	}	if (delegate != null) {	String delegateAnswer = delegate.parseProperty(key, answer != null ? answer : value, properties);	if (delegateAnswer != null) {	answer = delegateAnswer;	
delegate property parser parsed the property key as value 

} catch (Exception ex) {	}	}	}	if (delegate != null) {	String delegateAnswer = delegate.parseProperty(key, answer != null ? answer : value, properties);	if (delegateAnswer != null) {	answer = delegateAnswer;	}	}	
returning parsed property key as value 

========================= camel sample_8123 =========================

public void setEncoding(String encoding) {	if (!Charset.isSupported(encoding)) {	
unsupported encoding is being set 

========================= camel sample_16895 =========================

public void configure() throws Exception {	
about to setup splunk search route splunk server log results 

========================= camel sample_17768 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<NettyComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.netty.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.netty.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_770 =========================

properties.timestamp(convertTimestamp(timestamp));	}	final Map<String, Object> headers = msg.getHeaders();	Map<String, Object> filteredHeaders = new HashMap<>();	for (Map.Entry<String, Object> header : headers.entrySet()) {	Object value = getValidRabbitMQHeaderValue(header.getValue());	if (value != null) {	filteredHeaders.put(header.getKey(), header.getValue());	} else if (LOG.isDebugEnabled()) {	if (header.getValue() == null) {	
ignoring header with null value 

}	final Map<String, Object> headers = msg.getHeaders();	Map<String, Object> filteredHeaders = new HashMap<>();	for (Map.Entry<String, Object> header : headers.entrySet()) {	Object value = getValidRabbitMQHeaderValue(header.getValue());	if (value != null) {	filteredHeaders.put(header.getKey(), header.getValue());	} else if (LOG.isDebugEnabled()) {	if (header.getValue() == null) {	} else {	
ignoring header of class with value 

private void deserializeBody(final Exchange camelExchange, final Message message, final byte[] body) {	Object messageBody = null;	try (InputStream b = new ByteArrayInputStream(body);	ObjectInputStream o = new ObjectInputStream(b)) {	messageBody = o.readObject();	} catch (IOException | ClassNotFoundException e) {	
could not deserialize the object 

private void deserializeBody(final Exchange camelExchange, final Message message, final byte[] body) {	Object messageBody = null;	try (InputStream b = new ByteArrayInputStream(body);	ObjectInputStream o = new ObjectInputStream(b)) {	messageBody = o.readObject();	} catch (IOException | ClassNotFoundException e) {	camelExchange.setException(e);	}	if (messageBody instanceof Throwable) {	
reply was an exception setting the exception on the exchange 

========================= camel sample_14144 =========================

private static void manageCamelContext(Container container, CamelContext context) {	try {	container.manage(context);	} catch (Throwable t) {	
error during manage camelcontext this exception is ignored 

========================= camel sample_5087 =========================

boolean fixed = false;	String newName = findFreeName(mc, context.getManagementNameStrategy(), name);	if (newName != null) {	fixed = true;	done = true;	managementName = newName;	}	if (!fixed) {	throw new VetoCamelContextStartException("CamelContext (" + context.getName() + ") with ObjectName[" + on + "] is already registered." + " Make sure to use unique names on CamelContext when using multiple CamelContexts in the same MBeanServer.", context);	} else {	
this camelcontext will be registered using the name due to clash with an existing name already registered in mbeanserver 

camelContextMBean = (ManagedCamelContext) mc;	}	enlistPreRegisteredServices();	try {	Object me = getManagementObjectStrategy().getManagedObjectForCamelHealth(camelContext);	if (me == null) {	return;	}	manageObject(me);	} catch (Exception e) {	
could not register camelhealth mbean this exception will be ignored 

manageObject(me);	} catch (Exception e) {	}	try {	Object me = getManagementObjectStrategy().getManagedObjectForRouteController(camelContext);	if (me == null) {	return;	}	manageObject(me);	} catch (Exception e) {	
could not register routecontroller mbean this exception will be ignored 

if (strategy.isFixedName()) {	return null;	}	boolean done = false;	String newName = null;	while (!done) {	newName = strategy.getNextName();	ObjectName on = getManagementStrategy().getManagementNamingStrategy().getObjectNameForCamelContext(newName, name);	done = !getManagementStrategy().isManaged(mc, on);	if (LOG.isTraceEnabled()) {	
using name in objectname exists 

private void enlistPreRegisteredServices() {	if (preServices.isEmpty()) {	return;	}	
registering pre registered services 

public void onContextStop(CamelContext context) {	if (!initialized) {	return;	}	try {	Object mc = getManagementObjectStrategy().getManagedObjectForRouteController(context);	if (getManagementStrategy().isManaged(mc, null)) {	unmanageObject(mc);	}	} catch (Exception e) {	
could not unregister routecontroller mbean 

unmanageObject(mc);	}	} catch (Exception e) {	}	try {	Object mc = getManagementObjectStrategy().getManagedObjectForCamelHealth(context);	if (getManagementStrategy().isManaged(mc, null)) {	unmanageObject(mc);	}	} catch (Exception e) {	
could not unregister camelhealth mbean 

unmanageObject(mc);	}	} catch (Exception e) {	}	try {	Object mc = getManagementObjectStrategy().getManagedObjectForCamelContext(context);	if (getManagementStrategy().isManaged(mc, null)) {	unmanageObject(mc);	}	} catch (Exception e) {	
could not unregister camelcontext mbean 

if (!initialized) {	PreRegisterService pre = new PreRegisterService();	pre.onComponentAdd(name, component);	preServices.add(pre);	return;	}	try {	Object mc = getManagementObjectStrategy().getManagedObjectForComponent(camelContext, component, name);	manageObject(mc);	} catch (Exception e) {	
could not register component mbean 

public void onComponentRemove(String name, Component component) {	if (!initialized) {	return;	}	try {	Object mc = getManagementObjectStrategy().getManagedObjectForComponent(camelContext, component, name);	unmanageObject(mc);	} catch (Exception e) {	
could not unregister component mbean 

if (!shouldRegister(endpoint, null)) {	return;	}	try {	Object me = getManagementObjectStrategy().getManagedObjectForEndpoint(camelContext, endpoint);	if (me == null) {	return;	}	manageObject(me);	} catch (Exception e) {	
could not register endpoint mbean for endpoint this exception will be ignored 

public void onEndpointRemove(Endpoint endpoint) {	if (!initialized) {	return;	}	try {	Object me = getManagementObjectStrategy().getManagedObjectForEndpoint(camelContext, endpoint);	unmanageObject(me);	} catch (Exception e) {	
could not unregister endpoint mbean for endpoint this exception will be ignored 

return;	}	if (!shouldRegister(service, route)) {	return;	}	Object managedObject = getManagedObjectForService(context, service, route);	if (managedObject == null) {	return;	}	if (getManagementStrategy().isManaged(managedObject, null)) {	
the service is already managed 

Object managedObject = getManagedObjectForService(context, service, route);	if (managedObject == null) {	return;	}	if (getManagementStrategy().isManaged(managedObject, null)) {	return;	}	try {	manageObject(managedObject);	} catch (Exception e) {	
could not register service as service mbean 

public void onServiceRemove(CamelContext context, Service service, Route route) {	if (!initialized) {	return;	}	Object managedObject = getManagedObjectForService(context, service, route);	if (managedObject != null) {	try {	unmanageObject(managedObject);	} catch (Exception e) {	
could not unregister service as service mbean 

public void onRoutesAdd(Collection<Route> routes) {	for (Route route : routes) {	if (getCamelContext().getStatus().isStarting() || getManagementStrategy().getManagementAgent().getRegisterAlways() || getManagementStrategy().getManagementAgent().getRegisterNewRoutes()) {	knowRouteIds.add(route.getId());	}	if (!shouldRegister(route, route)) {	continue;	}	Object mr = getManagementObjectStrategy().getManagedObjectForRoute(camelContext, route);	if (getManagementStrategy().isManaged(mr, null)) {	
the route is already managed 

task.setCounter(wrapper);	} else {	task.setCounter(routeMBean);	}	}	}	}	try {	manageObject(mr);	} catch (JMException e) {	
could not register route mbean 

} else {	task.setCounter(routeMBean);	}	}	}	}	try {	manageObject(mr);	} catch (JMException e) {	} catch (Exception e) {	
could not create route mbean 

public void onRoutesRemove(Collection<Route> routes) {	if (!initialized) {	return;	}	for (Route route : routes) {	Object mr = getManagementObjectStrategy().getManagedObjectForRoute(camelContext, route);	if (!getManagementStrategy().isManaged(mr, null)) {	
the route is not managed 

return;	}	for (Route route : routes) {	Object mr = getManagementObjectStrategy().getManagedObjectForRoute(camelContext, route);	if (!getManagementStrategy().isManaged(mr, null)) {	continue;	}	try {	unmanageObject(mr);	} catch (Exception e) {	
could not unregister route mbean 

public void onErrorHandlerAdd(RouteContext routeContext, Processor errorHandler, ErrorHandlerFactory errorHandlerBuilder) {	if (!shouldRegister(errorHandler, null)) {	return;	}	Object me = getManagementObjectStrategy().getManagedObjectForErrorHandler(camelContext, routeContext, errorHandler, errorHandlerBuilder);	if (getManagementStrategy().isManaged(me, null)) {	
the error handler builder is already managed 

if (!shouldRegister(errorHandler, null)) {	return;	}	Object me = getManagementObjectStrategy().getManagedObjectForErrorHandler(camelContext, routeContext, errorHandler, errorHandlerBuilder);	if (getManagementStrategy().isManaged(me, null)) {	return;	}	try {	manageObject(me);	} catch (Exception e) {	
could not register error handler builder as errorhandler mbean 

public void onErrorHandlerRemove(RouteContext routeContext, Processor errorHandler, ErrorHandlerFactory errorHandlerBuilder) {	if (!initialized) {	return;	}	Object me = getManagementObjectStrategy().getManagedObjectForErrorHandler(camelContext, routeContext, errorHandler, errorHandlerBuilder);	if (me != null) {	try {	unmanageObject(me);	} catch (Exception e) {	
could not unregister error handler as errorhandler mbean 

public void onThreadPoolAdd(CamelContext camelContext, ThreadPoolExecutor threadPool, String id, String sourceId, String routeId, String threadPoolProfileId) {	if (!shouldRegister(threadPool, null)) {	return;	}	Object mtp = getManagementObjectStrategy().getManagedObjectForThreadPool(camelContext, threadPool, id, sourceId, routeId, threadPoolProfileId);	if (getManagementStrategy().isManaged(mtp, null)) {	
the thread pool is already managed 

return;	}	Object mtp = getManagementObjectStrategy().getManagedObjectForThreadPool(camelContext, threadPool, id, sourceId, routeId, threadPoolProfileId);	if (getManagementStrategy().isManaged(mtp, null)) {	return;	}	try {	manageObject(mtp);	managedThreadPools.put(threadPool, mtp);	} catch (Exception e) {	
could not register thread pool as threadpool mbean 

public void onThreadPoolRemove(CamelContext camelContext, ThreadPoolExecutor threadPool) {	if (!initialized) {	return;	}	Object mtp = managedThreadPools.remove(threadPool);	if (mtp != null) {	if (!getManagementStrategy().isManaged(mtp, null)) {	
the thread pool is not managed 

return;	}	Object mtp = managedThreadPools.remove(threadPool);	if (mtp != null) {	if (!getManagementStrategy().isManaged(mtp, null)) {	return;	}	try {	unmanageObject(mtp);	} catch (Exception e) {	
could not unregister threadpool mbean 

protected boolean shouldRegister(Object service, Route route) {	if (!initialized) {	return false;	}	
checking whether to register from route 

public void onCamelContextStarted(CamelContext context, boolean alreadyStarted) throws Exception {	boolean load = camelContext.getManagementStrategy().getManagementAgent().getLoadStatisticsEnabled() != null && camelContext.getManagementStrategy().getManagementAgent().getLoadStatisticsEnabled();	boolean disabled = !load || camelContext.getManagementStrategy().getStatisticsLevel() == ManagementStatisticsLevel.Off;	
load performance statistics disabled enabled 

========================= camel sample_4696 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<GooglePubsubComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.google-pubsub.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.google-pubsub.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1181 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	
mock exception 

========================= camel sample_6644 =========================

protected void doStart() throws Exception {	super.doStart();	
using schema resource 

========================= camel sample_16745 =========================

public void run() {	String threadName = Thread.currentThread().getName();	
runnable starting 

public void run() {	String threadName = Thread.currentThread().getName();	int currentRun = 0;	started = true;	try {	while (started && ++currentRun <= runCount) {	Thread.sleep(SLEEP_MILLIS);	
runnable running of runs 

public void run() {	String threadName = Thread.currentThread().getName();	int currentRun = 0;	started = true;	try {	while (started && ++currentRun <= runCount) {	Thread.sleep(SLEEP_MILLIS);	}	} catch (InterruptedException e) {	
runnable interrupted on run 

public void run() {	String threadName = Thread.currentThread().getName();	int currentRun = 0;	started = true;	try {	while (started && ++currentRun <= runCount) {	Thread.sleep(SLEEP_MILLIS);	}	} catch (InterruptedException e) {	} finally {	
runnable exiting after runs 

========================= camel sample_13814 =========================

if (sync) {	latch = new CountDownLatch(1);	ResponseHandler handler = (ResponseHandler) session.getHandler();	handler.reset();	}	if (LOG.isDebugEnabled()) {	Object out = body;	if (body instanceof byte[]) {	out = exchange.getContext().getTypeConverter().convertTo(String.class, body);	}	
writing body 

handler.reset();	}	if (LOG.isDebugEnabled()) {	Object out = body;	if (body instanceof byte[]) {	out = exchange.getContext().getTypeConverter().convertTo(String.class, body);	}	}	MinaHelper.writeBody(session, body, exchange);	if (sync) {	
waiting for response using timeout millis 

close = exchange.getOut().getHeader(MinaConstants.MINA_CLOSE_SESSION_WHEN_COMPLETE, Boolean.class);	} else {	close = exchange.getIn().getHeader(MinaConstants.MINA_CLOSE_SESSION_WHEN_COMPLETE, Boolean.class);	}	boolean disconnect = getEndpoint().getConfiguration().isDisconnect();	if (close != null) {	disconnect = close;	}	if (disconnect) {	if (LOG.isDebugEnabled()) {	
closing session when complete at address 

protected void doStop() throws Exception {	if (LOG.isDebugEnabled()) {	
stopping connector at address 

private void openConnection() {	SocketAddress address = getEndpoint().getAddress();	connector = getEndpoint().getConnector();	if (LOG.isDebugEnabled()) {	
creating connector to address using connector timeout millis 

public void messageReceived(IoSession ioSession, Object message) throws Exception {	
message received 

public void sessionClosed(IoSession session) throws Exception {	if (sync && !messageReceived) {	if (LOG.isDebugEnabled()) {	
session closed but no message received from address 

public void exceptionCaught(IoSession ioSession, Throwable cause) {	
exception on receiving message from address using connector 

========================= camel sample_7690 =========================

if (channel == null) {	channel = new JChannel(jgroupsConfig);	lockService = new LockService(channel);	}	channel.connect(jgroupsClusterName);	lock = lockService.getLock(lockName);	final CamelContext context = ObjectHelper.notNull(getCamelContext(), "CamelContext");	executor = context.getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "JGroupsLockClusterView-" + getClusterService().getId() + "-" + lockName);	executor.execute(new Runnable() {	public void run() {	
attempting to become master acquiring the lock for group in jgroups cluster with configuration 

}	channel.connect(jgroupsClusterName);	lock = lockService.getLock(lockName);	final CamelContext context = ObjectHelper.notNull(getCamelContext(), "CamelContext");	executor = context.getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "JGroupsLockClusterView-" + getClusterService().getId() + "-" + lockName);	executor.execute(new Runnable() {	public void run() {	lock.lock();	isMaster = true;	fireLeadershipChangedEvent(Optional.ofNullable(localMember));	
became master by acquiring the lock for group in jgroups cluster with configuration 

========================= camel sample_16929 =========================

public void prepareOnStartup(GenericFileOperations<File> operations, GenericFileEndpoint<File> endpoint) {	if (deleteOrphanLockFiles) {	String dir = endpoint.getConfiguration().getDirectory();	File file = new File(dir);	
prepare on startup by deleting orphaned lock files from 

public void prepareOnStartup(GenericFileOperations<File> operations, GenericFileEndpoint<File> endpoint) {	if (deleteOrphanLockFiles) {	String dir = endpoint.getConfiguration().getDirectory();	File file = new File(dir);	Pattern excludePattern = endpoint.getExcludePattern();	Pattern includePattern = endpoint.getIncludePattern();	String endpointPath = endpoint.getConfiguration().getDirectory();	StopWatch watch = new StopWatch();	deleteLockFiles(file, endpoint.isRecursive(), endpointPath, endpoint.getFilter(), endpoint.getAntFilter(), excludePattern, includePattern);	if (watch.taken() > 1000) {	
prepared on startup by deleting orphaned lock files from took millis to complete 

public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {	if (!markerFile) {	return true;	}	String lockFileName = getLockFileName(file);	
locking the file using the lock file name 

protected void doReleaseExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {	if (!markerFile) {	return;	}	boolean acquired = exchange.getProperty(asReadLockKey(file, Exchange.FILE_LOCK_FILE_ACQUIRED), false, Boolean.class);	if (acquired) {	String lockFileName = exchange.getProperty(asReadLockKey(file, Exchange.FILE_LOCK_FILE_NAME), String.class);	File lock = new File(lockFileName);	if (lock.exists()) {	
unlocking file 

protected void doReleaseExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {	if (!markerFile) {	return;	}	boolean acquired = exchange.getProperty(asReadLockKey(file, Exchange.FILE_LOCK_FILE_ACQUIRED), false, Boolean.class);	if (acquired) {	String lockFileName = exchange.getProperty(asReadLockKey(file, Exchange.FILE_LOCK_FILE_NAME), String.class);	File lock = new File(lockFileName);	if (lock.exists()) {	boolean deleted = FileUtil.deleteFile(lock);	
lock file was deleted 

} else {	targetFile = new File(target);	}	}	boolean accept = acceptFile(targetFile, endpointPath, filter, antFilter, excludePattern, includePattern);	if (!accept) {	continue;	}	}	if (file.getName().endsWith(FileComponent.DEFAULT_LOCK_FILE_POSTFIX)) {	
deleting orphaned lock file 

========================= camel sample_4815 =========================

public void testJettyAsyncTimeout() throws Exception {	getMockEndpoint("mock:result").expectedBodiesReceived("Bye World");	StopWatch watch = new StopWatch();	try {	template.requestBody("http: fail("Should have thrown an exception");	} catch (CamelExecutionException e) {	
timeout hit and client got reply with failure status code 

========================= camel sample_10957 =========================

public void testPerformance() {	DefaultUuidGenerator uuidGenerator = new DefaultUuidGenerator();	StopWatch watch = new StopWatch();	
first id 

public void testPerformance() {	DefaultUuidGenerator uuidGenerator = new DefaultUuidGenerator();	StopWatch watch = new StopWatch();	for (int i = 0; i < 500000; i++) {	uuidGenerator.generateUuid();	}	
last id 

public void testPerformance() {	DefaultUuidGenerator uuidGenerator = new DefaultUuidGenerator();	StopWatch watch = new StopWatch();	for (int i = 0; i < 500000; i++) {	uuidGenerator.generateUuid();	}	
took 

========================= camel sample_1314 =========================

public void process(Exchange exchange) throws Exception {	Message in = exchange.getIn();	Pod pod = exchange.getIn().getBody(Pod.class);	
got event with pod name and action 

========================= camel sample_13228 =========================

private boolean execute(ServiceDefinition server, Exchange exchange, AsyncCallback callback) throws Exception {	String host = server.getHost();	int port = server.getPort();	
service active at server 

========================= camel sample_4116 =========================

protected final void bind(String key, Processor processor) {	if (handlers.containsKey(key)) {	
a processor is already set for action 

========================= camel sample_4053 =========================

protected void doStart() throws Exception {	if ("1.2".equals(version)) {	
using soap adapter 

protected void doStart() throws Exception {	if ("1.2".equals(version)) {	adapter = new Soap12DataFormatAdapter(this);	} else {	
using soap adapter 

bodyParts.add(o);	}	}	} else {	bodyParts.add(inputObject);	}	List<Object> bodyElements = new ArrayList<Object>();	for (Object bodyObj : bodyParts) {	QName name = elementNameStrategy.findQNameForSoapActionOrType(soapAction, bodyObj.getClass());	if (name == null) {	
could not find qname for class 

QName name = elementNameStrategy.findQNameForSoapActionOrType(soapAction, bodyObj.getClass());	if (name == null) {	continue;	} else {	bodyElements.add(getElement(bodyObj, name));	}	}	for (Object headerObj : headerParts) {	QName name = elementNameStrategy.findQNameForSoapActionOrType(soapAction, headerObj.getClass());	if (name == null) {	
could not find qname for class 

========================= camel sample_9661 =========================

public <T> T evaluate(Exchange exchange, Class<T> tClass) {	ExpressionFactory factory = getExpressionFactory(exchange.getContext());	ELContext context = populateContext(createContext(), exchange);	ValueExpression valueExpression = factory.createValueExpression(context, expression, type);	Object value = valueExpression.getValue(context);	
value returned 

public synchronized ExpressionFactory getExpressionFactory(CamelContext context) {	if (expressionFactory == null && context != null) {	try {	FactoryFinder finder = context.getFactoryFinder("META-INF/services/org/apache/camel/language/");	Class<?> clazz = finder.findClass("el", "impl.", ExpressionFactory.class);	if (clazz != null) {	expressionFactory = (ExpressionFactory)clazz.newInstance();	}	} catch (ClassNotFoundException e) {	
impl class not found 

public synchronized ExpressionFactory getExpressionFactory(CamelContext context) {	if (expressionFactory == null && context != null) {	try {	FactoryFinder finder = context.getFactoryFinder("META-INF/services/org/apache/camel/language/");	Class<?> clazz = finder.findClass("el", "impl.", ExpressionFactory.class);	if (clazz != null) {	expressionFactory = (ExpressionFactory)clazz.newInstance();	}	} catch (ClassNotFoundException e) {	} catch (IOException e) {	
no impl class for juel expressionfactory defined in meta inf services org apache camel language el 

if (expressionFactory == null && context != null) {	try {	FactoryFinder finder = context.getFactoryFinder("META-INF/services/org/apache/camel/language/");	Class<?> clazz = finder.findClass("el", "impl.", ExpressionFactory.class);	if (clazz != null) {	expressionFactory = (ExpressionFactory)clazz.newInstance();	}	} catch (ClassNotFoundException e) {	} catch (IOException e) {	} catch (InstantiationException e) {	
failed to instantiate juel expressionfactory implementation class 

try {	FactoryFinder finder = context.getFactoryFinder("META-INF/services/org/apache/camel/language/");	Class<?> clazz = finder.findClass("el", "impl.", ExpressionFactory.class);	if (clazz != null) {	expressionFactory = (ExpressionFactory)clazz.newInstance();	}	} catch (ClassNotFoundException e) {	} catch (IOException e) {	} catch (InstantiationException e) {	} catch (IllegalAccessException e) {	
failed to instantiate juel expressionfactory implementation class 

========================= camel sample_12985 =========================

public RouteDefinition adviceWith(ModelCamelContext camelContext, RouteBuilder builder) throws Exception {	ObjectHelper.notNull(camelContext, "CamelContext");	ObjectHelper.notNull(builder, "RouteBuilder");	
advicewith route before 

public RouteDefinition adviceWith(ModelCamelContext camelContext, RouteBuilder builder) throws Exception {	ObjectHelper.notNull(camelContext, "CamelContext");	ObjectHelper.notNull(builder, "RouteBuilder");	if (builder instanceof AdviceWithRouteBuilder) {	((AdviceWithRouteBuilder) builder).setOriginalRoute(this);	}	RoutesDefinition routes = builder.configureRoutes(camelContext);	
advicewith routes 

}	camelContext.removeRouteDefinition(this);	if (builder instanceof AdviceWithRouteBuilder) {	List<AdviceWithTask> tasks = ((AdviceWithRouteBuilder) builder).getAdviceWithTasks();	for (AdviceWithTask task : tasks) {	task.task();	}	}	RouteDefinition merged = routes.route(this);	camelContext.getRouteDefinitions().add(0, merged);	
advicewith route after 

protected RouteContext addRoutes(CamelContext camelContext, Collection<Route> routes, FromDefinition fromType) throws Exception {	RouteContext routeContext = new DefaultRouteContext(camelContext, this, fromType, routes);	if (trace != null) {	Boolean isTrace = CamelContextHelper.parseBoolean(camelContext, getTrace());	if (isTrace != null) {	routeContext.setTracing(isTrace);	if (isTrace) {	
tracing is enabled on route 

routeContext.setTracing(isTrace);	if (isTrace) {	}	}	}	if (messageHistory != null) {	Boolean isMessageHistory = CamelContextHelper.parseBoolean(camelContext, getMessageHistory());	if (isMessageHistory != null) {	routeContext.setMessageHistory(isMessageHistory);	if (isMessageHistory) {	
message history is enabled on route 

routeContext.setMessageHistory(isMessageHistory);	if (isMessageHistory) {	}	}	}	if (logMask != null) {	Boolean isLogMask = CamelContextHelper.parseBoolean(camelContext, getLogMask());	if (isLogMask != null) {	routeContext.setLogMask(isLogMask);	if (isLogMask) {	
security mask for logging is enabled on route 

routeContext.setLogMask(isLogMask);	if (isLogMask) {	}	}	}	if (streamCache != null) {	Boolean isStreamCache = CamelContextHelper.parseBoolean(camelContext, getStreamCache());	if (isStreamCache != null) {	routeContext.setStreamCaching(isStreamCache);	if (isStreamCache) {	
streamcaching is enabled on route 

routeContext.setStreamCaching(isStreamCache);	if (isStreamCache) {	}	}	}	if (handleFault != null) {	Boolean isHandleFault = CamelContextHelper.parseBoolean(camelContext, getHandleFault());	if (isHandleFault != null) {	routeContext.setHandleFault(isHandleFault);	if (isHandleFault) {	
handlefault is enabled on route 

addInterceptStrategy(new HandleFault());	}	}	}	}	if (delayer != null) {	Long delayer = CamelContextHelper.parseLong(camelContext, getDelayer());	if (delayer != null) {	routeContext.setDelayer(delayer);	if (delayer > 0) {	
delayer is enabled with ms on route 

}	}	}	}	if (delayer != null) {	Long delayer = CamelContextHelper.parseLong(camelContext, getDelayer());	if (delayer != null) {	routeContext.setDelayer(delayer);	if (delayer > 0) {	} else {	
delayer is disabled on route 

Long delayer = CamelContextHelper.parseLong(camelContext, getDelayer());	if (delayer != null) {	routeContext.setDelayer(delayer);	if (delayer > 0) {	} else {	}	}	}	if (routePolicies != null && !routePolicies.isEmpty()) {	for (RoutePolicy policy : routePolicies) {	
routepolicy is enabled on route 

if (routePolicies != null && !routePolicies.isEmpty()) {	for (RoutePolicy policy : routePolicies) {	routeContext.getRoutePolicyList().add(policy);	}	}	if (routePolicyRef != null) {	StringTokenizer policyTokens = new StringTokenizer(routePolicyRef, ",");	while (policyTokens.hasMoreTokens()) {	String ref = policyTokens.nextToken().trim();	RoutePolicy policy = CamelContextHelper.mandatoryLookup(camelContext, ref, RoutePolicy.class);	
routepolicy is enabled on route 

while (policyTokens.hasMoreTokens()) {	String ref = policyTokens.nextToken().trim();	RoutePolicy policy = CamelContextHelper.mandatoryLookup(camelContext, ref, RoutePolicy.class);	routeContext.getRoutePolicyList().add(policy);	}	}	if (camelContext.getRoutePolicyFactories() != null) {	for (RoutePolicyFactory factory : camelContext.getRoutePolicyFactories()) {	RoutePolicy policy = factory.createRoutePolicy(camelContext, getId(), this);	if (policy != null) {	
routepolicy is enabled on route 

if (camelContext.getRoutePolicyFactories() != null) {	for (RoutePolicyFactory factory : camelContext.getRoutePolicyFactories()) {	RoutePolicy policy = factory.createRoutePolicy(camelContext, getId(), this);	if (policy != null) {	routeContext.getRoutePolicyList().add(policy);	}	}	}	Boolean isAutoStartup = CamelContextHelper.parseBoolean(camelContext, getAutoStartup());	if (isAutoStartup != null) {	
using autostartup on route 

if (policy != null) {	routeContext.getRoutePolicyList().add(policy);	}	}	}	Boolean isAutoStartup = CamelContextHelper.parseBoolean(camelContext, getAutoStartup());	if (isAutoStartup != null) {	routeContext.setAutoStartup(isAutoStartup);	}	if (shutdownRoute != null) {	
using shutdownroute on route 

}	}	Boolean isAutoStartup = CamelContextHelper.parseBoolean(camelContext, getAutoStartup());	if (isAutoStartup != null) {	routeContext.setAutoStartup(isAutoStartup);	}	if (shutdownRoute != null) {	routeContext.setShutdownRoute(getShutdownRoute());	}	if (shutdownRunningTask != null) {	
using shutdownrunningtask on route 

========================= camel sample_5212 =========================

public void doSomething(String body) {	ObjectHelper.notNull(destination, "destination");	
received body 

========================= camel sample_15743 =========================

protected void doStart() throws Exception {	try {	super.doStart();	} finally {	final HttpClient httpClient = getConfiguration().getHttpClient();	if (httpClient != null && getComponent().getConfig().getHttpClient() != httpClient) {	final String endpointUri = getEndpointUri();	
starting http client for 

protected void doStart() throws Exception {	try {	super.doStart();	} finally {	final HttpClient httpClient = getConfiguration().getHttpClient();	if (httpClient != null && getComponent().getConfig().getHttpClient() != httpClient) {	final String endpointUri = getEndpointUri();	httpClient.start();	
started http client for 

protected void doStop() throws Exception {	try {	super.doStop();	} finally {	final HttpClient httpClient = getConfiguration().getHttpClient();	if (httpClient != null && getComponent().getConfig().getHttpClient() != httpClient) {	final String endpointUri = getEndpointUri();	
stopping http client for 

protected void doStop() throws Exception {	try {	super.doStop();	} finally {	final HttpClient httpClient = getConfiguration().getHttpClient();	if (httpClient != null && getComponent().getConfig().getHttpClient() != httpClient) {	final String endpointUri = getEndpointUri();	httpClient.stop();	
stopped http client for 

========================= camel sample_14781 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<BoonDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.boon.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.boon.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_1178 =========================

private void updateValue(final ObjectAddress address, final Value<?> value) {	try {	final Exchange exchange = getEndpoint().createExchange();	exchange.setIn(mapMessage(value));	getAsyncProcessor().process(exchange);	} catch (final Exception e) {	
failed to process message 

========================= camel sample_6717 =========================

public static Exchange toExchange(Endpoint endpoint, SessionID sessionID, Message message, QuickfixjEventCategory eventCategory, ExchangePattern exchangePattern) {	Exchange exchange = endpoint.createExchange(exchangePattern);	org.apache.camel.Message camelMessage = exchange.getIn();	camelMessage.setHeader(EVENT_CATEGORY_KEY, eventCategory);	camelMessage.setHeader(SESSION_ID_KEY, sessionID);	if (message != null) {	try {	camelMessage.setHeader(MESSAGE_TYPE_KEY, message.getHeader().getString(MsgType.FIELD));	} catch (FieldNotFound e) {	
message type field not found in qfj message continuing 

========================= camel sample_10668 =========================

protected void assertCorrectBytesReceived() {	Exchange exchange = endpoint.getReceivedExchanges().get(0);	assertNotNull(ExchangeHelper.getBinding(exchange, JmsBinding.class));	JmsMessage in = (JmsMessage) exchange.getIn();	assertNotNull(in);	byte[] bytes = exchange.getIn().getBody(byte[].class);	
received bytes 

========================= camel sample_7043 =========================

private void doStopRoute(RouteHolder route,  boolean checker, ThrowingConsumer<RouteHolder, Exception> consumer) throws Exception {	synchronized (lock) {	if (checker) {	routeManager.release(route);	}	
route has been requested to stop stop supervising it 

public void onInit(Route route) {	final String autoStartup = route.getRouteContext().getRoute().getAutoStartup();	if (ObjectHelper.equalIgnoreCase("false", autoStartup)) {	
route won t be supervised reason has explicit auto startup flag set to false 

public void onInit(Route route) {	final String autoStartup = route.getRouteContext().getRoute().getAutoStartup();	if (ObjectHelper.equalIgnoreCase("false", autoStartup)) {	return;	}	for (Filter filter : filters) {	FilterResult result = filter.apply(route);	if (!result.supervised()) {	
route won t be supervised reason 

FilterResult result = filter.apply(route);	if (!result.supervised()) {	return;	}	}	RouteHolder holder = new RouteHolder(route, routeCount.incrementAndGet());	if (routes.add(holder)) {	holder.getContext().setRouteController(SupervisingRouteController.this);	holder.getDefinition().setAutoStartup("false");	if (contextStarted.get()) {	
context is already started attempt to start route 

if (!result.supervised()) {	return;	}	}	RouteHolder holder = new RouteHolder(route, routeCount.incrementAndGet());	if (routes.add(holder)) {	holder.getContext().setRouteController(SupervisingRouteController.this);	holder.getDefinition().setAutoStartup("false");	if (contextStarted.get()) {	if (initialDelay.toMillis() > 0) {	
route will be started in 

if (routes.add(holder)) {	holder.getContext().setRouteController(SupervisingRouteController.this);	holder.getDefinition().setAutoStartup("false");	if (contextStarted.get()) {	if (initialDelay.toMillis() > 0) {	executorService.schedule(() -> startRoute(holder), initialDelay.toMillis(), TimeUnit.MILLISECONDS);	} else {	startRoute(holder);	}	} else {	
context is not yet started defer route start 

private void onCamelContextStarted() {	if (contextStarted.compareAndSet(false, true)) {	if (initialDelay.toMillis() > 0) {	
routes will be started in 

========================= camel sample_4141 =========================

public void testSuspendResume() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceived("A");	template.sendBody("seda:foo", "A");	assertMockEndpointsSatisfied();	
Suspending 

mock.expectedMessageCount(0);	context.suspendRoute("foo");	assertEquals("Suspended", context.getRouteStatus("foo").name());	Route route = context.getRoute("foo");	if (route instanceof StatefulService) {	assertEquals("Suspended", ((StatefulService) route).getStatus().name());	}	await().atMost(1, TimeUnit.SECONDS).until(() -> context.getEndpoint("seda:foo", SedaEndpoint.class).getQueue().size() == 0);	template.sendBody("seda:foo", "B");	mock.assertIsSatisfied(100);	
Resuming 

========================= camel sample_1343 =========================

conn.setAutoCommit(false);	}	shouldCloseResources = createAndExecuteSqlStatement(exchange, sql, conn);	conn.commit();	} catch (Exception e) {	try {	if (conn != null) {	conn.rollback();	}	} catch (Throwable sqle) {	
error occurred during jdbc rollback this exception will be ignored 

throw new IllegalArgumentException( "Header specifying expected returning columns isn't an instance of String[] or int[] but " + expectedGeneratedColumns.getClass());	}	} else {	ps = conn.prepareStatement(preparedQuery);	}	int expectedCount = ps.getParameterMetaData().getParameterCount();	if (expectedCount > 0) {	Iterator<?> it = getEndpoint().getPrepareStatementStrategy() .createPopulateIterator(sql, preparedQuery, expectedCount, exchange, exchange.getIn().getBody());	getEndpoint().getPrepareStatementStrategy().populateStatement(ps, it, expectedCount);	}	
executing jdbc preparedstatement 

private boolean doCreateAndExecuteSqlStatement(Exchange exchange, String sql, Connection conn) throws Exception {	Statement stmt = null;	ResultSet rs = null;	boolean shouldCloseResources = true;	try {	stmt = conn.createStatement();	if (parameters != null && !parameters.isEmpty()) {	Map<String, Object> copy = new HashMap<String, Object>(parameters);	IntrospectionSupport.setProperties(stmt, copy);	}	
executing jdbc statement 

private void closeQuietly(ResultSet rs) {	if (rs != null) {	try {	if (!rs.isClosed()) {	rs.close();	}	} catch (Throwable sqle) {	
error by closing result set 

private void closeQuietly(Statement stmt) {	if (stmt != null) {	try {	if (!stmt.isClosed()) {	stmt.close();	}	} catch (Throwable sqle) {	
error by closing statement 

private void resetAutoCommit(Connection con, Boolean autoCommit) {	if (con != null && autoCommit != null) {	try {	con.setAutoCommit(autoCommit);	} catch (Throwable sqle) {	
error by resetting auto commit to its original value 

private void closeQuietly(Connection con) {	if (con != null) {	try {	if (!con.isClosed()) {	con.close();	}	} catch (Throwable sqle) {	
error by closing connection 

========================= camel sample_14040 =========================

}	final ExchangePattern existingPattern = exchange.getPattern();	final Endpoint endpoint;	final ExchangePattern destinationExchangePattern;	Object recipient = null;	try {	recipient = expression.evaluate(exchange, Object.class);	endpoint = resolveEndpoint(exchange, recipient);	if (endpoint == null) {	if (LOG.isDebugEnabled()) {	
send dynamic evaluated as null so cannot send to any endpoint 

if (endpoint == null) {	if (LOG.isDebugEnabled()) {	}	callback.done(true);	return true;	}	destinationExchangePattern = EndpointHelper.resolveExchangePatternFromUrl(endpoint.getEndpointUri());	} catch (Throwable e) {	if (isIgnoreInvalidEndpoint()) {	if (LOG.isDebugEnabled()) {	
endpoint uri is invalid this exception will be ignored 

protected void doStart() throws Exception {	if (producerCache == null) {	if (cacheSize < 0) {	producerCache = new EmptyProducerCache(this, camelContext);	
dynamicsendto is not using producercache 

protected void doStart() throws Exception {	if (producerCache == null) {	if (cacheSize < 0) {	producerCache = new EmptyProducerCache(this, camelContext);	} else if (cacheSize == 0) {	producerCache = new ProducerCache(this, camelContext);	
dynamicsendto using producercache with default cache size 

========================= camel sample_4511 =========================

public void process(Exchange exchange) throws Exception {	String remotePath = DropboxHelper.getRemotePath(configuration, exchange);	DropboxConfigurationValidator.validateDelOp(remotePath);	DropboxDelResult result = new DropboxAPIFacade(configuration.getClient(), exchange) .del(remotePath);	exchange.getIn().setHeader(DropboxResultHeader.DELETED_PATH.name(), result.getEntry());	exchange.getIn().setBody(result.getEntry());	
deleted 

========================= camel sample_8498 =========================

public void act(final Client client, final Exchange exchange) throws NoSuchHeaderException {	final Long jobId = BeanstalkExchangeHelper.getJobID(exchange);	final long priority = BeanstalkExchangeHelper.getPriority(endpoint, exchange.getIn());	final boolean result = client.bury(jobId, priority);	if (!result && LOG.isWarnEnabled()) {	
failed to bury job d with priority d 

public void act(final Client client, final Exchange exchange) throws NoSuchHeaderException {	final Long jobId = BeanstalkExchangeHelper.getJobID(exchange);	final long priority = BeanstalkExchangeHelper.getPriority(endpoint, exchange.getIn());	final boolean result = client.bury(jobId, priority);	if (!result && LOG.isWarnEnabled()) {	} else if (LOG.isDebugEnabled()) {	
job d buried with priority d result is b 

========================= camel sample_8162 =========================

public void testQuartzPersistentStoreRestart() throws Exception {	AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzPersistentStoreTest.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMinimumMessageCount(2);	mock.assertIsSatisfied();	app.stop();	
restarting 

public void testQuartzPersistentStoreRestart() throws Exception {	AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzPersistentStoreTest.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMinimumMessageCount(2);	mock.assertIsSatisfied();	app.stop();	
restarting 

public void testQuartzPersistentStoreRestart() throws Exception {	AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzPersistentStoreTest.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMinimumMessageCount(2);	mock.assertIsSatisfied();	app.stop();	
restarting 

========================= camel sample_14943 =========================

sshd.setCommandFactory(new ScpCommandFactory());	sshd.setPasswordAuthenticator((username, password, session) -> true);	sshd.setPublickeyAuthenticator((username, password, session) -> true);	sshd.start();	} catch (Exception e) {	NoSuchAlgorithmException nsae = ObjectHelper.getException(NoSuchAlgorithmException.class, e);	if (nsae != null) {	canTest = false;	String name = System.getProperty("os.name");	String message = nsae.getMessage();	
is not avail on this platform testing is skipped real cause 

========================= camel sample_15201 =========================

public void testReceivingFileFromCache() throws Exception {	
beginning test testreceivingfilefromcache 

public void process(Exchange exchange) throws Exception {	exchange.setProperty(Exchange.CHARSET_NAME, "UTF-8");	Message in = exchange.getIn();	in.setHeader(CacheConstants.CACHE_OPERATION, operation);	in.setHeader(CacheConstants.CACHE_KEY, "greeting");	in.setBody("Hello World");	}	});	}	resultEndpoint.assertIsSatisfied();	
completed test testreceivingfilefromcache 

public void testReceivingSerializedObjectFromCache() throws Exception {	
beginning test testreceivingserializedobjectfromcache 

p.setPoem("Brahma");	exchange.setProperty(Exchange.CHARSET_NAME, "UTF-8");	Message in = exchange.getIn();	in.setHeader(CacheConstants.CACHE_OPERATION, operation);	in.setHeader(CacheConstants.CACHE_KEY, "poetry");	in.setBody(p);	}	});	}	resultEndpoint.assertIsSatisfied();	
completed test testreceivingfilefromcache 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() {	from("cache: public void process(Exchange exchange) throws Exception {	String operation = (String) exchange.getIn().getHeader(CacheConstants.CACHE_OPERATION);	String key = (String) exchange.getIn().getHeader(CacheConstants.CACHE_KEY);	Object body = exchange.getIn().getBody();	String data = exchange.getContext().getTypeConverter().convertTo(String.class, body);	if (log.isDebugEnabled()) {	
cache event notification 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() {	from("cache: public void process(Exchange exchange) throws Exception {	String operation = (String) exchange.getIn().getHeader(CacheConstants.CACHE_OPERATION);	String key = (String) exchange.getIn().getHeader(CacheConstants.CACHE_KEY);	Object body = exchange.getIn().getBody();	String data = exchange.getContext().getTypeConverter().convertTo(String.class, body);	if (log.isDebugEnabled()) {	
received notification for the following activity in cache 

public void configure() {	from("cache: public void process(Exchange exchange) throws Exception {	String operation = (String) exchange.getIn().getHeader(CacheConstants.CACHE_OPERATION);	String key = (String) exchange.getIn().getHeader(CacheConstants.CACHE_KEY);	Object body = exchange.getIn().getBody();	String data = exchange.getContext().getTypeConverter().convertTo(String.class, body);	if (log.isDebugEnabled()) {	log.debug("Operation = {}", operation);	log.debug("key = {}", key);	log.debug("value = {}", data);	
end cache event notification 

========================= camel sample_10516 =========================

public void testCreate() throws Exception {	final com.braintreegateway.Result result = requestBody("direct: assertNotNull("create result", result);	
create 

public void testFind() throws Exception {	final com.braintreegateway.PaymentMethodNonce result = requestBody("direct: assertNotNull("find result", result);	
find 

========================= camel sample_17379 =========================

addServicesOnStartup(map);	List<KeyValueHolder<String, KeyValueHolder<Object, Dictionary>>> servicesList = new LinkedList<KeyValueHolder<String, KeyValueHolder<Object, Dictionary>>>();	for (Map.Entry<String, KeyValueHolder<Object, Dictionary>> entry : map.entrySet()) {	servicesList.add(asKeyValueService(entry.getKey(), entry.getValue().getKey(), entry.getValue().getValue()));	}	addServicesOnStartup(servicesList);	for (KeyValueHolder<String, KeyValueHolder<Object, Dictionary>> item : servicesList) {	String clazz = item.getKey();	Object service = item.getValue().getKey();	Dictionary dict = item.getValue().getValue();	
registering service 

if (currentProperties == null) {	currentProperties = newProps;	}	for (Enumeration<String> ek = currentProperties.keys(); ek.hasMoreElements();) {	String k = ek.nextElement();	newProps.put(k, currentProperties.get(k));	}	for (String p : ((Properties) props).stringPropertyNames()) {	newProps.put(p, ((Properties) props).getProperty(p));	}	
updating configadmin by overriding properties 

if (isCreateCamelContextPerClass()) {	boolean first = threadLocalBundleContext.get() == null;	if (first) {	threadLocalBundleContext.set(createBundleContext());	}	bundleContext = threadLocalBundleContext.get();	} else {	bundleContext = createBundleContext();	}	super.setUp();	
starting camelcontext 

boolean first = threadLocalBundleContext.get() == null;	if (first) {	threadLocalBundleContext.set(createBundleContext());	}	bundleContext = threadLocalBundleContext.get();	} else {	bundleContext = createBundleContext();	}	super.setUp();	if (isUseAdviceWith()) {	
skipping starting camelcontext as isuseadvicewith is set to true 

========================= camel sample_10146 =========================

QName elName2 = strategy.findQNameForSoapActionOrType("getCustomersByName", GetCustomersByName.class);	assertEquals("http: assertEquals("getCustomersByName", elName2.getLocalPart());	QName elName3 = strategy.findQNameForSoapActionOrType("http: null);	assertNull(elName3);	QName elName4 = strategy.findQNameForSoapActionOrType("http: null);	assertNull(elName4);	try {	elName = strategy.findQNameForSoapActionOrType("test", Class.class);	fail();	} catch (RuntimeCamelException e) {	
caught expected message 

public void testServiceInterfaceStrategyWithServer() {	ServiceInterfaceStrategy strategy = new ServiceInterfaceStrategy(CustomerService.class, false);	QName elName = strategy.findQNameForSoapActionOrType("", GetCustomersByNameResponse.class);	assertEquals("http: assertEquals("getCustomersByNameResponse", elName.getLocalPart());	QName elName2 = strategy.findQNameForSoapActionOrType("http: GetCustomersByName.class);	assertEquals("http: assertEquals("getCustomersByNameResponse", elName2.getLocalPart());	try {	elName = strategy.findQNameForSoapActionOrType("test", Class.class);	fail();	} catch (RuntimeCamelException e) {	
caught expected message 

public void testServiceInterfaceStrategyWithRequestWrapperAndClient() {	ServiceInterfaceStrategy strategy = new ServiceInterfaceStrategy( com.example.customerservice2.CustomerService.class, true);	QName elName = strategy.findQNameForSoapActionOrType("", com.example.customerservice2.GetCustomersByName.class);	assertEquals("http: assertEquals("getCustomersByName", elName.getLocalPart());	try {	elName = strategy.findQNameForSoapActionOrType("test", Class.class);	fail();	} catch (RuntimeCamelException e) {	
caught expected message 

public void testWithNonWebservice() {	try {	new ServiceInterfaceStrategy(Object.class, true);	fail("Should throw an exception for a class that is no webservice");	} catch (IllegalArgumentException e) {	
caught expected message 

========================= camel sample_9636 =========================

private void appendToStore(String key, String value) {	if (LOG.isDebugEnabled()) {	LOG.debug("Appending {}={} to state filestore: {}", new Object[]{key, value, fileStore});	}	FileOutputStream fos = null;	try {	File storeParentDirectory = fileStore.getParentFile();	if (storeParentDirectory != null && !storeParentDirectory.exists()) {	
parent directory of file store doesn t exist creating 

private void appendToStore(String key, String value) {	if (LOG.isDebugEnabled()) {	LOG.debug("Appending {}={} to state filestore: {}", new Object[]{key, value, fileStore});	}	FileOutputStream fos = null;	try {	File storeParentDirectory = fileStore.getParentFile();	if (storeParentDirectory != null && !storeParentDirectory.exists()) {	if (fileStore.getParentFile().mkdirs()) {	
parent directory of file store successfully created 

private void appendToStore(String key, String value) {	if (LOG.isDebugEnabled()) {	LOG.debug("Appending {}={} to state filestore: {}", new Object[]{key, value, fileStore});	}	FileOutputStream fos = null;	try {	File storeParentDirectory = fileStore.getParentFile();	if (storeParentDirectory != null && !storeParentDirectory.exists()) {	if (fileStore.getParentFile().mkdirs()) {	} else {	
parent directory of file store cannot be created 

protected void trunkStore() {	
trunking state filestore 

protected void loadStore() throws IOException {	if (!fileStore.exists()) {	
creating filestore 

if (!fileStore.exists()) {	File parent = fileStore.getParentFile();	if (parent != null) {	parent.mkdirs();	}	boolean created = FileUtil.createNewFile(fileStore);	if (!created) {	throw new IOException("Cannot create filestore: " + fileStore);	}	}	
loading to level cache from state filestore 

String value = line.substring(separatorIndex + KEY_VALUE_DELIMITER.length());	cache.put(key, value);	}	} catch (IOException e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	} finally {	if (scanner != null) {	scanner.close();	}	}	
loaded to the level cache from state filestore 

========================= camel sample_4004 =========================

protected void doGetBuildConfig(Exchange exchange, String operation) throws Exception {	BuildConfig buildConfig = null;	String buildConfigName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_BUILD_CONFIG_NAME, String.class);	String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(buildConfigName)) {	
get a specific build config require specify a build config name 

protected void doGetBuildConfig(Exchange exchange, String operation) throws Exception {	BuildConfig buildConfig = null;	String buildConfigName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_BUILD_CONFIG_NAME, String.class);	String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(buildConfigName)) {	throw new IllegalArgumentException("Get a specific Build Config require specify a Build Config name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
get a specific build config require specify a namespace name 

========================= camel sample_13290 =========================

URL blueprintUrl = ObjectHelper.loadResourceAsURL("org/apache/camel/itest/CamelTypeConverterTest.xml", CamelTypeConverterTest.class.getClassLoader());	installBlueprintAsBundle("CamelTypeConverterTest", blueprintUrl, true, bundle -> {	((TinyBundle) bundle) .add("META-INF/services/org/apache/camel/TypeConverter", new ByteArrayInputStream("org.apache.camel.itest.typeconverter.MyConverter".getBytes())) .add(MyConverter.class, InnerClassStrategy.NONE) .set(Constants.DYNAMICIMPORT_PACKAGE, "*");	});	CamelContext camel = getOsgiService(bundleContext, CamelContext.class);	final Pojo pojo = new Pojo();	String pojoName = "Constantine";	pojo.setName(pojoName);	final DefaultExchange exchange = new DefaultExchange(camel);	final String string = camel.getTypeConverter().mandatoryConvertTo(String.class, exchange, pojo);	
pojo string 

installBlueprintAsBundle("CamelTypeConverterTest", blueprintUrl, true, bundle -> {	((TinyBundle) bundle) .add("META-INF/services/org/apache/camel/TypeConverter", new ByteArrayInputStream("org.apache.camel.itest.typeconverter.MyConverter".getBytes())) .add(MyConverter.class, InnerClassStrategy.NONE) .set(Constants.DYNAMICIMPORT_PACKAGE, "*");	});	CamelContext camel = getOsgiService(bundleContext, CamelContext.class);	final Pojo pojo = new Pojo();	String pojoName = "Constantine";	pojo.setName(pojoName);	final DefaultExchange exchange = new DefaultExchange(camel);	final String string = camel.getTypeConverter().mandatoryConvertTo(String.class, exchange, pojo);	final Pojo copy = camel.getTypeConverter().mandatoryConvertTo(Pojo.class, exchange, string);	
string pojo 

========================= camel sample_6469 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<JmsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jms.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jms.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_418 =========================

public void testBigPayload() throws Exception {	
running test for millis 

public void testBigPayload() throws Exception {	Thread.sleep(60 * 1000);	File file = new File("target/data/leveldb.dat");	assertTrue(file + " should exists", file.exists());	long size = file.length();	
size is 

========================= camel sample_13910 =========================

public void testSyncSyncMethodInSync() throws Exception {	
grpc pingsyncsync method blocking test start 

public void testSyncAsyncMethodInSync() throws Exception {	
grpc pingsyncasync method blocking test start 

public void testSyncSyncMethodInAsync() throws Exception {	
grpc pingsyncsync method aync test start 

public void testSyncAsyncMethodInAsync() throws Exception {	
grpc pingsyncasync method aync test start 

public void testAsyncSyncMethodInAsync() throws Exception {	
grpc pingasyncsync method aync test start 

public void testAsyncAsyncMethodInAsync() throws Exception {	
grpc pingasyncasync method aync test start 

public void onError(Throwable t) {	
Exception 

========================= camel sample_7501 =========================

public void startThriftZlibClient() throws IOException, TTransportException {	if (transport == null) {	
connecting to the thrift server with zlib compression on port 

public void startThriftZlibClient() throws IOException, TTransportException {	if (transport == null) {	transport = new TSocket("localhost", THRIFT_TEST_PORT, THRIFT_CLIENT_TIMEOUT);	protocol = new TBinaryProtocol(new TZlibTransport(transport));	thriftClient = new Calculator.Client(protocol);	transport.open();	
connected to the thrift server with zlib compression 

public void stopThriftClient() throws Exception {	if (transport != null) {	transport.close();	transport = null;	
connection to the thrift server closed 

public void testCalculateMethodInvocation() throws Exception {	
test calculate method invocation 

public void testEchoMethodInvocation() throws Exception {	
test echo method invocation 

========================= camel sample_13013 =========================

public void testWSHttpCallEcho() throws Exception {	final List<String> received = new ArrayList<String>();	final CountDownLatch latch = new CountDownLatch(2);	DefaultAsyncHttpClient c = new DefaultAsyncHttpClient();	WebSocket websocket = c.prepareGet("ws: new WebSocketUpgradeHandler.Builder() .addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

========================= camel sample_13156 =========================

protected boolean pollDirectory(String fileName, List<GenericFile<File>> fileList, int depth) {	
polldirectory from filename 

protected boolean pollDirectory(String fileName, List<GenericFile<File>> fileList, int depth) {	depth++;	File directory = new File(fileName);	if (!directory.exists() || !directory.isDirectory()) {	
cannot poll as directory does not exists or its not a directory 

protected boolean pollDirectory(String fileName, List<GenericFile<File>> fileList, int depth) {	depth++;	File directory = new File(fileName);	if (!directory.exists() || !directory.isDirectory()) {	if (getEndpoint().isDirectoryMustExist()) {	throw new GenericFileOperationFailedException("Directory does not exist: " + directory);	}	return true;	}	
polling directory 

File directory = new File(fileName);	if (!directory.exists() || !directory.isDirectory()) {	if (getEndpoint().isDirectoryMustExist()) {	throw new GenericFileOperationFailedException("Directory does not exist: " + directory);	}	return true;	}	File[] dirFiles = directory.listFiles();	if (dirFiles == null || dirFiles.length == 0) {	if (log.isTraceEnabled()) {	
no files found in directory 

}	return true;	}	File[] dirFiles = directory.listFiles();	if (dirFiles == null || dirFiles.length == 0) {	if (log.isTraceEnabled()) {	}	return true;	} else {	if (log.isTraceEnabled()) {	
found in directory 

}	List<File> files = Arrays.asList(dirFiles);	if (getEndpoint().isPreSort()) {	Collections.sort(files, (a, b) -> a.getAbsoluteFile().compareTo(a.getAbsoluteFile()));	}	for (File file : dirFiles) {	if (!canPollMoreFiles(fileList)) {	return false;	}	if (log.isTraceEnabled()) {	
found file isabsolute isdirectory isfile ishidden 

if (file.isDirectory()) {	if (endpoint.isRecursive() && depth < endpoint.getMaxDepth() && isValidFile(gf, true, files)) {	String subDirectory = fileName + File.separator + file.getName();	boolean canPollMore = pollDirectory(subDirectory, fileList, depth);	if (!canPollMore) {	return false;	}	}	} else {	if (depth >= endpoint.minDepth && isValidFile(gf, false, files)) {	
adding valid file 

allAttributes.put(prefix + entry.getKey(), entry.getValue());	}	}	} else if (!attribute.contains(":")) {	allAttributes.put("basic:" + attribute, Files.getAttribute(path, attribute));	} else {	allAttributes.put(attribute, Files.getAttribute(path, attribute));	}	} catch (IOException e) {	if (log.isDebugEnabled()) {	
unable to read attribute on file 

protected boolean isMatched(GenericFile<File> file, String doneFileName, List<File> files) {	String onlyName = FileUtil.stripPath(doneFileName);	for (File f : files) {	if (f.getName().equals(onlyName)) {	return true;	}	}	
done file does not exist 

========================= camel sample_4792 =========================

protected RouteBuilder createRouteBuilder() {	return new RouteBuilder() {	public void configure() {	from("seda:async").to("direct:foo");	from("direct:foo").process(new Processor() {	public void process(Exchange exchange) throws Exception {	
received 

});	exchange.getUnitOfWork().addSynchronization(new SynchronizationAdapter() {	public void onFailure(Exchange exchange) {	failed = exchange;	baz = exchange.getIn().getHeader("baz");	doneLatch.countDown();	}	});	String name = getName();	if (name.equals("testFail")) {	
failing test 

failed = exchange;	baz = exchange.getIn().getHeader("baz");	doneLatch.countDown();	}	});	String name = getName();	if (name.equals("testFail")) {	exchange.getOut().setFault(true);	exchange.getOut().setBody("testFail() should always fail with a fault!");	} else if (name.equals("testException")) {	
throwing exception 

========================= camel sample_2216 =========================

public BindyAbstractFactory(Class<?> type) throws Exception {	this.type = type;	if (LOG.isDebugEnabled()) {	
class name 

private void loadModels(Class<?> root) {	models.add(root);	modelClassNames.add(root.getName());	for (Field field : root.getDeclaredFields()) {	Link linkField = field.getAnnotation(Link.class);	if (linkField != null) {	if (LOG.isDebugEnabled()) {	
class linked field 

if (linkField != null) {	if (LOG.isDebugEnabled()) {	}	models.add(field.getType());	modelClassNames.add(field.getType().getName());	loadModels(field.getType());	}	OneToMany oneToManyField = field.getAnnotation(OneToMany.class);	if (oneToManyField != null) {	if (LOG.isDebugEnabled()) {	
class onetomany linked field 

========================= camel sample_7444 =========================

if (EtcdHelper.isOutdatedIndexException(exception)) {	LOGGER.debug("Outdated index, key={}, cause={}", servicePath, exception.etcdCause);	index.set(exception.index + 1);	}	} else {	try {	EtcdKeysResponse response = promise.get();	EtcdHelper.setIndex(index, response);	serversRef.set(getServices());	} catch (TimeoutException e) {	
timeout watching for 

========================= camel sample_12253 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	errorHandler(defaultErrorHandler().maximumRedeliveries(2).redeliveryDelay(0));	onException(IllegalArgumentException.class).onRedelivery(new Processor() {	public void process(Exchange exchange) throws Exception {	
onredelivery invoked 

========================= camel sample_3810 =========================

public void onError(Throwable t) {	
Exception 

========================= camel sample_7500 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<AtomixMultiMapComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.atomix-multimap.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.atomix-multimap.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1084 =========================

public void testCalculateMethodInvocation() throws Exception {	
thrift calculate method async test start 

public void testAddMethodInvocation() throws Exception {	
thrift add method primitive parameters only async test start 

public void testCalculateWithException() throws Exception {	
thrift calculate method with business exception async test start 

public void testVoidMethodInvocation() throws Exception {	
thrift method with empty parameters and void output async test start 

public void testOneWayMethodInvocation() throws Exception {	
thrift one way method async test start 

public void testAllTypesMethodInvocation() throws Exception {	
thrift method with all possile types async test start 

public void testEchoMethodInvocation() throws Exception {	
thrift echo method return output as pass input parameter async test start 

========================= camel sample_13012 =========================

public GenericFileProcessStrategy<T> getGenericFileProcessStrategy() {	if (processStrategy == null) {	processStrategy = createGenericFileStrategy();	
using generic file process strategy 

});	consumer.setStartScheduler(false);	ServiceHelper.startService(consumer);	consumer.poll();	} catch (Exception e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	} finally {	try {	ServiceHelper.stopService(consumer);	} catch (Exception e) {	
error stopping consumer used for browsing exchanges this exception will be ignored 

protected GenericFileProcessStrategy<T> createGenericFileStrategy() {	Class<?> factory = null;	try {	FactoryFinder finder = getCamelContext().getFactoryFinder("META-INF/services/org/apache/camel/component/");	
using factoryfinder 

protected GenericFileProcessStrategy<T> createGenericFileStrategy() {	Class<?> factory = null;	try {	FactoryFinder finder = getCamelContext().getFactoryFinder("META-INF/services/org/apache/camel/component/");	factory = finder.findClass(getScheme(), "strategy.factory.", CamelContext.class);	} catch (ClassNotFoundException e) {	
strategy factory class not found 

protected GenericFileProcessStrategy<T> createGenericFileStrategy() {	Class<?> factory = null;	try {	FactoryFinder finder = getCamelContext().getFactoryFinder("META-INF/services/org/apache/camel/component/");	factory = finder.findClass(getScheme(), "strategy.factory.", CamelContext.class);	} catch (ClassNotFoundException e) {	} catch (IOException e) {	
no strategy factory defined in meta inf services org apache camel component 

protected GenericFileProcessStrategy<T> createGenericFileStrategy() {	Class<?> factory = null;	try {	FactoryFinder finder = getCamelContext().getFactoryFinder("META-INF/services/org/apache/camel/component/");	factory = finder.findClass(getScheme(), "strategy.factory.", CamelContext.class);	} catch (ClassNotFoundException e) {	} catch (IOException e) {	}	if (factory == null) {	try {	
using classresolver to resolve class 

try {	FactoryFinder finder = getCamelContext().getFactoryFinder("META-INF/services/org/apache/camel/component/");	factory = finder.findClass(getScheme(), "strategy.factory.", CamelContext.class);	} catch (ClassNotFoundException e) {	} catch (IOException e) {	}	if (factory == null) {	try {	factory = this.getCamelContext().getClassResolver().resolveClass(DEFAULT_STRATEGYFACTORY_CLASS);	} catch (Exception e) {	
cannot load class 

} catch (ClassNotFoundException e) {	} catch (IOException e) {	}	if (factory == null) {	try {	factory = this.getCamelContext().getClassResolver().resolveClass(DEFAULT_STRATEGYFACTORY_CLASS);	} catch (Exception e) {	}	try {	if (log.isTraceEnabled()) {	
using classloader to resolve class 

try {	factory = this.getCamelContext().getClassResolver().resolveClass(DEFAULT_STRATEGYFACTORY_CLASS);	} catch (Exception e) {	}	try {	if (log.isTraceEnabled()) {	}	factory = this.getCamelContext().getClassResolver().resolveClass(DEFAULT_STRATEGYFACTORY_CLASS, this.getClass().getClassLoader());	} catch (Exception e) {	if (log.isTraceEnabled()) {	
cannot load class using classloader 

if (log.isTraceEnabled()) {	}	}	if (factory == null) {	throw new TypeNotPresentException(DEFAULT_STRATEGYFACTORY_CLASS + " class not found", null);	}	}	try {	Method factoryMethod = factory.getMethod("createGenericFileProcessStrategy", CamelContext.class, Map.class);	Map<String, Object> params = getParamsAsMap();	
parameters for generic file process strategy 

========================= camel sample_4793 =========================

exchange.setException(e);	logTransactionRollback(redelivered, ids, e, false);	} finally {	exchange.getUnitOfWork().endTransactedBy(transactionKey);	}	Boolean onlyLast = (Boolean) exchange.removeProperty(Exchange.ROLLBACK_ONLY_LAST);	if (onlyLast != null && onlyLast) {	if (log.isDebugEnabled()) {	Exception cause = exchange.getException();	if (cause != null) {	
transaction rollback redelivered for due exchange was marked for rollbackonlylast and caught 

logTransactionRollback(redelivered, ids, e, false);	} finally {	exchange.getUnitOfWork().endTransactedBy(transactionKey);	}	Boolean onlyLast = (Boolean) exchange.removeProperty(Exchange.ROLLBACK_ONLY_LAST);	if (onlyLast != null && onlyLast) {	if (log.isDebugEnabled()) {	Exception cause = exchange.getException();	if (cause != null) {	} else {	
transaction rollback redelivered for due exchange was marked for rollbackonlylast 

if (exchange.getException() != null || exchange.isRollbackOnly()) {	if (exchange.getException() != null) {	rce = ObjectHelper.wrapRuntimeCamelException(exchange.getException());	} else {	rce = new TransactionRollbackException();	}	if (!status.isRollbackOnly()) {	status.setRollbackOnly();	}	if (log.isTraceEnabled()) {	
throwing runtime exception to force transaction to rollback on 

protected void processByErrorHandler(final Exchange exchange) {	final CountDownLatch latch = new CountDownLatch(1);	boolean sync = super.process(exchange, new AsyncCallback() {	public void done(boolean doneSync) {	if (!doneSync) {	
asynchronous callback received for exchangeid 

public void done(boolean doneSync) {	if (!doneSync) {	latch.countDown();	}	}	public String toString() {	return "Done " + TransactionErrorHandler.this.toString();	}	});	if (!sync) {	
waiting for asynchronous callback before continuing for exchangeid 

public String toString() {	return "Done " + TransactionErrorHandler.this.toString();	}	});	if (!sync) {	try {	latch.await();	} catch (InterruptedException e) {	exchange.setException(e);	}	
asynchronous callback received will continue routing exchangeid 

========================= camel sample_16355 =========================

}	}	public void onNext(Exchange ex) {	if (!active.get()) {	return;	}	R r;	try {	r = converter.apply(ex);	} catch (TypeConversionException e) {	
unable to convert body to the specified type 

========================= camel sample_11490 =========================

final int tempI = i;	Runnable worker = new Runnable() {	public void run() {	try {	final String requestText = "Message " + tempI;	final String responseText = "Response Message " + tempI;	String response = template.requestBody("direct:start", requestText, String.class);	assertNotNull(response);	assertEquals(responseText, response);	} catch (Exception e) {	
todo auto generated catch block 

========================= camel sample_12316 =========================

private FactoryRegistry tryToGetFactoryRegistry() {	Function<CamelContext, Registry> f = CamelContext::getRegistry;	Function<Registry, Set<FactoryRegistry>> g = r -> r.findByType(FactoryRegistry.class);	Function<Set<FactoryRegistry>, FactoryRegistry> h = factoryRegistries -> {	if (factoryRegistries.size() > 1) {	
number of registered 

========================= camel sample_7445 =========================

public void startView(String namespace) throws Exception {	LockHelper.doWithWriteLockT( lock, () -> {	ViewHolder<T> holder = views.get(namespace);	if (holder != null) {	
force start of view 

public void startView(String namespace) throws Exception {	LockHelper.doWithWriteLockT( lock, () -> {	ViewHolder<T> holder = views.get(namespace);	if (holder != null) {	holder.startView();	} else {	
error forcing start of view it does not exist 

public void stopView(String namespace) throws Exception {	LockHelper.doWithWriteLockT( lock, () -> {	ViewHolder<T> holder = views.get(namespace);	if (holder != null) {	
force stop of view 

public void stopView(String namespace) throws Exception {	LockHelper.doWithWriteLockT( lock, () -> {	ViewHolder<T> holder = views.get(namespace);	if (holder != null) {	holder.stopView();	} else {	
error forcing stop of view it does not exist 

LOGGER.debug("Retain view {}, old-refs={}", view.getNamespace(), count.get());	count.retain();	return get();	}	void release() {	LOGGER.debug("Release view {}, old-refs={}", view.getNamespace(), count.get());	count.release();	}	void startView() throws Exception {	if (AbstractCamelClusterService.this.isRunAllowed()) {	
start view 

return get();	}	void release() {	LOGGER.debug("Release view {}, old-refs={}", view.getNamespace(), count.get());	count.release();	}	void startView() throws Exception {	if (AbstractCamelClusterService.this.isRunAllowed()) {	view.start();	} else {	
can t start view as cluster service is not running view will be started on service start up 

LOGGER.debug("Release view {}, old-refs={}", view.getNamespace(), count.get());	count.release();	}	void startView() throws Exception {	if (AbstractCamelClusterService.this.isRunAllowed()) {	view.start();	} else {	}	}	void stopView() throws Exception {	
stop view 

========================= camel sample_3955 =========================

}	} else {	StringBuilder pathsExtracted = new StringBuilder();	for (Map.Entry<String, DropboxResultCode> entry : map.entrySet()) {	pathsExtracted.append(entry.getKey()).append("\n");	}	exchange.getIn().setHeader(DropboxResultHeader.UPLOADED_FILES.name(), pathsExtracted.toString());	exchange.getIn().setBody(map);	}	if (LOG.isDebugEnabled()) {	
uploaded 

========================= camel sample_8499 =========================

public void act(final Client client, final Exchange exchange) throws NoSuchHeaderException {	final Long jobId = ExchangeHelper.getMandatoryHeader(exchange, Headers.JOB_ID, Long.class);	final boolean result = client.touch(jobId);	if (!result && LOG.isWarnEnabled()) {	
failed to touch job d 

public void act(final Client client, final Exchange exchange) throws NoSuchHeaderException {	final Long jobId = ExchangeHelper.getMandatoryHeader(exchange, Headers.JOB_ID, Long.class);	final boolean result = client.touch(jobId);	if (!result && LOG.isWarnEnabled()) {	} else if (LOG.isDebugEnabled()) {	
job d touched result is b 

========================= camel sample_8163 =========================

public void testGenerate() throws Exception {	final com.braintreegateway.Result result = requestBody("direct: assertNotNull("generate result", result);	
generate 

public void testGenerateWithCustomFields() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBraintree.settlementDate", null);	headers.put("CamelBraintree.groupByCustomField", null);	final com.braintreegateway.Result result = requestBodyAndHeaders("direct: assertNotNull("generate result", result);	
generate 

========================= camel sample_17378 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<BarcodeDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.barcode.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.barcode.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_730 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<PahoComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.paho.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.paho.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1207 =========================

public boolean apply(Event event) {	Exchange exchange = endpoint.createExchange(ExchangePattern.InOnly);	Message in = exchange.getIn();	in.setBody(event);	try {	if (LOG.isTraceEnabled()) {	
processing ignite event 

Message in = exchange.getIn();	in.setBody(event);	try {	if (LOG.isTraceEnabled()) {	}	getAsyncProcessor().process(exchange, new AsyncCallback() {	public void done(boolean doneSync) {	}	});	} catch (Exception e) {	
exception while processing ignite event s 

protected void doStart() throws Exception {	super.doStart();	if (endpoint.getEvents() != null && endpoint.getEvents().size() > 0) {	eventTypes = new int[endpoint.getEvents().size()];	int counter = 0;	for (Integer i : endpoint.getEvents()) {	eventTypes[counter++] = i;	}	}	events.localListen(predicate, eventTypes);	
started local ignite events consumer for events 

protected void doStop() throws Exception {	super.doStop();	events.stopLocalListen(predicate, eventTypes);	
stopped local ignite events consumer for events 

========================= camel sample_11306 =========================

private void doUpdateCronDetails() throws Exception {	String trigger = "myTimer";	String group = "myGroup";	String cronExpression = "0 * * * * ?";	MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();	Set<ObjectName> objectNames = mBeanServer.queryNames( new ObjectName("quartz:type=QuartzScheduler,name=*,instance=NON_CLUSTERED"), null);	assertFalse("There should be a quartz scheduler MBean", objectNames.isEmpty());	ObjectName oName = objectNames.stream().findFirst().get();	
scheduler mbean 

========================= camel sample_6468 =========================

public boolean process(Exchange exchange, AsyncCallback callback) {	
processing 

========================= camel sample_14780 =========================

private void writeFile() throws Exception {	
writing file 

private void writeFile() throws Exception {	FileOutputStream fos = new FileOutputStream("target/changed/in/file.dat");	fos.write("Line".getBytes());	fos.flush();	fos.close();	
writing file done 

========================= camel sample_3144 =========================

String message = exchange.getIn().getBody(String.class);	Level level = exchange.getIn().getHeader(LEVEL, Level.class);	if (level == null) {	String name = exchange.getIn().getHeader(LEVEL, Level.OK.name(), String.class);	level = Level.valueOf(name);	}	String serviceName = exchange.getIn().getHeader(SERVICE_NAME, exchange.getContext().getName(), String.class);	String hostName = exchange.getIn().getHeader(HOST_NAME, "localhost", String.class);	MessagePayload payload = new MessagePayload(hostName, level, serviceName, message);	if (log.isDebugEnabled()) {	
sending notification to nagios 

if (level == null) {	String name = exchange.getIn().getHeader(LEVEL, Level.OK.name(), String.class);	level = Level.valueOf(name);	}	String serviceName = exchange.getIn().getHeader(SERVICE_NAME, exchange.getContext().getName(), String.class);	String hostName = exchange.getIn().getHeader(HOST_NAME, "localhost", String.class);	MessagePayload payload = new MessagePayload(hostName, level, serviceName, message);	if (log.isDebugEnabled()) {	}	sender.send(payload);	
sending notification done 

========================= camel sample_9119 =========================

isSleepycatStore(settings, impliedMessageStoreFactories);	if (impliedMessageStoreFactories.size() > 1) {	throw new ConfigError("Ambiguous message store implied in configuration.");	}	MessageStoreFactory messageStoreFactory;	if (impliedMessageStoreFactories.size() == 1) {	messageStoreFactory = impliedMessageStoreFactories.iterator().next();	} else {	messageStoreFactory = new MemoryStoreFactory();	}	
inferring message store factory 

========================= camel sample_10669 =========================

protected void installWatch() {	connection.exists(getNode(), this, new StatCallback() {	public void processResult(int rc, String path, Object ctx, Stat stat) {	}	}, null);	if (LOG.isDebugEnabled()) {	
installed exists watch 

========================= camel sample_12654 =========================

private void doTestWSHttpCall() throws Exception {	AsyncHttpClient c = new DefaultAsyncHttpClient();	WebSocket websocket = c.prepareGet("ws: new WebSocketUpgradeHandler.Builder() .addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

========================= camel sample_17456 =========================

public void testSendToAlotOfMessageToQueues() throws Exception {	int size = 100;	
about to send messages 

public void testSendToAlotOfMessageToQueues() throws Exception {	int size = 100;	for (int i = 0; i < size; i++) {	if (i > 0 && i % 50 == 0) {	
send messages so far 

public void testSendToAlotOfMessageToQueues() throws Exception {	int size = 100;	for (int i = 0; i < size; i++) {	if (i > 0 && i % 50 == 0) {	}	template.sendBodyAndHeader(URI, ExchangePattern.InOnly, "Hello " + i, JmsConstants.JMS_DESTINATION_NAME, "foo" + i);	}	
send complete use jconsole to view 

========================= camel sample_7107 =========================

public void testJavaVersion() throws Exception {	ExecResult body = templateJavaVersion.requestBody((Object)"test", ExecResult.class);	InputStream out = body.getStdout();	InputStream err = body.getStderr();	assertNull(out);	assertNotNull(err);	String outString = IOUtils.toString(err);	
received stdout 

public void testWinJavaVersionWorkingDir() throws Exception {	ExecResult body = templateJavaVersionWorkingDir.requestBody((Object)"test", ExecResult.class);	InputStream out = body.getStdout();	InputStream err = body.getStderr();	assertNull(out);	assertNotNull(err);	String outerr = IOUtils.toString(err);	
received stderr 

========================= camel sample_12204 =========================

public void run() {	try {	context.getTypeConverter().mandatoryConvertTo(MyCamelBean.class, "1;MyCamel");	latch.countDown();	} catch (NoTypeConversionAvailableException e) {	}	}	});	}	assertTrue("The expected mandatory conversions failed!", latch.await(1, TimeUnit.MINUTES));	
took millis to convert objects 

========================= camel sample_3902 =========================

private void dumpThreads() {	ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();	for (ThreadInfo threadInfo : threadMXBean.getThreadInfo(threadMXBean.getAllThreadIds(), Integer.MAX_VALUE)) {	if (Thread.State.BLOCKED.equals(threadInfo.getThreadState())) {	
blocked thread 

private void dumpThreads() {	ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();	for (ThreadInfo threadInfo : threadMXBean.getThreadInfo(threadMXBean.getAllThreadIds(), Integer.MAX_VALUE)) {	if (Thread.State.BLOCKED.equals(threadInfo.getThreadState())) {	} else {	
normal thread 

private void dumpThreads() {	ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();	for (ThreadInfo threadInfo : threadMXBean.getThreadInfo(threadMXBean.getAllThreadIds(), Integer.MAX_VALUE)) {	if (Thread.State.BLOCKED.equals(threadInfo.getThreadState())) {	} else {	}	
full stack t 

========================= camel sample_12341 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ControlBusComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.controlbus.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.controlbus.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_858 =========================

protected void onRequestComplete() {	
onRequestComplete 

protected void onResponseComplete(Result result, byte[] content) {	
onResponseComplete 

protected void onExpire() {	
onExpire 

protected void onException(Throwable ex) {	
onexception 

protected void onConnectionFailed(Throwable ex) {	
onconnectionfailed 

========================= camel sample_11097 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<YqlComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.yql.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.yql.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1196 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SmppComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.smpp.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.smpp.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_622 =========================

public static void assertInMessageBodyEquals(Exchange exchange, Object expected) throws InvalidPayloadException {	assertNotNull("Should have a response exchange!", exchange);	Object actual;	if (expected == null) {	actual = ExchangeHelper.getMandatoryInBody(exchange);	assertEquals("in body of: " + exchange, expected, actual);	} else {	actual = ExchangeHelper.getMandatoryInBody(exchange, expected.getClass());	}	assertEquals("in body of: " + exchange, expected, actual);	
received response with in 

public static void assertOutMessageBodyEquals(Exchange exchange, Object expected) throws InvalidPayloadException {	assertNotNull("Should have a response exchange!", exchange);	Object actual;	if (expected == null) {	actual = ExchangeHelper.getMandatoryOutBody(exchange);	assertEquals("output body of: " + exchange, expected, actual);	} else {	actual = ExchangeHelper.getMandatoryOutBody(exchange, expected.getClass());	}	assertEquals("output body of: " + exchange, expected, actual);	
received response with out 

public static Object assertExpression(Expression expression, Exchange exchange, Object expected) {	Object value;	if (expected != null) {	value = expression.evaluate(exchange, expected.getClass());	} else {	value = expression.evaluate(exchange, Object.class);	}	
evaluated expression on exchange result 

public static void assertPredicateDoesNotMatch(Predicate predicate, Exchange exchange) {	try {	PredicateAssertHelper.assertMatches(predicate, "Predicate should match: ", exchange);	} catch (AssertionError e) {	
caught expected assertion error 

public static boolean assertPredicate(final Predicate predicate, Exchange exchange, boolean expected) {	if (expected) {	PredicateAssertHelper.assertMatches(predicate, "Predicate failed: ", exchange);	}	boolean value = predicate.matches(exchange);	
evaluated predicate on exchange result 

return;	}	if (file.isDirectory()) {	File[] files = file.listFiles();	for (File child : files) {	recursivelyDeleteDirectory(child);	}	}	boolean success = file.delete();	if (!success) {	
deletion of file failed 

========================= camel sample_6829 =========================

public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {	if (!super.acquireExclusiveReadLock(operations, file, exchange)) {	return false;	}	File target = new File(file.getAbsoluteFilePath());	boolean exclusive = false;	
waiting for exclusive read lock to file 

if (timeout > 0) {	long delta = watch.taken();	if (delta > timeout) {	CamelLogger.log(LOG, readLockLoggingLevel, "Cannot acquire read lock within " + timeout + " millis. Will skip the file: " + file);	return false;	}	}	long newLastModified = target.lastModified();	long newLength = target.length();	long newOlderThan = startTime + watch.taken() - minAge;	
previous last modified new last modified 

if (timeout > 0) {	long delta = watch.taken();	if (delta > timeout) {	CamelLogger.log(LOG, readLockLoggingLevel, "Cannot acquire read lock within " + timeout + " millis. Will skip the file: " + file);	return false;	}	}	long newLastModified = target.lastModified();	long newLength = target.length();	long newOlderThan = startTime + watch.taken() - minAge;	
previous length new length 

if (timeout > 0) {	long delta = watch.taken();	if (delta > timeout) {	CamelLogger.log(LOG, readLockLoggingLevel, "Cannot acquire read lock within " + timeout + " millis. Will skip the file: " + file);	return false;	}	}	long newLastModified = target.lastModified();	long newLength = target.length();	long newOlderThan = startTime + watch.taken() - minAge;	
new older than threshold 

long delta = watch.taken();	if (delta > timeout) {	CamelLogger.log(LOG, readLockLoggingLevel, "Cannot acquire read lock within " + timeout + " millis. Will skip the file: " + file);	return false;	}	}	long newLastModified = target.lastModified();	long newLength = target.length();	long newOlderThan = startTime + watch.taken() - minAge;	if (newLength >= minLength && ((minAge == 0 && newLastModified == lastModified && newLength == length) || (minAge != 0 && newLastModified < newOlderThan))) {	
read lock acquired 

private boolean sleep() {	
exclusive read lock not granted sleeping for millis 

private boolean sleep() {	try {	Thread.sleep(checkInterval);	return false;	} catch (InterruptedException e) {	
sleep interrupted while waiting for exclusive read lock so breaking out 

========================= camel sample_4814 =========================

public void destroy() {	DefaultHttpRegistry.removeHttpRegistry(getServletName());	if (httpRegistry != null) {	httpRegistry.unregister(this);	httpRegistry = null;	}	
destroyed camelhttptransportservlet 

========================= camel sample_14446 =========================

public void initializeConnection() throws Exception {	
initialize gridfs endpoint 

protected void doStart() throws Exception {	if (writeConcern != null && writeConcernRef != null) {	String msg = "Cannot set both writeConcern and writeConcernRef at the same time. Respective values: " + writeConcern + ", " + writeConcernRef + ". Aborting initialization.";	throw new IllegalArgumentException(msg);	}	mongoConnection = CamelContextHelper.mandatoryLookup(getCamelContext(), connectionBean, MongoClient.class);	
resolved the connection with the name as 

protected void doStop() throws Exception {	super.doStop();	if (mongoConnection != null) {	
closing connection 

========================= camel sample_8837 =========================

public void process(Exchange exchange) throws Exception {	Message in = exchange.getIn();	
got event with body and action 

========================= camel sample_13229 =========================

public static Collection<HealthCheck.Result> invoke( CamelContext camelContext, Function<HealthCheck, Map<String, Object>> optionsSupplier, HealthCheckFilter filter) {	final HealthCheckRegistry registry = camelContext.getHealthCheckRegistry();	final HealthCheckService service = camelContext.hasService(HealthCheckService.class);	if (service != null) {	return service.getResults().stream() .filter(result -> !filter.test(result.getCheck())) .collect(Collectors.toList());	} else if (registry != null) {	return registry.stream() .collect(Collectors.groupingBy(HealthCheckHelper::getGroup)) .entrySet().stream() .map(Map.Entry::getValue) .flatMap(Collection::stream) .filter(check -> !filter.test(check)) .sorted(Comparator.comparingInt(HealthCheck::getOrder)) .map(check -> check.call(optionsSupplier.apply(check))) .collect(Collectors.toList());	} else {	
no health check source found 

public static Optional<HealthCheck.Result> query(CamelContext camelContext, String id, Map<String, Object> options) {	final HealthCheckRegistry registry = camelContext.getHealthCheckRegistry();	final HealthCheckService service = camelContext.hasService(HealthCheckService.class);	if (service != null) {	return service.getResults().stream() .filter(result -> ObjectHelper.equal(result.getCheck().getId(), id)) .findFirst();	} else if (registry != null) {	return registry.getCheck(id).map(check -> check.call(options));	} else {	
no health check source found 

public static Optional<HealthCheck.Result> invoke(CamelContext camelContext, String id, Map<String, Object> options) {	final HealthCheckRegistry registry = camelContext.getHealthCheckRegistry();	final HealthCheckService service = camelContext.hasService(HealthCheckService.class);	if (service != null) {	return service.call(id, options);	} else if (registry != null) {	return registry.getCheck(id).map(check -> check.call(options));	} else {	
no health check source found 

========================= camel sample_4402 =========================

UriParams uriParams = fieldType.getAnnotation(UriParams.class);	if (uriParams != null) {	String nestedPrefix = uriParams.prefix();	if (nestedPrefix == null) {	nestedPrefix = "";	}	nestedPrefix = (prefix + nestedPrefix).trim();	populateParameterConfigurationMap(parameterMap, fieldType, nestedPrefix);	} else {	if (parameterMap.containsKey(propertyName)) {	
duplicate property name defined on field 

========================= camel sample_4052 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<GoogleBigQueryComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.google-bigquery.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.google-bigquery.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1250 =========================

public void filter(Direction direction, List<Header> headers) {	if (headers == null) {	return;	}	Iterator<Header> iterator = headers.iterator();	while (iterator.hasNext()) {	Header header = iterator.next();	
processing header 

public void filter(Direction direction, List<Header> headers) {	if (headers == null) {	return;	}	Iterator<Header> iterator = headers.iterator();	while (iterator.hasNext()) {	Header header = iterator.next();	if (!(header instanceof SoapHeader)) {	
skipped header since it is not a soapheader 

Iterator<Header> iterator = headers.iterator();	while (iterator.hasNext()) {	Header header = iterator.next();	if (!(header instanceof SoapHeader)) {	continue;	}	SoapHeader soapHeader = SoapHeader.class.cast(header);	for (Iterator<SoapVersion> itv = SoapVersionFactory.getInstance().getVersions(); itv.hasNext();) {	SoapVersion version = itv.next();	if (soapHeader.getActor() != null && soapHeader.getActor().equals(version.getNextRole())) {	
filtered header 

========================= camel sample_6595 =========================

public List<CamelContext> getLocalCamelContexts() {	List<CamelContext> camelContexts = new ArrayList<CamelContext>();	try {	camelContexts.addAll(beanFactory.getBeansOfType(CamelContext.class).values());	} catch (Exception e) {	
cannot retrieve the list of camel contexts 

========================= camel sample_337 =========================

protected void debugBefore(Exchange exchange, Processor processor, ProcessorDefinition<?> definition, String id, String shortName) {	
before with body 

========================= camel sample_10540 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SchematronComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.schematron.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.schematron.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_458 =========================

public static File getClasspathResourceFileOrNull(String classpathResource) {	if (classpathResource == null) {	return null;	}	try {	Resource resource = new ClassPathResource(classpathResource);	File resourceFile = resource.getFile();	return resourceFile;	} catch (IOException ioe) {	
the resource does not exist 

========================= camel sample_12212 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	onException(IllegalArgumentException.class) .handled(true) .to("mock:handled");	
seda a mock dead a mock a forced a 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	onException(IllegalArgumentException.class) .handled(true) .to("mock:handled");	
seda b mock dead b mock b some io error 

========================= camel sample_3851 =========================

public Object evaluate(Exchange exchange) {	try {	
evaluation for exchange 

public List<?> evaluateAsList(Exchange exchange) throws Exception {	
evaluateaslist for exchange 

public Object evaluateAsStringSource(Exchange exchange) throws Exception {	
evaluateasstring for exchange 

public Object evaluateAsBytesSource(Exchange exchange) throws Exception {	
evaluateasbytessource for exchange 

public Node evaluateAsDOM(Exchange exchange) throws Exception {	
evaluateasdom for exchange 

public byte[] evaluateAsBytes(Exchange exchange) throws Exception {	
evaluateasbytes for exchange 

public String evaluateAsString(Exchange exchange) throws Exception {	
evaluateasstring for exchange 

public boolean matches(Exchange exchange) {	
matches for exchange 

protected synchronized void initialize(Exchange exchange) throws XPathException, IOException {	if (!initialized.get()) {	
initializing xquerybuilder 

protected synchronized void initialize(Exchange exchange) throws XPathException, IOException {	if (!initialized.get()) {	if (configuration == null) {	configuration = new Configuration();	configuration.setStripsWhiteSpace(isStripsAllWhiteSpace() ? Whitespace.ALL : Whitespace.IGNORABLE);	
created new configuration 

protected synchronized void initialize(Exchange exchange) throws XPathException, IOException {	if (!initialized.get()) {	if (configuration == null) {	configuration = new Configuration();	configuration.setStripsWhiteSpace(isStripsAllWhiteSpace() ? Whitespace.ALL : Whitespace.IGNORABLE);	} else {	
using existing configuration 

========================= camel sample_16744 =========================

public void testValidXML() throws Exception {	String payload = IOUtils.toString(ClassLoader.getSystemResourceAsStream("xml/article-1.xml"));	
validating payload 

public void testValidXML() throws Exception {	String payload = IOUtils.toString(ClassLoader.getSystemResourceAsStream("xml/article-1.xml"));	String result = getProcessor("sch/schematron-1.sch", null).validate(payload);	
schematron report 

public void testInvalidXMLWithClientResolver() throws Exception {	String payload = IOUtils.toString(ClassLoader.getSystemResourceAsStream("xml/article-3.xml"));	
validating payload 

public void testInvalidXMLWithClientResolver() throws Exception {	String payload = IOUtils.toString(ClassLoader.getSystemResourceAsStream("xml/article-3.xml"));	String result = getProcessor("sch/schematron-3.sch", new ClientUriResolver()).validate(payload);	
schematron report 

public void testInValidXML() throws Exception {	String payload = IOUtils.toString(ClassLoader.getSystemResourceAsStream("xml/article-2.xml"));	
validating payload 

public void testInValidXML() throws Exception {	String payload = IOUtils.toString(ClassLoader.getSystemResourceAsStream("xml/article-2.xml"));	String result = getProcessor("sch/schematron-2.sch", null).validate(payload);	
schematron report 

========================= camel sample_11982 =========================

public void testInOut() throws Exception {	getMockEndpoint("mock:log").expectedBodiesReceived("Logging: Bye World");	final String out = template.requestBody("direct:start", "Hello World", String.class);	assertEquals("Bye World", out);	
got reply 

========================= camel sample_10690 =========================

public void traceExchange(ProcessorDefinition<?> node, Processor target, TraceInterceptor traceInterceptor, Exchange exchange) throws Exception {	if (tracer.getDestination() != null || tracer.getDestinationUri() != null) {	Date timestamp = new Date();	Exchange event = new DefaultExchange(exchange);	event.setProperty(Exchange.TRACE_EVENT_NODE_ID, node.getId());	event.setProperty(Exchange.TRACE_EVENT_TIMESTAMP, timestamp);	event.setProperty(Exchange.TRACE_EVENT_EXCHANGE, exchange);	TraceEventMessage msg = new DefaultTraceEventMessage(timestamp, node, exchange);	if (tracer.isUseJpa()) {	if (LOG.isTraceEnabled()) {	
using class for tracing event messages 

IntrospectionSupport.setProperties(exchange.getContext().getTypeConverter(), jpa, options);	IntrospectionSupport.setProperty(exchange.getContext().getTypeConverter(), jpa, "timestamp", msg.getTimestamp());	event.getIn().setBody(jpa);	} else {	event.getIn().setBody(msg);	}	event.setProperty(Exchange.TRACE_EVENT, Boolean.TRUE);	try {	getTraceEventProducer(exchange).process(event);	} catch (Exception e) {	
error processing trace event original exchange will continue 

========================= camel sample_4551 =========================

private Bigquery buildClient(HttpTransport httpTransport) throws Exception {	GoogleCredential credential = null;	if (!Strings.isNullOrEmpty(serviceAccount) && !Strings.isNullOrEmpty(serviceAccountKey)) {	if (logger.isDebugEnabled()) {	
service account and key have been set explicitly initialising bigquery using service account 

private Bigquery buildClient(HttpTransport httpTransport) throws Exception {	GoogleCredential credential = null;	if (!Strings.isNullOrEmpty(serviceAccount) && !Strings.isNullOrEmpty(serviceAccountKey)) {	if (logger.isDebugEnabled()) {	}	credential = createFromAccountKeyPair(httpTransport);	}	if (credential == null && !Strings.isNullOrEmpty(credentialsFileLocation)) {	if (logger.isDebugEnabled()) {	
key file name has been set explicitly initialising bigquery using key file 

}	credential = createFromAccountKeyPair(httpTransport);	}	if (credential == null && !Strings.isNullOrEmpty(credentialsFileLocation)) {	if (logger.isDebugEnabled()) {	}	credential = createFromFile();	}	if (credential == null) {	if (logger.isDebugEnabled()) {	
no explicit service account or key file name have been provided initialising bigquery using defaults 

========================= camel sample_9363 =========================

public void register(HttpConsumer consumer) {	if (LOG.isDebugEnabled()) {	
registering consumer for path providers present 

public void unregister(HttpConsumer consumer) {	if (LOG.isDebugEnabled()) {	
unregistering consumer for path 

public void register(CamelServlet provider) {	if (LOG.isDebugEnabled()) {	
registering camelservlet with name consumers present 

public void unregister(CamelServlet provider) {	if (LOG.isDebugEnabled()) {	
unregistering camelservlet with name 

========================= camel sample_14450 =========================

public void testAsyncInvocation() throws Exception {	endpoint.expectedMessageCount(1);	myService.doSomethingAsync("Hello");	endpoint.assertIsSatisfied();	List<Exchange> list = endpoint.getReceivedExchanges();	for (Exchange exchange : list) {	
received 

========================= camel sample_15611 =========================

public void execute(Exchange exchange) throws SmppException {	SubmitSm[] submitSms = createSubmitSm(exchange);	List<String> messageIDs = new ArrayList<String>(submitSms.length);	for (int i = 0; i < submitSms.length; i++) {	SubmitSm submitSm = submitSms[i];	String messageID;	if (log.isDebugEnabled()) {	
sending short message for exchange id 

if (log.isDebugEnabled()) {	}	try {	messageID = session.submitShortMessage( submitSm.getServiceType(), TypeOfNumber.valueOf(submitSm.getSourceAddrTon()), NumberingPlanIndicator.valueOf(submitSm.getSourceAddrNpi()), submitSm.getSourceAddr(), TypeOfNumber.valueOf(submitSm.getDestAddrTon()), NumberingPlanIndicator.valueOf(submitSm.getDestAddrNpi()), submitSm.getDestAddress(), new ESMClass(submitSm.getEsmClass()), submitSm.getProtocolId(), submitSm.getPriorityFlag(), submitSm.getScheduleDeliveryTime(), submitSm.getValidityPeriod(), new RegisteredDelivery(submitSm.getRegisteredDelivery()), submitSm.getReplaceIfPresent(), DataCodings.newInstance(submitSm.getDataCoding()), (byte) 0, submitSm.getShortMessage(), submitSm.getOptionalParameters());	} catch (Exception e) {	throw new SmppException(e);	}	messageIDs.add(messageID);	}	if (log.isDebugEnabled()) {	
sent short message for exchange id and received message ids 

========================= camel sample_16894 =========================

protected void doStart() throws Exception {	super.doStart();	
binding to server address using acceptor 

protected void doStop() throws Exception {	
unbinding from server address using acceptor 

public void exceptionCaught(IoSession session, Throwable cause) throws Exception {	if (session != null) {	
closing session as an exception was thrown from mina 

public void messageReceived(IoSession session, Object object) throws Exception {	if (LOG.isDebugEnabled()) {	Object in = object;	if (in instanceof byte[]) {	in = getEndpoint().getCamelContext().getTypeConverter().convertTo(String.class, in);	}	
received body 

if (failed && !getEndpoint().getConfiguration().isTransferExchange()) {	if (exchange.getException() != null) {	body = exchange.getException();	} else {	body = exchange.getOut().getBody();	}	}	if (body == null) {	noReplyLogger.log("No payload to send as reply for exchange: " + exchange);	if (getEndpoint().getConfiguration().isDisconnectOnNoReply()) {	
closing session as no payload to send as reply at address 

} else {	body = exchange.getOut().getBody();	}	}	if (body == null) {	noReplyLogger.log("No payload to send as reply for exchange: " + exchange);	if (getEndpoint().getConfiguration().isDisconnectOnNoReply()) {	session.close();	}	} else {	
writing body 

if (ExchangeHelper.isOutCapable(exchange)) {	close = exchange.getOut().getHeader(MinaConstants.MINA_CLOSE_SESSION_WHEN_COMPLETE, Boolean.class);	} else {	close = exchange.getIn().getHeader(MinaConstants.MINA_CLOSE_SESSION_WHEN_COMPLETE, Boolean.class);	}	boolean disconnect = getEndpoint().getConfiguration().isDisconnect();	if (close != null) {	disconnect = close;	}	if (disconnect) {	
closing session when complete at address 

========================= camel sample_7687 =========================

protected Object assertReceivedValidExchange() throws Exception {	assertTrue(latch.await(5, TimeUnit.SECONDS));	assertNotNull(receivedExchange);	XmppMessage receivedMessage = (XmppMessage)receivedExchange.getIn();	assertEquals("cheese header", 123, receivedMessage.getHeader("cheese"));	Object body = receivedMessage.getBody();	
received body 

protected Object assertReceivedValidExchange() throws Exception {	assertTrue(latch.await(5, TimeUnit.SECONDS));	assertNotNull(receivedExchange);	XmppMessage receivedMessage = (XmppMessage)receivedExchange.getIn();	assertEquals("cheese header", 123, receivedMessage.getHeader("cheese"));	Object body = receivedMessage.getBody();	Message xmppMessage = receivedMessage.getXmppMessage();	assertNotNull(xmppMessage);	
received xmpp message 

protected void setUp() throws Exception {	client = new ProducerCache(this, container, 10);	String uriPrefix = getUriPrefix();	final String uri1 = uriPrefix + "&resource=camel-test-from&nickname=came-test-from";	final String uri2 = uriPrefix + "&resource=camel-test-to&nickname=came-test-to";	final String uri3 = uriPrefix + "&resource=camel-test-from-processor&nickname=came-test-from-processor";	
using uri and 

final String uri1 = uriPrefix + "&resource=camel-test-from&nickname=came-test-from";	final String uri2 = uriPrefix + "&resource=camel-test-to&nickname=came-test-to";	final String uri3 = uriPrefix + "&resource=camel-test-from-processor&nickname=came-test-from-processor";	endpoint = container.getEndpoint(uri1);	assertNotNull("No endpoint found!", endpoint);	container.addRoutes(new RouteBuilder() {	public void configure() {	from(uri1).to(uri2);	from(uri3).process(new Processor() {	public void process(Exchange e) {	
received exchange 

========================= camel sample_12584 =========================

public void configure() throws Exception {	
about to setup splunk saved search route splunk server log results 

========================= camel sample_17769 =========================

public void testMarshallMessage() {	String message = "8=FIX 4.19=2035=034=149=INVMGR56=BRKR1=BE.CHM.00122=411=CHM0001-0148=BE000124567854=158=this is a camel - bindy test10=220\r\n";	result.expectedBodiesReceived(message);	template.sendBody(generateModel());	try {	result.assertIsSatisfied();	} catch (InterruptedException e) {	
unit test error 

========================= camel sample_7392 =========================

public boolean matches() {	for (EventPredicate predicate : predicates) {	boolean answer = predicate.matches();	
matches 

public void reset() {	for (EventPredicate predicate : predicates) {	
reset 

public boolean onExchangeCreated(Exchange exchange) {	for (EventPredicate predicate : predicates) {	boolean answer = predicate.onExchangeCreated(exchange);	
onexchangecreated 

public boolean onExchangeCompleted(Exchange exchange) {	for (EventPredicate predicate : predicates) {	boolean answer = predicate.onExchangeCompleted(exchange);	
onexchangecompleted 

public boolean onExchangeFailed(Exchange exchange) {	for (EventPredicate predicate : predicates) {	boolean answer = predicate.onExchangeFailed(exchange);	
onexchangefailed 

public boolean onExchangeSent(Exchange exchange, Endpoint endpoint, long timeTaken) {	for (EventPredicate predicate : predicates) {	boolean answer = predicate.onExchangeSent(exchange, endpoint, timeTaken);	
onexchangesent 

========================= camel sample_5655 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<TwitterDirectMessageComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.twitter-directmessage.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.twitter-directmessage.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_771 =========================

private Message resolveMessageFrom(final Exchange camelExchange) {	Message message = camelExchange.hasOut() ? camelExchange.getOut() : camelExchange.getIn();	if (message.getHeaders() != null && message.getHeaders().containsKey(RabbitMQEndpoint.SERIALIZE_HEADER)) {	
removing the header 

properties = endpoint.getMessageConverter().buildProperties(camelExchange).build();	} catch (NoTypeConversionAvailableException | TypeConversionException e) {	if (message.getBody() instanceof Serializable) {	message.getHeaders().put(RabbitMQEndpoint.SERIALIZE_HEADER, true);	properties = endpoint.getMessageConverter().buildProperties(camelExchange).build();	body = serializeBodyFrom(message);	} else if (message.getBody() == null) {	properties = endpoint.getMessageConverter().buildProperties(camelExchange).build();	body = null;	} else {	
could not convert to byte 

private void waitForConfirmation() throws IOException {	try {	
waiting for publisher acknowledgements for ms 

private void waitForConfirmation() throws IOException {	try {	channel.waitForConfirmsOrDie(endpoint.getPublisherAcknowledgementsTimeout());	if (basicReturnReceived) {	throw new RuntimeCamelException("Failed to deliver message; basic.return received");	}	} catch (InterruptedException | TimeoutException e) {	
acknowledgement error for 

private byte[] serializeBodyFrom(final Message msg) throws IOException {	try (ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream o = new ObjectOutputStream(b)) {	o.writeObject(msg.getBody());	return b.toByteArray();	} catch (NotSerializableException nse) {	
can not send object via rabbitmq because it contains non serializable objects 

========================= camel sample_14145 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SjmsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.sjms.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.sjms.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1246 =========================

if (contains(o)) {	return false;	}	byte[] b = HBaseHelper.toBytes(o);	Put put = new Put(b);	put.addColumn(HBaseHelper.getHBaseFieldAsBytes(family), HBaseHelper.getHBaseFieldAsBytes(qualifier), b);	table.put(put);	return true;	}	} catch (Exception e) {	
error adding object to hbase repository 

public boolean contains(Object o) {	try {	byte[] b = HBaseHelper.toBytes(o);	Get get = new Get(b);	get.addColumn(HBaseHelper.getHBaseFieldAsBytes(family), HBaseHelper.getHBaseFieldAsBytes(qualifier));	return table.exists(get);	} catch (Exception e) {	
error reading object from hbase repository 

try {	byte[] b = HBaseHelper.toBytes(o);	if (table.exists(new Get(b))) {	Delete delete = new Delete(b);	table.delete(delete);	return true;	} else {	return false;	}	} catch (Exception e) {	
error removing object from hbase repository 

public void clear() {	Scan s = new Scan();	ResultScanner scanner;	try {	scanner = table.getScanner(s);	for (Result rr : scanner) {	Delete d = new Delete(rr.getRow());	table.delete(d);	}	} catch (Exception e) {	
error clear hbase repository 

========================= camel sample_14515 =========================

public void testPutAndGetNotFound() {	HawtDBAggregationRepository repo = new HawtDBAggregationRepository();	repo.setHawtDBFile(hawtDBFile);	repo.setRepositoryName("repo1");	Exchange exchange = new DefaultExchange(context);	exchange.getIn().setBody("Hello World");	
created 

HawtDBAggregationRepository repo = new HawtDBAggregationRepository();	repo.setHawtDBFile(hawtDBFile);	repo.setRepositoryName("repo1");	Exchange exchange = new DefaultExchange(context);	exchange.getIn().setBody("Hello World");	repo.add(context, exchange.getExchangeId(), exchange);	Exchange out = repo.get(context, exchange.getExchangeId());	assertNotNull("Should find exchange", out);	Exchange exchange2 = new DefaultExchange(context);	exchange2.getIn().setBody("Bye World");	
created 

========================= camel sample_11717 =========================

public void testSecureProxy() throws Exception {	send("http: StopWatch watch = new StopWatch();	
http log warn ms count watch taken 

========================= camel sample_6429 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SWFComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-swf.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-swf.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1138 =========================

public Exchange add(CamelContext camelContext, String key, Exchange oldExchange, Exchange newExchange) throws OptimisticLockingException {	if (!optimistic) {	throw new UnsupportedOperationException();	}	
adding an exchange with id for key in an optimistic manner 

final DefaultExchangeHolder misbehaviorHolder = cache.putIfAbsent(key, holder);	if (misbehaviorHolder != null) {	Exchange misbehaviorEx = unmarshallExchange(camelContext, misbehaviorHolder);	LOG.error("Optimistic locking failed for exchange with key {}: IMap#putIfAbsend returned Exchange with ID {}, while it's expected no exchanges to be returned", key, misbehaviorEx != null ? misbehaviorEx.getExchangeId() : "<null>");	throw  new OptimisticLockingException();	}	} else {	DefaultExchangeHolder oldHolder = DefaultExchangeHolder.marshal(oldExchange, true, allowSerializedHeaders);	DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(newExchange, true, allowSerializedHeaders);	if (!cache.replace(key, oldHolder, newHolder)) {	
optimistic locking failed for exchange with key imap replace returned no exchanges while it s expected to replace one 

LOG.error("Optimistic locking failed for exchange with key {}: IMap#putIfAbsend returned Exchange with ID {}, while it's expected no exchanges to be returned", key, misbehaviorEx != null ? misbehaviorEx.getExchangeId() : "<null>");	throw  new OptimisticLockingException();	}	} else {	DefaultExchangeHolder oldHolder = DefaultExchangeHolder.marshal(oldExchange, true, allowSerializedHeaders);	DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(newExchange, true, allowSerializedHeaders);	if (!cache.replace(key, oldHolder, newHolder)) {	throw new OptimisticLockingException();	}	}	
added an exchange with id for key in optimistic manner 

public Exchange add(CamelContext camelContext, String key, Exchange exchange) {	if (optimistic) {	throw new UnsupportedOperationException();	}	
adding an exchange with id for key in a thread safe manner 

if (optimistic) {	throw new UnsupportedOperationException();	}	Lock l = hzInstance.getLock(mapName);	try {	l.lock();	DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);	DefaultExchangeHolder oldHolder = cache.put(key, newHolder);	return unmarshallExchange(camelContext, oldHolder);	} finally {	
added an exchange with id for key in a thread safe manner 

public Set<String> scan(CamelContext camelContext) {	if (useRecovery) {	
scanning for exchanges to recover in context 

public Set<String> scan(CamelContext camelContext) {	if (useRecovery) {	Set<String> scanned = Collections.unmodifiableSet(persistedCache.keySet());	
found keys for exchanges to recover in context 

public Set<String> scan(CamelContext camelContext) {	if (useRecovery) {	Set<String> scanned = Collections.unmodifiableSet(persistedCache.keySet());	return scanned;	} else {	
what for to run recovery scans in context while repository is running in non recoverable aggregation repository mode 

public Exchange recover(CamelContext camelContext, String exchangeId) {	
recovering an exchange with id 

public void remove(CamelContext camelContext, String key, Exchange exchange) {	DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);	if (optimistic) {	
removing an exchange with id for key in an optimistic manner 

public void remove(CamelContext camelContext, String key, Exchange exchange) {	DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);	if (optimistic) {	if (!cache.remove(key, holder)) {	
optimistic locking failed for exchange with key imap remove removed no exchanges while it s expected to remove one 

public void remove(CamelContext camelContext, String key, Exchange exchange) {	DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);	if (optimistic) {	if (!cache.remove(key, holder)) {	throw new OptimisticLockingException();	}	
removed an exchange with id for key in an optimistic manner 

public void remove(CamelContext camelContext, String key, Exchange exchange) {	DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);	if (optimistic) {	if (!cache.remove(key, holder)) {	throw new OptimisticLockingException();	}	if (useRecovery) {	
putting an exchange with id for key into a recoverable storage in an optimistic manner 

public void remove(CamelContext camelContext, String key, Exchange exchange) {	DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);	if (optimistic) {	if (!cache.remove(key, holder)) {	throw new OptimisticLockingException();	}	if (useRecovery) {	persistedCache.put(exchange.getExchangeId(), holder);	
put an exchange with id for key into a recoverable storage in an optimistic manner 

DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);	if (optimistic) {	if (!cache.remove(key, holder)) {	throw new OptimisticLockingException();	}	if (useRecovery) {	persistedCache.put(exchange.getExchangeId(), holder);	}	} else {	if (useRecovery) {	
removing an exchange with id for key in a thread safe manner 

} else {	if (useRecovery) {	TransactionOptions tOpts = new TransactionOptions();	tOpts.setTransactionType(TransactionOptions.TransactionType.ONE_PHASE);	TransactionContext tCtx = hzInstance.newTransactionContext(tOpts);	try {	tCtx.beginTransaction();	TransactionalMap<String, DefaultExchangeHolder> tCache = tCtx.getMap(cache.getName());	TransactionalMap<String, DefaultExchangeHolder> tPersistentCache = tCtx.getMap(persistedCache.getName());	DefaultExchangeHolder removedHolder = tCache.remove(key);	
putting an exchange with id for key into a recoverable storage in a thread safe manner 

TransactionOptions tOpts = new TransactionOptions();	tOpts.setTransactionType(TransactionOptions.TransactionType.ONE_PHASE);	TransactionContext tCtx = hzInstance.newTransactionContext(tOpts);	try {	tCtx.beginTransaction();	TransactionalMap<String, DefaultExchangeHolder> tCache = tCtx.getMap(cache.getName());	TransactionalMap<String, DefaultExchangeHolder> tPersistentCache = tCtx.getMap(persistedCache.getName());	DefaultExchangeHolder removedHolder = tCache.remove(key);	tPersistentCache.put(exchange.getExchangeId(), removedHolder);	tCtx.commitTransaction();	
removed an exchange with id for key in a thread safe manner 

TransactionOptions tOpts = new TransactionOptions();	tOpts.setTransactionType(TransactionOptions.TransactionType.ONE_PHASE);	TransactionContext tCtx = hzInstance.newTransactionContext(tOpts);	try {	tCtx.beginTransaction();	TransactionalMap<String, DefaultExchangeHolder> tCache = tCtx.getMap(cache.getName());	TransactionalMap<String, DefaultExchangeHolder> tPersistentCache = tCtx.getMap(persistedCache.getName());	DefaultExchangeHolder removedHolder = tCache.remove(key);	tPersistentCache.put(exchange.getExchangeId(), removedHolder);	tCtx.commitTransaction();	
put an exchange with id for key into a recoverable storage in a thread safe manner 

public void confirm(CamelContext camelContext, String exchangeId) {	
confirming an exchange with id 

========================= camel sample_9508 =========================

if (secureRandom != null) {	secureRandom.setCamelContext(camelContext);	}	if (clientParameters != null) {	clientParameters.setCamelContext(camelContext);	}	if (serverParameters != null) {	serverParameters.setCamelContext(camelContext);	}	}	
creating sslcontext from sslcontextparameters 

if (secureRandom != null) {	secureRandom.setCamelContext(camelContext);	}	if (clientParameters != null) {	clientParameters.setCamelContext(camelContext);	}	if (serverParameters != null) {	serverParameters.setCamelContext(camelContext);	}	}	
available providers 

for (int idx = 0; idx < keyManagers.length; idx++) {	if (keyManagers[idx] instanceof X509KeyManager) {	try {	keyManagers[idx] = new AliasedX509ExtendedKeyManager(this.getCertAlias(), (X509KeyManager)keyManagers[idx]);	} catch (Exception e) {	throw new GeneralSecurityException(e);	}	}	}	}	
sslcontext initialized from is using provider protocol key managers trust managers and secure random 

protected void configureSSLContext(SSLContext context) throws GeneralSecurityException {	
configuring client and server side sslcontext parameters on sslcontext 

protected void configureSSLContext(SSLContext context) throws GeneralSecurityException {	super.configureSSLContext(context);	if (this.getClientParameters() != null) {	
overriding client side sslcontext parameters on sslcontext with configured client parameters 

protected void configureSSLContext(SSLContext context) throws GeneralSecurityException {	super.configureSSLContext(context);	if (this.getClientParameters() != null) {	this.getClientParameters().configureSSLContext(context);	}	if (this.getServerParameters() != null) {	
overriding server side sslcontext parameters on sslcontext with configured server parameters 

protected void configureSSLContext(SSLContext context) throws GeneralSecurityException {	super.configureSSLContext(context);	if (this.getClientParameters() != null) {	this.getClientParameters().configureSSLContext(context);	}	if (this.getServerParameters() != null) {	this.getServerParameters().configureSSLContext(context);	}	
configured client and server side sslcontext parameters on sslcontext 

protected List<Configurer<SSLEngine>> getSSLEngineConfigurers(SSLContext context) {	
collecting client and server side sslengine configurers on sslcontext 

protected List<Configurer<SSLEngine>> getSSLEngineConfigurers(SSLContext context) {	List<Configurer<SSLEngine>> configurers = super.getSSLEngineConfigurers(context);	if (this.getClientParameters() != null) {	
augmenting sslengine configurers with configurers from client parameters on sslcontext 

protected List<Configurer<SSLEngine>> getSSLEngineConfigurers(SSLContext context) {	List<Configurer<SSLEngine>> configurers = super.getSSLEngineConfigurers(context);	if (this.getClientParameters() != null) {	configurers.addAll(this.getClientParameters().getSSLEngineConfigurers(context));	}	if (this.getServerParameters() != null) {	
augmenting sslengine configurers with configurers from server parameters on sslcontext 

protected List<Configurer<SSLEngine>> getSSLEngineConfigurers(SSLContext context) {	List<Configurer<SSLEngine>> configurers = super.getSSLEngineConfigurers(context);	if (this.getClientParameters() != null) {	configurers.addAll(this.getClientParameters().getSSLEngineConfigurers(context));	}	if (this.getServerParameters() != null) {	configurers.addAll(this.getServerParameters().getSSLEngineConfigurers(context));	}	
collected client and server side sslengine configurers on sslcontext 

protected List<Configurer<SSLSocketFactory>> getSSLSocketFactoryConfigurers(SSLContext context) {	
collecting sslsocketfactory configurers on sslcontext 

protected List<Configurer<SSLSocketFactory>> getSSLSocketFactoryConfigurers(SSLContext context) {	List<Configurer<SSLSocketFactory>> configurers = super.getSSLSocketFactoryConfigurers(context);	if (this.getClientParameters() != null) {	
augmenting sslsocketfactory configurers with configurers from client parameters on sslcontext 

protected List<Configurer<SSLSocketFactory>> getSSLSocketFactoryConfigurers(SSLContext context) {	List<Configurer<SSLSocketFactory>> configurers = super.getSSLSocketFactoryConfigurers(context);	if (this.getClientParameters() != null) {	configurers.addAll(this.getClientParameters().getSSLSocketFactoryConfigurers(context));	}	
collected sslsocketfactory configurers on sslcontext 

protected List<Configurer<SSLServerSocketFactory>> getSSLServerSocketFactoryConfigurers(SSLContext context) {	
collecting sslserversocketfactory configurers for sslcontext 

protected List<Configurer<SSLServerSocketFactory>> getSSLServerSocketFactoryConfigurers(SSLContext context) {	List<Configurer<SSLServerSocketFactory>> configurers = super.getSSLServerSocketFactoryConfigurers(context);	if (this.getServerParameters() != null) {	
augmenting sslserversocketfactory configurers with configurers from server parameters for sslcontext 

protected List<Configurer<SSLServerSocketFactory>> getSSLServerSocketFactoryConfigurers(SSLContext context) {	List<Configurer<SSLServerSocketFactory>> configurers = super.getSSLServerSocketFactoryConfigurers(context);	if (this.getServerParameters() != null) {	configurers.addAll(this.getServerParameters().getSSLServerSocketFactoryConfigurers(context));	}	
collected client and server side sslserversocketfactory configurers for sslcontext 

========================= camel sample_4290 =========================

if (IntrospectionSupport.getProperties(bootstrapConfiguration, options, null, false)) {	IntrospectionSupport.setProperties(getCamelContext().getTypeConverter(), config, options);	}	}	NettyHttpSecurityConfiguration securityConfiguration = resolveAndRemoveReferenceParameter(parameters, "securityConfiguration", NettyHttpSecurityConfiguration.class);	Map<String, Object> securityOptions = IntrospectionSupport.extractProperties(parameters, "securityConfiguration.");	NettyHttpBinding bindingFromUri = resolveAndRemoveReferenceParameter(parameters, "nettyHttpBinding", NettyHttpBinding.class);	int sharedPort = -1;	NettySharedHttpServer shared = resolveAndRemoveReferenceParameter(parameters, "nettySharedHttpServer", NettySharedHttpServer.class);	if (shared != null) {	
using nettysharedhttpserver with port 

if (shared != null) {	sharedPort = shared.getPort();	}	boolean hasProtocol = remaining.startsWith("http: || remaining.startsWith("https: if (!hasProtocol) {	remaining = "http: }	boolean hasSlash = remaining.startsWith("http: if (!hasSlash) {	if (remaining.startsWith("http:")) {	remaining = "http: } else {	remaining = "https: }	}	
netty http url 

========================= camel sample_16656 =========================

private static SessionFactory loadSessionFactoryFromClassPath() {	try {	Class<?> factoryClass = null;	factoryClass = Class.forName("org.apache.chemistry.opencmis.client.runtime.SessionFactoryImpl");	if (factoryClass != null) {	Method method = factoryClass.getMethod("newInstance", new Class<?>[0]);	return (SessionFactory)method.invoke(null, new Object[0]);	}	} catch (Exception ex) {	
cannot create the sessionfactoryimpl due to 

========================= camel sample_9158 =========================

public Processor wrapProcessorInInterceptors(final CamelContext context, final ProcessorDefinition<?> definition, final Processor target, final Processor nextTarget) throws Exception {	return new DelegateAsyncProcessor(new Processor() {	public void process(Exchange exchange) throws Exception {	count++;	
i am the container wide interceptor intercepted total count 

========================= camel sample_3806 =========================

public void execute() {	DeleteAttributesRequest request = new DeleteAttributesRequest() .withDomainName(determineDomainName()) .withItemName(determineItemName()) .withExpected(determineUpdateCondition()) .withAttributes(determineAttributes());	
sending request for exchange 

public void execute() {	DeleteAttributesRequest request = new DeleteAttributesRequest() .withDomainName(determineDomainName()) .withItemName(determineItemName()) .withExpected(determineUpdateCondition()) .withAttributes(determineAttributes());	this.sdbClient.deleteAttributes(request);	
request sent 

========================= camel sample_8749 =========================

public static void main(String[] args) throws Exception {	
about to run google pubsub camel integration 

public static void main(String[] args) throws Exception {	CamelContext camelContext = new DefaultCamelContext();	GooglePubsubComponent googlePubsub = PubsubUtil.createComponent();	camelContext.addComponent("google-pubsub", googlePubsub);	camelContext.addRoutes(new RouteBuilder() {	public void configure() {	PropertiesComponent pc = getContext().getComponent("properties", PropertiesComponent.class);	pc.setLocation("classpath:example.properties");	
about to start route google pubsub log 

========================= camel sample_17552 =========================

parametersBuilder.addLong(headerKey, (Long) headerValue);	} else if (headerValue instanceof Double) {	parametersBuilder.addDouble(headerKey, (Double) headerValue);	} else if (headerValue != null) {	parametersBuilder.addString(headerKey, headerValue.toString());	} else {	parametersBuilder.addString(headerKey, null);	}	}	JobParameters jobParameters = parametersBuilder.toJobParameters();	
prepared parameters for spring batch job 

========================= camel sample_12750 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<InfinispanComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.infinispan.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.infinispan.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_819 =========================

public String greetMe(String me) {	
executing operation greetme 

public void greetMeOneWay(String me) {	
executing operation greetmeoneway 

public String sayHi() {	
executing operation sayhi 

========================= camel sample_17801 =========================

public List<AtmosphereRequest> onTextStream(WebSocket webSocket, Reader data) {	
processing reader message 

public List<AtmosphereRequest> onTextStream(WebSocket webSocket, Reader data) {	String connectionKey = store.getConnectionKey(webSocket);	consumer.sendMessage(connectionKey, data);	
reader message sent 

public List<AtmosphereRequest> onBinaryStream(WebSocket webSocket, InputStream data) {	
processing inputstream message 

public List<AtmosphereRequest> onBinaryStream(WebSocket webSocket, InputStream data) {	String connectionKey = store.getConnectionKey(webSocket);	consumer.sendMessage(connectionKey, data);	
reader message sent 

========================= camel sample_10014 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<DigitalSignatureComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.crypto.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.crypto.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_663 =========================

}	SplitStrategy idleStrategy = null;	for (SplitStrategy strategy : config.getSplitStrategies()) {	if (strategy.type == SplitStrategyType.IDLE) {	idleStrategy = strategy;	break;	}	}	if (idleStrategy != null) {	scheduler = getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "HdfsIdleCheck");	
creating idlecheck task scheduled to run every millis 

private synchronized HdfsOutputStream setupHdfs(boolean onStartup) throws Exception {	if (ostream != null) {	return ostream;	}	StringBuilder actualPath = new StringBuilder(hdfsPath);	if (config.getSplitStrategies().size() > 0) {	actualPath = newFileName();	}	if (onStartup) {	
connecting to hdfs file system may take a while if connection is not available 

if (ostream != null) {	return ostream;	}	StringBuilder actualPath = new StringBuilder(hdfsPath);	if (config.getSplitStrategies().size() > 0) {	actualPath = newFileName();	}	if (onStartup) {	} else {	if (log.isDebugEnabled()) {	
connecting to hdfs file system may take a while if connection is not available 

if (config.getSplitStrategies().size() > 0) {	actualPath = newFileName();	}	if (onStartup) {	} else {	if (log.isDebugEnabled()) {	}	}	HdfsOutputStream answer = HdfsOutputStream.createOutputStream(actualPath.toString(), config);	if (onStartup) {	
connected to hdfs file system 

}	if (onStartup) {	} else {	if (log.isDebugEnabled()) {	}	}	HdfsOutputStream answer = HdfsOutputStream.createOutputStream(actualPath.toString(), config);	if (onStartup) {	} else {	if (log.isDebugEnabled()) {	
connected to hdfs file system 

public void run() {	if (ostream == null) {	return;	}	
idlecheck running 

public void run() {	if (ostream == null) {	return;	}	if (System.currentTimeMillis() - ostream.getLastAccess() > strategy.value && !idle.get() && !ostream.isBusy().get()) {	idle.set(true);	try {	
closing stream as idle 

========================= camel sample_12183 =========================

public Object evaluate(Exchange exchange) {	try {	Object result = evaluateJsonPath(exchange, engine);	if (resultType != null) {	boolean resultIsCollection = Collection.class.isAssignableFrom(resultType);	boolean singleElement = result instanceof List && ((List) result).size() == 1;	if (singleElement && !resultIsCollection) {	result = ((List) result).get(0);	
unwrapping result from single element list before converting to 

public void init() {	String exp = expression;	if (predicate && isAllowEasyPredicate()) {	EasyPredicateParser parser = new EasyPredicateParser();	exp = parser.parse(expression);	if (!exp.equals(expression)) {	
easypredicateparser parsed 

public void init() {	String exp = expression;	if (predicate && isAllowEasyPredicate()) {	EasyPredicateParser parser = new EasyPredicateParser();	exp = parser.parse(expression);	if (!exp.equals(expression)) {	}	}	
initializing using predicate expression 

========================= camel sample_16969 =========================

}	}	}	index++;	}	} else {	BeanInvocation invocation = new BeanInvocation(method, args);	exchange.getIn().setBody(invocation);	}	if (binding) {	
binding to service interface as body header exchangeproperty detected when calling proxy method 

}	}	index++;	}	} else {	BeanInvocation invocation = new BeanInvocation(method, args);	exchange.getIn().setBody(invocation);	}	if (binding) {	} else {	
no binding to service interface as body header exchangeproperty not detected using beaninvocation as message body when calling proxy method 

protected Object doInvoke(final Method method, final Exchange exchange) throws Throwable {	final boolean isFuture = method.getReturnType() == Future.class;	FutureTask<Object> task = new FutureTask<Object>(new Callable<Object>() {	public Object call() throws Exception {	
proxied method call invoking producer 

protected Object doInvoke(final Method method, final Exchange exchange) throws Throwable {	final boolean isFuture = method.getReturnType() == Future.class;	FutureTask<Object> task = new FutureTask<Object>(new Callable<Object>() {	public Object call() throws Exception {	producer.process(exchange);	Object answer = afterInvoke(method, exchange, exchange.getPattern(), isFuture);	
proxied method call returning 

final boolean isFuture = method.getReturnType() == Future.class;	FutureTask<Object> task = new FutureTask<Object>(new Callable<Object>() {	public Object call() throws Exception {	producer.process(exchange);	Object answer = afterInvoke(method, exchange, exchange.getPattern(), isFuture);	return answer;	}	});	if (isFuture) {	if (LOG.isTraceEnabled()) {	
submitting task for exchange id 

========================= camel sample_4855 =========================

public void testAll() throws Exception {	final List<Discount> result = requestBody("direct: assertNotNull("all result", result);	
all 

========================= camel sample_17381 =========================

public void testPollEnrichDefaultAggregationStrategyBody() throws Exception {	getMockEndpoint("mock:start").expectedBodiesReceived("Start");	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceived("Big file");	mock.expectedFileExists("target/enrich/.done/AAA.fin");	mock.expectedFileExists("target/enrichdata/.done/AAA.dat");	
file log info file 

public void testPollEnrichDefaultAggregationStrategyBody() throws Exception {	getMockEndpoint("mock:start").expectedBodiesReceived("Start");	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceived("Big file");	mock.expectedFileExists("target/enrich/.done/AAA.fin");	mock.expectedFileExists("target/enrichdata/.done/AAA.dat");	Thread.sleep(250);	
file log info done 

========================= camel sample_1704 =========================

public void messageReceived(IoSession session, Object message) throws Exception {	
udpserver received body 

public void exceptionCaught(IoSession session, Throwable cause) throws Exception {	
ooops something went wrong 

public void messageReceived(IoSession session, Object message) throws Exception {	
client received body 

public void exceptionCaught(IoSession session, Throwable cause) throws Exception {	
ooops something went wrong 

========================= camel sample_11605 =========================

protected <T> T unmarshall(Class<T> type, Exchange exchange, Object value) throws Exception {	
unmarshal to with value 

}	Unmarshaller unmarshaller = getUnmarshaller(type);	if (parentTypeConverter != null) {	if (!needFiltering(exchange)) {	XMLStreamReader xmlReader = parentTypeConverter.convertTo(XMLStreamReader.class, exchange, value);	if (xmlReader != null) {	try {	Object unmarshalled = unmarshal(unmarshaller, exchange, xmlReader);	return castJaxbType(unmarshalled, type);	} catch (Exception ex) {	
cannot use staxstreamreader to unmarshal the message due to 

protected <T> T marshall(Class<T> type, Exchange exchange, Object value, Method objectFactoryMethod) throws JAXBException, XMLStreamException, FactoryConfigurationError, TypeConversionException {	
marshal from value to type 

marshaller.setProperty(Marshaller.JAXB_ENCODING, exchange.getProperty(Exchange.CHARSET_NAME, String.class));	}	Object toMarshall = value;	if (objectFactoryMethod != null) {	try {	Object instance = objectFactoryMethod.getDeclaringClass().newInstance();	if (instance != null) {	toMarshall = objectFactoryMethod.invoke(instance, value);	}	} catch (Exception e) {	
unable to create jaxbelement object for type due to 

========================= camel sample_13792 =========================

public Processor wrapProcessorInInterceptors(final CamelContext context, final ProcessorDefinition<?> definition, Processor target, Processor nextTarget) throws Exception {	definition.idOrCreate(context.getNodeIdFactory());	return new DelegateProcessor(target) {	protected void processNext(Exchange exchange) throws Exception {	
debugging at with id with exchange 

========================= camel sample_1354 =========================

public void testLoadTestHawtDBAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.setResultWaitTime(50 * 1000);	
staring to send messages 

public void testLoadTestHawtDBAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.setResultWaitTime(50 * 1000);	for (int i = 0; i < SIZE; i++) {	final int value = 1;	char id = 'A';	
sending with id 

public void testLoadTestHawtDBAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.setResultWaitTime(50 * 1000);	for (int i = 0; i < SIZE; i++) {	final int value = 1;	char id = 'A';	template.sendBodyAndHeader("seda:start?size=" + SIZE, value, "id", "" + id);	}	
sending all message done now waiting for aggregation to complete 

========================= camel sample_11740 =========================

public void testRead() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	final ServiceDocument document = requestBodyAndHeaders("direct: assertNotNull(document);	assertFalse("ServiceDocument entity sets", document.getEntitySetsInfo().isEmpty());	
service document has entity sets 

public void testRead() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	final ServiceDocument document = requestBodyAndHeaders("direct: assertNotNull(document);	assertFalse("ServiceDocument entity sets", document.getEntitySetsInfo().isEmpty());	final HashMap<String, String> queryParams = new HashMap<String, String>();	queryParams.put(SystemQueryOption.$top.name(), "5");	headers.put("CamelOlingo2.queryParams", queryParams);	final ODataFeed manufacturers = requestBodyAndHeaders("direct: assertNotNull(manufacturers);	final List<ODataEntry> manufacturersEntries = manufacturers.getEntries();	assertFalse("Manufacturers empty entries", manufacturersEntries.isEmpty());	
manufacturers feed has entries 

queryParams.put(SystemQueryOption.$top.name(), "5");	headers.put("CamelOlingo2.queryParams", queryParams);	final ODataFeed manufacturers = requestBodyAndHeaders("direct: assertNotNull(manufacturers);	final List<ODataEntry> manufacturersEntries = manufacturers.getEntries();	assertFalse("Manufacturers empty entries", manufacturersEntries.isEmpty());	headers.clear();	headers.put(Olingo2Constants.PROPERTY_PREFIX + "keyPredicate", "'1'");	final ODataEntry manufacturer = requestBodyAndHeaders("direct: assertNotNull(manufacturer);	final Map<String, Object> properties = manufacturer.getProperties();	assertEquals("Manufacturer Id", "1", properties.get(ID_PROPERTY));	
manufacturer 

public void testCreateUpdateDelete() throws Exception {	final Map<String, Object> data = getEntityData();	Map<String, Object> address;	final ODataEntry manufacturer = requestBody("direct: assertNotNull("Created Manufacturer", manufacturer);	final Map<String, Object> properties = manufacturer.getProperties();	assertEquals("Created Manufacturer Id", "123", properties.get(ID_PROPERTY));	
created manufacturer 

final Map<String, Object> data = getEntityData();	Map<String, Object> address;	final ODataEntry manufacturer = requestBody("direct: assertNotNull("Created Manufacturer", manufacturer);	final Map<String, Object> properties = manufacturer.getProperties();	assertEquals("Created Manufacturer Id", "123", properties.get(ID_PROPERTY));	data.put("Name", "MyCarManufacturer Renamed");	address = (Map<String, Object>)data.get("Address");	address.put("Street", "Main Street");	HttpStatusCodes status = requestBody("direct: assertNotNull("Update status", status);	assertEquals("Update status", HttpStatusCodes.NO_CONTENT.getStatusCode(), status.getStatusCode());	
update status 

final ODataEntry manufacturer = requestBody("direct: assertNotNull("Created Manufacturer", manufacturer);	final Map<String, Object> properties = manufacturer.getProperties();	assertEquals("Created Manufacturer Id", "123", properties.get(ID_PROPERTY));	data.put("Name", "MyCarManufacturer Renamed");	address = (Map<String, Object>)data.get("Address");	address.put("Street", "Main Street");	HttpStatusCodes status = requestBody("direct: assertNotNull("Update status", status);	assertEquals("Update status", HttpStatusCodes.NO_CONTENT.getStatusCode(), status.getStatusCode());	status = requestBody("direct: assertNotNull("Delete status", status);	assertEquals("Delete status", HttpStatusCodes.NO_CONTENT.getStatusCode(), status.getStatusCode());	
delete status 

address.put("Street", "Main Street");	batchParts.add( Olingo2BatchChangeRequest.resourcePath(TEST_RESOURCE_ADDRESS).operation(Operation.UPDATE).body(address).build());	updateData.put("Name", "MyCarManufacturer Renamed");	batchParts.add(Olingo2BatchChangeRequest.resourcePath(TEST_RESOURCE).operation(Operation.UPDATE) .body(updateData).build());	batchParts.add(Olingo2BatchChangeRequest.resourcePath(TEST_RESOURCE).operation(Operation.DELETE).build());	batchParts.add(Olingo2BatchQueryRequest.resourcePath(TEST_CREATE_MANUFACTURER).build());	final List<Olingo2BatchResponse> responseParts = requestBody("direct: assertNotNull("Batch response", responseParts);	assertEquals("Batch responses expected", 9, responseParts.size());	final Edm edm = (Edm) responseParts.get(0).getBody();	assertNotNull(edm);	
edm entity sets 

updateData.put("Name", "MyCarManufacturer Renamed");	batchParts.add(Olingo2BatchChangeRequest.resourcePath(TEST_RESOURCE).operation(Operation.UPDATE) .body(updateData).build());	batchParts.add(Olingo2BatchChangeRequest.resourcePath(TEST_RESOURCE).operation(Operation.DELETE).build());	batchParts.add(Olingo2BatchQueryRequest.resourcePath(TEST_CREATE_MANUFACTURER).build());	final List<Olingo2BatchResponse> responseParts = requestBody("direct: assertNotNull("Batch response", responseParts);	assertEquals("Batch responses expected", 9, responseParts.size());	final Edm edm = (Edm) responseParts.get(0).getBody();	assertNotNull(edm);	final ODataFeed feed = (ODataFeed) responseParts.get(1).getBody();	assertNotNull(feed);	
read feed 

batchParts.add(Olingo2BatchChangeRequest.resourcePath(TEST_RESOURCE).operation(Operation.DELETE).build());	batchParts.add(Olingo2BatchQueryRequest.resourcePath(TEST_CREATE_MANUFACTURER).build());	final List<Olingo2BatchResponse> responseParts = requestBody("direct: assertNotNull("Batch response", responseParts);	assertEquals("Batch responses expected", 9, responseParts.size());	final Edm edm = (Edm) responseParts.get(0).getBody();	assertNotNull(edm);	final ODataFeed feed = (ODataFeed) responseParts.get(1).getBody();	assertNotNull(feed);	ODataEntry dataEntry = (ODataEntry) responseParts.get(2).getBody();	assertNotNull(dataEntry);	
read entry 

final List<Olingo2BatchResponse> responseParts = requestBody("direct: assertNotNull("Batch response", responseParts);	assertEquals("Batch responses expected", 9, responseParts.size());	final Edm edm = (Edm) responseParts.get(0).getBody();	assertNotNull(edm);	final ODataFeed feed = (ODataFeed) responseParts.get(1).getBody();	assertNotNull(feed);	ODataEntry dataEntry = (ODataEntry) responseParts.get(2).getBody();	assertNotNull(dataEntry);	dataEntry = (ODataEntry) responseParts.get(3).getBody();	assertNotNull(dataEntry);	
read entry with expand 

final Edm edm = (Edm) responseParts.get(0).getBody();	assertNotNull(edm);	final ODataFeed feed = (ODataFeed) responseParts.get(1).getBody();	assertNotNull(feed);	ODataEntry dataEntry = (ODataEntry) responseParts.get(2).getBody();	assertNotNull(dataEntry);	dataEntry = (ODataEntry) responseParts.get(3).getBody();	assertNotNull(dataEntry);	dataEntry = (ODataEntry) responseParts.get(4).getBody();	assertNotNull(dataEntry);	
created entry 

final ODataFeed feed = (ODataFeed) responseParts.get(1).getBody();	assertNotNull(feed);	ODataEntry dataEntry = (ODataEntry) responseParts.get(2).getBody();	assertNotNull(dataEntry);	dataEntry = (ODataEntry) responseParts.get(3).getBody();	assertNotNull(dataEntry);	dataEntry = (ODataEntry) responseParts.get(4).getBody();	assertNotNull(dataEntry);	int statusCode = responseParts.get(5).getStatusCode();	assertEquals(HttpStatusCodes.NO_CONTENT.getStatusCode(), statusCode);	
update address status 

ODataEntry dataEntry = (ODataEntry) responseParts.get(2).getBody();	assertNotNull(dataEntry);	dataEntry = (ODataEntry) responseParts.get(3).getBody();	assertNotNull(dataEntry);	dataEntry = (ODataEntry) responseParts.get(4).getBody();	assertNotNull(dataEntry);	int statusCode = responseParts.get(5).getStatusCode();	assertEquals(HttpStatusCodes.NO_CONTENT.getStatusCode(), statusCode);	statusCode = responseParts.get(6).getStatusCode();	assertEquals(HttpStatusCodes.NO_CONTENT.getStatusCode(), statusCode);	
update entry status 

dataEntry = (ODataEntry) responseParts.get(3).getBody();	assertNotNull(dataEntry);	dataEntry = (ODataEntry) responseParts.get(4).getBody();	assertNotNull(dataEntry);	int statusCode = responseParts.get(5).getStatusCode();	assertEquals(HttpStatusCodes.NO_CONTENT.getStatusCode(), statusCode);	statusCode = responseParts.get(6).getStatusCode();	assertEquals(HttpStatusCodes.NO_CONTENT.getStatusCode(), statusCode);	statusCode = responseParts.get(7).getStatusCode();	assertEquals(HttpStatusCodes.NO_CONTENT.getStatusCode(), statusCode);	
delete status 

assertNotNull(dataEntry);	int statusCode = responseParts.get(5).getStatusCode();	assertEquals(HttpStatusCodes.NO_CONTENT.getStatusCode(), statusCode);	statusCode = responseParts.get(6).getStatusCode();	assertEquals(HttpStatusCodes.NO_CONTENT.getStatusCode(), statusCode);	statusCode = responseParts.get(7).getStatusCode();	assertEquals(HttpStatusCodes.NO_CONTENT.getStatusCode(), statusCode);	assertEquals(HttpStatusCodes.NOT_FOUND.getStatusCode(), responseParts.get(8).getStatusCode());	final Exception exception = (Exception) responseParts.get(8).getBody();	assertNotNull(exception);	
read deleted entry exception 

========================= camel sample_14542 =========================

protected void doListNamespaceByLabel(Exchange exchange, String operation) {	Map<String, String> labels = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_LABELS, Map.class);	if (ObjectHelper.isEmpty(labels)) {	
get a specific namespace by labels require specify a labels set 

protected void doGetNamespace(Exchange exchange, String operation) {	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(namespaceName)) {	
get a specific namespace require specify a namespace name 

protected void doCreateNamespace(Exchange exchange, String operation) {	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(namespaceName)) {	
create a specific namespace require specify a namespace name 

protected void doDeleteNamespace(Exchange exchange, String operation) {	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(namespaceName)) {	
delete a specific namespace require specify a namespace name 

========================= camel sample_13287 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<LumberjackComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.lumberjack.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.lumberjack.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1211 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<LdifComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ldif.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ldif.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_726 =========================

protected T loadEntity(Exchange exchange, Object key) throws Exception {	LOCK.lock();	try {	
loadentity call 

protected T loadEntity(Exchange exchange, Object key) throws Exception {	LOCK.lock();	try {	T entity = findEntityByCorrelationKey(key);	if (entity == null) {	entity = createEntity(exchange, key);	setKeyProperty(entity, key);	ProcessDefinition definition = ProcessDefinition.getRefreshedProcessDefinition(entityManagerTemplate, getActivityRules().getProcessRules().getProcessDefinition());	setProcessDefinitionProperty(entity, definition);	entityManagerTemplate.persist(entity);	
about to flush on entity with key 

protected Class<?> getKeyType() {	try {	Method getter = IntrospectionSupport.getPropertyGetter(getEntityType(), getKeyPropertyName());	return getter.getReturnType();	} catch (NoSuchMethodException e) {	
no such getter for on this exception will be ignored 

========================= camel sample_12496 =========================

protected void assertCorrectMapReceived() {	Exchange exchange = endpoint.getReceivedExchanges().get(0);	assertNotNull(ExchangeHelper.getBinding(exchange, JmsBinding.class));	JmsMessage in = (JmsMessage) exchange.getIn();	assertNotNull(in);	Map<?, ?> map = exchange.getIn().getBody(Map.class);	
received map 

========================= camel sample_6887 =========================

public void notify(EventObject event) throws Exception {	boolean begin = event instanceof ExchangeCreatedEvent;	boolean complete = event instanceof ExchangeCompletedEvent || event instanceof ExchangeFailedEvent;	if (maxMessages > 0 && complete) {	doneMessages++;	boolean result = doneMessages >= maxMessages;	LOG.trace("Duration max messages check {} >= {} -> {}", doneMessages, maxMessages, result);	if (result) {	if (completed.compareAndSet(false, true)) {	
duration max messages triggering shutdown of the jvm 

doneMessages++;	boolean result = doneMessages >= maxMessages;	LOG.trace("Duration max messages check {} >= {} -> {}", doneMessages, maxMessages, result);	if (result) {	if (completed.compareAndSet(false, true)) {	try {	if (stopCamelContext) {	camelContext.stop();	}	} catch (Exception e) {	
error during stopping camelcontext this exception is ignored 

camelContext.stop();	}	} catch (Exception e) {	} finally {	latch.countDown();	}	}	}	}	if (maxIdleSeconds > 0 && (begin || complete)) {	
message activity so restarting stop watch 

protected void doStart() throws Exception {	if (maxIdleSeconds > 0) {	camelContext.addStartupListener((context, alreadyStarted) -> watch = new StopWatch());	executorService = camelContext.getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "MainDurationIdleChecker");	Runnable task = () -> {	if (watch == null) {	return;	}	int inflight = camelContext.getInflightRepository().size();	if (inflight > 0) {	
duration max idle check is skipped due inflight messages 

}	int inflight = camelContext.getInflightRepository().size();	if (inflight > 0) {	return;	}	long seconds = watch.taken() / 1000;	boolean result = seconds >= maxIdleSeconds;	LOG.trace("Duration max idle check {} >= {} -> {}", seconds, maxIdleSeconds, result);	if (result) {	if (completed.compareAndSet(false, true)) {	
duration max idle triggering shutdown of the jvm 

long seconds = watch.taken() / 1000;	boolean result = seconds >= maxIdleSeconds;	LOG.trace("Duration max idle check {} >= {} -> {}", seconds, maxIdleSeconds, result);	if (result) {	if (completed.compareAndSet(false, true)) {	try {	if (stopCamelContext) {	camelContext.stop();	}	} catch (Exception e) {	
error during stopping camelcontext this exception is ignored 

========================= camel sample_5602 =========================

public void testCacheBasedBodyReplacer() throws Exception {	
beginning test testcachebasedbodyreplacer 

in.setHeader(CacheConstants.CACHE_KEY, key);	if (key.equalsIgnoreCase("greeting")) {	in.setBody("Hello World");	} else {	in.setBody("Bye World");	}	}	});	}	resultEndpoint.assertIsSatisfied();	
completed test testcachebasedbodyreplacer 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() {	from("cache: .process(new CacheBasedMessageBodyReplacer("cache: .to("direct:next");	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	String key = (String)exchange.getIn().getHeader(CacheConstants.CACHE_KEY);	Object body = exchange.getIn().getBody();	String data = exchange.getContext().getTypeConverter().convertTo(String.class, body);	if (log.isDebugEnabled()) {	
payload replacement results 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() {	from("cache: .process(new CacheBasedMessageBodyReplacer("cache: .to("direct:next");	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	String key = (String)exchange.getIn().getHeader(CacheConstants.CACHE_KEY);	Object body = exchange.getIn().getBody();	String data = exchange.getContext().getTypeConverter().convertTo(String.class, body);	if (log.isDebugEnabled()) {	
the following payload was replaced from cache 

from("cache: .process(new CacheBasedMessageBodyReplacer("cache: .to("direct:next");	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	String key = (String)exchange.getIn().getHeader(CacheConstants.CACHE_KEY);	Object body = exchange.getIn().getBody();	String data = exchange.getContext().getTypeConverter().convertTo(String.class, body);	if (log.isDebugEnabled()) {	log.debug("key = {}", key);	log.debug("Before value = Hello World");	log.debug("After value = {}", data);	
end 

========================= camel sample_10501 =========================

private void shutdownServer(SolrClient server) throws IOException {	if (server != null) {	
shutting down solr server 

========================= camel sample_13993 =========================

public DozerTypeConverterLoader(CamelContext camelContext, DozerBeanMapperConfiguration configuration) {	ClassLoader tccl = Thread.currentThread().getContextClassLoader();	try {	ClassLoader appcl = camelContext.getApplicationContextClassLoader();	if (appcl != null) {	Thread.currentThread().setContextClassLoader(appcl);	}	
using dozerbeanmapperconfiguration 

if (configurations != null) {	for (Map.Entry<String, DozerBeanMapperConfiguration> entry : configurations.entrySet()) {	String id = entry.getKey();	MapperFactory factory = new MapperFactory(getCamelContext(), entry.getValue());	Mapper beanMapper = factory.create();	if (!mappers.containsValue(beanMapper)) {	mappers.put(id, beanMapper);	}	}	}	
loaded dozer mappers from camel registry 

for (Map.Entry<String, DozerBeanMapperConfiguration> entry : configurations.entrySet()) {	String id = entry.getKey();	MapperFactory factory = new MapperFactory(getCamelContext(), entry.getValue());	Mapper beanMapper = factory.create();	if (!mappers.containsValue(beanMapper)) {	mappers.put(id, beanMapper);	}	}	}	if (mappers.size() == 0) {	
no dozer mappers found in camel registry you should add dozer mappers as beans to the registry of the type 

protected void addDozerTypeConverter(TypeConverterRegistry registry, DozerTypeConverter converter, String dozerId, Class<?> to, Class<?> from) {	if (log.isInfoEnabled()) {	if (dozerId != null) {	
added dozer as camel type converter 

protected void addDozerTypeConverter(TypeConverterRegistry registry, DozerTypeConverter converter, String dozerId, Class<?> to, Class<?> from) {	if (log.isInfoEnabled()) {	if (dozerId != null) {	} else {	
added dozer as camel type converter 

========================= camel sample_9436 =========================

public void afterPropertiesSet() throws Exception {	StopWatch watch = new StopWatch();	super.afterPropertiesSet();	Boolean shutdownEager = CamelContextHelper.parseBoolean(getContext(), getShutdownEager());	if (shutdownEager != null) {	
using shutdowneager 

public void afterPropertiesSet() throws Exception {	StopWatch watch = new StopWatch();	super.afterPropertiesSet();	Boolean shutdownEager = CamelContextHelper.parseBoolean(getContext(), getShutdownEager());	if (shutdownEager != null) {	getContext().setShutdownEager(shutdownEager);	}	
afterpropertiesset took millis 

protected void initCustomRegistry(SpringCamelContext context) {	Registry registry = getBeanForType(Registry.class);	if (registry != null) {	
using custom registry 

protected void initPropertyPlaceholder() throws Exception {	super.initPropertyPlaceholder();	Map<String, BridgePropertyPlaceholderConfigurer> beans = applicationContext.getBeansOfType(BridgePropertyPlaceholderConfigurer.class);	if (beans.size() == 1) {	BridgePropertyPlaceholderConfigurer configurer = beans.values().iterator().next();	String id = beans.keySet().iterator().next();	
bridging camel and spring property placeholder configurer with id 

}	pc.setSystemPropertiesMode(configurer.getSystemPropertiesMode());	configurer.setResolver(pc.getPropertiesResolver());	configurer.setParser(pc.getPropertiesParser());	pc.setPropertiesResolver(configurer);	pc.setPropertiesParser(configurer);	List<PropertiesLocation> locations = new ArrayList<>(pc.getLocations());	locations.add(0, new PropertiesLocation("ref", id));	pc.setLocations(locations);	} else if (beans.size() > 1) {	
cannot bridge camel and spring property placeholders as exact only bean of type bridgepropertyplaceholderconfigurer must be defined was beans defined 

========================= camel sample_16338 =========================

private InputStream consume(URL url, final Consumer<String> consumer) throws IOException {	final InputStream stream = url.openConnection().getInputStream();	new Thread() {	public void run() {	try (BufferedReader reader = new BufferedReader(new InputStreamReader(stream))) {	String line;	while ((line = reader.readLine()) != null) {	consumer.accept(line);	}	} catch (IOException ex) {	
consumer thread is terminating 

========================= camel sample_1006 =========================

public void onRemoval(K key, V value, RemovalCause cause) {	if (cause.wasEvicted()) {	evicted.increment();	
onremoval 

public void onRemoval(K key, V value, RemovalCause cause) {	if (cause.wasEvicted()) {	evicted.increment();	if (stopOnEviction) {	try {	ServiceHelper.stopService(value);	} catch (Exception e) {	
error stopping service this exception will be ignored 

========================= camel sample_4341 =========================

public boolean process(Exchange camelExchange, AsyncCallback callback) {	
process exchange in an async way 

public void process(Exchange camelExchange) throws Exception {	
process exchange in sync way 

camelExchange.setException(exception);	} finally {	if (endpoint.getCookieHandler() != null) {	try {	Message inMessage = cxfExchange.getInMessage();	if (inMessage != null) {	Map<String, List<String>> cxfHeaders = CastUtils.cast((Map<?, ?>)inMessage.get(Message.PROTOCOL_HEADERS));	endpoint.getCookieHandler().storeCookies(camelExchange, endpoint.getRequestUri(camelExchange), cxfHeaders);	}	} catch (IOException e) {	
cannot store cookies 

transportHeaders = new TreeMap<String, List<String>>(String.CASE_INSENSITIVE_ORDER);	added = true;	} else {	added = false;	}	transportHeaders.putAll(endpoint.getCookieHandler().loadCookies(camelExchange, endpoint.getRequestUri(camelExchange)));	if (added && transportHeaders.size() > 0) {	requestContext.put(Message.PROTOCOL_HEADERS, transportHeaders);	}	} catch (IOException e) {	
cannot load cookies 

private BindingOperationInfo prepareBindingOperation(Exchange camelExchange, org.apache.cxf.message.Exchange cxfExchange) {	BindingOperationInfo boi = getBindingOperationInfo(camelExchange);	ObjectHelper.notNull(boi, "BindingOperationInfo");	if (endpoint.getDataFormat() == DataFormat.PAYLOAD && boi.isUnwrapped()) {	boi = boi.getWrappedOperation();	cxfExchange.put(BindingOperationInfo.class, boi);	}	camelExchange.setProperty(BindingOperationInfo.class.getName(), boi);	
set exchange property bindingoperationinfo 

BindingOperationInfo boi = getBindingOperationInfo(camelExchange);	ObjectHelper.notNull(boi, "BindingOperationInfo");	if (endpoint.getDataFormat() == DataFormat.PAYLOAD && boi.isUnwrapped()) {	boi = boi.getWrappedOperation();	cxfExchange.put(BindingOperationInfo.class, boi);	}	camelExchange.setProperty(BindingOperationInfo.class.getName(), boi);	if (endpoint.getDataFormat() != DataFormat.PAYLOAD && !endpoint.isWrapped() && boi != null) {	if (boi.isUnwrappedCapable()) {	boi = boi.getUnwrappedOperation();	
unwrapped boi 

private BindingOperationInfo getBindingOperationInfo(Exchange ex) {	CxfEndpoint endpoint = (CxfEndpoint)this.getEndpoint();	BindingOperationInfo answer = null;	String lp = ex.getIn().getHeader(CxfConstants.OPERATION_NAME, String.class);	if (lp == null) {	
cxfproducer cannot find the from message header trying with defaultoperationname 

private BindingOperationInfo getBindingOperationInfo(Exchange ex) {	CxfEndpoint endpoint = (CxfEndpoint)this.getEndpoint();	BindingOperationInfo answer = null;	String lp = ex.getIn().getHeader(CxfConstants.OPERATION_NAME, String.class);	if (lp == null) {	lp = endpoint.getDefaultOperationName();	}	if (lp == null) {	
cxfproducer cannot find the from message header and there is no defaultoperationname setting cxfproducer will pick up the first available operation 

if (iter.hasNext()) {	answer = iter.next();	}	} else {	String ns = ex.getIn().getHeader(CxfConstants.OPERATION_NAMESPACE, String.class);	if (ns == null) {	ns = endpoint.getDefaultOperationNamespace();	}	if (ns == null) {	ns = client.getEndpoint().getService().getName().getNamespaceURI();	
operation namespace not in header set it to 

========================= camel sample_7994 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<AvroComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.avro.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.avro.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1143 =========================

protected void doResume() throws Exception {	if (channel != null) {	
serverbootstrap binding to 

protected void doSuspend() throws Exception {	if (channel != null) {	
serverbootstrap unbinding from 

serverBootstrap.setOption("child.reuseAddress", configuration.isReuseAddress());	serverBootstrap.setOption("child.connectTimeoutMillis", configuration.getConnectTimeout());	if (configuration.getBacklog() > 0) {	serverBootstrap.setOption("backlog", configuration.getBacklog());	}	if (configuration.getOptions() != null) {	for (Map.Entry<String, Object> entry : configuration.getOptions().entrySet()) {	serverBootstrap.setOption(entry.getKey(), entry.getValue());	}	}	
created serverbootstrap with options 

serverBootstrap.setOption("child.connectTimeoutMillis", configuration.getConnectTimeout());	if (configuration.getBacklog() > 0) {	serverBootstrap.setOption("backlog", configuration.getBacklog());	}	if (configuration.getOptions() != null) {	for (Map.Entry<String, Object> entry : configuration.getOptions().entrySet()) {	serverBootstrap.setOption(entry.getKey(), entry.getValue());	}	}	serverBootstrap.setPipelineFactory(pipelineFactory);	
serverbootstrap binding to 

protected void stopServerBootstrap() {	
serverbootstrap unbinding from 

protected void stopServerBootstrap() {	
closing channels 

========================= camel sample_6686 =========================

public void testTimerUsingStopWatch() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(2);	StopWatch watch = new StopWatch();	assertMockEndpointsSatisfied();	long interval = watch.taken();	
should take approx milliseconds was 

========================= camel sample_1513 =========================

final CountDownLatch receivedMessageLatch = new CountDownLatch(1);	RouteBuilder routes = new RouteBuilder() {	public void configure() throws Exception {	from("quickfix:examples/gateway.cfg"). filter(header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.SessionLogon)). bean(new CountDownLatchDecrementer("logon", logonLatch));	from("quickfix:examples/gateway.cfg"). filter(header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.AppMessageReceived)). recipientList(method(new FixMessageRouter("quickfix:examples/gateway.cfg")));	from("quickfix:examples/gateway.cfg"). filter(PredicateBuilder.or( header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.AppMessageReceived), header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.AppMessageSent))). bean(new QuickfixjMessageJsonPrinter());	from("quickfix:examples/gateway.cfg?sessionID=FIX.4.2:TRADER@2->GATEWAY"). filter(PredicateBuilder.and( header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.AppMessageReceived), header(QuickfixjEndpoint.MESSAGE_TYPE_KEY).isEqualTo(MsgType.EMAIL))). bean(new CountDownLatchDecrementer("message", receivedMessageLatch));	}	};	context.addRoutes(routes);	
starting camel context 

context.addRoutes(routes);	context.start();	if (!logonLatch.await(5, TimeUnit.SECONDS)) {	throw new IllegalStateException("Logon did not complete");	}	String gatewayUri = "quickfix:examples/gateway.cfg?sessionID=FIX.4.2:TRADER@1->GATEWAY";	Endpoint gatewayEndpoint = context.getEndpoint(gatewayUri);	Producer producer = gatewayEndpoint.createProducer();	Email email = TestSupport.createEmailMessage("Dynamic Routing Example");	email.getHeader().setString(DeliverToCompID.FIELD, "TRADER@2");	
sending routed message 

Endpoint gatewayEndpoint = context.getEndpoint(gatewayUri);	Producer producer = gatewayEndpoint.createProducer();	Email email = TestSupport.createEmailMessage("Dynamic Routing Example");	email.getHeader().setString(DeliverToCompID.FIELD, "TRADER@2");	Exchange exchange = producer.createExchange(ExchangePattern.InOnly);	exchange.getIn().setBody(email);	producer.process(exchange);	if (!receivedMessageLatch.await(5, TimeUnit.SECONDS)) {	throw new IllegalStateException("Message did not reach target");	}	
message received shutting down camel context 

Producer producer = gatewayEndpoint.createProducer();	Email email = TestSupport.createEmailMessage("Dynamic Routing Example");	email.getHeader().setString(DeliverToCompID.FIELD, "TRADER@2");	Exchange exchange = producer.createExchange(ExchangePattern.InOnly);	exchange.getIn().setBody(email);	producer.process(exchange);	if (!receivedMessageLatch.await(5, TimeUnit.SECONDS)) {	throw new IllegalStateException("Message did not reach target");	}	context.stop();	
dynamic routing example complete 

========================= camel sample_10653 =========================

CamelContext camelContext = getCamelContext(context);	QuartzEndpoint endpoint = lookupQuartzEndpoint(camelContext, context);	exchange = endpoint.createExchange();	exchange.setIn(new QuartzMessage(exchange, context));	endpoint.getConsumerLoadBalancer().process(exchange);	if (exchange.getException() != null) {	throw new JobExecutionException(exchange.getException());	}	} catch (Exception e) {	if (exchange != null) {	
error processing exchange 

QuartzEndpoint endpoint = lookupQuartzEndpoint(camelContext, context);	exchange = endpoint.createExchange();	exchange.setIn(new QuartzMessage(exchange, context));	endpoint.getConsumerLoadBalancer().process(exchange);	if (exchange.getException() != null) {	throw new JobExecutionException(exchange.getException());	}	} catch (Exception e) {	if (exchange != null) {	} else {	
failed to execute cameljob 

}	if (triggerKey.equals(checkTriggerKey) || (jobDetail.requestsRecovery() && jobKey.getGroup().equals(checkTriggerKey.getGroup()) && jobKey.getName().equals(checkTriggerKey.getName()))) {	return quartzEndpoint;	}	}	}	String endpointUri = quartzContext.getMergedJobDataMap().getString(QuartzConstants.QUARTZ_ENDPOINT_URI);	QuartzEndpoint result = null;	if (camelContext.hasEndpoint(endpointUri) != null) {	if (LOG.isDebugEnabled()) {	
getting endpoint from camelcontext 

QuartzEndpoint result = null;	if (camelContext.hasEndpoint(endpointUri) != null) {	if (LOG.isDebugEnabled()) {	}	result = camelContext.getEndpoint(endpointUri, QuartzEndpoint.class);	} else if ((result = searchForEndpointMatch(camelContext, endpointUri)) != null) {	if (LOG.isDebugEnabled()) {	LOG.debug("Found match for endpoint URI = " + endpointUri + " by searching endpoint list.");	}	} else {	
cannot find existing quartzendpoint with uri creating new endpoint instance 

========================= camel sample_15001 =========================

MockEndpoint mockEndpoint = resolveMandatoryEndpoint("mock:results", MockEndpoint.class);	mockEndpoint.expectedMessageCount(1);	template.sendBody("direct:start", null);	mockEndpoint.assertIsSatisfied();	List<Exchange> list = mockEndpoint.getReceivedExchanges();	Exchange exchange = list.get(0);	assertNotNull("exchange", exchange);	Message in = exchange.getIn();	assertNotNull("in", in);	Map<String, Object> headers = in.getHeaders();	
headers 

template.sendBody("direct:start", null);	mockEndpoint.assertIsSatisfied();	List<Exchange> list = mockEndpoint.getReceivedExchanges();	Exchange exchange = list.get(0);	assertNotNull("exchange", exchange);	Message in = exchange.getIn();	assertNotNull("in", in);	Map<String, Object> headers = in.getHeaders();	checkHeaders(headers);	String body = in.getBody(String.class);	
body 

========================= camel sample_12814 =========================

protected static void setupClient() throws Exception {	olingoApp = new Olingo2AppImpl(TEST_SERVICE_URL + "/");	olingoApp.setContentType(TEST_FORMAT_STRING);	
read edm 

protected static void setupClient() throws Exception {	olingoApp = new Olingo2AppImpl(TEST_SERVICE_URL + "/");	olingoApp.setContentType(TEST_FORMAT_STRING);	final TestOlingo2ResponseHandler<Edm> responseHandler = new TestOlingo2ResponseHandler<Edm>();	olingoApp.read(null, Olingo2AppImpl.METADATA, null, null, responseHandler);	edm = responseHandler.await();	
read default entitycontainer 

public void testServiceDocument() throws Exception {	final TestOlingo2ResponseHandler<ServiceDocument> responseHandler = new TestOlingo2ResponseHandler<ServiceDocument>();	olingoApp.read(null, "", null, null, responseHandler);	final ServiceDocument serviceDocument = responseHandler.await();	final List<Collection> collections = serviceDocument.getAtomInfo().getWorkspaces().get(0).getCollections();	assertEquals("Service Atom Collections", 3, collections.size());	
service atom collections 

public void testServiceDocument() throws Exception {	final TestOlingo2ResponseHandler<ServiceDocument> responseHandler = new TestOlingo2ResponseHandler<ServiceDocument>();	olingoApp.read(null, "", null, null, responseHandler);	final ServiceDocument serviceDocument = responseHandler.await();	final List<Collection> collections = serviceDocument.getAtomInfo().getWorkspaces().get(0).getCollections();	assertEquals("Service Atom Collections", 3, collections.size());	final List<EdmEntitySetInfo> entitySetsInfo = serviceDocument.getEntitySetsInfo();	assertEquals("Service Entity Sets", 3, entitySetsInfo.size());	
service document entries 

public void testReadFeed() throws Exception {	final TestOlingo2ResponseHandler<ODataFeed> responseHandler = new TestOlingo2ResponseHandler<ODataFeed>();	olingoApp.read(edm, MANUFACTURERS, null, null, responseHandler);	final ODataFeed dataFeed = responseHandler.await();	assertNotNull("Data feed", dataFeed);	
entries 

public void testReadUnparsedFeed() throws Exception {	final TestOlingo2ResponseHandler<InputStream> responseHandler = new TestOlingo2ResponseHandler<InputStream>();	olingoApp.uread(edm, MANUFACTURERS, null, null, responseHandler);	final InputStream rawfeed = responseHandler.await();	assertNotNull("Data feed", rawfeed);	final ODataFeed dataFeed = EntityProvider.readFeed(TEST_FORMAT_STRING, edmEntitySetMap.get(MANUFACTURERS), rawfeed, EntityProviderReadProperties.init().build());	
entries 

public void testReadEntry() throws Exception {	final TestOlingo2ResponseHandler<ODataEntry> responseHandler = new TestOlingo2ResponseHandler<ODataEntry>();	olingoApp.read(edm, TEST_MANUFACTURER, null, null, responseHandler);	ODataEntry entry = responseHandler.await();	
single entry 

public void testReadEntry() throws Exception {	final TestOlingo2ResponseHandler<ODataEntry> responseHandler = new TestOlingo2ResponseHandler<ODataEntry>();	olingoApp.read(edm, TEST_MANUFACTURER, null, null, responseHandler);	ODataEntry entry = responseHandler.await();	responseHandler.reset();	olingoApp.read(edm, TEST_CAR, null, null, responseHandler);	entry = responseHandler.await();	
single entry 

olingoApp.read(edm, TEST_MANUFACTURER, null, null, responseHandler);	ODataEntry entry = responseHandler.await();	responseHandler.reset();	olingoApp.read(edm, TEST_CAR, null, null, responseHandler);	entry = responseHandler.await();	responseHandler.reset();	final Map<String, String> queryParams = new HashMap<String, String>();	queryParams.put(SystemQueryOption.$expand.toString(), CARS);	olingoApp.read(edm, TEST_MANUFACTURER, queryParams, null, responseHandler);	ODataEntry entryExpanded = responseHandler.await();	
single entry with expanded cars relation 

public void testReadUnparsedEntry() throws Exception {	final TestOlingo2ResponseHandler<InputStream> responseHandler = new TestOlingo2ResponseHandler<InputStream>();	olingoApp.uread(edm, TEST_MANUFACTURER, null, null, responseHandler);	InputStream rawentry = responseHandler.await();	ODataEntry entry = EntityProvider.readEntry(TEST_FORMAT_STRING, edmEntitySetMap.get(MANUFACTURERS), rawentry, EntityProviderReadProperties.init().build());	
single entry 

public void testReadUnparsedEntry() throws Exception {	final TestOlingo2ResponseHandler<InputStream> responseHandler = new TestOlingo2ResponseHandler<InputStream>();	olingoApp.uread(edm, TEST_MANUFACTURER, null, null, responseHandler);	InputStream rawentry = responseHandler.await();	ODataEntry entry = EntityProvider.readEntry(TEST_FORMAT_STRING, edmEntitySetMap.get(MANUFACTURERS), rawentry, EntityProviderReadProperties.init().build());	responseHandler.reset();	olingoApp.uread(edm, TEST_CAR, null, null, responseHandler);	rawentry = responseHandler.await();	entry = EntityProvider.readEntry(TEST_FORMAT_STRING, edmEntitySetMap.get(CARS), rawentry, EntityProviderReadProperties.init().build());	
single entry 

responseHandler.reset();	olingoApp.uread(edm, TEST_CAR, null, null, responseHandler);	rawentry = responseHandler.await();	entry = EntityProvider.readEntry(TEST_FORMAT_STRING, edmEntitySetMap.get(CARS), rawentry, EntityProviderReadProperties.init().build());	responseHandler.reset();	final Map<String, String> queryParams = new HashMap<String, String>();	queryParams.put(SystemQueryOption.$expand.toString(), CARS);	olingoApp.uread(edm, TEST_MANUFACTURER, queryParams, null, responseHandler);	rawentry = responseHandler.await();	ODataEntry entryExpanded = EntityProvider.readEntry(TEST_FORMAT_STRING, edmEntitySetMap.get(MANUFACTURERS), rawentry, EntityProviderReadProperties.init().build());	
single entry with expanded cars relation 

public void testReadUpdateProperties() throws Exception {	final TestOlingo2ResponseHandler<Map<String, Object>> propertyHandler = new TestOlingo2ResponseHandler<Map<String, Object>>();	olingoApp.read(edm, TEST_MANUFACTURER_FOUNDED_PROPERTY, null, null, propertyHandler);	Calendar founded = (Calendar) propertyHandler.await().get(FOUNDED_PROPERTY);	
founded property 

public void testReadUpdateProperties() throws Exception {	final TestOlingo2ResponseHandler<Map<String, Object>> propertyHandler = new TestOlingo2ResponseHandler<Map<String, Object>>();	olingoApp.read(edm, TEST_MANUFACTURER_FOUNDED_PROPERTY, null, null, propertyHandler);	Calendar founded = (Calendar) propertyHandler.await().get(FOUNDED_PROPERTY);	final TestOlingo2ResponseHandler<Calendar> valueHandler = new TestOlingo2ResponseHandler<Calendar>();	olingoApp.read(edm, TEST_MANUFACTURER_FOUNDED_VALUE, null, null, valueHandler);	founded = valueHandler.await();	
founded property 

final TestOlingo2ResponseHandler<Map<String, Object>> propertyHandler = new TestOlingo2ResponseHandler<Map<String, Object>>();	olingoApp.read(edm, TEST_MANUFACTURER_FOUNDED_PROPERTY, null, null, propertyHandler);	Calendar founded = (Calendar) propertyHandler.await().get(FOUNDED_PROPERTY);	final TestOlingo2ResponseHandler<Calendar> valueHandler = new TestOlingo2ResponseHandler<Calendar>();	olingoApp.read(edm, TEST_MANUFACTURER_FOUNDED_VALUE, null, null, valueHandler);	founded = valueHandler.await();	final TestOlingo2ResponseHandler<HttpStatusCodes> statusHandler = new TestOlingo2ResponseHandler<HttpStatusCodes>();	final HashMap<String, Object> properties = new HashMap<String, Object>();	properties.put(FOUNDED_PROPERTY, new Date());	olingoApp.update(edm, TEST_MANUFACTURER_FOUNDED_PROPERTY, null, new Date(), statusHandler);	
founded property updated with status 

Calendar founded = (Calendar) propertyHandler.await().get(FOUNDED_PROPERTY);	final TestOlingo2ResponseHandler<Calendar> valueHandler = new TestOlingo2ResponseHandler<Calendar>();	olingoApp.read(edm, TEST_MANUFACTURER_FOUNDED_VALUE, null, null, valueHandler);	founded = valueHandler.await();	final TestOlingo2ResponseHandler<HttpStatusCodes> statusHandler = new TestOlingo2ResponseHandler<HttpStatusCodes>();	final HashMap<String, Object> properties = new HashMap<String, Object>();	properties.put(FOUNDED_PROPERTY, new Date());	olingoApp.update(edm, TEST_MANUFACTURER_FOUNDED_PROPERTY, null, new Date(), statusHandler);	statusHandler.reset();	olingoApp.update(edm, TEST_MANUFACTURER_FOUNDED_VALUE, null, new Date(), statusHandler);	
founded property updated with status 

founded = valueHandler.await();	final TestOlingo2ResponseHandler<HttpStatusCodes> statusHandler = new TestOlingo2ResponseHandler<HttpStatusCodes>();	final HashMap<String, Object> properties = new HashMap<String, Object>();	properties.put(FOUNDED_PROPERTY, new Date());	olingoApp.update(edm, TEST_MANUFACTURER_FOUNDED_PROPERTY, null, new Date(), statusHandler);	statusHandler.reset();	olingoApp.update(edm, TEST_MANUFACTURER_FOUNDED_VALUE, null, new Date(), statusHandler);	propertyHandler.reset();	olingoApp.read(edm, TEST_MANUFACTURER_ADDRESS_PROPERTY, null, null, propertyHandler);	final Map<String, Object> address = propertyHandler.await();	
address property 

propertyHandler.reset();	olingoApp.read(edm, TEST_MANUFACTURER_ADDRESS_PROPERTY, null, null, propertyHandler);	final Map<String, Object> address = propertyHandler.await();	statusHandler.reset();	address.clear();	address.put("Street", "Star Street 137");	address.put("City", "Stuttgart");	address.put("ZipCode", "70173");	address.put("Country", "Germany");	olingoApp.merge(edm, TEST_MANUFACTURER_ADDRESS_PROPERTY, null, address, statusHandler);	
address property updated with status 

public void testReadDeleteCreateLinks() throws Exception {	final TestOlingo2ResponseHandler<List<String>> linksHandler = new TestOlingo2ResponseHandler<List<String>>();	olingoApp.read(edm, TEST_MANUFACTURER_LINKS_CARS, null, null, linksHandler);	final List<String> links = linksHandler.await();	assertFalse(links.isEmpty());	
read links 

public void testReadDeleteCreateLinks() throws Exception {	final TestOlingo2ResponseHandler<List<String>> linksHandler = new TestOlingo2ResponseHandler<List<String>>();	olingoApp.read(edm, TEST_MANUFACTURER_LINKS_CARS, null, null, linksHandler);	final List<String> links = linksHandler.await();	assertFalse(links.isEmpty());	final TestOlingo2ResponseHandler<String> linkHandler = new TestOlingo2ResponseHandler<String>();	olingoApp.read(edm, TEST_CAR_LINK_MANUFACTURER, null, null, linkHandler);	final String link = linkHandler.await();	
read link 

public void testReadCount() throws Exception {	final TestOlingo2ResponseHandler<Long> countHandler = new TestOlingo2ResponseHandler<Long>();	olingoApp.read(edm, MANUFACTURERS + COUNT_OPTION, null, null, countHandler);	
manufacturers count 

public void testReadCount() throws Exception {	final TestOlingo2ResponseHandler<Long> countHandler = new TestOlingo2ResponseHandler<Long>();	olingoApp.read(edm, MANUFACTURERS + COUNT_OPTION, null, null, countHandler);	countHandler.reset();	olingoApp.read(edm, TEST_MANUFACTURER + COUNT_OPTION, null, null, countHandler);	
manufacturer count 

public void testReadCount() throws Exception {	final TestOlingo2ResponseHandler<Long> countHandler = new TestOlingo2ResponseHandler<Long>();	olingoApp.read(edm, MANUFACTURERS + COUNT_OPTION, null, null, countHandler);	countHandler.reset();	olingoApp.read(edm, TEST_MANUFACTURER + COUNT_OPTION, null, null, countHandler);	countHandler.reset();	olingoApp.read(edm, TEST_MANUFACTURER_LINKS_CARS + COUNT_OPTION, null, null, countHandler);	
manufacturers links count 

public void testReadCount() throws Exception {	final TestOlingo2ResponseHandler<Long> countHandler = new TestOlingo2ResponseHandler<Long>();	olingoApp.read(edm, MANUFACTURERS + COUNT_OPTION, null, null, countHandler);	countHandler.reset();	olingoApp.read(edm, TEST_MANUFACTURER + COUNT_OPTION, null, null, countHandler);	countHandler.reset();	olingoApp.read(edm, TEST_MANUFACTURER_LINKS_CARS + COUNT_OPTION, null, null, countHandler);	countHandler.reset();	olingoApp.read(edm, TEST_CAR_LINK_MANUFACTURER + COUNT_OPTION, null, null, countHandler);	
manufacturer link count 

public void testCreateUpdateDeleteEntry() throws Exception {	final TestOlingo2ResponseHandler<ODataEntry> entryHandler = new TestOlingo2ResponseHandler<ODataEntry>();	olingoApp.create(edm, MANUFACTURERS, null, getEntityData(), entryHandler);	ODataEntry createdEntry = entryHandler.await();	
created entry 

final TestOlingo2ResponseHandler<HttpStatusCodes> statusHandler = new TestOlingo2ResponseHandler<HttpStatusCodes>();	olingoApp.update(edm, TEST_CREATE_MANUFACTURER, null, data, statusHandler);	statusHandler.await();	statusHandler.reset();	data.put("Name", "MyCarManufacturer Patched");	olingoApp.patch(edm, TEST_CREATE_MANUFACTURER, null, data, statusHandler);	statusHandler.await();	entryHandler.reset();	olingoApp.read(edm, TEST_CREATE_MANUFACTURER, null, null, entryHandler);	ODataEntry updatedEntry = entryHandler.await();	
updated entry successfully 

statusHandler.reset();	data.put("Name", "MyCarManufacturer Patched");	olingoApp.patch(edm, TEST_CREATE_MANUFACTURER, null, data, statusHandler);	statusHandler.await();	entryHandler.reset();	olingoApp.read(edm, TEST_CREATE_MANUFACTURER, null, null, entryHandler);	ODataEntry updatedEntry = entryHandler.await();	statusHandler.reset();	olingoApp.delete(TEST_CREATE_MANUFACTURER, null, statusHandler);	HttpStatusCodes statusCode = statusHandler.await();	
deletion of entry was successful 

data.put("Name", "MyCarManufacturer Patched");	olingoApp.patch(edm, TEST_CREATE_MANUFACTURER, null, data, statusHandler);	statusHandler.await();	entryHandler.reset();	olingoApp.read(edm, TEST_CREATE_MANUFACTURER, null, null, entryHandler);	ODataEntry updatedEntry = entryHandler.await();	statusHandler.reset();	olingoApp.delete(TEST_CREATE_MANUFACTURER, null, statusHandler);	HttpStatusCodes statusCode = statusHandler.await();	try {	
verify delete entry 

ODataEntry updatedEntry = entryHandler.await();	statusHandler.reset();	olingoApp.delete(TEST_CREATE_MANUFACTURER, null, statusHandler);	HttpStatusCodes statusCode = statusHandler.await();	try {	entryHandler.reset();	olingoApp.read(edm, TEST_CREATE_MANUFACTURER, null, null, entryHandler);	entryHandler.await();	fail("Entry not deleted!");	} catch (Exception e) {	
deleted entry not found 

batchParts.add(Olingo2BatchChangeRequest.resourcePath(TEST_RESOURCE).operation(Operation.UPDATE) .body(updateData).build());	batchParts.add(Olingo2BatchChangeRequest.resourcePath(TEST_RESOURCE).operation(Operation.DELETE).build());	final TestOlingo2ResponseHandler<List<Olingo2BatchResponse>> responseHandler = new TestOlingo2ResponseHandler<List<Olingo2BatchResponse>>();	batchParts.add(Olingo2BatchQueryRequest.resourcePath(TEST_CREATE_MANUFACTURER).build());	olingoApp.batch(edm, null, batchParts, responseHandler);	final List<Olingo2BatchResponse> responseParts = responseHandler.await(15, TimeUnit.MINUTES);	assertEquals("Batch responses expected", 8, responseParts.size());	assertNotNull(responseParts.get(0).getBody());	final ODataFeed feed = (ODataFeed) responseParts.get(1).getBody();	assertNotNull(feed);	
batch feed 

final TestOlingo2ResponseHandler<List<Olingo2BatchResponse>> responseHandler = new TestOlingo2ResponseHandler<List<Olingo2BatchResponse>>();	batchParts.add(Olingo2BatchQueryRequest.resourcePath(TEST_CREATE_MANUFACTURER).build());	olingoApp.batch(edm, null, batchParts, responseHandler);	final List<Olingo2BatchResponse> responseParts = responseHandler.await(15, TimeUnit.MINUTES);	assertEquals("Batch responses expected", 8, responseParts.size());	assertNotNull(responseParts.get(0).getBody());	final ODataFeed feed = (ODataFeed) responseParts.get(1).getBody();	assertNotNull(feed);	ODataEntry dataEntry = (ODataEntry) responseParts.get(2).getBody();	assertNotNull(dataEntry);	
batch read entry 

olingoApp.batch(edm, null, batchParts, responseHandler);	final List<Olingo2BatchResponse> responseParts = responseHandler.await(15, TimeUnit.MINUTES);	assertEquals("Batch responses expected", 8, responseParts.size());	assertNotNull(responseParts.get(0).getBody());	final ODataFeed feed = (ODataFeed) responseParts.get(1).getBody();	assertNotNull(feed);	ODataEntry dataEntry = (ODataEntry) responseParts.get(2).getBody();	assertNotNull(dataEntry);	dataEntry = (ODataEntry) responseParts.get(3).getBody();	assertNotNull(dataEntry);	
batch read entry with expand 

assertEquals("Batch responses expected", 8, responseParts.size());	assertNotNull(responseParts.get(0).getBody());	final ODataFeed feed = (ODataFeed) responseParts.get(1).getBody();	assertNotNull(feed);	ODataEntry dataEntry = (ODataEntry) responseParts.get(2).getBody();	assertNotNull(dataEntry);	dataEntry = (ODataEntry) responseParts.get(3).getBody();	assertNotNull(dataEntry);	dataEntry = (ODataEntry) responseParts.get(4).getBody();	assertNotNull(dataEntry);	
batch create entry 

assertNotNull(dataEntry);	dataEntry = (ODataEntry) responseParts.get(3).getBody();	assertNotNull(dataEntry);	dataEntry = (ODataEntry) responseParts.get(4).getBody();	assertNotNull(dataEntry);	assertEquals(HttpStatusCodes.NO_CONTENT.getStatusCode(), responseParts.get(5).getStatusCode());	assertEquals(HttpStatusCodes.NO_CONTENT.getStatusCode(), responseParts.get(6).getStatusCode());	assertEquals(HttpStatusCodes.NOT_FOUND.getStatusCode(), responseParts.get(7).getStatusCode());	final Exception exception = (Exception) responseParts.get(7).getBody();	assertNotNull(exception);	
batch retrieve deleted entry 

public void onResponse(T response, Map<String, String> responseHeaders) {	this.response = response;	if (LOG.isDebugEnabled()) {	if (response instanceof ODataFeed) {	
received response 

public void onResponse(T response, Map<String, String> responseHeaders) {	this.response = response;	if (LOG.isDebugEnabled()) {	if (response instanceof ODataFeed) {	} else if (response instanceof ODataEntry) {	
received response 

public void onResponse(T response, Map<String, String> responseHeaders) {	this.response = response;	if (LOG.isDebugEnabled()) {	if (response instanceof ODataFeed) {	} else if (response instanceof ODataEntry) {	} else {	
received response 

========================= camel sample_14539 =========================

protected Enumeration<URL> getResources(ClassLoader loader, String packageName) throws IOException {	Enumeration<URL> enumeration = super.getResources(loader, packageName);	if (!enumeration.hasMoreElements()) {	
using websphere workaround to load the camel jars with the annotated converters 

========================= camel sample_4068 =========================

public static void setUpClass() throws Exception {	try {	hbaseUtil.startMiniCluster(numServers);	} catch (Exception e) {	
couldn t start hbase cluster test is not started but passed 

========================= camel sample_14493 =========================

public void setUp() throws Exception {	super.setUp();	File directory = new File(PATH);	if (!directory.isDirectory() || !directory.exists()) {	
cannot delete files from directory s because path is not a directory or it doesn t exist 

public void setUp() throws Exception {	super.setUp();	File directory = new File(PATH);	if (!directory.isDirectory() || !directory.exists()) {	} else {	
deleting files from 

public void setUp() throws Exception {	super.setUp();	File directory = new File(PATH);	if (!directory.isDirectory() || !directory.exists()) {	} else {	File[] files = directory.listFiles();	for (File file : files) {	
deleting s 

========================= camel sample_12117 =========================

public void onFailure(Exchange exchange) {	try {	lock.readLock().lock();	if (commitStrategy.rollback(exchange)) {	if (LOG.isDebugEnabled()) {	
processing failure of exchange id 

try {	lock.readLock().lock();	if (commitStrategy.rollback(exchange)) {	if (LOG.isDebugEnabled()) {	}	if (session != null && session.getTransacted()) {	session.rollback();	}	}	} catch (Exception e) {	
failed to rollback the session this exception will be ignored 

public void onComplete(Exchange exchange) {	try {	lock.readLock().lock();	if (commitStrategy.commit(exchange)) {	if (LOG.isDebugEnabled()) {	
processing completion of exchange id 

try {	lock.readLock().lock();	if (commitStrategy.commit(exchange)) {	if (LOG.isDebugEnabled()) {	}	if (session != null && session.getTransacted()) {	session.commit();	}	}	} catch (Exception e) {	
failed to commit the session this exception will be ignored 

public void run() {	
batch transaction timer expired 

public void run() {	try {	lock.writeLock().lock();	
committing the current transactions 

public void run() {	try {	lock.writeLock().lock();	try {	if (session != null && session.getTransacted()) {	session.commit();	}	((BatchTransactionCommitStrategy) commitStrategy).reset();	} catch (Exception e) {	
failed to commit the session during timeout this exception will be ignored 

public boolean cancel() {	
cancelling the timeouttask 

========================= camel sample_12402 =========================

protected int poll() throws Exception {	
going to execute the weather query 

protected int poll() throws Exception {	HttpClient httpClient = ((WeatherComponent) getEndpoint().getComponent()).getHttpClient();	GetMethod getMethod = new GetMethod(query);	try {	int status = httpClient.executeMethod(getMethod);	if (status != HttpStatus.SC_OK) {	
http call for weather returned error status code as a result with query 

protected int poll() throws Exception {	HttpClient httpClient = ((WeatherComponent) getEndpoint().getComponent()).getHttpClient();	GetMethod getMethod = new GetMethod(query);	try {	int status = httpClient.executeMethod(getMethod);	if (status != HttpStatus.SC_OK) {	return 0;	}	String weather = getEndpoint().getCamelContext().getTypeConverter().mandatoryConvertTo(String.class, getMethod.getResponseBodyAsStream());	
got back the weather information 

========================= camel sample_11384 =========================

public void testPostStatusUpdateRequestResponse() throws Exception {	Date now = new Date();	String tweet = "UserProducerInOutTest: This is a tweet posted on " + now.toString();	
tweet 

========================= camel sample_14186 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<BoxComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.box.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.box.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_566 =========================

public void updateCorrelationId(String correlationId, String newCorrelationId, long requestTimeout) {	
updated provisional correlationid to expected correlationid 

protected void handleReplyMessage(String correlationID, Message message, Session session) {	ReplyHandler handler = correlation.get(correlationID);	if (handler == null && endpoint.isUseMessageIDAsCorrelationID()) {	handler = waitForProvisionCorrelationToBeUpdated(correlationID, message);	}	if (handler != null) {	correlation.remove(correlationID);	handler.onReply(correlationID, message, session);	} else {	
reply received for unknown correlationid on reply destination current correlation map size the message will be ignored 

if (type == null) {	type = ReplyToType.Shared;	}	if (ReplyToType.Shared == type) {	String replyToSelectorName = endpoint.getReplyToDestinationSelectorName();	if (replyToSelectorName != null) {	replyToSelectorValue = "ID:" + new BigInteger(24 * 8, new Random()).toString(16);	String fixedMessageSelector = replyToSelectorName + "='" + replyToSelectorValue + "'";	answer = new SharedQueueMessageListenerContainer(endpoint, fixedMessageSelector);	answer.setCacheLevel(DefaultMessageListenerContainer.CACHE_CONSUMER);	
using shared queue with fixed message selector as reply listener 

String replyToSelectorName = endpoint.getReplyToDestinationSelectorName();	if (replyToSelectorName != null) {	replyToSelectorValue = "ID:" + new BigInteger(24 * 8, new Random()).toString(16);	String fixedMessageSelector = replyToSelectorName + "='" + replyToSelectorValue + "'";	answer = new SharedQueueMessageListenerContainer(endpoint, fixedMessageSelector);	answer.setCacheLevel(DefaultMessageListenerContainer.CACHE_CONSUMER);	} else {	dynamicMessageSelector = new MessageSelectorCreator(correlation);	answer = new SharedQueueMessageListenerContainer(endpoint, dynamicMessageSelector);	answer.setCacheLevel(DefaultMessageListenerContainer.CACHE_SESSION);	
using shared queue with dynamic message selector as reply listener 

answer = new SharedQueueMessageListenerContainer(endpoint, fixedMessageSelector);	answer.setCacheLevel(DefaultMessageListenerContainer.CACHE_CONSUMER);	} else {	dynamicMessageSelector = new MessageSelectorCreator(correlation);	answer = new SharedQueueMessageListenerContainer(endpoint, dynamicMessageSelector);	answer.setCacheLevel(DefaultMessageListenerContainer.CACHE_SESSION);	}	log.warn("{} is using a shared reply queue, which is not as fast as alternatives." + " See more detail at the section 'Request-reply over JMS' at http: } else if (ReplyToType.Exclusive == type) {	answer = new ExclusiveQueueMessageListenerContainer(endpoint);	answer.setCacheLevel(DefaultMessageListenerContainer.CACHE_CONSUMER);	
using exclusive queue as reply listener 

}	log.warn("{} is using a shared reply queue, which is not as fast as alternatives." + " See more detail at the section 'Request-reply over JMS' at http: } else if (ReplyToType.Exclusive == type) {	answer = new ExclusiveQueueMessageListenerContainer(endpoint);	answer.setCacheLevel(DefaultMessageListenerContainer.CACHE_CONSUMER);	} else {	throw new IllegalArgumentException("ReplyToType " + type + " is not supported for reply queues");	}	String replyToCacheLevelName = endpoint.getConfiguration().getReplyToCacheLevelName();	if (replyToCacheLevelName != null) {	answer.setCacheLevelName(replyToCacheLevelName);	
setting the replycachelevel to be 

} else {	answer.setErrorHandler(new DefaultSpringErrorHandler(endpoint.getCamelContext(), QueueReplyManager.class, endpoint.getErrorHandlerLoggingLevel(), endpoint.isErrorHandlerLogStackTrace()));	}	if (endpoint.getReceiveTimeout() >= 0) {	answer.setReceiveTimeout(endpoint.getReceiveTimeout());	}	if (endpoint.getRecoveryInterval() >= 0) {	answer.setRecoveryInterval(endpoint.getRecoveryInterval());	}	if (endpoint.getTaskExecutor() != null) {	
using custom taskexecutor on listener container 

if (endpoint.getRecoveryInterval() >= 0) {	answer.setRecoveryInterval(endpoint.getRecoveryInterval());	}	if (endpoint.getTaskExecutor() != null) {	answer.setTaskExecutor(endpoint.getTaskExecutor());	}	String name = "QueueReplyManager[" + answer.getDestinationName() + "]";	answer.setBeanName(name);	if (answer.getConcurrentConsumers() > 1) {	if (ReplyToType.Shared == type) {	
using concurrent consumer on with shared queue may not work properly with all message brokers 

answer.setRecoveryInterval(endpoint.getRecoveryInterval());	}	if (endpoint.getTaskExecutor() != null) {	answer.setTaskExecutor(endpoint.getTaskExecutor());	}	String name = "QueueReplyManager[" + answer.getDestinationName() + "]";	answer.setBeanName(name);	if (answer.getConcurrentConsumers() > 1) {	if (ReplyToType.Shared == type) {	} else {	
using concurrent consumers on 

========================= camel sample_7185 =========================

protected void doStart() throws Exception {	super.doStart();	
netty consumer binding to 

nettyServerBootstrapFactory = new ClientModeTCPNettyServerBootstrapFactory();	} else {	nettyServerBootstrapFactory = new SingleTCPNettyServerBootstrapFactory();	}	} else {	nettyServerBootstrapFactory = new SingleUDPNettyServerBootstrapFactory();	}	nettyServerBootstrapFactory.init(context, configuration, pipelineFactory);	}	ServiceHelper.startServices(nettyServerBootstrapFactory);	
netty consumer bound to 

protected void doStop() throws Exception {	
netty consumer unbinding from 

protected void doStop() throws Exception {	ServiceHelper.stopService(nettyServerBootstrapFactory);	
netty consumer unbound from 

========================= camel sample_10254 =========================

public void run() {	
running scheduled timerlistener task 

public void run() {	if (!isRunAllowed()) {	
timerlistener task cannot run as its not allowed 

public void run() {	if (!isRunAllowed()) {	return;	}	for (TimerListener listener : listeners) {	try {	
invoking ontimer on 

public void run() {	if (!isRunAllowed()) {	return;	}	for (TimerListener listener : listeners) {	try {	listener.onTimer();	} catch (Throwable e) {	
error occurred during ontimer for timerlistener this exception will be ignored 

public void addTimerListener(TimerListener listener) {	listeners.add(listener);	
added timerlistener 

public void removeTimerListener(TimerListener listener) {	listeners.remove(listener);	
removed timerlistener 

protected void doStart() throws Exception {	ObjectHelper.notNull(camelContext, "camelContext", this);	executorService = camelContext.getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "ManagementLoadTask");	task = executorService.scheduleAtFixedRate(this, interval, interval, TimeUnit.MILLISECONDS);	
started scheduled timerlistener task to run with interval ms 

========================= camel sample_5157 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<CouchDbComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.couchdb.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.couchdb.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_423 =========================

protected void setUp() throws Exception {	registryPort = 30000 + new Random().nextInt(10000);	
using port 

========================= camel sample_2738 =========================

protected void doStart() throws Exception {	super.doStart();	connection = zkm.getConnection();	if (log.isDebugEnabled()) {	
connected to zookeeper cluster s 

protected void doStop() throws Exception {	super.doStop();	shuttingDown = true;	if (log.isTraceEnabled()) {	
shutting down zookeeper consumer of s 

private void initializeDataConsumer(String node) {	if (!shuttingDown) {	if (log.isDebugEnabled()) {	
initializing consumption of data on node s 

private void initializeChildListingConsumer(String node) {	if (!shuttingDown) {	if (log.isDebugEnabled()) {	
initializing child listing of node s 

public void run() {	while (isRunAllowed()) {	try {	current = operations.take();	if (log.isTraceEnabled()) {	
processing s operation 

========================= camel sample_12639 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KinesisComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-kinesis.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-kinesis.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1114 =========================

final String key = entry.getKey();	if (key.startsWith(propertyPrefix)) {	properties.put(key.substring(prefixLength), entry.getValue());	nProperties++;	} else if (camelCasePrefix != null && key.startsWith(camelCasePrefix)) {	final String propertyName = String.valueOf(Character.toLowerCase(key.charAt(prefixLength - 1))) + key.substring(prefixLength);	properties.put(propertyName, entry.getValue());	nProperties++;	}	}	
found properties in exchange 

public void getEndpointProperties(Object endpointConfiguration, Map<String, Object> properties) {	Set<String> names = null;	if (IntrospectionSupport.getProperties(endpointConfiguration, properties, null, false)) {	names = properties.keySet();	names.removeAll(componentConfigFields);	}	
found endpoint properties 

========================= camel sample_4316 =========================

public void testIrcMessages() throws Exception {	resultEndpoint = context.getEndpoint("mock:result", MockEndpoint.class);	resultEndpoint.expectedBodiesReceived(body1, body2);	resultEndpoint.assertIsSatisfied();	List<Exchange> list = resultEndpoint.getReceivedExchanges();	for (Exchange exchange : list) {	
received exchange headers 

========================= camel sample_12140 =========================

protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {	ObjectHelper.notNull(getCamelContext(), "Camel Context");	AbstractIgniteEndpoint answer = null;	URI remainingUri = new URI(URISupport.normalizeUri(remaining));	String scheme = remainingUri.getScheme();	
the scheme syntax ignite has been deprecated use ignite instead 

========================= camel sample_11296 =========================

MockEndpoint mockEndpoint = resolveMandatoryEndpoint("mock:results", MockEndpoint.class);	mockEndpoint.expectedMessageCount(1);	template.sendBody("direct:start", null);	mockEndpoint.assertIsSatisfied();	List<Exchange> list = mockEndpoint.getReceivedExchanges();	Exchange exchange = list.get(0);	assertNotNull("exchange", exchange);	Message in = exchange.getIn();	assertNotNull("in", in);	Map<String, Object> headers = in.getHeaders();	
headers 

template.sendBody("direct:start", null);	mockEndpoint.assertIsSatisfied();	List<Exchange> list = mockEndpoint.getReceivedExchanges();	Exchange exchange = list.get(0);	assertNotNull("exchange", exchange);	Message in = exchange.getIn();	assertNotNull("in", in);	Map<String, Object> headers = in.getHeaders();	checkHeaders(headers);	String body = in.getBody(String.class);	
body 

========================= camel sample_12843 =========================

public void testSuspendResume() throws Exception {	assertFalse(context.isSuspended());	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceived("A");	template.sendBody("seda:foo", "A");	assertMockEndpointsSatisfied();	
Suspending 

resetMocks();	mock.expectedMessageCount(0);	context.suspend();	Thread.sleep(100);	template.sendBody("seda:foo", "B");	mock.assertIsSatisfied(1000);	assertTrue(context.isSuspended());	assertFalse(context.getStatus().isStarted());	assertTrue(context.getStatus().isSuspended());	assertFalse(context.getStatus().isStopped());	
Resuming 

========================= camel sample_1397 =========================

public void process(Exchange exchange) throws Exception {	AsteriskAction action = exchange.getIn().getHeader(AsteriskConstants.ACTION, AsteriskAction.class);	if (action == null) {	action = endpoint.getAction();	}	ObjectHelper.notNull(action, "action");	
send action 

========================= camel sample_12906 =========================

protected void doStart() throws Exception {	boolean startScheduler = isStartScheduler();	setStartScheduler(false);	try {	super.doStart();	if (endpoint.isAutoCreate()) {	
auto creating directory 

protected void doStart() throws Exception {	boolean startScheduler = isStartScheduler();	setStartScheduler(false);	try {	super.doStart();	if (endpoint.isAutoCreate()) {	try {	connectIfNecessary();	operations.buildDirectory(endpoint.getConfiguration().getDirectory(), true);	} catch (GenericFileOperationFailedException e) {	
error auto creating directory due this exception is ignored 

protected boolean doPollDirectory(String absolutePath, String dirName, List<GenericFile<FTPFile>> fileList, int depth) {	
dopolldirectory from absolutepath dirname 

protected boolean doPollDirectory(String absolutePath, String dirName, List<GenericFile<FTPFile>> fileList, int depth) {	depth++;	dirName = FileUtil.stripTrailingSeparator(dirName);	String dir;	if (isStepwise()) {	dir = ObjectHelper.isNotEmpty(dirName) ? dirName : absolutePath;	operations.changeCurrentDirectory(dir);	} else {	dir = absolutePath;	}	
polling directory 

FTPFile file = new FTPFile();	file.setType(FTPFile.FILE_TYPE);	fileExpressionResult = evaluateFileExpression();	if (fileExpressionResult != null) {	file.setName(fileExpressionResult);	files = new ArrayList<FTPFile>(1);	files.add(file);	}	}	if (files == null || files.isEmpty()) {	
no files found in directory 

fileExpressionResult = evaluateFileExpression();	if (fileExpressionResult != null) {	file.setName(fileExpressionResult);	files = new ArrayList<FTPFile>(1);	files.add(file);	}	}	if (files == null || files.isEmpty()) {	return true;	} else {	
found in directory 

if (!canPollMore) {	return false;	}	}	} else if (file.isFile()) {	RemoteFile<FTPFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset());	if (depth >= endpoint.getMinDepth() && isValidFile(remote, false, files)) {	fileList.add(remote);	}	} else {	
ignoring unsupported remote file type 

protected boolean isMatched(GenericFile<FTPFile> file, String doneFileName, List<FTPFile> files) {	String onlyName = FileUtil.stripPath(doneFileName);	for (FTPFile f : files) {	if (f.getName().equals(onlyName)) {	return true;	}	}	
done file does not exist 

========================= camel sample_15390 =========================

Future<String> out = executor.submit(new Callable<String>() {	public String call() throws Exception {	String reply = template.requestBody("netty4:tcp: log.debug("Sent {} received {}", index, reply);	assertEquals("Bye " + index, reply);	return reply;	}	});	responses.put(index, out);	}	notify.matches(2, TimeUnit.MINUTES);	
took millis to process messages using client threads 

========================= camel sample_10192 =========================

AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzConsumerClusteredAppOne.xml");	app.start();	AbstractXmlApplicationContext app2 = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzConsumerClusteredAppTwo.xml");	app2.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMinimumMessageCount(3);	mock.expectedMessagesMatches(new ClusteringPredicate(true));	Thread.sleep(5000);	mock.assertIsSatisfied();	
the first app is going to crash now 

app.start();	AbstractXmlApplicationContext app2 = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzConsumerClusteredAppTwo.xml");	app2.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMinimumMessageCount(3);	mock.expectedMessagesMatches(new ClusteringPredicate(true));	Thread.sleep(5000);	mock.assertIsSatisfied();	IOHelper.close(app);	
crashed 

app.start();	AbstractXmlApplicationContext app2 = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzConsumerClusteredAppTwo.xml");	app2.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMinimumMessageCount(3);	mock.expectedMessagesMatches(new ClusteringPredicate(true));	Thread.sleep(5000);	mock.assertIsSatisfied();	IOHelper.close(app);	
crashed 

app.start();	AbstractXmlApplicationContext app2 = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzConsumerClusteredAppTwo.xml");	app2.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMinimumMessageCount(3);	mock.expectedMessagesMatches(new ClusteringPredicate(true));	Thread.sleep(5000);	mock.assertIsSatisfied();	IOHelper.close(app);	
crashed 

========================= camel sample_14978 =========================

public void processTimeout(javax.sip.TimeoutEvent timeoutEvent) {	if (LOG.isWarnEnabled()) {	
processtimeout received at sip publish listener 

public void processIOException(IOExceptionEvent ioExceptionEvent) {	if (LOG.isWarnEnabled()) {	
ioexceptionevent received at sip publish listener 

public void processTransactionTerminated(TransactionTerminatedEvent transactionTerminatedEvent) {	if (LOG.isWarnEnabled()) {	
processtransactionterminated received at sip publish listener 

========================= camel sample_8509 =========================

public void configureListenerContainer(AbstractMessageListenerContainer listenerContainer, JmsConsumer consumer) {	if (destinationName != null) {	listenerContainer.setDestinationName(destinationName);	
using destinationname on listenercontainer 

public void configureListenerContainer(AbstractMessageListenerContainer listenerContainer, JmsConsumer consumer) {	if (destinationName != null) {	listenerContainer.setDestinationName(destinationName);	} else if (destination != null) {	listenerContainer.setDestination(destination);	
using destination on listenercontainer 

listenerContainer.setDestinationName(destinationName);	} else if (destination != null) {	listenerContainer.setDestination(destination);	} else {	DestinationResolver resolver = getDestinationResolver();	if (resolver != null) {	listenerContainer.setDestinationResolver(resolver);	} else {	throw new IllegalArgumentException("Neither destination, destinationName or destinationResolver are specified on this endpoint!");	}	
using destinationresolver on listenercontainer 

if (resolver != null) {	listenerContainer.setDestinationResolver(resolver);	} else {	throw new IllegalArgumentException("Neither destination, destinationName or destinationResolver are specified on this endpoint!");	}	}	listenerContainer.setPubSubDomain(pubSubDomain);	String consumerName = getThreadName();	if (configuration.getTaskExecutor() != null) {	if (log.isDebugEnabled()) {	
using custom taskexecutor on listener container 

}	setContainerTaskExecutor(listenerContainer, configuration.getTaskExecutor());	if (configuration.getTaskExecutor() instanceof ExecutorService) {	consumer.setListenerContainerExecutorService((ExecutorService) configuration.getTaskExecutor(), false);	}	} else if ((listenerContainer instanceof DefaultJmsMessageListenerContainer && configuration.getDefaultTaskExecutorType() == null) || !(listenerContainer instanceof DefaultJmsMessageListenerContainer)) {	ExecutorService executor = getCamelContext().getExecutorServiceManager().newCachedThreadPool(consumer, consumerName);	setContainerTaskExecutor(listenerContainer, executor);	consumer.setListenerContainerExecutorService(executor, true);	} else {	
deferring creation of taskexecutor for listener container as per policy 

public void stop() throws Exception {	int running = runningMessageListeners.get();	if (running <= 0) {	super.stop();	} else {	
there are still running message listeners cannot stop endpoint 

public void shutdown() throws Exception {	int running = runningMessageListeners.get();	if (running <= 0) {	super.shutdown();	} else {	
there are still running message listeners cannot shutdown endpoint 

========================= camel sample_7193 =========================

try {	beforePoll(0);	return queue.take();	} catch (InterruptedException e) {	handleInterruptedException(e);	} finally {	afterPoll();	}	}	}	
consumer is not running so returning null 

try {	if (getBlockTimeout() <= 0) {	queue.put(exchange);	} else {	boolean added = queue.offer(exchange, getBlockTimeout(), TimeUnit.MILLISECONDS);	if (!added) {	throw new ExchangeTimedOutException(exchange, getBlockTimeout());	}	}	} catch (InterruptedException e) {	
put interrupted are we stopping 

protected long beforePoll(long timeout) {	if (consumer instanceof PollingConsumerPollingStrategy) {	PollingConsumerPollingStrategy strategy = (PollingConsumerPollingStrategy) consumer;	try {	timeout = strategy.beforePoll(timeout);	} catch (Exception e) {	
error occurred before polling this exception will be ignored 

protected void afterPoll() {	if (consumer instanceof PollingConsumerPollingStrategy) {	PollingConsumerPollingStrategy strategy = (PollingConsumerPollingStrategy) consumer;	try {	strategy.afterPoll();	} catch (Exception e) {	
error occurred after polling this exception will be ignored 

========================= camel sample_3979 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<NettyComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.netty4.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.netty4.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_570 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<NettyHttpComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.netty4-http.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.netty4-http.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1047 =========================

private static void run(String id) {	try {	int events = ThreadLocalRandom.current().nextInt(2, 6);	CountDownLatch contextLatch = new CountDownLatch(events);	ConsulClusterService service = new ConsulClusterService();	service.setId("node-" + id);	
http logger info service geturl 

context.addService(service);	context.addRoutePolicyFactory(ClusteredRoutePolicyFactory.forNamespace("my-ns"));	context.addRoutes(new RouteBuilder() {	public void configure() throws Exception {	from("timer:consul?delay=1s&period=1s") .routeId("route-" + id) .log("From ${routeId}") .process(e -> contextLatch.countDown());	}	});	Thread.sleep(ThreadLocalRandom.current().nextInt(500));	context.start();	contextLatch.await();	
shutting down node 

========================= camel sample_14344 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<UndertowComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.undertow.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.undertow.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_823 =========================

public void read(String body, @XQuery("/foo/@id") String foo) {	this.foo = foo;	this.body = body;	
read method called on 

========================= camel sample_16729 =========================

public void testVertxMessages() throws Exception {	resultEndpoint = context.getEndpoint(resultUri, MockEndpoint.class);	resultEndpoint.expectedBodiesReceivedInAnyOrder(body1, body2);	template.sendBody(startUri, body1);	template.sendBody(startUri, body2);	resultEndpoint.assertIsSatisfied();	List<Exchange> list = resultEndpoint.getReceivedExchanges();	for (Exchange exchange : list) {	
received exchange headers 

========================= camel sample_11516 =========================

public static SortedMap<String, Properties> findComponents(CamelContext camelContext) throws LoadPropertiesException {	ClassResolver resolver = camelContext.getClassResolver();	
finding all components using class resolver 

public static SortedMap<String, Properties> findComponents(CamelContext camelContext, Enumeration<URL> componentDescriptionIter) throws LoadPropertiesException {	SortedMap<String, Properties> map = new TreeMap<String, Properties>();	while (componentDescriptionIter != null && componentDescriptionIter.hasMoreElements()) {	URL url = componentDescriptionIter.nextElement();	
finding components in url 

public static SortedMap<String, Properties> findEips(CamelContext camelContext) throws LoadPropertiesException {	SortedMap<String, Properties> answer = new TreeMap<String, Properties>();	ClassResolver resolver = camelContext.getClassResolver();	
finding all eips using class resolver 

public static Component lookupPropertiesComponent(CamelContext camelContext, boolean autoCreate) {	PropertiesComponent answer = (PropertiesComponent) camelContext.hasComponent("properties");	if (answer == null) {	Object found = camelContext.getRegistry().lookupByName("properties");	if (found instanceof PropertiesComponent) {	answer = (PropertiesComponent) found;	camelContext.addComponent("properties", answer);	}	}	if (answer == null && autoCreate) {	
no existing propertiescomponent has been configured creating a new default propertiescomponent with name properties 

public static void resolvePropertyPlaceholders(CamelContext camelContext, Object target) throws Exception {	
resolving property placeholders for 

public static void resolvePropertyPlaceholders(CamelContext camelContext, Object target) throws Exception {	Map<String, Object> properties = new HashMap<String, Object>();	IntrospectionSupport.getProperties(target, properties, null);	Map<String, Object> changedProperties = new HashMap<String, Object>();	if (!properties.isEmpty()) {	
there are properties on 

if (value instanceof String) {	String text = (String) value;	text = camelContext.resolvePropertyPlaceholders(text);	if (text != value) {	boolean changed = IntrospectionSupport.setProperty(camelContext.getTypeConverter(), target, name, text);	if (!changed) {	throw new IllegalArgumentException("No setter to set property: " + name + " to: " + text + " on: " + target);	}	changedProperties.put(name, value);	if (LOG.isDebugEnabled()) {	
changed property from to 

========================= camel sample_4300 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<GeoCoderComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.geocoder.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.geocoder.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1102 =========================

public void onEvent(EventIterator events) {	
onevent start 

public void onEvent(EventIterator events) {	
consumer received jcr events 

public void onEvent(EventIterator events) {	RuntimeCamelException rce = null;	try {	final Exchange exchange = createExchange(events);	try {	
processor is processing exchange 

try {	processor.process(exchange);	} catch (Exception e) {	exchange.setException(e);	}	rce = exchange.getException(RuntimeCamelException.class);	} catch (Exception e) {	rce = wrapRuntimeCamelException(e);	}	if (rce != null) {	
onevent end throwing exception 

} catch (Exception e) {	exchange.setException(e);	}	rce = exchange.getException(RuntimeCamelException.class);	} catch (Exception e) {	rce = wrapRuntimeCamelException(e);	}	if (rce != null) {	throw rce;	}	
onevent end 

========================= camel sample_11453 =========================

public void process(final Exchange exchange) throws Exception {	final Object data = exchange.getIn().getBody();	final SqlParameterSource param = new ElsqlSqlMapSource(exchange, data);	final String sql = elSql.getSql(elSqlName, new SpringSqlParams(param));	
elsqlproducer using sql 

public void process(final Exchange exchange) throws Exception {	final Object data = exchange.getIn().getBody();	final SqlParameterSource param = new ElsqlSqlMapSource(exchange, data);	final String sql = elSql.getSql(elSqlName, new SpringSqlParams(param));	final SqlOutputType outputType = getEndpoint().getOutputType();	if (outputType == SqlOutputType.StreamList) {	processStreamList(exchange, sql, param);	return;	}	
jdbctemplate execute 

protected void processStreamList(final Exchange exchange, final PreparedStatementCreator statementCreator, final String preparedQuery) throws Exception {	
processstreamlist 

========================= camel sample_13194 =========================

public void testGet() throws Exception {	final com.google.api.services.drive.model.ChangeList list = requestBody("direct: List<Change> items = list.getItems();	if (!items.isEmpty()) {	Change change = items.get(0);	Long id = change.getId();	final com.google.api.services.drive.model.Change result = requestBody("direct: assertNotNull("get result", result);	
get 

public void testList() throws Exception {	final com.google.api.services.drive.model.ChangeList result = requestBody("direct: assertNotNull("list result", result);	
list 

========================= camel sample_15410 =========================

public void configure() {	
adding route from to 

========================= camel sample_6444 =========================

public void testGrowIssue() throws Exception {	StringBuilder sb = new StringBuilder(SIZE);	for (int i = 0; i < SIZE; i++) {	sb.append("X");	}	Exchange item = new DefaultExchange(context);	item.getIn().setBody(sb.toString(), String.class);	final String key = "foo";	for (int i = 0; i < SIZE; i++) {	
updating 

========================= camel sample_8909 =========================

public boolean matches(Exchange exchange) {	
matches exchange called with 

========================= camel sample_3216 =========================

} else {	endpoint = new RabbitMQEndpoint(uri, this, connectionFactory);	}	endpoint.setHostname(hostname);	endpoint.setPortNumber(portNumber);	endpoint.setExchangeName(exchangeName);	endpoint.setClientProperties(clientProperties);	endpoint.setTrustManager(trustManager);	setProperties(endpoint, params);	if (LOG.isDebugEnabled()) {	
creating rabbitmqendpoint with host and exchangename 

========================= camel sample_14128 =========================

}	}	if (found != null) {	String xml;	if (supportResolvePlaceholder) {	xml = (String) server.invoke(found, "dumpRestsAsXml", new Object[]{true}, new String[]{"boolean"});	} else {	xml = (String) server.invoke(found, "dumpRestsAsXml", null, null);	}	if (xml != null) {	
dumprestasxml 

public void renderResourceListing(RestApiResponseAdapter response, BeanConfig swaggerConfig, String contextId, String route, boolean json, boolean yaml, ClassResolver classResolver, RestConfiguration configuration) throws Exception {	
renderResourceListing 

public void renderCamelContexts(RestApiResponseAdapter response, String contextId, String contextIdPattern, boolean json, boolean yaml, RestConfiguration configuration) throws Exception {	
renderCamelContexts 

}	String allowHeaders = corsHeaders != null ? corsHeaders.get("Access-Control-Allow-Headers") : null;	if (allowHeaders == null) {	allowHeaders = RestConfiguration.CORS_ACCESS_CONTROL_ALLOW_HEADERS;	}	String maxAge = corsHeaders != null ? corsHeaders.get("Access-Control-Max-Age") : null;	if (maxAge == null) {	maxAge = RestConfiguration.CORS_ACCESS_CONTROL_MAX_AGE;	}	if (LOG.isTraceEnabled()) {	
using cors headers 

========================= camel sample_17354 =========================

protected boolean prePollCheck() throws Exception {	if (log.isTraceEnabled()) {	
prepollcheck on 

protected void postPollCheck(int polledMessages) {	if (log.isTraceEnabled()) {	
postpollcheck on 

protected void postPollCheck(int polledMessages) {	if (log.isTraceEnabled()) {	}	if (polledMessages == 0) {	if (getEndpoint().isDisconnect()) {	
postpollcheck disconnect from 

protected boolean processExchange(Exchange exchange) {	exchange.setProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC, Boolean.TRUE);	boolean isLast = exchange.getProperty(Exchange.BATCH_COMPLETE, true, Boolean.class);	if (isLast && getEndpoint().isDisconnect()) {	exchange.addOnCompletion(new SynchronizationAdapter() {	public void onDone(Exchange exchange) {	
postpollcheck disconnect from 

protected void disconnect() {	loggedIn = false;	try {	if (getOperations().isConnected()) {	if (log.isDebugEnabled()) {	
disconnecting from 

protected void disconnect() {	loggedIn = false;	try {	if (getOperations().isConnected()) {	if (log.isDebugEnabled()) {	}	getOperations().disconnect();	}	} catch (GenericFileOperationFailedException e) {	
error occurred while disconnecting from due this exception will be ignored 

protected void forceDisconnect() {	loggedIn = false;	try {	if (log.isDebugEnabled()) {	
force disconnecting from 

protected void forceDisconnect() {	loggedIn = false;	try {	if (log.isDebugEnabled()) {	}	getOperations().forceDisconnect();	} catch (GenericFileOperationFailedException e) {	
error occurred while disconnecting from due this exception will be ignored 

protected void recoverableConnectIfNecessary() throws Exception {	try {	connectIfNecessary();	} catch (Exception e) {	if (log.isDebugEnabled()) {	
could not connect to will try to recover 

protected void recoverableConnectIfNecessary() throws Exception {	try {	connectIfNecessary();	} catch (Exception e) {	if (log.isDebugEnabled()) {	}	loggedIn = false;	}	if (!loggedIn) {	
trying to recover connection to with a fresh client 

protected void connectIfNecessary() throws IOException {	boolean isConnected = false;	try {	isConnected = getOperations().sendNoop();	} catch (Exception ex) {	if (log.isDebugEnabled()) {	
exception checking connection status 

protected void connectIfNecessary() throws IOException {	boolean isConnected = false;	try {	isConnected = getOperations().sendNoop();	} catch (Exception ex) {	if (log.isDebugEnabled()) {	}	}	if (!loggedIn || !isConnected) {	if (log.isDebugEnabled()) {	
not connected logged in connecting to 

isConnected = getOperations().sendNoop();	} catch (Exception ex) {	if (log.isDebugEnabled()) {	}	}	if (!loggedIn || !isConnected) {	if (log.isDebugEnabled()) {	}	loggedIn = getOperations().connect((RemoteFileConfiguration) endpoint.getConfiguration());	if (loggedIn) {	
connected and logged in to 

protected boolean doSafePollSubDirectory(String absolutePath, String dirName, List<GenericFile<T>> fileList, int depth) {	try {	
polling sub directory from 

protected boolean doSafePollSubDirectory(String absolutePath, String dirName, List<GenericFile<T>> fileList, int depth) {	try {	return doPollDirectory(absolutePath, dirName, fileList, depth);	} catch (Exception e) {	
caught exception 

protected boolean doSafePollSubDirectory(String absolutePath, String dirName, List<GenericFile<T>> fileList, int depth) {	try {	return doPollDirectory(absolutePath, dirName, fileList, depth);	} catch (Exception e) {	if (ignoreCannotRetrieveFile(absolutePath, null, e)) {	
ignoring file error for 

protected boolean doSafePollSubDirectory(String absolutePath, String dirName, List<GenericFile<T>> fileList, int depth) {	try {	return doPollDirectory(absolutePath, dirName, fileList, depth);	} catch (Exception e) {	if (ignoreCannotRetrieveFile(absolutePath, null, e)) {	return true;	} else {	
not ignoring file error for 

========================= camel sample_15369 =========================

public void testThrottlingRoutePolicyStartWithAlwaysOpenOn() throws Exception {	
sending some messages 

========================= camel sample_2112 =========================

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/SplitTokenizeTest.java"));	MethodSource<JavaClassSource> method = CamelJavaParserHelper.findConfigureMethod(clazz);	List<CamelEndpointDetails> details = new ArrayList<>();	RouteBuilderParser.parseRouteBuilderEndpoints(clazz, "src/test/java", "org/apache/camel/parser/SplitTokenizeTest.java", details);	LOG.info("{}", details);	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	
consumer 

for (ParserResult result : list) {	}	Assert.assertEquals("direct:a", list.get(0).getElement());	Assert.assertEquals("direct:b", list.get(1).getElement());	Assert.assertEquals("direct:c", list.get(2).getElement());	Assert.assertEquals("direct:d", list.get(3).getElement());	Assert.assertEquals("direct:e", list.get(4).getElement());	Assert.assertEquals("direct:f", list.get(5).getElement());	list = CamelJavaParserHelper.parseCamelProducerUris(method, true, true);	for (ParserResult result : list) {	
producer 

========================= camel sample_209 =========================

public void process(Exchange exchange) throws Exception {	InputStream signature = exchange.getIn().getHeader(CryptoCmsConstants.CAMEL_CRYPTO_CMS_SIGNED_DATA, InputStream.class);	if (signature == null) {	
no signed data found in header assuming signed data contained in message body 

public void process(Exchange exchange) throws Exception {	InputStream signature = exchange.getIn().getHeader(CryptoCmsConstants.CAMEL_CRYPTO_CMS_SIGNED_DATA, InputStream.class);	if (signature == null) {	super.process(exchange);	} else {	
signed data header found 

try {	sp = new CMSSignedDataParser(new JcaDigestCalculatorProviderBuilder().setProvider(BouncyCastleProvider.PROVIDER_NAME).build(), new CMSTypedStream(is), signature);	} catch (CMSException e) {	throw new CryptoCmsFormatException(getFormatErrorMessage(), e);	}	try {	sp.getSignedContent().drain();	} catch (NullPointerException e) {	throw getContentMissingException(e);	}	
signed data found 

========================= camel sample_11541 =========================

public Class<?> resolveClass(String name) {	
resolve class 

public Class<?> resolveClass(String name) {	name = ObjectHelper.normalizeClassName(name);	if (ObjectHelper.isEmpty(name)) {	return null;	}	Class<?> clazz = ObjectHelper.loadSimpleType(name);	if (clazz == null) {	clazz = doLoadClass(name, bundleContext.getBundle());	if (LOG.isTraceEnabled()) {	
loading class using bundlecontext 

}	Class<?> clazz = ObjectHelper.loadSimpleType(name);	if (clazz == null) {	clazz = doLoadClass(name, bundleContext.getBundle());	if (LOG.isTraceEnabled()) {	}	}	if (clazz == null && camelContext != null) {	clazz = super.loadClass(name, camelContext.getApplicationContextClassLoader());	if (LOG.isTraceEnabled()) {	
loading class using camelcontext 

try {	String resolvedName = resolveUriPath(uri);	Enumeration<URL> e = bundleContext.getBundle().getResources(resolvedName);	while (e != null && e.hasMoreElements()) {	answer.add(e.nextElement());	}	String path = FileUtil.onlyPath(uri);	String name = FileUtil.stripPath(uri);	if (path != null && name != null) {	for (Bundle bundle : bundleContext.getBundles()) {	
finding all entries in path with pattern 

protected Class<?> doLoadClass(String name, Bundle loader) {	ObjectHelper.notEmpty(name, "name");	Class<?> answer = null;	if (loader != null) {	try {	answer = loader.loadClass(name);	} catch (ClassNotFoundException e) {	if (LOG.isTraceEnabled()) {	
cannot load class using classloader this exception will be ignored 

========================= camel sample_13086 =========================

protected abstract JettyHttpEndpoint createEndpoint(URI endpointUri, URI httpUri) throws URISyntaxException;	public void connect(HttpConsumer consumer) throws Exception {	JettyHttpEndpoint endpoint = (JettyHttpEndpoint)consumer.getEndpoint();	String connectorKey = getConnectorKey(endpoint);	synchronized (CONNECTORS) {	ConnectorRef connectorRef = CONNECTORS.get(connectorKey);	if (connectorRef == null) {	Server server = createServer();	Connector connector = getConnector(server, endpoint);	if ("localhost".equalsIgnoreCase(endpoint.getHttpUri().getHost())) {	
you use localhost interface it means that no external connections will be available don t you want to use instead all network interfaces 

CONNECTORS.put(connectorKey, connectorRef);	} else {	if (endpoint.getHandlers() != null && !endpoint.getHandlers().isEmpty()) {	List<Handler> existingHandlers = new ArrayList<>();	if (connectorRef.server.getHandlers() != null && connectorRef.server.getHandlers().length > 0) {	existingHandlers = Arrays.asList(connectorRef.server.getHandlers());	}	List<Handler> newHandlers = new ArrayList<>(endpoint.getHandlers());	boolean changed = !existingHandlers.containsAll(newHandlers) && !newHandlers.containsAll(existingHandlers);	if (changed) {	
restarting jetty server due to adding new jetty handlers 

private void enableJmx(Server server) {	MBeanContainer containerToRegister = getMbContainer();	if (containerToRegister != null) {	
jetty jmx extensions is enabled 

}	filterHolder.setFilter(new CamelFilterWrapper(filter));	String pathSpec = endpoint.getPath();	if (pathSpec == null || "".equals(pathSpec)) {	pathSpec = "/";	}	if (endpoint.isMatchOnUriPrefix()) {	pathSpec = pathSpec.endsWith("/") ? pathSpec + "*" : pathSpec + "/*";	}	addFilter(context, filterHolder, pathSpec);	
using multipart filter implementation for path 

public CamelHttpClient createHttpClient(JettyHttpEndpoint endpoint, Integer minThreads, Integer maxThreads, SSLContextParameters ssl) throws Exception {	SslContextFactory sslContextFactory = createSslContextFactory(ssl);	HttpClientTransport transport = createHttpClientTransport(maxThreads);	CamelHttpClient httpClient = createCamelHttpClient(transport, sslContextFactory);	CamelContext context = endpoint.getCamelContext();	if (context != null && ObjectHelper.isNotEmpty(context.getProperty("http.proxyHost")) && ObjectHelper.isNotEmpty(context.getProperty("http.proxyPort"))) {	String host = context.getProperty("http.proxyHost");	int port = Integer.parseInt(context.getProperty("http.proxyPort"));	
camelcontext properties http proxyhost and http proxyport detected using http proxy host port 

CamelHttpClient httpClient = createCamelHttpClient(transport, sslContextFactory);	CamelContext context = endpoint.getCamelContext();	if (context != null && ObjectHelper.isNotEmpty(context.getProperty("http.proxyHost")) && ObjectHelper.isNotEmpty(context.getProperty("http.proxyPort"))) {	String host = context.getProperty("http.proxyHost");	int port = Integer.parseInt(context.getProperty("http.proxyPort"));	httpClient.setProxy(host, port);	}	if (ObjectHelper.isNotEmpty(endpoint.getProxyHost()) && endpoint.getProxyPort() > 0) {	String host = endpoint.getProxyHost();	int port = endpoint.getProxyPort();	
proxyhost and proxyport options detected using http proxy host port 

}	QueuedThreadPool qtp = new QueuedThreadPool();	qtp.setMinThreads(minThreads.intValue());	qtp.setMaxThreads(maxThreads.intValue());	qtp.setDaemon(true);	qtp.setName("CamelJettyClient(" + ObjectHelper.getIdentityHashCode(httpClient) + ")");	httpClient.setThreadPoolOrExecutor(qtp);	}	if (LOG.isDebugEnabled()) {	if (minThreads != null) {	
created httpclient with thread pool 

QueuedThreadPool qtp = new QueuedThreadPool();	qtp.setMinThreads(minThreads.intValue());	qtp.setMaxThreads(maxThreads.intValue());	qtp.setDaemon(true);	qtp.setName("CamelJettyClient(" + ObjectHelper.getIdentityHashCode(httpClient) + ")");	httpClient.setThreadPoolOrExecutor(qtp);	}	if (LOG.isDebugEnabled()) {	if (minThreads != null) {	} else {	
created httpclient with default thread pool size 

MBeanServer mbs = null;	final ManagementStrategy mStrategy = this.getCamelContext().getManagementStrategy();	final ManagementAgent mAgent = mStrategy.getManagementAgent();	if (mAgent != null) {	mbs = mAgent.getMBeanServer();	}	if (mbs != null) {	mbContainer = new MBeanContainer(mbs);	startMbContainer();	} else {	
jmx disabled in camelcontext jetty jmx extensions will remain disabled 

protected void startMbContainer() {	if (mbContainer != null && Server.getVersion().startsWith("8")) {	try {	boolean b = (Boolean)mbContainer.getClass().getMethod("isStarted").invoke(mbContainer);	if (b) {	mbContainer.getClass().getMethod("start").invoke(mbContainer);	mbContainer.getClass().getMethod("addBean", Object.class).invoke(mbContainer, mbContainer);	}	} catch (Throwable e) {	
could not start jetty mbeancontainer jetty jmx extensions will remain disabled 

========================= camel sample_17495 =========================

protected void doStart() throws Exception {	super.doStart();	this.queue = getAtomixEndpoint() .getAtomix() .getQueue( resourceName, new DistributedQueue.Config(getAtomixEndpoint().getConfiguration().getResourceOptions(resourceName)), new DistributedQueue.Options(getAtomixEndpoint().getConfiguration().getResourceConfig(resourceName))) .join();	
subscribe to events for queue 

========================= camel sample_10350 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	errorHandler(defaultErrorHandler() .maximumRedeliveries(5).redeliveryDelay(10));	from("seda:start") .to("log:before") .to("mock:before") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	
processing at attempt 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	errorHandler(defaultErrorHandler() .maximumRedeliveries(5).redeliveryDelay(10));	from("seda:start") .to("log:before") .to("mock:before") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String body = exchange.getIn().getBody(String.class);	if (body.contains("World")) {	if (++attempt <= 2) {	
processing failed will thrown an exception 

errorHandler(defaultErrorHandler() .maximumRedeliveries(5).redeliveryDelay(10));	from("seda:start") .to("log:before") .to("mock:before") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String body = exchange.getIn().getBody(String.class);	if (body.contains("World")) {	if (++attempt <= 2) {	throw new IllegalArgumentException("Damn");	}	}	exchange.getIn().setBody("Hello " + body);	
processing at attempt complete 

========================= camel sample_2329 =========================

ReceiveMessageRequest request = new ReceiveMessageRequest(getQueueUrl());	request.setMaxNumberOfMessages(getMaxMessagesPerPoll() > 0 ? getMaxMessagesPerPoll() : null);	request.setVisibilityTimeout(getConfiguration().getVisibilityTimeout() != null ? getConfiguration().getVisibilityTimeout() : null);	request.setWaitTimeSeconds(getConfiguration().getWaitTimeSeconds() != null ? getConfiguration().getWaitTimeSeconds() : null);	if (attributeNames != null) {	request.setAttributeNames(attributeNames);	}	if (messageAttributeNames != null) {	request.setMessageAttributeNames(messageAttributeNames);	}	
receiving messages with request 

if (attributeNames != null) {	request.setAttributeNames(attributeNames);	}	if (messageAttributeNames != null) {	request.setMessageAttributeNames(messageAttributeNames);	}	ReceiveMessageResult messageResult = null;	try {	messageResult = getClient().receiveMessage(request);	} catch (QueueDoesNotExistException e) {	
queue does not exist recreating now 

request.setMessageAttributeNames(messageAttributeNames);	}	ReceiveMessageResult messageResult = null;	try {	messageResult = getClient().receiveMessage(request);	} catch (QueueDoesNotExistException e) {	reConnectToQueue();	messageResult = getClient().receiveMessage(request);	}	if (LOG.isTraceEnabled()) {	
received messages 

public void reConnectToQueue() {	try {	getEndpoint().createQueue(getClient());	} catch (QueueDeletedRecentlyException qdr) {	
queue recently deleted will retry in seconds 

public void reConnectToQueue() {	try {	getEndpoint().createQueue(getClient());	} catch (QueueDeletedRecentlyException qdr) {	try {	Thread.sleep(30000);	getEndpoint().createQueue(getClient());	} catch (Exception e) {	
failed to retry queue connection 

public void reConnectToQueue() {	try {	getEndpoint().createQueue(getClient());	} catch (QueueDeletedRecentlyException qdr) {	try {	Thread.sleep(30000);	getEndpoint().createQueue(getClient());	} catch (Exception e) {	}	} catch (Exception e) {	
could not connect to queue in amazon 

protected Queue<Exchange> createExchanges(List<Message> messages) {	if (LOG.isTraceEnabled()) {	
received messages in this poll 

exchange.setProperty(Exchange.BATCH_INDEX, index);	exchange.setProperty(Exchange.BATCH_SIZE, total);	exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);	pendingExchanges = total - index - 1;	Integer visibilityTimeout = getConfiguration().getVisibilityTimeout();	if (this.scheduledExecutor != null && visibilityTimeout != null && (visibilityTimeout.intValue() / 2) > 0) {	int delay = visibilityTimeout.intValue() / 2;	int period = visibilityTimeout.intValue();	int repeatSeconds = Double.valueOf(visibilityTimeout.doubleValue() * 1.5).intValue();	if (LOG.isDebugEnabled()) {	
scheduled timeoutextender task to start after delay and run with period repeat seconds to extend exchangeid 

}	final ScheduledFuture<?> scheduledFuture = this.scheduledExecutor.scheduleAtFixedRate( new TimeoutExtender(exchange, repeatSeconds), delay, period, TimeUnit.SECONDS);	exchange.addOnCompletion(new Synchronization() {	public void onComplete(Exchange exchange) {	cancelExtender(exchange);	}	public void onFailure(Exchange exchange) {	cancelExtender(exchange);	}	private void cancelExtender(Exchange exchange) {	
processing done so cancelling timeoutextender task for exchangeid 

public void onComplete(Exchange exchange) {	processCommit(exchange);	}	public void onFailure(Exchange exchange) {	processRollback(exchange);	}	public String toString() {	return "SqsConsumerOnCompletion";	}	});	
processing exchange 

}	public void onFailure(Exchange exchange) {	processRollback(exchange);	}	public String toString() {	return "SqsConsumerOnCompletion";	}	});	getAsyncProcessor().process(exchange, new AsyncCallback() {	public void done(boolean doneSync) {	
processing exchange done 

protected void processCommit(Exchange exchange) {	try {	if (shouldDelete(exchange)) {	String receiptHandle = exchange.getIn().getHeader(SqsConstants.RECEIPT_HANDLE, String.class);	DeleteMessageRequest deleteRequest = new DeleteMessageRequest(getQueueUrl(), receiptHandle);	
deleting message with receipt handle 

protected void processCommit(Exchange exchange) {	try {	if (shouldDelete(exchange)) {	String receiptHandle = exchange.getIn().getHeader(SqsConstants.RECEIPT_HANDLE, String.class);	DeleteMessageRequest deleteRequest = new DeleteMessageRequest(getQueueUrl(), receiptHandle);	getClient().deleteMessage(deleteRequest);	
deleted message with receipt handle 

public void run() {	ChangeMessageVisibilityRequest request = new ChangeMessageVisibilityRequest(getQueueUrl(), exchange.getIn().getHeader(SqsConstants.RECEIPT_HANDLE, String.class), repeatSeconds);	try {	
extending visibility window by seconds for exchange 

public void run() {	ChangeMessageVisibilityRequest request = new ChangeMessageVisibilityRequest(getQueueUrl(), exchange.getIn().getHeader(SqsConstants.RECEIPT_HANDLE, String.class), repeatSeconds);	try {	getEndpoint().getClient().changeMessageVisibility(request);	
extended visibility window by seconds for exchange 

public void run() {	ChangeMessageVisibilityRequest request = new ChangeMessageVisibilityRequest(getQueueUrl(), exchange.getIn().getHeader(SqsConstants.RECEIPT_HANDLE, String.class), repeatSeconds);	try {	getEndpoint().getClient().changeMessageVisibility(request);	} catch (ReceiptHandleIsInvalidException e) {	} catch (MessageNotInflightException e) {	} catch (Exception e) {	
extending visibility window failed for exchange will not attempt to extend visibility further this exception will be ignored 

========================= camel sample_8724 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<SyslogDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.syslog.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.syslog.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_462 =========================

private boolean isKey(ResultSet resultSet) {	Row row = resultSet.one();	if (row == null) {	
no row to check key 

private boolean isKey(ResultSet resultSet) {	Row row = resultSet.one();	if (row == null) {	return false;	} else {	
row with columns to check key 

protected void initInsertStatement() {	Insert insert = generateInsert(table, pkColumns, true, ttl);	insert = applyConsistencyLevel(insert, writeConsistencyLevel);	
generated insert 

public boolean add(K key) {	Object[] idValues = getPKValues(key);	
inserting key 

protected void initSelectStatement() {	Select select = generateSelect(table, pkColumns, pkColumns);	select = applyConsistencyLevel(select, readConsistencyLevel);	
generated select 

public boolean contains(K key) {	Object[] idValues = getPKValues(key);	
checking key 

protected void initDeleteStatement() {	Delete delete = generateDelete(table, pkColumns, true);	delete = applyConsistencyLevel(delete, writeConsistencyLevel);	
generated delete 

public boolean remove(K key) {	Object[] idValues = getPKValues(key);	
deleting key 

protected void initClearStatement() {	Truncate truncate = generateTruncate(table);	truncate = applyConsistencyLevel(truncate, writeConsistencyLevel);	
generated truncate for clear operation 

public void clear() {	
clear table 

========================= camel sample_15447 =========================

public void messageReceived(ChannelHandlerContext ctx, MessageEvent messageEvent) throws Exception {	HttpRequest request = (HttpRequest) messageEvent.getMessage();	
message received 

public void messageReceived(ChannelHandlerContext ctx, MessageEvent messageEvent) throws Exception {	HttpRequest request = (HttpRequest) messageEvent.getMessage();	if (consumer.isSuspended()) {	
consumer suspended cannot service request 

boolean inRole = true;	if (principal != null) {	subject = authenticate(security.getSecurityAuthenticator(), security.getLoginDeniedLoggingLevel(), principal);	if (subject != null) {	String userRoles = security.getSecurityAuthenticator().getUserRoles(subject);	inRole = matchesRoles(roles, userRoles);	}	}	if (principal == null || subject == null || !inRole) {	if (principal == null) {	
http basic auth required for resource 

if (principal != null) {	subject = authenticate(security.getSecurityAuthenticator(), security.getLoginDeniedLoggingLevel(), principal);	if (subject != null) {	String userRoles = security.getSecurityAuthenticator().getUserRoles(subject);	inRole = matchesRoles(roles, userRoles);	}	}	if (principal == null || subject == null || !inRole) {	if (principal == null) {	} else if (subject == null) {	
http basic auth not authorized for username 

subject = authenticate(security.getSecurityAuthenticator(), security.getLoginDeniedLoggingLevel(), principal);	if (subject != null) {	String userRoles = security.getSecurityAuthenticator().getUserRoles(subject);	inRole = matchesRoles(roles, userRoles);	}	}	if (principal == null || subject == null || !inRole) {	if (principal == null) {	} else if (subject == null) {	} else {	
http basic auth not in role for username 

}	HttpResponse response = new DefaultHttpResponse(HTTP_1_1, UNAUTHORIZED);	response.headers().set("WWW-Authenticate", "Basic realm=\"" + security.getRealm() + "\"");	response.headers().set(Exchange.CONTENT_TYPE, "text/plain");	response.headers().set(Exchange.CONTENT_LENGTH, 0);	response.setContent(ChannelBuffers.copiedBuffer(new byte[]{}));	messageEvent.getChannel().write(response).syncUninterruptibly();	messageEvent.getChannel().close();	return;	} else {	
http basic auth authorized for username 

String constraint = ObjectHelper.before(auth, " ");	if (constraint != null) {	if ("Basic".equalsIgnoreCase(constraint.trim())) {	String decoded = ObjectHelper.after(auth, " ");	ChannelBuffer buf = ChannelBuffers.copiedBuffer(decoded.getBytes());	ChannelBuffer out = Base64.decode(buf);	String userAndPw = out.toString(Charset.defaultCharset());	String username = ObjectHelper.before(userAndPw, ":");	String password = ObjectHelper.after(userAndPw, ":");	HttpPrincipal principal = new HttpPrincipal(username, password);	
extracted basic auth principal from http header 

public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent exceptionEvent) throws Exception {	if (consumer.isRunAllowed()) {	if (exceptionEvent.getCause() instanceof ClosedChannelException) {	
channel already closed ignoring this exception 

public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent exceptionEvent) throws Exception {	if (consumer.isRunAllowed()) {	if (exceptionEvent.getCause() instanceof ClosedChannelException) {	} else {	
closing channel as an exception was thrown from netty 

========================= camel sample_8374 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<Base64DataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.base64.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.base64.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_1155 =========================

}	if (close == null) {	close = exchange.getProperty(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);	}	boolean disconnect = consumer.getConfiguration().isDisconnect();	if (close != null) {	disconnect = close;	}	if (disconnect) {	if (LOG.isTraceEnabled()) {	
closing channel when complete at address 

========================= camel sample_6690 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<Olingo2Component> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.olingo2.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.olingo2.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_931 =========================

public Thread newThread(Runnable runnable) {	String threadName = ThreadHelper.resolveThreadName(pattern, name);	Thread answer = new Thread(runnable, threadName);	answer.setDaemon(daemon);	
created thread 

========================= camel sample_4357 =========================

public void testMqttDuplicatesAfterBrokerRestartWithoutClientID() throws Exception {	brokerService.stop();	brokerService.waitUntilStopped();	
restarting broker 

public void testMqttDuplicatesAfterBrokerRestartWithoutClientID() throws Exception {	brokerService.stop();	brokerService.waitUntilStopped();	brokerService = new BrokerService();	brokerService.setPersistent(false);	brokerService.setAdvisorySupport(false);	brokerService.addConnector(MQTTTestSupport.getConnection() + "?trace=true");	brokerService.start();	brokerService.waitUntilStarted();	
broker restarted 

public void testMqttDuplicatesAfterBrokerRestartWithClientID() throws Exception {	brokerService.stop();	brokerService.waitUntilStopped();	
restarting broker 

public void testMqttDuplicatesAfterBrokerRestartWithClientID() throws Exception {	brokerService.stop();	brokerService.waitUntilStopped();	brokerService = new BrokerService();	brokerService.setPersistent(false);	brokerService.setAdvisorySupport(false);	brokerService.addConnector(MQTTTestSupport.getConnection() + "?trace=true");	brokerService.start();	brokerService.waitUntilStarted();	
broker restarted 

========================= camel sample_16841 =========================

Language language = assertResolveLanguage(getLanguageName());	Expression expression = language.createExpression(expressionText);	assertNotNull(expression, "No Expression could be created for text: " + expressionText + " language: " + language);	Object value;	if (expectedValue != null) {	value = expression.evaluate(exchange, expectedValue.getClass());	} else {	value = expression.evaluate(exchange, Object.class);	}	if (log.isDebugEnabled()) {	
evaluated expression on exchange result 

========================= camel sample_11687 =========================

public synchronized boolean setConfigMap(ConfigMap map, boolean insert) {	if (insert && currentMap != null) {	
current map should have been null 

public synchronized boolean setConfigMap(ConfigMap map, boolean insert) {	if (insert && currentMap != null) {	return false;	}	if (!insert && currentMap == null) {	
current map should not have been null 

if (insert && currentMap != null) {	return false;	}	if (!insert && currentMap == null) {	return false;	}	String version = map.getMetadata() != null ? map.getMetadata().getResourceVersion() : null;	if (version != null) {	long versionLong = Long.parseLong(version);	if (versionLong != versionCounter) {	
current resource version is while the update is related to version 

========================= camel sample_13205 =========================

ObjectHelper.notNull(camelContext, "CamelContext");	ObjectHelper.notEmpty("groupName", groupName);	String path = getCamelClusterPath(groupName);	this.groupListener = new ZookeeperGroupListenerSupport(path, route.getEndpoint(), onLockOwned(), onDisconnected());	this.groupListener.setCamelContext(camelContext);	this.groupListener.setCurator(curator);	this.groupListener.setMaximumConnectionTimeout(maximumConnectionTimeout);	this.groupListener.setZooKeeperUrl(zooKeeperUrl);	this.groupListener.setZooKeeperPassword(zooKeeperPassword);	ServiceHelper.startService(groupListener);	
attempting to become master for endpoint in with singletonid 

protected Runnable onLockOwned() {	return () -> {	if (masterConsumer.compareAndSet(false, true)) {	try {	
elected as master starting consumer 

protected Runnable onLockOwned() {	return () -> {	if (masterConsumer.compareAndSet(false, true)) {	try {	startConsumer(route.getConsumer());	thisNodeState = createNodeState();	thisNodeState.setStarted(true);	groupListener.updateState(thisNodeState);	} catch (Exception e) {	
failed to start master consumer for 

protected Runnable onLockOwned() {	return () -> {	if (masterConsumer.compareAndSet(false, true)) {	try {	startConsumer(route.getConsumer());	thisNodeState = createNodeState();	thisNodeState.setStarted(true);	groupListener.updateState(thisNodeState);	} catch (Exception e) {	}	
elected as master consumer started 

protected Runnable onDisconnected() {	return () -> {	masterConsumer.set(false);	try {	stopConsumer(route.getConsumer());	} catch (Exception e) {	
failed to stop master consumer 

========================= camel sample_9709 =========================

private AuthCmd executeAuthRequest(DockerClient client, Message message) {	
executing docker auth request 

private InfoCmd executeInfoRequest(DockerClient client, Message message) {	
executing docker info request 

private PingCmd executePingRequest(DockerClient client, Message message) {	
executing docker ping request 

private VersionCmd executeVersionRequest(DockerClient client, Message message) {	
executing docker version request 

private CreateImageCmd executeCreateImageRequest(DockerClient client, Message message) {	
executing docker create image request 

private InspectImageCmd executeInspectImageRequest(DockerClient client, Message message) {	
executing docker inspect image request 

private ListImagesCmd executeListImagesRequest(DockerClient client, Message message) {	
executing docker images list request 

private RemoveImageCmd executeRemoveImageRequest(DockerClient client, Message message) {	
executing docker remove image request 

private SearchImagesCmd executeSearchImageRequest(DockerClient client, Message message) {	
executing docker search image request 

private TagImageCmd executeTagImageRequest(DockerClient client, Message message) {	
executing docker tag image request 

private CommitCmd executeCommitContainerRequest(DockerClient client, Message message) throws DockerException {	
executing docker commit container request 

private CopyFileFromContainerCmd executeCopyFileContainerRequest(DockerClient client, Message message) {	
executing docker copy file folder container request 

private CreateContainerCmd executeCreateContainerRequest(DockerClient client, Message message) {	
executing docker create container request 

private ContainerDiffCmd executeDiffContainerRequest(DockerClient client, Message message) {	
executing docker diff container request 

private InspectContainerCmd executeInspectContainerRequest(DockerClient client, Message message) {	
executing docker inspect container request 

private KillContainerCmd executeKillContainerRequest(DockerClient client, Message message) {	
executing docker kill container request 

private ListContainersCmd executeListContainersRequest(DockerClient client, Message message) {	
executing docker list container request 

private PauseContainerCmd executePauseContainerRequest(DockerClient client, Message message) {	
executing docker pause container request 

private RemoveContainerCmd executeRemoveContainerRequest(DockerClient client, Message message) {	
executing docker remove container request 

private RestartContainerCmd executeRestartContainerRequest(DockerClient client, Message message) throws DockerException {	
executing docker restart container request 

private StartContainerCmd executeStartContainerRequest(DockerClient client, Message message) {	
executing docker start container request 

private StopContainerCmd executeStopContainerRequest(DockerClient client, Message message) {	
executing docker kill container request 

private TopContainerCmd executeTopContainerRequest(DockerClient client, Message message) {	
executing docker top container request 

private UnpauseContainerCmd executeUnpauseContainerRequest(DockerClient client, Message message) {	
executing docker unpause container request 

private ExecCreateCmd executeExecCreateRequest(DockerClient client, Message message) {	
executing docker exec create request 

========================= camel sample_6556 =========================

protected void debugBefore(Exchange exchange, Processor processor, ProcessorDefinition<?> definition, String id, String shortName) {	
before with body 

========================= camel sample_11668 =========================

public HeadersMapFactory resolve(CamelContext context) {	Class<?> type = null;	try {	type = findFactory("headers-map-factory", context);	} catch (Exception e) {	}	if (type != null) {	if (LOG.isDebugEnabled()) {	
found headersmapfactory via headers map factory 

Class<?> type = null;	try {	type = findFactory("headers-map-factory", context);	} catch (Exception e) {	}	if (type != null) {	if (LOG.isDebugEnabled()) {	}	if (HeadersMapFactory.class.isAssignableFrom(type)) {	HeadersMapFactory answer = (HeadersMapFactory) context.getInjector().newInstance(type);	
detected and using custom headersmapfactory 

if (type != null) {	if (LOG.isDebugEnabled()) {	}	if (HeadersMapFactory.class.isAssignableFrom(type)) {	HeadersMapFactory answer = (HeadersMapFactory) context.getInjector().newInstance(type);	return answer;	} else {	throw new IllegalArgumentException("Type is not a HeadersMapFactory implementation. Found: " + type.getName());	}	}	
creating default headersmapfactory 

========================= camel sample_4091 =========================

result.whenAnyExchangeReceived(new Processor() {	public void process(Exchange exchange) throws Exception {	String msg = exchange.getIn().getBody(String.class);	exchange.setException(new ThrottlingException(msg));	}	});	sendMessage("Message One");	sendMessage("Message Two");	final ServiceSupport consumer = (ServiceSupport) context.getRoute("foo").getConsumer();	await().atMost(2, TimeUnit.SECONDS).until(consumer::isSuspended);	
sending message three 

sendMessage("Message Two");	final ServiceSupport consumer = (ServiceSupport) context.getRoute("foo").getConsumer();	await().atMost(2, TimeUnit.SECONDS).until(consumer::isSuspended);	sendMessage("Message Three");	assertMockEndpointsSatisfied();	result.reset();	result.expectedMessageCount(1);	bodies = Arrays.asList("Message Four");	result.expectedBodiesReceivedInAnyOrder(bodies);	await().atMost(2, TimeUnit.SECONDS).until(consumer::isStarted);	
sending message four 

protected void sendMessage(String bodyText) {	try {	template.sendBody(url, bodyText);	} catch (Exception e) {	
error sending 

========================= camel sample_1769 =========================

public void execute(Exchange exchange) throws SmppException {	DataSm dataSm = createDataSm(exchange);	if (log.isDebugEnabled()) {	
sending a data short message for exchange id 

DataSm dataSm = createDataSm(exchange);	if (log.isDebugEnabled()) {	}	DataSmResult result;	try {	result = session.dataShortMessage( dataSm.getServiceType(), TypeOfNumber.valueOf(dataSm.getSourceAddrTon()), NumberingPlanIndicator.valueOf(dataSm.getSourceAddrNpi()), dataSm.getSourceAddr(), TypeOfNumber.valueOf(dataSm.getDestAddrTon()), NumberingPlanIndicator.valueOf(dataSm.getDestAddrNpi()), dataSm.getDestAddress(), new ESMClass(dataSm.getEsmClass()), new RegisteredDelivery(dataSm.getRegisteredDelivery()), DataCodings.newInstance(dataSm.getDataCoding()), dataSm.getOptionalParameters());	} catch (Exception e) {	throw new SmppException(e);	}	if (log.isDebugEnabled()) {	
sent a data short message for exchange id and message id 

========================= camel sample_16904 =========================

public String say(String name) {	
invoking say method with 

========================= camel sample_6872 =========================

public void notification(int processId, String channel, String payload) {	if (LOG.isDebugEnabled()) {	
notification processid channel payload 

========================= camel sample_12463 =========================

public void testFetcher() throws Exception {	final Account result = requestBody("direct: assertNotNull("fetcher result not null", result);	assertNotNull("fetcher result sid not null", result.getSid());	
fetcher 

public void testFetcherWithPathSid() throws Exception {	TwilioConfiguration configuration = ((TwilioComponent) context().getComponent("twilio")) .getConfiguration();	final Account result = requestBodyAndHeaders("direct: headers("CamelTwilioPathSid", configuration.getAccountSid()));	assertNotNull("fetcher result not null", result);	assertNotNull("fetcher result sid not null", result.getSid());	
fetcher 

public void testReader() throws Exception {	final ResourceSet<Account> result = requestBody("direct: assertNotNull("reader result not null", result);	result.forEach(account -> {	assertNotNull("reader result account not null", account);	
reader 

public void testReaderWithStatusActive() throws Exception {	final ResourceSet<Account> result = requestBodyAndHeaders("direct: headers("CamelTwilioStatus", "active"));	assertNotNull("reader result not null", result);	result.forEach(account -> {	assertEquals("reader result account active", Account.Status.ACTIVE, account.getStatus());	
reader 

========================= camel sample_16420 =========================

protected void doStop() throws Exception {	super.doStop();	
stopping kubernetes nodes consumer 

========================= camel sample_13272 =========================

public <T> T doInProducer(Endpoint endpoint, Exchange exchange, ExchangePattern pattern, ProducerCallback<T> callback) {	T answer = null;	Producer producer = doGetProducer(endpoint, true);	if (producer == null) {	if (isStopped()) {	
ignoring exchange sent after processor is stopped 

if (exchange != null) {	exchange.setException(e);	}	} finally {	if (producer instanceof ServicePoolAware) {	pool.release(endpoint, producer);	} else if (!producer.isSingleton()) {	try {	ServiceHelper.stopAndShutdownService(producer);	} catch (Exception e) {	
error stopping shutting down producer 

public boolean doInAsyncProducer(final Endpoint endpoint, final Exchange exchange, final ExchangePattern pattern, final AsyncCallback callback, final AsyncProducerCallback producerCallback) {	Producer target;	try {	target = doGetProducer(endpoint, true);	if (target == null) {	if (isStopped()) {	
ignoring exchange sent after processor is stopped 

if (eventNotifierEnabled && watch != null) {	long timeTaken = watch.taken();	EventHelper.notifyExchangeSent(exchange.getContext(), exchange, endpoint, timeTaken);	}	if (producer instanceof ServicePoolAware) {	pool.release(endpoint, producer);	} else if (!producer.isSingleton()) {	try {	ServiceHelper.stopAndShutdownService(producer);	} catch (Exception e) {	
error stopping shutting down producer 

boolean add = answer.isSingleton() || answer instanceof ServicePoolAware;	if (add) {	getCamelContext().addService(answer, false);	} else {	ServiceHelper.startService(answer);	}	} catch (Throwable e) {	throw new FailedToCreateProducerException(endpoint, e);	}	if (pooled && answer instanceof ServicePoolAware) {	
adding to producer service pool with key for producer 

getCamelContext().addService(answer, false);	} else {	ServiceHelper.startService(answer);	}	} catch (Throwable e) {	throw new FailedToCreateProducerException(endpoint, e);	}	if (pooled && answer instanceof ServicePoolAware) {	answer = pool.addAndAcquire(endpoint, answer);	} else if (answer.isSingleton()) {	
adding to producer cache with key for producer 

========================= camel sample_4009 =========================

public void testSendEndReceive() throws Exception {	int nbMessages = 50;	int failedMessages = 0;	for (int i = 0; i < nbMessages; i++) {	try {	directProducer.sendBodyAndHeader("Message #" + i, RabbitMQConstants.ROUTING_KEY, "rk3");	} catch (CamelExecutionException e) {	
can not send message 

========================= camel sample_14108 =========================

MockEndpoint mockEndpoint = getMockEndpoint("mock:a");	mockEndpoint.expectedBodiesReceived(expectedBody);	invokeHttpEndpoint();	mockEndpoint.assertIsSatisfied();	List<Exchange> list = mockEndpoint.getReceivedExchanges();	Exchange exchange = list.get(0);	assertNotNull("exchange", exchange);	Message in = exchange.getIn();	assertNotNull("in", in);	Map<String, Object> headers = in.getHeaders();	
headers 

exchange.getOut().setFault(true);	exchange.getOut().setBody(e);	}	exchange.getOut().setBody("<b>Hello World</b>");	}	};	from("jetty:http: Processor printProcessor = new Processor() {	public void process(Exchange exchange) throws Exception {	Message out = exchange.getOut();	out.copyFrom(exchange.getIn());	
the body s object is 

========================= camel sample_11023 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SqsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-sqs.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-sqs.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1122 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<AtomixSetComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.atomix-set.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.atomix-set.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1088 =========================

public void process(Exchange exchange) throws Exception {	if (exchange.getIn().getBody() == null) {	
received exchange with empty body skipping 

public void process(Exchange exchange) throws Exception {	if (exchange.getIn().getBody() == null) {	return;	}	TelegramConfiguration config = endpoint.getConfiguration();	OutgoingMessage message = exchange.getIn().getBody(OutgoingMessage.class);	if (message == null) {	throw new IllegalArgumentException("Cannot convert the content to a Telegram OutgoingMessage");	}	if (message.getChatId() == null) {	
chat id is null on outgoing message trying resolution 

if (exchange.getIn().getBody() == null) {	return;	}	TelegramConfiguration config = endpoint.getConfiguration();	OutgoingMessage message = exchange.getIn().getBody(OutgoingMessage.class);	if (message == null) {	throw new IllegalArgumentException("Cannot convert the content to a Telegram OutgoingMessage");	}	if (message.getChatId() == null) {	String chatId = resolveChatId(config, message, exchange);	
resolved chat id is 

TelegramConfiguration config = endpoint.getConfiguration();	OutgoingMessage message = exchange.getIn().getBody(OutgoingMessage.class);	if (message == null) {	throw new IllegalArgumentException("Cannot convert the content to a Telegram OutgoingMessage");	}	if (message.getChatId() == null) {	String chatId = resolveChatId(config, message, exchange);	message.setChatId(chatId);	}	TelegramService service = TelegramServiceProvider.get().getService();	
message being sent is 

TelegramConfiguration config = endpoint.getConfiguration();	OutgoingMessage message = exchange.getIn().getBody(OutgoingMessage.class);	if (message == null) {	throw new IllegalArgumentException("Cannot convert the content to a Telegram OutgoingMessage");	}	if (message.getChatId() == null) {	String chatId = resolveChatId(config, message, exchange);	message.setChatId(chatId);	}	TelegramService service = TelegramServiceProvider.get().getService();	
headers of message being sent are 

========================= camel sample_11920 =========================

public void onReloadXml(CamelContext camelContext, String name, InputStream resource) {	
reloading routes from xml resource 

public void onReloadXml(CamelContext camelContext, String name, InputStream resource) {	Document dom;	String xml;	try {	xml = camelContext.getTypeConverter().mandatoryConvertTo(String.class, resource);	dom = XmlLineNumberParser.parseXml(new ByteArrayInputStream(xml.getBytes()), null, "camelContext,routeContext,routes", "http: } catch (Exception e) {	failed++;	
cannot load the resource as xml 

if (list != null && list.getLength() > 0) {	for (int i = 0; i < list.getLength(); i++) {	Node node = list.item(i);	String lineNumber = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER);	String lineNumberEnd = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER_END);	if (lineNumber != null && lineNumberEnd != null && !changed.isEmpty()) {	int start = Integer.valueOf(lineNumber);	int end = Integer.valueOf(lineNumberEnd);	boolean within = withinChanged(start, end, changed);	if (within) {	
updating route in lines 

for (int i = 0; i < list.getLength(); i++) {	Node node = list.item(i);	String lineNumber = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER);	String lineNumberEnd = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER_END);	if (lineNumber != null && lineNumberEnd != null && !changed.isEmpty()) {	int start = Integer.valueOf(lineNumber);	int end = Integer.valueOf(lineNumberEnd);	boolean within = withinChanged(start, end, changed);	if (within) {	} else {	
no changes to route in lines 

}	if (!routes.isEmpty()) {	try {	boolean unassignedRouteIds = false;	CollectionStringBuffer csb = new CollectionStringBuffer(",");	for (RouteDefinition route : routes) {	unassignedRouteIds |= !route.hasCustomIdAssigned();	String id = route.idOrCreate(camelContext.getNodeIdFactory());	csb.append(id);	}	
reloading routes from xml resource 

if (!routes.isEmpty()) {	try {	boolean unassignedRouteIds = false;	CollectionStringBuffer csb = new CollectionStringBuffer(",");	for (RouteDefinition route : routes) {	unassignedRouteIds |= !route.hasCustomIdAssigned();	String id = route.idOrCreate(camelContext.getNodeIdFactory());	csb.append(id);	}	if (unassignedRouteIds) {	
routes with no id s detected its recommended to assign id s to your routes so camel can reload the routes correctly 

boolean unassignedRouteIds = false;	CollectionStringBuffer csb = new CollectionStringBuffer(",");	for (RouteDefinition route : routes) {	unassignedRouteIds |= !route.hasCustomIdAssigned();	String id = route.idOrCreate(camelContext.getNodeIdFactory());	csb.append(id);	}	if (unassignedRouteIds) {	}	camelContext.addRouteDefinitions(routes);	
reloaded routes from xml resource 

private boolean withinChanged(int start, int end, List<Integer> changed) {	for (int change : changed) {	
changed line within 

========================= camel sample_5161 =========================

public void channelActive(ChannelHandlerContext ctx) throws Exception {	if (LOG.isTraceEnabled()) {	
channel open 

public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {	if (LOG.isTraceEnabled()) {	
exception caught at channel 

public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {	if (LOG.isTraceEnabled()) {	}	if (exceptionHandled) {	return;	}	exceptionHandled = true;	if (LOG.isDebugEnabled()) {	
closing channel as an exception was thrown from netty 

public void channelInactive(ChannelHandlerContext ctx) throws Exception {	if (LOG.isTraceEnabled()) {	
channel closed 

Exchange exchange = getExchange(ctx);	AsyncCallback callback = getAsyncCallback(ctx);	producer.removeState(ctx.channel());	producer.getAllChannels().remove(ctx.channel());	boolean doneUoW = exchange.getUnitOfWork() == null;	NettyConfiguration configuration = producer.getConfiguration();	if (configuration.isSync() && !doneUoW && !messageReceived && !exceptionHandled) {	exceptionHandled = true;	String address = configuration != null ? configuration.getAddress() : "";	if (LOG.isDebugEnabled()) {	
channel closed but no message received from address 

protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {	messageReceived = true;	if (LOG.isTraceEnabled()) {	
message received 

protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {	messageReceived = true;	if (LOG.isTraceEnabled()) {	}	ChannelHandler handler = ctx.pipeline().get("timeout");	if (handler != null) {	
removing timeout channel as we received message 

}	if (close == null) {	close = exchange.getProperty(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);	}	boolean disconnect = producer.getConfiguration().isDisconnect();	if (close != null) {	disconnect = close;	}	if (!producer.getConfiguration().isReuseChannel() && disconnect) {	if (LOG.isTraceEnabled()) {	
closing channel when complete at address 

protected Message getResponseMessage(Exchange exchange, ChannelHandlerContext ctx, Object message) throws Exception {	Object body = message;	if (LOG.isDebugEnabled()) {	
channel received body 

========================= camel sample_10262 =========================

for (EndpointMappingKey key : endpoints.keySet()) {	String compositeOrSimpleKey = null;	switch (key.getType()) {	case ACTION: compositeOrSimpleKey = getActionCompositeLookupKey(map);	break;	case TO: compositeOrSimpleKey = getToCompositeLookupKey(map);	break;	default: throw new RuntimeCamelException( "Invalid mapping type specified. Supported types are: spring-ws:action:<WS-Addressing Action>(optional:<WS-Addressing To>?<params...>\n)" + "spring-ws:to:<WS-Addressing To>(optional:<WS-Addressing Action>?<params...>)");	}	if (compositeOrSimpleKey != null && key.getLookupKey().equals(compositeOrSimpleKey)) {	
found mapping for key 

simpleKey = map.getAction().toString();	}	break;	case TO: if (map.getTo() != null) {	simpleKey = map.getTo().toString();	}	break;	default: throw new RuntimeCamelException( "Invalid mapping type specified. Supported types are: spring-ws:action:<WS-Addressing Action>(optional:<WS-Addressing To>?<params...>\n)" + "spring-ws:to:<WS-Addressing To>(optional:<WS-Addressing Action>?<params...>)");	}	if (simpleKey != null && key.getLookupKey().equals(simpleKey)) {	
found mapping for key 

========================= camel sample_17118 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ZooKeeperComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.zookeeper.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.zookeeper.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1067 =========================

public Processor wrap(RouteContext routeContext, Processor processor) {	TransactionErrorHandler answer;	ErrorHandlerBuilder builder = (ErrorHandlerBuilder)routeContext.getRoute().getErrorHandlerBuilder();	if (builder instanceof ErrorHandlerBuilderRef) {	ErrorHandlerBuilderRef builderRef = (ErrorHandlerBuilderRef) builder;	String ref = builderRef.getRef();	if (ErrorHandlerBuilderRef.isErrorHandlerBuilderConfigured(ref)) {	
looking up errorhandlerbuilder with ref 

TransactionErrorHandler answer;	ErrorHandlerBuilder builder = (ErrorHandlerBuilder)routeContext.getRoute().getErrorHandlerBuilder();	if (builder instanceof ErrorHandlerBuilderRef) {	ErrorHandlerBuilderRef builderRef = (ErrorHandlerBuilderRef) builder;	String ref = builderRef.getRef();	if (ErrorHandlerBuilderRef.isErrorHandlerBuilderConfigured(ref)) {	builder = (ErrorHandlerBuilder)ErrorHandlerBuilderRef.lookupErrorHandlerBuilder(routeContext, ref);	}	}	if (builder != null && builder.supportTransacted()) {	
the errorhandlerbuilder configured is already a transactionerrorhandlerbuilder 

if (ErrorHandlerBuilderRef.isErrorHandlerBuilderConfigured(ref)) {	builder = (ErrorHandlerBuilder)ErrorHandlerBuilderRef.lookupErrorHandlerBuilder(routeContext, ref);	}	}	if (builder != null && builder.supportTransacted()) {	answer = createTransactionErrorHandler(routeContext, processor, builder);	answer.setExceptionPolicy(builder.getExceptionPolicyStrategy());	builder.configure(routeContext, answer);	} else {	if (builder != null) {	
the errorhandlerbuilder configured is not a transactionerrorhandlerbuilder 

builder = (ErrorHandlerBuilder)ErrorHandlerBuilderRef.lookupErrorHandlerBuilder(routeContext, ref);	}	}	if (builder != null && builder.supportTransacted()) {	answer = createTransactionErrorHandler(routeContext, processor, builder);	answer.setExceptionPolicy(builder.getExceptionPolicyStrategy());	builder.configure(routeContext, answer);	} else {	if (builder != null) {	} else {	
no errorhandlerbuilder configured will use default transactionerrorhandlerbuilder settings 

========================= camel sample_16359 =========================

public static int subnumbers(int val1, int val2) {	
calling subnumbers 

========================= camel sample_8991 =========================

protected void setDataValue(final DataValue value) {	
setvalue 

========================= camel sample_17266 =========================

public void testOneGroupMessage() throws Exception {	String message = "8=FIX 4.19=2034=135=049=INVMGR56=BRKR" + "1=BE.CHM.00111=CHM0001-0158=this is a camel - bindy test" + "22=448=BE000124567854=1" + "10=220" + "777=22-06-2013 12:21:11";	List<String> data = Arrays.asList(message.split("\\u0001"));	CamelContext camelContext = new DefaultCamelContext();	factory.bind(camelContext, data, model, counter);	
model 

public void testSeveralGroupMessage() throws Exception {	String message = "8=FIX 4.19=2034=135=049=INVMGR56=BRKR" + "1=BE.CHM.00111=CHM0001-0158=this is a camel - bindy test" + "22=448=BE000124567854=1" + "22=548=BE000987654354=2" + "22=648=BE000999999954=3" + "10=220" + "777=22-06-2013 12:21:11";	List<String> data = Arrays.asList(message.split("\\u0001"));	CamelContext camelContext = new DefaultCamelContext();	factory.bind(camelContext, data, model, counter);	
model 

public void testNoGroupMessage() throws Exception {	String message = "8=FIX 4.19=2034=135=049=INVMGR56=BRKR" + "1=BE.CHM.00111=CHM0001-0158=this is a camel - bindy test" + "10=220" + "777=22-06-2013 12:21:11";	List<String> data = Arrays.asList(message.split("\\u0001"));	CamelContext camelContext = new DefaultCamelContext();	factory.bind(camelContext, data, model, counter);	
model 

========================= camel sample_7388 =========================

public final void addToHintMap(final EncodeHintType hintType, final Object value) {	this.writerHintMap.put(hintType, value);	
added s with value s to writer hint map 

public final void removeFromHintMap(final EncodeHintType hintType) {	if (this.writerHintMap.containsKey(hintType)) {	this.writerHintMap.remove(hintType);	
removed s from writer hint map 

public final void removeFromHintMap(final EncodeHintType hintType) {	if (this.writerHintMap.containsKey(hintType)) {	this.writerHintMap.remove(hintType);	} else {	
could not find encode hint type s in writer hint map 

public final void removeFromHintMap(final DecodeHintType hintType) {	if (this.readerHintMap.containsKey(hintType)) {	this.readerHintMap.remove(hintType);	
removed s from reader hint map 

public final void removeFromHintMap(final DecodeHintType hintType) {	if (this.readerHintMap.containsKey(hintType)) {	this.readerHintMap.remove(hintType);	} else {	
could not find decode hint type s in reader hint map 

========================= camel sample_12121 =========================

public void testChoice() throws InterruptedException {	template.setDefaultEndpointUri("direct:choice");	execute(20000);	resetMock(count);	StopWatch watch = new StopWatch();	execute(count);	assertMockEndpointsSatisfied();	
ran tests in ms 

public void testFilter() throws InterruptedException {	template.setDefaultEndpointUri("direct:filter");	execute(20000);	resetMock(count);	StopWatch watch = new StopWatch();	execute(count);	assertMockEndpointsSatisfied();	
ran tests in ms 

========================= camel sample_6433 =========================

Exchange exchange = executeScript(scriptFile, NO_TIMEOUT, classpathArg, PRINT_IN_STDOUT);	if (exchange != null) {	String out = exchange.getIn().getBody(String.class);	String err = (String)exchange.getIn().getHeader(EXEC_STDERR);	assertNotNull(out);	assertTrue(out.contains(PRINT_IN_STDOUT));	assertNull(err);	}	} else {	String os = System.getProperty("os.name");	
executing batch scripts is not tested on 

private File getExecScriptFileOrNull(String scriptNameBase) {	String resource = null;	if (OS.isFamilyWindows()) {	resource = scriptNameBase + ".bat";	} else if (OS.isFamilyUnix()) {	resource = scriptNameBase + ".sh";	}	File resourceFile = getClasspathResourceFileOrNull(resource);	if (resourceFile != null && !resourceFile.canRead()) {	
the resource is not readable 

========================= camel sample_12208 =========================

Map<String, Object> options = new HashMap<String, Object>();	if (IntrospectionSupport.getProperties(bootstrapConfiguration, options, null, false)) {	IntrospectionSupport.setProperties(getCamelContext().getTypeConverter(), config, options);	}	}	NettyHttpSecurityConfiguration securityConfiguration = resolveAndRemoveReferenceParameter(parameters, "securityConfiguration", NettyHttpSecurityConfiguration.class);	Map<String, Object> securityOptions = IntrospectionSupport.extractProperties(parameters, "securityConfiguration.");	int sharedPort = -1;	NettySharedHttpServer shared = resolveAndRemoveReferenceParameter(parameters, "nettySharedHttpServer", NettySharedHttpServer.class);	if (shared != null) {	
using nettysharedhttpserver with port 

if (shared != null) {	sharedPort = shared.getPort();	}	boolean hasProtocol = remaining.startsWith("http: || remaining.startsWith("https: if (!hasProtocol) {	remaining = "http: }	boolean hasSlash = remaining.startsWith("http: if (!hasSlash) {	if (remaining.startsWith("http:")) {	remaining = "http: } else {	remaining = "https: }	}	
netty http url 

========================= camel sample_8354 =========================

parser.setContentHandler(createContentHandler(w));	try {	parser.parse(new InputSource(inputStream));	return w.toString();	} catch (Exception e) {	throw new CamelException("Failed to convert the HTML to tidy Markup", e);	} finally {	try {	inputStream.close();	} catch (Exception e) {	
failed to close the inputstream 

========================= camel sample_11977 =========================

protected Object decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Exception {	ByteBuf buf = (ByteBuf) super.decode(ctx, buffer);	if (buf != null) {	try {	int pos = buf.bytesBefore((byte) config.getStartByte());	if (pos >= 0) {	ByteBuf msg = buf.readerIndex(pos + 1).slice();	
message ends with length 

if (pos >= 0) {	ByteBuf msg = buf.readerIndex(pos + 1).slice();	return config.isProduceString() ? asString(msg) : asByteArray(msg);	} else {	throw new DecoderException("Did not find start byte " + (int) config.getStartByte());	}	} finally {	buf.release();	}	}	
no complete messages yet at position 

========================= camel sample_11424 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<IgniteEventsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ignite-events.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ignite-events.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1175 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<HeaderLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.header.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.header.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_911 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<MustacheComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mustache.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mustache.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1030 =========================

mock.expectedBodiesReceived(expected);	ProducerTemplate triggerTemplate = context.createProducerTemplate();	triggerTemplate.sendBody("vm:trigger", "");	assertMockEndpointsSatisfied();	long startFileDeletionCheckTime = System.currentTimeMillis();	boolean fileExists = true;	while (System.currentTimeMillis() - startFileDeletionCheckTime < 3000) {	File file = new File(FTP_ROOT_DIR + "/hello.txt");	fileExists = file.exists();	if (fileExists) {	
will check that file has been deleted again in 

========================= camel sample_15172 =========================

public void process(Exchange exchange) throws Exception {	String container = getContainerName(exchange);	String blobName = getBlobName(exchange);	String operation = getOperation(exchange);	List blobNames = getBlobNameList(exchange);	if (LOG.isTraceEnabled()) {	
processing operation on 

========================= camel sample_8084 =========================

protected void doStart() throws Exception {	super.doStart();	
connecting receiver to the cluster 

protected void doStop() throws Exception {	
closing connection to cluster from receiver 

========================= camel sample_16932 =========================

public void initializeProcess() throws Exception {	if (LOG.isInfoEnabled()) {	
starting mongodb tailable cursor consumer binding to collection db col 

public void run() {	stoppedLatch = new CountDownLatch(1);	while (keepRunning) {	doRun();	if (keepRunning) {	cursor.close();	if (LOG.isDebugEnabled()) {	
regenerating cursor with lastval waiting ms first 

protected void stop() throws Exception {	if (LOG.isInfoEnabled()) {	
stopping mongodb tailable cursor consumer bound to collection db col 

protected void stop() throws Exception {	if (LOG.isInfoEnabled()) {	}	keepRunning = false;	if (cursor != null) {	cursor.close();	}	awaitStopped();	if (LOG.isInfoEnabled()) {	
stopped mongodb tailable cursor consumer bound to collection db col 

private void doRun() {	int counter = 0;	int persistRecords = endpoint.getPersistRecords();	boolean persistRegularly = persistRecords > 0;	try {	while (cursor.hasNext() && keepRunning) {	DBObject dbObj = cursor.next();	Exchange exchange = endpoint.createMongoDbExchange(dbObj);	try {	if (LOG.isTraceEnabled()) {	
sending exchange objectid id 

consumer.getProcessor().process(exchange);	} catch (Exception e) {	}	tailTracking.setLastVal(dbObj);	if (persistRegularly && counter++ % persistRecords == 0) {	tailTracking.persistToStore();	}	}	} catch (MongoCursorNotFoundException e) {	if (keepRunning) {	
cursor not found exception from mongodb will regenerate cursor this is normal behaviour with tailable cursors 

private void awaitStopped() throws InterruptedException {	if (!stopped) {	
going to wait for stopping 

========================= camel sample_16461 =========================

public ZooKeeperGroup(CuratorFramework client, String path, Class<T> clazz, final ExecutorService executorService) {	
creating zk group for path path 

public void start() {	
starting zk group for path 

public void close() throws IOException {	
close connected 

protected void doUpdate(T state) throws Exception {	if (LOG.isTraceEnabled()) {	
doupdate state id 

try {	if (isConnected()) {	client.delete().guaranteed().forPath(id);	unstable.set(false);	}	} catch (KeeperException.NoNodeException e) {	} finally {	id = null;	}	} else if (creating.get()) {	
ephemeral node could be created in the registry but zookeeper group didn t record its id 

private String createEphemeralNode(T state) throws Exception {	state.uuid = uuid;	creating.set(true);	String pathId = client.create().creatingParentsIfNeeded() .withMode(CreateMode.EPHEMERAL_SEQUENTIAL) .forPath(path + "/0", encode(state));	creating.set(false);	unstable.set(false);	if (LOG.isTraceEnabled()) {	
state new ephemeralsequential path 

private void prunePartialState(final T ourState, final String pathId) throws Exception {	if (ourState.uuid != null) {	clearAndRefresh(true, true);	List<ChildData<T>> children = new ArrayList<ChildData<T>>(currentData.values());	for (ChildData<T> child : children) {	if (ourState.uuid.equals(child.getNode().uuid) && !child.getPath().equals(pathId)) {	
deleting partially created znode 

========================= camel sample_9695 =========================

protected void doStart() throws Exception {	super.doStart();	
starting nats consumer 

protected void doStart() throws Exception {	super.doStart();	executor = getEndpoint().createExecutor();	
getting nats connection 

protected void doStop() throws Exception {	super.doStop();	if (getEndpoint().getNatsConfiguration().isFlushConnection()) {	
flushing messages before stopping 

protected void doStop() throws Exception {	super.doStop();	if (getEndpoint().getNatsConfiguration().isFlushConnection()) {	connection.flush(getEndpoint().getNatsConfiguration().getFlushTimeout());	}	try {	sid.unsubscribe();	} catch (Exception e) {	getExceptionHandler().handleException("Error during unsubscribing", e);	}	
stopping nats consumer 

getExceptionHandler().handleException("Error during unsubscribing", e);	}	if (executor != null) {	if (getEndpoint() != null && getEndpoint().getCamelContext() != null) {	getEndpoint().getCamelContext().getExecutorServiceManager().shutdownNow(executor);	} else {	executor.shutdownNow();	}	}	executor = null;	
closing nats connection 

public void run() {	try {	if (ObjectHelper.isNotEmpty(configuration.getQueueName())) {	sid = connection.subscribe(getEndpoint().getNatsConfiguration().getTopic(), getEndpoint().getNatsConfiguration().getQueueName(), new MessageHandler() {	public void onMessage(Message msg) {	
received message 

});	if (ObjectHelper.isNotEmpty(getEndpoint().getNatsConfiguration().getMaxMessages())) {	sid.autoUnsubscribe(Integer.parseInt(getEndpoint().getNatsConfiguration().getMaxMessages()));	}	if (sid.isValid()) {	setSubscribed(true);	}	} else {	sid = connection.subscribe(getEndpoint().getNatsConfiguration().getTopic(), new MessageHandler() {	public void onMessage(Message msg) {	
received message 

========================= camel sample_12971 =========================

public void testHttpHbr() throws Exception {	send("http: StopWatch watch = new StopWatch();	
http log warn ms count watch taken 

========================= camel sample_6425 =========================

exchange.setException(e);	callback.done(true);	return true;	}	}	callback = new InternalCallback(states, exchange, callback, resultProcessor);	Object synchronous = exchange.removeProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC);	if (exchange.isTransacted() || synchronous != null) {	if (LOG.isTraceEnabled()) {	if (exchange.isTransacted()) {	
transacted exchange must be routed synchronously for exchangeid 

callback.done(true);	return true;	}	}	callback = new InternalCallback(states, exchange, callback, resultProcessor);	Object synchronous = exchange.removeProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC);	if (exchange.isTransacted() || synchronous != null) {	if (LOG.isTraceEnabled()) {	if (exchange.isTransacted()) {	} else {	
synchronous unitofwork exchange must be routed synchronously for exchangeid 

}	callback.done(true);	return true;	} else {	final UnitOfWork uow = exchange.getUnitOfWork();	AsyncCallback async = callback;	if (uow != null) {	async = uow.beforeProcess(processor, exchange, callback);	}	if (LOG.isTraceEnabled()) {	
processing exchange for exchangeid 

if (uow != null) {	async = uow.beforeProcess(processor, exchange, callback);	}	if (LOG.isTraceEnabled()) {	}	boolean sync = processor.process(exchange, async);	if (uow != null) {	uow.afterProcess(processor, exchange, callback, sync);	}	if (LOG.isTraceEnabled()) {	
exchange processed and is continued routed for exchangeid synchronously asynchronously 

protected boolean continueProcessing(Exchange exchange, AsyncProcessor processor) {	Object stop = exchange.getProperty(Exchange.ROUTE_STOP);	if (stop != null) {	boolean doStop = exchange.getContext().getTypeConverter().convertTo(Boolean.class, stop);	if (doStop) {	
exchange is marked to stop routing 

========================= camel sample_4418 =========================

public void start(BundleContext context) throws Exception {	
camel activator starting 

public void start(BundleContext context) throws Exception {	cachePackageCapabilities(context);	bundleId = context.getBundle().getBundleId();	BundleContext systemBundleContext = context.getBundle(0).getBundleContext();	tracker = new BundleTracker(systemBundleContext, Bundle.ACTIVE, this);	tracker.open();	
camel activator started 

public void stop(BundleContext context) throws Exception {	
camel activator stopping 

public void stop(BundleContext context) throws Exception {	tracker.close();	packageCapabilities.clear();	
camel activator stopped 

public Object addingBundle(Bundle bundle, BundleEvent event) {	
bundle started 

private boolean extenderCapabilityWired(Bundle bundle) {	BundleWiring wiring = bundle.adapt(BundleWiring.class);	if (wiring == null) {	return true;	}	List<BundleWire> requiredWires = wiring.getRequiredWires(EXTENDER_NAMESPACE);	for (BundleWire requiredWire : requiredWires) {	if (CAMEL_EXTENDER.equals(requiredWire.getCapability().getAttributes().get(EXTENDER_NAMESPACE))) {	if (this.bundleId == requiredWire.getProviderWiring().getBundle().getBundleId()) {	
camel extender requirement of bundle correctly wired to this implementation 

BundleWiring wiring = bundle.adapt(BundleWiring.class);	if (wiring == null) {	return true;	}	List<BundleWire> requiredWires = wiring.getRequiredWires(EXTENDER_NAMESPACE);	for (BundleWire requiredWire : requiredWires) {	if (CAMEL_EXTENDER.equals(requiredWire.getCapability().getAttributes().get(EXTENDER_NAMESPACE))) {	if (this.bundleId == requiredWire.getProviderWiring().getBundle().getBundleId()) {	return true;	} else {	
not processing bundle as it requires a camel extender but is not wired to the this implementation 

public void removedBundle(Bundle bundle, BundleEvent event, Object object) {	
bundle stopped 

protected void registerComponents(Bundle bundle, List<BaseService> resolvers) {	if (canSee(bundle, Component.class)) {	Map<String, String> components = new HashMap<String, String>();	for (Enumeration<?> e = bundle.getEntryPaths(META_INF_COMPONENT); e != null && e.hasMoreElements();) {	String path = (String) e.nextElement();	
found entry in bundle 

protected void registerLanguages(Bundle bundle, List<BaseService> resolvers) {	if (canSee(bundle, Language.class)) {	Map<String, String> languages = new HashMap<String, String>();	for (Enumeration<?> e = bundle.getEntryPaths(META_INF_LANGUAGE); e != null && e.hasMoreElements();) {	String path = (String) e.nextElement();	
found entry in bundle 

for (Enumeration<?> e = bundle.getEntryPaths(META_INF_LANGUAGE); e != null && e.hasMoreElements();) {	String path = (String) e.nextElement();	String name = path.substring(path.lastIndexOf("/") + 1);	languages.put(name, path);	}	if (!languages.isEmpty()) {	resolvers.add(new BundleLanguageResolver(bundle, languages));	}	for (Enumeration<?> e = bundle.getEntryPaths(META_INF_LANGUAGE_RESOLVER); e != null && e.hasMoreElements();) {	String path = (String) e.nextElement();	
found entry in bundle 

protected void registerDataFormats(Bundle bundle, List<BaseService> resolvers) {	if (canSee(bundle, DataFormat.class)) {	Map<String, String> dataformats = new HashMap<String, String>();	for (Enumeration<?> e = bundle.getEntryPaths(META_INF_DATAFORMAT); e != null && e.hasMoreElements();) {	String path = (String) e.nextElement();	
found entry in bundle 

protected void registerTypeConverterLoader(Bundle bundle, List<BaseService> resolvers) {	if (canSee(bundle, TypeConverter.class)) {	URL url1 = bundle.getEntry(META_INF_TYPE_CONVERTER);	URL url2 = bundle.getEntry(META_INF_FALLBACK_TYPE_CONVERTER);	if (url1 != null || url2 != null) {	
found typeconverter in bundle 

public void load(TypeConverterRegistry registry) throws TypeConverterLoaderException {	PackageScanFilter test = new AnnotatedWithPackageScanFilter(Converter.class, true);	Set<Class<?>> classes = new LinkedHashSet<Class<?>>();	Set<String> packages = getConverterPackages(bundle.getEntry(META_INF_TYPE_CONVERTER));	if (LOG.isTraceEnabled()) {	
found packages 

public void load(TypeConverterRegistry registry) throws TypeConverterLoaderException {	PackageScanFilter test = new AnnotatedWithPackageScanFilter(Converter.class, true);	Set<Class<?>> classes = new LinkedHashSet<Class<?>>();	Set<String> packages = getConverterPackages(bundle.getEntry(META_INF_TYPE_CONVERTER));	if (LOG.isTraceEnabled()) {	}	if (packages.size() == 1 && "org.apache.camel.core".equals(packages.iterator().next())) {	
no additional package names found in classpath for annotated type converters 

Set<Class<?>> classes = new LinkedHashSet<Class<?>>();	Set<String> packages = getConverterPackages(bundle.getEntry(META_INF_TYPE_CONVERTER));	if (LOG.isTraceEnabled()) {	}	if (packages.size() == 1 && "org.apache.camel.core".equals(packages.iterator().next())) {	return;	}	packages.remove("org.apache.camel.core");	for (String pkg : packages) {	if (StringHelper.isClassName(pkg)) {	
loading class 

return;	}	packages.remove("org.apache.camel.core");	for (String pkg : packages) {	if (StringHelper.isClassName(pkg)) {	try {	Class<?> clazz = bundle.loadClass(pkg);	classes.add(clazz);	continue;	} catch (Throwable t) {	
failed to load class due this exception will be ignored 

Class<?> clazz = bundle.loadClass(pkg);	classes.add(clazz);	continue;	} catch (Throwable t) {	}	}	Enumeration<URL> e = bundle.findEntries("/" + pkg.replace('.', '/'), "*.class", true);	while (e != null && e.hasMoreElements()) {	String path = e.nextElement().getPath();	String externalName = path.substring(path.charAt(0) == '/' ? 1 : 0, path.indexOf('.')).replace('/', '.');	
loading class 

Enumeration<URL> e = bundle.findEntries("/" + pkg.replace('.', '/'), "*.class", true);	while (e != null && e.hasMoreElements()) {	String path = e.nextElement().getPath();	String externalName = path.substring(path.charAt(0) == '/' ? 1 : 0, path.indexOf('.')).replace('/', '.');	try {	Class<?> clazz = bundle.loadClass(externalName);	if (test.matches(clazz)) {	classes.add(clazz);	}	} catch (Throwable t) {	
failed to load class due this exception will be ignored 

String externalName = path.substring(path.charAt(0) == '/' ? 1 : 0, path.indexOf('.')).replace('/', '.');	try {	Class<?> clazz = bundle.loadClass(externalName);	if (test.matches(clazz)) {	classes.add(clazz);	}	} catch (Throwable t) {	}	}	}	
found converter classes to load 

Class<?> clazz = bundle.loadClass(externalName);	if (test.matches(clazz)) {	classes.add(clazz);	}	} catch (Throwable t) {	}	}	}	for (Class<?> type : classes) {	if (LOG.isTraceEnabled()) {	
loading converter class 

}	}	}	for (Class<?> type : classes) {	if (LOG.isTraceEnabled()) {	}	loadConverterMethods(registry, type);	}	URL fallbackUrl = bundle.getEntry(META_INF_FALLBACK_TYPE_CONVERTER);	if (fallbackUrl != null) {	
found to load the fallbacktypeconverter 

protected T createInstance(String name, String path, CamelContext context) {	if (path == null) {	return null;	}	URL url = bundle.getEntry(path);	
the entry s url is 

========================= camel sample_4048 =========================

private void authenticateUser(Subject currentUser, ShiroSecurityToken securityToken) {	boolean authenticated = currentUser.isAuthenticated();	boolean sameUser = securityToken.getUsername().equals(currentUser.getPrincipal());	
authenticated same username 

boolean sameUser = securityToken.getUsername().equals(currentUser.getPrincipal());	if (!authenticated || !sameUser) {	UsernamePasswordToken token = new UsernamePasswordToken(securityToken.getUsername(), securityToken.getPassword());	if (policy.isAlwaysReauthenticate()) {	token.setRememberMe(false);	} else {	token.setRememberMe(true);	}	try {	currentUser.login(token);	
current user successfully authenticated 

authorized = currentUser.hasAllRoles(policy.getRolesList());	} else {	for (String role : policy.getRolesList()) {	if (currentUser.hasRole(role)) {	authorized = true;	break;	}	}	}	} else {	
valid permissions or roles list not specified for shirosecuritypolicy no authorization checks will be performed for current user 

break;	}	}	}	} else {	authorized = true;	}	if (!authorized) {	throw new CamelAuthorizationException("Authorization Failed. Subject's role set does " + "not have the necessary roles or permissions to perform further processing.", exchange);	}	
current user is successfully authorized 

========================= camel sample_12137 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	context.addComponent("async", new MyAsyncComponent());	from("direct:start").routeId("myRoute") .to("mock:before") .to("async:bye:camel?delay=2000").id("myAsync") .to("mock:after") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	int size = context.getAsyncProcessorAwaitManager().size();	
async inflight 

========================= camel sample_2036 =========================

public GetCommitFileProducer(GitHubEndpoint endpoint) throws Exception {	super(endpoint);	Registry registry = endpoint.getCamelContext().getRegistry();	Object service = registry.lookupByName(GitHubConstants.GITHUB_DATA_SERVICE);	if (service != null) {	
using dataservice found in registry 

========================= camel sample_14260 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SipComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.sip.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.sip.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1163 =========================

public void run() {	BlockingQueue<Exchange> queue = ((RouteboxSedaEndpoint)getRouteboxEndpoint()).getQueue();	while (queue != null && isRunAllowed()) {	try {	final Exchange exchange = queue.poll(getRouteboxEndpoint().getConfig().getPollInterval(), TimeUnit.MILLISECONDS);	dispatchToInnerRoute(queue, exchange);	} catch (InterruptedException e) {	if (LOG.isDebugEnabled()) {	
sleep interrupted are we stopping 

private void dispatchToInnerRoute(BlockingQueue<Exchange> queue, final Exchange exchange) throws InterruptedException {	Exchange result;	if (exchange != null) {	if (isRunAllowed()) {	try {	
dispatching to inner route 

result = dispatcher.dispatchAsync(getRouteboxEndpoint(), exchange);	processor.process(result, new AsyncCallback() {	public void done(boolean doneSync) {	}	});	} catch (Exception e) {	getExceptionHandler().handleException("Error processing exchange", exchange, e);	}	} else {	if (LOG.isWarnEnabled()) {	
this consumer is stopped during polling an exchange so putting it back on the seda queue 

========================= camel sample_14630 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<GuavaEventBusComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.guava-eventbus.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.guava-eventbus.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_454 =========================

((InEntry) entry).buffer = bos.toByteArray();	}	} else {	entry = (Entry) body;	}	Transaction tnx = null;	if (transactionHelper != null) {	tnx = transactionHelper.getJiniTransaction(transactionTimeout).transaction;	}	if (LOG.isDebugEnabled()) {	
writing body 

========================= camel sample_15021 =========================

protected RouteBuilder createRouteBuilder() {	final int groupInterval = 1000;	final boolean groupActiveOnly = false;	mllpClient.setMllpHost("localhost");	mllpClient.setMllpPort(AvailablePortFinder.getNextAvailable());	return new RouteBuilder() {	String routeId = "mllp-receiver";	public void configure() throws Exception {	
test route complete 

protected RouteBuilder createRouteBuilder() {	final int groupInterval = 1000;	final boolean groupActiveOnly = false;	mllpClient.setMllpHost("localhost");	mllpClient.setMllpPort(AvailablePortFinder.getNextAvailable());	return new RouteBuilder() {	String routeId = "mllp-receiver";	public void configure() throws Exception {	
mllp mllpclient getmllphost mllpclient getmllpport routeid routeid process new passthroughprocessor result to result tof test route received message 

========================= camel sample_13819 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<MiloClientComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.milo-client.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.milo-client.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_511 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<MvelLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.mvel.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.mvel.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_1026 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ValidatorComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.validator.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.validator.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_842 =========================

if (outParameter.getScale() != null) {	sqlOutParameter = new SqlOutParameter(outParameter.getOutValueMapKey(), outParameter.getSqlType(), outParameter.getScale());	} else if (outParameter.getTypeName() != null) {	sqlOutParameter = new SqlOutParameter(outParameter.getOutValueMapKey(), outParameter.getSqlType(), outParameter.getTypeName());	} else {	sqlOutParameter = new SqlOutParameter(outParameter.getOutValueMapKey(), outParameter.getSqlType());	}	declareParameter(sqlOutParameter);	}	}	
compiling stored procedure 

public Map execute(Exchange exchange, Object rowData) {	Map<String, Object> params = new HashMap<>();	for (InputParameter inputParameter : inputParameterList) {	params.put(inputParameter.getName(), inputParameter.getValueExtractor().eval(exchange, rowData));	}	
invoking stored procedure 

========================= camel sample_9046 =========================

public void testRestartAppChangeCronExpression() throws Exception {	app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzPersistentStoreRestartAppChangeCronExpressionTest1.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	String cronExpression = ((CronTrigger) getTrigger(camel, "quartzRoute")).getCronExpression();	app.stop();	
restarting 

public void testRestartAppChangeCronExpression() throws Exception {	app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzPersistentStoreRestartAppChangeCronExpressionTest1.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	String cronExpression = ((CronTrigger) getTrigger(camel, "quartzRoute")).getCronExpression();	app.stop();	
restarting 

public void testRestartAppChangeCronExpression() throws Exception {	app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzPersistentStoreRestartAppChangeCronExpressionTest1.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	String cronExpression = ((CronTrigger) getTrigger(camel, "quartzRoute")).getCronExpression();	app.stop();	
restarting 

public void testRestartAppChangeTriggerOptions() throws Exception {	AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzPersistentStoreRestartAppChangeOptionsTest1.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	SimpleTrigger trigger = (SimpleTrigger) getTrigger(camel, "quartzRoute");	long repeatInterval = trigger.getRepeatInterval();	app.stop();	
restarting 

public void testRestartAppChangeTriggerOptions() throws Exception {	AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzPersistentStoreRestartAppChangeOptionsTest1.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	SimpleTrigger trigger = (SimpleTrigger) getTrigger(camel, "quartzRoute");	long repeatInterval = trigger.getRepeatInterval();	app.stop();	
restarting 

public void testRestartAppChangeTriggerOptions() throws Exception {	AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzPersistentStoreRestartAppChangeOptionsTest1.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	SimpleTrigger trigger = (SimpleTrigger) getTrigger(camel, "quartzRoute");	long repeatInterval = trigger.getRepeatInterval();	app.stop();	
restarting 

public void testRestartAppChangeTriggerType() throws Exception {	app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzPersistentStoreRestartAppChangeCronExpressionTest1.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	assertTrue(getTrigger(camel, "quartzRoute") instanceof CronTrigger);	app.stop();	
restarting 

public void testRestartAppChangeTriggerType() throws Exception {	app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzPersistentStoreRestartAppChangeCronExpressionTest1.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	assertTrue(getTrigger(camel, "quartzRoute") instanceof CronTrigger);	app.stop();	
restarting 

public void testRestartAppChangeTriggerType() throws Exception {	app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzPersistentStoreRestartAppChangeCronExpressionTest1.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	assertTrue(getTrigger(camel, "quartzRoute") instanceof CronTrigger);	app.stop();	
restarting 

========================= camel sample_14958 =========================

public static void startServer() throws Exception {	Object implementor = new GreeterImpl();	String address = "http: endpoint = Endpoint.publish(address, implementor);	
the ws endpoint is published 

========================= camel sample_6022 =========================

private void createTag(Exchange exchange) throws Exception {	String name = exchange.getIn().getHeader(DigitalOceanHeaders.NAME, String.class);	if (ObjectHelper.isEmpty(name)) {	throw new IllegalArgumentException(DigitalOceanHeaders.NAME + " must be specified");	}	Tag tag = getEndpoint().getDigitalOceanClient().createTag(name);	
create tag 

private void getTag(Exchange exchange) throws Exception {	String name = exchange.getIn().getHeader(DigitalOceanHeaders.NAME, String.class);	if (ObjectHelper.isEmpty(name)) {	throw new IllegalArgumentException(DigitalOceanHeaders.NAME + " must be specified");	}	Tag tag = getEndpoint().getDigitalOceanClient().getTag(name);	
tag 

private void getTags(Exchange exchange) throws Exception {	Tags tags = getEndpoint().getDigitalOceanClient().getAvailableTags(configuration.getPage(), configuration.getPerPage());	
all tags page per page 

private void deleteTag(Exchange exchange) throws Exception {	String name = exchange.getIn().getHeader(DigitalOceanHeaders.NAME, String.class);	if (ObjectHelper.isEmpty(name)) {	throw new IllegalArgumentException(DigitalOceanHeaders.NAME + " must be specified");	}	Delete delete = getEndpoint().getDigitalOceanClient().deleteTag(name);	
delete tag 

========================= camel sample_8895 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("direct:start").streamCaching() .process(new Processor() {	public void process(Exchange exchange) throws Exception {	byte[] data = exchange.getIn().getBody(byte[].class);	InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, data);	XMLReader xmlReader = XMLReaderFactory.createXMLReader();	exchange.getIn().setBody(new SAXSource(xmlReader, new InputSource(is)));	}	
body xslt xslt common staff template xsl log result mock result 

========================= camel sample_3559 =========================

public void testPollFileWhileSlowFileIsBeingWritten() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(1);	template.sendBody("seda:start", "Create the slow file");	mock.assertIsSatisfied();	String body = mock.getReceivedExchanges().get(0).getIn().getBody(String.class);	
body is 

public void process(Exchange exchange) throws Exception {	
creating a slow file with no locks 

public void process(Exchange exchange) throws Exception {	File file = new File("target/exclusiveread/slowfile/hello.txt");	FileOutputStream fos = new FileOutputStream(file);	fos.write("Hello World".getBytes());	for (int i = 0; i < 3; i++) {	Thread.sleep(100);	fos.write(("Line #" + i).getBytes());	
appending to slowfile 

public void process(Exchange exchange) throws Exception {	File file = new File("target/exclusiveread/slowfile/hello.txt");	FileOutputStream fos = new FileOutputStream(file);	fos.write("Hello World".getBytes());	for (int i = 0; i < 3; i++) {	Thread.sleep(100);	fos.write(("Line #" + i).getBytes());	}	fos.write("Bye World".getBytes());	fos.close();	
done creating slowfile 

========================= camel sample_3109 =========================

exchange.setException(new IllegalStateException("EventBus is not started or not configured"));	callback.done(true);	return true;	}	String address = getEndpoint().getAddress();	boolean reply = ExchangeHelper.isOutCapable(exchange);	boolean pubSub = getEndpoint().isPubSub();	Object body = getVertxBody(exchange);	if (body != null) {	if (reply) {	
sending to with body 

String address = getEndpoint().getAddress();	boolean reply = ExchangeHelper.isOutCapable(exchange);	boolean pubSub = getEndpoint().isPubSub();	Object body = getVertxBody(exchange);	if (body != null) {	if (reply) {	eventBus.send(address, body, new CamelReplyHandler(exchange, callback));	return false;	} else {	if (pubSub) {	
publishing to with body 

boolean pubSub = getEndpoint().isPubSub();	Object body = getVertxBody(exchange);	if (body != null) {	if (reply) {	eventBus.send(address, body, new CamelReplyHandler(exchange, callback));	return false;	} else {	if (pubSub) {	eventBus.publish(address, body);	} else {	
sending to with body 

========================= camel sample_11520 =========================

public void process(Exchange exchange) throws Exception {	String unmarshalId = endpoint.getConfiguration().getUnmarshalId();	if (unmarshalId != null) {	
unmarshalling input data using data format 

if (unmarshalId != null) {	resolveUnmarshaller(exchange, unmarshalId).process(exchange);	if (exchange.getException() != null) {	throw exchange.getException();	}	}	Class<?> targetModel = endpoint.getCamelContext().getClassResolver().resolveMandatoryClass( endpoint.getConfiguration().getTargetModel());	Message msg = exchange.hasOut() ? exchange.getOut() : exchange.getIn();	String sourceType = endpoint.getConfiguration().getSourceModel();	if (sourceType != null) {	
converting to source model 

Class<?> targetModel = endpoint.getCamelContext().getClassResolver().resolveMandatoryClass( endpoint.getConfiguration().getTargetModel());	Message msg = exchange.hasOut() ? exchange.getOut() : exchange.getIn();	String sourceType = endpoint.getConfiguration().getSourceModel();	if (sourceType != null) {	Class<?> sourceModel = endpoint.getCamelContext() .getClassResolver().resolveClass(sourceType);	if (sourceModel == null) {	throw new Exception("Unable to load sourceModel class: " + sourceType);	}	msg.setBody(msg.getBody(sourceModel));	}	
mapping to target model 

try {	endpoint.getExpressionMapper().setCurrentExchange(exchange);	endpoint.getMapper().map(endpoint.getExpressionMapper(), targetObject);	} finally {	endpoint.getExpressionMapper().setCurrentExchange(null);	}	msg.setBody(targetObject);	exchange.setIn(msg);	String marshalId = endpoint.getConfiguration().getMarshalId();	if (marshalId != null) {	
marshalling output data using data format 

========================= camel sample_9441 =========================

public void testPostStatusUpdateRequestResponse() throws Exception {	Date now = new Date();	String tweet = "UserProducerInOnlyTest: This is a tweet posted on " + now.toString();	
tweet 

========================= camel sample_14165 =========================

protected void doStart() throws Exception {	ObjectHelper.notNull(getCamelContext(), "camelContext");	if (isResolvePropertyPlaceholders()) {	Component existing = CamelContextHelper.lookupPropertiesComponent(camelContext, false);	if (existing != null) {	
resolving property placeholders on component 

protected void doStart() throws Exception {	ObjectHelper.notNull(getCamelContext(), "camelContext");	if (isResolvePropertyPlaceholders()) {	Component existing = CamelContextHelper.lookupPropertiesComponent(camelContext, false);	if (existing != null) {	CamelContextHelper.resolvePropertyPlaceholders(camelContext, this);	} else {	
cannot resolve property placeholders on component as propertiescomponent is not in use 

========================= camel sample_4064 =========================

public void run() {	delayedCount.decrementAndGet();	
delayed task woke up and continues routing for exchangeid 

public void run() {	delayedCount.decrementAndGet();	if (!isRunAllowed()) {	exchange.setException(new RejectedExecutionException("Run is not allowed"));	}	DelayProcessorSupport.this.processor.process(exchange, new AsyncCallback() {	public void done(boolean doneSync) {	
delayed task done for exchangeid 

return processor.process(exchange, callback);	} catch (Exception e) {	exchange.setException(e);	callback.done(true);	return true;	}	} else {	delayedCount.incrementAndGet();	ProcessCall call = new ProcessCall(exchange, callback);	try {	
scheduling delayed task to run in millis for exchangeid 

ProcessCall call = new ProcessCall(exchange, callback);	try {	executorService.schedule(call, delay, TimeUnit.MILLISECONDS);	return false;	} catch (RejectedExecutionException e) {	delayedCount.decrementAndGet();	if (isCallerRunsWhenRejected()) {	if (!isRunAllowed()) {	exchange.setException(new RejectedExecutionException());	} else {	
scheduling rejected task so letting caller run delaying at first for millis for exchangeid 

public boolean process(Exchange exchange, AsyncCallback callback) {	if (!isRunAllowed()) {	exchange.setException(new RejectedExecutionException("Run is not allowed"));	callback.done(true);	return true;	}	long delay;	try {	delay = calculateDelay(exchange);	if (delay <= 0) {	
no delay for exchangeid 

protected void handleSleepInterruptedException(InterruptedException e, Exchange exchange) throws InterruptedException {	if (log.isDebugEnabled()) {	
sleep interrupted are we stopping 

private void sleep(long delay) throws InterruptedException {	if (delay <= 0) {	return;	}	
sleeping for millis 

========================= camel sample_4434 =========================

public void process(Exchange exchange) throws Exception {	boolean matches = predicate.matches(exchange);	if (LOG.isDebugEnabled()) {	
validation for with predicate succeed failed 

========================= camel sample_4571 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() {	getContext().addInterceptStrategy(new HandleFault());	
mock error 

========================= camel sample_1773 =========================

}	file = new File(classesDirectory, "camel-connector-schema.json");	if (file.exists() && javaType != null && connectorScheme != null) {	String json = loadText(new FileInputStream(file));	ComponentModel model = generateComponentModel(json);	boolean hasComponentOptions = model.getComponentOptions().stream().anyMatch(o -> !o.getName().equals("resolvePropertyPlaceholders"));	boolean hasConnectorOptions = !model.getConnectorOptions().isEmpty();	int pos = javaType.lastIndexOf(".");	String pkg = javaType.substring(0, pos) + ".springboot";	if (hasComponentOptions || hasConnectorOptions) {	
generating spring boot autoconfiguration for connector 

String fileName = "src/main/resources/META-INF/spring.factories";	File target = new File(root, fileName);	try {	String header = "";	if (includeLicenseHeader) {	InputStream is = getClass().getClassLoader().getResourceAsStream("license-header.txt");	header = loadText(is);	}	String code = sb.toString();	code = header + "\n" + code;	
source code generated 

File target = new File(root, fileName);	try {	String header = "";	if (includeLicenseHeader) {	InputStream is = getClass().getClassLoader().getResourceAsStream("license-header.txt");	header = loadText(is);	}	String code = sb.toString();	code = header + "\n" + code;	FileUtils.write(target, code);	
created file 

File root = classesDirectory.getParentFile().getParentFile();	File target = new File(root, "src/main/java/" + fileName);	try {	String header = "";	if (includeLicenseHeader) {	InputStream is = getClass().getClassLoader().getResourceAsStream("license-header-java.txt");	header = loadText(is);	}	String code = sourceToString(source);	code = header + code;	
source code generated 

if (includeLicenseHeader) {	InputStream is = getClass().getClassLoader().getResourceAsStream("license-header-java.txt");	header = loadText(is);	}	String code = sourceToString(source);	code = header + code;	if (target.exists()) {	String existing = FileUtils.readFileToString(target);	if (!code.equals(existing)) {	FileUtils.write(target, code, false);	
updated existing file 

InputStream is = getClass().getClassLoader().getResourceAsStream("license-header-java.txt");	header = loadText(is);	}	String code = sourceToString(source);	code = header + code;	if (target.exists()) {	String existing = FileUtils.readFileToString(target);	if (!code.equals(existing)) {	FileUtils.write(target, code, false);	} else {	
no changes to existing file 

String code = sourceToString(source);	code = header + code;	if (target.exists()) {	String existing = FileUtils.readFileToString(target);	if (!code.equals(existing)) {	FileUtils.write(target, code, false);	} else {	}	} else {	FileUtils.write(target, code);	
created file 

sb.append("                applicationContext.getEnvironment(),\n");	sb.append("               \"camel.connector.customizer\",\n");	sb.append("               \"camel.connector.").append(name).append(".customizer\",\n");	sb.append("               ((HasId)customizer).getId())\n");	sb.append("            : HierarchicalPropertiesEvaluator.evaluate(\n");	sb.append("                applicationContext.getEnvironment(),\n");	sb.append("               \"camel.connector.customizer\",\n");	sb.append("               \"camel.connector.").append(name).append(".customizer\");\n");	sb.append("\n");	sb.append("        if (useCustomizer) {\n");	
logger debug connector customizer 

sb.append("                applicationContext.getEnvironment(),\n");	sb.append("               \"camel.connector.customizer\",\n");	sb.append("               \"camel.connector.").append(name).append(".\" + entry.getKey() + \".customizer\",\n");	sb.append("               ((HasId)customizer).getId())\n");	sb.append("            : HierarchicalPropertiesEvaluator.evaluate(\n");	sb.append("                applicationContext.getEnvironment(),\n");	sb.append("               \"camel.connector.customizer\",\n");	sb.append("               \"camel.connector.").append(name).append(".\" + entry.getKey() + \".customizer\");\n");	sb.append("\n");	sb.append("        if (useCustomizer) {\n");	
logger debug connector customizer 

========================= camel sample_64 =========================

protected void doStart() throws Exception {	this.client = createClient(component);	handshakeError = null;	handshakeException = null;	connectError = null;	connectException = null;	if (handshakeListener == null) {	handshakeListener = new ClientSessionChannel.MessageListener() {	public void onMessage(ClientSessionChannel channel, Message message) {	
channel meta handshake 

protected void doStart() throws Exception {	this.client = createClient(component);	handshakeError = null;	handshakeException = null;	connectError = null;	connectException = null;	if (handshakeListener == null) {	handshakeListener = new ClientSessionChannel.MessageListener() {	public void onMessage(ClientSessionChannel channel, Message message) {	if (!message.isSuccessful()) {	
handshake failure 

connectException = null;	if (handshakeListener == null) {	handshakeListener = new ClientSessionChannel.MessageListener() {	public void onMessage(ClientSessionChannel channel, Message message) {	if (!message.isSuccessful()) {	handshakeError = (String) message.get(ERROR_FIELD);	handshakeException = getFailure(message);	if (handshakeError != null) {	if (handshakeError.startsWith("401::")) {	try {	
refreshing oauth token 

if (handshakeListener == null) {	handshakeListener = new ClientSessionChannel.MessageListener() {	public void onMessage(ClientSessionChannel channel, Message message) {	if (!message.isSuccessful()) {	handshakeError = (String) message.get(ERROR_FIELD);	handshakeException = getFailure(message);	if (handshakeError != null) {	if (handshakeError.startsWith("401::")) {	try {	session.login(session.getAccessToken());	
refreshed oauth token for re handshake 

handshakeListener = new ClientSessionChannel.MessageListener() {	public void onMessage(ClientSessionChannel channel, Message message) {	if (!message.isSuccessful()) {	handshakeError = (String) message.get(ERROR_FIELD);	handshakeException = getFailure(message);	if (handshakeError != null) {	if (handshakeError.startsWith("401::")) {	try {	session.login(session.getAccessToken());	} catch (SalesforceException e) {	
error renewing oauth token on error 

handshakeException = getFailure(message);	if (handshakeError != null) {	if (handshakeError.startsWith("401::")) {	try {	session.login(session.getAccessToken());	} catch (SalesforceException e) {	}	}	if (handshakeError.startsWith("403::")) {	try {	
cleaning session logout from salesforcesession before restarting client 

if (handshakeError.startsWith("401::")) {	try {	session.login(session.getAccessToken());	} catch (SalesforceException e) {	}	}	if (handshakeError.startsWith("403::")) {	try {	session.logout();	} catch (SalesforceException e) {	
error while cleaning session 

} else if (!listenerMap.isEmpty()) {	reconnecting = true;	}	}	};	}	client.getChannel(META_HANDSHAKE).addListener(handshakeListener);	if (connectListener == null) {	connectListener = new ClientSessionChannel.MessageListener() {	public void onMessage(ClientSessionChannel channel, Message message) {	
channel meta connect 

reconnecting = true;	}	}	};	}	client.getChannel(META_HANDSHAKE).addListener(handshakeListener);	if (connectListener == null) {	connectListener = new ClientSessionChannel.MessageListener() {	public void onMessage(ClientSessionChannel channel, Message message) {	if (!message.isSuccessful()) {	
connect failure 

}	client.getChannel(META_HANDSHAKE).addListener(handshakeListener);	if (connectListener == null) {	connectListener = new ClientSessionChannel.MessageListener() {	public void onMessage(ClientSessionChannel channel, Message message) {	if (!message.isSuccessful()) {	connectError = (String) message.get(ERROR_FIELD);	connectException = getFailure(message);	} else if (reconnecting) {	reconnecting = false;	
refreshing subscriptions to channels on reconnect 

private void restartClient() {	final SalesforceHttpClient httpClient = component.getConfig().getHttpClient();	httpClient.getExecutor().execute(new Runnable() {	public void run() {	
restarting on unexpected disconnect from salesforce 

private void restartClient() {	final SalesforceHttpClient httpClient = component.getConfig().getHttpClient();	httpClient.getExecutor().execute(new Runnable() {	public void run() {	boolean abort = false;	
waiting to disconnect 

private void restartClient() {	final SalesforceHttpClient httpClient = component.getConfig().getHttpClient();	httpClient.getExecutor().execute(new Runnable() {	public void run() {	boolean abort = false;	while (!client.isDisconnected()) {	try {	Thread.sleep(DISCONNECT_INTERVAL);	} catch (InterruptedException e) {	
aborting restart on interrupt 

while (!client.isDisconnected()) {	try {	Thread.sleep(DISCONNECT_INTERVAL);	} catch (InterruptedException e) {	abort = true;	}	}	if (!abort) {	final long backoff = restartBackoff.getAndAdd(backoffIncrement);	if (backoff > maxBackoff) {	
restart aborted after exceeding msecs backoff 

Thread.sleep(DISCONNECT_INTERVAL);	} catch (InterruptedException e) {	abort = true;	}	}	if (!abort) {	final long backoff = restartBackoff.getAndAdd(backoffIncrement);	if (backoff > maxBackoff) {	abort = true;	} else {	
pausing for msecs before restart attempt 

}	}	if (!abort) {	final long backoff = restartBackoff.getAndAdd(backoffIncrement);	if (backoff > maxBackoff) {	abort = true;	} else {	try {	Thread.sleep(backoff);	} catch (InterruptedException e) {	
aborting restart on interrupt 

} catch (InterruptedException e) {	abort = true;	}	}	if (!abort) {	Exception lastError = new SalesforceException("Unknown error", null);	try {	doStop();	doStart();	} catch (Exception e) {	
error restarting 

}	if (!abort) {	Exception lastError = new SalesforceException("Unknown error", null);	try {	doStop();	doStart();	} catch (Exception e) {	lastError = e;	}	if (client.isHandshook()) {	
successfully restarted 

Exception lastError = new SalesforceException("Unknown error", null);	try {	doStop();	doStart();	} catch (Exception e) {	lastError = e;	}	if (client.isHandshook()) {	restartBackoff.set(client.getBackoffIncrement());	} else {	
failed to restart after pausing for msecs 

protected void doStop() throws Exception {	client.getChannel(META_DISCONNECT).removeListener(disconnectListener);	client.getChannel(META_CONNECT).removeListener(connectListener);	client.getChannel(META_HANDSHAKE).removeListener(handshakeListener);	boolean disconnected = client.disconnect(timeout);	if (!disconnected) {	
could not disconnect client connected to after msec 

public void subscribe(final String topicName, final SalesforceConsumer consumer) {	final String channelName = getChannelName(topicName);	setupReplay((SalesforceEndpoint) consumer.getEndpoint());	
subscribing to channel 

public void subscribe(final String topicName, final SalesforceConsumer consumer) {	final String channelName = getChannelName(topicName);	setupReplay((SalesforceEndpoint) consumer.getEndpoint());	final ClientSessionChannel.MessageListener listener = new ClientSessionChannel.MessageListener() {	public void onMessage(ClientSessionChannel channel, Message message) {	
received message 

final String channelName = getChannelName(topicName);	setupReplay((SalesforceEndpoint) consumer.getEndpoint());	final ClientSessionChannel.MessageListener listener = new ClientSessionChannel.MessageListener() {	public void onMessage(ClientSessionChannel channel, Message message) {	consumer.processMessage(channel, message);	}	};	final ClientSessionChannel clientChannel = client.getChannel(channelName);	final ClientSessionChannel.MessageListener subscriptionListener = new ClientSessionChannel.MessageListener() {	public void onMessage(ClientSessionChannel channel, Message message) {	
channel meta subscribe 

if (channelName.equals(subscribedChannelName)) {	if (!message.isSuccessful()) {	String error = (String) message.get(ERROR_FIELD);	if (error == null) {	error = "Missing error message";	}	Exception failure = getFailure(message);	String msg = String.format("Error subscribing to %s: %s", topicName, failure != null ? failure.getMessage() : error);	consumer.handleException(msg, new SalesforceException(msg, failure));	} else {	
subscribed to channel 

public void unsubscribe(String topicName, SalesforceConsumer consumer) throws CamelException {	final String channelName = getChannelName(topicName);	final CountDownLatch latch = new CountDownLatch(1);	final String[] unsubscribeError = {null};	final Exception[] unsubscribeFailure = {null};	final ClientSessionChannel.MessageListener unsubscribeListener = new ClientSessionChannel.MessageListener() {	public void onMessage(ClientSessionChannel channel, Message message) {	
channel meta unsubscribe 

final ClientSessionChannel.MessageListener unsubscribeListener = new ClientSessionChannel.MessageListener() {	public void onMessage(ClientSessionChannel channel, Message message) {	Object subscription = message.get(SUBSCRIPTION_FIELD);	if (subscription != null) {	String unsubscribedChannelName = subscription.toString();	if (channelName.equals(unsubscribedChannelName)) {	if (!message.isSuccessful()) {	unsubscribeError[0] = (String) message.get(ERROR_FIELD);	unsubscribeFailure[0] = getFailure(message);	} else {	
unsubscribed from channel 

}	latch.countDown();	}	}	}	};	client.getChannel(META_UNSUBSCRIBE).addListener(unsubscribeListener);	try {	final ClientSessionChannel.MessageListener listener = listenerMap.remove(consumer);	if (listener != null) {	
unsubscribing from channel 

========================= camel sample_14759 =========================

protected RouteBuilder[] createRouteBuilders() throws Exception {	RouteBuilder[] builders = new RouteBuilder[2];	builders[0] = new RouteBuilder() {	String routeId = "mllp-receiver";	public void configure() {	
mllp convertbodyto string class to acknowledged process new passthroughprocessor result log logginglevel debug routeid 

protected RouteBuilder[] createRouteBuilders() throws Exception {	RouteBuilder[] builders = new RouteBuilder[2];	builders[0] = new RouteBuilder() {	String routeId = "mllp-receiver";	public void configure() {	}	};	builders[1] = new RouteBuilder() {	String routeId = "mllp-sender";	public void configure() {	
sending body mllp setbody header mllpconstants mllp acknowledgement 

public void testLoopbackWithMultipleMessages() throws Exception {	int messageCount = 1000;	acknowledged.expectedMessageCount(messageCount);	for (int i = 1; i <= messageCount; ++i) {	
processing message 

========================= camel sample_13835 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<RssComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.rss.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.rss.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_497 =========================

public void tapSomething(String body) {	
wire tapping 

========================= camel sample_2333 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<IronMQComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ironmq.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ironmq.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_478 =========================

SortedMap<String, Properties> map = CamelContextHelper.findComponents(context);	assertNotNull("Should never return null", map);	assertTrue("Component map should never be empty", !map.isEmpty());	String[] expectedComponentNames = {"file", "vm"};	for (String expectedName : expectedComponentNames) {	Properties properties = map.get(expectedName);	assertTrue("Component map contain component: " + expectedName, properties != null);	}	Set<Map.Entry<String, Properties>> entries = map.entrySet();	for (Map.Entry<String, Properties> entry : entries) {	
found component with properties 

========================= camel sample_3522 =========================

}	if (fault) {	if (exchange.hasOut()) {	exchange.getOut().setFault(true);	} else {	exchange.getIn().setFault(true);	}	}	if (!doneSync) {	ExchangeHelper.prepareOutToIn(exchange);	
processing complete for exchangeid 

========================= camel sample_4463 =========================

public void testLoadTestJdbcAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(10);	mock.setResultWaitTime(50 * 1000);	ExecutorService executor = Executors.newFixedThreadPool(10);	
staring to send messages 

MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(10);	mock.setResultWaitTime(50 * 1000);	ExecutorService executor = Executors.newFixedThreadPool(10);	for (int i = 0; i < SIZE; i++) {	final int value = 1;	final int key = i % 10;	executor.submit(new Callable<Object>() {	public Object call() throws Exception {	char id = KEYS[key];	
sending with id 

final int key = i % 10;	executor.submit(new Callable<Object>() {	public Object call() throws Exception {	char id = KEYS[key];	template.sendBodyAndHeader("direct:start", value, "id", "" + id);	Thread.sleep(3);	return null;	}	});	}	
sending all message done now waiting for aggregation to complete 

========================= camel sample_8913 =========================

public void process(Exchange exchange) throws Exception {	String cacheKey = key.evaluate(exchange, String.class);	if (isValid(cacheManager, cacheName, cacheKey)) {	Ehcache cache = cacheManager.getCache(cacheName);	
replacing message body from cachename for key 

========================= camel sample_10521 =========================

public void process(Exchange exchange) throws Exception {	MongoDbOperation operation = endpoint.getOperation();	Object header = exchange.getIn().getHeader(OPERATION_HEADER);	if (header != null) {	
overriding default operation with operation specified on header 

return endpoint.getMongoDatabase();	}	String dynamicDB = exchange.getIn().getHeader(DATABASE, String.class);	MongoDatabase db;	if (dynamicDB == null) {	db = endpoint.getMongoDatabase();	} else {	db = endpoint.getMongoConnection().getDatabase(dynamicDB);	}	if (LOG.isDebugEnabled()) {	
dynamic database selected 

} else {	dbCol = db.getCollection(dynamicCollection, Document.class);	if (dynamicIndex == null) {	endpoint.ensureIndex(dbCol, endpoint.createIndex());	} else {	endpoint.ensureIndex(dbCol, dynamicIndex);	}	}	}	if (LOG.isDebugEnabled()) {	
dynamic database and or collection selected 

========================= camel sample_10464 =========================

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MySimpleToFRoute.java"));	MethodSource<JavaClassSource> method = CamelJavaParserHelper.findConfigureMethod(clazz);	List<CamelEndpointDetails> details = new ArrayList<>();	RouteBuilderParser.parseRouteBuilderEndpoints(clazz, ".", "src/test/java/org/apache/camel/parser/java/MySimpleToFRoute.java", details);	LOG.info("{}", details);	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	
consumer 

MethodSource<JavaClassSource> method = CamelJavaParserHelper.findConfigureMethod(clazz);	List<CamelEndpointDetails> details = new ArrayList<>();	RouteBuilderParser.parseRouteBuilderEndpoints(clazz, ".", "src/test/java/org/apache/camel/parser/java/MySimpleToFRoute.java", details);	LOG.info("{}", details);	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	}	Assert.assertEquals("direct:start", list.get(0).getElement());	list = CamelJavaParserHelper.parseCamelProducerUris(method, true, true);	for (ParserResult result : list) {	
producer 

========================= camel sample_213 =========================

return message;	}	for (LogListener listener : listeners) {	if (listener == null) {	continue;	}	try {	String output = listener.onLog(exchange, logger, message);	message = output != null ? output : message;	} catch (Throwable t) {	
ignoring an exception thrown by 

========================= camel sample_4526 =========================

public void testGetJob() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.job_id", 0L);	headers.put("CamelLinkedIn.fields", null);	final org.apache.camel.component.linkedin.api.model.Job result = requestBodyAndHeaders("direct: assertNotNull("getJob result", result);	
getjob 

========================= camel sample_8856 =========================

public void process(Exchange exchange) {	exchange.getIn().setBody(new MultiSteps("foo@bar.com"));	}	});	results = entityManager.createQuery(queryText).getResultList();	assertEquals("Should have results: " + results, 1, results.size());	MultiSteps mail = (MultiSteps)results.get(0);	assertEquals("address property", "foo@bar.com", mail.getAddress());	consumer = endpoint.createConsumer(new Processor() {	public void process(Exchange e) {	
received exchange 

}	entityManager2.joinTransaction();	List<?> rows = entityManager2.createQuery("select x from MultiSteps x").getResultList();	assertEquals("Number of entities: " + rows, 2, rows.size());	int counter = 1;	for (Object rowObj : rows) {	assertTrue("Rows are not instances of MultiSteps",  rowObj instanceof MultiSteps);	final MultiSteps row = (MultiSteps) rowObj;	LOG.info("entity: " + counter++ + " = " + row);	if (row.getAddress().equals("foo@bar.com")) {	
found updated row 

========================= camel sample_14077 =========================

public void setJmsMessage(Message jmsMessage) {	if (jmsMessage != null) {	try {	setMessageId(jmsMessage.getJMSMessageID());	} catch (JMSException e) {	
unable to retrieve jmsmessageid from jms message 

protected String createMessageId() {	if (jmsMessage == null) {	
no javax jms message set so generating a new message id 

========================= camel sample_7189 =========================

public void process(Exchange exchange) throws Exception {	if (!(exchange.getIn().getBody() instanceof javax.mail.Message)) {	SendEmailRequest request = createMailRequest(exchange);	
sending request from exchange 

public void process(Exchange exchange) throws Exception {	if (!(exchange.getIn().getBody() instanceof javax.mail.Message)) {	SendEmailRequest request = createMailRequest(exchange);	SendEmailResult result = getEndpoint().getSESClient().sendEmail(request);	
received result 

public void process(Exchange exchange) throws Exception {	if (!(exchange.getIn().getBody() instanceof javax.mail.Message)) {	SendEmailRequest request = createMailRequest(exchange);	SendEmailResult result = getEndpoint().getSESClient().sendEmail(request);	Message message = getMessageForResponse(exchange);	message.setHeader(SesConstants.MESSAGE_ID, result.getMessageId());	} else {	SendRawEmailRequest request = createRawMailRequest(exchange);	
sending request from exchange 

public void process(Exchange exchange) throws Exception {	if (!(exchange.getIn().getBody() instanceof javax.mail.Message)) {	SendEmailRequest request = createMailRequest(exchange);	SendEmailResult result = getEndpoint().getSESClient().sendEmail(request);	Message message = getMessageForResponse(exchange);	message.setHeader(SesConstants.MESSAGE_ID, result.getMessageId());	} else {	SendRawEmailRequest request = createRawMailRequest(exchange);	SendRawEmailResult result = getEndpoint().getSESClient().sendRawEmail(request);	
received result 

private com.amazonaws.services.simpleemail.model.RawMessage createRawMessage(Exchange exchange) throws Exception {	com.amazonaws.services.simpleemail.model.RawMessage message = new com.amazonaws.services.simpleemail.model.RawMessage();	javax.mail.Message content = exchange.getIn().getBody(javax.mail.Message.class);	OutputStream byteOutput = new ByteArrayOutputStream();	try {	content.writeTo(byteOutput);	} catch (Exception e) {	
cannot write to byte array 

========================= camel sample_8786 =========================

protected void doStart() throws Exception {	try {	super.doStart();	if (applicationContext == null) {	applicationContext = createDefaultApplicationContext();	}	if (additionalApplicationContext == null) {	additionalApplicationContext = createAdditionalLocationsFromClasspath();	if (additionalApplicationContext != null) {	
starting additional applicationcontext 

super.doStart();	if (applicationContext == null) {	applicationContext = createDefaultApplicationContext();	}	if (additionalApplicationContext == null) {	additionalApplicationContext = createAdditionalLocationsFromClasspath();	if (additionalApplicationContext != null) {	additionalApplicationContext.start();	}	}	
starting spring applicationcontext 

protected void doStop() throws Exception {	super.doStop();	if (additionalApplicationContext != null) {	
stopping additional applicationcontext 

protected void doStop() throws Exception {	super.doStop();	if (additionalApplicationContext != null) {	IOHelper.close(additionalApplicationContext);	}	if (applicationContext != null) {	
stopping spring applicationcontext 

protected AbstractApplicationContext createAdditionalLocationsFromClasspath() throws IOException {	Set<String> locations = new LinkedHashSet<String>();	findLocations(locations, Main.class.getClassLoader());	if (!locations.isEmpty()) {	
found locations for additional spring xml files 

========================= camel sample_16363 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ScpComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.scp.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.scp.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_993 =========================

for (PGPPublicKey key : keys) {	encGen.addMethod(new JcePublicKeyKeyEncryptionMethodGenerator(key));	}	OutputStream encOut = encGen.open(outputStream, new byte[BUFFER_SIZE]);	OutputStream comOut;	if (withCompressedDataPacket) {	PGPCompressedDataGenerator comData = new PGPCompressedDataGenerator(findCompressionAlgorithm(exchange));	comOut = new BufferedOutputStream(comData.open(encOut));	} else {	comOut = encOut;	
no compressed data packet is added 

DecryptedDataAndPPublicKeyEncryptedData encDataAndPbe = getDecryptedData(exchange, in);	encData = encDataAndPbe.getDecryptedData();	PGPObjectFactory pgpFactory = new PGPObjectFactory(encData, new BcKeyFingerprintCalculator());	Object object = pgpFactory.nextObject();	if (object instanceof PGPCompressedData) {	PGPCompressedData comData = (PGPCompressedData) object;	uncompressedData = comData.getDataStream();	pgpFactory = new PGPObjectFactory(uncompressedData, new BcKeyFingerprintCalculator());	object = pgpFactory.nextObject();	} else {	
pgp message does not contain a compressed data packet 

protected void doStart() throws Exception {	if (Security.getProvider(BC) == null && BC.equals(getProvider())) {	
adding bouncycastleprovider as security provider 

protected void doStart() throws Exception {	if (Security.getProvider(BC) == null && BC.equals(getProvider())) {	Security.addProvider(new BouncyCastleProvider());	} else {	
using custom provider which is expected to be enlisted manually 

========================= camel sample_9178 =========================

public void testMasterGoesAway() throws Exception {	candidateOneContext = createNewContext();	candidateTwoContext = createNewContext();	ZooKeeperElection electionCandidate1 = createElectionCandidate(candidateOneContext, 1);	assertTrue("The first candidate was not elected.", electionCandidate1.isMaster());	ZooKeeperElection electionCandidate2 = createElectionCandidate(candidateTwoContext, 1);	assertFalse("The second candidate should not have been elected.", electionCandidate2.isMaster());	
about to shutdown the first candidate 

========================= camel sample_12635 =========================

public void testWSHttpCall() throws Exception {	AsyncHttpClient c = new DefaultAsyncHttpClient();	WebSocket websocket = c.prepareGet("ws: new WebSocketUpgradeHandler.Builder() .addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

========================= camel sample_17437 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	context.getManagementStrategy().getManagementAgent().setStatisticsLevel(ManagementStatisticsLevel.RoutesOnly);	onException(Exception.class).handled(true) .redeliveryDelay(0) .maximumRedeliveries(4).logStackTrace(false) .setBody().constant("Error");	from("direct:start") .to("mock:foo") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	
invoking me 

========================= camel sample_2734 =========================

public DefaultServerInitializerFactory(NettyServerBootstrapConfiguration configuration) {	this.consumer = null;	try {	this.sslContext = createSSLContext(null, configuration);	} catch (Exception e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	}	if (sslContext != null) {	
created sslcontext 

public DefaultServerInitializerFactory(NettyConsumer consumer) {	this.consumer = consumer;	try {	this.sslContext = createSSLContext(consumer.getContext(), consumer.getConfiguration());	} catch (Exception e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	}	if (sslContext != null) {	
created sslcontext 

protected void initChannel(Channel ch) throws Exception {	ChannelPipeline channelPipeline = ch.pipeline();	SslHandler sslHandler = configureServerSSLOnDemand();	if (sslHandler != null) {	
server ssl handler configured and added as an interceptor against the channelpipeline 

decoder = ((ChannelHandlerFactory) decoder).newChannelHandler();	}	addToPipeline("decoder-" + x, channelPipeline, decoder);	}	if (consumer.getConfiguration().isUsingExecutorService()) {	EventExecutorGroup applicationExecutor = consumer.getEndpoint().getComponent().getExecutorService();	addToPipeline("handler", channelPipeline, applicationExecutor, new ServerChannelHandler(consumer));	} else {	addToPipeline("handler", channelPipeline, new ServerChannelHandler(consumer));	}	
created channelpipeline 

private SSLContext createSSLContext(CamelContext camelContext, NettyServerBootstrapConfiguration configuration) throws Exception {	if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(camelContext);	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	
keystorefile is null 

if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(camelContext);	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	
truststorefile is null 

}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(camelContext);	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	}	if (configuration.getPassphrase().toCharArray() == null) {	
passphrase is null 

========================= camel sample_10258 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<ProtobufDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.protobuf.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.protobuf.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_1227 =========================

private ConnectionFactory createConnectionFactory(String uri) throws TimeoutException {	RabbitMQEndpoint endpoint = context.getEndpoint(uri, RabbitMQEndpoint.class);	try {	endpoint.connect(Executors.newSingleThreadExecutor());	} catch (IOException ioExc) {	
rabbitmq not available 

========================= camel sample_14124 =========================

mockEndpointB.expectedBodiesReceived(expectedBody);	invokeHttpEndpoint();	mockEndpointA.assertIsSatisfied();	mockEndpointB.assertIsSatisfied();	List<Exchange> list = mockEndpointA.getReceivedExchanges();	Exchange exchange = list.get(0);	assertNotNull("exchange", exchange);	Message in = exchange.getIn();	assertNotNull("in", in);	Map<String, Object> headers = in.getHeaders();	
headers 

========================= camel sample_10864 =========================

private void waitForActionCalled() throws InterruptedException {	for (int i = 0; i < 50; i++) {	if (action.hasBeenCalled()) {	break;	}	
sleeping for millis to wait for action call 

========================= camel sample_11799 =========================

public boolean sleep() throws InterruptedException {	if (delay < 1000) {	policy.sleep(delay);	return true;	}	StopWatch watch = new StopWatch();	
sleeping for millis until attempting redelivery 

public boolean sleep() throws InterruptedException {	if (delay < 1000) {	policy.sleep(delay);	return true;	}	StopWatch watch = new StopWatch();	while (watch.taken() < delay) {	long delta = delay - watch.taken();	long max = Math.min(1000, delta);	if (max > 0) {	
sleeping for millis until waking up for re check 

return true;	}	StopWatch watch = new StopWatch();	while (watch.taken() < delay) {	long delta = delay - watch.taken();	long max = Math.min(1000, delta);	if (max > 0) {	Thread.sleep(max);	}	if (preparingShutdown && !policy.isAllowRedeliveryWhileStopping()) {	
rejected redelivery while stopping 

public Boolean call() throws Exception {	prepareExchangeForRedelivery(exchange, data);	deliverToOnRedeliveryProcessor(exchange, data);	if (log.isTraceEnabled()) {	
redelivering exchangeid for exchange 

public Boolean call() throws Exception {	prepareExchangeForRedelivery(exchange, data);	deliverToOnRedeliveryProcessor(exchange, data);	if (log.isTraceEnabled()) {	}	EventHelper.notifyExchangeRedelivery(exchange.getContext(), exchange, data.redeliveryCounter);	boolean sync;	if (data.redeliverFromSync) {	sync = outputAsync.process(exchange, new AsyncCallback() {	public void done(boolean doneSync) {	
redelivering exchangeid done sync 

if (isDone(exchange)) {	callback.done(false);	return;	}	processAsyncErrorHandler(exchange, callback, data);	}	});	} else {	sync = outputAsync.process(exchange, new AsyncCallback() {	public void done(boolean doneSync) {	
redelivering exchangeid done sync 

protected boolean isRunAllowed(RedeliveryData data) {	boolean forceShutdown = camelContext.getShutdownStrategy().forceShutdown(this);	if (forceShutdown) {	
isrunallowed false run not allowed as shutdownstrategy is forcing shutting down 

protected boolean isRunAllowed(RedeliveryData data) {	boolean forceShutdown = camelContext.getShutdownStrategy().forceShutdown(this);	if (forceShutdown) {	return false;	}	if (data.redeliveryCounter > 0) {	if (data.currentRedeliveryPolicy.allowRedeliveryWhileStopping) {	
isrunallowed true run allowed as redeliverwhilestopping is enabled 

protected boolean isRunAllowed(RedeliveryData data) {	boolean forceShutdown = camelContext.getShutdownStrategy().forceShutdown(this);	if (forceShutdown) {	return false;	}	if (data.redeliveryCounter > 0) {	if (data.currentRedeliveryPolicy.allowRedeliveryWhileStopping) {	return true;	} else if (preparingShutdown) {	boolean answer = isRunAllowedOnPreparingShutdown();	
isrunallowed run not allowed as we are preparing for shutdown 

}	if (data.redeliveryCounter > 0) {	if (data.currentRedeliveryPolicy.allowRedeliveryWhileStopping) {	return true;	} else if (preparingShutdown) {	boolean answer = isRunAllowedOnPreparingShutdown();	return answer;	}	}	boolean answer = !isStoppingOrStopped();	
isrunallowed run allowed if we are not stopped stopping 

protected boolean isRedeliveryAllowed(RedeliveryData data) {	if (data.redeliveryCounter > 0) {	boolean stopping = isStoppingOrStopped();	if (!preparingShutdown && !stopping) {	
isredeliveryallowed true we are not stopping stopped 

protected boolean isRedeliveryAllowed(RedeliveryData data) {	if (data.redeliveryCounter > 0) {	boolean stopping = isStoppingOrStopped();	if (!preparingShutdown && !stopping) {	return true;	} else {	if (data.currentRedeliveryPolicy.allowRedeliveryWhileStopping) {	
isredeliveryallowed true redelivery allowed as redeliverwhilestopping is enabled 

protected boolean isRedeliveryAllowed(RedeliveryData data) {	if (data.redeliveryCounter > 0) {	boolean stopping = isStoppingOrStopped();	if (!preparingShutdown && !stopping) {	return true;	} else {	if (data.currentRedeliveryPolicy.allowRedeliveryWhileStopping) {	return true;	} else {	
isredeliveryallowed false redelivery not allowed as redeliverwhilestopping is disabled 

public void prepareShutdown(boolean suspendOnly, boolean forced) {	
prepare shutdown on error handler 

public boolean process(final Exchange exchange, final AsyncCallback callback) {	final RedeliveryData data = new RedeliveryData();	data.original = defensiveCopyExchangeIfNeeded(exchange);	while (true) {	if (!isRunAllowed(data)) {	
run not allowed will reject executing exchange 

}	if (data.redeliveryCounter > 0) {	data.redeliveryDelay = determineRedeliveryDelay(exchange, data.currentRedeliveryPolicy, data.redeliveryDelay, data.redeliveryCounter);	if (data.redeliveryDelay > 0) {	if (data.currentRedeliveryPolicy.isAsyncDelayedRedelivery() && !exchange.isTransacted()) {	ObjectHelper.notNull(executorService, "Redelivery is enabled but ExecutorService has not been configured.", this);	data.sync = false;	data.redeliverFromSync = true;	AsyncRedeliveryTask task = new AsyncRedeliveryTask(exchange, callback, data);	if (log.isTraceEnabled()) {	
scheduling redelivery task to run in millis for exchangeid 

protected long determineRedeliveryDelay(Exchange exchange, RedeliveryPolicy redeliveryPolicy, long redeliveryDelay, int redeliveryCounter) {	Message message = exchange.getIn();	Long delay = message.getHeader(Exchange.REDELIVERY_DELAY, Long.class);	if (delay == null) {	delay = redeliveryPolicy.calculateRedeliveryDelay(redeliveryDelay, redeliveryCounter);	
redelivery delay calculated as 

protected long determineRedeliveryDelay(Exchange exchange, RedeliveryPolicy redeliveryPolicy, long redeliveryDelay, int redeliveryCounter) {	Message message = exchange.getIn();	Long delay = message.getHeader(Exchange.REDELIVERY_DELAY, Long.class);	if (delay == null) {	delay = redeliveryPolicy.calculateRedeliveryDelay(redeliveryDelay, redeliveryCounter);	} else {	
redelivery delay is from message header 

protected void processAsyncErrorHandler(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data) {	if (!isRunAllowed(data)) {	
run not allowed will reject executing exchange 

boolean isDeadLetterChannel = isDeadLetterChannel() && target == deadLetter;	deliverToFailureProcessor(target, isDeadLetterChannel, exchange, data, callback);	return;	}	if (data.redeliveryCounter > 0) {	ObjectHelper.notNull(executorService, "Redelivery is enabled but ExecutorService has not been configured.", this);	AsyncRedeliveryTask task = new AsyncRedeliveryTask(exchange, callback, data);	data.redeliveryDelay = determineRedeliveryDelay(exchange, data.currentRedeliveryPolicy, data.redeliveryDelay, data.redeliveryCounter);	if (data.redeliveryDelay > 0) {	if (log.isTraceEnabled()) {	
scheduling redelivery task to run in millis for exchangeid 

protected boolean isDone(Exchange exchange) {	boolean answer = isCancelledOrInterrupted(exchange);	if (!answer) {	answer = exchange.getException() == null || ExchangeHelper.isFailureHandled(exchange) || ExchangeHelper.isRedeliveryExhausted(exchange);	}	
is exchangeid done 

protected boolean isCancelledOrInterrupted(Exchange exchange) {	boolean answer = false;	if (ExchangeHelper.isInterrupted(exchange)) {	exchange.setProperty(Exchange.ROUTE_STOP, Boolean.TRUE);	answer = true;	}	
is exchangeid interrupted 

data.handledPredicate = exceptionPolicy.getHandledPolicy();	data.continuedPredicate = exceptionPolicy.getContinuedPolicy();	data.retryWhilePredicate = exceptionPolicy.getRetryWhilePolicy();	data.useOriginalInMessage = exceptionPolicy.getUseOriginalMessagePolicy() != null && exceptionPolicy.getUseOriginalMessagePolicy();	Processor processor = null;	UnitOfWork uow = exchange.getUnitOfWork();	if (uow != null && uow.getRouteContext() != null) {	String routeId = uow.getRouteContext().getRoute().getId();	processor = exceptionPolicy.getErrorHandler(routeId);	} else if (!exceptionPolicy.getErrorHandlers().isEmpty()) {	
cannot determine current route from exchange with id will fallback and use first error handler 

protected void onExceptionOccurred(Exchange exchange, final RedeliveryData data) {	if (data.onExceptionProcessor == null) {	return;	}	try {	if (log.isTraceEnabled()) {	
onexceptionoccurred processor is processing exchange due exception occurred 

protected void onExceptionOccurred(Exchange exchange, final RedeliveryData data) {	if (data.onExceptionProcessor == null) {	return;	}	try {	if (log.isTraceEnabled()) {	}	data.onExceptionProcessor.process(exchange);	} catch (Throwable e) {	
error during processing onexceptionoccurred this exception is ignored 

protected void onExceptionOccurred(Exchange exchange, final RedeliveryData data) {	if (data.onExceptionProcessor == null) {	return;	}	try {	if (log.isTraceEnabled()) {	}	data.onExceptionProcessor.process(exchange);	} catch (Throwable e) {	}	
onexceptionoccurred processor done 

protected void deliverToOnRedeliveryProcessor(final Exchange exchange, final RedeliveryData data) {	if (data.onRedeliveryProcessor == null) {	return;	}	if (log.isTraceEnabled()) {	
redelivery processor is processing exchange before its redelivered 

if (data.onRedeliveryProcessor == null) {	return;	}	if (log.isTraceEnabled()) {	}	try {	data.onRedeliveryProcessor.process(exchange);	} catch (Throwable e) {	exchange.setException(e);	}	
redelivery processor done 

exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);	exchange.removeProperty(Exchange.ROLLBACK_ONLY);	exchange.removeProperty(Exchange.UNIT_OF_WORK_EXHAUSTED);	handled = true;	} else {	decrementRedeliveryCounter(exchange);	}	boolean allowFailureProcessor = !shouldContinue || !isDeadLetterChannel;	if (allowFailureProcessor && processor != null) {	if (data.useOriginalInMessage) {	
using the original in message instead of current 

handled = true;	} else {	decrementRedeliveryCounter(exchange);	}	boolean allowFailureProcessor = !shouldContinue || !isDeadLetterChannel;	if (allowFailureProcessor && processor != null) {	if (data.useOriginalInMessage) {	Message original = ExchangeHelper.getOriginalInMessage(exchange);	exchange.setIn(original);	if (exchange.hasOut()) {	
removing the out message to avoid some uncertain behavior 

if (data.useOriginalInMessage) {	Message original = ExchangeHelper.getOriginalInMessage(exchange);	exchange.setIn(original);	if (exchange.hasOut()) {	exchange.setOut(null);	}	}	MessageHelper.resetStreamCache(exchange.getIn());	if (onPrepareProcessor != null) {	try {	
onprepare processor is processing exchange 

}	}	MessageHelper.resetStreamCache(exchange.getIn());	if (onPrepareProcessor != null) {	try {	onPrepareProcessor.process(exchange);	} catch (Exception e) {	exchange.setException(e);	}	}	
failure processor is processing exchange 

exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));	UnitOfWork uow = exchange.getUnitOfWork();	if (uow != null && uow.getRouteContext() != null) {	exchange.setProperty(Exchange.FAILURE_ROUTE_ID, uow.getRouteContext().getRoute().getId());	}	final boolean deadLetterChannel = processor == deadLetter;	EventHelper.notifyExchangeFailureHandling(exchange.getContext(), exchange, processor, deadLetterChannel, deadLetterUri);	AsyncProcessor afp = AsyncProcessorConverterHelper.convert(processor);	sync = afp.process(exchange, new AsyncCallback() {	public void done(boolean sync) {	
failure processor done processing exchange 

} finally {	data.sync &= sync;	callback.done(data.sync);	}	}	});	} else {	try {	if (onPrepareProcessor != null) {	try {	
onprepare processor is processing exchange 

protected void prepareExchangeAfterFailure(final Exchange exchange, final RedeliveryData data, final boolean isDeadLetterChannel, final boolean shouldHandle, final boolean shouldContinue) {	Exception newException = exchange.getException();	ExchangeHelper.setFailureHandled(exchange);	boolean alreadySet = exchange.getProperty(Exchange.ERRORHANDLER_HANDLED) != null;	if (alreadySet) {	boolean handled = exchange.getProperty(Exchange.ERRORHANDLER_HANDLED, Boolean.class);	
this exchange has already been marked for handling 

boolean alreadySet = exchange.getProperty(Exchange.ERRORHANDLER_HANDLED) != null;	if (alreadySet) {	boolean handled = exchange.getProperty(Exchange.ERRORHANDLER_HANDLED, Boolean.class);	if (!handled) {	exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class));	exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));	}	return;	}	if (shouldContinue) {	
this exchange is continued 

boolean handled = exchange.getProperty(Exchange.ERRORHANDLER_HANDLED, Boolean.class);	if (!handled) {	exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class));	exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));	}	return;	}	if (shouldContinue) {	prepareExchangeForContinue(exchange, data, isDeadLetterChannel);	} else if (shouldHandle) {	
this exchange is handled so its marked as not failed 

String uri = URISupport.sanitizeUri(deadLetterUri);	String msg = "New exception occurred during processing by the DeadLetterChannel[" + uri + "] due " + newException.getMessage();	if (handled) {	msg += ". The new exception is being handled as deadLetterHandleNewException=true.";	} else {	msg += ". The new exception is not handled as deadLetterHandleNewException=false.";	}	logFailedDelivery(false, true, handled, false, true, exchange, msg, data, newException);	}	if (handled) {	
this exchange is handled so its marked as not failed 

private void prepareExchangeAfterFailureNotHandled(Exchange exchange) {	
this exchange is not handled or continued so its marked as failed 

private boolean isExhausted(Exchange exchange, RedeliveryData data) {	boolean exhausted = exchange.getProperty(Exchange.REDELIVERY_EXHAUSTED, false, Boolean.class);	if (exhausted) {	
this exchange is marked as redelivery exhausted 

private boolean isExhausted(Exchange exchange, RedeliveryData data) {	boolean exhausted = exchange.getProperty(Exchange.REDELIVERY_EXHAUSTED, false, Boolean.class);	if (exhausted) {	return true;	}	boolean rollbackOnly = exchange.getProperty(Exchange.ROLLBACK_ONLY, false, Boolean.class);	if (rollbackOnly) {	
this exchange is marked as rollback only so forcing it to be exhausted 

protected void doStart() throws Exception {	ServiceHelper.startServices(output, outputAsync, deadLetter);	redeliveryEnabled = determineIfRedeliveryIsEnabled();	if (log.isTraceEnabled()) {	
redelivery enabled on error handler 

protected void doStart() throws Exception {	ServiceHelper.startServices(output, outputAsync, deadLetter);	redeliveryEnabled = determineIfRedeliveryIsEnabled();	if (log.isTraceEnabled()) {	}	if (redeliveryEnabled) {	if (executorService == null) {	executorService = camelContext.getErrorHandlerExecutorService();	}	if (log.isDebugEnabled()) {	
using executorservice for redeliveries on error handler 

========================= camel sample_4530 =========================

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MySimpleRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelSimpleExpressions(method);	for (ParserResult simple : list) {	
simple 

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MySimpleRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelSimpleExpressions(method);	for (ParserResult simple : list) {	
line 

========================= camel sample_205 =========================

TwitterMentionComponent connector = new TwitterMentionComponent();	connector.setCamelContext(camelContext);	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, connector, parameters, false);	connector.setOptions(parameters);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ConnectorCustomizer<TwitterMentionComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.connector.customizer", "camel.connector.twitter-mention.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.connector.customizer", "camel.connector.twitter-mention.customizer");	if (useCustomizer) {	
configure connector with customizer 

TwitterMentionComponent connector = new TwitterMentionComponent( entry.getKey());	connector.setCamelContext(camelContext);	try {	IntrospectionSupport.getProperties(entry.getValue(), parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, connector, parameters, false);	connector.setOptions(parameters);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ConnectorCustomizer<TwitterMentionComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.connector.customizer", "camel.connector.twitter-mention." + entry.getKey() + ".customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.connector.customizer", "camel.connector.twitter-mention." + entry.getKey() + ".customizer");	if (useCustomizer) {	
configure connector with customizer 

========================= camel sample_25 =========================

public void afterTest() {	try {	camelContext.stopRoute(CamelTestConfiguration.SIMPLE_ROUTE_ID);	} catch (Exception e) {	
exception trying to stop de routes 

========================= camel sample_12766 =========================

private void sendAcknowledgement(byte[] originalHl7MessageBytes, Exchange exchange) {	
entering sendacknowledgement byte exchange 

final byte bM = 77;	final byte bS = 83;	final byte bA = 65;	final byte bE = 69;	final byte bR = 82;	final byte fieldSeparator = originalHl7MessageBytes[3];	for (int i = 0; i < originalHl7MessageBytes.length; ++i) {	if (MllpProtocolConstants.SEGMENT_DELIMITER == i) {	if (i + 7 < originalHl7MessageBytes.length && bM == originalHl7MessageBytes[i + 1] && bS == originalHl7MessageBytes[i + 2] && bA == originalHl7MessageBytes[i + 3] && fieldSeparator == originalHl7MessageBytes[i + 4]) {	if (fieldSeparator != originalHl7MessageBytes[i + 7]) {	
msa is longer than bytes ignoring trailing bytes 

acknowledgmentTypeBytes[0] = originalHl7MessageBytes[i + 5];	acknowledgmentTypeBytes[1] = originalHl7MessageBytes[i + 6];	try {	acknowledgementMessageType = IOConverter.toString(acknowledgmentTypeBytes, exchange);	} catch (IOException ioEx) {	throw new RuntimeException("Failed to convert acknowledgement message to string", ioEx);	}	if (bA != acknowledgmentTypeBytes[0]) {	switch (acknowledgementMessageBytes[1]) {	case bA: case bR: case bE: break;	
invalid acknowledgement type found in message should be aa ae or ar 

} catch (IOException ioEx) {	throw new RuntimeException("Failed to convert acknowledgement message to string", ioEx);	}	if (bA != acknowledgmentTypeBytes[0]) {	switch (acknowledgementMessageBytes[1]) {	case bA: case bR: case bE: break;	}	}	String acknowledgementTypeProperty = exchange.getProperty(MllpConstants.MLLP_ACKNOWLEDGEMENT_TYPE, String.class);	if (null != acknowledgementTypeProperty && !acknowledgementTypeProperty.equals(acknowledgementMessageType)) {	
acknowledgement type found in message does not match exchange property value using value found in message 

}	}	Message message = exchange.hasOut() ? exchange.getOut() : exchange.getIn();	if (acknowledgementMessageType != null && !acknowledgementMessageType.isEmpty()) {	message.setHeader(MllpConstants.MLLP_ACKNOWLEDGEMENT_TYPE, acknowledgementMessageType);	}	if (mllpBuffer.hasCompleteEnvelope()) {	message.setHeader(MllpConstants.MLLP_ACKNOWLEDGEMENT, mllpBuffer.toMllpPayload());	message.setHeader(MllpConstants.MLLP_ACKNOWLEDGEMENT_STRING, mllpBuffer.toHl7String(IOHelper.getCharsetName(exchange, false)));	if (log.isDebugEnabled()) {	
sending acknowledgement 

mllpBuffer.reset();	}	} else if (acknowledgementMessageBytes != null && acknowledgementMessageBytes.length > 0) {	message.setHeader(MllpConstants.MLLP_ACKNOWLEDGEMENT, acknowledgementMessageBytes);	String acknowledgementMessageString = "";	String exchangeCharset = IOHelper.getCharsetName(exchange, false);	if (exchangeCharset != null && !exchangeCharset.isEmpty()) {	try {	acknowledgementMessageString = new String(acknowledgementMessageBytes, exchangeCharset);	} catch (UnsupportedEncodingException e) {	
failed to covert acknowledgment to string using charset falling back to default charset 

try {	acknowledgementMessageString = new String(acknowledgementMessageBytes, exchangeCharset);	} catch (UnsupportedEncodingException e) {	acknowledgementMessageString = new String(acknowledgementMessageBytes, MllpProtocolConstants.DEFAULT_CHARSET);	}	} else {	acknowledgementMessageString = new String(acknowledgementMessageBytes, MllpProtocolConstants.DEFAULT_CHARSET);	}	message.setHeader(MllpConstants.MLLP_ACKNOWLEDGEMENT_STRING, acknowledgementMessageString);	if (log.isDebugEnabled()) {	
sending acknowledgement 

fieldSeparatorIndexes.add(i);	} else if (MllpProtocolConstants.SEGMENT_DELIMITER == hl7MessageBytes[i]) {	if (fieldSeparator != hl7MessageBytes[i - 1]) {	fieldSeparatorIndexes.add(i);	}	endOfMSH = i;	break;	}	}	if (-1 == endOfMSH) {	
population of message headers failed unable to find the end of the msh segment 

} else if (MllpProtocolConstants.SEGMENT_DELIMITER == hl7MessageBytes[i]) {	if (fieldSeparator != hl7MessageBytes[i - 1]) {	fieldSeparatorIndexes.add(i);	}	endOfMSH = i;	break;	}	}	if (-1 == endOfMSH) {	} else if (consumer.getConfiguration().isHl7Headers()) {	
populating the message headers 

String componentSeparator = new String(hl7MessageBytes, 4, 1, charset);	String[] components = headerValue.split(String.format("\\Q%s\\E", componentSeparator), 3);	message.setHeader(MllpConstants.MLLP_EVENT_TYPE, components[0]);	if (2 <= components.length) {	message.setHeader(MllpConstants.MLLP_TRIGGER_EVENT, components[1]);	}	}	}	}	} else {	
message headers disabled 

String originalThreadName = Thread.currentThread().getName();	Thread.currentThread().setName(createThreadName(clientSocket));	MDC.put(MDCUnitOfWork.MDC_CAMEL_CONTEXT_ID, consumer.getEndpoint().getCamelContext().getName());	Route route = consumer.getRoute();	if (route != null) {	String routeId = route.getId();	if (routeId != null) {	MDC.put(MDCUnitOfWork.MDC_ROUTE_ID, route.getId());	}	}	
starting for 

Route route = consumer.getRoute();	if (route != null) {	String routeId = route.getId();	if (routeId != null) {	MDC.put(MDCUnitOfWork.MDC_ROUTE_ID, route.getId());	}	}	try {	while (running && null != clientSocket && clientSocket.isConnected() && !clientSocket.isClosed()) {	byte[] hl7MessageBytes = null;	
checking for data 

MDC.put(MDCUnitOfWork.MDC_ROUTE_ID, route.getId());	}	}	try {	while (running && null != clientSocket && clientSocket.isConnected() && !clientSocket.isClosed()) {	byte[] hl7MessageBytes = null;	try {	mllpBuffer.readFrom(clientSocket);	if (mllpBuffer.hasCompleteEnvelope()) {	hl7MessageBytes = mllpBuffer.toMllpPayload();	
received byte message 

}	}	try {	while (running && null != clientSocket && clientSocket.isConnected() && !clientSocket.isClosed()) {	byte[] hl7MessageBytes = null;	try {	mllpBuffer.readFrom(clientSocket);	if (mllpBuffer.hasCompleteEnvelope()) {	hl7MessageBytes = mllpBuffer.toMllpPayload();	if (mllpBuffer.hasLeadingOutOfBandData()) {	
ignoring leading out of band data 

try {	while (running && null != clientSocket && clientSocket.isConnected() && !clientSocket.isClosed()) {	byte[] hl7MessageBytes = null;	try {	mllpBuffer.readFrom(clientSocket);	if (mllpBuffer.hasCompleteEnvelope()) {	hl7MessageBytes = mllpBuffer.toMllpPayload();	if (mllpBuffer.hasLeadingOutOfBandData()) {	}	if (mllpBuffer.hasTrailingOutOfBandData()) {	
ignoring trailing out of band data 

if (mllpBuffer.hasCompleteEnvelope()) {	hl7MessageBytes = mllpBuffer.toMllpPayload();	if (mllpBuffer.hasLeadingOutOfBandData()) {	}	if (mllpBuffer.hasTrailingOutOfBandData()) {	}	mllpBuffer.reset();	processMessage(hl7MessageBytes);	} else if (!mllpBuffer.hasStartOfBlock()) {	byte[] payload = mllpBuffer.toByteArray();	
ignoring byte un enveloped payload 

}	if (mllpBuffer.hasTrailingOutOfBandData()) {	}	mllpBuffer.reset();	processMessage(hl7MessageBytes);	} else if (!mllpBuffer.hasStartOfBlock()) {	byte[] payload = mllpBuffer.toByteArray();	mllpBuffer.reset();	} else if (!mllpBuffer.isEmpty()) {	byte[] payload = mllpBuffer.toByteArray();	
partial byte payload received 

} catch (SocketTimeoutException timeoutEx) {	if (mllpBuffer.isEmpty()) {	if (consumer.getConfiguration().hasIdleTimeout()) {	long currentTicks = System.currentTimeMillis();	long lastReceivedMessageTicks = consumer.getConsumerRunnables().get(this);	long idleTime = currentTicks - lastReceivedMessageTicks;	if (idleTime >= consumer.getConfiguration().getIdleTimeout()) {	consumer.getEndpoint().doConnectionClose(clientSocket, true, log);	}	}	
no data received ignoring timeout 

long idleTime = currentTicks - lastReceivedMessageTicks;	if (idleTime >= consumer.getConfiguration().getIdleTimeout()) {	consumer.getEndpoint().doConnectionClose(clientSocket, true, log);	}	}	} else {	mllpBuffer.resetSocket(clientSocket);	if (consumer.getEndpoint().isBridgeErrorHandler()) {	Exchange exchange = consumer.getEndpoint().createExchange(ExchangePattern.InOut);	exchange.setException(new MllpInvalidMessageException("Timeout receiving complete payload", mllpBuffer.toByteArray()));	
exception encountered reading payload sending exception to route 

}	}	} else {	mllpBuffer.resetSocket(clientSocket);	if (consumer.getEndpoint().isBridgeErrorHandler()) {	Exchange exchange = consumer.getEndpoint().createExchange(ExchangePattern.InOut);	exchange.setException(new MllpInvalidMessageException("Timeout receiving complete payload", mllpBuffer.toByteArray()));	try {	consumer.getProcessor().process(exchange);	} catch (Exception e) {	
exception encountered processing exchange with exception encounter reading payload 

} else {	mllpBuffer.resetSocket(clientSocket);	if (consumer.getEndpoint().isBridgeErrorHandler()) {	Exchange exchange = consumer.getEndpoint().createExchange(ExchangePattern.InOut);	exchange.setException(new MllpInvalidMessageException("Timeout receiving complete payload", mllpBuffer.toByteArray()));	try {	consumer.getProcessor().process(exchange);	} catch (Exception e) {	}	} else {	
timeout receiving complete payload timeout receiving complete payload 

} else {	}	}	} catch (MllpSocketException mllpSocketEx) {	if (!mllpBuffer.isEmpty()) {	Exchange exchange = consumer.getEndpoint().createExchange(ExchangePattern.InOut);	exchange.setException(new MllpReceiveException("Exception encountered reading payload", mllpBuffer.toByteArrayAndReset(), mllpSocketEx));	try {	consumer.getProcessor().process(exchange);	} catch (Exception ignoredEx) {	
ingnoring exception encountered processing exchange with exception encounter reading payload 

}	} catch (MllpSocketException mllpSocketEx) {	if (!mllpBuffer.isEmpty()) {	Exchange exchange = consumer.getEndpoint().createExchange(ExchangePattern.InOut);	exchange.setException(new MllpReceiveException("Exception encountered reading payload", mllpBuffer.toByteArrayAndReset(), mllpSocketEx));	try {	consumer.getProcessor().process(exchange);	} catch (Exception ignoredEx) {	}	} else {	
ignoring exception encountered checking for data 

exchange.setException(new MllpReceiveException("Exception encountered reading payload", mllpBuffer.toByteArrayAndReset(), mllpSocketEx));	try {	consumer.getProcessor().process(exchange);	} catch (Exception ignoredEx) {	}	} else {	}	}	}	} catch (Exception unexpectedEx) {	
unexpected exception encountered receiving messages 

consumer.getProcessor().process(exchange);	} catch (Exception ignoredEx) {	}	} else {	}	}	}	} catch (Exception unexpectedEx) {	} finally {	consumer.getConsumerRunnables().remove(this);	
for completed 

========================= camel sample_13874 =========================

priority = this.getPriority();	}	int deliveryMode;	if (JmsMessageHelper.hasProperty(message, JmsConstants.JMS_DELIVERY_MODE)) {	deliveryMode = message.getIntProperty(JmsConstants.JMS_DELIVERY_MODE);	JmsMessageHelper.removeJmsProperty(message, JmsConstants.JMS_DELIVERY_MODE);	} else {	deliveryMode = message.getJMSDeliveryMode();	}	if (LOG.isDebugEnabled()) {	
sending jms message to with message 

deliveryMode = message.getIntProperty(JmsConstants.JMS_DELIVERY_MODE);	JmsMessageHelper.removeJmsProperty(message, JmsConstants.JMS_DELIVERY_MODE);	} else {	deliveryMode = message.getJMSDeliveryMode();	}	if (LOG.isDebugEnabled()) {	}	producer.send(message, deliveryMode, priority, ttl);	} else {	if (LOG.isDebugEnabled()) {	
sending jms message to with message 

deliveryMode = message.getJMSDeliveryMode();	}	if (LOG.isDebugEnabled()) {	}	producer.send(message, deliveryMode, priority, ttl);	} else {	if (LOG.isDebugEnabled()) {	}	super.doSend(producer, message);	if (LOG.isTraceEnabled()) {	
sent jms message to with message 

public JmsOperations createInOnlyTemplate(JmsEndpoint endpoint, boolean pubSubDomain, String destination) {	if (jmsOperations != null) {	return jmsOperations;	}	ConnectionFactory factory = getTemplateConnectionFactory();	JmsTemplate template = new CamelJmsTemplate(this, factory);	template.setPubSubDomain(pubSubDomain);	if (destinationResolver != null) {	template.setDestinationResolver(destinationResolver);	if (endpoint instanceof DestinationEndpoint) {	
you are overloading the destinationresolver property on a destinationendpoint are you sure you want to do that 

========================= camel sample_7170 =========================

protected int poll() throws Exception {	final Exchange exchange = this.getEndpoint().createExchange();	if (firstRun) {	this.query.setStartTime(System.currentTimeMillis());	} else {	this.query.setStartTime(System.currentTimeMillis() - getDelay());	}	final Result result = query.execute();	
processing exchange 

========================= camel sample_12273 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ElasticsearchComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.elasticsearch.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.elasticsearch.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_593 =========================

public void notify(EventObject event) throws Exception {	if (notificationBroadcaster != null) {	String type = event.getClass().getSimpleName();	String message = event.toString();	Notification notification = new Notification(type, source, counter.getAndIncrement(), message);	
broadcasting jmx notification 

========================= camel sample_4588 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<XmlJsonDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.xmljson.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.xmljson.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_747 =========================

public void process(Exchange exchange) throws Exception {	String body = exchange.getIn().getBody(String.class);	List<String> result = null;	exchange.setOut(exchange.getIn());	if (ObjectHelper.isEmpty(body)) {	exchange.getOut().setBody("");	} else if (body.startsWith(LDIF_HEADER)) {	
reading from ldif body 

List<String> result = null;	exchange.setOut(exchange.getIn());	if (ObjectHelper.isEmpty(body)) {	exchange.getOut().setBody("");	} else if (body.startsWith(LDIF_HEADER)) {	result = processLdif(new StringReader(body));	} else {	URL loc;	try {	loc = new URL(body);	
reading from url 

exchange.getOut().setBody("");	} else if (body.startsWith(LDIF_HEADER)) {	result = processLdif(new StringReader(body));	} else {	URL loc;	try {	loc = new URL(body);	result = processLdif(new InputStreamReader(loc.openStream()));	} catch (MalformedURLException e) {	if (log.isDebugEnabled()) {	
failed to parse body as url and ldif 

private String processLdifEntry(LdapConnection conn, LdifEntry ldifEntry) {	try {	if (ldifEntry.isChangeAdd() || ldifEntry.isLdifContent()) {	if (log.isDebugEnabled()) {	
attempting add of 

private String processLdifEntry(LdapConnection conn, LdifEntry ldifEntry) {	try {	if (ldifEntry.isChangeAdd() || ldifEntry.isLdifContent()) {	if (log.isDebugEnabled()) {	}	conn.add(ldifEntry.getEntry());	} else if (ldifEntry.isChangeModify()) {	if (log.isDebugEnabled()) {	
attempting modify of 

if (ldifEntry.isChangeAdd() || ldifEntry.isLdifContent()) {	if (log.isDebugEnabled()) {	}	conn.add(ldifEntry.getEntry());	} else if (ldifEntry.isChangeModify()) {	if (log.isDebugEnabled()) {	}	conn.modify(ldifEntry.getDn(), ldifEntry.getModificationArray());	} else if (ldifEntry.isChangeDelete()) {	if (log.isDebugEnabled()) {	
attempting delete of 

} else if (ldifEntry.isChangeModify()) {	if (log.isDebugEnabled()) {	}	conn.modify(ldifEntry.getDn(), ldifEntry.getModificationArray());	} else if (ldifEntry.isChangeDelete()) {	if (log.isDebugEnabled()) {	}	conn.delete(ldifEntry.getDn());	} else if (ldifEntry.isChangeModDn()) {	if (log.isDebugEnabled()) {	
attempting dn move of 

} else if (ldifEntry.isChangeDelete()) {	if (log.isDebugEnabled()) {	}	conn.delete(ldifEntry.getDn());	} else if (ldifEntry.isChangeModDn()) {	if (log.isDebugEnabled()) {	}	conn.moveAndRename(ldifEntry.getDn(), new Dn(ldifEntry.getNewRdn(), ldifEntry.getNewSuperior()), ldifEntry.isDeleteOldRdn());	} else if (ldifEntry.isChangeModRdn()) {	if (log.isDebugEnabled()) {	
attempting rdn move of 

conn.delete(ldifEntry.getDn());	} else if (ldifEntry.isChangeModDn()) {	if (log.isDebugEnabled()) {	}	conn.moveAndRename(ldifEntry.getDn(), new Dn(ldifEntry.getNewRdn(), ldifEntry.getNewSuperior()), ldifEntry.isDeleteOldRdn());	} else if (ldifEntry.isChangeModRdn()) {	if (log.isDebugEnabled()) {	}	conn.rename(ldifEntry.getDn(), new Rdn(ldifEntry.getNewRdn()), ldifEntry.isDeleteOldRdn());	}	
ldif success 

if (log.isDebugEnabled()) {	}	conn.moveAndRename(ldifEntry.getDn(), new Dn(ldifEntry.getNewRdn(), ldifEntry.getNewSuperior()), ldifEntry.isDeleteOldRdn());	} else if (ldifEntry.isChangeModRdn()) {	if (log.isDebugEnabled()) {	}	conn.rename(ldifEntry.getDn(), new Rdn(ldifEntry.getNewRdn()), ldifEntry.isDeleteOldRdn());	}	return "success";	} catch (LdapException e) {	
failed to apply ldif 

========================= camel sample_8051 =========================

protected void runCamel(ClassLoader newLoader) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, MojoExecutionException {	
running camel in 

protected void runCamel(ClassLoader newLoader) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, MojoExecutionException {	Class<?> type = newLoader.loadClass(mainClass);	Method method = type.getMethod("main", String[].class);	String[] arguments = createArguments();	
starting the camel main with arguments 

public ClassLoader createClassLoader(ClassLoader parent) throws MalformedURLException {	
using classpath 

public ClassLoader createClassLoader(ClassLoader parent) throws MalformedURLException {	int size = classpathElements.size();	URL[] urls = new URL[size];	for (int i = 0; i < size; i++) {	String name = (String) classpathElements.get(i);	File file = new File(name);	urls[i] = file.toURI().toURL();	
url 

========================= camel sample_72 =========================

public void setUp() throws Exception {	byte[] utf = payload.getBytes("utf-8");	byte[] iso = payload.getBytes("iso-8859-1");	
utf utf 

public void setUp() throws Exception {	byte[] utf = payload.getBytes("utf-8");	byte[] iso = payload.getBytes("iso-8859-1");	
iso iso 

public void setUp() throws Exception {	byte[] utf = payload.getBytes("utf-8");	byte[] iso = payload.getBytes("iso-8859-1");	for (byte b : utf) {	
utf byte 

public void setUp() throws Exception {	byte[] utf = payload.getBytes("utf-8");	byte[] iso = payload.getBytes("iso-8859-1");	for (byte b : utf) {	}	for (byte b : iso) {	
iso byte 

========================= camel sample_15277 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<ASN1DataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.asn1.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.asn1.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_602 =========================

}	}	}	if (methodInfo == null && methodMap.size() >= 2) {	methodInfo = chooseMethod(pojo, exchange, null);	}	if (methodInfo == null) {	methodInfo = defaultMethod;	}	if (methodInfo != null) {	
chosen method to invoke on bean 

}	if (methodInfo == null && methodMap.size() >= 2) {	methodInfo = chooseMethod(pojo, exchange, null);	}	if (methodInfo == null) {	methodInfo = defaultMethod;	}	if (methodInfo != null) {	return methodInfo.createMethodInvocation(pojo, methodInfo.hasParameters(), exchange);	}	
cannot find suitable method to invoke on bean 

private void introspect(Class<?> clazz) {	publicConstructors = clazz.getConstructors().length > 0;	MethodsFilter methods = new MethodsFilter(getType());	introspect(clazz, methods);	for (Method method : methods.asReadOnlyList()) {	boolean valid = isValidMethod(clazz, method);	
method is valid 

private void introspect(Class<?> clazz, MethodsFilter filteredMethods) {	clazz = getTargetClass(clazz);	ObjectHelper.notNull(clazz, "clazz", this);	
introspecting class 

private MethodInfo introspect(Class<?> clazz, Method method) {	
introspecting class method 

private MethodInfo introspect(Class<?> clazz, Method method) {	String opName = method.getName();	MethodInfo methodInfo = createMethodInfo(clazz, method);	MethodInfo existingMethodInfo = findMostSpecificOverride(methodInfo);	if (existingMethodInfo != null) {	
this method is already overridden in a subclass so the method from the sub class is preferred 

private MethodInfo introspect(Class<?> clazz, Method method) {	String opName = method.getName();	MethodInfo methodInfo = createMethodInfo(clazz, method);	MethodInfo existingMethodInfo = findMostSpecificOverride(methodInfo);	if (existingMethodInfo != null) {	return existingMethodInfo;	}	
adding operation for method 

protected MethodInfo createMethodInfo(Class<?> clazz, Method method) {	Class<?>[] parameterTypes = method.getParameterTypes();	List<Annotation>[] parametersAnnotations = collectParameterAnnotations(clazz, method);	List<ParameterInfo> parameters = new ArrayList<ParameterInfo>();	List<ParameterInfo> bodyParameters = new ArrayList<ParameterInfo>();	boolean hasCustomAnnotation = false;	boolean hasHandlerAnnotation = ObjectHelper.hasAnnotation(method.getAnnotations(), Handler.class);	int size = parameterTypes.length;	if (LOG.isTraceEnabled()) {	
creating methodinfo for class method having parameters 

boolean hasHandlerAnnotation = ObjectHelper.hasAnnotation(method.getAnnotations(), Handler.class);	int size = parameterTypes.length;	if (LOG.isTraceEnabled()) {	}	for (int i = 0; i < size; i++) {	Class<?> parameterType = parameterTypes[i];	Annotation[] parameterAnnotations = parametersAnnotations[i].toArray(new Annotation[parametersAnnotations[i].size()]);	Expression expression = createParameterUnmarshalExpression(clazz, method, parameterType, parameterAnnotations);	hasCustomAnnotation |= expression != null;	ParameterInfo parameterInfo = new ParameterInfo(i, parameterType, parameterAnnotations, expression);	
parameter 

}	for (int i = 0; i < size; i++) {	Class<?> parameterType = parameterTypes[i];	Annotation[] parameterAnnotations = parametersAnnotations[i].toArray(new Annotation[parametersAnnotations[i].size()]);	Expression expression = createParameterUnmarshalExpression(clazz, method, parameterType, parameterAnnotations);	hasCustomAnnotation |= expression != null;	ParameterInfo parameterInfo = new ParameterInfo(i, parameterType, parameterAnnotations, expression);	parameters.add(parameterInfo);	if (expression == null) {	boolean bodyAnnotation = ObjectHelper.hasAnnotation(parameterAnnotations, Body.class);	
parameter has body annotation 

parameters.add(parameterInfo);	if (expression == null) {	boolean bodyAnnotation = ObjectHelper.hasAnnotation(parameterAnnotations, Body.class);	hasCustomAnnotation |= bodyAnnotation;	if (bodyParameters.isEmpty()) {	if (Exchange.class.isAssignableFrom(parameterType)) {	expression = ExpressionBuilder.exchangeExpression();	} else {	expression = ExpressionBuilder.mandatoryBodyExpression(parameterType, true);	}	
parameter is the body parameter using expression 

if (Exchange.class.isAssignableFrom(parameterType)) {	expression = ExpressionBuilder.exchangeExpression();	} else {	expression = ExpressionBuilder.mandatoryBodyExpression(parameterType, true);	}	parameterInfo.setExpression(expression);	bodyParameters.add(parameterInfo);	} else {	}	}	
parameter has parameter info 

possibleOperations.addAll(localOperationsWithBody);	}	if (localOperationsWithCustomAnnotation != null) {	possibleOperations.addAll(localOperationsWithCustomAnnotation);	}	if (!possibleOperations.isEmpty()) {	MethodInfo answer = null;	if (name != null) {	String parameters = StringHelper.between(name, "(", ")");	if (parameters != null) {	
choosing best matching method matching parameters 

boolean matches = true;	while (it.hasNext()) {	String parameter = (String) it.next();	if (parameter != null) {	parameter = parameter.trim();	}	Class<?> parameterType = BeanHelper.getValidParameterType(parameter);	Class<?> expectedType = info.getParameters().get(index).getType();	if (parameterType != null && expectedType != null) {	if (StringHelper.hasStartToken(parameter, "simple")) {	
evaluating simple expression for parameter to determine the class type of the parameter 

private MethodInfo chooseMethodWithMatchingBody(Exchange exchange, Collection<MethodInfo> operationList, List<MethodInfo> operationsWithCustomAnnotation) throws AmbiguousMethodCallException {	Message in = exchange.getIn();	Object body = in.getBody();	if (body != null) {	Class<?> bodyType = body.getClass();	if (LOG.isTraceEnabled()) {	
matching for method with a single parameter that matches type 

if (LOG.isTraceEnabled()) {	}	List<MethodInfo> possibles = new ArrayList<>();	List<MethodInfo> possiblesWithException = null;	for (MethodInfo methodInfo : operationList) {	boolean out = exchange.getPattern().isOutCapable();	if (out && methodInfo.isReturnTypeVoid()) {	continue;	}	if (methodInfo.bodyParameterMatches(bodyType)) {	
found a possible method 

private MethodInfo chooseBestPossibleMethodInfo(Exchange exchange, Collection<MethodInfo> operationList, Object body, List<MethodInfo> possibles, List<MethodInfo> possiblesWithException, List<MethodInfo> possibleWithCustomAnnotation) throws AmbiguousMethodCallException {	Exception exception = ExpressionBuilder.exchangeExceptionExpression().evaluate(exchange, Exception.class);	if (exception != null && possiblesWithException != null && possiblesWithException.size() == 1) {	
exchange has exception set so we prefer method that also has exception as parameter 

private MethodInfo chooseBestPossibleMethodInfo(Exchange exchange, Collection<MethodInfo> operationList, Object body, List<MethodInfo> possibles, List<MethodInfo> possiblesWithException, List<MethodInfo> possibleWithCustomAnnotation) throws AmbiguousMethodCallException {	Exception exception = ExpressionBuilder.exchangeExceptionExpression().evaluate(exchange, Exception.class);	if (exception != null && possiblesWithException != null && possiblesWithException.size() == 1) {	return possiblesWithException.get(0);	} else if (possibles.size() == 1) {	return possibles.get(0);	} else if (possibles.isEmpty()) {	
no possible methods so now trying to convert body to parameter types 

MethodInfo matched = null;	int matchCounter = 0;	for (MethodInfo methodInfo : operationList) {	if (methodInfo.getBodyParameterType() != null) {	if (methodInfo.getBodyParameterType().isInstance(body)) {	return methodInfo;	}	Object value = exchange.getContext().getTypeConverter().tryConvertTo(methodInfo.getBodyParameterType(), exchange, body);	if (value != null) {	if (LOG.isTraceEnabled()) {	
converted body from to 

matchCounter++;	newBody = value;	matched = methodInfo;	}	}	}	if (matchCounter > 1) {	throw new AmbiguousMethodCallException(exchange, Arrays.asList(matched, matched));	}	if (matched != null) {	
setting converted body 

throw new AmbiguousMethodCallException(exchange, Arrays.asList(matched, matched));	}	if (matched != null) {	Message in = exchange.getIn();	in.setBody(newBody);	return matched;	}	} else {	if (possibleWithCustomAnnotation != null && possibleWithCustomAnnotation.size() == 1) {	MethodInfo answer = possibleWithCustomAnnotation.get(0);	
there are only one method with annotations so we choose it 

return ExpressionBuilder.convertToExpression(inject, parameterType);	} else {	LanguageAnnotation languageAnnotation = annotation.annotationType().getAnnotation(LanguageAnnotation.class);	if (languageAnnotation != null) {	Class<?> type = languageAnnotation.factory();	Object object = camelContext.getInjector().newInstance(type);	if (object instanceof AnnotationExpressionFactory) {	AnnotationExpressionFactory expressionFactory = (AnnotationExpressionFactory) object;	return expressionFactory.createExpression(camelContext, annotation, languageAnnotation, parameterType);	} else {	
ignoring bad annotation on method which declares a factory which does not implement 

========================= camel sample_4834 =========================

public void warning(SAXParseException e) throws SAXException {	if (LOG.isDebugEnabled()) {	
validation warning 

public void error(SAXParseException e) throws SAXException {	if (LOG.isDebugEnabled()) {	
validation error 

public void fatalError(SAXParseException e) throws SAXException {	if (LOG.isDebugEnabled()) {	
validation fatalerror 

========================= camel sample_4567 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SplunkComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.splunk.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.splunk.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_481 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<JsonValidatorComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.json-validator.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.json-validator.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1159 =========================

public void testConvertToDocument() throws Exception {	Document document = converter .convertTo(Document.class, "<?xml version=\"1.0\" encoding=\"UTF-8\"?><hello>world!</hello>");	assertNotNull(document);	
found document 

public void testConvertToSource() throws Exception {	Source source = converter.convertTo(Source.class, "<hello>world!</hello>");	assertNotNull(source);	
found document 

public void testStreamSourceToDomSource() throws Exception {	StreamSource streamSource = new StreamSource(new StringReader("<hello>world!</hello>"));	DOMSource domSource = converter.convertTo(DOMSource.class, streamSource);	assertNotNull("Could not convert to a DOMSource!", domSource);	
found document 

public void testNodeToSourceThenToInputStream() throws Exception {	Document document = converter.convertTo(Document.class, "<?xml version=\"1.0\"?><hello>world!</hello>");	Element element = document.getDocumentElement();	Source source = converter.convertTo(Source.class, element);	assertNotNull("Could not convert from Node to Source!", source);	
found source 

========================= camel sample_1509 =========================

public void onInit(Route route) {	ensureElectionIsCreated();	
route managed by setting route autostartup flag to false 

private void startAllStoppedRoutes() {	try {	lock.lock();	if (!suspendedRoutes.isEmpty()) {	if (log.isDebugEnabled()) {	
route s have been stopped previously by policy restarting 

private void startAllStoppedRoutes() {	try {	lock.lock();	if (!suspendedRoutes.isEmpty()) {	if (log.isDebugEnabled()) {	}	for (Route suspended : suspendedRoutes) {	DefaultCamelContext ctx = (DefaultCamelContext)suspended.getRouteContext().getCamelContext();	while (!ctx.isStarted()) {	
context is not started yet sleeping for a bit 

try {	lock.lock();	if (!suspendedRoutes.isEmpty()) {	if (log.isDebugEnabled()) {	}	for (Route suspended : suspendedRoutes) {	DefaultCamelContext ctx = (DefaultCamelContext)suspended.getRouteContext().getCamelContext();	while (!ctx.isStarted()) {	Thread.sleep(5000);	}	
starting route defined in context 

========================= camel sample_12674 =========================

public HttpServerPipelineFactory(NettyHttpConsumer nettyConsumer) {	this.consumer = nettyConsumer;	this.configuration = nettyConsumer.getConfiguration();	try {	this.sslContext = createSSLContext(consumer.getContext(), consumer.getConfiguration());	} catch (Exception e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	}	if (sslContext != null) {	
created sslcontext 

public ChannelPipeline getPipeline() throws Exception {	ChannelPipeline pipeline = Channels.pipeline();	SslHandler sslHandler = configureServerSSLOnDemand();	if (sslHandler != null) {	sslHandler.setCloseOnSSLException(true);	
server ssl handler configured and added as an interceptor against the channelpipeline 

encoder = ((ChannelHandlerFactory) encoder).newChannelHandler();	}	pipeline.addLast("encoder-" + x, encoder);	}	if (supportCompressed()) {	pipeline.addLast("deflater", new HttpContentCompressor());	}	if (consumer.getConfiguration().isOrderedThreadPoolExecutor()) {	ExecutionHandler executionHandler = new ExecutionHandler(consumer.getEndpoint().getComponent().getExecutorService());	pipeline.addLast("executionHandler", executionHandler);	
using orderedmemoryawarethreadpoolexecutor with core pool size 

private SSLContext createSSLContext(CamelContext camelContext, NettyServerBootstrapConfiguration configuration) throws Exception {	if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(camelContext);	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	
keystorefile is null 

if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(camelContext);	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	
truststorefile is null 

}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(camelContext);	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	}	if (configuration.getPassphrase().toCharArray() == null) {	
passphrase is null 

========================= camel sample_8378 =========================

public void read(PersonBean body, @JXPath("in/body/name") String name) {	this.body = body;	this.name = name;	
read method called on 

========================= camel sample_12805 =========================

public void testTwoRoutesRestartConsumer() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceived(TEST_MESSAGE);	template.sendBody("direct:input", TEST_MESSAGE);	mock.assertIsSatisfied();	resetMocks();	
restarting bar route 

public void testTwoRoutesRestartProducer() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceived(TEST_MESSAGE);	template.sendBody("direct:input", TEST_MESSAGE);	mock.assertIsSatisfied();	resetMocks();	
restarting foo route 

========================= camel sample_13717 =========================

public void onMessage(Message message) {	RuntimeCamelException rce = null;	try {	final Exchange exchange = getEndpoint().createExchange(message, getSession());	
processing exchange id 

RuntimeCamelException rce = null;	try {	final Exchange exchange = getEndpoint().createExchange(message, getSession());	if (isTransacted()) {	if (isSharedJMSSession()) {	exchange.getIn().setHeader(SjmsConstants.JMS_SESSION, getSession());	}	}	try {	if (isTransacted() || isSynchronous()) {	
handling synchronous message 

}	try {	if (isTransacted() || isSynchronous()) {	handleMessage(exchange);	if (exchange.isFailed()) {	synchronization.onFailure(exchange);	} else {	synchronization.onComplete(exchange);	}	} else {	
handling asynchronous message 

========================= camel sample_12413 =========================

Map<String, Object> headers = exchange.getIn().getHeaders();	String id = (headers.containsKey(HEADER_ID)) ? exchange.getIn().getHeader(HEADER_ID, String.class) : endpoint.getId();	int ttl = (headers.containsKey(HEADER_TTL)) ? Integer.parseInt(exchange.getIn().getHeader(HEADER_TTL, String.class)) : DEFAULT_TTL;	if (endpoint.isAutoStartIdForInserts()) {	id = Long.toString(startId);	startId++;	} else if (id == null) {	throw new CouchbaseException(HEADER_ID + " is not specified in message header or endpoint URL.", exchange);	}	if (endpoint.getOperation().equals(COUCHBASE_PUT)) {	
type of operation put 

if (endpoint.isAutoStartIdForInserts()) {	id = Long.toString(startId);	startId++;	} else if (id == null) {	throw new CouchbaseException(HEADER_ID + " is not specified in message header or endpoint URL.", exchange);	}	if (endpoint.getOperation().equals(COUCHBASE_PUT)) {	Object obj = exchange.getIn().getBody();	exchange.getOut().setBody(setDocument(id, ttl, obj, persistTo, replicateTo));	} else if (endpoint.getOperation().equals(COUCHBASE_GET)) {	
type of operation get 

} else if (id == null) {	throw new CouchbaseException(HEADER_ID + " is not specified in message header or endpoint URL.", exchange);	}	if (endpoint.getOperation().equals(COUCHBASE_PUT)) {	Object obj = exchange.getIn().getBody();	exchange.getOut().setBody(setDocument(id, ttl, obj, persistTo, replicateTo));	} else if (endpoint.getOperation().equals(COUCHBASE_GET)) {	Object result = client.get(id);	exchange.getOut().setBody(result);	} else if (endpoint.getOperation().equals(COUCHBASE_DELETE)) {	
type of operation delete 

OperationFuture<Boolean> result = client.set(id, expiry, obj, persistTo, replicateTo);	try {	if (!result.get()) {	throw new Exception("Unable to save Document. " + id);	}	return true;	} catch (Exception e) {	if (retryAttempts <= 0) {	throw e;	} else {	
unable to save document retrying in ms 

========================= camel sample_7710 =========================

public void testList() throws Exception {	Message m1 = createThreadedTestEmail(null);	Message m2 = createThreadedTestEmail(m1.getThreadId());	Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelGoogleMail.q", "subject:\"Hello from camel-google-mail\"");	com.google.api.services.gmail.model.ListThreadsResponse result = requestBodyAndHeaders("direct: assertNotNull("list result", result);	assertTrue(result.getThreads().size() > 0);	
list 

========================= camel sample_12043 =========================

public void leadershipChanged(CamelClusterView view, Optional<CamelClusterMember> leader) {	
cluster view leader changed to 

========================= camel sample_13202 =========================

public void initializeConnection() throws CamelMongoDbException {	
initialising mongodb endpoint 

}	mongoDatabase = mongoConnection.getDatabase(database);	if (mongoDatabase == null) {	throw new CamelMongoDbException("Could not initialise MongoDbComponent. Database " + database + " does not exist.");	}	if (collection != null) {	if (!createCollection && !databaseContainsCollection(collection)) {	throw new CamelMongoDbException("Could not initialise MongoDbComponent. Collection " + collection + " and createCollection is false.");	}	mongoCollection = mongoDatabase.getCollection(collection, BasicDBObject.class);	
mongodb component initialised and endpoint bound to mongodb collection with the following parameters address list db collection 

public void ensureIndex(MongoCollection<BasicDBObject> collection, List<BasicDBObject> dynamicIndex) {	if (dynamicIndex != null && !dynamicIndex.isEmpty()) {	for (BasicDBObject index : dynamicIndex) {	
create bdobject index 

protected void doStart() throws Exception {	if (writeConcern != null && writeConcernRef != null) {	String msg = "Cannot set both writeConcern and writeConcernRef at the same time. Respective values: " + writeConcern + ", " + writeConcernRef + ". Aborting initialization.";	throw new IllegalArgumentException(msg);	}	mongoConnection = CamelContextHelper.mandatoryLookup(getCamelContext(), connectionBean, MongoClient.class);	
resolved the connection with the name as 

protected void doStop() throws Exception {	super.doStop();	if (mongoConnection != null) {	
closing connection 

========================= camel sample_16450 =========================

} else {	if (is == null && isFailOnNullBody()) {	throw new NoJsonBodyValidationException(exchange);	}	}	if (is != null) {	ObjectMapper mapper = new ObjectMapper();	JsonNode node = mapper.readTree(is);	Set<ValidationMessage> errors = localSchema.validate(node);	if (errors.size() > 0) {	
validated json has errors 

throw new NoJsonBodyValidationException(exchange);	}	}	if (is != null) {	ObjectMapper mapper = new ObjectMapper();	JsonNode node = mapper.readTree(is);	Set<ValidationMessage> errors = localSchema.validate(node);	if (errors.size() > 0) {	this.errorHandler.handleErrors(exchange, schema, errors);	} else {	
validated json success 

========================= camel sample_11395 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SpringLdapComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.spring-ldap.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.spring-ldap.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_520 =========================

public Object addingService(ServiceReference<TypeConverterLoader> serviceReference) {	
addingservice bundle 

public Object addingService(ServiceReference<TypeConverterLoader> serviceReference) {	TypeConverterLoader loader = bundleContext.getService(serviceReference);	try {	
loading type converter from bundle 

public void removedService(ServiceReference<TypeConverterLoader> serviceReference, Object o) {	
removedservice bundle 

public void removedService(ServiceReference<TypeConverterLoader> serviceReference, Object o) {	try {	ServiceHelper.stopService(this.delegate);	} catch (Exception e) {	
error stopping service due this exception will be ignored 

answer.loadCoreTypeConverters();	} catch (Exception e) {	throw new RuntimeCamelException("Error loading CoreTypeConverter due: " + e.getMessage(), e);	}	ServiceReference<TypeConverterLoader>[] serviceReferences = this.tracker.getServiceReferences();	if (serviceReferences != null) {	ArrayList<ServiceReference<TypeConverterLoader>> servicesList = new ArrayList<ServiceReference<TypeConverterLoader>>(Arrays.asList(serviceReferences));	Collections.sort(servicesList);	for (ServiceReference<TypeConverterLoader> sr : servicesList) {	try {	
loading type converter from bundle 

ArrayList<ServiceReference<TypeConverterLoader>> servicesList = new ArrayList<ServiceReference<TypeConverterLoader>>(Arrays.asList(serviceReferences));	Collections.sort(servicesList);	for (ServiceReference<TypeConverterLoader> sr : servicesList) {	try {	((TypeConverterLoader)this.tracker.getService(sr)).load(answer);	} catch (Throwable t) {	throw new RuntimeCamelException("Error loading type converters from service: " + sr + " due: " + t.getMessage(), t);	}	}	}	
created typeconverter 

========================= camel sample_13081 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<MsvComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.msv.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.msv.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1017 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<DirectVmComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.direct-vm.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.direct-vm.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_873 =========================

public void process(Exchange exchange) throws Exception {	Message in = exchange.getIn();	RepositoryTag tag = (RepositoryTag) in.getBody();	
got tag 

========================= camel sample_14251 =========================

return Optional.empty();	}	root.put("$schema", "http: root.put("id", String.format("urn:jsonschema:%s:%s)", baseUrn, context.getObjectName()));	root.put("type", "object");	root.put("additionalProperties", false);	root.putObject("properties");	root.putArray("required");	loadProperties(context);	for (String name : names) {	context.getStack().push(name);	
load dictionary 

included = isIncluded || !isExcluded;	} else if (ObjectHelper.isNotEmpty(fields)) {	included = Stream.of(fields.split(",")).map(StringHelper::trimToNull).filter(Objects::nonNull).anyMatch(id::equalsIgnoreCase);	} else if (ObjectHelper.isNotEmpty(exclude)) {	included = !Pattern.compile(exclude).matcher(id).matches();	}	if (!included) {	return;	}	context.getStack().push(id);	
load dictionary element 

========================= camel sample_13594 =========================

Producer producer = directEndpoint.createProducer();	int nummsg = 1;	countLatch = new CountDownLatch(nummsg);	long start = System.currentTimeMillis();	producer.start();	for (int i = 0; i < nummsg; ++i) {	producer.process(exchange);	}	countLatch.await();	long stop = System.currentTimeMillis();	
took milliseconds 

========================= camel sample_15010 =========================

public void messageReceived(ChannelHandlerContext ctx, MessageEvent messageEvent) throws Exception {	Object msg = messageEvent.getMessage();	if (msg instanceof HttpChunk) {	HttpChunk chunk = (HttpChunk) msg;	if (LOG.isTraceEnabled()) {	
httpchunk received islast 

HttpChunkTrailer trailer = (HttpChunkTrailer) msg;	for (Map.Entry<String, String> entry : trailer.trailingHeaders()) {	if (LOG.isTraceEnabled()) {	LOG.trace("Adding trailing header {}={}", entry.getKey(), entry.getValue());	}	response.headers().add(entry.getKey(), entry.getValue());	}	} else {	buffer.writeBytes(chunk.getContent());	if (LOG.isTraceEnabled()) {	
wrote bytes to chunk buffer 

response.setContent(copy);	super.messageReceived(ctx, messageEvent);	}	} else if (msg instanceof HttpResponse) {	response = (HttpResponse) msg;	Exchange exchange = super.getExchange(ctx);	if (!HttpHeaders.isKeepAlive(response)) {	exchange.setProperty(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, true);	}	if (LOG.isTraceEnabled()) {	
httpresponse received chunked 

} else if (msg instanceof HttpResponse) {	response = (HttpResponse) msg;	Exchange exchange = super.getExchange(ctx);	if (!HttpHeaders.isKeepAlive(response)) {	exchange.setProperty(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, true);	}	if (LOG.isTraceEnabled()) {	}	if (response.getStatus().getCode() == HttpResponseStatus.CONTINUE.getCode()) {	if (LOG.isTraceEnabled()) {	
httpresponse received 

if (response.getStatus().getCode() == HttpResponseStatus.CONTINUE.getCode()) {	if (LOG.isTraceEnabled()) {	}	} else if (!response.isChunked()) {	super.messageReceived(ctx, messageEvent);	} else {	buffer = ChannelBuffers.dynamicBuffer();	}	} else {	if (LOG.isTraceEnabled() && msg != null) {	
ignoring non supported response message of type 

========================= camel sample_8373 =========================

public synchronized QueueReference getOrCreateQueue(SedaEndpoint endpoint, Integer size, Boolean multipleConsumers, BlockingQueueFactory<Exchange> customQueueFactory) {	String key = getQueueKey(endpoint.getEndpointUri());	QueueReference ref = getQueues().get(key);	if (ref != null) {	if (size != null && !size.equals(ref.getSize())) {	throw new IllegalArgumentException("Cannot use existing queue " + key + " as the existing queue size " + (ref.getSize() != null ? ref.getSize() : Integer.MAX_VALUE) + " does not match given queue size " + size);	}	ref.addReference(endpoint);	if (log.isDebugEnabled()) {	
reusing existing queue with size and reference count 

if (size != null && size > 0) {	queue = queueFactory.create(size);	} else {	if (getQueueSize() > 0) {	size = getQueueSize();	queue = queueFactory.create(getQueueSize());	} else {	queue = queueFactory.create();	}	}	
created queue with size 

========================= camel sample_4887 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("direct:start") .inOut("activemq:queue:foo?replyTo=queue:bar&useMessageIDAsCorrelationID=true&requestTimeout=2000") .to("mock:result");	from("activemq:queue:foo") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String body = exchange.getIn().getBody(String.class);	if ("World".equals(body)) {	
sleeping for sec to force a timeout 

========================= camel sample_6910 =========================

public boolean isActive() {	if (resolvesTo.isEmpty()) {	try {	resolvesTo.addAll(getLocalIps());	} catch (Exception e) {	
failed to get local ips and resolvesto not specified identifying as inactive 

public boolean isActive() {	if (resolvesTo.isEmpty()) {	try {	resolvesTo.addAll(getLocalIps());	} catch (Exception e) {	return false;	}	}	
resolving 

}	resolved.add(value);	}	} catch (Exception e) {	LOG.warn(hostname, e);	} finally {	if (attributeEnumeration != null) {	try {	attributeEnumeration.close();	} catch (Exception e) {	
failed to close attributeenumeration memory leak possible 

private List<String> getLocalIps() throws Exception {	List<String> localIps = new ArrayList<String>();	Enumeration<NetworkInterface> networkInterfacesEnumeration = NetworkInterface.getNetworkInterfaces();	while (networkInterfacesEnumeration.hasMoreElements()) {	NetworkInterface networkInterface = networkInterfacesEnumeration.nextElement();	Enumeration<InetAddress> inetAddressesEnumeration = networkInterface.getInetAddresses();	while (inetAddressesEnumeration.hasMoreElements()) {	InetAddress inetAddress = inetAddressesEnumeration.nextElement();	String ip = inetAddress.getHostAddress();	
local ip 

========================= camel sample_6506 =========================

protected void dump(RouteContainer context) throws Exception {	Marshaller marshaller = jaxbContext.createMarshaller();	marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);	StringWriter buffer = new StringWriter();	marshaller.marshal(context, buffer);	
created 

========================= camel sample_3704 =========================

if (HeaderConstants.ATTRIBUTE_HEADERS.equalsIgnoreCase(key)) {	Series<Header> series = (Series<Header>) value;	for (Header header: series) {	if (!headerFilterStrategy.applyFilterToExternalHeaders(header.getName(), header.getValue(), exchange)) {	inMessage.setHeader(header.getName(), header.getValue());	}	}	} else {	inMessage.setHeader(key, value);	}	
populate exchange from restlet request header value 

Object value = null;	if (values != null && values.length > 0) {	if (values.length == 1) {	value = values[0];	} else {	value = values;	}	}	if (value == null) {	inMessage.setBody(paramName);	
populate exchange from restlet request body 

value = values[0];	} else {	value = values;	}	}	if (value == null) {	inMessage.setBody(paramName);	} else {	if (!headerFilterStrategy.applyFilterToExternalHeaders(paramName, value, exchange)) {	inMessage.setHeader(paramName, value);	
populate exchange from restlet request user header value 

}	}	request.getAttributes().put(HeaderConstants.ATTRIBUTE_HEADERS, restletHeaders);	exchange.getIn().removeHeader(HeaderConstants.ATTRIBUTE_HEADERS);	}	String login = exchange.getIn().getHeader(RestletConstants.RESTLET_LOGIN, String.class);	String password = exchange.getIn().getHeader(RestletConstants.RESTLET_PASSWORD, String.class);	if (login != null && password != null) {	ChallengeResponse authentication = new ChallengeResponse(ChallengeScheme.HTTP_BASIC, login, password);	request.setChallengeResponse(authentication);	
basic http authentication has been applied 

if (!headerFilterStrategy.applyFilterToCamelHeaders(key, value, exchange)) {	restletHeaders.set(key, value.toString());	}	}	}	} else {	if (!headerFilterStrategy.applyFilterToCamelHeaders(key, value, exchange)) {	restletHeaders.set(key, value.toString());	}	}	
populate restlet request from exchange header value 

}	} else {	if (!headerFilterStrategy.applyFilterToCamelHeaders(key, value, exchange)) {	restletHeaders.set(key, value.toString());	}	}	}	}	if (form != null) {	request.setEntity(form.getWebRepresentation());	
populate restlet request from exchange body as form using media type 

}	}	}	}	if (form != null) {	request.setEntity(form.getWebRepresentation());	} else {	if (request.getMethod() == Method.PUT || request.getMethod() == Method.POST) {	Representation body = createRepresentationFromBody(exchange, mediaType);	request.setEntity(body);	
populate restlet request from exchange body using media type 

}	}	}	if (form != null) {	request.setEntity(form.getWebRepresentation());	} else {	if (request.getMethod() == Method.PUT || request.getMethod() == Method.POST) {	Representation body = createRepresentationFromBody(exchange, mediaType);	request.setEntity(body);	} else {	
populate restlet request from exchange using media type 

} else {	request.setEntity(new EmptyRepresentation());	}	}	org.restlet.Message extensionHeaders = new Request();	HeaderUtils.copyExtensionHeaders(restletHeaders, extensionHeaders);	Series<Header> standardHeaders = new Series<>(Header.class);	standardHeaders.addAll(restletHeaders);	standardHeaders.removeAll(extensionHeaders.getHeaders());	restletHeaders.removeAll(standardHeaders);	
detected request extension headers 

} else {	request.setEntity(new EmptyRepresentation());	}	}	org.restlet.Message extensionHeaders = new Request();	HeaderUtils.copyExtensionHeaders(restletHeaders, extensionHeaders);	Series<Header> standardHeaders = new Series<>(Header.class);	standardHeaders.addAll(restletHeaders);	standardHeaders.removeAll(extensionHeaders.getHeaders());	restletHeaders.removeAll(standardHeaders);	
detected request standard headers 

} else if ("Referer".equalsIgnoreCase(key)) {	request.setReferrerRef(value);	} else if ("Host".equalsIgnoreCase(key)) {	request.setHostRef(value);	} else if ("Date".equalsIgnoreCase(key)) {	Date d = exchange.getContext().getTypeConverter().tryConvertTo(Date.class, exchange, value);	if (d != null) {	request.setDate(d);	}	} else {	
addition of the standard request header is not allowed please use the equivalent property in the restlet api 

Date d = exchange.getContext().getTypeConverter().tryConvertTo(Date.class, exchange, value);	if (d != null) {	response.setDate(d);	}	} else if ("Access-Control-Max-Age".equalsIgnoreCase(key)) {	Integer accessControlMaxAge = exchange.getContext().getTypeConverter().tryConvertTo(Integer.class, exchange, value);	if (accessControlMaxAge != null) {	response.setAccessControlMaxAge(accessControlMaxAge);	}	} else {	
addition of the standard response header is not allowed please use the equivalent property in the restlet api 

if (body instanceof WrappedFile) {	GenericFile<?> gf = (GenericFile<?>) body;	body = gf.getBody();	}	if (body == null) {	response.setEntity("", MediaType.TEXT_PLAIN);	if (Status.SUCCESS_OK.equals(response.getStatus())) {	response.setStatus(Status.SUCCESS_NO_CONTENT);	}	} else if (body instanceof Response) {	
using existing restlet response from exchange body 

response.setEntity(new InputRepresentation(out.getBody(InputStream.class), mediaType));	} else if (body instanceof File) {	response.setEntity(new FileRepresentation(out.getBody(File.class), mediaType));	} else if (body instanceof byte[]) {	byte[] bytes = out.getBody(byte[].class);	response.setEntity(new ByteArrayRepresentation(bytes, mediaType, bytes.length));	} else {	String text = out.getBody(String.class);	response.setEntity(text, mediaType);	}	
populate restlet response from exchange body 

}	}	}	}	org.restlet.Message extensionHeaders = new Request();	HeaderUtils.copyExtensionHeaders(series, extensionHeaders);	Series<Header> standardHeaders = new Series<>(Header.class);	standardHeaders.addAll(series);	standardHeaders.removeAll(extensionHeaders.getHeaders());	series.removeAll(standardHeaders);	
detected response extension headers 

}	}	}	}	org.restlet.Message extensionHeaders = new Request();	HeaderUtils.copyExtensionHeaders(series, extensionHeaders);	Series<Header> standardHeaders = new Series<>(Header.class);	standardHeaders.addAll(series);	standardHeaders.removeAll(extensionHeaders.getHeaders());	series.removeAll(standardHeaders);	
detected response standard headers 

public void populateExchangeFromRestletResponse(Exchange exchange, Response response) throws Exception {	for (Map.Entry<String, Object> entry : response.getAttributes().entrySet()) {	String key = entry.getKey();	Object value = entry.getValue();	if (!headerFilterStrategy.applyFilterToExternalHeaders(key, value, exchange)) {	exchange.getOut().setHeader(key, value);	
populate exchange from restlet response header value 

if (!headerFilterStrategy.applyFilterToExternalHeaders(key, value, exchange)) {	exchange.getOut().setHeader(key, value);	}	}	int responseCode = response.getStatus().getCode();	exchange.getOut().setHeader(Exchange.HTTP_RESPONSE_CODE, responseCode);	exchange.getOut().setHeader(RestletConstants.RESTLET_RESPONSE, response);	if (response.getEntity() != null) {	MediaType mediaType = response.getEntity().getMediaType();	if (mediaType != null) {	
setting the content type to be 

InputStream is = representationDecoded.getStream();	exchange.getOut().setBody(is);	if (autoCloseStream) {	exchange.addOnCompletion(new RestletOnCompletion(is));	}	} else if (response.getEntity() instanceof Representation) {	Representation representationDecoded = new DecodeRepresentation(response.getEntity());	exchange.getOut().setBody(representationDecoded.getText());	} else {	String text = response.getEntity().getText();	
populate exchange from restlet response 

if (value instanceof Calendar) {	message.getEntity().setExpirationDate(((Calendar) value).getTime());	} else if (value instanceof Date) {	message.getEntity().setExpirationDate((Date) value);	} else if (value instanceof String) {	SimpleDateFormat format = new SimpleDateFormat(RFC_2822_DATE_PATTERN, Locale.ENGLISH);	try {	Date date = format.parse((String) value);	message.getEntity().setExpirationDate(date);	} catch (ParseException e) {	
header with value cannot be converted as a date the value will be ignored 

if (value instanceof Calendar) {	message.getEntity().setModificationDate(((Calendar) value).getTime());	} else if (value instanceof Date) {	message.getEntity().setModificationDate((Date) value);	} else if (value instanceof String) {	SimpleDateFormat format = new SimpleDateFormat(RFC_2822_DATE_PATTERN, Locale.ENGLISH);	try {	Date date = format.parse((String) value);	message.getEntity().setModificationDate(date);	} catch (ParseException e) {	
header with value cannot be converted as a date the value will be ignored 

if (header.equalsIgnoreCase(HeaderConstants.HEADER_CONTENT_LENGTH)) {	if (value instanceof Long) {	message.getEntity().setSize((Long) value);	} else if (value instanceof Integer) {	message.getEntity().setSize((Integer) value);	} else {	Long num = exchange.getContext().getTypeConverter().tryConvertTo(Long.class, value);	if (num != null) {	message.getEntity().setSize(num);	} else {	
header with value cannot be converted as a long the value will be ignored 

}	if (header.equalsIgnoreCase(HeaderConstants.HEADER_CONTENT_TYPE)) {	if (value instanceof MediaType) {	message.getEntity().setMediaType((MediaType) value);	} else {	String type = value.toString();	MediaType media = MediaType.valueOf(type);	if (media != null) {	message.getEntity().setMediaType(media);	} else {	
header with value cannot be converted as a mediatype the value will be ignored 

========================= camel sample_9309 =========================

public void someMethod() {	
invoked somemethod 

========================= camel sample_3354 =========================

public boolean verifyServerKey(ClientSession sshClientSession, SocketAddress remoteAddress, PublicKey serverKey) {	
trying to find known hosts file s 

public boolean verifyServerKey(ClientSession sshClientSession, SocketAddress remoteAddress, PublicKey serverKey) {	InputStream knownHostsInputStream = null;	try {	knownHostsInputStream = ResourceHelper.resolveMandatoryResourceAsInputStream(camelContext, knownHostsResource);	List<String> possibleTokens = getKnownHostsFileTokensForSocketAddress(remoteAddress);	
trying to mach publickey against provided known hosts file 

public boolean verifyServerKey(ClientSession sshClientSession, SocketAddress remoteAddress, PublicKey serverKey) {	InputStream knownHostsInputStream = null;	try {	knownHostsInputStream = ResourceHelper.resolveMandatoryResourceAsInputStream(camelContext, knownHostsResource);	List<String> possibleTokens = getKnownHostsFileTokensForSocketAddress(remoteAddress);	PublicKey matchingKey = findKeyForServerToken(knownHostsInputStream, possibleTokens);	if (matchingKey != null) {	
found publickey match for server 

InputStream knownHostsInputStream = null;	try {	knownHostsInputStream = ResourceHelper.resolveMandatoryResourceAsInputStream(camelContext, knownHostsResource);	List<String> possibleTokens = getKnownHostsFileTokensForSocketAddress(remoteAddress);	PublicKey matchingKey = findKeyForServerToken(knownHostsInputStream, possibleTokens);	if (matchingKey != null) {	boolean match = Arrays.areEqual(matchingKey.getEncoded(), serverKey.getEncoded());	return match;	}	} catch (IOException ioException) {	
could not find known hosts file s 

PublicKey matchingKey = findKeyForServerToken(knownHostsInputStream, possibleTokens);	if (matchingKey != null) {	boolean match = Arrays.areEqual(matchingKey.getEncoded(), serverKey.getEncoded());	return match;	}	} catch (IOException ioException) {	} finally {	IOHelper.close(knownHostsInputStream);	}	if (failOnUnknownHost) {	
could not find matching key for client session connection will fail due to configuration 

boolean match = Arrays.areEqual(matchingKey.getEncoded(), serverKey.getEncoded());	return match;	}	} catch (IOException ioException) {	} finally {	IOHelper.close(knownHostsInputStream);	}	if (failOnUnknownHost) {	return false;	} else {	
could not find matching key for client session connection will continue anyway due to configuration 

private PublicKey findKeyForServerToken(InputStream knownHostsInputStream, List<String> possibleTokens) {	String knowHostsLines = camelContext.getTypeConverter().convertTo(String.class, knownHostsInputStream);	if (knowHostsLines == null) {	
could not read from the known hosts file input stream 

private PublicKey findKeyForServerToken(InputStream knownHostsInputStream, List<String> possibleTokens) {	String knowHostsLines = camelContext.getTypeConverter().convertTo(String.class, knownHostsInputStream);	if (knowHostsLines == null) {	return null;	}	for (String s : knowHostsLines.split("\n")) {	String[] parts = s.split(" ");	if (parts.length != 3) {	
found malformed entry in known hosts file 

if (parts.length != 3) {	continue;	}	String entry = parts[0];	String key = parts[2];	for (String serverToken : possibleTokens) {	if (entry.contains(serverToken)) {	try {	return loadKey(key);	} catch (NoSuchAlgorithmException | InvalidKeySpecException e) {	
could not load key for server token s 

========================= camel sample_10029 =========================

was = "delta: " + delta + " millis";	if (timeFrom != null) {	long from = timeFrom.toMillis();	answer = delta >= from;	}	if (answer) {	long to = timeTo.toMillis();	answer = delta <= to;	}	if (LOG.isDebugEnabled()) {	
evaluated time clause with current other 

========================= camel sample_4868 =========================

public HttpServerSharedInitializerFactory(NettySharedHttpServerBootstrapConfiguration configuration, HttpServerConsumerChannelFactory channelFactory, ClassResolver classResolver) {	this.configuration = configuration;	this.channelFactory = channelFactory;	this.classResolver = classResolver != null ? classResolver : new DefaultClassResolver();	try {	this.sslContext = createSSLContext();	} catch (Exception e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	}	if (sslContext != null) {	
created sslcontext 

protected void initChannel(Channel ch) throws Exception {	ChannelPipeline pipeline = ch.pipeline();	SslHandler sslHandler = configureServerSSLOnDemand();	if (sslHandler != null) {	
server ssl handler configured and added as an interceptor against the channelpipeline 

private SSLContext createSSLContext() throws Exception {	if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext();	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	
keystorefile is null 

if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext();	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	
truststorefile is null 

}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext();	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	}	if (configuration.getPassphrase().toCharArray() == null) {	
passphrase is null 

========================= camel sample_16684 =========================

private static void run(String id) {	try {	int events = ThreadLocalRandom.current().nextInt(2, 6);	CountDownLatch contextLatch = new CountDownLatch(events);	ConsulClusterService service = new ConsulClusterService();	service.setId("node-" + id);	
http logger info service geturl 

context.setName("context-" + id);	context.addService(service);	context.addRoutes(new RouteBuilder() {	public void configure() throws Exception {	from("master:my-ns:timer:consul?delay=1s&period=1s") .routeId("route-" + id) .log("From ${routeId}") .process(e -> contextLatch.countDown());	}	});	Thread.sleep(ThreadLocalRandom.current().nextInt(500));	context.start();	contextLatch.await();	
shutting down node 

========================= camel sample_14343 =========================

public synchronized void reconfigure() throws Exception {	
reconfiguring disruptor 

private void start() throws Exception {	
starting disruptor 

Disruptor<ExchangeEvent> newDisruptor = createDisruptor();	newDisruptor.start();	if (executor != null) {	delayedExecutor.executeDelayedCommands(executor);	}	for (final LifecycleAwareExchangeEventHandler handler : handlers) {	boolean eventHandlerStarted = false;	while (!eventHandlerStarted) {	try {	if (!handler.awaitStarted(10, TimeUnit.SECONDS)) {	
disruptor event handler failed to start properly please report 

uniqueConsumerCount = 0;	for (final DisruptorEndpoint endpoint : endpoints) {	final Map<DisruptorConsumer, Collection<LifecycleAwareExchangeEventHandler>> consumerEventHandlers = endpoint.createConsumerEventHandlers();	if (consumerEventHandlers != null) {	uniqueConsumerCount += consumerEventHandlers.keySet().size();	for (Collection<LifecycleAwareExchangeEventHandler> lifecycleAwareExchangeEventHandlers : consumerEventHandlers .values()) {	eventHandlers.addAll(lifecycleAwareExchangeEventHandlers);	}	}	}	
disruptor created with event handlers 

private void resizeThreadPoolExecutor(final int newSize) {	if (executor == null && newSize > 0) {	
creating new executor with threads 

private void resizeThreadPoolExecutor(final int newSize) {	if (executor == null && newSize > 0) {	executor = component.getCamelContext().getExecutorServiceManager().newFixedThreadPool(this, uri, newSize);	} else if (executor != null && newSize <= 0) {	
shutting down executor 

private void resizeThreadPoolExecutor(final int newSize) {	if (executor == null && newSize > 0) {	executor = component.getCamelContext().getExecutorServiceManager().newFixedThreadPool(this, uri, newSize);	} else if (executor != null && newSize <= 0) {	component.getCamelContext().getExecutorServiceManager().shutdown(executor);	executor = null;	} else if (executor instanceof ThreadPoolExecutor) {	
resizing existing executor to threads 

} else if (executor instanceof ThreadPoolExecutor) {	final ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor)executor;	if (newSize <= threadPoolExecutor.getCorePoolSize()) {	threadPoolExecutor.setCorePoolSize(newSize);	threadPoolExecutor.setMaximumPoolSize(newSize);	} else {	threadPoolExecutor.setMaximumPoolSize(newSize);	threadPoolExecutor.setCorePoolSize(newSize);	}	} else if (newSize > 0) {	
shutting down old and creating new executor with threads 

private synchronized void shutdownDisruptor(boolean isReconfiguring) {	
shutting down disruptor reconfiguring 

if (handlers != null && handlers.length == 1 && handlers[0] instanceof BlockingExchangeEventHandler) {	final BlockingExchangeEventHandler blockingExchangeEventHandler = (BlockingExchangeEventHandler)handlers[0];	blockingExchangeEventHandler.unblock();	}	currentDisruptor.shutdown();	for (final LifecycleAwareExchangeEventHandler eventHandler : handlers) {	boolean eventHandlerFinished = false;	while (!eventHandlerFinished) {	try {	if (!eventHandler.awaitStopped(10, TimeUnit.SECONDS)) {	
disruptor event handler failed to shut down properly please report 

public synchronized void addEndpoint(final DisruptorEndpoint disruptorEndpoint) {	
adding endpoint 

public synchronized void addEndpoint(final DisruptorEndpoint disruptorEndpoint) {	endpoints.add(disruptorEndpoint);	
endpoint added new total endpoints 

public synchronized void removeEndpoint(final DisruptorEndpoint disruptorEndpoint) {	
removing endpoint 

public synchronized void removeEndpoint(final DisruptorEndpoint disruptorEndpoint) {	if (getEndpointCount() == 1) {	
last endpoint removed shutdown disruptor 

public synchronized void removeEndpoint(final DisruptorEndpoint disruptorEndpoint) {	if (getEndpointCount() == 1) {	shutdownDisruptor(false);	shutdownExecutor();	}	endpoints.remove(disruptorEndpoint);	
endpoint removed new total endpoints 

public void onEvent(final ExchangeEvent event, final long sequence, final boolean endOfBatch) throws Exception {	blockingLatch.await();	final Exchange exchange = event.getSynchronizedExchange().cancelAndGetOriginalExchange();	if (exchange.getProperty(DisruptorEndpoint.DISRUPTOR_IGNORE_EXCHANGE, false, boolean.class)) {	
ignoring exchange 

========================= camel sample_10750 =========================

public void confirm(CamelContext camelContext, String exchangeId) {	
confirmed id 

========================= camel sample_1943 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<FastjsonDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.json-fastjson.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.json-fastjson.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_577 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<DropboxComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.dropbox.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.dropbox.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_598 =========================

result.expectedMessageCount(1);	template.sendBody("direct:start", "Hello World");	result.assertIsSatisfied();	MBeanServer mbeanServer = getMBeanServer();	ObjectName on = ObjectName.getInstance("org.apache.camel:context=camel-1,type=services,*");	Set<ObjectName> names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	ObjectName onP = ObjectName.getInstance("org.apache.camel:context=camel-1,type=producers,*");	Set<ObjectName> namesP = mbeanServer.queryNames(onP, null);	assertEquals(3, namesP.size());	
adding route 

}	});	MockEndpoint bar = getMockEndpoint("mock:bar");	bar.expectedMessageCount(1);	template.sendBodyAndHeader("direct:bar", "Hello World", "bar", "mock:bar");	bar.assertIsSatisfied();	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	namesP = mbeanServer.queryNames(onP, null);	assertEquals(5, namesP.size());	
removing route 

assertEquals(services, names.size());	namesP = mbeanServer.queryNames(onP, null);	assertEquals(5, namesP.size());	context.stopRoute("bar");	boolean removed = context.removeRoute("bar");	assertTrue(removed);	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	namesP = mbeanServer.queryNames(onP, null);	assertEquals(4, namesP.size());	
shutting down 

========================= camel sample_2683 =========================

private <T> T doConvertTo(Class<T> type, Exchange exchange, Object value) throws Exception {	if (StreamCache.class.isAssignableFrom(value.getClass())) {	return null;	}	if (Future.class.isAssignableFrom(value.getClass())) {	Future<?> future = (Future<?>) value;	if (future.isCancelled()) {	return (T) Void.TYPE;	}	
getting future response 

private <T> T doConvertTo(Class<T> type, Exchange exchange, Object value) throws Exception {	if (StreamCache.class.isAssignableFrom(value.getClass())) {	return null;	}	if (Future.class.isAssignableFrom(value.getClass())) {	Future<?> future = (Future<?>) value;	if (future.isCancelled()) {	return (T) Void.TYPE;	}	Object body = future.get();	
got future response 

========================= camel sample_3991 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<RabbitMQComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.rabbitmq.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.rabbitmq.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_432 =========================

private void writeSlowFile() throws Exception {	
writing slow file 

private void writeSlowFile() throws Exception {	FileOutputStream fos = new FileOutputStream("target/changed/in/slowfile.dat");	for (int i = 0; i < 20; i++) {	fos.write(("Line " + i + LS).getBytes());	
writing line 

private void writeSlowFile() throws Exception {	FileOutputStream fos = new FileOutputStream("target/changed/in/slowfile.dat");	for (int i = 0; i < 20; i++) {	fos.write(("Line " + i + LS).getBytes());	Thread.sleep(50);	}	fos.flush();	fos.close();	
writing slow file done 

========================= camel sample_3138 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<JGroupsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jgroups.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jgroups.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_961 =========================

public Consumer createConsumer(final Processor processor) throws Exception {	final SqlProcessingStrategy proStrategy = new ElsqlSqlProcessingStrategy(elSql);	final SqlPrepareStatementStrategy preStategy = new ElsqlSqlPrepareStatementStrategy();	final SqlParameterSource param = new EmptySqlParameterSource();	final String sql = elSql.getSql(elsqlName, new SpringSqlParams(param));	
elsqlconsumer using sql 

========================= camel sample_13193 =========================

protected void setUp() throws Exception {	utf = "ABC\u00e6".getBytes("utf-8");	deleteDirectory("target/charset");	createDirectory("target/charset/input");	
utf utf 

protected void setUp() throws Exception {	utf = "ABC\u00e6".getBytes("utf-8");	deleteDirectory("target/charset");	createDirectory("target/charset/input");	for (byte b : utf) {	
utf byte 

========================= camel sample_2945 =========================

protected void doStart() throws Exception {	super.doStart();	String verb = getEndpoint().getVerb();	String path = getEndpoint().getPath();	String accept = getEndpoint().getAccept();	boolean matchOnUriPrefix = getEndpoint().getSparkConfiguration().isMatchOnUriPrefix();	if (accept != null) {	
spark rest accepting 

protected void doStart() throws Exception {	super.doStart();	String verb = getEndpoint().getVerb();	String path = getEndpoint().getPath();	String accept = getEndpoint().getAccept();	boolean matchOnUriPrefix = getEndpoint().getSparkConfiguration().isMatchOnUriPrefix();	if (accept != null) {	} else {	
spark rest 

========================= camel sample_7614 =========================

public void onRegistered() {	super.onRegistered();	
onRegistered 

public void onDisconnected() {	super.onDisconnected();	
onDisconnected 

final IRCConnection conn = new IRCConnection(config.getHostname(), config.getPorts(), config.getPassword(), config.getNickname(), config.getUsername(), config.getRealname());	conn.addIRCEventListener(new CodehausIRCEventAdapter());	conn.setEncoding("UTF-8");	conn.setColors(false);	conn.setPong(true);	try {	conn.connect();	} catch (IOException e) {	e.printStackTrace();	}	
Connected 

========================= camel sample_12147 =========================

public void execute(JobExecutionContext context) throws JobExecutionException {	
execute job 

Consumer consumer = route.getConsumer();	if (consumer instanceof Runnable) {	task = (Runnable) consumer;	break;	}	}	}	}	}	if (task != null) {	
running task 

========================= camel sample_14990 =========================

private int doSearch(String searchPhrase, int maxNumberOfHits, Version luceneVersion) throws NullPointerException, ParseException, IOException {	
search phrase 

private int doSearch(String searchPhrase, int maxNumberOfHits, Version luceneVersion) throws NullPointerException, ParseException, IOException {	QueryParser parser = new QueryParser("contents", analyzer);	Query query = parser.parse(searchPhrase);	TopScoreDocCollector collector = TopScoreDocCollector.create(maxNumberOfHits);	indexSearcher.search(query, collector);	hits = collector.topDocs().scoreDocs;	
search generated hits 

========================= camel sample_6843 =========================

public boolean acquireExclusiveReadLock(GenericFileOperations<FTPFile> operations, GenericFile<FTPFile> file, Exchange exchange) throws Exception {	boolean exclusive = false;	
waiting for exclusive read lock to file 

CamelLogger.log(LOG, readLockLoggingLevel, "Cannot acquire read lock within " + timeout + " millis. Will skip the file: " + file);	return false;	}	}	long newLastModified = 0;	long newLength = 0;	List<FTPFile> files;	if (fastExistsCheck) {	String path = file.getAbsoluteFilePath();	if (path.equals("/") || path.equals("\\")) {	
using fast exists to update file information in home directory 

}	}	long newLastModified = 0;	long newLength = 0;	List<FTPFile> files;	if (fastExistsCheck) {	String path = file.getAbsoluteFilePath();	if (path.equals("/") || path.equals("\\")) {	files = operations.listFiles();	} else {	
using fast exists to update file information for 

if (fastExistsCheck) {	String path = file.getAbsoluteFilePath();	if (path.equals("/") || path.equals("\\")) {	files = operations.listFiles();	} else {	files = operations.listFiles(path);	}	} else {	String path = file.getParent();	if (path.equals("/") || path.equals("\\")) {	
using full directory listing in home directory to update file information consider enabling fastexistscheck option 

if (path.equals("/") || path.equals("\\")) {	files = operations.listFiles();	} else {	files = operations.listFiles(path);	}	} else {	String path = file.getParent();	if (path.equals("/") || path.equals("\\")) {	files = operations.listFiles();	} else {	
using full directory listing to update file information for consider enabling fastexistscheck option 

files = operations.listFiles(path);	}	} else {	String path = file.getParent();	if (path.equals("/") || path.equals("\\")) {	files = operations.listFiles();	} else {	files = operations.listFiles(path);	}	}	
list files found files 

} else {	match = f.getName().equals(file.getFileNameOnly());	}	if (match) {	newLength = f.getSize();	if (f.getTimestamp() != null) {	newLastModified = f.getTimestamp().getTimeInMillis();	}	}	}	
previous last modified new last modified 

} else {	match = f.getName().equals(file.getFileNameOnly());	}	if (match) {	newLength = f.getSize();	if (f.getTimestamp() != null) {	newLastModified = f.getTimestamp().getTimeInMillis();	}	}	}	
previous length new length 

match = f.getName().equals(file.getFileNameOnly());	}	if (match) {	newLength = f.getSize();	if (f.getTimestamp() != null) {	newLastModified = f.getTimestamp().getTimeInMillis();	}	}	}	long newOlderThan = startTime + watch.taken() - minAge;	
new older than threshold 

}	if (match) {	newLength = f.getSize();	if (f.getTimestamp() != null) {	newLastModified = f.getTimestamp().getTimeInMillis();	}	}	}	long newOlderThan = startTime + watch.taken() - minAge;	if (newLength >= minLength && ((minAge == 0 && newLastModified == lastModified && newLength == length) || (minAge != 0 && newLastModified < newOlderThan))) {	
read lock acquired 

private boolean sleep() {	
exclusive read lock not granted sleeping for millis 

private boolean sleep() {	try {	Thread.sleep(checkInterval);	return false;	} catch (InterruptedException e) {	
sleep interrupted while waiting for exclusive read lock so breaking out 

========================= camel sample_15397 =========================

protected Object evaluateExpression(String expressionText, String expectedValue) {	Language language = assertResolveLanguage(getLanguageName());	Expression expression = language.createExpression(expressionText);	assertNotNull("No Expression could be created for text: " + expressionText + " language: " + language, expression);	Object value;	if (expectedValue != null) {	value = expression.evaluate(exchange, expectedValue.getClass());	} else {	value = expression.evaluate(exchange, Object.class);	}	
evaluated expression on exchange result 

========================= camel sample_3712 =========================

private void prepareMessageSenders(SpringWebserviceConfiguration configuration) {	if (!(configuration.getTimeout() > -1) && configuration.getSslContextParameters() == null) {	return;	}	WebServiceTemplate webServiceTemplate = configuration.getWebServiceTemplate();	WebServiceMessageSender[] messageSenders = webServiceTemplate.getMessageSenders();	for (int i = 0; i < messageSenders.length; i++) {	WebServiceMessageSender messageSender = messageSenders[i];	if (messageSender instanceof HttpComponentsMessageSender) {	if (configuration.getSslContextParameters() != null) {	
not applying sslcontextparameters based configuration to httpcomponentsmessagesender if you are using this messagesender which you are not by default you will need to configure ssl using the commons http x protocol registry 

WebServiceMessageSender[] messageSenders = webServiceTemplate.getMessageSenders();	for (int i = 0; i < messageSenders.length; i++) {	WebServiceMessageSender messageSender = messageSenders[i];	if (messageSender instanceof HttpComponentsMessageSender) {	if (configuration.getSslContextParameters() != null) {	}	if (configuration.getTimeout() > -1) {	if (messageSender.getClass().equals(HttpComponentsMessageSender.class)) {	((HttpComponentsMessageSender) messageSender).setReadTimeout(configuration.getTimeout());	} else {	
not applying timeout configuration to httpcomponentsmessagesender based implementation you are using what appears to be a custom messagesender which you are not doing by default you will need configure timeout on your own 

}	if (configuration.getTimeout() > -1) {	if (messageSender.getClass().equals(HttpComponentsMessageSender.class)) {	((HttpComponentsMessageSender) messageSender).setReadTimeout(configuration.getTimeout());	} else {	}	}	} else if (messageSender.getClass().equals(HttpUrlConnectionMessageSender.class)) {	messageSenders[i] = new AbstractHttpWebServiceMessageSenderDecorator((HttpUrlConnectionMessageSender) messageSender, configuration, getEndpoint().getCamelContext());	} else {	
ignoring the timeout and sslcontextparameters options for you will need to configure these options directly on your custom configured webservicemessagesender 

========================= camel sample_17129 =========================

protected void doStop() throws Exception {	super.doStop();	if (atomix != null) {	
leaving atomix cluster replica 

private AtomixReplica getOrCreateReplica() throws Exception {	if (atomix == null) {	ObjectHelper.notNull(getCamelContext(), "Camel Context");	ObjectHelper.notNull(address, "Atomix Node Address");	ObjectHelper.notNull(configuration, "Atomix Node Configuration");	atomix = AtomixClusterHelper.createReplica(getCamelContext(), address, configuration);	if (ObjectHelper.isNotEmpty(configuration.getNodes())) {	
bootstrap cluster on address for nodes 

private AtomixReplica getOrCreateReplica() throws Exception {	if (atomix == null) {	ObjectHelper.notNull(getCamelContext(), "Camel Context");	ObjectHelper.notNull(address, "Atomix Node Address");	ObjectHelper.notNull(configuration, "Atomix Node Configuration");	atomix = AtomixClusterHelper.createReplica(getCamelContext(), address, configuration);	if (ObjectHelper.isNotEmpty(configuration.getNodes())) {	this.atomix.bootstrap(configuration.getNodes()).join();	
bootstrap cluster done 

private AtomixReplica getOrCreateReplica() throws Exception {	if (atomix == null) {	ObjectHelper.notNull(getCamelContext(), "Camel Context");	ObjectHelper.notNull(address, "Atomix Node Address");	ObjectHelper.notNull(configuration, "Atomix Node Configuration");	atomix = AtomixClusterHelper.createReplica(getCamelContext(), address, configuration);	if (ObjectHelper.isNotEmpty(configuration.getNodes())) {	this.atomix.bootstrap(configuration.getNodes()).join();	} else {	
bootstrap cluster on address 

private AtomixReplica getOrCreateReplica() throws Exception {	if (atomix == null) {	ObjectHelper.notNull(getCamelContext(), "Camel Context");	ObjectHelper.notNull(address, "Atomix Node Address");	ObjectHelper.notNull(configuration, "Atomix Node Configuration");	atomix = AtomixClusterHelper.createReplica(getCamelContext(), address, configuration);	if (ObjectHelper.isNotEmpty(configuration.getNodes())) {	this.atomix.bootstrap(configuration.getNodes()).join();	} else {	this.atomix.bootstrap().join();	
bootstrap cluster done 

========================= camel sample_10316 =========================

server = new Server(PORT);	port = PORT;	ServletContextHandler servletContext = new ServletContextHandler(ServletContextHandler.SESSIONS);	servletContext.setSecurityHandler(basicAuth("camel", "camelPass", "Private!"));	servletContext.setContextPath("/");	server.setHandler(servletContext);	servletContext.addServlet(new ServletHolder(new MyHttpServlet()), "/*");	try {	server.start();	} catch (Exception ex) {	
could not start server 

public void stopServer() {	if (server != null) {	try {	server.stop();	} catch (Exception ex) {	
server doesn t stop normal 

========================= camel sample_12281 =========================

public void setReplyTo(Destination replyTo) {	
replyto destination 

public Destination getReplyTo() {	if (replyTo != null) {	return replyTo;	}	try {	
waiting for replyto to be set 

public Destination getReplyTo() {	if (replyTo != null) {	return replyTo;	}	try {	boolean done = replyToLatch.await(replyToTimeout, TimeUnit.MILLISECONDS);	if (!done) {	
replyto destination was not set and timeout occurred 

public Destination getReplyTo() {	if (replyTo != null) {	return replyTo;	}	try {	boolean done = replyToLatch.await(replyToTimeout, TimeUnit.MILLISECONDS);	if (!done) {	} else {	
waiting for replyto to be set done 

String correlationID = null;	try {	if (correlationProperty == null) {	correlationID = message.getJMSCorrelationID();	} else {	correlationID = message.getStringProperty(correlationProperty);	}	} catch (JMSException e) {	}	if (correlationID == null) {	
ignoring message with no correlationid 

if (correlationProperty == null) {	correlationID = message.getJMSCorrelationID();	} else {	correlationID = message.getStringProperty(correlationProperty);	}	} catch (JMSException e) {	}	if (correlationID == null) {	return;	}	
received reply message with correlationid 

public void processReply(ReplyHolder holder) {	if (holder != null && isRunAllowed()) {	try {	Exchange exchange = holder.getExchange();	boolean timeout = holder.isTimeout();	if (timeout) {	if (log.isWarnEnabled()) {	
timeout occurred after millis waiting for reply message with correlationid on destination setting exchangetimedoutexception on and continue routing 

}	String msg = "reply message with correlationID: " + holder.getCorrelationId() + " not received on destination: " + replyTo;	exchange.setException(new ExchangeTimedOutException(exchange, holder.getRequestTimeout(), msg));	} else {	Message message = holder.getMessage();	Session session = holder.getSession();	JmsMessage response = new JmsMessage(message, session, endpoint.getBinding());	exchange.setOut(response);	Object body = response.getBody();	if (endpoint.isTransferException() && body instanceof Exception) {	
reply was an exception setting the exception on the exchange 

exchange.setException(new ExchangeTimedOutException(exchange, holder.getRequestTimeout(), msg));	} else {	Message message = holder.getMessage();	Session session = holder.getSession();	JmsMessage response = new JmsMessage(message, session, endpoint.getBinding());	exchange.setOut(response);	Object body = response.getBody();	if (endpoint.isTransferException() && body instanceof Exception) {	exchange.setException((Exception) body);	} else {	
reply received out message body set to reply payload 

exchange.setOut(response);	Object body = response.getBody();	if (endpoint.isTransferException() && body instanceof Exception) {	exchange.setException((Exception) body);	} else {	}	if (endpoint.isTransferFault()) {	Object faultHeader = response.removeHeader(JmsConstants.JMS_TRANSFER_FAULT);	if (faultHeader != null) {	boolean isFault = exchange.getContext().getTypeConverter().tryConvertTo(boolean.class, faultHeader);	
transfer fault on out message 

protected abstract void handleReplyMessage(String correlationID, Message message, Session session);	protected abstract AbstractMessageListenerContainer createListenerContainer() throws Exception;	protected ReplyHandler waitForProvisionCorrelationToBeUpdated(String correlationID, Message message) {	if (log.isWarnEnabled()) {	
early reply received with correlationid 

protected abstract void handleReplyMessage(String correlationID, Message message, Session session);	protected abstract AbstractMessageListenerContainer createListenerContainer() throws Exception;	protected ReplyHandler waitForProvisionCorrelationToBeUpdated(String correlationID, Message message) {	if (log.isWarnEnabled()) {	}	ReplyHandler answer = null;	boolean done = false;	int counter = 0;	while (!done && counter++ < endpoint.getConfiguration().getWaitForProvisionCorrelationToBeUpdatedCounter()) {	
early reply not found handler at attempt waiting a bit longer 

int counter = 0;	while (!done && counter++ < endpoint.getConfiguration().getWaitForProvisionCorrelationToBeUpdatedCounter()) {	try {	Thread.sleep(endpoint.getConfiguration().getWaitForProvisionCorrelationToBeUpdatedThreadSleepingTime());	} catch (InterruptedException e) {	}	answer = correlation.get(correlationID);	done = answer != null;	if (answer != null) {	if (log.isTraceEnabled()) {	
early reply with correlationid has been matched after attempts and can be processed using handler 

protected void doStart() throws Exception {	ObjectHelper.notNull(executorService, "executorService", this);	ObjectHelper.notNull(scheduledExecutorService, "scheduledExecutorService", this);	ObjectHelper.notNull(endpoint, "endpoint", this);	
using timeout checker interval with millis 

protected void doStart() throws Exception {	ObjectHelper.notNull(executorService, "executorService", this);	ObjectHelper.notNull(scheduledExecutorService, "scheduledExecutorService", this);	ObjectHelper.notNull(endpoint, "endpoint", this);	correlation = new CorrelationTimeoutMap(scheduledExecutorService, endpoint.getRequestTimeoutCheckerInterval(), executorService);	ServiceHelper.startService(correlation);	listenerContainer = createListenerContainer();	listenerContainer.afterPropertiesSet();	
starting reply listener container on endpoint 

protected void doStop() throws Exception {	ServiceHelper.stopService(correlation);	if (listenerContainer != null) {	
stopping reply listener container on endpoint 

========================= camel sample_7182 =========================

public void testJobLifecycle() throws Exception {	
testing job lifecycle for of type 

========================= camel sample_14705 =========================

public void request(long l) {	
requested events from subscriber 

sendingQueue = new LinkedList<>();	while (amount > 0) {	sendingQueue.add(buffer.removeFirst());	amount--;	}	}	} finally {	mutex.unlock();	}	if (sendingQueue != null) {	
sending events to the subscriber 

========================= camel sample_11507 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<SerializationDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.serialization.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.serialization.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_832 =========================

if (isJavaVendor("IBM")) {	ibmJDK = true;	}	try {	KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());	InputStream in = ECDSASignatureTest.class.getResourceAsStream("/org/apache/camel/component/crypto/ecdsa.jks");	keyStore.load(in, "security".toCharArray());	privateKey = (PrivateKey) keyStore.getKey("ECDSA", "security".toCharArray());	x509 = (X509Certificate)keyStore.getCertificate("ECDSA");	} catch (Throwable e) {	
cannot setup keystore for running this test due this test is skipped 

========================= camel sample_9173 =========================

public void testOnNextPropagation() throws Exception {	
grpc pingasyncsync method aync test start 

public void testOnCompletedPropagation() throws Exception {	
grpc pingasyncasync method aync test start 

public void onError(Throwable t) {	
Exception 

========================= camel sample_7497 =========================

public void execute() {	DeleteDomainRequest request = new DeleteDomainRequest() .withDomainName(determineDomainName());	
sending request for exchange 

public void execute() {	DeleteDomainRequest request = new DeleteDomainRequest() .withDomainName(determineDomainName());	this.sdbClient.deleteDomain(request);	
request sent 

========================= camel sample_8762 =========================

public void testComment() throws Exception {	File testFile = uploadTestFile();	String fileId = testFile.getId();	Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelGoogleDrive.fileId", fileId);	com.google.api.services.drive.model.Comment comment = new com.google.api.services.drive.model.Comment();	comment.setContent("Camel rocks!");	headers.put("CamelGoogleDrive.content", comment);	requestBodyAndHeaders("direct: com.google.api.services.drive.model.CommentList result1 = requestBody("direct: assertNotNull(result1.get("items"));	
list 

========================= camel sample_15401 =========================

public void testProducerBlocksResumeTest() throws Exception {	context.suspendRoute("foo");	ExecutorService executor = Executors.newSingleThreadExecutor();	executor.submit(new Runnable() {	public void run() {	try {	Thread.sleep(200);	
resuming consumer 

========================= camel sample_2912 =========================

protected void doProcess(Exchange exchange, MetricsEndpoint endpoint, MetricRegistry registry, String metricsName) throws Exception {	Message in = exchange.getIn();	MetricsTimerAction action = endpoint.getAction();	MetricsTimerAction finalAction = in.getHeader(HEADER_TIMER_ACTION, action, MetricsTimerAction.class);	if (finalAction == MetricsTimerAction.start) {	handleStart(exchange, registry, metricsName);	} else if (finalAction == MetricsTimerAction.stop) {	handleStop(exchange, registry, metricsName);	} else {	
no action provided for timer 

========================= camel sample_13701 =========================

public CompletableFuture<Boolean> doFinalize(Function<CamelSagaStep, Optional<Endpoint>> endpointExtractor, String description) {	CompletableFuture<Boolean> result = CompletableFuture.completedFuture(true);	for (CamelSagaStep step : reversed(steps)) {	Optional<Endpoint> endpoint = endpointExtractor.apply(step);	if (endpoint.isPresent()) {	result = result.thenCompose(prevResult -> doFinalize(endpoint.get(), step, 0, description).thenApply(res -> prevResult && res));	}	}	return result.whenComplete((done, ex) -> {	if (ex != null) {	
cannot finalize the saga 

CompletableFuture<Boolean> result = CompletableFuture.completedFuture(true);	for (CamelSagaStep step : reversed(steps)) {	Optional<Endpoint> endpoint = endpointExtractor.apply(step);	if (endpoint.isPresent()) {	result = result.thenCompose(prevResult -> doFinalize(endpoint.get(), step, 0, description).thenApply(res -> prevResult && res));	}	}	return result.whenComplete((done, ex) -> {	if (ex != null) {	} else if (!done) {	
unable to finalize for all required steps of the saga 

private CompletableFuture<Boolean> doFinalize(Endpoint endpoint, CamelSagaStep step, int doneAttempts, String description) {	Exchange exchange = createExchange(endpoint, step);	return CompletableFuture.supplyAsync(() -> {	Exchange res = camelContext.createFluentProducerTemplate().to(endpoint).withExchange(exchange).send();	Exception ex = res.getException();	if (ex != null) {	throw new RuntimeCamelException(res.getException());	}	return true;	}, sagaService.getExecutorService()).exceptionally(ex -> {	
exception thrown during at attempt of 

========================= camel sample_4080 =========================

for (int i = 0; i < map.getLength(); i++) {	Node att = map.item(i);	if (att.getNodeName().equals("uri") || att.getNodeName().endsWith("Uri")) {	final String value = att.getNodeValue();	String before = ObjectHelper.before(value, "?");	String after = ObjectHelper.after(value, "?");	if (before != null && after != null) {	String changed = after.replaceAll("\\s{2,}", "");	if (!after.equals(changed)) {	String newAtr = before.trim() + "?" + changed.trim();	
removed whitespace noise from attribute 

public Metadata parse(Element element, ParserContext context) {	
parsing element 

private Metadata parseCamelContextNode(Element element, ParserContext context) {	
parsing camelcontext 

MutableBeanMetadata regProcessor = context.createMetadata(MutableBeanMetadata.class);	regProcessor.setId(".camelBlueprint.processor.registry." + contextId);	regProcessor.setRuntimeClass(CamelDependenciesFinder.class);	regProcessor.setFactoryComponent(regProcessorFactory);	regProcessor.setFactoryMethod("call");	regProcessor.setProcessor(true);	regProcessor.addDependsOn(".camelBlueprint.processor.bean." + contextId);	regProcessor.addProperty("blueprintContainer", createRef(context, "blueprintContainer"));	context.getComponentDefinitionRegistry().registerComponentDefinition(regProcessor);	injectNamespaces(element, binder);	
parsing camelcontext done returning 

private Metadata parseRouteContextNode(Element element, ParserContext context) {	
parsing routecontext 

factory2.setId(".camelBlueprint.factory." + id);	factory2.setFactoryComponent(factory);	factory2.setFactoryMethod("call");	MutableBeanMetadata ctx = context.createMetadata(MutableBeanMetadata.class);	ctx.setId(id);	ctx.setRuntimeClass(List.class);	ctx.setFactoryComponent(factory2);	ctx.setFactoryMethod("getRoutes");	ctx.setActivation(ACTIVATION_LAZY);	injectNamespaces(element, binder);	
parsing routecontext done returning 

private Metadata parseRestContextNode(Element element, ParserContext context) {	
parsing restcontext 

factory2.setId(".camelBlueprint.factory." + id);	factory2.setFactoryComponent(factory);	factory2.setFactoryMethod("call");	MutableBeanMetadata ctx = context.createMetadata(MutableBeanMetadata.class);	ctx.setId(id);	ctx.setRuntimeClass(List.class);	ctx.setFactoryComponent(factory2);	ctx.setFactoryMethod("getRests");	ctx.setActivation(ACTIVATION_LAZY);	injectNamespaces(element, binder);	
parsing restcontext done returning 

private Metadata parseEndpointNode(Element element, ParserContext context) {	
parsing endpoint 

factory2.setFactoryMethod("call");	factory2.setInitMethod("afterPropertiesSet");	factory2.setDestroyMethod("destroy");	factory2.addProperty("blueprintContainer", createRef(context, "blueprintContainer"));	MutableBeanMetadata ctx = context.createMetadata(MutableBeanMetadata.class);	ctx.setId(id);	ctx.setRuntimeClass(Endpoint.class);	ctx.setFactoryComponent(factory2);	ctx.setFactoryMethod("getObject");	ctx.setActivation(ACTIVATION_LAZY);	
parsing endpoint done returning 

private Metadata parseKeyStoreParametersNode(Element element, ParserContext context) {	
parsing keystoreparameters 

factory2.setFactoryMethod("call");	factory2.setInitMethod("afterPropertiesSet");	factory2.setDestroyMethod("destroy");	factory2.addProperty("blueprintContainer", createRef(context, "blueprintContainer"));	MutableBeanMetadata ctx = context.createMetadata(MutableBeanMetadata.class);	ctx.setId(id);	ctx.setRuntimeClass(KeyStoreParameters.class);	ctx.setFactoryComponent(factory2);	ctx.setFactoryMethod("getObject");	ctx.setActivation(ACTIVATION_LAZY);	
parsing keystoreparameters done returning 

private Metadata parseSecureRandomParametersNode(Element element, ParserContext context) {	
parsing securerandomparameters 

factory2.setFactoryMethod("call");	factory2.setInitMethod("afterPropertiesSet");	factory2.setDestroyMethod("destroy");	factory2.addProperty("blueprintContainer", createRef(context, "blueprintContainer"));	MutableBeanMetadata ctx = context.createMetadata(MutableBeanMetadata.class);	ctx.setId(id);	ctx.setRuntimeClass(SecureRandomParameters.class);	ctx.setFactoryComponent(factory2);	ctx.setFactoryMethod("getObject");	ctx.setActivation(ACTIVATION_LAZY);	
parsing securerandomparameters done returning 

private Metadata parseSSLContextParametersNode(Element element, ParserContext context) {	
parsing sslcontextparameters 

factory2.setFactoryMethod("call");	factory2.setInitMethod("afterPropertiesSet");	factory2.setDestroyMethod("destroy");	factory2.addProperty("blueprintContainer", createRef(context, "blueprintContainer"));	MutableBeanMetadata ctx = context.createMetadata(MutableBeanMetadata.class);	ctx.setId(id);	ctx.setRuntimeClass(SSLContextParameters.class);	ctx.setFactoryComponent(factory2);	ctx.setFactoryMethod("getObject");	ctx.setActivation(ACTIVATION_LAZY);	
parsing sslcontextparameters done returning 

public Object beforeInit(Object bean, String beanName, BeanCreator beanCreator, BeanMetadata beanMetadata) {	
before init of bean 

protected void setterPropertyInjection(Method method, String propertyValue, String propertyDefaultValue, Object bean, String beanName) {	Class<?>[] parameterTypes = method.getParameterTypes();	if (parameterTypes != null) {	if (parameterTypes.length != 1) {	
ignoring badly annotated method for injection due to incorrect number of parameters 

protected void setterBeanInjection(Method method, String name, Object bean, String beanName) {	Class<?>[] parameterTypes = method.getParameterTypes();	if (parameterTypes != null) {	if (parameterTypes.length != 1) {	
ignoring badly annotated method for injection due to incorrect number of parameters 

protected void setterInjection(Method method, Object bean, String beanName, String endpointUri, String endpointRef, String endpointProperty) {	Class<?>[] parameterTypes = method.getParameterTypes();	if (parameterTypes != null) {	if (parameterTypes.length != 1) {	
ignoring badly annotated method for injection due to incorrect number of parameters 

public Object afterInit(Object bean, String beanName, BeanCreator beanCreator, BeanMetadata beanMetadata) {	
after init of bean 

}	if (xml != null) {	dataformats.add(xml);	}	}	try {	for (String component : components) {	if (camelContext.getComponent(component) == null) {	getComponentResolverReference(context, component);	} else {	
not creating a service reference for component because a component already exists in the camel context 

} else {	}	}	for (String language : languages) {	getLanguageResolverReference(context, language);	}	for (String dataformat : dataformats) {	getDataformatResolverReference(context, dataformat);	}	} catch (UnsupportedOperationException e) {	
unable to add dependencies to camel components osgi services the apache aries blueprint implementation used is too old and the blueprint bundle cannot see the org apache camel spi package 

private static boolean validateUri(String uri) {	try {	URISupport.normalizeUri(uri);	} catch (URISyntaxException | UnsupportedEncodingException e) {	
endpoint uri is not valid due to 

========================= camel sample_8109 =========================

return description.getName() + "_" + enumTypeName(field.getName());	} else if (isMultiSelectPicklist(field)) {	if (useStringsForPicklists) {	return String.class.getName() + "[]";	}	return description.getName() + "_" + enumTypeName(field.getName()) + "[]";	} else {	final String soapType = field.getSoapType();	final String type = LOOKUP_MAP.get(soapType.substring(soapType.indexOf(':') + 1));	if (type == null) {	
unsupported field type s in field s of object s 

}	if (outputDirectory.getAbsolutePath().contains("$")) {	outputDirectory = new File("generated-sources/camel-salesforce");	}	final File pkgDir = new File(outputDirectory, packageName.trim().replace('.', File.separatorChar));	if (!pkgDir.exists()) {	if (!pkgDir.mkdirs()) {	throw new MojoExecutionException("Unable to create " + pkgDir);	}	}	
generating java classes 

for (final SObjectDescription description : descriptions.fetched()) {	if (Defaults.IGNORED_OBJECTS.contains(description.getName())) {	continue;	}	try {	processDescription(pkgDir, description, utility, generatedDate);	} catch (final IOException e) {	throw new MojoExecutionException("Unable to generate source files for: " + description.getName(), e);	}	}	
successfully generated s java classes 

========================= camel sample_14928 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<LanguageComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.language.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.language.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_865 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<NagiosComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.nagios.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.nagios.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1001 =========================

public void foo(@Body String body) {	this.body = body;	
foo method called on 

========================= camel sample_3196 =========================

}	Destination replyToDestination;	if (ObjectHelper.isEmpty(getNamedReplyTo())) {	replyToDestination = getEndpoint().getDestinationCreationStrategy().createTemporaryDestination(session, isTopic());	} else {	replyToDestination = getEndpoint().getDestinationCreationStrategy().createDestination(session, getNamedReplyTo(), isTopic());	}	MessageConsumer messageConsumer = getEndpoint().getJmsObjectFactory().createMessageConsumer(session, replyToDestination, null, isTopic(), null, true, false, false);	messageConsumer.setMessageListener(new MessageListener() {	public void onMessage(final Message message) {	
message received in the consumer pool 

}	Destination replyToDestination;	if (ObjectHelper.isEmpty(getNamedReplyTo())) {	replyToDestination = getEndpoint().getDestinationCreationStrategy().createTemporaryDestination(session, isTopic());	} else {	replyToDestination = getEndpoint().getDestinationCreationStrategy().createDestination(session, getNamedReplyTo(), isTopic());	}	MessageConsumer messageConsumer = getEndpoint().getJmsObjectFactory().createMessageConsumer(session, replyToDestination, null, isTopic(), null, true, false, false);	messageConsumer.setMessageListener(new MessageListener() {	public void onMessage(final Message message) {	
message 

} else {	replyToDestination = getEndpoint().getDestinationCreationStrategy().createDestination(session, getNamedReplyTo(), isTopic());	}	MessageConsumer messageConsumer = getEndpoint().getJmsObjectFactory().createMessageConsumer(session, replyToDestination, null, isTopic(), null, true, false, false);	messageConsumer.setMessageListener(new MessageListener() {	public void onMessage(final Message message) {	try {	Exchanger<Object> exchanger = EXCHANGERS.get(message.getJMSCorrelationID());	exchanger.exchange(message, getResponseTimeOut(), TimeUnit.MILLISECONDS);	} catch (Exception e) {	
unable to exchange message 

public void onMessage(final Message message) {	try {	Exchanger<Object> exchanger = EXCHANGERS.get(message.getJMSCorrelationID());	exchanger.exchange(message, getResponseTimeOut(), TimeUnit.MILLISECONDS);	} catch (Exception e) {	}	}	});	answer = new MessageConsumerResources(session, messageConsumer, replyToDestination);	} catch (Exception e) {	
unable to create the messageconsumerresource 

protected void doStart() throws Exception {	if (isEndpointTransacted()) {	throw new IllegalArgumentException("InOut exchange pattern is incompatible with transacted=true as it cuases a deadlock. Please use transacted=false or InOnly exchange pattern.");	}	if (ObjectHelper.isEmpty(getNamedReplyTo())) {	
no reply to destination is defined using temporary destinations 

protected void doStart() throws Exception {	if (isEndpointTransacted()) {	throw new IllegalArgumentException("InOut exchange pattern is incompatible with transacted=true as it cuases a deadlock. Please use transacted=false or InOnly exchange pattern.");	}	if (ObjectHelper.isEmpty(getNamedReplyTo())) {	} else {	
using as the reply to destination 

consumers.returnObject(consumer);	producer.getMessageProducer().send(request);	try {	releaseProducerCallback.release(producer);	} catch (Exception exception) {	}	try {	responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS);	EXCHANGERS.remove(correlationId);	} catch (InterruptedException e) {	
exchanger was interrupted while waiting on response 

try {	releaseProducerCallback.release(producer);	} catch (Exception exception) {	}	try {	responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS);	EXCHANGERS.remove(correlationId);	} catch (InterruptedException e) {	exchange.setException(e);	} catch (TimeoutException e) {	
exchanger timed out while waiting on response 

========================= camel sample_12393 =========================

public String route(Exchange exchange) {	Message message = exchange.getIn().getBody(Message.class);	if (message != null) {	SessionID destinationSession = getDestinationSessionID(message);	if (destinationSession != null) {	String destinationUri = String.format("%s?sessionID=%s", engineUri, destinationSession);	
routing destination 

========================= camel sample_10654 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<AvroDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.avro.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.avro.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_1144 =========================

public Book findBook(String author) throws Exception {	
finding book with author 

public Book findAuthor(String title) throws Exception {	
finding author with book 

========================= camel sample_14617 =========================

protected void initJsch()  {	JSch.setConfig("StrictHostKeyChecking",  "yes");	JSch.setLogger(new com.jcraft.jsch.Logger() {	public boolean isEnabled(int level) {	return level == FATAL || level == ERROR ? LOG.isErrorEnabled() : level == WARN ? LOG.isWarnEnabled() : level == INFO ? LOG.isInfoEnabled() : LOG.isDebugEnabled();	}	public void log(int level, String message) {	if (level == FATAL || level == ERROR) {	
jsch 

protected void initJsch()  {	JSch.setConfig("StrictHostKeyChecking",  "yes");	JSch.setLogger(new com.jcraft.jsch.Logger() {	public boolean isEnabled(int level) {	return level == FATAL || level == ERROR ? LOG.isErrorEnabled() : level == WARN ? LOG.isWarnEnabled() : level == INFO ? LOG.isInfoEnabled() : LOG.isDebugEnabled();	}	public void log(int level, String message) {	if (level == FATAL || level == ERROR) {	} else if (level == WARN) {	
jsch 

JSch.setConfig("StrictHostKeyChecking",  "yes");	JSch.setLogger(new com.jcraft.jsch.Logger() {	public boolean isEnabled(int level) {	return level == FATAL || level == ERROR ? LOG.isErrorEnabled() : level == WARN ? LOG.isWarnEnabled() : level == INFO ? LOG.isInfoEnabled() : LOG.isDebugEnabled();	}	public void log(int level, String message) {	if (level == FATAL || level == ERROR) {	} else if (level == WARN) {	} else if (level == INFO) {	if (isVerboseLogging()) {	
jsch 

JSch.setLogger(new com.jcraft.jsch.Logger() {	public boolean isEnabled(int level) {	return level == FATAL || level == ERROR ? LOG.isErrorEnabled() : level == WARN ? LOG.isWarnEnabled() : level == INFO ? LOG.isInfoEnabled() : LOG.isDebugEnabled();	}	public void log(int level, String message) {	if (level == FATAL || level == ERROR) {	} else if (level == WARN) {	} else if (level == INFO) {	if (isVerboseLogging()) {	} else {	
jsch 

return level == FATAL || level == ERROR ? LOG.isErrorEnabled() : level == WARN ? LOG.isWarnEnabled() : level == INFO ? LOG.isInfoEnabled() : LOG.isDebugEnabled();	}	public void log(int level, String message) {	if (level == FATAL || level == ERROR) {	} else if (level == WARN) {	} else if (level == INFO) {	if (isVerboseLogging()) {	} else {	}	} else {	
jsch 

========================= camel sample_9124 =========================

protected void warnMissingUriParamOnProperty(String name) {	
using property on endpoint which does not have a uriparam annotation please add the uriparam annotation to the field 

========================= camel sample_4151 =========================

try {	return (String) valueMethod.invoke(value);	} catch (IllegalAccessException e) {	throw new IllegalArgumentException(e);	} catch (InvocationTargetException e) {	throw new IllegalArgumentException(e);	}	}	};	} catch (NoSuchMethodException e) {	
enumeration does not follow jaxb convention for conversion 

========================= camel sample_8871 =========================

protected void doService(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {	
service 

protected void doService(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {	HttpConsumer consumer = getServletResolveConsumerStrategy().resolve(request, getConsumers());	if (consumer == null) {	
no consumer to service request 

protected void doService(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {	HttpConsumer consumer = getServletResolveConsumerStrategy().resolve(request, getConsumers());	if (consumer == null) {	response.sendError(HttpServletResponse.SC_NOT_FOUND);	return;	}	if (consumer.isSuspended()) {	
consumer suspended cannot service request 

}	if (consumer.getEndpoint().getHttpMethodRestrict() != null && !consumer.getEndpoint().getHttpMethodRestrict().equals(request.getMethod())) {	response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);	return;	}	if ("TRACE".equals(request.getMethod()) && !consumer.isTraceEnabled()) {	response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);	return;	}	if (!(consumer instanceof WebsocketConsumer)) {	
consumer not supporting websocket 

return;	}	if ("TRACE".equals(request.getMethod()) && !consumer.isTraceEnabled()) {	response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);	return;	}	if (!(consumer instanceof WebsocketConsumer)) {	response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);	return;	}	
dispatching to websocket consumer at 

private void initParameters(ServletConfig config) {	String eventsResendingParameter = config.getInitParameter(RESEND_ALL_WEBSOCKET_EVENTS_PARAM_KEY);	if ("true".equals(eventsResendingParameter)) {	
events resending enabled 

========================= camel sample_10013 =========================

public void testAll() throws Exception {	final List<Plan> result = requestBody("direct: assertNotNull("all result", result);	
all 

========================= camel sample_17386 =========================

public Metadata parse(Element element, ParserContext context) {	Metadata answer = null;	String s = element.getLocalName();	if ("cxfEndpoint".equals(s)) {	
parsing the cxfendpoint element 

public Metadata parse(Element element, ParserContext context) {	Metadata answer = null;	String s = element.getLocalName();	if ("cxfEndpoint".equals(s)) {	answer = new EndpointDefinitionParser().parse(element, context);	}	if ("rsClient".equals(s)) {	
parsing the rsclient element 

public Metadata parse(Element element, ParserContext context) {	Metadata answer = null;	String s = element.getLocalName();	if ("cxfEndpoint".equals(s)) {	answer = new EndpointDefinitionParser().parse(element, context);	}	if ("rsClient".equals(s)) {	answer = new RsClientDefinitionParser().parse(element, context);	}	if ("rsServer".equals(s)) {	
parsing the rsserver element 

========================= camel sample_8037 =========================

protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {	List<PropertiesLocation> paths = locations;	Boolean ignoreMissingLocationLoc = getAndRemoveParameter(parameters, "ignoreMissingLocation", Boolean.class);	if (ignoreMissingLocationLoc != null) {	ignoreMissingLocation = ignoreMissingLocationLoc;	}	String locations = getAndRemoveParameter(parameters, "locations", String.class);	if (locations != null) {	
overriding default locations with location 

List<PropertiesLocation> paths = locations;	Boolean ignoreMissingLocationLoc = getAndRemoveParameter(parameters, "ignoreMissingLocation", Boolean.class);	if (ignoreMissingLocationLoc != null) {	ignoreMissingLocation = ignoreMissingLocationLoc;	}	String locations = getAndRemoveParameter(parameters, "locations", String.class);	if (locations != null) {	paths = Arrays.stream(locations.split(",")).map(PropertiesLocation::new).collect(Collectors.toList());	}	String endpointUri = parseUri(remaining, paths);	
endpoint uri parsed as 

override.putAll(prop);	override.putAll(overrideProperties);	prop = override;	}	if (!uri.contains(prefixToken) && !uri.startsWith(prefixToken)) {	uri = prefixToken + uri;	}	if (!uri.contains(suffixToken) && !uri.endsWith(suffixToken)) {	uri = uri + suffixToken;	}	
parsing uri with properties 

private List<PropertiesLocation> parseLocations(List<PropertiesLocation> locations) {	List<PropertiesLocation> answer = new ArrayList<>();	for (PropertiesLocation location : locations) {	
parsing location 

private List<PropertiesLocation> parseLocations(List<PropertiesLocation> locations) {	List<PropertiesLocation> answer = new ArrayList<>();	for (PropertiesLocation location : locations) {	try {	String path = FilePathResolver.resolvePath(location.getPath());	
parsed location 

for (PropertiesLocation location : locations) {	try {	String path = FilePathResolver.resolvePath(location.getPath());	if (ObjectHelper.isNotEmpty(path)) {	answer.add(new PropertiesLocation( location.getResolver(), path, location.isOptional()) );	}	} catch (IllegalArgumentException e) {	if (!ignoreMissingLocation && !location.isOptional()) {	throw e;	} else {	
ignored missing location 

========================= camel sample_4917 =========================

public void testQuery() throws Exception {	com.google.api.services.calendar.model.FreeBusyRequest request = new FreeBusyRequest();	List<FreeBusyRequestItem> items = new ArrayList<FreeBusyRequestItem>();	items.add(new FreeBusyRequestItem().setId(getCalendar().getId()));	request.setItems(items);	request.setTimeMin(DateTime.parseRfc3339("2014-11-10T20:45:30-00:00"));	request.setTimeMax(DateTime.parseRfc3339("2014-11-10T21:45:30-00:00"));	final com.google.api.services.calendar.model.FreeBusyResponse result = requestBody("direct: assertNotNull("query result", result);	
query 

========================= camel sample_11747 =========================

protected void doStart() throws Exception {	if (objectMapper == null) {	if (camelContext != null) {	Set<ObjectMapper> set = camelContext.getRegistry().findByType(ObjectMapper.class);	if (set.size() == 1) {	objectMapper = set.iterator().next();	
found single objectmapper in registry to use 

protected void doStart() throws Exception {	if (objectMapper == null) {	if (camelContext != null) {	Set<ObjectMapper> set = camelContext.getRegistry().findByType(ObjectMapper.class);	if (set.size() == 1) {	objectMapper = set.iterator().next();	} else if (set.size() > 1) {	
found objectmapper in registry cannot use as default as there are more than one instance 

if (objectMapper == null) {	if (camelContext != null) {	Set<ObjectMapper> set = camelContext.getRegistry().findByType(ObjectMapper.class);	if (set.size() == 1) {	objectMapper = set.iterator().next();	} else if (set.size() > 1) {	}	}	if (objectMapper == null) {	objectMapper = new ObjectMapper();	
creating new objectmapper to use 

objectMapper = set.iterator().next();	} else if (set.size() > 1) {	}	}	if (objectMapper == null) {	objectMapper = new ObjectMapper();	}	}	if (enableJaxbAnnotationModule) {	JaxbAnnotationModule module = new JaxbAnnotationModule();	
registering jaxbannotationmodule 

MapperFeature mf = getCamelContext().getTypeConverter().tryConvertTo(MapperFeature.class, disable);	if (mf != null) {	objectMapper.disable(mf);	continue;	}	throw new IllegalArgumentException("Disable feature: " + disable + " cannot be converted to an accepted enum of types [SerializationFeature,DeserializationFeature,MapperFeature]");	}	}	if (modules != null) {	for (Module module : modules) {	
registering module 

for (Module module : modules) {	objectMapper.registerModules(module);	}	}	if (moduleClassNames != null) {	Iterable<Object> it = ObjectHelper.createIterable(moduleClassNames);	for (Object o : it) {	String name = o.toString();	Class<Module> clazz = camelContext.getClassResolver().resolveMandatoryClass(name, Module.class);	Module module = camelContext.getInjector().newInstance(clazz);	
registering module 

}	}	if (moduleRefs != null) {	Iterable<Object> it = ObjectHelper.createIterable(moduleRefs);	for (Object o : it) {	String name = o.toString();	if (name.startsWith("#")) {	name = name.substring(1);	}	Module module = CamelContextHelper.mandatoryLookup(camelContext, name, Module.class);	
registering module 

for (Object o : it) {	String name = o.toString();	if (name.startsWith("#")) {	name = name.substring(1);	}	Module module = CamelContextHelper.mandatoryLookup(camelContext, name, Module.class);	objectMapper.registerModule(module);	}	}	if (ObjectHelper.isNotEmpty(timezone)) {	
setting timezone to object mapper 

========================= camel sample_10855 =========================

public void process(Exchange exchange) throws Exception {	List<String> params = new ArrayList<String>();	params.add(exchange.getIn().getBody(String.class));	exchange.getOut().setBody(params);	String operation = (String)exchange.getIn().getHeader(CxfConstants.OPERATION_NAME);	
the operation name is 

========================= camel sample_6029 =========================

public void testAddFolderCollaborationByEmail() throws Exception {	deleteTestCollaborator();	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.folderId", testFolder.getID());	headers.put("CamelBox.email", CAMEL_TEST_COLLABORATOR_EMAIL);	headers.put("CamelBox.role", BoxCollaboration.Role.EDITOR);	final com.box.sdk.BoxCollaboration result = requestBodyAndHeaders("direct: testFolder.getID(), headers);	assertNotNull("addFolderCollaboration result", result);	
addfoldercollaboration 

try {	CreateUserParams params = new CreateUserParams();	params.setSpaceAmount(1073741824);	user = BoxUser.createAppUser(getConnection(), CAMEL_TEST_COLLABORATOR_NAME, params).getResource();	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.folderId", testFolder.getID());	headers.put("CamelBox.collaborator", user);	headers.put("CamelBox.role", BoxCollaboration.Role.EDITOR);	final com.box.sdk.BoxCollaboration result = requestBodyAndHeaders("direct: testFolder.getID(), headers);	assertNotNull("addFolderCollaboration result", result);	
addfoldercollaboration 

public void testGetCollaborationInfo() throws Exception {	final com.box.sdk.BoxCollaboration.Info result = requestBody("direct: testCollaboration.getID());	assertNotNull("getCollaborationInfo result", result);	
getcollaborationinfo 

public void testGetFolderCollaborations() throws Exception {	final java.util.Collection result = requestBody("direct: assertNotNull("getFolderCollaborations result", result);	
getfoldercollaborations 

public void testGetPendingCollaborations() throws Exception {	final java.util.Collection result = requestBody("direct: assertNotNull("getPendingCollaborations result", result);	
getpendingcollaborations 

public void testUpdateCollaborationInfo() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.collaborationId", testCollaboration.getID());	BoxCollaboration.Info info = testCollaboration.getInfo();	info.setRole(BoxCollaboration.Role.PREVIEWER);	headers.put("CamelBox.info", info);	final com.box.sdk.BoxCollaboration result = requestBodyAndHeaders("direct: headers);	assertNotNull("updateCollaborationInfo result", result);	assertNotNull("updateCollaborationInfo info", result.getInfo());	assertEquals("updateCollaborationInfo info", BoxCollaboration.Role.PREVIEWER, result.getInfo().getRole());	
updatecollaborationinfo 

========================= camel sample_17410 =========================

String jwtToken = metadata.get(GrpcConstants.GRPC_JWT_METADATA_KEY);	if (jwtToken == null) {	call.close(Status.UNAUTHENTICATED.withDescription("JWT Token is missing from metadata"), metadata);	return NOOP_LISTENER;	}	Context ctx;	try {	DecodedJWT verified = verifier.verify(jwtToken);	ctx = Context.current() .withValue(GrpcConstants.GRPC_JWT_USER_ID_CTX_KEY, verified.getSubject() == null ? "anonymous" : verified.getSubject()) .withValue(GrpcConstants.GRPC_JWT_CTX_KEY, jwtToken);	} catch (Exception e) {	
jwt token verification failed unauthenticated 

========================= camel sample_7511 =========================

public AbstractJIRAConsumer(JIRAEndpoint endpoint, Processor processor) {	super(endpoint, processor);	this.endpoint = endpoint;	setDelay(endpoint.getDelay());	JerseyJiraRestClientFactory factory;	Registry registry = endpoint.getCamelContext().getRegistry();	Object target = registry.lookupByName("JerseyJiraRestClientFactory");	if (target != null) {	
jerseyjirarestclientfactory found in registry 

protected List<BasicIssue> getIssues(String jql, int start, int maxResults, int maxPerQuery) {	
indexing current jira issues 

========================= camel sample_13003 =========================

public Consumer createConsumer(Processor processor) throws Exception {	NettyHttpConsumer answer = new NettyHttpConsumer(this, processor, getConfiguration());	configureConsumer(answer);	if (nettySharedHttpServer != null) {	answer.setNettyServerBootstrapFactory(nettySharedHttpServer.getServerBootstrapFactory());	
nettyhttpconsumer is using nettysharedhttpserver on port 

public Consumer createConsumer(Processor processor) throws Exception {	NettyHttpConsumer answer = new NettyHttpConsumer(this, processor, getConfiguration());	configureConsumer(answer);	if (nettySharedHttpServer != null) {	answer.setNettyServerBootstrapFactory(nettySharedHttpServer.getServerBootstrapFactory());	} else {	HttpServerBootstrapFactory factory = getComponent().getOrCreateHttpNettyServerBootstrapFactory(answer);	answer.setNettyServerBootstrapFactory(factory);	
created nettyhttpconsumer using httpserverbootstrapfactory 

protected void doStart() throws Exception {	super.doStart();	ObjectHelper.notNull(nettyHttpBinding, "nettyHttpBinding", this);	ObjectHelper.notNull(headerFilterStrategy, "headerFilterStrategy", this);	if (securityConfiguration != null) {	ObjectHelper.notEmpty(securityConfiguration.getRealm(), "realm", securityConfiguration);	ObjectHelper.notEmpty(securityConfiguration.getConstraint(), "restricted", securityConfiguration);	if (securityConfiguration.getSecurityAuthenticator() == null) {	JAASSecurityAuthenticator jaas = new JAASSecurityAuthenticator();	jaas.setName(securityConfiguration.getRealm());	
no securityauthenticator configured using jaassecurityauthenticator as authenticator 

========================= camel sample_16651 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<CoAPComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.coap.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.coap.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1095 =========================

protected void doStart() throws Exception {	ObjectHelper.notEmpty(cron, "cron", this);	trigger = new CronTrigger(getCron(), getTimeZone());	if (taskScheduler == null) {	taskScheduler = new CamelThreadPoolTaskScheduler(getCamelContext(), consumer, consumer.getEndpoint().getEndpointUri());	taskScheduler.afterPropertiesSet();	destroyTaskScheduler = true;	}	
scheduling cron trigger 

========================= camel sample_16344 =========================

protected void onCompletion(Exchange exchange) {	GenericFileProcessStrategy<T> processStrategy = endpoint.getGenericFileProcessStrategy();	
done processing file using exchange 

if (endpoint.getIdempotentKey() != null) {	Exchange dummy = endpoint.createExchange(file);	key = endpoint.getIdempotentKey().evaluate(dummy, String.class);	}	if (key != null) {	endpoint.getIdempotentRepository().add(key);	}	}	handleDoneFile(exchange);	try {	
commit file strategy for file 

protected void processStrategyRollback(GenericFileProcessStrategy<T> processStrategy, Exchange exchange, GenericFile<T> file) {	if (log.isWarnEnabled()) {	
rollback file strategy for file 

protected void handleDoneFile(Exchange exchange) {	boolean complete = exchange.getProperty(Exchange.BATCH_COMPLETE, false, Boolean.class);	if (endpoint.getDoneFileName() != null && !endpoint.isNoop()) {	String doneFileName = endpoint.createDoneFileName(absoluteFileName);	ObjectHelper.notEmpty(doneFileName, "doneFileName", endpoint);	if (endpoint.getDoneFileName().indexOf("{file:name") > 0 || complete) {	try {	boolean deleted = operations.deleteFile(doneFileName);	
done file was deleted 

protected void handleDoneFile(Exchange exchange) {	boolean complete = exchange.getProperty(Exchange.BATCH_COMPLETE, false, Boolean.class);	if (endpoint.getDoneFileName() != null && !endpoint.isNoop()) {	String doneFileName = endpoint.createDoneFileName(absoluteFileName);	ObjectHelper.notEmpty(doneFileName, "doneFileName", endpoint);	if (endpoint.getDoneFileName().indexOf("{file:name") > 0 || complete) {	try {	boolean deleted = operations.deleteFile(doneFileName);	if (!deleted) {	
done file could not be deleted 

========================= camel sample_4782 =========================

protected int poll() throws Exception {	shutdownRunningTask = null;	pendingExchanges = 0;	int polledMessages = 0;	ensureIsConnected();	if (store == null || folder == null) {	throw new IllegalStateException("MailConsumer did not connect properly to the MailStore: " + getEndpoint().getConfiguration().getMailStoreLogInformation());	}	if (LOG.isDebugEnabled()) {	
polling mailbox folder 

shutdownRunningTask = null;	pendingExchanges = 0;	int polledMessages = 0;	ensureIsConnected();	if (store == null || folder == null) {	throw new IllegalStateException("MailConsumer did not connect properly to the MailStore: " + getEndpoint().getConfiguration().getMailStoreLogInformation());	}	if (LOG.isDebugEnabled()) {	}	if (getEndpoint().getConfiguration().getFetchSize() == 0) {	
fetch size is meaning the configuration is set to poll no new messages at all camel will skip this poll 

postProcessor.process(folder);	}	} else if (count == -1) {	throw new MessagingException("Folder: " + folder.getFullName() + " is closed");	}	} catch (Exception e) {	handleException(e);	} finally {	if (getEndpoint().getConfiguration().isCloseFolder() || getEndpoint().getConfiguration().isDisconnect()) {	if (LOG.isDebugEnabled()) {	
close mailbox folder from 

handleException(e);	} finally {	if (getEndpoint().getConfiguration().isCloseFolder() || getEndpoint().getConfiguration().isDisconnect()) {	if (LOG.isDebugEnabled()) {	}	try {	if (folder.isOpen()) {	folder.close(true);	}	} catch (Exception e) {	
could not close mailbox folder this exception is ignored 

if (folder.isOpen()) {	folder.close(true);	}	} catch (Exception e) {	}	}	}	boolean disconnect = getEndpoint().getConfiguration().isDisconnect();	if (disconnect) {	if (LOG.isDebugEnabled()) {	
disconnecting from 

}	}	}	boolean disconnect = getEndpoint().getConfiguration().isDisconnect();	if (disconnect) {	if (LOG.isDebugEnabled()) {	}	try {	store.close();	} catch (Exception e) {	
could not disconnect from this exception is ignored 

public int processBatch(Queue<Object> exchanges) throws Exception {	int total = exchanges.size();	if (maxMessagesPerPoll > 0 && total > maxMessagesPerPoll) {	
limiting to maximum messages to poll as there were messages in this poll 

private void peekMessage(Message mail) {	if (mail.getClass().getSimpleName().startsWith("IMAP")) {	try {	
calling setpeek true on mail message 

private void peekMessage(Message mail) {	if (mail.getClass().getSimpleName().startsWith("IMAP")) {	try {	IntrospectionSupport.setProperty(mail, "peek", true);	} catch (Throwable e) {	
error setting peak property to true on this exception is ignored 

private Message[] retrieveAllMessages() throws MessagingException {	int total = folder.getMessageCount();	List<Message> msgs = new ArrayList<Message>();	for (int i = 1; i <= total; i++) {	try {	Message msg = folder.getMessage(i);	msgs.add(msg);	} catch (Exception e) {	if (skipFailedMessage) {	
skipping failed message at index due 

private boolean isValidMessage(String key, Message msg) {	boolean answer = true;	if (getEndpoint().getIdempotentRepository() != null) {	if (!getEndpoint().getIdempotentRepository().add(key)) {	
this consumer is idempotent and the mail message has been consumed before matching idempotentkey will skip this message 

private boolean isValidMessage(String key, Message msg) {	boolean answer = true;	if (getEndpoint().getIdempotentRepository() != null) {	if (!getEndpoint().getIdempotentRepository().add(key)) {	answer = false;	}	}	
message with key is valid 

protected Queue<Exchange> createExchanges(List<KeyValueHolder<String, Message>> messages) throws MessagingException {	Queue<Exchange> answer = new LinkedList<Exchange>();	int fetchSize = getEndpoint().getConfiguration().getFetchSize();	int count = fetchSize == -1 ? messages.size() : Math.min(fetchSize, messages.size());	if (LOG.isDebugEnabled()) {	
fetching messages total messages 

int fetchSize = getEndpoint().getConfiguration().getFetchSize();	int count = fetchSize == -1 ? messages.size() : Math.min(fetchSize, messages.size());	if (LOG.isDebugEnabled()) {	}	for (int i = 0; i < count; i++) {	try {	KeyValueHolder<String, Message> holder = messages.get(i);	String key = holder.getKey();	Message message = holder.getValue();	if (LOG.isTraceEnabled()) {	
mail is of type 

for (int i = 0; i < count; i++) {	try {	KeyValueHolder<String, Message> holder = messages.get(i);	String key = holder.getKey();	Message message = holder.getValue();	if (LOG.isTraceEnabled()) {	}	if (!message.getFlags().contains(Flags.Flag.DELETED)) {	Exchange exchange = getEndpoint().createExchange(message);	if (getEndpoint().getConfiguration().isMapMailMessage()) {	
mapping from javax mail message to camel mailmessage 

Exchange exchange = getEndpoint().createExchange(message);	if (getEndpoint().getConfiguration().isMapMailMessage()) {	exchange.getIn().getBody();	exchange.getIn().getHeaders();	exchange.getIn().getAttachments();	}	exchange.setProperty(MAIL_MESSAGE_UID, key);	answer.add(exchange);	} else {	if (LOG.isDebugEnabled()) {	
skipping message as it was flagged as deleted 

exchange.getIn().getAttachments();	}	exchange.setProperty(MAIL_MESSAGE_UID, key);	answer.add(exchange);	} else {	if (LOG.isDebugEnabled()) {	}	}	} catch (Exception e) {	if (skipFailedMessage) {	
skipping failed message at index due 

protected void processExchange(Exchange exchange) throws Exception {	if (LOG.isDebugEnabled()) {	MailMessage msg = (MailMessage) exchange.getIn();	
processing message 

protected void processCommit(Message mail, Exchange exchange) {	try {	if (!folder.isOpen()) {	folder.open(Folder.READ_WRITE);	}	String uid = (String) exchange.removeProperty(MAIL_MESSAGE_UID);	if (getEndpoint().getConfiguration().getProtocol().startsWith("pop3")) {	int count = folder.getMessageCount();	Message found = null;	
looking for with uid from folder with mails 

if (!folder.isOpen()) {	folder.open(Folder.READ_WRITE);	}	String uid = (String) exchange.removeProperty(MAIL_MESSAGE_UID);	if (getEndpoint().getConfiguration().getProtocol().startsWith("pop3")) {	int count = folder.getMessageCount();	Message found = null;	for (int i = 1; i <= count; ++i) {	Message msg = folder.getMessage(i);	if (uid.equals(getEndpoint().getMailUidGenerator().generateUuid(getEndpoint(), msg))) {	
found with uid from folder with mails 

Message found = null;	for (int i = 1; i <= count; ++i) {	Message msg = folder.getMessage(i);	if (uid.equals(getEndpoint().getMailUidGenerator().generateUuid(getEndpoint(), msg))) {	found = msg;	break;	}	}	if (found == null) {	boolean delete = getEndpoint().getConfiguration().isDelete();	
not found in folder message cannot be marked as DELETED SEEN 

} else {	mail = found;	}	}	org.apache.camel.Message in = exchange.getIn();	MailConfiguration config = getEndpoint().getConfiguration();	String copyTo = in.getHeader("copyTo", config.getCopyTo(), String.class);	boolean delete = in.getHeader("delete", config.isDelete(), boolean.class);	if (config.getProtocol().equals(MailUtils.PROTOCOL_IMAP) || config.getProtocol().equals(MailUtils.PROTOCOL_IMAPS)) {	if (copyTo != null) {	
imap message needs to be copied to 

MailConfiguration config = getEndpoint().getConfiguration();	String copyTo = in.getHeader("copyTo", config.getCopyTo(), String.class);	boolean delete = in.getHeader("delete", config.isDelete(), boolean.class);	if (config.getProtocol().equals(MailUtils.PROTOCOL_IMAP) || config.getProtocol().equals(MailUtils.PROTOCOL_IMAPS)) {	if (copyTo != null) {	Folder destFolder = store.getFolder(copyTo);	if (!destFolder.exists()) {	destFolder.create(Folder.HOLDS_MESSAGES);	}	folder.copyMessages(new Message[]{mail}, destFolder);	
imap message copied to 

if (config.getProtocol().equals(MailUtils.PROTOCOL_IMAP) || config.getProtocol().equals(MailUtils.PROTOCOL_IMAPS)) {	if (copyTo != null) {	Folder destFolder = store.getFolder(copyTo);	if (!destFolder.exists()) {	destFolder.create(Folder.HOLDS_MESSAGES);	}	folder.copyMessages(new Message[]{mail}, destFolder);	}	}	if (delete) {	
exchange processed so flagging message as deleted 

Folder destFolder = store.getFolder(copyTo);	if (!destFolder.exists()) {	destFolder.create(Folder.HOLDS_MESSAGES);	}	folder.copyMessages(new Message[]{mail}, destFolder);	}	}	if (delete) {	mail.setFlag(Flags.Flag.DELETED, true);	} else {	
exchange processed so flagging message as seen 

protected void processRollback(Message mail, Exchange exchange) {	String uid = (String) exchange.removeProperty(MAIL_MESSAGE_UID);	if (getEndpoint().getIdempotentRepository() != null) {	getEndpoint().getIdempotentRepository().remove(uid);	}	Exception cause = exchange.getException();	if (cause != null) {	
exchange failed so rolling back message status 

protected void processRollback(Message mail, Exchange exchange) {	String uid = (String) exchange.removeProperty(MAIL_MESSAGE_UID);	if (getEndpoint().getIdempotentRepository() != null) {	getEndpoint().getIdempotentRepository().remove(uid);	}	Exception cause = exchange.getException();	if (cause != null) {	} else {	
exchange failed so rolling back message status 

private void ensureIsConnected() throws MessagingException {	MailConfiguration config = getEndpoint().getConfiguration();	boolean connected = false;	try {	if (store != null && store.isConnected()) {	connected = true;	}	} catch (Exception e) {	
exception while testing for is connected to mailstore caused by 

try {	if (store != null && store.isConnected()) {	connected = true;	}	} catch (Exception e) {	}	if (!connected) {	store = null;	folder = null;	if (LOG.isDebugEnabled()) {	
connecting to mailstore 

store = null;	folder = null;	if (LOG.isDebugEnabled()) {	}	store = sender.getSession().getStore(config.getProtocol());	store.connect(config.getHost(), config.getPort(), config.getUsername(), config.getPassword());	serverCanSort = hasSortCapability(store);	}	if (folder == null) {	if (LOG.isDebugEnabled()) {	
getting folder 

========================= camel sample_11878 =========================

if (exchange == null) {	return;	}	if (exchange.getUnitOfWork() == null) {	List<Synchronization> synchronizations = exchange.handoverCompletions();	UnitOfWorkHelper.doneSynchronizations(exchange, synchronizations, LOG);	} else {	exchange.getUnitOfWork().done(exchange);	}	} catch (Throwable e) {	
exception occurred during done unitofwork for exchange this exception will be ignored 

========================= camel sample_3944 =========================

public void process(Exchange exchange) {	Integer counter = exchange.getIn().getHeader(Exchange.REDELIVERY_COUNTER, Integer.class);	int attempt = (counter == null) ? 1 : counter + 1;	if (attempt < failUntilAttempt) {	throw new RuntimeException("Failed to process due to attempt: " + attempt + " being less than: " + failUntilAttempt);	}	}	};	return new RouteBuilder() {	public void configure() {	
direct start mock failed mock success 

========================= camel sample_2656 =========================

public Component resolveComponent(String name, CamelContext context) throws Exception {	Component componentReg = ResolverHelper.lookupComponentInRegistryWithFallback(context, name, new ResolverHelper.LookupExceptionHandler() {	public void handleException(Exception e, Logger log, String name) {	if (getException(NoSuchComponentException.class, e) != null) {	} else {	
ignored error looking up bean due 

} else {	}	}	});	if (componentReg != null) {	return componentReg;	}	try {	Object bean = context.getRegistry().lookupByName(".camelBlueprint.componentResolver." + name);	if (bean instanceof ComponentResolver) {	
found component resolver in registry 

});	if (componentReg != null) {	return componentReg;	}	try {	Object bean = context.getRegistry().lookupByName(".camelBlueprint.componentResolver." + name);	if (bean instanceof ComponentResolver) {	return ((ComponentResolver) bean).resolveComponent(name, context);	}	} catch (Exception e) {	
ignored error looking up bean due 

========================= camel sample_8125 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<CastorDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.castor.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.castor.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_799 =========================

public void testLuceneIndexProducer() throws Exception {	MockEndpoint mockEndpoint = getMockEndpoint("mock:result");	context.stop();	context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:start"). to("lucene:stdQuotesIndex:insert?analyzer=#stdAnalyzer&indexDir=#std&srcDir=#load_dir"). to("lucene:simpleQuotesIndex:insert?analyzer=#simpleAnalyzer&indexDir=#simple&srcDir=#load_dir"). to("lucene:whitespaceQuotesIndex:insert?analyzer=#whitespaceAnalyzer&indexDir=#whitespace&srcDir=#load_dir"). to("mock:result");	}	});	context.start();	
beginning luceneindexproducer test 

context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:start"). to("lucene:stdQuotesIndex:insert?analyzer=#stdAnalyzer&indexDir=#std&srcDir=#load_dir"). to("lucene:simpleQuotesIndex:insert?analyzer=#simpleAnalyzer&indexDir=#simple&srcDir=#load_dir"). to("lucene:whitespaceQuotesIndex:insert?analyzer=#whitespaceAnalyzer&indexDir=#whitespace&srcDir=#load_dir"). to("mock:result");	}	});	context.start();	for (String quote : humorousQuotes) {	sendRequest(quote);	}	mockEndpoint.assertIsSatisfied();	
completed luceneindexproducer test 

context.stop();	context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:start"). setHeader("QUERY", constant("Seinfeld")). to("lucene:searchIndex:query?analyzer=#whitespaceAnalyzer&indexDir=#whitespace&maxHits=20"). to("direct:next");	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	Hits hits = exchange.getIn().getBody(Hits.class);	printResults(hits);	}	private void printResults(Hits hits) {	
number of hits 

context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:start"). setHeader("QUERY", constant("Seinfeld")). to("lucene:searchIndex:query?analyzer=#whitespaceAnalyzer&indexDir=#whitespace&maxHits=20"). to("direct:next");	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	Hits hits = exchange.getIn().getBody(Hits.class);	printResults(hits);	}	private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	
hit index location 

context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:start"). setHeader("QUERY", constant("Seinfeld")). to("lucene:searchIndex:query?analyzer=#whitespaceAnalyzer&indexDir=#whitespace&maxHits=20"). to("direct:next");	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	Hits hits = exchange.getIn().getBody(Hits.class);	printResults(hits);	}	private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	
hit score 

context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:start"). setHeader("QUERY", constant("Seinfeld")). to("lucene:searchIndex:query?analyzer=#whitespaceAnalyzer&indexDir=#whitespace&maxHits=20"). to("direct:next");	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	Hits hits = exchange.getIn().getBody(Hits.class);	printResults(hits);	}	private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	
hit data 

printResults(hits);	}	private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	}	}	}).to("mock:searchResult");	}	});	context.start();	
beginning lucenequeryproducer phrase test 

private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	}	}	}).to("mock:searchResult");	}	});	context.start();	sendQuery();	mockSearchEndpoint.assertIsSatisfied();	
completed lucenequeryproducer phrase test 

context.stop();	context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:start"). setHeader("QUERY", constant("Grouc?? Marx")). to("lucene:searchIndex:query?analyzer=#stdAnalyzer&indexDir=#std&maxHits=20"). to("direct:next");	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	Hits hits = exchange.getIn().getBody(Hits.class);	printResults(hits);	}	private void printResults(Hits hits) {	
number of hits 

context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:start"). setHeader("QUERY", constant("Grouc?? Marx")). to("lucene:searchIndex:query?analyzer=#stdAnalyzer&indexDir=#std&maxHits=20"). to("direct:next");	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	Hits hits = exchange.getIn().getBody(Hits.class);	printResults(hits);	}	private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	
hit index location 

context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:start"). setHeader("QUERY", constant("Grouc?? Marx")). to("lucene:searchIndex:query?analyzer=#stdAnalyzer&indexDir=#std&maxHits=20"). to("direct:next");	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	Hits hits = exchange.getIn().getBody(Hits.class);	printResults(hits);	}	private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	
hit score 

context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:start"). setHeader("QUERY", constant("Grouc?? Marx")). to("lucene:searchIndex:query?analyzer=#stdAnalyzer&indexDir=#std&maxHits=20"). to("direct:next");	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	Hits hits = exchange.getIn().getBody(Hits.class);	printResults(hits);	}	private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	
hit data 

printResults(hits);	}	private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	}	}	}).to("mock:searchResult");	}	});	context.start();	
beginning lucenequeryproducer wildcard test 

private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	}	}	}).to("mock:searchResult");	}	});	context.start();	sendQuery();	mockSearchEndpoint.assertIsSatisfied();	
completed lucenequeryproducer wildcard test 

public void process(Exchange exchange) throws Exception {	Hits hits = exchange.getIn().getBody(Hits.class);	try {	printResults(hits);	} catch (Exception e) {	LOG.error(e.getMessage());	exchange.getOut().setBody(null);	}	}	private void printResults(Hits hits) throws Exception {	
number of hits 

Hits hits = exchange.getIn().getBody(Hits.class);	try {	printResults(hits);	} catch (Exception e) {	LOG.error(e.getMessage());	exchange.getOut().setBody(null);	}	}	private void printResults(Hits hits) throws Exception {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	
hit index location 

Hits hits = exchange.getIn().getBody(Hits.class);	try {	printResults(hits);	} catch (Exception e) {	LOG.error(e.getMessage());	exchange.getOut().setBody(null);	}	}	private void printResults(Hits hits) throws Exception {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	
hit score 

Hits hits = exchange.getIn().getBody(Hits.class);	try {	printResults(hits);	} catch (Exception e) {	LOG.error(e.getMessage());	exchange.getOut().setBody(null);	}	}	private void printResults(Hits hits) throws Exception {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	
hit data 

}	}	}).to("mock:searchResult").process(new Processor() {	public void process(Exchange exchange) throws Exception {	Hits hits = exchange.getIn().getBody(Hits.class);	if (hits == null) {	HashMap<String, String> map = new HashMap<String, String>();	map.put("NO_LUCENE_DOCS_ERROR", "NO LUCENE DOCS FOUND");	exchange.getContext().setProperties(map);	}	
number of hits 

if (hits == null) {	HashMap<String, String> map = new HashMap<String, String>();	map.put("NO_LUCENE_DOCS_ERROR", "NO LUCENE DOCS FOUND");	exchange.getContext().setProperties(map);	}	}	});	}	});	context.start();	
beginning lucenequeryproducer wildcard with return lucene docs test 

exchange.getContext().setProperties(map);	}	}	});	}	});	context.start();	sendQuery();	mockSearchEndpoint.assertIsSatisfied();	Map<String, String> errorMap = mockSearchEndpoint.getCamelContext().getProperties();	
completed lucenequeryproducer wildcard with return lucene docs test 

========================= camel sample_6838 =========================

byte[] bytes = serializer.serialize(s);	try {	synchronized (dataSet) {	if (dataSet.has(bytes)) {	return false;	} else {	return dataSet.add(serializer.serialize(s));	}	}	} catch (Exception e) {	
error adding item to krati idempotent repository this exception is ignored 

public boolean contains(String s) {	byte[] bytes = serializer.serialize(s);	try {	return dataSet.has(bytes);	} catch (Exception e) {	
error checking item exists in krati idempotent repository this exception is ignored 

public boolean remove(String s) {	byte[] bytes = serializer.serialize(s);	try {	return dataSet.delete(bytes);	} catch (Exception e) {	
error removing item from krati idempotent repository this exception is ignored 

public void clear() {	try {	dataSet.clear();	} catch (Exception e) {	
error clear krati idempotent repository this exception is ignored 

========================= camel sample_14007 =========================

protected void doStart() throws Exception {	super.doStart();	this.targetAddress = GenericAddress.parse(this.endpoint.getAddress());	
targetaddress 

public void process(final Exchange exchange) throws Exception {	Snmp snmp = null;	TransportMapping<? extends Address> transport = null;	try {	
starting snmp producer on 

TransportMapping<? extends Address> transport = null;	try {	if ("tcp".equals(this.endpoint.getProtocol())) {	transport = new DefaultTcpTransportMapping();	} else if ("udp".equals(this.endpoint.getProtocol())) {	transport = new DefaultUdpTransportMapping();	} else {	throw new IllegalArgumentException("Unknown protocol: {} " + this.endpoint.getProtocol());	}	snmp = new Snmp(transport);	
snmp i am sending 

if ("tcp".equals(this.endpoint.getProtocol())) {	transport = new DefaultTcpTransportMapping();	} else if ("udp".equals(this.endpoint.getProtocol())) {	transport = new DefaultUdpTransportMapping();	} else {	throw new IllegalArgumentException("Unknown protocol: {} " + this.endpoint.getProtocol());	}	snmp = new Snmp(transport);	snmp.listen();	ResponseEvent responseEvent = snmp.send(this.pdu, this.target);	
snmp sended 

========================= camel sample_8826 =========================

public void await(Exchange exchange, CountDownLatch latch) {	
waiting for asynchronous callback before continuing for exchangeid 

public void await(Exchange exchange, CountDownLatch latch) {	try {	if (statistics.isStatisticsEnabled()) {	blockedCounter.incrementAndGet();	}	inflight.put(exchange, new AwaitThreadEntry(Thread.currentThread(), exchange, latch));	latch.await();	
asynchronous callback received will continue routing exchangeid 

public void await(Exchange exchange, CountDownLatch latch) {	try {	if (statistics.isStatisticsEnabled()) {	blockedCounter.incrementAndGet();	}	inflight.put(exchange, new AwaitThreadEntry(Thread.currentThread(), exchange, latch));	latch.await();	} catch (InterruptedException e) {	
interrupted while waiting for callback will continue routing exchangeid 

public void countDown(Exchange exchange, CountDownLatch latch) {	
asynchronous callback received for exchangeid 

protected void doStop() throws Exception {	Collection<AwaitThread> threads = browse();	int count = threads.size();	if (count > 0) {	
shutting down while there are still inflight threads currently blocked 

protected void doStop() throws Exception {	Collection<AwaitThread> threads = browse();	int count = threads.size();	if (count > 0) {	StringBuilder sb = new StringBuilder();	for (AwaitThread entry : threads) {	sb.append(dumpBlockedThread(entry));	}	if (isInterruptThreadsWhileStopping()) {	
the following threads are blocked and will be interrupted so the threads are released 

if (count > 0) {	StringBuilder sb = new StringBuilder();	for (AwaitThread entry : threads) {	sb.append(dumpBlockedThread(entry));	}	if (isInterruptThreadsWhileStopping()) {	for (AwaitThread entry : threads) {	try {	interrupt(entry.getExchange());	} catch (Throwable e) {	
error while interrupting thread this exception is ignored 

sb.append(dumpBlockedThread(entry));	}	if (isInterruptThreadsWhileStopping()) {	for (AwaitThread entry : threads) {	try {	interrupt(entry.getExchange());	} catch (Throwable e) {	}	}	} else {	
the following threads are blocked and may reside in the jvm 

if (isInterruptThreadsWhileStopping()) {	for (AwaitThread entry : threads) {	try {	interrupt(entry.getExchange());	} catch (Throwable e) {	}	}	} else {	}	} else {	
shutting down with no inflight threads 

========================= camel sample_4106 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	errorHandler(defaultErrorHandler().maximumRedeliveries(5).redeliveryDelay(10).asyncDelayedRedelivery());	from("seda:start") .to("log:before") .to("mock:before") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	
processing at attempt 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	errorHandler(defaultErrorHandler().maximumRedeliveries(5).redeliveryDelay(10).asyncDelayedRedelivery());	from("seda:start") .to("log:before") .to("mock:before") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String body = exchange.getIn().getBody(String.class);	if (body.contains("World")) {	if (++attempt <= 2) {	
processing failed will thrown an exception 

errorHandler(defaultErrorHandler().maximumRedeliveries(5).redeliveryDelay(10).asyncDelayedRedelivery());	from("seda:start") .to("log:before") .to("mock:before") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String body = exchange.getIn().getBody(String.class);	if (body.contains("World")) {	if (++attempt <= 2) {	throw new IllegalArgumentException("Damn");	}	}	exchange.getIn().setBody("Hello " + body);	
processing at attempt complete 

========================= camel sample_1754 =========================

public void status(PubNub pubnub, PNStatus status) {	if (status.getCategory() == PNUnexpectedDisconnectCategory || status.getCategory() == PNTimeoutCategory) {	
got status reconnecting to pubnub 

public void status(PubNub pubnub, PNStatus status) {	if (status.getCategory() == PNUnexpectedDisconnectCategory || status.getCategory() == PNTimeoutCategory) {	pubnub.reconnect();	} else {	
status message 

========================= camel sample_11655 =========================

public void myMethod(@ExchangeProperties Map<?, ?> foo, @Headers Map<?, ?> bar) {	this.foo = foo;	this.bar = bar;	
mymethod method called on 

========================= camel sample_3293 =========================

public Endpoint registerEndpoint(String uri, Endpoint endpoint) {	if (endpoint instanceof InterceptSendToEndpoint) {	return endpoint;	} else if (endpoint instanceof MockEndpoint) {	return endpoint;	} else if (matchPattern(uri, endpoint, pattern)) {	InterceptSendToEndpoint proxy = new InterceptSendToEndpoint(endpoint, skip);	String key = "mock:" + endpoint.getEndpointKey().replaceFirst(": if (key.contains("?")) {	key = ObjectHelper.before(key, "?");	}	
adviced endpoint with mock endpoint 

========================= camel sample_4043 =========================

public Metadata parse(Element element, ParserContext context) {	Metadata answer = null;	String s = element.getLocalName();	if ("conduit".equals(s)) {	
parsing the conduit element 

public Metadata parse(Element element, ParserContext context) {	Metadata answer = null;	String s = element.getLocalName();	if ("conduit".equals(s)) {	answer = new CamelConduitDefinitionParser().parse(element, context);	}	if ("destination".equals(s)) {	
parsing the detination element 

========================= camel sample_6584 =========================

public void process(Exchange exchange) throws Exception {	Message in = exchange.getIn();	BasicIssue issue = in.getBody(BasicIssue.class);	
got issue with id key 

========================= camel sample_12995 =========================

while (continueRouting(processors, nextExchange)) {	if (first) {	first = false;	} else {	nextExchange = createNextExchange(nextExchange);	}	Processor processor = processors.next();	AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);	boolean sync = process(exchange, nextExchange, callback, processors, async);	if (!sync) {	
processing exchangeid is continued being processed asynchronously 

first = false;	} else {	nextExchange = createNextExchange(nextExchange);	}	Processor processor = processors.next();	AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);	boolean sync = process(exchange, nextExchange, callback, processors, async);	if (!sync) {	return false;	}	
processing exchangeid is continued being processed synchronously 

Processor processor = processors.next();	AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);	boolean sync = process(exchange, nextExchange, callback, processors, async);	if (!sync) {	return false;	}	if (!continueProcessing(nextExchange, "so breaking out of pipeline", LOG)) {	break;	}	}	
processing complete for exchangeid 

private boolean process(final Exchange original, final Exchange exchange, final AsyncCallback callback, final Iterator<Processor> processors, final AsyncProcessor asyncProcessor) {	
processing exchangeid 

}	Exchange nextExchange = exchange;	while (continueRouting(processors, nextExchange)) {	AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());	if (!continueProcessing(nextExchange, "so breaking out of pipeline", LOG)) {	break;	}	nextExchange = createNextExchange(nextExchange);	boolean isDoneSync = process(original, nextExchange, callback, processors, processor);	if (!isDoneSync) {	
processing exchangeid is continued being processed asynchronously 

if (!continueProcessing(nextExchange, "so breaking out of pipeline", LOG)) {	break;	}	nextExchange = createNextExchange(nextExchange);	boolean isDoneSync = process(original, nextExchange, callback, processors, processor);	if (!isDoneSync) {	return;	}	}	ExchangeHelper.copyResults(original, nextExchange);	
processing complete for exchangeid 

protected boolean continueRouting(Iterator<Processor> it, Exchange exchange) {	boolean answer = true;	Object stop = exchange.getProperty(Exchange.ROUTE_STOP);	if (stop != null) {	boolean doStop = exchange.getContext().getTypeConverter().convertTo(Boolean.class, stop);	if (doStop) {	
exchangeid is marked to stop routing 

boolean answer = true;	Object stop = exchange.getProperty(Exchange.ROUTE_STOP);	if (stop != null) {	boolean doStop = exchange.getContext().getTypeConverter().convertTo(Boolean.class, stop);	if (doStop) {	answer = false;	}	} else {	answer = it.hasNext();	}	
exchangeid should continue routing 

========================= camel sample_4413 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<TwitterStreamingComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.twitter-streaming.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.twitter-streaming.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_776 =========================

}	}	try {	super.setUp();	} catch (Exception e) {	NoSuchAlgorithmException nsae = ObjectHelper.getException(NoSuchAlgorithmException.class, e);	if (nsae != null) {	canTest = false;	String name = System.getProperty("os.name");	String message = nsae.getMessage();	
is not avail on this platform testing is skipped real cause 

========================= camel sample_15303 =========================

jarStream = new JarInputStream(stream);	JarEntry entry;	while ((entry = jarStream.getNextJarEntry()) != null) {	String name = entry.getName();	if (name != null) {	name = name.trim();	if (!entry.isDirectory() && name.endsWith(".class")) {	entries.add(cleanupSpringbootClassName(name));	} else if (inspectNestedJars && !entry.isDirectory() && isSpringBootNestedJar(name)) {	String nestedUrl = urlPath + "!/" + name;	
inspecting nested jar 

if (!entry.isDirectory() && name.endsWith(".class")) {	entries.add(cleanupSpringbootClassName(name));	} else if (inspectNestedJars && !entry.isDirectory() && isSpringBootNestedJar(name)) {	String nestedUrl = urlPath + "!/" + name;	List<String> nestedEntries = doLoadJarClassEntries(jarStream, nestedUrl, false, false);	entries.addAll(nestedEntries);	}	}	}	} catch (IOException ioe) {	
cannot search jar file due to an ioexception this exception is ignored 

========================= camel sample_13404 =========================

public void foo(InE in, InE in1, Holder<InE> out, Holder<InE> out1) {	
executing operation foo 

========================= camel sample_7815 =========================

public void process(Exchange exchange) throws Exception {	Object body = exchange.getIn().getBody();	if (body != null) {	
posting to eventbus 

public void process(Exchange exchange) throws Exception {	Object body = exchange.getIn().getBody();	if (body != null) {	eventBus.post(body);	} else {	
body is null cannot post to eventbus 

========================= camel sample_9108 =========================

final Object body = queue.poll(config.getPollingTimeout(), TimeUnit.MILLISECONDS);	Exchange exchange = getEndpoint().createExchange();	exchange.getOut().setBody(body);	try {	processor.process(exchange);	} catch (Exception e) {	getExceptionHandler().handleException("Error during processing", exchange, e);	}	} catch (InterruptedException e) {	if (LOG.isDebugEnabled()) {	
hazelcast queue consumer interrupted 

========================= camel sample_9558 =========================

public OperationResult<byte[]> getResult() {	try {	Stat statistics = new Stat();	if (LOG.isDebugEnabled()) {	if (LOG.isTraceEnabled()) {	
received data from s path with statistics s 

public OperationResult<byte[]> getResult() {	try {	Stat statistics = new Stat();	if (LOG.isDebugEnabled()) {	if (LOG.isTraceEnabled()) {	} else {	
received data from s path 

========================= camel sample_12645 =========================

public Consumer createConsumer(Processor processor) throws Exception {	NettyHttpConsumer answer = new NettyHttpConsumer(this, processor, getConfiguration());	configureConsumer(answer);	if (nettySharedHttpServer != null) {	answer.setNettyServerBootstrapFactory(nettySharedHttpServer.getServerBootstrapFactory());	
nettyhttpconsumer is using nettysharedhttpserver on port 

public Consumer createConsumer(Processor processor) throws Exception {	NettyHttpConsumer answer = new NettyHttpConsumer(this, processor, getConfiguration());	configureConsumer(answer);	if (nettySharedHttpServer != null) {	answer.setNettyServerBootstrapFactory(nettySharedHttpServer.getServerBootstrapFactory());	} else {	HttpServerBootstrapFactory factory = getComponent().getOrCreateHttpNettyServerBootstrapFactory(answer);	answer.setNettyServerBootstrapFactory(factory);	
created nettyhttpconsumer using httpserverbootstrapfactory 

protected void doStart() throws Exception {	super.doStart();	ObjectHelper.notNull(nettyHttpBinding, "nettyHttpBinding", this);	ObjectHelper.notNull(headerFilterStrategy, "headerFilterStrategy", this);	if (securityConfiguration != null) {	ObjectHelper.notEmpty(securityConfiguration.getRealm(), "realm", securityConfiguration);	ObjectHelper.notEmpty(securityConfiguration.getConstraint(), "restricted", securityConfiguration);	if (securityConfiguration.getSecurityAuthenticator() == null) {	JAASSecurityAuthenticator jaas = new JAASSecurityAuthenticator();	jaas.setName(securityConfiguration.getRealm());	
no securityauthenticator configured using jaassecurityauthenticator as authenticator 

========================= camel sample_8349 =========================

public void testWSHttpCallEcho() throws Exception {	received.clear();	latch = new CountDownLatch(2);	AsyncHttpClient c = new DefaultAsyncHttpClient();	WebSocket websocket = c.prepareGet("ws: new WebSocketUpgradeHandler.Builder() .addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

========================= camel sample_17447 =========================

public static SchematronProcessor newScehamtronEngine(final Templates rules) {	try {	return new SchematronProcessor(getXMLReader(), rules);	} catch (Exception e) {	
failed to parse the configuration file 

========================= camel sample_11985 =========================

public boolean process(final Exchange exchange, final AsyncCallback callback) {	executor.submit(new Callable<Object>() {	public Object call() throws Exception {	
simulating a task which takes millis to reply 

public boolean process(final Exchange exchange, final AsyncCallback callback) {	executor.submit(new Callable<Object>() {	public Object call() throws Exception {	Thread.sleep(getEndpoint().getDelay());	int count = counter.incrementAndGet();	if (getEndpoint().getFailFirstAttempts() >= count) {	
simulating a failure at attempt 

executor.submit(new Callable<Object>() {	public Object call() throws Exception {	Thread.sleep(getEndpoint().getDelay());	int count = counter.incrementAndGet();	if (getEndpoint().getFailFirstAttempts() >= count) {	exchange.setException(new CamelExchangeException("Simulated error at attempt " + count, exchange));	} else {	String reply = getEndpoint().getReply();	exchange.getOut().setBody(reply);	exchange.getOut().setHeaders(exchange.getIn().getHeaders());	
setting reply 

public Object call() throws Exception {	Thread.sleep(getEndpoint().getDelay());	int count = counter.incrementAndGet();	if (getEndpoint().getFailFirstAttempts() >= count) {	exchange.setException(new CamelExchangeException("Simulated error at attempt " + count, exchange));	} else {	String reply = getEndpoint().getReply();	exchange.getOut().setBody(reply);	exchange.getOut().setHeaders(exchange.getIn().getHeaders());	}	
callback done false 

exchange.setException(new CamelExchangeException("Simulated error at attempt " + count, exchange));	} else {	String reply = getEndpoint().getReply();	exchange.getOut().setBody(reply);	exchange.getOut().setHeaders(exchange.getIn().getHeaders());	}	callback.done(false);	return null;	}	});	
task submitted now tell camel routing engine to that this exchange is being continued asynchronously 

========================= camel sample_12350 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("direct:start") .inOut("activemq:queue:foo?replyTo=queue:bar&requestTimeout=2000") .to("mock:result");	from("activemq:queue:foo") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String body = exchange.getIn().getBody(String.class);	if ("World".equals(body)) {	
sleeping for sec to force a timeout 

========================= camel sample_7053 =========================

public void testAddRunnable() throws Exception {	int runnableCount = 3;	int runCount = 5;	
starting first set of runnables 

public void testAddRunnable() throws Exception {	int runnableCount = 3;	int runCount = 5;	startRunnables(runnableCount, runCount);	Thread.sleep(THREAD_COUNT * TestRunnable.SLEEP_MILLIS);	
starting second set of runnables 

========================= camel sample_13812 =========================

protected void doStart() throws Exception {	ServiceHelper.startService(mFormatter);	if (mJmxEndpoint.isPlatformServer()) {	setServerConnection(ManagementFactory.getPlatformMBeanServer());	} else {	try {	initNetworkConnection();	} catch (IOException e) {	if (!mJmxEndpoint.getTestConnectionOnStartup()) {	
failed to connect to jmx server 

protected void scheduleDelayedStart() throws Exception {	Runnable startRunnable = new Runnable() {	public void run() {	try {	doStart();	} catch (Exception e) {	
an unrecoverable exception has occurred while starting the jmx consumer for endpoint 

protected void scheduleDelayedStart() throws Exception {	Runnable startRunnable = new Runnable() {	public void run() {	try {	doStart();	} catch (Exception e) {	}	}	};	
delaying jmx consumer startup for endpoint trying again in seconds 

public void handleNotification(Notification notification, Object handback) {	JMXConnectionNotification connectionNotification = (JMXConnectionNotification)notification;	if (!connectionNotification.getConnectionId().equals(mConnectionId)) {	return;	}	if (connectionNotification.getType().equals(JMXConnectionNotification.NOTIFS_LOST) || connectionNotification.getType().equals(JMXConnectionNotification.CLOSED) || connectionNotification.getType().equals(JMXConnectionNotification.FAILED)) {	
lost jmx connection for 

public void handleNotification(Notification notification, Object handback) {	JMXConnectionNotification connectionNotification = (JMXConnectionNotification)notification;	if (!connectionNotification.getConnectionId().equals(mConnectionId)) {	return;	}	if (connectionNotification.getType().equals(JMXConnectionNotification.NOTIFS_LOST) || connectionNotification.getType().equals(JMXConnectionNotification.CLOSED) || connectionNotification.getType().equals(JMXConnectionNotification.FAILED)) {	if (mJmxEndpoint.getReconnectOnConnectionFailure()) {	scheduleReconnect();	} else {	
the jmx consumer will not be reconnected use reconnectonconnectionfailure to enable reconnections 

protected void scheduleReconnect() {	Runnable startRunnable = new Runnable() {	public void run() {	try {	initNetworkConnection();	addNotificationListener();	} catch (Exception e) {	
failed to reconnect to jmx server 

Runnable startRunnable = new Runnable() {	public void run() {	try {	initNetworkConnection();	addNotificationListener();	} catch (Exception e) {	scheduleReconnect();	}	}	};	
delaying jmx consumer reconnection for endpoint trying again in seconds 

========================= camel sample_12700 =========================

public void testBeanPerformance() throws Exception {	StopWatch watch = new StopWatch();	
invoking a bean in a route times 

public void testBeanPerformance() throws Exception {	StopWatch watch = new StopWatch();	for (int i = 0; i < times; i++) {	template.sendBody("direct:start", "Hello World");	}	
took to invoke the bean times 

========================= camel sample_3285 =========================

protected void doStart() throws Exception {	super.doStart();	if (LOG.isInfoEnabled()) {	
starting trap consumer on 

if ("tcp".equals(endpoint.getProtocol())) {	this.transport = new DefaultTcpTransportMapping((TcpAddress)this.listenGenericAddress);	} else if ("udp".equals(endpoint.getProtocol())) {	this.transport = new DefaultUdpTransportMapping((UdpAddress)this.listenGenericAddress);	} else {	throw new IllegalArgumentException("Unknown protocol: " + endpoint.getProtocol());	}	this.snmp = new Snmp(transport);	this.snmp.addCommandResponder(this);	if (LOG.isDebugEnabled()) {	
starting trap consumer on using protocol 

this.transport = new DefaultUdpTransportMapping((UdpAddress)this.listenGenericAddress);	} else {	throw new IllegalArgumentException("Unknown protocol: " + endpoint.getProtocol());	}	this.snmp = new Snmp(transport);	this.snmp.addCommandResponder(this);	if (LOG.isDebugEnabled()) {	}	this.transport.listen();	if (LOG.isInfoEnabled()) {	
started trap consumer on using protocol 

protected void doStop() throws Exception {	if (this.transport != null && this.transport.isListening()) {	if (LOG.isDebugEnabled()) {	
stopping trap consumer on 

protected void doStop() throws Exception {	if (this.transport != null && this.transport.isListening()) {	if (LOG.isDebugEnabled()) {	}	this.transport.close();	
stopped trap consumer on 

if (pdu != null) {	if ((pdu.getType() != PDU.TRAP) && (pdu.getType() != PDU.V1TRAP) && (pdu.getType() != PDU.REPORT) && (pdu.getType() != PDU.RESPONSE)) {	pdu.setErrorIndex(0);	pdu.setErrorStatus(0);	pdu.setType(PDU.RESPONSE);	StatusInformation statusInformation = new StatusInformation();	StateReference ref = event.getStateReference();	try {	event.getMessageDispatcher().returnResponsePdu(event.getMessageProcessingModel(), event.getSecurityModel(), event.getSecurityName(), event.getSecurityLevel(), pdu, event.getMaxSizeResponsePDU(), ref, statusInformation);	if (LOG.isDebugEnabled()) {	
response to inform sent 

try {	event.getMessageDispatcher().returnResponsePdu(event.getMessageProcessingModel(), event.getSecurityModel(), event.getSecurityName(), event.getSecurityLevel(), pdu, event.getMaxSizeResponsePDU(), ref, statusInformation);	if (LOG.isDebugEnabled()) {	}	} catch (MessageException ex) {	getExceptionHandler().handleException(ex);	}	}	processPDU(pdu, event);	} else {	
received invalid trap pdu 

public void processPDU(PDU pdu, CommandResponderEvent event) {	if (LOG.isDebugEnabled()) {	
received trap event for 

========================= camel sample_8830 =========================

public void testPerformance() {	JavaUuidGenerator uuidGenerator = new JavaUuidGenerator();	StopWatch watch = new StopWatch();	
first id 

public void testPerformance() {	JavaUuidGenerator uuidGenerator = new JavaUuidGenerator();	StopWatch watch = new StopWatch();	for (int i = 0; i < 500000; i++) {	uuidGenerator.generateUuid();	}	
last id 

public void testPerformance() {	JavaUuidGenerator uuidGenerator = new JavaUuidGenerator();	StopWatch watch = new StopWatch();	for (int i = 0; i < 500000; i++) {	uuidGenerator.generateUuid();	}	
took 

========================= camel sample_1312 =========================

public boolean unregister() {	if (--registrationCount <= 0) {	try {	dataStore.close();	} catch (IOException e) {	
error while closing datastore this exception is ignored 

========================= camel sample_14011 =========================

public void process(Exchange exchange) throws Exception {	exchange.addOnCompletion(new MyOnCompletion());	}	}) .end() .to("log:foo") .to("direct:b");	from("direct:b").routeId("route-b") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	assertEquals("route-b", MDC.get("camel.routeId"));	assertEquals(exchange.getExchangeId(), MDC.get("camel.exchangeId"));	assertEquals(exchange.getIn().getMessageId(), MDC.get("camel.messageId"));	MDC.put("custom.id", "1");	
from processor in route b 

public void onDone(Exchange exchange) {	assertEquals("route-a", MDC.get("camel.routeId"));	assertEquals(exchange.getExchangeId(), MDC.get("camel.exchangeId"));	assertEquals(exchange.getIn().getMessageId(), MDC.get("camel.messageId"));	assertEquals("1", MDC.get("custom.id"));	
from oncompletion after route a 

========================= camel sample_2494 =========================

}	Message message = chat.createMessage();	try {	message.setTo(JidCreate.from(room));	message.setFrom(JidCreate.from(endpoint.getUser()));	endpoint.getBinding().populateXmppMessage(message, exchange);	if (!connection.isConnected()) {	this.reconnect();	}	if (LOG.isDebugEnabled()) {	
sending xmpp message 

private synchronized void reconnect() throws InterruptedException, IOException, SmackException, XMPPException {	if (!connection.isConnected()) {	if (LOG.isDebugEnabled()) {	
reconnecting to 

protected void doStart() throws Exception {	if (connection == null) {	try {	connection = endpoint.createConnection();	} catch (SmackException e) {	if (endpoint.isTestConnectionOnStartup()) {	throw new RuntimeException("Could not connect to XMPP server:  " + endpoint.getConnectionDescription(), e);	} else {	
could not connect to xmpp server producer will attempt lazy connection when needed 

protected synchronized void initializeChat() throws InterruptedException, SmackException, XMPPException, XmppStringprepException {	if (chat == null) {	room = endpoint.resolveRoom(connection);	MultiUserChatManager chatManager = MultiUserChatManager.getInstanceFor(connection);	chat = chatManager.getMultiUserChat(JidCreate.entityBareFrom(room));	MucEnterConfiguration mucc = chat.getEnterConfigurationBuilder(Resourcepart.from(endpoint.getNickname())) .requestNoHistory() .build();	chat.join(mucc);	
joined room as 

protected void doStop() throws Exception {	if (chat != null) {	
leaving room 

========================= camel sample_12595 =========================

protected GenericFile<T> renameFile(GenericFileOperations<T> operations, GenericFile<T> from, GenericFile<T> to) throws IOException {	try {	operations.deleteFile(to.getAbsoluteFilePath());	} catch (GenericFileOperationFailedException e) {	}	boolean mkdir = operations.buildDirectory(to.getParent(), to.isAbsolute());	if (!mkdir) {	throw new GenericFileOperationFailedException("Cannot create directory: " + to.getParent() + " (could be because of denied permissions)");	}	
renaming file to 

protected void deleteLocalWorkFile(Exchange exchange) {	File local = exchange.getIn().getHeader(Exchange.FILE_LOCAL_WORK_PATH, File.class);	if (local != null && local.exists()) {	boolean deleted = FileUtil.deleteFile(local);	
local work file was deleted 

========================= camel sample_4813 =========================

for (ServiceReference<?> reference : references) {	if (reference != null) {	CamelContext camelContext = (CamelContext) bundleContext.getService(reference);	if (camelContext != null) {	camelContexts.add(camelContext);	}	}	}	}	} catch (Exception e) {	
cannot retrieve the list of camel contexts 

========================= camel sample_275 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<DnsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.dns.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.dns.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_760 =========================

public void process(final Exchange exchange) throws Exception {	final Message msg = exchange.getIn();	final Object value = msg.getBody();	
processing message 

========================= camel sample_17282 =========================

public void testSendToNonExistingEndpoint() throws Exception {	try {	template.sendBody("thisUriDoesNotExist", "<hello>world!</hello>");	fail("Should have failed to send this message!");	} catch (NoSuchEndpointException e) {	
caught expected exception 

========================= camel sample_1607 =========================

public void testChoiceSimple() throws InterruptedException {	template.setDefaultEndpointUri("direct:choice-simple");	execute(20000);	resetMock(count);	StopWatch watch = new StopWatch();	execute(count);	assertMockEndpointsSatisfied();	
ran tests in ms 

public void testChoiceExpression() throws InterruptedException {	template.setDefaultEndpointUri("direct:choice-expression");	execute(20000);	resetMock(count);	StopWatch watch = new StopWatch();	execute(count);	assertMockEndpointsSatisfied();	
ran tests in ms 

public void testFilterSimple() throws InterruptedException {	template.setDefaultEndpointUri("direct:filter-simple");	execute(20000);	resetMock(count);	StopWatch watch = new StopWatch();	execute(count);	assertMockEndpointsSatisfied();	
ran tests in ms 

public void testFilterExpression() throws InterruptedException {	template.setDefaultEndpointUri("direct:filter-expression");	execute(20000);	resetMock(count);	StopWatch watch = new StopWatch();	execute(count);	assertMockEndpointsSatisfied();	
ran tests in ms 

========================= camel sample_6438 =========================

public synchronized void process(Exchange exchange) throws Exception {	final Object body = exchange.getIn().getMandatoryBody();	final String solverId = getSolverId(exchange);	if (body.getClass().isAnnotationPresent(PlanningSolution.class) || body instanceof Solution) {	if (isAsync(exchange)) {	
asynchronously solving problem with id 

final Object body = exchange.getIn().getMandatoryBody();	final String solverId = getSolverId(exchange);	if (body.getClass().isAnnotationPresent(PlanningSolution.class) || body instanceof Solution) {	if (isAsync(exchange)) {	final Solver<Object> solver = endpoint.getOrCreateSolver(solverId);	executor.submit(new Runnable() {	public void run() {	try {	solver.solve(body);	} catch (Throwable e) {	
asynchronously solving failed for solverid 

final Solver<Object> solver = endpoint.getOrCreateSolver(solverId);	executor.submit(new Runnable() {	public void run() {	try {	solver.solve(body);	} catch (Throwable e) {	}	}	});	} else {	
synchronously solving problem with id 

});	} else {	Solver<Object> solver = endpoint.getSolver(solverId);	if (solver == null) {	solver = endpoint.createSolver();	}	solver.solve(body);	populateResult(exchange, solver);	}	} else if (body instanceof ProblemFactChange) {	
adding problemfactchange to solver with id 

} else if (body instanceof ProblemFactChange) {	Solver<Object> solver = endpoint.getOrCreateSolver(solverId);	solver.addProblemFactChange((ProblemFactChange<Object>)body);	if (!isAsync(exchange)) {	while (!solver.isEveryProblemFactChangeProcessed()) {	Thread.sleep(OptaPlannerConstants.IS_EVERY_PROBLEM_FACT_CHANGE_DELAY);	}	}	populateResult(exchange, solver);	} else {	
retrieving best score for solver 

private String getSolverId(Exchange exchange) throws Exception {	String solverId = exchange.getIn().getHeader(OptaPlannerConstants.SOLVER_ID, String.class);	if (solverId == null) {	solverId = configuration.getSolverId();	}	
solverid 

========================= camel sample_11706 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<RubyLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.ruby.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.ruby.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_1257 =========================

protected Message getFallback() {	synchronized (lock) {	fallbackInUse.set(true);	}	if (fallback == null && fallbackCommand == null) {	throw new UnsupportedOperationException("No fallback available.");	}	Throwable exception = getExecutionException();	if (exception != null) {	
error occurred processing will now run fallback exception class message 

protected Message getFallback() {	synchronized (lock) {	fallbackInUse.set(true);	}	if (fallback == null && fallbackCommand == null) {	throw new UnsupportedOperationException("No fallback available.");	}	Throwable exception = getExecutionException();	if (exception != null) {	} else {	
error occurred processing will now run fallback 

}	exchange.setProperty(Exchange.EXCEPTION_HANDLED, true);	exchange.setProperty(Exchange.EXCEPTION_CAUGHT, exception);	exchange.removeProperty(Exchange.ROUTE_STOP);	exchange.setException(null);	exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);	try {	if (fallbackCommand != null) {	return fallbackCommand.execute();	} else {	
running fallback with exchange 

exchange.setProperty(Exchange.EXCEPTION_HANDLED, true);	exchange.setProperty(Exchange.EXCEPTION_CAUGHT, exception);	exchange.removeProperty(Exchange.ROUTE_STOP);	exchange.setException(null);	exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);	try {	if (fallbackCommand != null) {	return fallbackCommand.execute();	} else {	fallback.process(exchange);	
running fallback with exchange done 

protected Message run() throws Exception {	
running processor with exchange 

protected Message run() throws Exception {	Exchange copy = ExchangeHelper.createCorrelatedCopy(exchange, false, false);	try {	processor.process(copy);	} catch (Exception e) {	copy.setException(e);	}	if (fallbackInUse.get()) {	
exiting run command as fallback is already in use processing exchange 

} catch (Exception e) {	copy.setException(e);	}	if (fallbackInUse.get()) {	return null;	}	Throwable hystrixExecutionException = getExecutionException();	Exception camelExchangeException = copy.getException();	synchronized (lock) {	if (fallbackInUse.get()) {	
exiting run command as fallback is already in use processing exchange 

if (fallbackInUse.get()) {	return null;	}	ExchangeHelper.copyResults(exchange, copy);	if (hystrixExecutionException != null) {	exchange.setException(new CamelExchangeException("Hystrix execution exception occurred while processing Exchange", exchange, hystrixExecutionException));	}	if (hystrixExecutionException == null && camelExchangeException != null) {	throw camelExchangeException;	}	
running processor with exchange done 

========================= camel sample_11356 =========================

public DefaultPackageScanClassResolver() {	try {	ClassLoader ccl = Thread.currentThread().getContextClassLoader();	if (ccl != null) {	
adding contextclassloader from current thread 

public DefaultPackageScanClassResolver() {	try {	ClassLoader ccl = Thread.currentThread().getContextClassLoader();	if (ccl != null) {	classLoaders.add(ccl);	}	} catch (Exception e) {	
cannot add contextclassloader from current thread due this exception will be ignored 

public Set<Class<?>> findAnnotated(Class<? extends Annotation> annotation, String... packageNames) {	if (packageNames == null) {	return Collections.emptySet();	}	if (log.isDebugEnabled()) {	
searching for annotations of in packages 

if (packageNames == null) {	return Collections.emptySet();	}	if (log.isDebugEnabled()) {	}	PackageScanFilter test = getCompositeFilter(new AnnotatedWithPackageScanFilter(annotation, true));	Set<Class<?>> classes = new LinkedHashSet<Class<?>>();	for (String pkg : packageNames) {	find(test, pkg, classes);	}	
found 

public Set<Class<?>> findAnnotated(Set<Class<? extends Annotation>> annotations, String... packageNames) {	if (packageNames == null) {	return Collections.emptySet();	}	if (log.isDebugEnabled()) {	
searching for annotations of in packages 

if (packageNames == null) {	return Collections.emptySet();	}	if (log.isDebugEnabled()) {	}	PackageScanFilter test = getCompositeFilter(new AnnotatedWithAnyPackageScanFilter(annotations, true));	Set<Class<?>> classes = new LinkedHashSet<Class<?>>();	for (String pkg : packageNames) {	find(test, pkg, classes);	}	
found 

public Set<Class<?>> findImplementations(Class<?> parent, String... packageNames) {	if (packageNames == null) {	return Collections.emptySet();	}	if (log.isDebugEnabled()) {	
searching for implementations of in packages 

if (packageNames == null) {	return Collections.emptySet();	}	if (log.isDebugEnabled()) {	}	PackageScanFilter test = getCompositeFilter(new AssignableToPackageScanFilter(parent));	Set<Class<?>> classes = new LinkedHashSet<Class<?>>();	for (String pkg : packageNames) {	find(test, pkg, classes);	}	
found 

public Set<Class<?>> findByFilter(PackageScanFilter filter, String... packageNames) {	if (packageNames == null) {	return Collections.emptySet();	}	Set<Class<?>> classes = new LinkedHashSet<Class<?>>();	for (String pkg : packageNames) {	find(filter, pkg, classes);	}	
found 

protected void find(PackageScanFilter test, String packageName, ClassLoader loader, Set<Class<?>> classes) {	if (log.isTraceEnabled()) {	
searching for in package using classloader 

protected void find(PackageScanFilter test, String packageName, ClassLoader loader, Set<Class<?>> classes) {	if (log.isTraceEnabled()) {	}	Enumeration<URL> urls;	try {	urls = getResources(loader, packageName);	if (!urls.hasMoreElements()) {	
no urls returned by classloader 

protected void find(PackageScanFilter test, String packageName, ClassLoader loader, Set<Class<?>> classes) {	if (log.isTraceEnabled()) {	}	Enumeration<URL> urls;	try {	urls = getResources(loader, packageName);	if (!urls.hasMoreElements()) {	}	} catch (IOException ioe) {	
cannot read package 

urls = getResources(loader, packageName);	if (!urls.hasMoreElements()) {	}	} catch (IOException ioe) {	return;	}	while (urls.hasMoreElements()) {	URL url = null;	try {	url = urls.nextElement();	
url from classloader 

return;	}	while (urls.hasMoreElements()) {	URL url = null;	try {	url = urls.nextElement();	url = customResourceLocator(url);	String urlPath = url.getFile();	urlPath = URLDecoder.decode(urlPath, "UTF-8");	if (log.isTraceEnabled()) {	
decoded urlpath with protocol 

if (urlPath.startsWith("file:")) {	try {	urlPath = new URI(url.getFile()).getPath();	} catch (URISyntaxException e) {	}	if (urlPath.startsWith("file:")) {	urlPath = urlPath.substring(5);	}	}	if (url.toString().startsWith("bundle:") || urlPath.startsWith("bundle:")) {	
skipping osgi bundle 

} catch (URISyntaxException e) {	}	if (urlPath.startsWith("file:")) {	urlPath = urlPath.substring(5);	}	}	if (url.toString().startsWith("bundle:") || urlPath.startsWith("bundle:")) {	continue;	}	if (url.toString().startsWith("bundleresource:") || urlPath.startsWith("bundleresource:")) {	
skipping bundleresource 

}	if (url.toString().startsWith("bundle:") || urlPath.startsWith("bundle:")) {	continue;	}	if (url.toString().startsWith("bundleresource:") || urlPath.startsWith("bundleresource:")) {	continue;	}	if (urlPath.indexOf('!') > 0) {	urlPath = urlPath.substring(0, urlPath.indexOf('!'));	}	
scanning for classes in matching criteria 

continue;	}	if (url.toString().startsWith("bundleresource:") || urlPath.startsWith("bundleresource:")) {	continue;	}	if (urlPath.indexOf('!') > 0) {	urlPath = urlPath.substring(0, urlPath.indexOf('!'));	}	File file = new File(urlPath);	if (file.isDirectory()) {	
loading from directory using file 

}	if (urlPath.indexOf('!') > 0) {	urlPath = urlPath.substring(0, urlPath.indexOf('!'));	}	File file = new File(urlPath);	if (file.isDirectory()) {	loadImplementationsInDirectory(test, packageName, file, classes);	} else {	InputStream stream;	if (urlPath.startsWith("http:") || urlPath.startsWith("https:") || urlPath.startsWith("sonicfs:") || isAcceptableScheme(urlPath)) {	
loading from jar using url 

if (file.isDirectory()) {	loadImplementationsInDirectory(test, packageName, file, classes);	} else {	InputStream stream;	if (urlPath.startsWith("http:") || urlPath.startsWith("https:") || urlPath.startsWith("sonicfs:") || isAcceptableScheme(urlPath)) {	URL urlStream = new URL(urlPath);	URLConnection con = urlStream.openConnection();	con.setUseCaches(false);	stream = con.getInputStream();	} else {	
loading from jar using file 

URL urlStream = new URL(urlPath);	URLConnection con = urlStream.openConnection();	con.setUseCaches(false);	stream = con.getInputStream();	} else {	stream = new FileInputStream(file);	}	loadImplementationsInJar(test, packageName, stream, urlPath, classes, jarCache);	}	} catch (IOException e) {	
cannot read entries in url 

protected Enumeration<URL> getResources(ClassLoader loader, String packageName) throws IOException {	
getting resource url for package with classloader 

private void loadImplementationsInJar(PackageScanFilter test, String parent, InputStream stream, String urlPath, Set<Class<?>> classes, Map<String, List<String>> jarCache) {	ObjectHelper.notNull(classes, "classes");	List<String> entries = jarCache != null ? jarCache.get(urlPath) : null;	if (entries == null) {	entries = doLoadJarClassEntries(stream, urlPath);	if (jarCache != null) {	jarCache.put(urlPath, entries);	
cached jar with entries 

private void loadImplementationsInJar(PackageScanFilter test, String parent, InputStream stream, String urlPath, Set<Class<?>> classes, Map<String, List<String>> jarCache) {	ObjectHelper.notNull(classes, "classes");	List<String> entries = jarCache != null ? jarCache.get(urlPath) : null;	if (entries == null) {	entries = doLoadJarClassEntries(stream, urlPath);	if (jarCache != null) {	jarCache.put(urlPath, entries);	}	} else {	
using cached jar with entries 

while ((entry = jarStream.getNextJarEntry()) != null) {	String name = entry.getName();	if (name != null) {	name = name.trim();	if (!entry.isDirectory() && name.endsWith(".class")) {	entries.add(name);	}	}	}	} catch (IOException ioe) {	
cannot search jar file due to an ioexception 

protected void addIfMatching(PackageScanFilter test, String fqn, Set<Class<?>> classes) {	try {	String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.');	Set<ClassLoader> set = getClassLoaders();	boolean found = false;	for (ClassLoader classLoader : set) {	if (log.isTraceEnabled()) {	
testing for class matches criteria using classloader 

protected void addIfMatching(PackageScanFilter test, String fqn, Set<Class<?>> classes) {	try {	String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.');	Set<ClassLoader> set = getClassLoaders();	boolean found = false;	for (ClassLoader classLoader : set) {	if (log.isTraceEnabled()) {	}	try {	Class<?> type = classLoader.loadClass(externalName);	
loaded the class in classloader 

try {	String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.');	Set<ClassLoader> set = getClassLoaders();	boolean found = false;	for (ClassLoader classLoader : set) {	if (log.isTraceEnabled()) {	}	try {	Class<?> type = classLoader.loadClass(externalName);	if (test.matches(type)) {	
found class which matches the filter in classloader 

}	try {	Class<?> type = classLoader.loadClass(externalName);	if (test.matches(type)) {	classes.add(type);	}	found = true;	break;	} catch (ClassNotFoundException e) {	if (log.isTraceEnabled()) {	
cannot find class in classloader reason 

if (test.matches(type)) {	classes.add(type);	}	found = true;	break;	} catch (ClassNotFoundException e) {	if (log.isTraceEnabled()) {	}	} catch (NoClassDefFoundError e) {	if (log.isTraceEnabled()) {	
cannot find the class definition in classloader reason 

break;	} catch (ClassNotFoundException e) {	if (log.isTraceEnabled()) {	}	} catch (NoClassDefFoundError e) {	if (log.isTraceEnabled()) {	}	}	}	if (!found) {	
cannot find class in any classloaders 

}	} catch (NoClassDefFoundError e) {	if (log.isTraceEnabled()) {	}	}	}	if (!found) {	}	} catch (Exception e) {	if (log.isWarnEnabled()) {	
cannot examine class due to a with message 

========================= camel sample_4055 =========================

public Processor wrapProcessorInInterceptors(final CamelContext context, final ProcessorDefinition<?> definition, final Processor target, final Processor nextTarget) throws Exception {	if (definition instanceof RoutingSlipDefinition<?>) {	final DelegateAsyncProcessor delegateAsyncProcessor = new DelegateAsyncProcessor() {	public boolean process(final Exchange exchange, final AsyncCallback callback) {	
i m doing someting 

public Processor wrapProcessorInInterceptors(final CamelContext context, final ProcessorDefinition<?> definition, final Processor target, final Processor nextTarget) throws Exception {	if (definition instanceof RoutingSlipDefinition<?>) {	final DelegateAsyncProcessor delegateAsyncProcessor = new DelegateAsyncProcessor() {	public boolean process(final Exchange exchange, final AsyncCallback callback) {	return super.process(exchange, new AsyncCallback() {	public void done(final boolean doneSync) {	
i m done 

========================= camel sample_3840 =========================

public OperationResult<String> getResult() {	try {	Stat statistics = connection.exists(node, true);	boolean ok = isOk(statistics);	if (LOG.isTraceEnabled()) {	
node exists node does not exist 

========================= camel sample_12653 =========================

protected Authentication getAuthentication(Message message) {	Subject subject = message.getHeader(Exchange.AUTHENTICATION, Subject.class);	Authentication answer = null;	if (subject != null) {	answer = getAuthenticationAdapter().toAuthentication(subject);	}	if (answer == null && useThreadSecurityContext) {	answer = SecurityContextHolder.getContext().getAuthentication();	
get the authentication from securitycontextholder 

private Authentication authenticateIfRequired(Authentication authentication) {	if (authentication.isAuthenticated() && !alwaysReauthenticate) {	
previously authenticated 

private Authentication authenticateIfRequired(Authentication authentication) {	if (authentication.isAuthenticated() && !alwaysReauthenticate) {	return authentication;	}	authentication = authenticationManager.authenticate(authentication);	
successfully authenticated 

========================= camel sample_12203 =========================

protected void doStart() throws Exception {	super.doStart();	if (client == null) {	
connecting to the elasticsearch cluster 

protected void doStart() throws Exception {	super.doStart();	if (client == null) {	if (configuration.getIp() != null) {	client = createClient().addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(configuration.getIp()), configuration.getPort()));	} else if (configuration.getTransportAddressesList() != null && !configuration.getTransportAddressesList().isEmpty()) {	List<TransportAddress> addresses = new ArrayList<TransportAddress>(configuration.getTransportAddressesList().size());	addresses.addAll(configuration.getTransportAddressesList());	client = createClient().addTransportAddresses(addresses.toArray(new TransportAddress[addresses.size()]));	} else {	
incorrect ip address and port parameters settings for elasticsearch cluster 

private TransportClient createClient() throws Exception {	final Settings.Builder settings = getSettings();	final CamelContext camelContext = getEndpoint().getCamelContext();	final Class<?> clazz = camelContext.getClassResolver().resolveClass("org.elasticsearch.xpack.client.PreBuiltXPackTransportClient");	if (clazz != null) {	Constructor<?> ctor = clazz.getConstructor(Settings.class, Class[].class);	settings.put("xpack.security.user", configuration.getUser() + ":" + configuration.getPassword()) .put("xpack.security.transport.ssl.enabled", configuration.getEnableSSL());	
xpack client was found on the classpath 

private TransportClient createClient() throws Exception {	final Settings.Builder settings = getSettings();	final CamelContext camelContext = getEndpoint().getCamelContext();	final Class<?> clazz = camelContext.getClassResolver().resolveClass("org.elasticsearch.xpack.client.PreBuiltXPackTransportClient");	if (clazz != null) {	Constructor<?> ctor = clazz.getConstructor(Settings.class, Class[].class);	settings.put("xpack.security.user", configuration.getUser() + ":" + configuration.getPassword()) .put("xpack.security.transport.ssl.enabled", configuration.getEnableSSL());	return (TransportClient) ctor.newInstance(new Object[]{settings.build(), new Class[0]});	} else {	
xpack client was not found on the classpath using the standard client 

protected void doStop() throws Exception {	if (client != null) {	
disconnecting from elasticsearch cluster 

========================= camel sample_12716 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from(timeOutEndpointUri).to("jms:queue:test.b");	from("jms:queue:test.b").aggregate(header("cheese"), new AggregationStrategy() {	public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {	try {	Thread.sleep(2000);	} catch (InterruptedException e) {	
aggregration delay sleep inturrepted 

public void process(Exchange exchange) throws Exception {	
get the exchange here 

========================= camel sample_7045 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() {	from("direct:start") .to("sjms:topic:test.topic?transacted=true") .process( new Processor() {	public void process(Exchange exchange) throws Exception {	if (exchange.getIn().getHeader("isfailed", Boolean.class)) {	
we failed should roll back 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() {	from("direct:start") .to("sjms:topic:test.topic?transacted=true") .process( new Processor() {	public void process(Exchange exchange) throws Exception {	if (exchange.getIn().getHeader("isfailed", Boolean.class)) {	exchange.getOut().setFault(true);	} else {	
we passed should commit 

========================= camel sample_12346 =========================

public Consumer createConsumer(Processor processor) throws Exception {	
creating a consumer 

public Producer createProducer() throws Exception {	
creating a producer 

========================= camel sample_9958 =========================

public void testGetPerson() throws Exception {	execute(new Runnable() {	public void run() {	final Person person = peopleResource.getPerson(":(id)", true);	assertNotNull(person);	assertNotNull(person.getId());	
getperson result 

public void testGetPosts() throws Exception {	execute(new Runnable() {	public void run() {	final GroupMemberships groupMemberships = peopleResource.getGroupMemberships(MembershipStateCode.MEMBER, "", null, null);	assertNotNull(groupMemberships);	assertNotNull(groupMemberships.getGroupMembershipList());	assertFalse(groupMemberships.getGroupMembershipList().isEmpty());	final Posts posts = peopleResource.getPosts(Long.parseLong( groupMemberships.getGroupMembershipList().get(0).getGroup().getId()), null, null, Order.RECENCY, PostRole.FOLLOWER, PostCategoryCode.DISCUSSION, null, ":(id)");	assertNotNull(posts);	
getposts result 

public void testLinkedInException() throws Exception {	try {	peopleResource.getPerson("bad_fields_selector", true);	} catch (LinkedInException e) {	assertNotNull(e.getError());	
getperson error 

public void testGetSuggestedJobs() throws Exception {	execute(new Runnable() {	public void run() {	final JobSuggestions suggestedJobs = peopleResource.getSuggestedJobs(DEFAULT_FIELDS);	assertNotNull(suggestedJobs);	
suggested jobs 

========================= camel sample_8867 =========================

public void test() throws Exception {	URL url = ObjectHelper.loadResourceAsURL("org/apache/camel/itest/CamelJacksonFallbackConverterTest.xml", CamelJacksonFallbackConverterTest.class.getClassLoader());	installBlueprintAsBundle("CamelJacksonFallbackConverterTest", url, true);	CamelContext camel = getOsgiService(bundleContext, CamelContext.class);	camel.getProperties().put(JacksonConstants.ENABLE_TYPE_CONVERTER, "true");	camel.getProperties().put(JacksonConstants.TYPE_CONVERTER_TO_POJO, "true");	final Pojo pojo = new Pojo(1337, "Constantine");	final DefaultExchange exchange = new DefaultExchange(camel);	final String string = camel.getTypeConverter().mandatoryConvertTo(String.class, exchange, pojo);	
pojo string 

public void test() throws Exception {	URL url = ObjectHelper.loadResourceAsURL("org/apache/camel/itest/CamelJacksonFallbackConverterTest.xml", CamelJacksonFallbackConverterTest.class.getClassLoader());	installBlueprintAsBundle("CamelJacksonFallbackConverterTest", url, true);	CamelContext camel = getOsgiService(bundleContext, CamelContext.class);	camel.getProperties().put(JacksonConstants.ENABLE_TYPE_CONVERTER, "true");	camel.getProperties().put(JacksonConstants.TYPE_CONVERTER_TO_POJO, "true");	final Pojo pojo = new Pojo(1337, "Constantine");	final DefaultExchange exchange = new DefaultExchange(camel);	final String string = camel.getTypeConverter().mandatoryConvertTo(String.class, exchange, pojo);	final Pojo copy = camel.getTypeConverter().mandatoryConvertTo(Pojo.class, exchange, string);	
string pojo 

========================= camel sample_6480 =========================

protected void doGetPersistentVolume(Exchange exchange, String operation) throws Exception {	PersistentVolume pv = null;	String pvName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_PERSISTENT_VOLUME_NAME, String.class);	if (ObjectHelper.isEmpty(pvName)) {	
get a specific persistent volume require specify a persistent volume name 

========================= camel sample_13279 =========================

public void testCapture() {	
testError 

========================= camel sample_16581 =========================

private PropertyEditor lookupEditor(Class<?> type) {	if (misses.containsKey(type)) {	
no previously found property editor for type 

private PropertyEditor lookupEditor(Class<?> type) {	if (misses.containsKey(type)) {	return null;	}	synchronized (cache) {	PropertyEditor editor = cache.get(type);	if (editor == null) {	editor = PropertyEditorManager.findEditor(type);	if (editor != null) {	
found property editor for type 

if (misses.containsKey(type)) {	return null;	}	synchronized (cache) {	PropertyEditor editor = cache.get(type);	if (editor == null) {	editor = PropertyEditorManager.findEditor(type);	if (editor != null) {	cache.put(type, editor);	} else {	
cannot find property editor for type 

========================= camel sample_4002 =========================

public void testLoadAndRecoverJdbcAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(SIZE / 10);	mock.setResultWaitTime(50 * 1000);	
staring to send messages 

public void testLoadAndRecoverJdbcAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(SIZE / 10);	mock.setResultWaitTime(50 * 1000);	for (int i = 0; i < SIZE; i++) {	final int value = 1;	char id = 'A';	Map<String, Object> headers = new HashMap<String, Object>();	headers.put("id", id);	headers.put("seq", i);	
sending with id 

mock.setResultWaitTime(50 * 1000);	for (int i = 0; i < SIZE; i++) {	final int value = 1;	char id = 'A';	Map<String, Object> headers = new HashMap<String, Object>();	headers.put("id", id);	headers.put("seq", i);	template.sendBodyAndHeaders("seda:start?size=" + SIZE, value, headers);	Thread.sleep(3);	}	
sending all message done now waiting for aggregation to complete 

========================= camel sample_8922 =========================

protected void doStart() throws Exception {	super.doStart();	if (entityManagerFactory == null) {	Map<String, EntityManagerFactory> map = getCamelContext().getRegistry().findByTypeWithName(EntityManagerFactory.class);	if (map != null) {	if (map.size() == 1) {	entityManagerFactory = map.values().iterator().next();	
using entitymanagerfactory found in registry with id 

protected void doStart() throws Exception {	super.doStart();	if (entityManagerFactory == null) {	Map<String, EntityManagerFactory> map = getCamelContext().getRegistry().findByTypeWithName(EntityManagerFactory.class);	if (map != null) {	if (map.size() == 1) {	entityManagerFactory = map.values().iterator().next();	} else {	
could not find a single entitymanagerfactory in registry as there was instances 

super.doStart();	if (entityManagerFactory == null) {	Map<String, EntityManagerFactory> map = getCamelContext().getRegistry().findByTypeWithName(EntityManagerFactory.class);	if (map != null) {	if (map.size() == 1) {	entityManagerFactory = map.values().iterator().next();	} else {	}	}	} else {	
using entitymanagerfactory configured 

} else {	}	}	} else {	}	if (transactionManager == null) {	Map<String, PlatformTransactionManager> map = getCamelContext().getRegistry().findByTypeWithName(PlatformTransactionManager.class);	if (map != null) {	if (map.size() == 1) {	transactionManager = map.values().iterator().next();	
using transactionmanager found in registry with id 

}	}	} else {	}	if (transactionManager == null) {	Map<String, PlatformTransactionManager> map = getCamelContext().getRegistry().findByTypeWithName(PlatformTransactionManager.class);	if (map != null) {	if (map.size() == 1) {	transactionManager = map.values().iterator().next();	} else {	
could not find a single transactionmanager in registry as there was instances 

}	if (transactionManager == null) {	Map<String, PlatformTransactionManager> map = getCamelContext().getRegistry().findByTypeWithName(PlatformTransactionManager.class);	if (map != null) {	if (map.size() == 1) {	transactionManager = map.values().iterator().next();	} else {	}	}	} else {	
using transactionmanager configured on this component 

} else {	}	}	} else {	}	if (transactionManager == null) {	Map<String, TransactionTemplate> map = getCamelContext().getRegistry().findByTypeWithName(TransactionTemplate.class);	if (map != null) {	if (map.size() == 1) {	transactionManager = map.values().iterator().next().getTransactionManager();	
using transactionmanager found in registry with id 

}	}	} else {	}	if (transactionManager == null) {	Map<String, TransactionTemplate> map = getCamelContext().getRegistry().findByTypeWithName(TransactionTemplate.class);	if (map != null) {	if (map.size() == 1) {	transactionManager = map.values().iterator().next().getTransactionManager();	} else {	
could not find a single transactiontemplate in registry as there was instances 

if (transactionManager == null) {	Map<String, TransactionTemplate> map = getCamelContext().getRegistry().findByTypeWithName(TransactionTemplate.class);	if (map != null) {	if (map.size() == 1) {	transactionManager = map.values().iterator().next().getTransactionManager();	} else {	}	}	}	if (entityManagerFactory == null) {	
no entitymanagerfactory has been configured on this jpacomponent each jpaendpoint will auto create their own entitymanagerfactory 

if (map != null) {	if (map.size() == 1) {	transactionManager = map.values().iterator().next().getTransactionManager();	} else {	}	}	}	if (entityManagerFactory == null) {	}	if (transactionManager == null) {	
no transactionmanager has been configured on this jpacomponent each jpaendpoint will auto create their own jpatransactionmanager 

========================= camel sample_14103 =========================

private void getAction(Exchange exchange) throws Exception {	Integer actionId = exchange.getIn().getHeader(DigitalOceanHeaders.ID, Integer.class);	if (ObjectHelper.isEmpty(actionId)) {	throw new IllegalArgumentException(DigitalOceanHeaders.ID + " must be specified");	}	Action action = getEndpoint().getDigitalOceanClient().getActionInfo(actionId);	
action 

private void getActions(Exchange exchange) throws Exception {	Actions actions = getEndpoint().getDigitalOceanClient().getAvailableActions(configuration.getPage(), configuration.getPerPage());	
all actions page per page 

========================= camel sample_8888 =========================

protected void setUp() throws Exception {	try {	super.setUp();	fail("Should have failed to create this route!");	} catch (FailedToCreateRouteException e) {	
caught expected exception 

========================= camel sample_1650 =========================

onException(Exception.class). handled(true). to("log:LOGGER"). to("mock:ObjectCacheProducerTest.cacheException");	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). to("cache: from("direct:aGet"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_GET)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). to("cache: choice().when(header(CacheConstants.CACHE_ELEMENT_WAS_FOUND).isNotNull()). to("mock:ObjectCacheProducerTest.result").end();	from("direct:b"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson_2")). to("cache: from("direct:bGet"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_GET)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson_2")). to("cache: choice().when(header(CacheConstants.CACHE_ELEMENT_WAS_FOUND).isNotNull()). to("mock:ObjectCacheProducerTest.result").end();	from("direct:c"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson_3")). to("cache: from("direct:cGet"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_GET)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson_3")). to("cache: choice().when(header(CacheConstants.CACHE_ELEMENT_WAS_FOUND).isNotNull()). to("mock:ObjectCacheProducerTest.result").end();	}	});	context.setTracing(true);	context.start();	resultEndpoint.expectedMessageCount(2);	cacheExceptionEndpoint.expectedMessageCount(0);	
beginning cacheproducer add and get test 

onException(Exception.class). handled(true). to("log:LOGGER"). to("mock:ObjectCacheProducerTest.cacheException");	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). to("cache: from("direct:aGet"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_GET)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). to("cache: choice().when(header(CacheConstants.CACHE_ELEMENT_WAS_FOUND).isNotNull()). to("mock:ObjectCacheProducerTest.result").end();	from("direct:b"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson_2")). to("cache: from("direct:bGet"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_GET)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson_2")). to("cache: choice().when(header(CacheConstants.CACHE_ELEMENT_WAS_FOUND).isNotNull()). to("mock:ObjectCacheProducerTest.result").end();	from("direct:c"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson_3")). to("cache: from("direct:cGet"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_GET)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson_3")). to("cache: choice().when(header(CacheConstants.CACHE_ELEMENT_WAS_FOUND).isNotNull()). to("mock:ObjectCacheProducerTest.result").end();	}	});	context.setTracing(true);	context.start();	resultEndpoint.expectedMessageCount(2);	cacheExceptionEndpoint.expectedMessageCount(0);	
putting data into cache 

from("direct:c"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson_3")). to("cache: from("direct:cGet"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_GET)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson_3")). to("cache: choice().when(header(CacheConstants.CACHE_ELEMENT_WAS_FOUND).isNotNull()). to("mock:ObjectCacheProducerTest.result").end();	}	});	context.setTracing(true);	context.start();	resultEndpoint.expectedMessageCount(2);	cacheExceptionEndpoint.expectedMessageCount(0);	sendNonSerializedData("direct:a", newPoetry("Ralph Waldo Emerson", "Brahma"));	sendNonSerializedData("direct:b", newPoetry("Ralph Waldo Emerson", "The Rhodora"));	sendNonSerializedData("direct:c", newPoetry("Ralph Waldo Emerson", "Concord Hymn"));	
retrieving data from cache 

========================= camel sample_10510 =========================

public boolean process(final Exchange exchange, final AsyncCallback callback) {	final Exchange copy = prepareExchange(exchange);	ClassLoader current = Thread.currentThread().getContextClassLoader();	boolean changed = false;	try {	ClassLoader appClassLoader = endpoint.getCamelContext().getApplicationContextClassLoader();	if (appClassLoader != null) {	
setting thread contextclassloader to 

ClassLoader appClassLoader = endpoint.getCamelContext().getApplicationContextClassLoader();	if (appClassLoader != null) {	Thread.currentThread().setContextClassLoader(appClassLoader);	changed = true;	}	final boolean chgd = changed;	return processor.process(copy, new AsyncCallback() {	public void done(boolean done) {	try {	if (chgd) {	
restoring thread contextclassloader to 

Thread.currentThread().setContextClassLoader(current);	}	ExchangeHelper.copyResults(exchange, copy);	} finally {	callback.done(done);	}	}	});	} finally {	if (changed) {	
restoring thread contextclassloader to 

========================= camel sample_4901 =========================

}	if (!interceptorHolder.getInFaultInterceptors().isEmpty()) {	factory.setInFaultInterceptors(interceptorHolder.getInFaultInterceptors());	}	if (getProperties() != null) {	if (factory.getProperties() != null) {	factory.getProperties().putAll(getProperties());	} else {	factory.setProperties(getProperties());	}	
jaxrs factorybean added properties 

public void setBus(Bus bus) {	this.bus = bus;	if (defaultBus) {	BusFactory.setDefaultBus(bus);	
set bus as thread default bus 

========================= camel sample_8021 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<AtomixMapComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.atomix-map.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.atomix-map.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1083 =========================

public KeyStore createKeyStore() throws GeneralSecurityException, IOException {	
creating keystore instance from keystoreparameters 

} else {	InputStream is = this.resolveResource(this.parsePropertyValue(this.resource));	ks.load(is, ksPassword);	}	if (LOG.isDebugEnabled()) {	List<String> aliases = new LinkedList<String>();	Enumeration<String> aliasEnum = ks.aliases();	while (aliasEnum.hasMoreElements()) {	aliases.add(aliasEnum.nextElement());	}	
keystore initialized from is using provider has type and contains aliases 

========================= camel sample_4281 =========================

public static void startThriftServer() throws Exception {	processor = new Calculator.Processor(new CalculatorSyncServerImpl());	serverTransport = new TNonblockingServerSocket(THRIFT_TEST_PORT);	server = new THsHaServer(new Args(serverTransport).processor(processor));	Runnable simple = new Runnable() {	public void run() {	
thrift server started on port 

public static void stopThriftServer() throws IOException {	if (server != null) {	server.stop();	serverTransport.close();	
thrift server stoped 

========================= camel sample_13015 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<LambdaComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-lambda.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-lambda.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1129 =========================

public void testPollEnrich() throws Exception {	getMockEndpoint("mock:start").expectedBodiesReceived("Start");	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceived("Big file");	mock.expectedFileExists("target/enrich/.done/AAA.fin");	mock.expectedFileExists("target/enrichdata/.done/AAA.dat");	
file log info file 

public void testPollEnrich() throws Exception {	getMockEndpoint("mock:start").expectedBodiesReceived("Start");	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceived("Big file");	mock.expectedFileExists("target/enrich/.done/AAA.fin");	mock.expectedFileExists("target/enrichdata/.done/AAA.dat");	Thread.sleep(250);	
file log info done 

========================= camel sample_3114 =========================

public void testSenderXmlData() throws Exception {	MockEndpoint result = getMockEndpoint("mock:result");	result.reset();	result.expectedMessageCount(4);	template.sendBody("direct:endpoint", xmlData);	assertMockEndpointsSatisfied();	for (Exchange exchange : result.getExchanges()) {	String message = exchange.getIn().getBody(String.class);	
the message is 

========================= camel sample_2355 =========================

protected void doStart() throws Exception {	super.doStart();	if (server == null) {	
starting the grpc server 

protected void doStart() throws Exception {	super.doStart();	if (server == null) {	initializeServer();	server.start();	
grpc server started and listening on port 

protected void doStop() throws Exception {	if (server != null) {	
terminating grpc server 

ProxyFactory serviceProxy = new ProxyFactory();	ServerInterceptor headerInterceptor = new GrpcHeaderInterceptor();	MethodHandler methodHandler = new GrpcMethodHandler(endpoint, this);	serviceProxy.setSuperclass(GrpcUtils.constructGrpcImplBaseClass(endpoint.getServicePackage(), endpoint.getServiceName(), endpoint.getCamelContext()));	try {	bindableService = (BindableService)serviceProxy.create(new Class<?>[0], new Object[0], methodHandler);	} catch (NoSuchMethodException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException e) {	throw new IllegalArgumentException("Unable to create bindable proxy service for " + configuration.getService());	}	if (!ObjectHelper.isEmpty(configuration.getHost()) && !ObjectHelper.isEmpty(configuration.getPort())) {	
building grpc server on 

private boolean doSend(Exchange exchange, AsyncCallback callback) {	if (this.isRunAllowed()) {	this.getAsyncProcessor().process(exchange, doneSync -> {	if (exchange.getException() != null) {	getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException());	}	callback.done(doneSync);	});	return false;	} else {	
consumer not ready to process exchanges the exchange will be discarded 

========================= camel sample_7507 =========================

public void testAddFileComment() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.fileId", testFile.getID());	headers.put("CamelBox.message", CAMEL_TEST_FILE_COMMENT);	final com.box.sdk.BoxFile result = requestBodyAndHeaders("direct: assertNotNull("addFileComment result", result);	assertNotNull("addFileComment comments", result.getComments());	assertTrue("changeCommentMessage comments size", result.getComments().size() > 0);	assertEquals("changeCommentMessage comment message", CAMEL_TEST_FILE_COMMENT, result.getComments().get(0).getMessage());	
addfilecomment 

public void testChangeCommentMessage() throws Exception {	BoxComment.Info commentInfo = testFile.addComment(CAMEL_TEST_FILE_COMMENT);	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.commentId", commentInfo.getID());	headers.put("CamelBox.message", CAMEL_TEST_FILE_CHANGED_COMMENT);	final com.box.sdk.BoxComment result = requestBodyAndHeaders("direct: assertNotNull("changeCommentMessage result", result);	assertNotNull("changeCommentMessage message", result.getInfo().getMessage());	assertEquals("changeCommentMessage message", CAMEL_TEST_FILE_CHANGED_COMMENT, result.getInfo().getMessage());	
changecommentmessage 

public void testGetCommentInfo() throws Exception {	BoxComment.Info commentInfo = testFile.addComment(CAMEL_TEST_FILE_COMMENT);	final com.box.sdk.BoxComment.Info result = requestBody("direct: assertNotNull("getCommentInfo result", result);	assertEquals("getCommentInfo message", CAMEL_TEST_FILE_COMMENT, result.getMessage());	
getcommentinfo 

public void testGetFileComments() throws Exception {	testFile.addComment(CAMEL_TEST_FILE_COMMENT);	final java.util.List result = requestBody("direct: assertNotNull("getFileComments result", result);	assertEquals("getFileComments size", 1, result.size());	
getfilecomments 

public void testReplyToComment() throws Exception {	BoxComment.Info commentInfo = testFile.addComment(CAMEL_TEST_FILE_COMMENT);	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.commentId", commentInfo.getID());	headers.put("CamelBox.message", CAMEL_TEST_FILE_REPLY_COMMENT);	final com.box.sdk.BoxComment result = requestBodyAndHeaders("direct: assertNotNull("replyToComment result", result);	assertEquals("replyToComment result", CAMEL_TEST_FILE_REPLY_COMMENT, result.getInfo().getMessage());	
replytocomment 

========================= camel sample_17406 =========================

public void send(WebServiceMessage message) throws IOException {	try {	camelContext.createProducerTemplate().sendBody(destination.toString(), message);	} catch (CamelExecutionException e) {	
could not found any camel endpoint for wsa replyto camel mapping 

========================= camel sample_17113 =========================

public void testConsumerInOnly() throws Exception {	CamelContext context = new DefaultCamelContext();	context.addRoutes(createConsumerInOnlyRouteBuilder());	try {	context.start();	} catch (Throwable t) {	Assert.assertEquals(IllegalArgumentException.class, t.getClass());	
expected exception was thrown 

public void testConsumerInOut() throws Exception {	CamelContext context = new DefaultCamelContext();	context.addRoutes(createConsumerInOutRouteBuilder());	try {	context.start();	} catch (Throwable t) {	Assert.assertEquals(IllegalArgumentException.class, t.getClass());	
expected exception was thrown 

public void testProducerInOnly() throws Exception {	CamelContext context = new DefaultCamelContext();	context.addRoutes(createProducerInOnlyRouteBuilder());	try {	context.start();	} catch (Throwable t) {	Assert.assertEquals(IllegalArgumentException.class, t.getClass());	
expected exception was thrown 

public void testProducerInOut() throws Exception {	CamelContext context = new DefaultCamelContext();	context.addRoutes(createProducerInOutRouteBuilder());	try {	context.start();	} catch (Throwable t) {	Assert.assertEquals(IllegalArgumentException.class, t.getClass());	
expected exception was thrown 

========================= camel sample_12311 =========================

result.whenAnyExchangeReceived(new Processor() {	public void process(Exchange exchange) throws Exception {	String msg = exchange.getIn().getBody(String.class);	exchange.setException(new ThrottlingException(msg));	}	});	template.sendBody(url, "Message One");	template.sendBody(url, "Message Two");	final ServiceSupport consumer = (ServiceSupport) context.getRoute("foo").getConsumer();	await().atMost(2, TimeUnit.SECONDS).until(consumer::isSuspended);	
sending message three 

========================= camel sample_2640 =========================

protected RouteBuilder createRouteBuilder() {	mllpClient.setMllpHost("localhost");	mllpClient.setMllpPort(AvailablePortFinder.getNextAvailable());	return new RouteBuilder() {	int connectTimeout = 500;	int responseTimeout = 5000;	public void configure() throws Exception {	String routeId = "mllp-test-receiver-route";	onCompletion() .toF("log:%s?level=INFO&showAll=true", routeId) .log(LoggingLevel.INFO, routeId, "Test route complete");	
mllp mllpclient getmllphost mllpclient getmllpport connecttimeout responsetimeout routeid routeid log logginglevel info routeid message to result 

========================= camel sample_13853 =========================

public String greetMe(String me) {	
executing operation greetme 

public void greetMeOneWay(String me) {	
executing operation greetmeoneway 

public String sayHi() {	
executing operation sayhi 

========================= camel sample_17810 =========================

protected void processExchange(Exchange exchange, String target) throws Exception {	
processing file for exchange 

protected void processExchange(Exchange exchange, String target) throws Exception {	try {	preWriteCheck();	boolean writeAsTempAndRename = ObjectHelper.isNotEmpty(endpoint.getTempFileName());	String tempTarget = null;	Boolean targetExists;	if (writeAsTempAndRename) {	tempTarget = createTempFileName(exchange, target);	
writing using tempnamefile 

try {	preWriteCheck();	boolean writeAsTempAndRename = ObjectHelper.isNotEmpty(endpoint.getTempFileName());	String tempTarget = null;	Boolean targetExists;	if (writeAsTempAndRename) {	tempTarget = createTempFileName(exchange, target);	if (endpoint.getFileExist() != GenericFileExist.TryRename && endpoint.isEagerDeleteTargetFile()) {	targetExists = operations.existsFile(target);	if (targetExists) {	
eagerdeletetargetfile target exists 

preWriteCheck();	boolean writeAsTempAndRename = ObjectHelper.isNotEmpty(endpoint.getTempFileName());	String tempTarget = null;	Boolean targetExists;	if (writeAsTempAndRename) {	tempTarget = createTempFileName(exchange, target);	if (endpoint.getFileExist() != GenericFileExist.TryRename && endpoint.isEagerDeleteTargetFile()) {	targetExists = operations.existsFile(target);	if (targetExists) {	if (endpoint.getFileExist() == GenericFileExist.Ignore) {	
an existing file already exists ignore and do not override it 

if (endpoint.getFileExist() != GenericFileExist.TryRename && endpoint.isEagerDeleteTargetFile()) {	targetExists = operations.existsFile(target);	if (targetExists) {	if (endpoint.getFileExist() == GenericFileExist.Ignore) {	return;	} else if (endpoint.getFileExist() == GenericFileExist.Fail) {	throw new GenericFileOperationFailedException("File already exist: " + target + ". Cannot write new file.");	} else if (endpoint.getFileExist() == GenericFileExist.Move) {	doMoveExistingFile(target);	} else if (endpoint.isEagerDeleteTargetFile() && endpoint.getFileExist() == GenericFileExist.Override) {	
eagerly deleting existing file 

} else if (endpoint.getFileExist() == GenericFileExist.Move) {	doMoveExistingFile(target);	} else if (endpoint.isEagerDeleteTargetFile() && endpoint.getFileExist() == GenericFileExist.Override) {	if (!operations.deleteFile(target)) {	throw new GenericFileOperationFailedException("Cannot delete file: " + target);	}	}	}	}	if (endpoint.getFileExist() != GenericFileExist.TryRename && operations.existsFile(tempTarget)) {	
deleting existing temp file 

if (!operations.deleteFile(tempTarget)) {	throw new GenericFileOperationFailedException("Cannot delete file: " + tempTarget);	}	}	}	writeFile(exchange, tempTarget != null ? tempTarget : target);	if (tempTarget != null) {	if (endpoint.getFileExist() != GenericFileExist.TryRename && !endpoint.isEagerDeleteTargetFile()) {	targetExists = operations.existsFile(target);	if (targetExists) {	
not using eagerdeletetargetfile target exists 

throw new GenericFileOperationFailedException("Cannot delete file: " + tempTarget);	}	}	}	writeFile(exchange, tempTarget != null ? tempTarget : target);	if (tempTarget != null) {	if (endpoint.getFileExist() != GenericFileExist.TryRename && !endpoint.isEagerDeleteTargetFile()) {	targetExists = operations.existsFile(target);	if (targetExists) {	if (endpoint.getFileExist() == GenericFileExist.Ignore) {	
an existing file already exists ignore and do not override it 

writeFile(exchange, tempTarget != null ? tempTarget : target);	if (tempTarget != null) {	if (endpoint.getFileExist() != GenericFileExist.TryRename && !endpoint.isEagerDeleteTargetFile()) {	targetExists = operations.existsFile(target);	if (targetExists) {	if (endpoint.getFileExist() == GenericFileExist.Ignore) {	return;	} else if (endpoint.getFileExist() == GenericFileExist.Fail) {	throw new GenericFileOperationFailedException("File already exist: " + target + ". Cannot write new file.");	} else if (endpoint.getFileExist() == GenericFileExist.Override) {	
deleting existing file 

return;	} else if (endpoint.getFileExist() == GenericFileExist.Fail) {	throw new GenericFileOperationFailedException("File already exist: " + target + ". Cannot write new file.");	} else if (endpoint.getFileExist() == GenericFileExist.Override) {	if (!operations.deleteFile(target)) {	throw new GenericFileOperationFailedException("Cannot delete file: " + target);	}	}	}	}	
renaming file to 

boolean renamed = operations.renameFile(tempTarget, target);	if (!renamed) {	throw new GenericFileOperationFailedException("Cannot rename file from: " + tempTarget + " to: " + target);	}	}	if (endpoint.getDoneFileName() != null) {	String doneFileName = endpoint.createDoneFileName(target);	ObjectHelper.notEmpty(doneFileName, "doneFileName", endpoint);	Exchange empty = new DefaultExchange(exchange);	empty.getIn().setBody("");	
writing done file 

public void writeFile(Exchange exchange, String fileName) throws GenericFileOperationFailedException {	if (endpoint.isAutoCreate()) {	String name = FileUtil.normalizePath(fileName);	File file = new File(name);	String directory = file.getParent();	boolean absolute = FileUtil.isAbsolute(file);	if (directory != null) {	if (!operations.buildDirectory(directory, absolute)) {	
cannot build directory could be because of denied permissions 

String name = FileUtil.normalizePath(fileName);	File file = new File(name);	String directory = file.getParent();	boolean absolute = FileUtil.isAbsolute(file);	if (directory != null) {	if (!operations.buildDirectory(directory, absolute)) {	}	}	}	if (log.isTraceEnabled()) {	
about to write to from exchange 

if (!operations.buildDirectory(directory, absolute)) {	}	}	}	if (log.isTraceEnabled()) {	}	boolean success = operations.storeFile(fileName, exchange, -1);	if (!success) {	throw new GenericFileOperationFailedException("Error writing file [" + fileName + "]");	}	
wrote to 

} else {	value = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, overrule);	}	} else {	value = exchange.getIn().getHeader(Exchange.FILE_NAME);	}	if (overrule != null) {	exchange.getIn().setHeader(Exchange.FILE_NAME, value);	}	if (value != null && value instanceof String && StringHelper.hasStartToken((String) value, "simple")) {	
simple expression detected in header of type string this feature has been removed see camel 

exchange.getIn().setHeader(Exchange.FILE_NAME, value);	}	if (value != null && value instanceof String && StringHelper.hasStartToken((String) value, "simple")) {	}	Expression expression = endpoint.getFileName();	if (value instanceof Expression) {	expression = (Expression) value;	}	String name;	if (expression != null) {	
filename evaluated as expression 

========================= camel sample_4794 =========================

public void onOpen(WebSocket websocket) {	
ws opened 

public void onClose(WebSocket websocket) {	
ws closed 

public void onError(Throwable t) {	
ws error 

public void onMessage(byte[] message) {	received.add(message);	
ws received bytes 

public void onMessage(String message) {	received.add(message);	
ws received 

========================= camel sample_13150 =========================

private Exchange receive(DataQueue queue, long timeout) throws Exception {	DataQueueEntry entry;	if (timeout >= 0) {	int seconds = (int) timeout / 1000;	
reading from data queue with seconds timeout 

private Exchange receive(DataQueue queue, long timeout) throws Exception {	DataQueueEntry entry;	if (timeout >= 0) {	int seconds = (int) timeout / 1000;	entry = queue.read(seconds);	} else {	
reading from data queue with no timeout 

private Exchange receive(KeyedDataQueue queue, long timeout) throws Exception {	String key = getEndpoint().getSearchKey();	String searchType = getEndpoint().getSearchType().name();	KeyedDataQueueEntry entry;	if (timeout >= 0) {	int seconds = (int) timeout / 1000;	
reading from data queue with seconds timeout 

private Exchange receive(KeyedDataQueue queue, long timeout) throws Exception {	String key = getEndpoint().getSearchKey();	String searchType = getEndpoint().getSearchType().name();	KeyedDataQueueEntry entry;	if (timeout >= 0) {	int seconds = (int) timeout / 1000;	entry = queue.read(key, seconds, searchType);	} else {	
reading from data queue with no timeout 

========================= camel sample_16775 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<GoogleDriveComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.google-drive.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.google-drive.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_486 =========================

try {	template.sendBodyAndHeader("direct:start", "<body/>", "route", route);	fail("Should have thrown exception");	} catch (RuntimeCamelException e) {	assertTrue(e.getCause() instanceof IllegalArgumentException);	assertEquals("Exception thrown intentionally.", e.getCause().getMessage());	}	assertMockEndpointsSatisfied();	List<Exchange> list = exceptionEndpoint.getReceivedExchanges();	Exchange exchange = list.get(0);	
received 

protected RouteBuilder createRouteBuilder() throws Exception {	final Processor exceptionThrower = new Processor() {	public void process(Exchange exchange) throws Exception {	
about to throw exception on 

========================= camel sample_3860 =========================

public void onClose(int closeCode, String message) {	
onclose 

public void onConnect(Session session) {	
onconnect 

public void onMessage(String message) {	
onmessage 

public void onMessage(String message) {	if (this.consumer != null) {	this.consumer.sendMessage(this.connectionKey, message);	} else {	
no consumer to handle message received 

public void onMessage(byte[] data, int offset, int length) {	
onmessage byte 

public void onMessage(byte[] data, int offset, int length) {	if (this.consumer != null) {	byte[] message = new byte[length];	System.arraycopy(data, offset, message, 0, length);	this.consumer.sendMessage(this.connectionKey, message);	} else {	
no consumer to handle message received byte 

========================= camel sample_17471 =========================

protected int poll() throws Exception {	GetRecordsRequest req = new GetRecordsRequest().withShardIterator(getShardItertor()).withLimit(getEndpoint().getConfiguration().getMaxResultsPerRequest());	GetRecordsResult result = getClient().getRecords(req);	Queue<Exchange> exchanges = createExchanges(result.getRecords());	int processedExchangeCount = processBatch(CastUtils.cast(exchanges));	currentShardIterator = result.getNextShardIterator();	if (isShardClosed) {	switch (getEndpoint().getConfiguration().getShardClosed()) {	
the shard is in closed state 

protected int poll() throws Exception {	GetRecordsRequest req = new GetRecordsRequest().withShardIterator(getShardItertor()).withLimit(getEndpoint().getConfiguration().getMaxResultsPerRequest());	GetRecordsResult result = getClient().getRecords(req);	Queue<Exchange> exchanges = createExchanges(result.getRecords());	int processedExchangeCount = processBatch(CastUtils.cast(exchanges));	currentShardIterator = result.getNextShardIterator();	if (isShardClosed) {	switch (getEndpoint().getConfiguration().getShardClosed()) {	break;	case silent: break;	
shard iterator reaches close status 

public int processBatch(Queue<Object> exchanges) throws Exception {	int processedExchanges = 0;	while (!exchanges.isEmpty()) {	final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());	
processing exchange started 

public int processBatch(Queue<Object> exchanges) throws Exception {	int processedExchanges = 0;	while (!exchanges.isEmpty()) {	final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());	getAsyncProcessor().process(exchange, new AsyncCallback() {	public void done(boolean doneSync) {	
processing exchange done 

} else {	DescribeStreamRequest req1 = new DescribeStreamRequest().withStreamName(getEndpoint().getConfiguration().getStreamName());	DescribeStreamResult res1 = getClient().describeStream(req1);	shardId = res1.getStreamDescription().getShards().get(0).getShardId();	if (res1.getStreamDescription().getShards().get(0).getSequenceNumberRange().getEndingSequenceNumber() == null) {	isShardClosed = false;	} else {	isShardClosed = true;	}	}	
shardid is 

isShardClosed = true;	}	}	GetShardIteratorRequest req = new GetShardIteratorRequest().withStreamName(getEndpoint().getConfiguration().getStreamName()).withShardId(shardId) .withShardIteratorType(getEndpoint().getConfiguration().getIteratorType());	if (hasSequenceNumber()) {	req.withStartingSequenceNumber(getEndpoint().getConfiguration().getSequenceNumber());	}	GetShardIteratorResult result = getClient().getShardIterator(req);	currentShardIterator = result.getShardIterator();	}	
shard iterator is 

========================= camel sample_8685 =========================

private String createCandidateName() {	StringBuilder builder = new StringBuilder();	try {	builder.append(InetAddress.getLocalHost().getCanonicalHostName());	} catch (UnknownHostException ex) {	
failed to get the local hostname 

private void notifyElectionWatchers() {	for (ElectionWatcher watcher : watchers) {	try {	watcher.electionResultChanged();	} catch (Exception e) {	
election watcher of type threw an exception 

public void takeLeadership(CuratorFramework curatorFramework) throws Exception {	masterNode.set(true);	
is now leader 

notifyElectionWatchers();	while (!isCamelStopping(camelContext)) {	try {	Thread.sleep(5000);	} catch (InterruptedException e) {	Thread.interrupted();	break;	}	}	masterNode.set(false);	
has given up its own leadership 

========================= camel sample_12673 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<CaffeineLoadCacheComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.caffeine-loadcache.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.caffeine-loadcache.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_469 =========================

} else if (getDataFormat().dealias() == DataFormat.RAW) {	RAWDataFormatFeature feature = new RAWDataFormatFeature();	if (this.getExchangePattern().equals(ExchangePattern.InOnly)) {	feature.setOneway(true);	}	feature.addInIntercepters(getInInterceptors());	feature.addOutInterceptors(getOutInterceptors());	sfb.getFeatures().add(feature);	}	} else {	
ignore dataformat mode since sei class is annotated with webserviceprovider 

}	if (getWrappedStyle() != null && getDataFormat().dealias() != DataFormat.CXF_MESSAGE) {	setWrapped(sfb, getWrappedStyle());	}	if (getProperties() != null) {	if (sfb.getProperties() != null) {	sfb.getProperties().putAll(getProperties());	} else {	sfb.setProperties(getProperties());	}	
serverfactorybean added properties 

}	if (getWrappedStyle() != null) {	setWrapped(factoryBean, getWrappedStyle());	}	if (getProperties() != null) {	if (factoryBean.getProperties() != null) {	factoryBean.getProperties().putAll(getProperties());	} else {	factoryBean.setProperties(getProperties());	}	
clientfactorybean added properties 

public Bus getBus() {	if (bus == null) {	bus = CxfEndpointUtils.createBus(getCamelContext());	this.createBus = true;	
using defaultbus 

public Bus getBus() {	if (bus == null) {	bus = CxfEndpointUtils.createBus(getCamelContext());	this.createBus = true;	}	if (!getBusHasBeenCalled.getAndSet(true) && defaultBus) {	BusFactory.setDefaultBus(bus);	
set bus as thread default bus 

public void setCamelContext(CamelContext c) {	super.setCamelContext(c);	if (this.properties != null) {	try {	EndpointHelper.setReferenceProperties(getCamelContext(), this, this.properties);	EndpointHelper.setProperties(getCamelContext(), this, this.properties);	} catch (Throwable e) {	
error setting camelcontext this exception will be ignored 

if (this.properties == null) {	this.properties = properties;	} else {	this.properties.putAll(properties);	}	if (getCamelContext() != null && this.properties != null) {	try {	EndpointHelper.setReferenceProperties(getCamelContext(), this, this.properties);	EndpointHelper.setProperties(getCamelContext(), this, this.properties);	} catch (Throwable e) {	
error setting properties this exception will be ignored 

protected void doStop() throws Exception {	if (createBus && bus != null) {	
shutdown the bus 

}	if (r != null) {	try {	if (r.getEventType() == XMLStreamConstants.START_DOCUMENT) {	r.next();	}	if (r.getEventType() != XMLStreamConstants.START_ELEMENT) {	r.nextTag();	}	} catch (XMLStreamException e) {	
error finding the start element 

========================= camel sample_7989 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<RestApiComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.rest-api.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.rest-api.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_890 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<BraintreeComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.braintree.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.braintree.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_740 =========================

private void startBroker() throws Exception {	broker.start();	
started embedded jms server 

public void tearDown() throws Exception {	super.tearDown();	DefaultCamelContext dcc = (DefaultCamelContext)context;	while (!dcc.isStopped()) {	
waiting on the camel context to stop 

public void tearDown() throws Exception {	super.tearDown();	DefaultCamelContext dcc = (DefaultCamelContext)context;	while (!dcc.isStopped()) {	}	
closing jms session 

public void tearDown() throws Exception {	super.tearDown();	DefaultCamelContext dcc = (DefaultCamelContext)context;	while (!dcc.isStopped()) {	}	if (getSession() != null) {	getSession().close();	setSession(null);	}	
closing jms connection 

while (!dcc.isStopped()) {	}	if (getSession() != null) {	getSession().close();	setSession(null);	}	if (connection != null) {	connection.stop();	connection = null;	}	
stopping the activemq broker 

========================= camel sample_6418 =========================

protected void doStart() throws Exception {	super.doStart();	String path = endpoint.getComponent().getCamelClusterPath(endpoint.getGroupName());	this.groupListener = new ZookeeperGroupListenerSupport(path, endpoint, onLockOwned(), onDisconnected());	this.groupListener.setCamelContext(endpoint.getCamelContext());	this.groupListener.setZooKeeperUrl(endpoint.getComponent().getZooKeeperUrl());	this.groupListener.setZooKeeperPassword(endpoint.getComponent().getZooKeeperPassword());	this.groupListener.setCurator(endpoint.getComponent().getCurator());	this.groupListener.setMaximumConnectionTimeout(endpoint.getComponent().getMaximumConnectionTimeout());	ServiceHelper.startService(groupListener);	
attempting to become master for endpoint in with singletonid 

protected Runnable onLockOwned() {	return () -> {	if (delegate == null) {	try {	
elected as master starting consumer 

delegate = endpoint.getConsumerEndpoint().createConsumer(processor);	delegateService = null;	if (delegate instanceof SuspendableService) {	delegateService = (SuspendableService) delegate;	}	thisNodeState = createNodeState();	thisNodeState.setStarted(true);	groupListener.updateState(thisNodeState);	ServiceHelper.startService(delegate);	} catch (Exception e) {	
failed to start master consumer for 

delegateService = null;	if (delegate instanceof SuspendableService) {	delegateService = (SuspendableService) delegate;	}	thisNodeState = createNodeState();	thisNodeState.setStarted(true);	groupListener.updateState(thisNodeState);	ServiceHelper.startService(delegate);	} catch (Exception e) {	}	
elected as master consumer started 

protected Runnable onDisconnected() {	return () -> {	try {	stopConsumer();	} catch (Exception e) {	
failed to stop master consumer for 

========================= camel sample_9702 =========================

policy.setRouteResumeRepeatInterval(3000);	from("direct:start") .routeId("test") .routePolicy(policy) .to("mock:success");	}	});	context.start();	ServiceHelper.suspendService(context.getRoute("test").getConsumer());	try {	template.sendBody("direct:start", "Ready or not, Here, I come");	fail("Should have thrown an exception");	} catch (CamelExecutionException e) {	
consumer successfully suspended 

policy.setRouteResumeRepeatInterval(3000);	from("direct:start") .routeId("test") .routePolicy(policy) .to("mock:success");	}	});	context.start();	Thread.sleep(1000);	try {	template.sendBody("direct:start", "Ready or not, Here, I come");	fail("Should have thrown an exception");	} catch (CamelExecutionException e) {	
consumer successfully suspended 

policy.setRouteResumeRepeatInterval(3000);	from("direct:start") .routeId("test") .routePolicy(policy) .to("mock:success");	}	});	context.start();	Thread.sleep(1000);	try {	template.sendBody("direct:start", "Ready or not, Here, I come");	fail("Should have thrown an exception");	} catch (CamelExecutionException e) {	
consumer successfully suspended 

========================= camel sample_14932 =========================

public void setDefaultThreadPoolProfile(ThreadPoolProfile defaultThreadPoolProfile) {	threadPoolProfiles.remove(defaultThreadPoolProfileId);	defaultThreadPoolProfile.addDefaults(defaultProfile);	
using custom defaultthreadpoolprofile 

public ExecutorService newThreadPool(Object source, String name, ThreadPoolProfile profile) {	String sanitizedName = URISupport.sanitizeUri(name);	ObjectHelper.notNull(profile, "ThreadPoolProfile");	ThreadPoolProfile defaultProfile = getDefaultThreadPoolProfile();	profile.addDefaults(defaultProfile);	ThreadFactory threadFactory = createThreadFactory(sanitizedName, true);	ExecutorService executorService = threadPoolFactory.newThreadPool(profile, threadFactory);	onThreadPoolCreated(executorService, source, profile.getId());	if (LOG.isDebugEnabled()) {	
created new threadpool for source with name 

public ExecutorService newCachedThreadPool(Object source, String name) {	String sanitizedName = URISupport.sanitizeUri(name);	ExecutorService answer = threadPoolFactory.newCachedThreadPool(createThreadFactory(sanitizedName, true));	onThreadPoolCreated(answer, source, null);	if (LOG.isDebugEnabled()) {	
created new cachedthreadpool for source with name 

public ScheduledExecutorService newScheduledThreadPool(Object source, String name, ThreadPoolProfile profile) {	String sanitizedName = URISupport.sanitizeUri(name);	profile.addDefaults(getDefaultThreadPoolProfile());	ScheduledExecutorService answer = threadPoolFactory.newScheduledThreadPool(profile, createThreadFactory(sanitizedName, true));	onThreadPoolCreated(answer, source, null);	if (LOG.isDebugEnabled()) {	
created new scheduledthreadpool for source with name 

private boolean doShutdown(ExecutorService executorService, long shutdownAwaitTermination, boolean failSafe) {	if (executorService == null) {	return false;	}	boolean warned = false;	if (!executorService.isShutdown()) {	StopWatch watch = new StopWatch();	
shutdown of executorservice with await termination millis 

return false;	}	boolean warned = false;	if (!executorService.isShutdown()) {	StopWatch watch = new StopWatch();	executorService.shutdown();	if (shutdownAwaitTermination > 0) {	try {	if (!awaitTermination(executorService, shutdownAwaitTermination)) {	warned = true;	
forcing shutdown of executorservice due first await termination elapsed 

boolean warned = false;	if (!executorService.isShutdown()) {	StopWatch watch = new StopWatch();	executorService.shutdown();	if (shutdownAwaitTermination > 0) {	try {	if (!awaitTermination(executorService, shutdownAwaitTermination)) {	warned = true;	executorService.shutdownNow();	if (!awaitTermination(executorService, shutdownAwaitTermination)) {	
cannot completely force shutdown of executorservice due second await termination elapsed 

if (shutdownAwaitTermination > 0) {	try {	if (!awaitTermination(executorService, shutdownAwaitTermination)) {	warned = true;	executorService.shutdownNow();	if (!awaitTermination(executorService, shutdownAwaitTermination)) {	}	}	} catch (InterruptedException e) {	warned = true;	
forcing shutdown of executorservice due interrupted 

executorService.shutdownNow();	if (!awaitTermination(executorService, shutdownAwaitTermination)) {	}	}	} catch (InterruptedException e) {	warned = true;	executorService.shutdownNow();	}	}	if (warned) {	
shutdown of executorservice is shutdown and terminated took 

if (!awaitTermination(executorService, shutdownAwaitTermination)) {	}	}	} catch (InterruptedException e) {	warned = true;	executorService.shutdownNow();	}	}	if (warned) {	} else if (LOG.isDebugEnabled()) {	
shutdown of executorservice is shutdown and terminated took 

private List<Runnable> doShutdownNow(ExecutorService executorService, boolean failSafe) {	ObjectHelper.notNull(executorService, "executorService");	List<Runnable> answer = null;	if (!executorService.isShutdown()) {	if (failSafe) {	
forcing shutdown of executorservice 

private List<Runnable> doShutdownNow(ExecutorService executorService, boolean failSafe) {	ObjectHelper.notNull(executorService, "executorService");	List<Runnable> answer = null;	if (!executorService.isShutdown()) {	if (failSafe) {	} else {	
forcing shutdown of executorservice 

private List<Runnable> doShutdownNow(ExecutorService executorService, boolean failSafe) {	ObjectHelper.notNull(executorService, "executorService");	List<Runnable> answer = null;	if (!executorService.isShutdown()) {	if (failSafe) {	} else {	}	answer = executorService.shutdownNow();	if (LOG.isTraceEnabled()) {	
shutdown of executorservice is shutdown and terminated 

public boolean awaitTermination(ExecutorService executorService, long shutdownAwaitTermination) throws InterruptedException {	StopWatch watch = new StopWatch();	long interval = Math.min(2000, shutdownAwaitTermination);	boolean done = false;	while (!done && interval > 0) {	if (executorService.awaitTermination(interval, TimeUnit.MILLISECONDS)) {	done = true;	} else {	
waited for executorservice to terminate 

protected void doShutdown() throws Exception {	Set<ExecutorService> forced = new LinkedHashSet<>();	if (!executorServices.isEmpty()) {	
giving time for executorservice s to shutdown properly acting as fail safe 

protected void doShutdown() throws Exception {	Set<ExecutorService> forced = new LinkedHashSet<>();	if (!executorServices.isEmpty()) {	for (ExecutorService executorService : executorServices) {	try {	boolean warned = doShutdown(executorService, getShutdownAwaitTermination(), true);	if (warned) {	forced.add(executorService);	}	} catch (Throwable e) {	
error occurred during shutdown of executorservice this exception will be ignored 

try {	boolean warned = doShutdown(executorService, getShutdownAwaitTermination(), true);	if (warned) {	forced.add(executorService);	}	} catch (Throwable e) {	}	}	}	if (!forced.isEmpty()) {	
forced shutdown of executorservice s which has not been shutdown properly acting as fail safe 

boolean warned = doShutdown(executorService, getShutdownAwaitTermination(), true);	if (warned) {	forced.add(executorService);	}	} catch (Throwable e) {	}	}	}	if (!forced.isEmpty()) {	for (ExecutorService executorService : forced) {	
forced 

========================= camel sample_3972 =========================

public Object processWorkflow(Object[] parameters, long startTime, boolean replaying) throws Exception {	
processing workflow task 

public void signalRecieved(Object[] parameters) throws Exception {	
signalrecieved 

public Object getWorkflowState(Object parameters) throws Exception {	
getworkflowstate 

========================= camel sample_8797 =========================

String originalThreadName = Thread.currentThread().getName();	Thread.currentThread().setName(createThreadName(serverSocket));	MDC.put(MDCUnitOfWork.MDC_CAMEL_CONTEXT_ID, consumer.getEndpoint().getCamelContext().getName());	Route route = consumer.getRoute();	if (route != null) {	String routeId = route.getId();	if (routeId != null) {	MDC.put(MDCUnitOfWork.MDC_ROUTE_ID, route.getId());	}	}	
starting serversocket accept thread for 

MDC.put(MDCUnitOfWork.MDC_ROUTE_ID, route.getId());	}	}	try {	while (running && null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {	Socket socket = null;	try {	socket = serverSocket.accept();	consumer.getEndpoint().updateLastConnectionEstablishedTicks();	} catch (SocketTimeoutException timeoutEx) {	
timeout waiting for client connection keep listening 

try {	socket = serverSocket.accept();	consumer.getEndpoint().updateLastConnectionEstablishedTicks();	} catch (SocketTimeoutException timeoutEx) {	continue;	} catch (SocketException socketEx) {	if (serverSocket.isBound()) {	try {	serverSocket.close();	} catch (Exception ex) {	
exception encountered closing serversocket after socketexception on accept ignoring 

continue;	} catch (SocketException socketEx) {	if (serverSocket.isBound()) {	try {	serverSocket.close();	} catch (Exception ex) {	}	}	continue;	} catch (IOException ioEx) {	
exception encountered accepting connection closing serversocket 

serverSocket.close();	} catch (Exception ex) {	}	}	continue;	} catch (IOException ioEx) {	if (serverSocket.isBound()) {	try {	serverSocket.close();	} catch (Exception ex) {	
exception encountered closing serversocket after exception on accept ignoring 

} catch (Exception ex) {	}	}	continue;	}	if (MllpSocketBuffer.isConnectionValid(socket)) {	consumer.startConsumer(socket);	}	}	} finally {	
serversocket accept loop finished closing listener 

}	if (MllpSocketBuffer.isConnectionValid(socket)) {	consumer.startConsumer(socket);	}	}	} finally {	if (null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {	try {	serverSocket.close();	} catch (Exception ex) {	
exception encountered closing serversocket after accept loop had exited ignoring 

========================= camel sample_13873 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SqlStoredComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.sql-stored.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.sql-stored.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_982 =========================

public HttpServerInitializerFactory(NettyHttpConsumer nettyConsumer) {	this.consumer = nettyConsumer;	this.configuration = nettyConsumer.getConfiguration();	try {	this.sslContext = createSSLContext(consumer.getContext(), consumer.getConfiguration());	} catch (Exception e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	}	if (sslContext != null) {	
created sslcontext 

protected void initChannel(Channel ch) throws Exception {	ChannelPipeline pipeline = ch.pipeline();	SslHandler sslHandler = configureServerSSLOnDemand();	if (sslHandler != null) {	
server ssl handler configured and added as an interceptor against the channelpipeline 

private SSLContext createSSLContext(CamelContext camelContext, NettyServerBootstrapConfiguration configuration) throws Exception {	if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(camelContext);	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	
keystorefile is null 

if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(camelContext);	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	
truststorefile is null 

}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(camelContext);	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	}	if (configuration.getPassphrase().toCharArray() == null) {	
passphrase is null 

========================= camel sample_16667 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<OpenShiftComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.openshift.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.openshift.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1109 =========================

public void process(Exchange exchange) throws Exception {	
crafting standard response in stockquoteresponseprocessor 

========================= camel sample_17076 =========================

protected void onFailedMessage(Exchange exchange, String messageId) {	if (removeOnFailure) {	if (idempotentRepository instanceof ExchangeIdempotentRepository) {	((ExchangeIdempotentRepository<String>) idempotentRepository).remove(exchange, messageId);	} else {	idempotentRepository.remove(messageId);	}	
removed from repository as exchange failed with id 

========================= camel sample_4472 =========================

public Ehcache initializeCache() {	CacheManager cacheManager = getCacheManagerFactory().getInstance();	Ehcache cache;	if (cacheManager.cacheExists(config.getCacheName())) {	if (LOG.isTraceEnabled()) {	
found an existing cache 

public Ehcache initializeCache() {	CacheManager cacheManager = getCacheManagerFactory().getInstance();	Ehcache cache;	if (cacheManager.cacheExists(config.getCacheName())) {	if (LOG.isTraceEnabled()) {	
cache currently contains elements 

cache = new Cache(config.getCacheName(), config.getMaxElementsInMemory(), config.getMemoryStoreEvictionPolicy(), config.isOverflowToDisk(), config.getDiskStorePath(), config.isEternal(), config.getTimeToLiveSeconds(), config.getTimeToIdleSeconds(), config.isDiskPersistent(), config.getDiskExpiryThreadIntervalSeconds(), null);	for (CacheEventListener listener : config.getEventListenerRegistry().getEventListeners()) {	cache.getCacheEventNotificationService().registerListener(listener);	}	for (CacheLoaderWrapper loader : config.getCacheLoaderRegistry().getCacheLoaders()) {	loader.init(cache);	cache.registerCacheLoader(loader);	}	cacheManager.addCache(cache);	if (LOG.isDebugEnabled()) {	
added a new cache 

========================= camel sample_10530 =========================

answer = message.getHeader(localPart);	}	if (answer == null) {	answer = exchange.get().getProperty(localPart);	}	}	} else if (uri.equals(SYSTEM_PROPERTIES_NAMESPACE)) {	try {	answer = System.getProperty(localPart);	} catch (Exception e) {	
security exception evaluating system property reason 

========================= camel sample_5633 =========================

public Destination getDestination(EndpointInfo endpointInfo, Bus b) throws IOException {	
create cxfbeandestination 

========================= camel sample_8001 =========================

public void doSomething(String body) {	ObjectHelper.notNull(destination, "destination");	
received body 

========================= camel sample_15732 =========================

try {	clazz = routeContext.getCamelContext().getClassResolver().resolveMandatoryClass(beanType);	} catch (ClassNotFoundException e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	}	} else {	clazz = beanClass;	}	if (isCacheBean() && routeContext.getCamelContext().getInjector().supportsAutoWiring()) {	try {	
attempting to create new bean instance from class via auto wiring enabled 

} catch (ClassNotFoundException e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	}	} else {	clazz = beanClass;	}	if (isCacheBean() && routeContext.getCamelContext().getInjector().supportsAutoWiring()) {	try {	bean = CamelContextHelper.newInstance(routeContext.getCamelContext(), clazz);	} catch (Throwable e) {	
error creating new bean instance from class this exception is ignored 

} else {	clazz = beanClass;	}	if (isCacheBean() && routeContext.getCamelContext().getInjector().supportsAutoWiring()) {	try {	bean = CamelContextHelper.newInstance(routeContext.getCamelContext(), clazz);	} catch (Throwable e) {	}	}	if (bean == null && isCacheBean() && ObjectHelper.hasDefaultPublicNoArgConstructor(clazz)) {	
class has default no arg constructor so creating a new bean instance 

========================= camel sample_5263 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<DisruptorComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.disruptor.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.disruptor.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_717 =========================

public void testXMLRouteLoading() throws Exception {	applicationContext = new ClassPathXmlApplicationContext("org/apache/camel/spring/camelContextFactoryBean.xml");	CamelContext context = applicationContext.getBean("camel2", CamelContext.class);	assertNotNull("No context found!", context);	List<Route> routes = context.getRoutes();	
found routes 

========================= camel sample_15677 =========================

PEMDecryptorProvider pemDecryptor = decryptorBuilder.build(passwordFinder.getPassword());	o = pemConverter.getKeyPair(((PEMEncryptedKeyPair) o).decryptKeyPair(pemDecryptor));	}	if (o instanceof PEMKeyPair) {	o = pemConverter.getKeyPair((PEMKeyPair)o);	keys.add((KeyPair) o);	} else if (o instanceof KeyPair) {	keys.add((KeyPair) o);	}	} catch (Exception e) {	
unable to read key 

========================= camel sample_10025 =========================

assertNotNull(classes);	assertTrue("There should be > 140 classes, was: " + classes.size(), classes.size() > 140);	for (Class<?> clazz : classes) {	if (clazz == ProcessorDefinition.class) {	continue;	}	if (clazz == RouteDefinition.class) {	continue;	}	for (Field field : clazz.getDeclaredFields()) {	
class has field 

fail("Class " + clazz.getName() + " has field " + field.getName() + " which has 2+ annotations that are not allowed together.");	}	if (attribute || element || elementRef) {	Method getter = IntrospectionSupport.getPropertyGetter(clazz, field.getName());	Method setter = IntrospectionSupport.getPropertySetter(clazz, field.getName());	assertNotNull("Getter " + field.getName() + " on class " + clazz.getName() + " is missing", getter);	assertNotNull("Setter " + field.getName() + " on class " + clazz.getName() + " is missing", setter);	}	}	for (Method method : clazz.getDeclaredMethods()) {	
class has method 

========================= camel sample_3708 =========================

}	if (sync) {	responseLatch = new CountDownLatch(1);	handler.reset();	}	if (LOG.isDebugEnabled()) {	Object out = body;	if (body instanceof byte[]) {	out = exchange.getContext().getTypeConverter().convertTo(String.class, body);	}	
writing body 

handler.reset();	}	if (LOG.isDebugEnabled()) {	Object out = body;	if (body instanceof byte[]) {	out = exchange.getContext().getTypeConverter().convertTo(String.class, body);	}	}	Mina2Helper.writeBody(session, body, exchange, writeTimeout);	if (sync) {	
waiting for response using timeout millis 

if (ExchangeHelper.isOutCapable(exchange)) {	close = exchange.getOut().getHeader(Mina2Constants.MINA_CLOSE_SESSION_WHEN_COMPLETE, Boolean.class);	} else {	close = exchange.getIn().getHeader(Mina2Constants.MINA_CLOSE_SESSION_WHEN_COMPLETE, Boolean.class);	}	boolean disconnect = getEndpoint().getConfiguration().isDisconnect();	if (close != null) {	disconnect = close;	}	if (disconnect) {	
closing session when complete at address 

protected void doStop() throws Exception {	if (LOG.isDebugEnabled()) {	
stopping connector at address 

private void openConnection() {	if (this.address == null || !this.configuration.isCachedAddress()) {	setSocketAddress(this.configuration.getProtocol());	}	if (LOG.isDebugEnabled()) {	
creating connector to address using connector timeout millis 

protected void setupVmProtocol(String uri) {	boolean minaLogger = configuration.isMinaLogger();	List<IoFilter> filters = configuration.getFilters();	address = new VmPipeAddress(configuration.getPort());	connector = new VmPipeConnector();	if (minaLogger) {	connector.getFilterChain().addLast("logger", new LoggingFilter());	}	appendIoFiltersToChain(filters, connector.getFilterChain());	if (configuration.getSslContextParameters() != null) {	
using vm protocol but an sslcontextparameters instance was provided sslcontextparameters is only supported on the tcp protocol 

Charset charset = getEncodingParameter(type, configuration);	LineDelimiter delimiter = getLineDelimiterParameter(configuration.getTextlineDelimiter());	Mina2TextLineCodecFactory codecFactory = new Mina2TextLineCodecFactory(charset, delimiter);	if (configuration.getEncoderMaxLineLength() > 0) {	codecFactory.setEncoderMaxLineLength(configuration.getEncoderMaxLineLength());	}	if (configuration.getDecoderMaxLineLength() > 0) {	codecFactory.setDecoderMaxLineLength(configuration.getDecoderMaxLineLength());	}	addCodecFactory(service, codecFactory);	
using textlinecodecfactory using encoding line delimiter 

Charset charset = getEncodingParameter(type, configuration);	LineDelimiter delimiter = getLineDelimiterParameter(configuration.getTextlineDelimiter());	Mina2TextLineCodecFactory codecFactory = new Mina2TextLineCodecFactory(charset, delimiter);	if (configuration.getEncoderMaxLineLength() > 0) {	codecFactory.setEncoderMaxLineLength(configuration.getEncoderMaxLineLength());	}	if (configuration.getDecoderMaxLineLength() > 0) {	codecFactory.setDecoderMaxLineLength(configuration.getDecoderMaxLineLength());	}	addCodecFactory(service, codecFactory);	
encoder maximum line length decoder maximum line length 

if (configuration.getEncoderMaxLineLength() > 0) {	codecFactory.setEncoderMaxLineLength(configuration.getEncoderMaxLineLength());	}	if (configuration.getDecoderMaxLineLength() > 0) {	codecFactory.setDecoderMaxLineLength(configuration.getDecoderMaxLineLength());	}	addCodecFactory(service, codecFactory);	} else {	ObjectSerializationCodecFactory codecFactory = new ObjectSerializationCodecFactory();	addCodecFactory(service, codecFactory);	
using objectserializationcodecfactory 

} else {	workerPool = new UnorderedThreadPoolExecutor(configuration.getMaximumPoolSize());	}	connectorConfig = connector.getSessionConfig();	connector.getFilterChain().addLast("threadPool", new ExecutorFilter(workerPool));	if (minaLogger) {	connector.getFilterChain().addLast("logger", new LoggingFilter());	}	appendIoFiltersToChain(filters, connector.getFilterChain());	if (configuration.getSslContextParameters() != null) {	
using datagram protocol but an sslcontextparameters instance was provided sslcontextparameters is only supported on the tcp protocol 

protected void configureDataGramCodecFactory(final String type, final IoService service, final Mina2Configuration configuration) {	ProtocolCodecFactory codecFactory = configuration.getCodec();	if (codecFactory == null) {	codecFactory = new Mina2UdpProtocolCodecFactory(this.getEndpoint().getCamelContext());	if (LOG.isDebugEnabled()) {	
using codecfactory 

private void addCodecFactory(IoService service, ProtocolCodecFactory codecFactory) {	
addcodecfactory name 

private Charset getEncodingParameter(String type, Mina2Configuration configuration) {	String encoding = configuration.getEncoding();	if (encoding == null) {	encoding = Charset.defaultCharset().name();	configuration.setEncoding(encoding);	
no encoding parameter using default charset 

public void messageReceived(IoSession ioSession, Object message) throws Exception {	
message received 

public void sessionClosed(IoSession session) throws Exception {	if (sync && !messageReceived) {	
session closed but no message received from address 

========================= camel sample_11634 =========================

builder.setBufferSize(options.getBufferSize());	}	if (options.getDirectBuffers() != null) {	builder.setDirectBuffers(options.getDirectBuffers());	}	if (options.getHttp2Enabled() != null) {	builder.setServerOption(UndertowOptions.ENABLE_HTTP2, options.getHttp2Enabled());	}	}	undertow = builder.setHandler(rootHandler).build();	
starting undertow server on try 

if (options.getDirectBuffers() != null) {	builder.setDirectBuffers(options.getDirectBuffers());	}	if (options.getHttp2Enabled() != null) {	builder.setServerOption(UndertowOptions.ENABLE_HTTP2, options.getHttp2Enabled());	}	}	undertow = builder.setHandler(rootHandler).build();	undertow.start();	} catch (RuntimeException e) {	
failed to start undertow server on undertow stop 

public synchronized void unregisterHandler(HttpHandlerRegistrationInfo registrationInfo) {	if (undertow == null) {	return;	}	rootHandler.remove(registrationInfo.getUri().getPath(), registrationInfo.getMethodRestrict(), registrationInfo.isMatchOnUriPrefix());	if (rootHandler.isEmpty()) {	
stopping undertow server on undertow stop 

========================= camel sample_13166 =========================

Future<String> out = executor.submit(new Callable<String>() {	public String call() throws Exception {	String reply = template.requestBody("netty:tcp: log.debug("Sent {} received {}", index, reply);	assertEquals("Bye " + index, reply);	return reply;	}	});	responses.put(index, out);	}	notify.matches(2, TimeUnit.MINUTES);	
took millis to process messages using client threads 

========================= camel sample_6635 =========================

public synchronized Service addAndAcquire(Key key, Service service) {	BlockingQueue<Service> entry = pool.get(key);	if (entry == null) {	entry = new ArrayBlockingQueue<Service>(capacity);	pool.put(key, entry);	}	
addandacquire key service 

public synchronized Service acquire(Key key) {	BlockingQueue<Service> services = pool.get(key);	if (services == null || services.isEmpty()) {	
no free services in pool to acquire for key 

public synchronized Service acquire(Key key) {	BlockingQueue<Service> services = pool.get(key);	if (services == null || services.isEmpty()) {	return null;	}	Service answer = services.poll();	
acquire service 

public synchronized void release(Key key, Service service) {	
release service 

protected void doStart() throws Exception {	
starting service pool 

protected void doStop() throws Exception {	
stopping service pool 

========================= camel sample_3964 =========================

public void testAsynchronous() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(100);	mock.expectsNoDuplicates(body());	StopWatch watch = new StopWatch();	for (int i = 0; i < 100; i++) {	template.sendBody("seda:start", "" + i);	}	assertMockEndpointsSatisfied(20, TimeUnit.SECONDS);	
took ms to process messages request reply over jms 

========================= camel sample_12327 =========================

public void testJmsRequestReplyExclusiveFixedReplyTo() throws Exception {	StopWatch watch = new StopWatch();	ExecutorService executor = Executors.newFixedThreadPool(10);	for (int i = 0; i < size; i++) {	final Integer num = i;	executor.submit(new Runnable() {	public void run() {	String reply = template.requestBody("direct:start", "" + num, String.class);	
sent expecting reply hello got 

final Integer num = i;	executor.submit(new Runnable() {	public void run() {	String reply = template.requestBody("direct:start", "" + num, String.class);	assertNotNull(reply);	assertEquals("Hello " + num, reply);	latch.countDown();	}	});	}	
waiting to process messages 

public void run() {	String reply = template.requestBody("direct:start", "" + num, String.class);	assertNotNull(reply);	assertEquals("Hello " + num, reply);	latch.countDown();	}	});	}	assertTrue("All assertions outside the main thread above should have passed", latch.await(3, TimeUnit.SECONDS));	long delta = watch.stop();	
took millis 

========================= camel sample_7024 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<PubNubComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.pubnub.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.pubnub.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_582 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<LuceneComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.lucene.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.lucene.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_428 =========================

public void process(Exchange exchange) throws Exception {	try {	
xml signature generation started using algorithm and canonicalization method 

try {	Message out = exchange.getOut();	out.copyFrom(exchange.getIn());	Document outputDoc = sign(out);	ByteArrayOutputStream outStream = new ByteArrayOutputStream();	XmlSignatureHelper.transformNonTextNodeToOutputStream(outputDoc, outStream, omitXmlDeclaration(out), getConfiguration().getOutputXmlEncoding());	byte[] data = outStream.toByteArray();	out.setBody(data);	setOutputEncodingToMessageHeader(out);	clearMessageHeaders(out);	
xml signature generation finished 

if (isEnveloped) {	result = SignatureType.enveloped;	} else if (isDetached) {	if (getSchemaResourceUri(message) == null) {	throw new XmlSignatureException( "The configruation of the XML Signature component is wrong: No XML schema specified in the detached case");	}	result = SignatureType.detached;	} else {	result = SignatureType.enveloping;	}	
signature type 

protected Boolean omitXmlDeclaration(Message message) {	Boolean omitXmlDeclaration = message.getHeader(XmlSignatureConstants.HEADER_OMIT_XML_DECLARATION, Boolean.class);	if (omitXmlDeclaration == null) {	omitXmlDeclaration = getConfiguration().getOmitXmlDeclaration();	}	if (omitXmlDeclaration == null) {	omitXmlDeclaration = Boolean.FALSE;	}	
omit xml declaration 

Boolean isPlainText = isPlainText(message);	Node node;	if (isPlainText != null && isPlainText) {	node = getTextNode(message, is);	} else {	ValidatorErrorHandler errorHandler = new DefaultValidationErrorHandler();	Schema schema = getSchemaForSigner(message, errorHandler);	Document doc = parseInput(is, getConfiguration().getDisallowDoctypeDecl(), schema, errorHandler);	errorHandler.handleErrors(message.getExchange(), schema, null);	node = doc.getDocumentElement();	
root element of document to be signed 

protected Boolean isPlainText(Message message) {	Boolean isPlainText = message.getHeader(XmlSignatureConstants.HEADER_MESSAGE_IS_PLAIN_TEXT, Boolean.class);	if (isPlainText == null) {	isPlainText = getConfiguration().getPlainText();	}	
is plain text 

private Element getParentForDetachedCase(Document doc, Message inMessage, String referenceUri) throws XmlSignatureException {	String elementId = referenceUri;	if (elementId.startsWith("#")) {	elementId = elementId.substring(1);	}	Element el = doc.getElementById(elementId);	if (el == null) {	throw new IllegalStateException("No element found for element ID " + elementId);	}	
sibling element of the detached xml signature with reference uri 

protected List<? extends XMLObject> getObjects(XmlSignatureProperties.Input input, XmlSignatureProperties.Output properties) throws Exception {	if (SignatureType.enveloped == input.getSignatureType() || SignatureType.detached == input.getSignatureType()) {	if (properties == null || properties.getObjects() == null) {	return Collections.emptyList();	}	return properties.getObjects();	}	final String objectId = getConfiguration().getContentObjectId();	
object content id 

private Node getTextNode(Message inMessage, InputStream is) throws IOException, ParserConfigurationException, XmlSignatureException {	
message body to be signed is plain text 

protected String getMessageEncoding(Message inMessage) {	String encoding = inMessage.getHeader(XmlSignatureConstants.HEADER_PLAIN_TEXT_ENCODING, String.class);	if (encoding == null) {	encoding = getConfiguration().getPlainTextEncoding();	}	
messge encoding 

protected String getContentReferenceType(Message message) {	String type = message.getHeader(XmlSignatureConstants.HEADER_CONTENT_REFERENCE_TYPE, String.class);	if (type == null) {	type = getConfiguration().getContentReferenceType();	}	
content reference type 

}	if (uri == null) {	uri = "";	}	result = Collections.singletonList(uri);	} else if (SignatureType.detached == signatureType) {	result = getContentReferenceUrisForDetachedCase(message, messageBodyNode);	} else {	throw new IllegalStateException("Signature type " + signatureType + " not supported");	}	
content reference uri s 

List<ComparableNode> result = new ArrayList<ComparableNode>(xpathsToIdAttributes.size());	for (XPathFilterParameterSpec xp : xpathsToIdAttributes) {	XPathExpression exp;	try {	exp = XmlSignatureHelper.getXPathExpression(xp);	} catch (XPathExpressionException e) {	throw new XmlSignatureException("The configured xpath expression " + xp.getXPath() + " is invalid.", e);	}	NodeList list = (NodeList) exp.evaluate(messageBodyNode, XPathConstants.NODESET);	if (list == null) {	
no id attribute found for xpath expression therfore this xpath expression will be ignored 

for (int i = 0; i < length; i++) {	Node node = list.item(i);	if (node.getNodeType() == Node.ATTRIBUTE_NODE) {	Attr attr = (Attr) node;	String value = attr.getValue();	Element element = messageBodyNode.getOwnerDocument().getElementById(value);	if (element == null) {	throw new XmlSignatureException( "Wrong configured xpath expression for ID attributes: The evaluation of the xpath expression " + xp.getXPath() + " resulted in an attribute which is not of type ID. The attribute value is " + value + ".");	}	result.add(new ComparableNode(element, "#" + value));	
id attribute with value found for xpath 

} else {	configuredTrafos = new ArrayList<AlgorithmMethod>(2);	configuredTrafos.add(XmlSignatureHelper.getEnvelopedTransform());	configuredTrafos.add(XmlSignatureHelper.getCanonicalizationMethod(CanonicalizationMethod.INCLUSIVE));	}	}	List<Transform> transforms = new ArrayList<Transform>(configuredTrafos.size());	for (AlgorithmMethod trafo : configuredTrafos) {	Transform transform = fac.newTransform(trafo.getAlgorithm(), (TransformParameterSpec) trafo.getParameterSpec());	transforms.add(transform);	
transform method 

configuredTrafos.add(XmlSignatureHelper.getCanonicalizationMethod(CanonicalizationMethod.INCLUSIVE));	}	}	List<Transform> transforms = new ArrayList<Transform>(configuredTrafos.size());	for (AlgorithmMethod trafo : configuredTrafos) {	Transform transform = fac.newTransform(trafo.getAlgorithm(), (TransformParameterSpec) trafo.getParameterSpec());	transforms.add(transform);	}	return transforms;	} else {	
header with value found 

transforms.add(transform);	}	return transforms;	} else {	String[] transformAlgorithms = transformMethodsHeaderValue.split(",");	List<Transform> transforms = new ArrayList<Transform>(transformAlgorithms.length);	for (String transformAlgorithm : transformAlgorithms) {	transformAlgorithm = transformAlgorithm.trim();	Transform transform = fac.newTransform(transformAlgorithm, (TransformParameterSpec) null);	transforms.add(transform);	
transform method 

} else if (signatureAlgorithm.contains(SHA384)) {	result = HTTP_WWW_W3_ORG_2001_04_XMLDSIG_MORE_SHA384;	} else if (signatureAlgorithm.contains(SHA512)) {	result = DigestMethod.SHA512;	} else if (signatureAlgorithm.contains(RIPEMD160)) {	return DigestMethod.RIPEMD160;	}	}	}	if (result != null) {	
digest algorithm 

protected Reference createKeyInfoReference(XMLSignatureFactory fac, String keyInfoId, String digestAlgorithm) throws Exception {	if (keyInfoId == null) {	return null;	}	if (getConfiguration().getAddKeyInfoReference() == null) {	return null;	}	if (!getConfiguration().getAddKeyInfoReference()) {	return null;	}	
creating reference to key info element with id 

========================= camel sample_6770 =========================

public void handleFailedWrite(Exchange exchange, Exception exception) throws Exception {	loggedIn = false;	if (isStopping() || isStopped()) {	
exception occurred during stopping 

public void handleFailedWrite(Exchange exchange, Exception exception) throws Exception {	loggedIn = false;	if (isStopping() || isStopped()) {	} else {	
writing file failed with 

public void handleFailedWrite(Exchange exchange, Exception exception) throws Exception {	loggedIn = false;	if (isStopping() || isStopped()) {	} else {	try {	disconnect();	} catch (Exception e) {	
ignored exception during disconnect 

public void disconnect() throws GenericFileOperationFailedException {	loggedIn = false;	if (getOperations().isConnected()) {	
disconnecting from 

public void preWriteCheck() throws Exception {	boolean noop = false;	if (loggedIn) {	if (getEndpoint().getConfiguration().isSendNoop()) {	try {	noop = getOperations().sendNoop();	} catch (Exception e) {	noop = false;	loggedIn = false;	}	
prewritecheck send noop success 

if (loggedIn) {	if (getEndpoint().getConfiguration().isSendNoop()) {	try {	noop = getOperations().sendNoop();	} catch (Exception e) {	noop = false;	loggedIn = false;	}	} else {	noop = true;	
prewritecheck send noop disabled 

public void postWriteCheck(Exchange exchange) {	try {	boolean isLast = exchange.getProperty(Exchange.BATCH_COMPLETE, false, Boolean.class);	if (isLast && getEndpoint().isDisconnectOnBatchComplete()) {	
postwritecheck disconnect on batch complete from 

public void postWriteCheck(Exchange exchange) {	try {	boolean isLast = exchange.getProperty(Exchange.BATCH_COMPLETE, false, Boolean.class);	if (isLast && getEndpoint().isDisconnectOnBatchComplete()) {	disconnect();	}	if (getEndpoint().isDisconnect()) {	
postwritecheck disconnect from 

public void postWriteCheck(Exchange exchange) {	try {	boolean isLast = exchange.getProperty(Exchange.BATCH_COMPLETE, false, Boolean.class);	if (isLast && getEndpoint().isDisconnectOnBatchComplete()) {	disconnect();	}	if (getEndpoint().isDisconnect()) {	disconnect();	}	} catch (GenericFileOperationFailedException e) {	
exception occurred during disconnecting from 

protected void doStart() throws Exception {	
Starting 

protected void doStop() throws Exception {	try {	disconnect();	} catch (Exception e) {	
exception occurred during disconnecting from 

protected void recoverableConnectIfNecessary() throws Exception {	try {	connectIfNecessary();	} catch (Exception e) {	loggedIn = false;	InterruptedException ie = ObjectHelper.getException(InterruptedException.class, e);	if (ie != null) {	if (log.isDebugEnabled()) {	
interrupted during connect to 

connectIfNecessary();	} catch (Exception e) {	loggedIn = false;	InterruptedException ie = ObjectHelper.getException(InterruptedException.class, e);	if (ie != null) {	if (log.isDebugEnabled()) {	}	throw ie;	}	if (log.isDebugEnabled()) {	
could not connect to will try to recover 

InterruptedException ie = ObjectHelper.getException(InterruptedException.class, e);	if (ie != null) {	if (log.isDebugEnabled()) {	}	throw ie;	}	if (log.isDebugEnabled()) {	}	}	if (!loggedIn) {	
trying to recover connection to with a new ftp client 

protected void connectIfNecessary() throws GenericFileOperationFailedException {	if (!loggedIn || !getOperations().isConnected()) {	
not already connected logged in connecting to 

protected void connectIfNecessary() throws GenericFileOperationFailedException {	if (!loggedIn || !getOperations().isConnected()) {	RemoteFileConfiguration config = getEndpoint().getConfiguration();	loggedIn = getOperations().connect(config);	if (!loggedIn) {	return;	}	
connected and logged in to 

========================= camel sample_15374 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<HazelcastListComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-list.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-list.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_701 =========================

if (isInputStreamNeeded(exchange)) {	is = exchange.getIn().getBody(InputStream.class);	source = getSource(exchange, is);	} else {	Object body = exchange.getIn().getBody();	source = getSource(exchange, body);	}	if (source instanceof StAXSource) {	source = new StAX2SAXSource(((StAXSource) source).getXMLStreamReader());	}	
using as source 

is = exchange.getIn().getBody(InputStream.class);	source = getSource(exchange, is);	} else {	Object body = exchange.getIn().getBody();	source = getSource(exchange, body);	}	if (source instanceof StAXSource) {	source = new StAX2SAXSource(((StAXSource) source).getXMLStreamReader());	}	transformer.transform(source, result);	
transform complete with result 

protected void addParameters(Transformer transformer, Map<String, Object> map) {	Set<Map.Entry<String, Object>> propertyEntries = map.entrySet();	for (Map.Entry<String, Object> entry : propertyEntries) {	String key = entry.getKey();	Object value = entry.getValue();	if (value != null) {	
transformer set parameter 

========================= camel sample_5625 =========================

public boolean onEviction(String key, ReplyHandler value) {	try {	if (listener != null) {	listener.onEviction(key);	}	} catch (Throwable e) {	}	try {	value.onTimeout(key);	} catch (Throwable e) {	
error processing ontimeout for correlationid due this exception is ignored 

try {	if (listener != null) {	listener.onEviction(key);	}	} catch (Throwable e) {	}	try {	value.onTimeout(key);	} catch (Throwable e) {	}	
evicted correlationid 

listener.onPut(key);	}	} catch (Throwable e) {	}	ReplyHandler result;	if (timeoutMillis <= 0) {	result = super.put(key, value, Integer.MAX_VALUE);	} else {	result = super.put(key, value, timeoutMillis);	}	
added correlationid to timeout after millis 

public ReplyHandler putIfAbsent(String key, ReplyHandler value, long timeoutMillis) {	
in putifabsent with key 

}	} catch (Throwable e) {	}	ReplyHandler result;	if (timeoutMillis <= 0) {	result = super.putIfAbsent(key, value, Integer.MAX_VALUE);	} else {	result = super.putIfAbsent(key, value, timeoutMillis);	}	if (result == null) {	
added correlationid to timeout after millis 

} catch (Throwable e) {	}	ReplyHandler result;	if (timeoutMillis <= 0) {	result = super.putIfAbsent(key, value, Integer.MAX_VALUE);	} else {	result = super.putIfAbsent(key, value, timeoutMillis);	}	if (result == null) {	} else {	
duplicate correlationid detected 

========================= camel sample_14135 =========================

public void notify(EventObject event) throws Exception {	if (event instanceof CamelContextStartedEvent) {	
sending a message on startup 

public void notify(EventObject event) throws Exception {	if (event instanceof CamelContextStartedEvent) {	template.sendBody("file:target/startandstop/start.txt", "Starting");	} else if (event instanceof CamelContextStoppingEvent) {	
sending a message on stopping 

========================= camel sample_16108 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SwiftComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.openstack-swift.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.openstack-swift.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1236 =========================

public void testSlowLoop() throws Exception {	for (int i = 0; i < 10; i++) {	try {	
test run 

========================= camel sample_11337 =========================

if (!isRunAllowed()) {	throw new RejectedExecutionException("Run is not allowed");	}	calculateAndSetMaxRequestsPerPeriod(exchange);	ThrottlePermit permit = delayQueue.poll();	if (permit == null) {	if (isRejectExecution()) {	throw new ThrottlerRejectedExecutionException("Exceeded the max throttle rate of " + throttleRate + " within " + timePeriodMillis + "ms");	} else {	if (isAsyncDelayed() && !exchange.isTransacted() && state == State.SYNC) {	
throttle rate exceeded but asyncdelayed enabled so queueing for async processing exchangeid 

start = System.currentTimeMillis();	}	permit = delayQueue.take();	if (log.isTraceEnabled()) {	elapsed = System.currentTimeMillis() - start;	}	enqueuePermit(permit, exchange);	if (state == State.ASYNC) {	if (log.isTraceEnabled()) {	long queuedTime = start - queuedStart;	
queued for ms throttled for ms exchangeid 

permit = delayQueue.take();	if (log.isTraceEnabled()) {	elapsed = System.currentTimeMillis() - start;	}	enqueuePermit(permit, exchange);	if (state == State.ASYNC) {	if (log.isTraceEnabled()) {	long queuedTime = start - queuedStart;	}	} else {	
throttled for ms exchangeid 

long queuedTime = start - queuedStart;	}	} else {	}	}	} else {	enqueuePermit(permit, exchange);	if (state == State.ASYNC) {	if (log.isTraceEnabled()) {	long queuedTime = System.currentTimeMillis() - queuedStart;	
queued for ms no throttling applied throttle cleared while queued for exchangeid 

} else {	}	}	} else {	enqueuePermit(permit, exchange);	if (state == State.ASYNC) {	if (log.isTraceEnabled()) {	long queuedTime = System.currentTimeMillis() - queuedStart;	}	} else {	
no throttling applied to exchangeid 

}	exchange.setProperty(PROPERTY_EXCHANGE_STATE, State.ASYNC);	asyncExecutor.submit(new Runnable() {	public void run() {	process(exchange, callback);	}	});	return false;	} catch (final RejectedExecutionException e) {	if (isCallerRunsWhenRejected()) {	
asyncexecutor is full rejected exchange will run in the current thread exchangeid 

protected void enqueuePermit(final ThrottlePermit permit, final Exchange exchange) {	permit.setDelayMs(getTimePeriodMillis());	delayQueue.put(permit);	if (log.isTraceEnabled()) {	
permit released for exchangeid 

if (newThrottle == null && throttleRate == 0) {	throw new RuntimeExchangeException("The maxRequestsPerPeriodExpression was evaluated as null: " + maxRequestsPerPeriodExpression, exchange);	}	if (newThrottle != null) {	if (newThrottle != throttleRate) {	if (throttleRate > newThrottle) {	int delta = throttleRate - newThrottle;	while (delta > 0) {	delayQueue.take();	delta--;	
permit discarded due to throttling rate decrease triggered by exchangeid 

throw new RuntimeExchangeException("The maxRequestsPerPeriodExpression was evaluated as null: " + maxRequestsPerPeriodExpression, exchange);	}	if (newThrottle != null) {	if (newThrottle != throttleRate) {	if (throttleRate > newThrottle) {	int delta = throttleRate - newThrottle;	while (delta > 0) {	delayQueue.take();	delta--;	}	
throttle rate decreased from to triggered by exchangeid 

while (delta > 0) {	delayQueue.take();	delta--;	}	} else if (newThrottle > throttleRate) {	int delta = newThrottle - throttleRate;	for (int i = 0; i < delta; i++) {	delayQueue.put(new ThrottlePermit(-1));	}	if (throttleRate == 0) {	
initial throttle rate set to triggered by exchangeid 

delayQueue.take();	delta--;	}	} else if (newThrottle > throttleRate) {	int delta = newThrottle - throttleRate;	for (int i = 0; i < delta; i++) {	delayQueue.put(new ThrottlePermit(-1));	}	if (throttleRate == 0) {	} else {	
throttle rate increase from to triggered by exchangeid 

========================= camel sample_4521 =========================

}	if (resletHostOptions.getThreadMaxIdleTimeMs() != null) {	params.add("threadMaxIdleTimeMs", resletHostOptions.getThreadMaxIdleTimeMs().toString());	}	if (resletHostOptions.getUseForwardedForHeader() != null) {	params.add("useForwardedForHeader", resletHostOptions.getUseForwardedForHeader().toString());	}	if (resletHostOptions.getReuseAddress() != null) {	params.add("reuseAddress", resletHostOptions.getReuseAddress().toString());	}	
setting parameters to server 

========================= camel sample_9313 =========================

public void testGetConnections() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.fields", null);	headers.put("CamelLinkedIn.secure_urls", null);	final org.apache.camel.component.linkedin.api.model.Connections result = requestBodyAndHeaders("direct: assertNotNull("getConnections result", result);	
getconnections 

public void testGetConnectionsById() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.person_id", null);	headers.put("CamelLinkedIn.fields", null);	headers.put("CamelLinkedIn.secure_urls", null);	final org.apache.camel.component.linkedin.api.model.Connections result = requestBodyAndHeaders("direct: assertNotNull("getConnectionsById result", result);	
getconnectionsbyid 

public void testGetConnectionsByUrl() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.public_profile_url", null);	headers.put("CamelLinkedIn.fields", null);	headers.put("CamelLinkedIn.secure_urls", null);	final org.apache.camel.component.linkedin.api.model.Connections result = requestBodyAndHeaders("direct: assertNotNull("getConnectionsByUrl result", result);	
getconnectionsbyurl 

public void testGetFollowedCompanies() throws Exception {	final org.apache.camel.component.linkedin.api.model.Companies result = requestBody("direct: assertNotNull("getFollowedCompanies result", result);	
getfollowedcompanies 

public void testGetGroupMembershipSettings() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.group_id", 0L);	headers.put("CamelLinkedIn.fields", null);	headers.put("CamelLinkedIn.count", null);	headers.put("CamelLinkedIn.start", null);	final org.apache.camel.component.linkedin.api.model.GroupMembership result = requestBodyAndHeaders("direct: assertNotNull("getGroupMembershipSettings result", result);	
getgroupmembershipsettings 

public void testGetGroupMemberships() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.membership_state", null);	headers.put("CamelLinkedIn.fields", null);	headers.put("CamelLinkedIn.count", null);	headers.put("CamelLinkedIn.start", null);	final org.apache.camel.component.linkedin.api.model.GroupMemberships result = requestBodyAndHeaders("direct: assertNotNull("getGroupMemberships result", result);	
getgroupmemberships 

public void testGetJobBookmarks() throws Exception {	final org.apache.camel.component.linkedin.api.model.JobBookmarks result = requestBody("direct: assertNotNull("getJobBookmarks result", result);	
getjobbookmarks 

public void testGetNetworkStats() throws Exception {	final org.apache.camel.component.linkedin.api.model.NetworkStats result = requestBody("direct: assertNotNull("getNetworkStats result", result);	
getnetworkstats 

headers.put("CamelLinkedIn.scope", null);	headers.put("CamelLinkedIn.type", null);	headers.put("CamelLinkedIn.count", null);	headers.put("CamelLinkedIn.start", null);	headers.put("CamelLinkedIn.after", null);	headers.put("CamelLinkedIn.before", null);	headers.put("CamelLinkedIn.show_hidden_members", null);	headers.put("CamelLinkedIn.fields", null);	headers.put("CamelLinkedIn.secure_urls", null);	final org.apache.camel.component.linkedin.api.model.Updates result = requestBodyAndHeaders("direct: assertNotNull("getNetworkUpdates result", result);	
getnetworkupdates 

headers.put("CamelLinkedIn.type", null);	headers.put("CamelLinkedIn.count", null);	headers.put("CamelLinkedIn.start", null);	headers.put("CamelLinkedIn.after", null);	headers.put("CamelLinkedIn.before", null);	headers.put("CamelLinkedIn.show_hidden_members", null);	headers.put("CamelLinkedIn.person_id", null);	headers.put("CamelLinkedIn.fields", null);	headers.put("CamelLinkedIn.secure_urls", null);	final org.apache.camel.component.linkedin.api.model.Updates result = requestBodyAndHeaders("direct: assertNotNull("getNetworkUpdatesById result", result);	
getnetworkupdatesbyid 

public void testGetPerson() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.fields", "");	headers.put("CamelLinkedIn.secure_urls", true);	final Person result = requestBodyAndHeaders("direct: assertNotNull("getPerson result", result);	
getperson 

public void testGetPersonById() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.person_id", null);	headers.put("CamelLinkedIn.fields", null);	headers.put("CamelLinkedIn.secure_urls", null);	final Person result = requestBodyAndHeaders("direct: assertNotNull("getPersonById result", result);	
getpersonbyid 

public void testGetPersonByUrl() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.public_profile_url", null);	headers.put("CamelLinkedIn.fields", null);	headers.put("CamelLinkedIn.secure_urls", null);	final Person result = requestBodyAndHeaders("direct: assertNotNull("getPersonByUrl result", result);	
getpersonbyurl 

final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.group_id", 0L);	headers.put("CamelLinkedIn.start", null);	headers.put("CamelLinkedIn.count", null);	headers.put("CamelLinkedIn.order", null);	headers.put("CamelLinkedIn.role", null);	headers.put("CamelLinkedIn.category", null);	headers.put("CamelLinkedIn.modified_since", null);	headers.put("CamelLinkedIn.fields", null);	final org.apache.camel.component.linkedin.api.model.Posts result = requestBodyAndHeaders("direct: assertNotNull("getPosts result", result);	
getposts 

public void testGetSuggestedCompanies() throws Exception {	final org.apache.camel.component.linkedin.api.model.Companies result = requestBody("direct: assertNotNull("getSuggestedCompanies result", result);	
getsuggestedcompanies 

final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.group_id", 0L);	headers.put("CamelLinkedIn.start", null);	headers.put("CamelLinkedIn.count", null);	headers.put("CamelLinkedIn.order", null);	headers.put("CamelLinkedIn.role", null);	headers.put("CamelLinkedIn.category", null);	headers.put("CamelLinkedIn.modified_since", null);	headers.put("CamelLinkedIn.fields", null);	final org.apache.camel.component.linkedin.api.model.Posts result = requestBodyAndHeaders("direct: assertNotNull("getSuggestedGroupPosts result", result);	
getsuggestedgroupposts 

public void testGetSuggestedGroups() throws Exception {	final org.apache.camel.component.linkedin.api.model.Groups result = requestBody("direct: assertNotNull("getSuggestedGroups result", result);	
getsuggestedgroups 

public void testGetSuggestedJobs() throws Exception {	final org.apache.camel.component.linkedin.api.model.JobSuggestions result = requestBody("direct: assertNotNull("getSuggestedJobs result", result);	
getsuggestedjobs 

public void testGetUpdateComments() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.update_key", null);	headers.put("CamelLinkedIn.fields", null);	headers.put("CamelLinkedIn.secure_urls", null);	final org.apache.camel.component.linkedin.api.model.UpdateComments result = requestBodyAndHeaders("direct: assertNotNull("getUpdateComments result", result);	
getupdatecomments 

public void testGetUpdateLikes() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.update_key", null);	headers.put("CamelLinkedIn.fields", null);	headers.put("CamelLinkedIn.secure_urls", null);	final org.apache.camel.component.linkedin.api.model.Likes result = requestBodyAndHeaders("direct: assertNotNull("getUpdateLikes result", result);	
getupdatelikes 

public void testShare() throws Exception {	final org.apache.camel.component.linkedin.api.model.Update result = requestBody("direct: assertNotNull("share result", result);	
share 

========================= camel sample_8851 =========================

protected abstract int poll() throws Exception;	protected void doStart() throws Exception {	if (configuration.getClient() == null) {	configuration.createClient();	
consumer dropbox client created 

protected void doStop() throws Exception {	if (configuration.getClient() == null) {	configuration.setClient(null);	
consumer dropbox client deleted 

========================= camel sample_8502 =========================

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, false);	for (ParserResult result : list) {	
consumer 

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, false);	for (ParserResult result : list) {	}	Assert.assertEquals("timer:foo", list.get(0).getElement());	list = CamelJavaParserHelper.parseCamelProducerUris(method, true, false);	for (ParserResult result : list) {	
producer 

========================= camel sample_214 =========================

public void initializeConnection() throws CamelMongoDbException {	
initialising mongodb endpoint 

}	mongoDatabase = mongoConnection.getDatabase(database);	if (mongoDatabase == null) {	throw new CamelMongoDbException("Could not initialise MongoDbComponent. Database " + database + " does not exist.");	}	if (collection != null) {	if (!createCollection && !databaseContainsCollection(collection)) {	throw new CamelMongoDbException("Could not initialise MongoDbComponent. Collection " + collection + " and createCollection is false.");	}	mongoCollection = mongoDatabase.getCollection(collection, Document.class);	
mongodb component initialised and endpoint bound to mongodb collection with the following parameters address list db collection 

public void ensureIndex(MongoCollection<Document> aCollection, List<Bson> dynamicIndex) {	if (dynamicIndex != null && !dynamicIndex.isEmpty()) {	for (Bson index : dynamicIndex) {	
create document index 

protected void doStart() throws Exception {	mongoConnection = CamelContextHelper.mandatoryLookup(getCamelContext(), connectionBean, MongoClient.class);	
resolved the connection with the name as 

protected void doStop() throws Exception {	super.doStop();	if (mongoConnection != null) {	
closing connection 

========================= camel sample_10463 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<JettyHttpComponent9> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jetty.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jetty.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_490 =========================

protected void assertValidContext(SpringCamelContext context) {	assertNotNull("No context found!", context);	List<Route> routes = context.getRoutes();	assertNotNull("Should have some routes defined", routes);	assertEquals("Number of routes defined", 1, routes.size());	Route route = routes.get(0);	
found route 

========================= camel sample_16299 =========================

for (int i = 0; i < map.getLength(); i++) {	Node att = map.item(i);	if (att.getNodeName().equals("uri") || att.getNodeName().endsWith("Uri")) {	final String value = att.getNodeValue();	String before = ObjectHelper.before(value, "?");	String after = ObjectHelper.after(value, "?");	if (before != null && after != null) {	String changed = after.replaceAll("\\s{2,}", "");	if (!after.equals(changed)) {	String newAtr = before.trim() + "?" + changed.trim();	
removed whitespace noise from attribute 

try {	Class.forName("org.osgi.framework.BundleActivator");	Class<?> c = Class.forName("org.apache.camel.osgi.Activator");	Method mth = c.getDeclaredMethod("getBundle");	Object bundle = mth.invoke(null);	if (bundle != null) {	cl = Class.forName("org.apache.camel.osgi.CamelContextFactoryBean");	osgi = true;	}	} catch (Throwable t) {	
cannot find class so assuming not running in osgi container 

Class<?> c = Class.forName("org.apache.camel.osgi.Activator");	Method mth = c.getDeclaredMethod("getBundle");	Object bundle = mth.invoke(null);	if (bundle != null) {	cl = Class.forName("org.apache.camel.osgi.CamelContextFactoryBean");	osgi = true;	}	} catch (Throwable t) {	}	if (osgi) {	
osgi environment detected 

Method mth = c.getDeclaredMethod("getBundle");	Object bundle = mth.invoke(null);	if (bundle != null) {	cl = Class.forName("org.apache.camel.osgi.CamelContextFactoryBean");	osgi = true;	}	} catch (Throwable t) {	}	if (osgi) {	}	
using as camelcontextbeandefinitionparser 

parserContext.registerComponent(new BeanComponentDefinition(definition, id));	if (localName.equals("template") || localName.equals("fluentTemplate") || localName.equals("consumerTemplate") || localName.equals("proxy") || localName.equals("export")) {	definition.getPropertyValues().addPropertyValue("camelContext", new RuntimeBeanReference(contextId));	}	}	}	}	}	}	if (registerEndpointIdsFromRoute) {	
registering endpoint with ids defined in camel routes 

protected void addDependsOn(CamelContextFactoryBean factoryBean, BeanDefinitionBuilder builder) {	String dependsOn = factoryBean.getDependsOn();	if (ObjectHelper.isNotEmpty(dependsOn)) {	String[] depends = dependsOn.split(",|;|\\s");	if (depends == null) {	throw new IllegalArgumentException("Cannot separate depends-on, was: " + dependsOn);	} else {	for (String depend : depends) {	depend = depend.trim();	
adding dependson to camelcontext 

consumerTemplate = true;	}	}	}	if (!template) {	boolean existing = autoRegisterMap.get("template") != null;	boolean inUse = false;	try {	inUse = parserContext.getRegistry().isBeanNameInUse("template");	} catch (BeanCreationException e) {	
error checking isbeannameinuse template this exception will be ignored 

BeanDefinition definition = parser.parse(templateElement, parserContext);	autoRegisterBeanDefinition(id, definition, parserContext, contextId);	}	}	if (!fluentTemplate) {	boolean existing = autoRegisterMap.get("fluentTemplate") != null;	boolean inUse = false;	try {	inUse = parserContext.getRegistry().isBeanNameInUse("fluentTemplate");	} catch (BeanCreationException e) {	
error checking isbeannameinuse fluenttemplate this exception will be ignored 

BeanDefinition definition = parser.parse(templateElement, parserContext);	autoRegisterBeanDefinition(id, definition, parserContext, contextId);	}	}	if (!consumerTemplate) {	boolean existing = autoRegisterMap.get("consumerTemplate") != null;	boolean inUse = false;	try {	inUse = parserContext.getRegistry().isBeanNameInUse("consumerTemplate");	} catch (BeanCreationException e) {	
error checking isbeannameinuse consumertemplate this exception will be ignored 

private void autoRegisterBeanDefinition(String id, BeanDefinition definition, ParserContext parserContext, String contextId) {	BeanDefinition existing = autoRegisterMap.get(id);	if (existing == null) {	autoRegisterMap.put(id, definition);	parserContext.registerComponent(new BeanComponentDefinition(definition, id));	if (LOG.isDebugEnabled()) {	
registered default with id on camel context 

private void autoRegisterBeanDefinition(String id, BeanDefinition definition, ParserContext parserContext, String contextId) {	BeanDefinition existing = autoRegisterMap.get(id);	if (existing == null) {	autoRegisterMap.put(id, definition);	parserContext.registerComponent(new BeanComponentDefinition(definition, id));	if (LOG.isDebugEnabled()) {	}	} else {	
unregistered default with id as we have multiple camel contexts and they must use unique ids you must define the definition in the xml file manually to avoid id clashes when using multiple camel contexts 

private void registerEndpoint(Element childElement, ParserContext parserContext, String contextId) {	String id = childElement.getAttribute("id");	if (ObjectHelper.isNotEmpty(id)) {	if (id.startsWith("_")) {	
skip registering endpoint starting with underscore 

========================= camel sample_16333 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<BindingNameComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.binding.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.binding.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_869 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<DataFormatComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.dataformat.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.dataformat.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_886 =========================

String candidate = null;	boolean clash = false;	do {	try {	clash = false;	if (candidate == null && checkFirst) {	candidate = prefix;	} else {	candidate = prefix + "-" + getNextCounter(counter);	}	
checking osgi service registry for existence of existing camelcontext with name 

if (refs != null && refs.length > 0) {	for (ServiceReference<?> ref : refs) {	Object id = ref.getProperty(key);	if (id != null && candidate.equals(id)) {	clash = true;	break;	}	}	}	} catch (InvalidSyntaxException e) {	
error finding free camel name in osgi service registry due this exception is ignored 

if (id != null && candidate.equals(id)) {	clash = true;	break;	}	}	}	} catch (InvalidSyntaxException e) {	break;	}	} while (clash);	
generated free name for bundle id clash 

========================= camel sample_13074 =========================

String latlng = exchange.getIn().getHeader(GeoCoderConstants.LATLNG, String.class);	if (latlng == null) {	latlng = endpoint.getLatlng();	}	if (latlng != null) {	GeocoderRequest req = new GeocoderRequest();	req.setLanguage(endpoint.getLanguage());	String lat = ObjectHelper.before(latlng, ",");	String lng = ObjectHelper.after(latlng, ",");	req.setLocation(new LatLng(lat, lng));	
geocode for lat lng 

if (latlng == null) {	latlng = endpoint.getLatlng();	}	if (latlng != null) {	GeocoderRequest req = new GeocoderRequest();	req.setLanguage(endpoint.getLanguage());	String lat = ObjectHelper.before(latlng, ",");	String lng = ObjectHelper.after(latlng, ",");	req.setLocation(new LatLng(lat, lng));	GeocodeResponse res = geocoder.geocode(req);	
geocode response 

String lng = ObjectHelper.after(latlng, ",");	req.setLocation(new LatLng(lat, lng));	GeocodeResponse res = geocoder.geocode(req);	if (res != null) {	extractGeoResult(res, exchange);	}	} else if (address != null) {	if ("current".equals(address)) {	processCurrentLocation(exchange);	} else {	
geocode for address 

GeocodeResponse res = geocoder.geocode(req);	if (res != null) {	extractGeoResult(res, exchange);	}	} else if (address != null) {	if ("current".equals(address)) {	processCurrentLocation(exchange);	} else {	GeocoderRequest req = new GeocoderRequest(address, endpoint.getLanguage());	GeocodeResponse res = geocoder.geocode(req);	
geocode response 

protected void processCurrentLocation(Exchange exchange) throws Exception {	
geocode for current address 

protected void processCurrentLocation(Exchange exchange) throws Exception {	String json = exchange.getContext().getTypeConverter().mandatoryConvertTo(String.class, new URL("https: if (isEmpty(json)) {	throw new IllegalStateException("Got the unexpected value '" + json + "' for the geolocation");	}	
geocode response 

========================= camel sample_9578 =========================

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/SimpleProcessorTest.java"));	MethodSource<JavaClassSource> method = CamelJavaParserHelper.findConfigureMethod(clazz);	List<CamelEndpointDetails> details = new ArrayList<CamelEndpointDetails>();	RouteBuilderParser.parseRouteBuilderEndpoints(clazz, ".", "src/test/java/org/apache/camel/parser/java/SimpleProcessorTest.java", details);	LOG.info("{}", details);	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	
consumer 

MethodSource<JavaClassSource> method = CamelJavaParserHelper.findConfigureMethod(clazz);	List<CamelEndpointDetails> details = new ArrayList<CamelEndpointDetails>();	RouteBuilderParser.parseRouteBuilderEndpoints(clazz, ".", "src/test/java/org/apache/camel/parser/java/SimpleProcessorTest.java", details);	LOG.info("{}", details);	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	}	Assert.assertEquals("direct:start", list.get(0).getElement());	list = CamelJavaParserHelper.parseCamelProducerUris(method, true, true);	for (ParserResult result : list) {	
producer 

========================= camel sample_185 =========================

RouteBuilder routes = new RouteBuilder() {	public void configure() throws Exception {	from("quickfix:examples/inprocess.cfg"). filter(header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.SessionLogon)). bean(new CountDownLatchDecrementer("logon", logonLatch));	from("quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:MARKET->TRADER"). filter(header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.AppMessageReceived)). to("trade-executor:market");	from("trade-executor:market").to("quickfix:examples/inprocess.cfg");	from("quickfix:examples/inprocess.cfg"). filter(PredicateBuilder.or( header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.AppMessageReceived), header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.AppMessageSent))). bean(new QuickfixjMessageJsonPrinter());	from("quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:TRADER->MARKET"). filter(PredicateBuilder.and( header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.AppMessageReceived), header(QuickfixjEndpoint.MESSAGE_TYPE_KEY).isEqualTo(MsgType.EXECUTION_REPORT))). bean(new CountDownLatchDecrementer("execution report", executionReportLatch));	}	};	context.addRoutes(routes);	
starting camel context 

}	};	context.addRoutes(routes);	context.start();	if (!logonLatch.await(5, TimeUnit.SECONDS)) {	throw new IllegalStateException("Logon did not complete");	}	String gatewayUri = "quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:TRADER->MARKET";	Endpoint gatewayEndpoint = context.getEndpoint(gatewayUri);	Producer producer = gatewayEndpoint.createProducer();	
sending order 

String gatewayUri = "quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:TRADER->MARKET";	Endpoint gatewayEndpoint = context.getEndpoint(gatewayUri);	Producer producer = gatewayEndpoint.createProducer();	NewOrderSingle order = createNewOrderMessage();	Exchange exchange = producer.createExchange(ExchangePattern.InOnly);	exchange.getIn().setBody(order);	producer.process(exchange);	if (!executionReportLatch.await(5, TimeUnit.SECONDS)) {	throw new IllegalStateException("Did not receive execution reports");	}	
message received shutting down camel context 

Endpoint gatewayEndpoint = context.getEndpoint(gatewayUri);	Producer producer = gatewayEndpoint.createProducer();	NewOrderSingle order = createNewOrderMessage();	Exchange exchange = producer.createExchange(ExchangePattern.InOnly);	exchange.getIn().setBody(order);	producer.process(exchange);	if (!executionReportLatch.await(5, TimeUnit.SECONDS)) {	throw new IllegalStateException("Did not receive execution reports");	}	context.stop();	
order execution example complete 

========================= camel sample_10658 =========================

protected int poll() throws Exception {	shutdownRunningTask = null;	pendingExchanges = 0;	String fileName = getConfiguration().getFileName();	String bucketName = getConfiguration().getBucketName();	Queue<Exchange> exchanges;	if (fileName != null) {	
getting object in bucket with file name 

protected int poll() throws Exception {	shutdownRunningTask = null;	pendingExchanges = 0;	String fileName = getConfiguration().getFileName();	String bucketName = getConfiguration().getBucketName();	Queue<Exchange> exchanges;	if (fileName != null) {	S3Object s3Object = getAmazonS3Client().getObject(new GetObjectRequest(bucketName, fileName));	exchanges = createExchanges(s3Object);	} else {	
queueing objects in bucket 

S3Object s3Object = getAmazonS3Client().getObject(new GetObjectRequest(bucketName, fileName));	exchanges = createExchanges(s3Object);	} else {	ListObjectsRequest listObjectsRequest = new ListObjectsRequest();	listObjectsRequest.setBucketName(bucketName);	listObjectsRequest.setPrefix(getConfiguration().getPrefix());	if (maxMessagesPerPoll > 0) {	listObjectsRequest.setMaxKeys(maxMessagesPerPoll);	}	if (marker != null) {	
resuming from marker 

listObjectsRequest.setPrefix(getConfiguration().getPrefix());	if (maxMessagesPerPoll > 0) {	listObjectsRequest.setMaxKeys(maxMessagesPerPoll);	}	if (marker != null) {	listObjectsRequest.setMarker(marker);	}	ObjectListing listObjects = getAmazonS3Client().listObjects(listObjectsRequest);	if (listObjects.isTruncated()) {	marker = listObjects.getNextMarker();	
returned list is truncated so setting next marker 

if (marker != null) {	listObjectsRequest.setMarker(marker);	}	ObjectListing listObjects = getAmazonS3Client().listObjects(listObjectsRequest);	if (listObjects.isTruncated()) {	marker = listObjects.getNextMarker();	} else {	marker = null;	}	if (LOG.isTraceEnabled()) {	
found objects in bucket 

protected Queue<Exchange> createExchanges(List<S3ObjectSummary> s3ObjectSummaries) {	if (LOG.isTraceEnabled()) {	
received messages in this poll 

Collection<S3Object> s3Objects = new ArrayList<>();	Queue<Exchange> answer = new LinkedList<Exchange>();	try {	for (S3ObjectSummary s3ObjectSummary : s3ObjectSummaries) {	S3Object s3Object = getAmazonS3Client().getObject(s3ObjectSummary.getBucketName(), s3ObjectSummary.getKey());	s3Objects.add(s3Object);	Exchange exchange = getEndpoint().createExchange(s3Object);	answer.add(exchange);	}	} catch (Throwable e) {	
error getting due 

public void onComplete(Exchange exchange) {	processCommit(exchange);	}	public void onFailure(Exchange exchange) {	processRollback(exchange);	}	public String toString() {	return "S3ConsumerOnCompletion";	}	});	
processing exchange 

}	public void onFailure(Exchange exchange) {	processRollback(exchange);	}	public String toString() {	return "S3ConsumerOnCompletion";	}	});	getAsyncProcessor().process(exchange, new AsyncCallback() {	public void done(boolean doneSync) {	
processing exchange done 

protected void processCommit(Exchange exchange) {	try {	if (getConfiguration().isDeleteAfterRead()) {	String bucketName = exchange.getIn().getHeader(S3Constants.BUCKET_NAME, String.class);	String key = exchange.getIn().getHeader(S3Constants.KEY, String.class);	
deleting object from bucket with key 

protected void processCommit(Exchange exchange) {	try {	if (getConfiguration().isDeleteAfterRead()) {	String bucketName = exchange.getIn().getHeader(S3Constants.BUCKET_NAME, String.class);	String key = exchange.getIn().getHeader(S3Constants.KEY, String.class);	getAmazonS3Client().deleteObject(bucketName, key);	
deleted object from bucket with key 

protected void processRollback(Exchange exchange) {	Exception cause = exchange.getException();	if (cause != null) {	
exchange failed so rolling back message status 

protected void processRollback(Exchange exchange) {	Exception cause = exchange.getException();	if (cause != null) {	} else {	
exchange failed so rolling back message status 

========================= camel sample_8693 =========================

protected void checkWeatherContent(String weather) {	
the weather in format is 

========================= camel sample_11360 =========================

public void testPostStatusUpdateRequestResponse() throws Exception {	Date now = new Date();	String tweet = "UserProducerInOutTest: This is a tweet posted on " + now.toString();	
tweet 

========================= camel sample_14162 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<UniVocityCsvDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.univocity-csv.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.univocity-csv.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_1261 =========================

public ApplicationContext loadContext(MergedContextConfiguration mergedConfig) throws Exception {	Class<?> testClass = getTestClass();	if (LOG.isDebugEnabled()) {	
loading applicationcontext for merged context configuration 

public ApplicationContext loadContext(String... locations) throws Exception {	Class<?> testClass = getTestClass();	if (LOG.isDebugEnabled()) {	
loading applicationcontext for locations 

protected GenericApplicationContext createContext(Class<?> testClass, MergedContextConfiguration mergedConfig) {	ApplicationContext parentContext = null;	GenericApplicationContext routeExcludingContext = null;	if (mergedConfig != null) {	parentContext = mergedConfig.getParentApplicationContext();	}	if (testClass.isAnnotationPresent(ExcludeRoutes.class)) {	Class<?>[] excludedClasses = testClass.getAnnotation(ExcludeRoutes.class).value();	if (excludedClasses.length > 0) {	if (LOG.isDebugEnabled()) {	
setting up package scanning excluded classes as excluderoutes annotation was found excluding 

} else {	routeExcludingContext = new GenericApplicationContext(parentContext);	}	routeExcludingContext.registerBeanDefinition("excludingResolver", new RootBeanDefinition(ExcludingPackageScanClassResolver.class));	routeExcludingContext.refresh();	ExcludingPackageScanClassResolver excludingResolver = routeExcludingContext.getBean("excludingResolver", ExcludingPackageScanClassResolver.class);	List<Class<?>> excluded = Arrays.asList(excludedClasses);	excludingResolver.setExcludedClasses(new HashSet<Class<?>>(excluded));	} else {	if (LOG.isDebugEnabled()) {	
not enabling package scanning excluded classes as excluderoutes annotation was found but no classes were excluded 

protected void handleDisableJmx(GenericApplicationContext context, Class<?> testClass) {	CamelSpringTestHelper.setOriginalJmxDisabledValue(System.getProperty(JmxSystemPropertyKeys.DISABLED));	if (testClass.isAnnotationPresent(DisableJmx.class)) {	if (testClass.getAnnotation(DisableJmx.class).value()) {	
disabling camel jmx globally as disablejmx annotation was found and disablejmx is set to true 

protected void handleDisableJmx(GenericApplicationContext context, Class<?> testClass) {	CamelSpringTestHelper.setOriginalJmxDisabledValue(System.getProperty(JmxSystemPropertyKeys.DISABLED));	if (testClass.isAnnotationPresent(DisableJmx.class)) {	if (testClass.getAnnotation(DisableJmx.class).value()) {	System.setProperty(JmxSystemPropertyKeys.DISABLED, "true");	} else {	
enabling camel jmx as disablejmx annotation was found and disablejmx is set to false 

protected void handleDisableJmx(GenericApplicationContext context, Class<?> testClass) {	CamelSpringTestHelper.setOriginalJmxDisabledValue(System.getProperty(JmxSystemPropertyKeys.DISABLED));	if (testClass.isAnnotationPresent(DisableJmx.class)) {	if (testClass.getAnnotation(DisableJmx.class).value()) {	System.setProperty(JmxSystemPropertyKeys.DISABLED, "true");	} else {	System.clearProperty(JmxSystemPropertyKeys.DISABLED);	}	} else if (!testClass.isAnnotationPresent(EnableRouteCoverage.class)) {	
disabling camel jmx globally for tests by default use the disablejmx annotation to override the default setting 

private void handleRouteCoverage(GenericApplicationContext context, Class<?> testClass) throws Exception {	if (testClass.isAnnotationPresent(EnableRouteCoverage.class)) {	System.setProperty(CamelTestSupport.ROUTE_COVERAGE_ENABLED, "true");	CamelSpringTestHelper.doToSpringCamelContexts(context, new DoToSpringCamelContextsStrategy() {	public void execute(String contextName, SpringCamelContext camelContext) throws Exception {	
enabling routecoverage 

}	if (breakpoints.size() != 0) {	CamelSpringTestHelper.doToSpringCamelContexts(context, new DoToSpringCamelContextsStrategy() {	public void execute(String contextName, SpringCamelContext camelContext) throws Exception {	Debugger debugger = camelContext.getDebugger();	if (debugger == null) {	debugger = new DefaultDebugger();	camelContext.setDebugger(debugger);	}	for (Breakpoint breakpoint : breakpoints) {	
adding breakpoint to camelcontext with name 

final TimeUnit shutdownTimeUnit;	if (testClass.isAnnotationPresent(ShutdownTimeout.class)) {	shutdownTimeout = testClass.getAnnotation(ShutdownTimeout.class).value();	shutdownTimeUnit = testClass.getAnnotation(ShutdownTimeout.class).timeUnit();	} else {	shutdownTimeout = 10;	shutdownTimeUnit = TimeUnit.SECONDS;	}	CamelSpringTestHelper.doToSpringCamelContexts(context, new DoToSpringCamelContextsStrategy() {	public void execute(String contextName, SpringCamelContext camelContext) throws Exception {	
setting shutdown timeout to on camelcontext with name 

protected void handleMockEndpoints(GenericApplicationContext context, Class<?> testClass) throws Exception {	if (testClass.isAnnotationPresent(MockEndpoints.class)) {	final String mockEndpoints = testClass.getAnnotation(MockEndpoints.class).value();	CamelSpringTestHelper.doToSpringCamelContexts(context, new DoToSpringCamelContextsStrategy() {	public void execute(String contextName, SpringCamelContext camelContext) throws Exception {	
enabling auto mocking of endpoints matching pattern on camelcontext with name 

protected void handleMockEndpointsAndSkip(GenericApplicationContext context, Class<?> testClass) throws Exception {	if (testClass.isAnnotationPresent(MockEndpointsAndSkip.class)) {	final String mockEndpoints = testClass.getAnnotation(MockEndpointsAndSkip.class).value();	CamelSpringTestHelper.doToSpringCamelContexts(context, new DoToSpringCamelContextsStrategy() {	public void execute(String contextName, SpringCamelContext camelContext) throws Exception {	String mockEndpointsValue = camelContext.resolvePropertyPlaceholders(mockEndpoints);	
enabling auto mocking and skipping of endpoints matching pattern on camelcontext with name 

}	if (properties.size() != 0) {	CamelSpringTestHelper.doToSpringCamelContexts(context, new DoToSpringCamelContextsStrategy() {	public void execute(String contextName, SpringCamelContext camelContext) throws Exception {	PropertiesComponent pc = camelContext.getComponent("properties", PropertiesComponent.class);	Properties extra = new Properties();	for (Properties prop : properties) {	extra.putAll(prop);	}	if (!extra.isEmpty()) {	
using properties to override any existing properties on the propertiescomponent on camelcontext with name 

protected void handleCamelContextStartup(GenericApplicationContext context, Class<?> testClass) throws Exception {	boolean skip = "true".equalsIgnoreCase(System.getProperty("skipStartingCamelContext"));	if (skip) {	
skipping starting camelcontext s as system property skipstartingcamelcontext is set to be true 

protected void handleCamelContextStartup(GenericApplicationContext context, Class<?> testClass) throws Exception {	boolean skip = "true".equalsIgnoreCase(System.getProperty("skipStartingCamelContext"));	if (skip) {	} else if (testClass.isAnnotationPresent(UseAdviceWith.class)) {	if (testClass.getAnnotation(UseAdviceWith.class).value()) {	
skipping starting camelcontext s as useadvicewith annotation was found and isuseadvicewith is set to true 

protected void handleCamelContextStartup(GenericApplicationContext context, Class<?> testClass) throws Exception {	boolean skip = "true".equalsIgnoreCase(System.getProperty("skipStartingCamelContext"));	if (skip) {	} else if (testClass.isAnnotationPresent(UseAdviceWith.class)) {	if (testClass.getAnnotation(UseAdviceWith.class).value()) {	skip = true;	} else {	
starting camelcontext s as useadvicewith annotation was found but isuseadvicewith is set to false 

} else if (testClass.isAnnotationPresent(UseAdviceWith.class)) {	if (testClass.getAnnotation(UseAdviceWith.class).value()) {	skip = true;	} else {	skip = false;	}	}	if (!skip) {	CamelSpringTestHelper.doToSpringCamelContexts(context, new DoToSpringCamelContextsStrategy() {	public void execute(String contextName, SpringCamelContext camelContext) throws Exception {	
starting camelcontext with name 

========================= camel sample_10571 =========================

protected void executeWithClient(final RestClient client) throws MojoExecutionException {	
generating json schema 

} catch (final IOException e) {	throw new MojoExecutionException("Unable to generate JSON Schema types for: " + description.getName(), e);	}	}	final Path schemaFilePath = outputDirectory.toPath().resolve(jsonSchemaFilename);	try {	Files.write(schemaFilePath, JsonUtils.getJsonSchemaString(schemaObjectMapper, allSchemas, jsonSchemaId).getBytes("UTF-8"));	} catch (final IOException e) {	throw new MojoExecutionException("Unable to generate JSON Schema source file: " + schemaFilePath, e);	}	
successfully generated s json types in file s 

========================= camel sample_14924 =========================

context.setName("context-" + id);	context.addService(service);	context.addRoutes(new RouteBuilder() {	public void configure() throws Exception {	from("master:jgl:timer:master?delay=1s&period=1s") .routeId("route-" + id) .log("From ${routeId}") .process(e -> contextLatch.countDown());	}	});	Thread.sleep(ThreadLocalRandom.current().nextInt(500));	context.start();	contextLatch.await();	
shutting down node 

========================= camel sample_16919 =========================

args.setOwner(owner);	}	args.setUsername(username);	args.setPassword(password);	if (isUseSunHttpsHandler()) {	String sunHandlerClassName = "sun.net.www.protocol.https.Handler";	Class<URLStreamHandler> clazz = camelContext.getClassResolver().resolveClass(sunHandlerClassName, URLStreamHandler.class);	if (clazz != null) {	URLStreamHandler handler = camelContext.getInjector().newInstance(clazz);	args.setHTTPSHandler(handler);	
using the urlstreamhandler for 

}	args.setUsername(username);	args.setPassword(password);	if (isUseSunHttpsHandler()) {	String sunHandlerClassName = "sun.net.www.protocol.https.Handler";	Class<URLStreamHandler> clazz = camelContext.getClassResolver().resolveClass(sunHandlerClassName, URLStreamHandler.class);	if (clazz != null) {	URLStreamHandler handler = camelContext.getInjector().newInstance(clazz);	args.setHTTPSHandler(handler);	} else {	
could not resolve and use the urlstreamhandler class 

if (clazz != null) {	URLStreamHandler handler = camelContext.getInjector().newInstance(clazz);	args.setHTTPSHandler(handler);	} else {	}	}	ExecutorService executor = camelContext.getExecutorServiceManager().newSingleThreadExecutor(this, "DefaultSplunkConnectionFactory");	Future<Service> future = executor.submit(new Callable<Service>() {	public Service call() throws Exception {	if (Service.DEFAULT_SCHEME.equals(getScheme())) {	
https in use setting ssl protocol to 

return Service.connect(args);	}	});	try {	Service service = null;	if (connectionTimeout > 0) {	service = future.get(connectionTimeout, TimeUnit.MILLISECONDS);	} else {	service = future.get();	}	
successfully connected to splunk 

========================= camel sample_14477 =========================

private void startBroker() throws Exception {	broker.start();	
started embedded jms server 

public void tearDown() throws Exception {	super.tearDown();	DefaultCamelContext dcc = (DefaultCamelContext)context;	while (!dcc.isStopped()) {	
waiting on the camel context to stop 

public void tearDown() throws Exception {	super.tearDown();	DefaultCamelContext dcc = (DefaultCamelContext)context;	while (!dcc.isStopped()) {	}	
closing jms session 

public void tearDown() throws Exception {	super.tearDown();	DefaultCamelContext dcc = (DefaultCamelContext)context;	while (!dcc.isStopped()) {	}	if (getSession() != null) {	getSession().close();	setSession(null);	}	
closing jms connection 

while (!dcc.isStopped()) {	}	if (getSession() != null) {	getSession().close();	setSession(null);	}	if (connection != null) {	connection.stop();	connection = null;	}	
stopping the activemq broker 

========================= camel sample_9344 =========================

public boolean process(final Exchange exchange, final AsyncCallback callback) {	final String id = routeIdExpression().evaluate(exchange, String.class);	Deque<String> fatals = exchange.getProperty(Exchange.FATAL_FALLBACK_ERROR_HANDLER, null, Deque.class);	if (fatals == null) {	fatals = new ArrayDeque<>();	exchange.setProperty(Exchange.FATAL_FALLBACK_ERROR_HANDLER, fatals);	}	if (fatals.contains(id)) {	
circular error handler detected at route breaking out processing exchange 

========================= camel sample_4576 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<GitHubComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.github.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.github.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1099 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KinesisFirehoseComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-kinesis-firehose.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-kinesis-firehose.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1133 =========================

private void warnIfNoCamelFound() {	BeanManager manager = cdiContainer.getBeanManager();	Set<Bean<?>> contexts = manager.getBeans(CamelContext.class, ANY);	if (contexts.isEmpty()) {	
camel cdi main has started with no camel context 

========================= camel sample_9915 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KubernetesPersistentVolumesClaimsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-persistent-volumes-claims.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-persistent-volumes-claims.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_541 =========================

public void xxxtestAggregateSimpleExpression() throws Exception {	int files = 10;	int rows = 100000;	int batches = rows / 1000;	int total = files + (files * rows) + (files * batches);	
there are exchanges 

public void xxxtestAggregateSimpleExpression() throws Exception {	int files = 10;	int rows = 100000;	int batches = rows / 1000;	int total = files + (files * rows) + (files * batches);	NotifyBuilder notify = new NotifyBuilder(context).whenDone(total).create();	
writing files with rows in each file 

NotifyBuilder notify = new NotifyBuilder(context).whenDone(total).create();	for (int i = 0; i < files; i++) {	Writer out = IOHelper.buffered(new FileWriter(new File("target/files", "data" + i)));	for (int j = 0; j < rows; j++) {	out.write(DATA);	}	out.close();	}	StopWatch watch = new StopWatch();	context.startRoute("foo");	
waiting to process all the files 

for (int i = 0; i < files; i++) {	Writer out = IOHelper.buffered(new FileWriter(new File("target/files", "data" + i)));	for (int j = 0; j < rows; j++) {	out.write(DATA);	}	out.close();	}	StopWatch watch = new StopWatch();	context.startRoute("foo");	boolean matches = notify.matches(3, TimeUnit.MINUTES);	
should process all files 

for (int i = 0; i < files; i++) {	Writer out = IOHelper.buffered(new FileWriter(new File("target/files", "data" + i)));	for (int j = 0; j < rows; j++) {	out.write(DATA);	}	out.close();	}	StopWatch watch = new StopWatch();	context.startRoute("foo");	boolean matches = notify.matches(3, TimeUnit.MINUTES);	
time taken ms 

public void invoke(final List<String> strList) {	
batch 

========================= camel sample_1975 =========================

public void initAnnotatedFields() {	maxpos = 0;	for (Class<?> cl : models) {	List<Field> linkFields = new ArrayList<Field>();	if (LOG.isDebugEnabled()) {	
class retrieved 

public void initAnnotatedFields() {	maxpos = 0;	for (Class<?> cl : models) {	List<Field> linkFields = new ArrayList<Field>();	if (LOG.isDebugEnabled()) {	}	for (Field field : cl.getDeclaredFields()) {	DataField dataField = field.getAnnotation(DataField.class);	if (dataField != null) {	if (LOG.isDebugEnabled()) {	
position defined in the class position field 

if (LOG.isDebugEnabled()) {	}	if (dataField.required()) {	++numberMandatoryFields;	} else {	++numberOptionalFields;	}	int pos = dataField.pos();	if (annotatedFields.containsKey(pos)) {	Field f = annotatedFields.get(pos);	
potentially invalid model existing datafield replaced by 

if (annotatedFields.containsKey(pos)) {	Field f = annotatedFields.get(pos);	}	dataFields.put(pos, dataField);	annotatedFields.put(pos, field);	maxpos = Math.max(maxpos, pos);	}	Link linkField = field.getAnnotation(Link.class);	if (linkField != null) {	if (LOG.isDebugEnabled()) {	
class linked field 

if (LOG.isDebugEnabled()) {	}	linkFields.add(field);	}	}	if (!linkFields.isEmpty()) {	annotatedLinkFields.put(cl.getName(), linkFields);	}	totalFields = numberMandatoryFields + numberOptionalFields;	if (LOG.isDebugEnabled()) {	
number of optional fields 

if (LOG.isDebugEnabled()) {	}	linkFields.add(field);	}	}	if (!linkFields.isEmpty()) {	annotatedLinkFields.put(cl.getName(), linkFields);	}	totalFields = numberMandatoryFields + numberOptionalFields;	if (LOG.isDebugEnabled()) {	
number of mandatory fields 

if (LOG.isDebugEnabled()) {	}	linkFields.add(field);	}	}	if (!linkFields.isEmpty()) {	annotatedLinkFields.put(cl.getName(), linkFields);	}	totalFields = numberMandatoryFields + numberOptionalFields;	if (LOG.isDebugEnabled()) {	
total 

}	}	if (!linkFields.isEmpty()) {	annotatedLinkFields.put(cl.getName(), linkFields);	}	totalFields = numberMandatoryFields + numberOptionalFields;	if (LOG.isDebugEnabled()) {	}	}	if (annotatedFields.size() < maxpos) {	
potentially incomplete model some csv fields may not be mapped to datafield members 

}	if (dataField.required()) {	++counterMandatoryFields;	if (data.equals("")) {	throw new IllegalArgumentException("The mandatory field defined at the position " + pos + " is empty for the line: " + line);	}	}	Field field = annotatedFields.get(pos);	field.setAccessible(true);	if (LOG.isDebugEnabled()) {	
pos data field type 

if (m != null) {	value = ObjectHelper.invokeMethod(m, null, value);	} else {	m = ReflectionHelper.findMethod(clazz, methodName);	value = ObjectHelper.invokeMethod(m, value);	}	}	field.set(modelField, value);	++pos;	}	
counter mandatory fields 

public String unbind(CamelContext camelContext, Map<String, Object> model) throws Exception {	StringBuilder buffer = new StringBuilder();	Map<Integer, List<String>> results = new HashMap<Integer, List<String>>();	ObjectHelper.notNull(this.separator, "The separator has not been instantiated or property not defined in the @CsvRecord annotation");	char separator = ConverterUtils.getCharDelimiter(this.getSeparator());	if (LOG.isDebugEnabled()) {	
separator converted from 

StringBuilder buffer = new StringBuilder();	Map<Integer, List<String>> results = new HashMap<Integer, List<String>>();	ObjectHelper.notNull(this.separator, "The separator has not been instantiated or property not defined in the @CsvRecord annotation");	char separator = ConverterUtils.getCharDelimiter(this.getSeparator());	if (LOG.isDebugEnabled()) {	}	for (Class<?> clazz : models) {	if (model.containsKey(clazz.getName())) {	Object obj = model.get(clazz.getName());	if (LOG.isDebugEnabled()) {	
model object class 

List<String> l = values.get(ii);	if (l == null) {	v.add("");	++idxSize;	continue;	}	if (l.size() >= idx + 1) {	v.add(l.get(idx));	index.put(ii, idx);	if (LOG.isDebugEnabled()) {	
value pos at 

if (l.size() >= idx + 1) {	v.add(l.get(idx));	index.put(ii, idx);	if (LOG.isDebugEnabled()) {	}	} else {	v.add(l.get(0));	index.put(ii, 0);	++idxSize;	if (LOG.isDebugEnabled()) {	
value pos at index 

value = datafield.defaultValue();	}	result = formatString(format, value);	if (datafield.trim()) {	result = result.trim();	}	if (datafield.clip() && result.length() > datafield.length()) {	result = result.substring(0, datafield.length());	}	if (LOG.isDebugEnabled()) {	
value to be formatted position and its formatted value 

}	} else {	result = "";	}	Integer key;	if (isMessageOrdered() && obj != null) {	Integer key1 = sections.get(obj.getClass().getName());	Integer key2 = datafield.position();	Integer keyGenerated = generateKey(key1, key2);	if (LOG.isDebugEnabled()) {	
key generated for section 

private void initCsvRecordParameters() {	if (separator == null) {	for (Class<?> cl : models) {	CsvRecord record = cl.getAnnotation(CsvRecord.class);	Section section = cl.getAnnotation(Section.class);	if (record != null) {	
csv record 

private void initCsvRecordParameters() {	if (separator == null) {	for (Class<?> cl : models) {	CsvRecord record = cl.getAnnotation(CsvRecord.class);	Section section = cl.getAnnotation(Section.class);	if (record != null) {	skipFirstLine = record.skipFirstLine();	
skip first line parameter of the csv 

private void initCsvRecordParameters() {	if (separator == null) {	for (Class<?> cl : models) {	CsvRecord record = cl.getAnnotation(CsvRecord.class);	Section section = cl.getAnnotation(Section.class);	if (record != null) {	skipFirstLine = record.skipFirstLine();	generateHeaderColumnNames = record.generateHeaderColumns();	
generate header column names parameter of the csv 

private void initCsvRecordParameters() {	if (separator == null) {	for (Class<?> cl : models) {	CsvRecord record = cl.getAnnotation(CsvRecord.class);	Section section = cl.getAnnotation(Section.class);	if (record != null) {	skipFirstLine = record.skipFirstLine();	generateHeaderColumnNames = record.generateHeaderColumns();	ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation");	separator = record.separator();	
separator defined for the csv 

if (separator == null) {	for (Class<?> cl : models) {	CsvRecord record = cl.getAnnotation(CsvRecord.class);	Section section = cl.getAnnotation(Section.class);	if (record != null) {	skipFirstLine = record.skipFirstLine();	generateHeaderColumnNames = record.generateHeaderColumns();	ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation");	separator = record.separator();	crlf = record.crlf();	
carriage return defined for the csv 

for (Class<?> cl : models) {	CsvRecord record = cl.getAnnotation(CsvRecord.class);	Section section = cl.getAnnotation(Section.class);	if (record != null) {	skipFirstLine = record.skipFirstLine();	generateHeaderColumnNames = record.generateHeaderColumns();	ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation");	separator = record.separator();	crlf = record.crlf();	messageOrdered = record.isOrdered();	
must csv record be ordered 

Section section = cl.getAnnotation(Section.class);	if (record != null) {	skipFirstLine = record.skipFirstLine();	generateHeaderColumnNames = record.generateHeaderColumns();	ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation");	separator = record.separator();	crlf = record.crlf();	messageOrdered = record.isOrdered();	if (ObjectHelper.isNotEmpty(record.quote())) {	quote = record.quote();	
quoting columns with 

skipFirstLine = record.skipFirstLine();	generateHeaderColumnNames = record.generateHeaderColumns();	ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation");	separator = record.separator();	crlf = record.crlf();	messageOrdered = record.isOrdered();	if (ObjectHelper.isNotEmpty(record.quote())) {	quote = record.quote();	}	quoting = record.quoting();	
csv will be quoted 

generateHeaderColumnNames = record.generateHeaderColumns();	ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation");	separator = record.separator();	crlf = record.crlf();	messageOrdered = record.isOrdered();	if (ObjectHelper.isNotEmpty(record.quote())) {	quote = record.quote();	}	quoting = record.quoting();	autospanLine = record.autospanLine();	
autospan line in last record 

ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation");	separator = record.separator();	crlf = record.crlf();	messageOrdered = record.isOrdered();	if (ObjectHelper.isNotEmpty(record.quote())) {	quote = record.quote();	}	quoting = record.quoting();	autospanLine = record.autospanLine();	allowEmptyStream = record.allowEmptyStream();	
allow empty stream parameter of the csv 

separator = record.separator();	crlf = record.crlf();	messageOrdered = record.isOrdered();	if (ObjectHelper.isNotEmpty(record.quote())) {	quote = record.quote();	}	quoting = record.quoting();	autospanLine = record.autospanLine();	allowEmptyStream = record.allowEmptyStream();	quotingEscaped = record.quotingEscaped();	
escape quote character flag of the csv 

crlf = record.crlf();	messageOrdered = record.isOrdered();	if (ObjectHelper.isNotEmpty(record.quote())) {	quote = record.quote();	}	quoting = record.quoting();	autospanLine = record.autospanLine();	allowEmptyStream = record.allowEmptyStream();	quotingEscaped = record.quotingEscaped();	endWithLineBreak = record.endWithLineBreak();	
end with line break 

========================= camel sample_7458 =========================

protected int poll() throws Exception {	shutdownRunningTask = null;	pendingExchanges = 0;	final String preparedQuery = sqlPrepareStatementStrategy.prepareQuery(resolvedQuery, getEndpoint().isAllowNamedParameters(), null);	
poll 

protected int poll() throws Exception {	shutdownRunningTask = null;	pendingExchanges = 0;	final String preparedQuery = sqlPrepareStatementStrategy.prepareQuery(resolvedQuery, getEndpoint().isAllowNamedParameters(), null);	final PreparedStatementCallback<Integer> callback = new PreparedStatementCallback<Integer>() {	public Integer doInPreparedStatement(PreparedStatement ps) throws SQLException, DataAccessException {	Queue<DataHolder> answer = new LinkedList<DataHolder>();	
executing query 

public int processBatch(Queue<Object> exchanges) throws Exception {	int total = exchanges.size();	if (maxMessagesPerPoll > 0 && total == maxMessagesPerPoll) {	
maximum messages to poll is and there were exactly messages in this poll 

}	try {	if (onConsumeBatchComplete != null) {	int updateCount;	if (namedJdbcTemplate != null && sqlProcessingStrategy instanceof SqlNamedProcessingStrategy) {	SqlNamedProcessingStrategy namedProcessingStrategy = (SqlNamedProcessingStrategy) sqlProcessingStrategy;	updateCount = namedProcessingStrategy.commitBatchComplete(getEndpoint(), namedJdbcTemplate, parameterSource, onConsumeBatchComplete);	} else {	updateCount = sqlProcessingStrategy.commitBatchComplete(getEndpoint(), jdbcTemplate, onConsumeBatchComplete);	}	
onconsumebatchcomplete update count 

========================= camel sample_9016 =========================

public void testSharedThreadPool() throws Exception {	int delta = Thread.activeCount() - before;	
created threads 

========================= camel sample_6619 =========================

protected void initHdfs() {	try {	URL.setURLStreamHandlerFactory(new FsUrlStreamHandlerFactory());	} catch (Throwable e) {	
cannot set urlstreamhandlerfactory due this exception will be ignored 

static Configuration getJAASConfiguration() {	Configuration auth = null;	try {	auth = Configuration.getConfiguration();	
existing jaas configuration 

static Configuration getJAASConfiguration() {	Configuration auth = null;	try {	auth = Configuration.getConfiguration();	} catch (SecurityException e) {	
cannot load existing jaas configuration 

static void setJAASConfiguration(Configuration auth) {	if (auth != null) {	
restoring existing jaas configuration 

static void setJAASConfiguration(Configuration auth) {	if (auth != null) {	try {	Configuration.setConfiguration(auth);	} catch (SecurityException e) {	
cannot restore jaas configuration this exception is ignored 

static void setJAASConfiguration(Configuration auth) {	if (auth != null) {	try {	Configuration.setConfiguration(auth);	} catch (SecurityException e) {	}	} else {	
no jaas configuration to restore 

========================= camel sample_12188 =========================

public Producer createProducer() throws Exception {	
resolve producer dropbox endpoint 

public Producer createProducer() throws Exception {	
resolve producer dropbox attached client 

public Consumer createConsumer(Processor processor) throws Exception {	
resolve consumer dropbox endpoint 

public Consumer createConsumer(Processor processor) throws Exception {	
resolve consumer dropbox attached client 

========================= camel sample_8484 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<HazelcastRingbufferComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-ringbuffer.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-ringbuffer.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_668 =========================

public void start() throws Exception {	if (serializedExecutor == null) {	
starting leadership controller 

public void stop() throws Exception {	
stopping leadership controller 

private void refreshStatusNotLeader() {	
pod is not leader pulling new data from the cluster 

private void refreshStatusNotLeader() {	boolean pulled = lookupNewLeaderInfo();	if (!pulled) {	rescheduleAfterDelay();	return;	}	if (this.latestLeaderInfo.hasEmptyLeader()) {	
the cluster has no leaders trying to acquire the leadership 

private void refreshStatusNotLeader() {	boolean pulled = lookupNewLeaderInfo();	if (!pulled) {	rescheduleAfterDelay();	return;	}	if (this.latestLeaderInfo.hasEmptyLeader()) {	boolean acquired = tryAcquireLeadership();	if (acquired) {	
leadership acquired by current pod with immediate effect 

rescheduleAfterDelay();	return;	}	if (this.latestLeaderInfo.hasEmptyLeader()) {	boolean acquired = tryAcquireLeadership();	if (acquired) {	this.currentState = State.LEADER;	this.serializedExecutor.execute(this::refreshStatus);	return;	} else {	
unable to acquire the leadership it may have been acquired by another pod 

}	if (this.latestLeaderInfo.hasEmptyLeader()) {	boolean acquired = tryAcquireLeadership();	if (acquired) {	this.currentState = State.LEADER;	this.serializedExecutor.execute(this::refreshStatus);	return;	} else {	}	} else if (!this.latestLeaderInfo.hasValidLeader()) {	
leadership has been lost by old owner trying to acquire the leadership 

boolean acquired = tryAcquireLeadership();	if (acquired) {	this.currentState = State.LEADER;	this.serializedExecutor.execute(this::refreshStatus);	return;	} else {	}	} else if (!this.latestLeaderInfo.hasValidLeader()) {	boolean acquired = tryAcquireLeadership();	if (acquired) {	
leadership acquired by current pod 

return;	} else {	}	} else if (!this.latestLeaderInfo.hasValidLeader()) {	boolean acquired = tryAcquireLeadership();	if (acquired) {	this.currentState = State.BECOMING_LEADER;	this.serializedExecutor.execute(this::refreshStatus);	return;	} else {	
unable to acquire the leadership it may have been acquired by another pod 

}	} else if (!this.latestLeaderInfo.hasValidLeader()) {	boolean acquired = tryAcquireLeadership();	if (acquired) {	this.currentState = State.BECOMING_LEADER;	this.serializedExecutor.execute(this::refreshStatus);	return;	} else {	}	} else if (this.latestLeaderInfo.isValidLeader(this.lockConfiguration.getPodName())) {	
leadership is already owned by current pod 

private void refreshStatusBecomingLeader() {	long delay = this.lockConfiguration.getLeaseDurationMillis();	
current pod owns the leadership but it will be effective in seconds 

private void refreshStatusBecomingLeader() {	long delay = this.lockConfiguration.getLeaseDurationMillis();	try {	Thread.sleep(delay);	} catch (InterruptedException e) {	
thread interrupted 

private void refreshStatusBecomingLeader() {	long delay = this.lockConfiguration.getLeaseDurationMillis();	try {	Thread.sleep(delay);	} catch (InterruptedException e) {	}	
current pod is becoming the new leader now 

private void refreshStatusLeader() {	
pod should be the leader pulling new data from the cluster 

private void refreshStatusLeader() {	long timeBeforePulling = System.currentTimeMillis();	boolean pulled = lookupNewLeaderInfo();	if (!pulled) {	rescheduleAfterDelay();	return;	}	if (this.latestLeaderInfo.isValidLeader(this.lockConfiguration.getPodName())) {	
current pod is still the leader 

boolean pulled = lookupNewLeaderInfo();	if (!pulled) {	rescheduleAfterDelay();	return;	}	if (this.latestLeaderInfo.isValidLeader(this.lockConfiguration.getPodName())) {	this.leaderNotifier.refreshLeadership(Optional.of(this.lockConfiguration.getPodName()), timeBeforePulling, this.lockConfiguration.getRenewDeadlineMillis(), this.latestLeaderInfo.getMembers());	rescheduleAfterDelay();	return;	} else {	
current pod has lost the leadership 

private boolean lookupNewLeaderInfo() {	
looking up leadership information 

private boolean lookupNewLeaderInfo() {	ConfigMap configMap;	try {	configMap = pullConfigMap();	} catch (Throwable e) {	
unable to retrieve the current configmap from kubernetes 

private boolean lookupNewLeaderInfo() {	ConfigMap configMap;	try {	configMap = pullConfigMap();	} catch (Throwable e) {	
exception thrown during configmap lookup 

ConfigMap configMap;	try {	configMap = pullConfigMap();	} catch (Throwable e) {	return false;	}	Set<String> members;	try {	members = Objects.requireNonNull(pullClusterMembers(), "Retrieved a null set of members");	} catch (Throwable e) {	
unable to retrieve the list of cluster members from kubernetes 

ConfigMap configMap;	try {	configMap = pullConfigMap();	} catch (Throwable e) {	return false;	}	Set<String> members;	try {	members = Objects.requireNonNull(pullClusterMembers(), "Retrieved a null set of members");	} catch (Throwable e) {	
exception thrown during pod list lookup 

private boolean tryAcquireLeadership() {	
trying to acquire the leadership 

private boolean tryAcquireLeadership() {	ConfigMap configMap = this.latestConfigMap;	Set<String> members = this.latestMembers;	LeaderInfo latestLeaderInfo = this.latestLeaderInfo;	if (latestLeaderInfo == null || members == null) {	
unexpected condition latest leader info or list of members is empty 

private boolean tryAcquireLeadership() {	ConfigMap configMap = this.latestConfigMap;	Set<String> members = this.latestMembers;	LeaderInfo latestLeaderInfo = this.latestLeaderInfo;	if (latestLeaderInfo == null || members == null) {	return false;	} else if (!members.contains(this.lockConfiguration.getPodName())) {	
the list of cluster members does not contain the current pod cannot acquire leadership 

ConfigMap configMap = this.latestConfigMap;	Set<String> members = this.latestMembers;	LeaderInfo latestLeaderInfo = this.latestLeaderInfo;	if (latestLeaderInfo == null || members == null) {	return false;	} else if (!members.contains(this.lockConfiguration.getPodName())) {	return false;	}	LeaderInfo newLeaderInfo = new LeaderInfo(this.lockConfiguration.getGroupName(), this.lockConfiguration.getPodName(), new Date(), members);	if (configMap == null) {	
lock configmap is not present in the kubernetes namespace a new configmap will be created 

if (latestLeaderInfo == null || members == null) {	return false;	} else if (!members.contains(this.lockConfiguration.getPodName())) {	return false;	}	LeaderInfo newLeaderInfo = new LeaderInfo(this.lockConfiguration.getGroupName(), this.lockConfiguration.getPodName(), new Date(), members);	if (configMap == null) {	ConfigMap newConfigMap = ConfigMapLockUtils.createNewConfigMap(this.lockConfiguration.getConfigMapName(), newLeaderInfo);	try {	kubernetesClient.configMaps() .inNamespace(this.lockConfiguration.getKubernetesResourcesNamespaceOrDefault(kubernetesClient)) .create(newConfigMap);	
configmap successfully created 

return false;	}	LeaderInfo newLeaderInfo = new LeaderInfo(this.lockConfiguration.getGroupName(), this.lockConfiguration.getPodName(), new Date(), members);	if (configMap == null) {	ConfigMap newConfigMap = ConfigMapLockUtils.createNewConfigMap(this.lockConfiguration.getConfigMapName(), newLeaderInfo);	try {	kubernetesClient.configMaps() .inNamespace(this.lockConfiguration.getKubernetesResourcesNamespaceOrDefault(kubernetesClient)) .create(newConfigMap);	updateLatestLeaderInfo(newConfigMap, members);	return true;	} catch (Exception ex) {	
unable to create the configmap it may have been created by other cluster members concurrently if the problem persists check if the service account has the right permissions to create it 

return false;	}	LeaderInfo newLeaderInfo = new LeaderInfo(this.lockConfiguration.getGroupName(), this.lockConfiguration.getPodName(), new Date(), members);	if (configMap == null) {	ConfigMap newConfigMap = ConfigMapLockUtils.createNewConfigMap(this.lockConfiguration.getConfigMapName(), newLeaderInfo);	try {	kubernetesClient.configMaps() .inNamespace(this.lockConfiguration.getKubernetesResourcesNamespaceOrDefault(kubernetesClient)) .create(newConfigMap);	updateLatestLeaderInfo(newConfigMap, members);	return true;	} catch (Exception ex) {	
exception while trying to create the configmap 

if (configMap == null) {	ConfigMap newConfigMap = ConfigMapLockUtils.createNewConfigMap(this.lockConfiguration.getConfigMapName(), newLeaderInfo);	try {	kubernetesClient.configMaps() .inNamespace(this.lockConfiguration.getKubernetesResourcesNamespaceOrDefault(kubernetesClient)) .create(newConfigMap);	updateLatestLeaderInfo(newConfigMap, members);	return true;	} catch (Exception ex) {	return false;	}	} else {	
lock configmap already present in the kubernetes namespace checking 

} catch (Exception ex) {	return false;	}	} else {	LeaderInfo leaderInfo = ConfigMapLockUtils.getLeaderInfo(configMap, members, this.lockConfiguration.getGroupName());	boolean canAcquire = !leaderInfo.hasValidLeader();	if (canAcquire) {	try {	ConfigMap updatedConfigMap = ConfigMapLockUtils.getConfigMapWithNewLeader(configMap, newLeaderInfo);	kubernetesClient.configMaps() .inNamespace(this.lockConfiguration.getKubernetesResourcesNamespaceOrDefault(kubernetesClient)) .withName(this.lockConfiguration.getConfigMapName()) .lockResourceVersion(configMap.getMetadata().getResourceVersion()) .replace(updatedConfigMap);	
configmap successfully updated 

} else {	LeaderInfo leaderInfo = ConfigMapLockUtils.getLeaderInfo(configMap, members, this.lockConfiguration.getGroupName());	boolean canAcquire = !leaderInfo.hasValidLeader();	if (canAcquire) {	try {	ConfigMap updatedConfigMap = ConfigMapLockUtils.getConfigMapWithNewLeader(configMap, newLeaderInfo);	kubernetesClient.configMaps() .inNamespace(this.lockConfiguration.getKubernetesResourcesNamespaceOrDefault(kubernetesClient)) .withName(this.lockConfiguration.getConfigMapName()) .lockResourceVersion(configMap.getMetadata().getResourceVersion()) .replace(updatedConfigMap);	updateLatestLeaderInfo(updatedConfigMap, members);	return true;	} catch (Exception ex) {	
unable to update the lock configmap to set leadership information 

} else {	LeaderInfo leaderInfo = ConfigMapLockUtils.getLeaderInfo(configMap, members, this.lockConfiguration.getGroupName());	boolean canAcquire = !leaderInfo.hasValidLeader();	if (canAcquire) {	try {	ConfigMap updatedConfigMap = ConfigMapLockUtils.getConfigMapWithNewLeader(configMap, newLeaderInfo);	kubernetesClient.configMaps() .inNamespace(this.lockConfiguration.getKubernetesResourcesNamespaceOrDefault(kubernetesClient)) .withName(this.lockConfiguration.getConfigMapName()) .lockResourceVersion(configMap.getMetadata().getResourceVersion()) .replace(updatedConfigMap);	updateLatestLeaderInfo(updatedConfigMap, members);	return true;	} catch (Exception ex) {	
error received during configmap lock replace 

if (canAcquire) {	try {	ConfigMap updatedConfigMap = ConfigMapLockUtils.getConfigMapWithNewLeader(configMap, newLeaderInfo);	kubernetesClient.configMaps() .inNamespace(this.lockConfiguration.getKubernetesResourcesNamespaceOrDefault(kubernetesClient)) .withName(this.lockConfiguration.getConfigMapName()) .lockResourceVersion(configMap.getMetadata().getResourceVersion()) .replace(updatedConfigMap);	updateLatestLeaderInfo(updatedConfigMap, members);	return true;	} catch (Exception ex) {	return false;	}	} else {	
another pod is the current leader and it is still active 

private void updateLatestLeaderInfo(ConfigMap configMap, Set<String> members) {	
updating internal status about the current leader 

private void updateLatestLeaderInfo(ConfigMap configMap, Set<String> members) {	this.latestConfigMap = configMap;	this.latestMembers = members;	this.latestLeaderInfo = ConfigMapLockUtils.getLeaderInfo(configMap, members, this.lockConfiguration.getGroupName());	
current leader info 

========================= camel sample_13263 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	context().setTracing(true);	return new RouteBuilder() {	public void configure() throws Exception {	
building routes 

========================= camel sample_14119 =========================

public void process(Exchange exchange) throws Exception {	Account accountInfo = getEndpoint().getDigitalOceanClient().getAccountInfo();	
account 

========================= camel sample_8892 =========================

protected void doStart() throws Exception {	super.doStart();	if (client == null) {	if (configuration.isLocal()) {	
starting local elasticsearch server 

protected void doStart() throws Exception {	super.doStart();	if (client == null) {	if (configuration.isLocal()) {	} else {	
joining elasticsearch cluster 

protected void doStop() throws Exception {	if (closeClient) {	if (configuration.isLocal()) {	
stopping local elasticsearch server 

protected void doStop() throws Exception {	if (closeClient) {	if (configuration.isLocal()) {	} else {	
leaving elasticsearch cluster 

========================= camel sample_7634 =========================

public void testConfiguration() throws Exception {	Component component = context().getComponent(componentName);	ComponentConfiguration configuration = component.createComponentConfiguration();	SortedMap<String, ParameterConfiguration> parameterConfigurationMap = configuration.getParameterConfigurationMap();	if (verbose) {	Set<Map.Entry<String, ParameterConfiguration>> entries = parameterConfigurationMap.entrySet();	for (Map.Entry<String, ParameterConfiguration> entry : entries) {	String name = entry.getKey();	ParameterConfiguration config = entry.getValue();	
has name with type 

========================= camel sample_6926 =========================

private Producer createHttpProducer(CamelContext camelContext, Swagger swagger, Operation operation, String host, String verb, String path, String queryParameters, String consumes, String produces, String componentName, Map<String, Object> parameters) throws Exception {	
using swagger operation with 

private Producer createHttpProducer(CamelContext camelContext, Swagger swagger, Operation operation, String host, String verb, String path, String queryParameters, String consumes, String produces, String componentName, Map<String, Object> parameters) throws Exception {	RestProducerFactory factory = (RestProducerFactory) parameters.remove("restProducerFactory");	if (factory != null) {	
using restproducerfactory 

========================= camel sample_17365 =========================

public static String getTextlineBody(Object body, Exchange exchange, TextLineDelimiter delimiter, boolean autoAppendDelimiter) throws NoTypeConversionAvailableException {	String s = exchange.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body);	if (autoAppendDelimiter) {	if (TextLineDelimiter.LINE.equals(delimiter)) {	if (!s.endsWith("\n")) {	
auto appending missing newline delimiter to body 

public static String getTextlineBody(Object body, Exchange exchange, TextLineDelimiter delimiter, boolean autoAppendDelimiter) throws NoTypeConversionAvailableException {	String s = exchange.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body);	if (autoAppendDelimiter) {	if (TextLineDelimiter.LINE.equals(delimiter)) {	if (!s.endsWith("\n")) {	s = s + "\n";	}	} else {	if (!s.endsWith("\u0000")) {	
auto appending missing null delimiter to body 

public static void close(Channel channel) {	if (channel != null) {	channel.close().addListener(new ChannelFutureListener() {	public void operationComplete(ChannelFuture future) {	
channel closed 

========================= camel sample_10224 =========================

InputStream input = exchange.getIn().getBody(InputStream.class);	List<String> argsList = null;	if (isListOfStrings(args)) {	argsList = (List<String>) args;	}	if (argsList == null) {	String s = endpoint.getArgs();	if (args != null) {	s = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, args);	}	
parsing argument string to a list 

========================= camel sample_12219 =========================

public PullRequestCommentConsumer(GitHubEndpoint endpoint, Processor processor) throws Exception {	super(endpoint, processor);	Registry registry = endpoint.getCamelContext().getRegistry();	Object service = registry.lookupByName(GitHubConstants.GITHUB_PULL_REQUEST_SERVICE);	if (service != null) {	
using pullrequestservice found in registry 

pullRequestService = new PullRequestService();	}	initService(pullRequestService);	service = registry.lookupByName(GitHubConstants.GITHUB_ISSUE_SERVICE);	if (service != null) {	issueService = (IssueService) service;	} else {	issueService = new IssueService();	}	initService(issueService);	
github pullrequestcommentconsumer indexing current pull request comments 

========================= camel sample_14267 =========================

public Exchange dispatchSync(RouteboxEndpoint endpoint, Exchange exchange) throws Exception {	URI dispatchUri;	Exchange reply;	if (LOG.isDebugEnabled()) {	
dispatching exchange to endpoint 

public Exchange dispatchAsync(RouteboxEndpoint endpoint, Exchange exchange) throws Exception {	URI dispatchUri;	Exchange reply;	if (LOG.isDebugEnabled()) {	
dispatching exchange to endpoint 

throw new CamelExchangeException("No matching entry found in Dispatch Map for ROUTE_DISPATCH_KEY: " + key, exchange);	}	} else {	dispatchUri = endpoint.getConfig().getDispatchStrategy().selectDestinationUri(consumerUris, exchange);	if (dispatchUri == null) {	throw new CamelExchangeException("No matching inner routes found for Operation", exchange);	}	}	}	if (LOG.isDebugEnabled()) {	
dispatch uri set to 

========================= camel sample_14637 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<DirectComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.direct.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.direct.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_845 =========================

setProperty(factory, XMLInputFactory.IS_NAMESPACE_AWARE, nsAware);	setProperty(factory, XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);	setProperty(factory, XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, Boolean.FALSE);	setProperty(factory, XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);	factory.setXMLResolver(new XMLResolver() {	public Object resolveEntity(String publicID, String systemID, String baseURI, String namespace) throws XMLStreamException {	throw new XMLStreamException("Reading external entities is disabled");	}	});	if (isWoodstox(factory)) {	
created woodstox xmlinputfactory 

setProperty(factory, XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);	setProperty(factory, XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, Boolean.FALSE);	setProperty(factory, XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);	factory.setXMLResolver(new XMLResolver() {	public Object resolveEntity(String publicID, String systemID, String baseURI, String namespace) throws XMLStreamException {	throw new XMLStreamException("Reading external entities is disabled");	}	});	if (isWoodstox(factory)) {	} else {	
created xmlinputfactory domsource domresult may have issues with we suggest using woodstox 

========================= camel sample_4223 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<BlobServiceComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.azure-blob.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.azure-blob.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1021 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SlackComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.slack.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.slack.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_516 =========================

public void process(Exchange exchange) throws Exception {	String payload = exchange.getIn().getBody(String.class);	
applying schematron validation on payload 

public void process(Exchange exchange) throws Exception {	String payload = exchange.getIn().getBody(String.class);	String report = SchematronProcessorFactory.newScehamtronEngine(endpoint.getRules()).validate(payload);	
schematron validation report 

public void process(Exchange exchange) throws Exception {	String payload = exchange.getIn().getBody(String.class);	String report = SchematronProcessorFactory.newScehamtronEngine(endpoint.getRules()).validate(payload);	String status = getValidationStatus(report);	
schematron validation status 

========================= camel sample_11989 =========================

protected void assertExpression(String expressionText, String expectedValue, String orThisExpectedValue) {	Language language = assertResolveLanguage(getLanguageName());	Expression expression = language.createExpression(expressionText);	assertNotNull("No Expression could be created for text: " + expressionText + " language: " + language, expression);	Object value;	if (expectedValue != null) {	value = expression.evaluate(exchange, expectedValue.getClass());	} else {	value = expression.evaluate(exchange, Object.class);	}	
evaluated expression on exchange result 

========================= camel sample_6834 =========================

public void appendBuilders(List<RoutesBuilder> list) {	Map<String, RoutesBuilder> beans = BlueprintContainerRegistry.lookupByType(blueprintContainer, RoutesBuilder.class, includeNonSingletons);	for (Entry<String, RoutesBuilder> entry : beans.entrySet()) {	String key = entry.getKey();	Object bean = entry.getValue();	
found routebuilder with id 

public void appendBuilders(List<RoutesBuilder> list) {	Map<String, RoutesBuilder> beans = BlueprintContainerRegistry.lookupByType(blueprintContainer, RoutesBuilder.class, includeNonSingletons);	for (Entry<String, RoutesBuilder> entry : beans.entrySet()) {	String key = entry.getKey();	Object bean = entry.getValue();	if (shouldIgnoreBean(bean)) {	
ignoring routebuilder id 

public void appendBuilders(List<RoutesBuilder> list) {	Map<String, RoutesBuilder> beans = BlueprintContainerRegistry.lookupByType(blueprintContainer, RoutesBuilder.class, includeNonSingletons);	for (Entry<String, RoutesBuilder> entry : beans.entrySet()) {	String key = entry.getKey();	Object bean = entry.getValue();	if (shouldIgnoreBean(bean)) {	continue;	}	if (!isFilteredClass(bean)) {	if (LOG.isDebugEnabled()) {	
ignoring filtered routebuilder id as class 

Object bean = entry.getValue();	if (shouldIgnoreBean(bean)) {	continue;	}	if (!isFilteredClass(bean)) {	if (LOG.isDebugEnabled()) {	}	continue;	}	if (LOG.isDebugEnabled()) {	
adding instantiated routebuilder id as class 

========================= camel sample_8129 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<NatsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.nats.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.nats.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_795 =========================

protected void doStop() throws Exception {	
closing jgroups channel 

public void connect() throws Exception {	connectCount.incrementAndGet();	
connecting jgroups channel 

public void disconnect() {	if (connectCount.decrementAndGet() == 0) {	
disconnecting jgroups channel 

========================= camel sample_16935 =========================

public Producer createProducer() throws Exception {	
resolve producer atmos endpoint 

public Producer createProducer() throws Exception {	
resolve producer atmos attached client 

public Consumer createConsumer(Processor processor) throws Exception {	
resolve consumer atmos endpoint 

public Consumer createConsumer(Processor processor) throws Exception {	
resolve consumer atmos attached client 

========================= camel sample_7233 =========================

public void connect() throws Exception {	String uri = getHttpUri().toASCIIString();	
connecting to 

protected void doStop() throws Exception {	if (websocket != null && websocket.isOpen()) {	if (LOG.isDebugEnabled()) {	
disconnecting from 

public void onOpen(WebSocket websocket) {	
websocket opened 

public void onClose(WebSocket websocket) {	
websocket closed reconnecting 

public void onClose(WebSocket websocket) {	try {	reConnect();	} catch (Exception e) {	
error re connecting to websocket 

public void onError(Throwable t) {	
websocket on error 

public void onMessage(byte[] message) {	
received message 

public void onMessage(String message) {	
received message 

========================= camel sample_13721 =========================

public void testRouteboxSedaAsyncRequests() throws Exception {	template = new DefaultProducerTemplate(context);	template.start();	context.addRoutes(new RouteBuilder() {	public void configure() {	from(routeboxUri) .to("log:Routes operation performed?showAll=true");	}	});	context.start();	
beginning test testrouteboxsedaasyncrequests 

context.addRoutes(new RouteBuilder() {	public void configure() {	from(routeboxUri) .to("log:Routes operation performed?showAll=true");	}	});	context.start();	Book book = new Book("Sir Arthur Conan Doyle", "The Adventures of Sherlock Holmes");	String response = sendAddToCatalogRequest(template, routeboxUri, "addToCatalog", book);	assertEquals("Book with Author " + book.getAuthor() + " and title " + book.getTitle() + " added to Catalog", response);	book = sendFindBookRequest(template, routeboxUri, "findBook", "Sir Arthur Conan Doyle");	
received book with author and title 

public void configure() {	from(routeboxUri) .to("log:Routes operation performed?showAll=true");	}	});	context.start();	Book book = new Book("Sir Arthur Conan Doyle", "The Adventures of Sherlock Holmes");	String response = sendAddToCatalogRequest(template, routeboxUri, "addToCatalog", book);	assertEquals("Book with Author " + book.getAuthor() + " and title " + book.getTitle() + " added to Catalog", response);	book = sendFindBookRequest(template, routeboxUri, "findBook", "Sir Arthur Conan Doyle");	assertEquals("The Adventures of Sherlock Holmes", book.getTitle());	
completed test testrouteboxsedaasyncrequests 

========================= camel sample_14621 =========================

hzInstance = Hazelcast.newHazelcastInstance(config);	} else if (config != null) {	if (ObjectHelper.isNotEmpty(config.getInstanceName())) {	hzInstance = Hazelcast.getOrCreateHazelcastInstance(config);	} else {	hzInstance = Hazelcast.newHazelcastInstance(config);	}	}	if (hzInstance != null) {	if (this.customHazelcastInstances.add(hzInstance)) {	
add managed hz instance 

if (hazelcastInstance == null && config == null) {	config = new XmlClientConfigBuilder().build();	config.getProperties().setProperty("hazelcast.version.check.enabled", "false");	config.getProperties().setProperty("hazelcast.phone.home.enabled", "false");	hzInstance = HazelcastClient.newHazelcastClient(config);	} else if (config != null) {	hzInstance = HazelcastClient.newHazelcastClient(config);	}	if (hzInstance != null) {	if (this.customHazelcastInstances.add(hzInstance)) {	
add managed hz instance 

========================= camel sample_9542 =========================

public TagConsumer(GitHubEndpoint endpoint, Processor processor) throws Exception {	super(endpoint, processor);	
github tagconsumer indexing current tags 

========================= camel sample_14271 =========================

protected void initChannel(Channel ch) throws Exception {	ChannelPipeline channelPipeline = ch.pipeline();	SslHandler sslHandler = configureClientSSLOnDemand();	if (sslHandler != null) {	
client ssl handler configured and added to the channelpipeline 

List<ChannelHandler> encoders = producer.getConfiguration().getEncoders();	for (int x = 0; x < encoders.size(); x++) {	ChannelHandler encoder = encoders.get(x);	if (encoder instanceof ChannelHandlerFactory) {	encoder = ((ChannelHandlerFactory) encoder).newChannelHandler();	}	addToPipeline("encoder-" + x, channelPipeline, encoder);	}	if (producer.getConfiguration().getRequestTimeout() > 0) {	if (LOG.isTraceEnabled()) {	
using request timeout millis 

}	addToPipeline("encoder-" + x, channelPipeline, encoder);	}	if (producer.getConfiguration().getRequestTimeout() > 0) {	if (LOG.isTraceEnabled()) {	}	ChannelHandler timeout = new ReadTimeoutHandler(producer.getConfiguration().getRequestTimeout(), TimeUnit.MILLISECONDS);	addToPipeline("timeout", channelPipeline, timeout);	}	addToPipeline("handler", channelPipeline, new ClientChannelHandler(producer));	
created channelpipeline 

private SSLContext createSSLContext(NettyProducer producer) throws Exception {	NettyConfiguration configuration = producer.getConfiguration();	if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(producer.getContext());	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	
keystorefile is null 

if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(producer.getContext());	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	
truststorefile is null 

}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(producer.getContext());	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	}	if (configuration.getPassphrase().toCharArray() == null) {	
passphrase is null 

========================= camel sample_10232 =========================

private OutputStream resolveStreamFromUrl() throws IOException {	String u = endpoint.getUrl();	ObjectHelper.notEmpty(u, "url");	
about to write to url 

private OutputStream resolveStreamFromFile() throws IOException {	String fileName = endpoint.getFileName();	ObjectHelper.notEmpty(fileName, "fileName");	
about to write to file 

private void delay(long ms) throws InterruptedException {	if (ms == 0) {	return;	}	
delaying millis 

private void writeToStream(OutputStream outputStream, Exchange exchange) throws IOException, CamelExchangeException {	Object body = exchange.getIn().getBody();	if (body == null) {	
body is null cannot write it to the stream 

private void writeToStream(OutputStream outputStream, Exchange exchange) throws IOException, CamelExchangeException {	Object body = exchange.getIn().getBody();	if (body == null) {	return;	}	if (!(body instanceof String)) {	byte[] bytes = exchange.getIn().getBody(byte[].class);	if (bytes != null) {	
writing as byte to 

if (bytes != null) {	outputStream.write(bytes);	return;	}	}	String s = exchange.getIn().getMandatoryBody(String.class);	Charset charset = endpoint.getCharset();	Writer writer = new OutputStreamWriter(outputStream, charset);	BufferedWriter bw = IOHelper.buffered(writer);	if (LOG.isDebugEnabled()) {	
writing as text to using encoding 

if ("out".equals(uri)) {	outputStream = System.out;	} else if ("err".equals(uri)) {	outputStream = System.err;	} else if ("file".equals(uri)) {	outputStream = resolveStreamFromFile();	} else if ("url".equals(uri)) {	outputStream = resolveStreamFromUrl();	}	count.set(outputStream == null ? 0 : endpoint.getAutoCloseCount());	
opened stream 

private void openStream(final Exchange exchange) throws Exception {	if (outputStream != null) {	return;	}	if ("header".equals(uri)) {	outputStream = resolveStreamFromHeader(exchange.getIn().getHeader("stream"), exchange);	
opened stream 

return;	}	boolean systemStream = outputStream == System.out || outputStream == System.err;	boolean headerStream = "header".equals(uri);	boolean reachedLimit = endpoint.getAutoCloseCount() > 0 && count.decrementAndGet() <= 0;	boolean isDone = endpoint.isCloseOnDone() && isDone(exchange);	boolean expiredStream = force || headerStream || isDone || reachedLimit;	if (!systemStream && expiredStream) {	outputStream.close();	outputStream = null;	
closed stream 

========================= camel sample_11970 =========================

public void done(boolean doneSync) {	try {	NettyHttpMessage nettyMessage = exchange.hasOut() ? exchange.getOut(NettyHttpMessage.class) : exchange.getIn(NettyHttpMessage.class);	if (nettyMessage != null) {	HttpResponse response = nettyMessage.getHttpResponse();	if (response != null) {	String actualUrl = exchange.getIn().getHeader(Exchange.HTTP_URL, String.class);	int code = response.getStatus() != null ? response.getStatus().getCode() : -1;	
http responsecode 

========================= camel sample_8353 =========================

public void run() {	try {	
waiting for request 

public void run() {	try {	Exchange request = consumer.receive("jms:queue:foo", 5000);	
got request sending reply 

========================= camel sample_7049 =========================

public static void assertInMessageBodyEquals(Exchange exchange, Object expected) throws InvalidPayloadException {	assertNotNull("Should have a response exchange!", exchange);	Object actual;	if (expected == null) {	actual = exchange.getIn().getMandatoryBody();	assertEquals("in body of: " + exchange, expected, actual);	} else {	actual = exchange.getIn().getMandatoryBody(expected.getClass());	}	assertEquals("in body of: " + exchange, expected, actual);	
received response with in 

public static void assertOutMessageBodyEquals(Exchange exchange, Object expected) throws InvalidPayloadException {	assertNotNull("Should have a response exchange!", exchange);	Object actual;	if (expected == null) {	actual = exchange.getOut().getMandatoryBody();	assertEquals("output body of: " + exchange, expected, actual);	} else {	actual = exchange.getOut().getMandatoryBody(expected.getClass());	}	assertEquals("output body of: " + exchange, expected, actual);	
received response with out 

public static Object assertExpression(Expression expression, Exchange exchange, Object expected) {	Object value;	if (expected != null) {	value = expression.evaluate(exchange, expected.getClass());	} else {	value = expression.evaluate(exchange, Object.class);	}	
evaluated expression on exchange result 

public static void assertPredicateDoesNotMatch(Predicate predicate, Exchange exchange) {	try {	PredicateAssertHelper.assertMatches(predicate, "Predicate should match: ", exchange);	} catch (AssertionError e) {	
caught expected assertion error 

public static boolean assertPredicate(final Predicate predicate, Exchange exchange, boolean expected) {	if (expected) {	PredicateAssertHelper.assertMatches(predicate, "Predicate failed: ", exchange);	}	boolean value = predicate.matches(exchange);	
evaluated predicate on exchange result 

========================= camel sample_1467 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<AtomComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.atom.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.atom.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1037 =========================

public static ByteBuffer toByteBuffer(String value, Exchange exchange) {	byte[] bytes = null;	if (exchange != null) {	String charsetName = exchange.getProperty(Exchange.CHARSET_NAME, String.class);	if (charsetName != null) {	try {	bytes = value.getBytes(charsetName);	} catch (UnsupportedEncodingException e) {	
cannot convert the byte to string with the charset 

========================= camel sample_4235 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<DataSetComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.dataset.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.dataset.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_853 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<CsvDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.csv.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.csv.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_783 =========================

protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {	String cacheKey = extractCacheKeyFromUri(uri);	if (endpointCache.containsKey(cacheKey)) {	
using cached endpoint for uri 

protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {	String cacheKey = extractCacheKeyFromUri(uri);	if (endpointCache.containsKey(cacheKey)) {	return endpointCache.get(cacheKey);	}	
creating new endpoint for uri 

========================= camel sample_12599 =========================

public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {	if (!isStarted()) {	throw new IllegalStateException("The endpoint is not active: " + getEndpoint().getEndpointUri());	}	BeanInvocation invocation = new BeanInvocation(method, args);	Exchange exchange = getEndpoint().createExchange();	exchange.getIn().setBody(invocation);	try {	
invoking with args 

========================= camel sample_9391 =========================

public void testChoiceSimple() throws InterruptedException {	template.setDefaultEndpointUri("direct:choice-simple");	execute(20000);	resetMock(count);	StopWatch watch = new StopWatch();	execute(count);	assertMockEndpointsSatisfied();	
ran tests in ms 

public void testChoiceExpression() throws InterruptedException {	template.setDefaultEndpointUri("direct:choice-expression");	execute(20000);	resetMock(count);	StopWatch watch = new StopWatch();	execute(count);	assertMockEndpointsSatisfied();	
ran tests in ms 

public void testFilterSimple() throws InterruptedException {	template.setDefaultEndpointUri("direct:filter-simple");	execute(20000);	resetMock(count);	StopWatch watch = new StopWatch();	execute(count);	assertMockEndpointsSatisfied();	
ran tests in ms 

public void testFilterExpression() throws InterruptedException {	template.setDefaultEndpointUri("direct:filter-expression");	execute(20000);	resetMock(count);	StopWatch watch = new StopWatch();	execute(count);	assertMockEndpointsSatisfied();	
ran tests in ms 

========================= camel sample_6434 =========================

public LdapProducer(LdapEndpoint endpoint, String remaining, String base, int scope, Integer pageSize, String returnedAttributes) throws Exception {	super(endpoint);	this.remaining = remaining;	this.searchBase = base;	this.pageSize = pageSize;	this.searchControls = new SearchControls();	this.searchControls.setSearchScope(scope);	if (returnedAttributes != null) {	String returnedAtts[] = returnedAttributes.split(",");	if (log.isDebugEnabled()) {	
setting returning attributes to searchcontrols 

private List<SearchResult> pagedSearch(LdapContext ldapContext, String searchFilter) throws Exception {	List<SearchResult> data = new ArrayList<SearchResult>();	log.trace("Using paged ldap search, pageSize={}", pageSize);	Control[] requestControls = new Control[]{new PagedResultsControl(pageSize, Control.CRITICAL)};	ldapContext.setRequestControls(requestControls);	do {	List<SearchResult> pageResult = simpleSearch(ldapContext, searchFilter);	data.addAll(pageResult);	
page returned entries 

private List<SearchResult> pagedSearch(LdapContext ldapContext, String searchFilter) throws Exception {	List<SearchResult> data = new ArrayList<SearchResult>();	log.trace("Using paged ldap search, pageSize={}", pageSize);	Control[] requestControls = new Control[]{new PagedResultsControl(pageSize, Control.CRITICAL)};	ldapContext.setRequestControls(requestControls);	do {	List<SearchResult> pageResult = simpleSearch(ldapContext, searchFilter);	data.addAll(pageResult);	} while (prepareNextPage(ldapContext));	if (log.isDebugEnabled()) {	
found a total of entries for ldap filter 

========================= camel sample_12126 =========================

public void handleResult(XmlRpcRequest pRequest, Object pResult) {	
get the response 

public void handleError(XmlRpcRequest pRequest, Throwable pError) {	
get the error 

========================= camel sample_17324 =========================

context.setName("context-" + id);	context.addService(service);	context.addRoutes(new RouteBuilder() {	public void configure() throws Exception {	from("master:zk:timer:master?delay=1s&period=1s") .routeId("route-" + id) .log("From ${routeId}") .process(e -> contextLatch.countDown());	}	});	Thread.sleep(ThreadLocalRandom.current().nextInt(500));	context.start();	contextLatch.await();	
shutting down node 

========================= camel sample_12608 =========================

public void execute() {	BatchPutAttributesRequest request = new BatchPutAttributesRequest() .withDomainName(determineDomainName()) .withItems(determineReplaceableItems());	
sending request for exchange 

public void execute() {	BatchPutAttributesRequest request = new BatchPutAttributesRequest() .withDomainName(determineDomainName()) .withItems(determineReplaceableItems());	this.sdbClient.batchPutAttributes(request);	
request sent 

========================= camel sample_8754 =========================

xcode = readNext();	switch (xcode) {	case XMLStreamConstants.START_ELEMENT: depth++;	QName name = reader.getName();	if (LOG.isTraceEnabled()) {	LOG.trace("se={}; depth={}; trackdepth={}", new Object[]{name, depth, trackdepth});	}	String token = getCurrentText();	if (!compliant) {	if (token != null && token.startsWith("<") && !token.startsWith("<?")) {	
xmlstreamreader not supporting location 

========================= camel sample_5166 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<DdbStreamComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-ddbstream.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-ddbstream.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1125 =========================

public void startThriftClient() throws IOException, TTransportException {	if (transport == null) {	
connecting to the thrift server on port 

public void stopThriftClient() throws Exception {	if (transport != null) {	transport.close();	transport = null;	
connection to the thrift server closed 

public void testCalculateMethodInvocation() throws Exception {	CountDownLatch latch = new CountDownLatch(1);	Work work = new Work(THRIFT_TEST_NUM1, THRIFT_TEST_NUM2, Operation.MULTIPLY);	thriftClient.calculate(1, work, new AsyncMethodCallback<Integer>() {	public void onComplete(Integer response) {	calculateResult = response;	latch.countDown();	}	public void onError(Exception exception) {	
Exception 

public void testVoidMethodInvocation() throws Exception {	CountDownLatch latch = new CountDownLatch(1);	thriftClient.ping(new AsyncMethodCallback<Void>() {	public void onComplete(Void response) {	pingResult = 0;	latch.countDown();	}	public void onError(Exception exception) {	
Exception 

public void testOneWayMethodInvocation() throws Exception {	CountDownLatch latch = new CountDownLatch(1);	thriftClient.zip(new AsyncMethodCallback<Void>() {	public void onComplete(Void response) {	zipResult = 0;	latch.countDown();	}	public void onError(Exception exception) {	
Exception 

public void testAllTypesMethodInvocation() throws Exception {	
thrift method with all possile types async test start 

public void testAllTypesMethodInvocation() throws Exception {	final CountDownLatch latch = new CountDownLatch(1);	thriftClient.alltypes(true, (byte)THRIFT_TEST_NUM1, (short)THRIFT_TEST_NUM1, (int)THRIFT_TEST_NUM1, (long)THRIFT_TEST_NUM1, (double)THRIFT_TEST_NUM1, "empty", ByteBuffer.allocate(10), new Work(THRIFT_TEST_NUM1, THRIFT_TEST_NUM2, Operation.MULTIPLY), new ArrayList<Integer>(), new HashSet<String>(), new HashMap<String, Long>(), new AsyncMethodCallback<Integer>() {	public void onComplete(Integer response) {	allTypesResult = response;	latch.countDown();	}	public void onError(Exception exception) {	
Exception 

public void testEchoMethodInvocation() throws Exception {	CountDownLatch latch = new CountDownLatch(1);	Work work = new Work(THRIFT_TEST_NUM1, THRIFT_TEST_NUM2, Operation.MULTIPLY);	thriftClient.echo(work, new AsyncMethodCallback<Work>() {	public void onComplete(Work response) {	echoResult = response;	latch.countDown();	}	public void onError(Exception exception) {	
Exception 

========================= camel sample_13019 =========================

try {	if (localMember.isLeader()) {	LOGGER.trace("Holding the lock on file {} (lock={})", path, lock);	return;	}	synchronized (FileLockClusterView.this) {	if (lock != null) {	LOGGER.info("Lock on file {} lost (lock={})", path, lock);	fireLeadershipChangedEvent(Optional.empty());	}	
try to acquire a lock on 

if (lock != null) {	LOGGER.info("Lock on file {} lost (lock={})", path, lock);	fireLeadershipChangedEvent(Optional.empty());	}	lock = null;	lock = channel.tryLock();	if (lock != null) {	LOGGER.info("Lock on file {} acquired (lock={})", path, lock);	fireLeadershipChangedEvent(Optional.of(localMember));	} else {	
lock on file not acquired 

}	lock = null;	lock = channel.tryLock();	if (lock != null) {	LOGGER.info("Lock on file {} acquired (lock={})", path, lock);	fireLeadershipChangedEvent(Optional.of(localMember));	} else {	}	}	} catch (OverlappingFileLockException e) {	
lock on file not acquired 

========================= camel sample_4777 =========================

public FileConsumer createConsumer(Processor processor) throws Exception {	ObjectHelper.notNull(operations, "operations");	ObjectHelper.notNull(file, "file");	if (!file.exists() && !file.isDirectory()) {	if (isAutoCreate()) {	
creating non existing starting directory 

public FileConsumer createConsumer(Processor processor) throws Exception {	ObjectHelper.notNull(operations, "operations");	ObjectHelper.notNull(file, "file");	if (!file.exists() && !file.isDirectory()) {	if (isAutoCreate()) {	boolean absolute = FileUtil.isAbsolute(file);	boolean created = operations.buildDirectory(file.getPath(), absolute);	if (!created) {	
cannot auto create starting directory 

}	FileConsumer result = newFileConsumer(processor, operations);	if (isDelete() && getMove() != null) {	throw new IllegalArgumentException("You cannot set both delete=true and move options");	}	if (isNoop() && !isIdempotentSet()) {	log.info("Endpoint is configured with noop=true so forcing endpoint to be idempotent as well");	setIdempotent(true);	}	if (isIdempotentSet() && isIdempotent() && idempotentRepository == null) {	
using default memory based idempotent repository with cache max size 

public PollingConsumer createPollingConsumer() throws Exception {	ObjectHelper.notNull(operations, "operations");	ObjectHelper.notNull(file, "file");	if (log.isDebugEnabled()) {	
creating genericfilepollingconsumer with queuesize blockwhenfull blocktimeout 

========================= camel sample_4798 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<CMComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.cm-sms.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.cm-sms.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1060 =========================

private Object unmarshal(CMSEnvelopedDataParser parser, Exchange exchange) throws Exception {	
decrypting cms enveloped data started 

}	Object result;	try {	result = transformToStreamCacheOrByteArray(exchange, is);	} finally {	IOHelper.close(is);	}	if (LOG.isDebugEnabled()) {	AttributeTable unprotectedAttsTable = parser.getUnprotectedAttributes();	if (unprotectedAttsTable != null) {	
unprotected attributes size 

try {	result = transformToStreamCacheOrByteArray(exchange, is);	} finally {	IOHelper.close(is);	}	if (LOG.isDebugEnabled()) {	AttributeTable unprotectedAttsTable = parser.getUnprotectedAttributes();	if (unprotectedAttsTable != null) {	Hashtable<String, Attribute> unprotectedAtts = unprotectedAttsTable.toHashtable();	if (unprotectedAtts != null) {	
unprotected attributes 

private Object transformToStreamCacheOrByteArray(Exchange exchange, InputStream is) throws CryptoCmsException {	OutputStreamBuilder output = OutputStreamBuilder.withExchange(exchange);	try {	if (is != null) {	try {	IOHelper.copy(is, output);	} finally {	IOHelper.close(is);	}	}	
cms enveloped data decryption successful 

========================= camel sample_11531 =========================

public List<String> getSignatureList() throws MojoExecutionException {	Map<String, String> result = new HashMap<String, String>();	final Pattern packagePatterns = Pattern.compile(excludePackages);	final Pattern classPatterns = (excludeClasses != null) ? Pattern.compile(excludeClasses) : null;	final Pattern includeMethodPatterns = (includeMethods != null) ? Pattern.compile(includeMethods) : null;	final Pattern excludeMethodPatterns = (excludeMethods != null) ? Pattern.compile(excludeMethods) : null;	for (Class<?> aClass = getProxyType();	aClass != null && !packagePatterns.matcher(aClass.getPackage().getName()).matches() && (classPatterns == null || !classPatterns.matcher(aClass.getSimpleName()).matches());	aClass = aClass.getSuperclass()) {	
processing 

final Pattern includeMethodPatterns = (includeMethods != null) ? Pattern.compile(includeMethods) : null;	final Pattern excludeMethodPatterns = (excludeMethods != null) ? Pattern.compile(excludeMethods) : null;	for (Class<?> aClass = getProxyType();	aClass != null && !packagePatterns.matcher(aClass.getPackage().getName()).matches() && (classPatterns == null || !classPatterns.matcher(aClass.getSimpleName()).matches());	aClass = aClass.getSuperclass()) {	final String javaDocPath = aClass.getName().replaceAll("\\.", "/").replace('$', '.') + ".html";	InputStream inputStream = null;	try {	inputStream = getProjectClassLoader().getResourceAsStream(javaDocPath);	if (inputStream == null) {	
javadoc not found on classpath for 

========================= camel sample_107 =========================

protected void doStop() throws Exception {	super.doStop();	if (atomix != null) {	
shutdown atomix client 

private AtomixClient getOrCreateClient() throws Exception {	if (atomix == null) {	ObjectHelper.notNull(getCamelContext(), "Camel Context");	ObjectHelper.notNull(configuration, "Atomix Node Configuration");	if (ObjectHelper.isEmpty(configuration.getNodes())) {	throw new IllegalArgumentException("Atomix nodes should not be empty");	}	atomix = AtomixClientHelper.createClient(getCamelContext(), configuration);	
connect to cluster nodes 

private AtomixClient getOrCreateClient() throws Exception {	if (atomix == null) {	ObjectHelper.notNull(getCamelContext(), "Camel Context");	ObjectHelper.notNull(configuration, "Atomix Node Configuration");	if (ObjectHelper.isEmpty(configuration.getNodes())) {	throw new IllegalArgumentException("Atomix nodes should not be empty");	}	atomix = AtomixClientHelper.createClient(getCamelContext(), configuration);	atomix.connect(configuration.getNodes()).join();	
connect to cluster done 

========================= camel sample_10320 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KubernetesConfigMapsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-config-maps.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-config-maps.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_557 =========================

public void process(Exchange exchange) throws Exception {	
start of onexchange 

public void process(Exchange exchange) throws Exception {	super.process(exchange);	
end of onexchange 

========================= camel sample_3724 =========================

}	if (allowProcessor(explicitMethodName, beanInfo)) {	processor = getProcessor();	if (processor == null && !lookupProcessorDone) {	synchronized (lock) {	lookupProcessorDone = true;	processor = exchange.getContext().getTypeConverter().tryConvertTo(Processor.class, exchange, bean);	}	}	if (processor != null) {	
using a custom adapter as bean invocation 

callback.done(true);	return true;	}	}	Message in = exchange.getIn();	BeanInvocation beanInvoke = null;	if (in.getBody() instanceof BeanInvocation) {	beanInvoke = (BeanInvocation) in.getBody();	}	if (beanInvoke != null) {	
exchange in body is a beaninvocation instance 

}	Message in = exchange.getIn();	BeanInvocation beanInvoke = null;	if (in.getBody() instanceof BeanInvocation) {	beanInvoke = (BeanInvocation) in.getBody();	}	if (beanInvoke != null) {	Class<?> clazz = beanInvoke.getMethod().getDeclaringClass();	boolean sameBean = clazz.isInstance(bean);	if (LOG.isDebugEnabled()) {	
beanholder bean and beaninvocation bean is same instance 

========================= camel sample_4848 =========================

protected final void parseUri() throws IllegalArgumentException {	
uri 

protected final void parseUri() throws IllegalArgumentException {	if (uri.matches(FORMAT1)) {	
FORMAT1 

protected final void parseUri() throws IllegalArgumentException {	if (uri.matches(FORMAT1)) {	String[] parts = uri.replaceFirst(FORMAT1, "$1:$2:$3:$4").split(":");	host = parts[0];	port = Integer.parseInt(parts[1]);	database = parts[2];	channel = parts[3];	} else if (uri.matches(FORMAT2)) {	
FORMAT2 

port = Integer.parseInt(parts[1]);	database = parts[2];	channel = parts[3];	} else if (uri.matches(FORMAT2)) {	String[] parts = uri.replaceFirst(FORMAT2, "$1:$2:$3").split(":");	host = parts[0];	port = 5432;	database = parts[1];	channel = parts[2];	} else if (uri.matches(FORMAT3)) {	
FORMAT3 

port = 5432;	database = parts[1];	channel = parts[2];	} else if (uri.matches(FORMAT3)) {	String[] parts = uri.replaceFirst(FORMAT3, "$1:$2").split(":");	host = "localhost";	port = 5432;	database = parts[0];	channel = parts[1];	} else if (uri.matches(FORMAT4)) {	
FORMAT4 

private void validateInputs() throws InvalidClassException, IllegalArgumentException {	if (getChannel() == null || getChannel().length() == 0) {	throw new IllegalArgumentException("A required parameter was not set when creating this Endpoint (channel)");	}	if (datasource != null) {	
datasource detected 

========================= camel sample_12464 =========================

public void create() throws Exception {	JdbcTemplate jdbc = new JdbcTemplate(dataSource);	String sql = "create table orders (\n" + "  id integer primary key,\n" + "  item varchar(10),\n" + "  amount varchar(5),\n" + "  description varchar(30),\n" + "  processed boolean\n" + ")";	
creating table orders 

public void create() throws Exception {	JdbcTemplate jdbc = new JdbcTemplate(dataSource);	String sql = "create table orders (\n" + "  id integer primary key,\n" + "  item varchar(10),\n" + "  amount varchar(5),\n" + "  description varchar(30),\n" + "  processed boolean\n" + ")";	try {	jdbc.execute("drop table orders");	} catch (Throwable e) {	}	jdbc.execute(sql);	
created table orders 

========================= camel sample_17666 =========================

public void warning(SAXParseException exception) throws SAXException {	
warning occured during parsing 

========================= camel sample_7272 =========================

private void getDroplet(Exchange exchange) throws Exception {	Droplet droplet = getEndpoint().getDigitalOceanClient().getDropletInfo(dropletId);	
droplet 

private void getDroplets(Exchange exchange) throws Exception {	Droplets droplets = getEndpoint().getDigitalOceanClient().getAvailableDroplets(configuration.getPage(), configuration.getPerPage());	
all droplets page per page 

private void getDropletActions(Exchange exchange) throws Exception {	Actions actions = getEndpoint().getDigitalOceanClient().getAvailableDropletActions(dropletId, configuration.getPage(), configuration.getPerPage());	
actions for droplet page per page 

private void getDropletKernels(Exchange exchange) throws Exception {	Kernels kernels = getEndpoint().getDigitalOceanClient().getDropletKernels(dropletId, configuration.getPage(), configuration.getPerPage());	
kernels for droplet page per page 

private void getDropletBackups(Exchange exchange) throws Exception {	Backups backups = getEndpoint().getDigitalOceanClient().getDropletBackups(dropletId, configuration.getPage(), configuration.getPerPage());	
backups for droplet page per page 

private void getDropletSnapshots(Exchange exchange) throws Exception {	Snapshots snapshots = getEndpoint().getDigitalOceanClient().getDropletSnapshots(dropletId, configuration.getPage(), configuration.getPerPage());	
snapshots for droplet page per page 

private void getDropletNeighbors(Exchange exchange) throws Exception {	Droplets droplets = getEndpoint().getDigitalOceanClient().getDropletNeighbors(dropletId, configuration.getPage());	
neighbors for droplet page 

private void getAllDropletNeighbors(Exchange exchange) throws Exception {	Neighbors neighbors = getEndpoint().getDigitalOceanClient().getAllDropletNeighbors(configuration.getPage());	
all neighbors page 

private void deleteDroplet(Exchange exchange) throws Exception {	Delete delete = getEndpoint().getDigitalOceanClient().deleteDroplet(dropletId);	
delete droplet 

}	if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(DigitalOceanHeaders.DROPLET_VOLUMES))) {	droplet.setVolumeIds((List<String>) exchange.getIn().getHeader(DigitalOceanHeaders.DROPLET_VOLUMES));	}	if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(DigitalOceanHeaders.DROPLET_TAGS))) {	droplet.setTags((List<String>) exchange.getIn().getHeader(DigitalOceanHeaders.DROPLET_TAGS));	}	if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(DigitalOceanHeaders.NAMES))) {	droplet.setNames((List<String>) in.getHeader(DigitalOceanHeaders.NAMES));	Droplets droplets = getEndpoint().getDigitalOceanClient().createDroplets(droplet);	
droplets created 

if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(DigitalOceanHeaders.DROPLET_TAGS))) {	droplet.setTags((List<String>) exchange.getIn().getHeader(DigitalOceanHeaders.DROPLET_TAGS));	}	if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(DigitalOceanHeaders.NAMES))) {	droplet.setNames((List<String>) in.getHeader(DigitalOceanHeaders.NAMES));	Droplets droplets = getEndpoint().getDigitalOceanClient().createDroplets(droplet);	exchange.getOut().setBody(droplets.getDroplets());	} else if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(DigitalOceanHeaders.NAME))) {	droplet.setName(in.getHeader(DigitalOceanHeaders.NAME, String.class));	droplet = getEndpoint().getDigitalOceanClient().createDroplet(droplet);	
droplet created 

private void restoreDroplet(Exchange exchange) throws Exception {	if (ObjectHelper.isEmpty(exchange.getIn().getHeader(DigitalOceanHeaders.IMAGE_ID))) {	throw new IllegalArgumentException(DigitalOceanHeaders.IMAGE_ID + " must be specified");	}	Action action = getEndpoint().getDigitalOceanClient().restoreDroplet(dropletId, exchange.getIn().getHeader(DigitalOceanHeaders.IMAGE_ID, Integer.class));	
dropletaction restore 

private void resizeDroplet(Exchange exchange) throws Exception {	if (ObjectHelper.isEmpty(exchange.getIn().getHeader(DigitalOceanHeaders.DROPLET_SIZE))) {	throw new IllegalArgumentException(DigitalOceanHeaders.DROPLET_SIZE + " must be specified");	}	Action action = getEndpoint().getDigitalOceanClient().resizeDroplet(dropletId, exchange.getIn().getHeader(DigitalOceanHeaders.DROPLET_SIZE, String.class));	
dropletaction resize 

private void rebuildDroplet(Exchange exchange) throws Exception {	if (ObjectHelper.isEmpty(exchange.getIn().getHeader(DigitalOceanHeaders.IMAGE_ID))) {	throw new IllegalArgumentException(DigitalOceanHeaders.IMAGE_ID + " must be specified");	}	Action action = getEndpoint().getDigitalOceanClient().rebuildDroplet(dropletId, exchange.getIn().getHeader(DigitalOceanHeaders.IMAGE_ID, Integer.class));	
rebuild droplet 

private void renameDroplet(Exchange exchange) throws Exception {	if (ObjectHelper.isEmpty(exchange.getIn().getHeader(DigitalOceanHeaders.NAME))) {	throw new IllegalArgumentException(DigitalOceanHeaders.NAME + " must be specified");	}	Action action = getEndpoint().getDigitalOceanClient().renameDroplet(dropletId, exchange.getIn().getHeader(DigitalOceanHeaders.NAME, String.class));	
rename droplet 

private void changeDropletKernel(Exchange exchange) throws Exception {	if (ObjectHelper.isEmpty(exchange.getIn().getHeader(DigitalOceanHeaders.KERNEL_ID))) {	throw new IllegalArgumentException(DigitalOceanHeaders.KERNEL_ID + " must be specified");	}	Action action = getEndpoint().getDigitalOceanClient().changeDropletKernel(dropletId, exchange.getIn().getHeader(DigitalOceanHeaders.KERNEL_ID, Integer.class));	
rename droplet 

private void resetDropletPassword(Exchange exchange) throws Exception {	Action action = getEndpoint().getDigitalOceanClient().resetDropletPassword(dropletId);	
reset password droplet 

private void powerOnDroplet(Exchange exchange) throws Exception {	Action action = getEndpoint().getDigitalOceanClient().powerOnDroplet(dropletId);	
power on droplet 

private void powerOffDroplet(Exchange exchange) throws Exception {	Action action = getEndpoint().getDigitalOceanClient().powerOffDroplet(dropletId);	
power off droplet 

private void shutdownDroplet(Exchange exchange) throws Exception {	Action action = getEndpoint().getDigitalOceanClient().shutdownDroplet(dropletId);	
shutdown droplet 

private void powerCycleDroplet(Exchange exchange) throws Exception {	Action action = getEndpoint().getDigitalOceanClient().powerCycleDroplet(dropletId);	
power cycle droplet 

private void enableDropletBackups(Exchange exchange) throws Exception {	Action action = getEndpoint().getDigitalOceanClient().enableDropletBackups(dropletId);	
enable backups droplet 

private void disableDropletBackups(Exchange exchange) throws Exception {	Action action = getEndpoint().getDigitalOceanClient().disableDropletBackups(dropletId);	
disable backups for droplet 

private void enableDropletIpv6(Exchange exchange) throws Exception {	Action action = getEndpoint().getDigitalOceanClient().enableDropletIpv6(dropletId);	
enable ip for droplet 

private void enableDropletPrivateNetworking(Exchange exchange) throws Exception {	Action action = getEndpoint().getDigitalOceanClient().enableDropletPrivateNetworking(dropletId);	
enable private networking for droplet 

private void rebootDroplet(Exchange exchange) throws Exception {	Action action = getEndpoint().getDigitalOceanClient().rebootDroplet(dropletId);	
reboot droplet 

private void takeDropletSnapshot(Exchange exchange) throws Exception {	Action action;	if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(DigitalOceanHeaders.NAME))) {	action = getEndpoint().getDigitalOceanClient().takeDropletSnapshot(dropletId, exchange.getIn().getHeader(DigitalOceanHeaders.NAME, String.class));	} else {	action = getEndpoint().getDigitalOceanClient().takeDropletSnapshot(dropletId);	}	
take snapshot for droplet 

private void tagDroplet(Exchange exchange) throws Exception {	if (ObjectHelper.isEmpty(exchange.getIn().getHeader(DigitalOceanHeaders.NAME))) {	throw new IllegalArgumentException(DigitalOceanHeaders.NAME + " must be specified");	}	ArrayList<Resource> resources = new ArrayList<>(1);	resources.add(new Resource(dropletId.toString(), ResourceType.DROPLET));	Response response = getEndpoint().getDigitalOceanClient().tagResources(dropletId.toString(), resources);	
tag droplet 

private void untagDroplet(Exchange exchange) throws Exception {	if (ObjectHelper.isEmpty(exchange.getIn().getHeader(DigitalOceanHeaders.NAME))) {	throw new IllegalArgumentException(DigitalOceanHeaders.NAME + " must be specified");	}	ArrayList<Resource> resources = new ArrayList<>(1);	resources.add(new Resource(dropletId.toString(), ResourceType.DROPLET));	Response response = getEndpoint().getDigitalOceanClient().untagResources(dropletId.toString(), resources);	
untag droplet 

========================= camel sample_8885 =========================

protected int poll() throws Exception {	TelegramConfiguration config = endpoint.getConfiguration();	Long realOffset = offset != null ? offset : 0L;	TelegramService service = TelegramServiceProvider.get().getService();	
polling telegram service to get updates 

TelegramService service = TelegramServiceProvider.get().getService();	UpdateResult updateResult = service.getUpdates(config.getAuthorizationToken(), offset, config.getLimit(), config.getTimeout());	if (updateResult.getUpdates() == null) {	updateResult.setUpdates(Collections.emptyList());	}	if (!updateResult.isOk()) {	throw new IllegalStateException("The server was unable to process the request. Response was " + updateResult);	}	List<Update> updates = updateResult.getUpdates();	if (updates.size() > 0) {	
received updates from telegram service 

UpdateResult updateResult = service.getUpdates(config.getAuthorizationToken(), offset, config.getLimit(), config.getTimeout());	if (updateResult.getUpdates() == null) {	updateResult.setUpdates(Collections.emptyList());	}	if (!updateResult.isOk()) {	throw new IllegalStateException("The server was unable to process the request. Response was " + updateResult);	}	List<Update> updates = updateResult.getUpdates();	if (updates.size() > 0) {	} else {	
no updates received from telegram service 

private void processUpdates(List<Update> updates) throws Exception {	for (Update update : updates) {	
received update from telegram service 

private void updateOffset(List<Update> updates) {	OptionalLong ol = updates.stream().mapToLong(Update::getUpdateId).max();	if (ol.isPresent()) {	this.offset = ol.getAsLong() + 1;	
next telegram offset will be 

========================= camel sample_11926 =========================

public void execute() {	PutAttributesRequest request = new PutAttributesRequest() .withDomainName(determineDomainName()) .withItemName(determineItemName()) .withAttributes(determineReplaceableAttributes()) .withExpected(determineUpdateCondition());	
sending request for exchange 

public void execute() {	PutAttributesRequest request = new PutAttributesRequest() .withDomainName(determineDomainName()) .withItemName(determineItemName()) .withAttributes(determineReplaceableAttributes()) .withExpected(determineUpdateCondition());	this.sdbClient.putAttributes(request);	
request sent 

========================= camel sample_8755 =========================

TSSLTransportFactory.TSSLTransportParameters sslParams = new TSSLTransportFactory.TSSLTransportParameters();	sslParams.setKeyStore(KEY_STORE_PATH, SECURITY_STORE_PASSWORD);	serverTransport = TSSLTransportFactory.getServerSocket(THRIFT_TEST_PORT, THRIFT_CLIENT_TIMEOUT, InetAddress.getByName("localhost"), sslParams);	ThriftThreadPoolServer.Args args = new ThriftThreadPoolServer.Args(serverTransport);	args.processor((TProcessor)processor);	args.executorService(this.context().getExecutorServiceManager().newThreadPool(this, "test-server-invoker", 1, 10));	args.startThreadPool(this.context().getExecutorServiceManager().newSingleThreadExecutor(this, "test-start-thread"));	args.context(this.context());	server = new ThriftThreadPoolServer(args);	server.serve();	
thrift secured server started on port 

public void stopThriftServer() throws IOException {	if (server != null) {	server.stop();	serverTransport.close();	
thrift secured server stoped 

========================= camel sample_13018 =========================

public boolean acceptPathName(String path) {	path = path.replace(File.separatorChar, '/');	
filtering file 

public boolean acceptPathName(String path) {	path = path.replace(File.separatorChar, '/');	if (excludes != null) {	for (String exclude : excludes) {	if (matcher.match(exclude, path, caseSensitive)) {	
file is excluded 

if (excludes != null) {	for (String exclude : excludes) {	if (matcher.match(exclude, path, caseSensitive)) {	return false;	}	}	}	if (includes != null) {	for (String include : includes) {	if (matcher.match(include, path, caseSensitive)) {	
file is included 

========================= camel sample_4776 =========================

public static InputStream genericFileToInputStream(GenericFile<?> file, Exchange exchange) throws IOException, NoTypeConversionAvailableException {	if (file.getFile() instanceof File) {	File f = (File) file.getFile();	if (f.exists()) {	String charset = file.getCharset();	if (charset != null) {	
read file with charset 

public static InputStream genericFileToInputStream(GenericFile<?> file, Exchange exchange) throws IOException, NoTypeConversionAvailableException {	if (file.getFile() instanceof File) {	File f = (File) file.getFile();	if (f.exists()) {	String charset = file.getCharset();	if (charset != null) {	} else {	
read file no charset 

private static BufferedReader genericFileToReader(GenericFile<?> file, Exchange exchange) throws IOException, NoTypeConversionAvailableException {	if (file.getFile() instanceof File) {	File f = (File) file.getFile();	if (!f.exists()) {	return null;	}	String charset = file.getCharset();	if (charset != null) {	
read file with charset 

private static BufferedReader genericFileToReader(GenericFile<?> file, Exchange exchange) throws IOException, NoTypeConversionAvailableException {	if (file.getFile() instanceof File) {	File f = (File) file.getFile();	if (!f.exists()) {	return null;	}	String charset = file.getCharset();	if (charset != null) {	return IOConverter.toReader(f, charset);	} else {	
read file no charset 

========================= camel sample_4799 =========================

getProducers().setMaxActive(getProducerCount());	getProducers().setMaxIdle(getProducerCount());	getProducers().setLifo(false);	if (getEndpoint().isPrefillPool()) {	if (getEndpoint().isAsyncStartListener()) {	asyncStart = getEndpoint().getComponent().getAsyncStartStopExecutorService().submit(new Runnable() {	public void run() {	try {	fillProducersPool();	} catch (Throwable e) {	
error filling producer pool for destination this exception will be ignored 

asyncStart.cancel(true);	}	if (getProducers() != null) {	if (getEndpoint().isAsyncStopListener()) {	getEndpoint().getComponent().getAsyncStartStopExecutorService().submit(new Runnable() {	public void run() {	try {	getProducers().close();	setProducers(null);	} catch (Throwable e) {	
error closing producers on destination this exception will be ignored 

protected MessageProducerResources doCreateProducerModel(Session session) throws Exception {	MessageProducerResources answer;	try {	MessageProducer messageProducer = getEndpoint().getJmsObjectFactory().createMessageProducer(session, getEndpoint());	answer = new MessageProducerResources(session, messageProducer, getCommitStrategy());	} catch (Exception e) {	
unable to create the messageproducer 

protected Session createSession() throws Exception {	ConnectionResource connectionResource = getOrCreateConnectionResource();	Connection conn = connectionResource.borrowConnection();	try {	return conn.createSession(isEndpointTransacted(), getAcknowledgeMode());	} catch (Exception e) {	
unable to create the session 

public abstract void sendMessage(Exchange exchange, AsyncCallback callback, MessageProducerResources producer, ReleaseProducerCallback releaseProducerCallback) throws Exception;	public boolean process(final Exchange exchange, final AsyncCallback callback) {	if (log.isDebugEnabled()) {	
processing exchange id 

releaseProducerCallback = new ReturnProducerCallback();	if (isEndpointTransacted()) {	exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), producer.getCommitStrategy()));	}	}	if (producer == null) {	exchange.setException(new Exception("Unable to send message: connection not available"));	} else {	if (!isSynchronous()) {	if (log.isDebugEnabled()) {	
sending message asynchronously 

public void run() {	try {	sendMessage(exchange, callback, finalProducer, finalrpc);	} catch (Exception e) {	ObjectHelper.wrapRuntimeCamelException(e);	}	}	});	} else {	if (log.isDebugEnabled()) {	
sending message synchronously 

}	});	} else {	if (log.isDebugEnabled()) {	}	sendMessage(exchange, callback, producer, releaseProducerCallback);	}	}	} catch (Exception e) {	if (log.isDebugEnabled()) {	
processing exchange id failed 

} else {	if (log.isDebugEnabled()) {	}	sendMessage(exchange, callback, producer, releaseProducerCallback);	}	}	} catch (Exception e) {	if (log.isDebugEnabled()) {	}	if (log.isDebugEnabled()) {	
exception 

sendMessage(exchange, callback, producer, releaseProducerCallback);	}	}	} catch (Exception e) {	if (log.isDebugEnabled()) {	}	if (log.isDebugEnabled()) {	}	exchange.setException(e);	}	
processing exchange id success 

========================= camel sample_12432 =========================

public XmppPubSubProducer(XmppEndpoint endpoint) {	super(endpoint);	this.endpoint = endpoint;	
creating xmpppresenceproducer 

public void process(Exchange exchange) throws Exception {	try {	if (connection == null) {	connection = endpoint.createConnection();	}	if (!connection.isConnected()) {	if (LOG.isDebugEnabled()) {	
reconnecting to 

========================= camel sample_12598 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<InfluxDbComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.influxdb.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.influxdb.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_628 =========================

protected abstract String getUri();	protected abstract Logger getLogger();	public void testDailyTrend() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.assertIsSatisfied();	List<Exchange> tweets = mock.getExchanges();	for (Exchange e : tweets) {	
tweet 

========================= camel sample_14159 =========================

public void testChoice() throws InterruptedException {	template.setDefaultEndpointUri("direct:choice");	execute(20000);	resetMock(count);	StopWatch watch = new StopWatch();	execute(count);	assertMockEndpointsSatisfied();	
ran tests in ms 

public void testFilter() throws InterruptedException {	template.setDefaultEndpointUri("direct:filter");	execute(20000);	resetMock(count);	StopWatch watch = new StopWatch();	execute(count);	assertMockEndpointsSatisfied();	
ran tests in ms 

========================= camel sample_6435 =========================

ProcessorDefinition<?> output = it.next();	if (matchBy.match(output)) {	List<ProcessorDefinition<?>> outputs = getOutputs(output);	if (outputs != null) {	int index = outputs.indexOf(output);	if (index != -1) {	match = true;	outputs.add(index + 1, replace);	Object old = outputs.remove(index);	replace.setParent(output.getParent());	
advicewith replace 

Iterator<ProcessorDefinition<?>> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo, maxDeep);	while (it.hasNext()) {	ProcessorDefinition<?> output = it.next();	if (matchBy.match(output)) {	List<ProcessorDefinition<?>> outputs = getOutputs(output);	if (outputs != null) {	int index = outputs.indexOf(output);	if (index != -1) {	match = true;	Object old = outputs.remove(index);	
advicewith remove 

ProcessorDefinition<?> output = it.next();	if (matchBy.match(output)) {	List<ProcessorDefinition<?>> outputs = getOutputs(output);	if (outputs != null) {	int index = outputs.indexOf(output);	if (index != -1) {	match = true;	Object existing = outputs.get(index);	outputs.add(index, before);	before.setParent(output.getParent());	
advicewith before 

ProcessorDefinition<?> output = it.next();	if (matchBy.match(output)) {	List<ProcessorDefinition<?>> outputs = getOutputs(output);	if (outputs != null) {	int index = outputs.indexOf(output);	if (index != -1) {	match = true;	Object existing = outputs.get(index);	outputs.add(index + 1, after);	after.setParent(output.getParent());	
advicewith after 

public static AdviceWithTask replaceFromWith(final RouteDefinition route, final String uri) {	return new AdviceWithTask() {	public void task() throws Exception {	FromDefinition from = route.getInputs().get(0);	
advicewith replace input from 

public static AdviceWithTask replaceFrom(final RouteDefinition route, final Endpoint endpoint) {	return new AdviceWithTask() {	public void task() throws Exception {	FromDefinition from = route.getInputs().get(0);	
advicewith replace input from 

========================= camel sample_5649 =========================

public void doSomething(String body, Exchange exchange) {	ObjectHelper.notNull(destination, "destination");	ObjectHelper.notNull(exchange, "exchange");	ObjectHelper.notNull(exchange.getContext(), "exchange.getContext");	
received body 

========================= camel sample_15748 =========================

public void run() {	
starting 

swagger.setPrettyPrint(true);	swagger.setSupportSwaggerUi(true);	swagger.setTitle("Camel Catalog and Connector Catalog REST Api");	swagger.setDescription("REST Api for the Camel Catalog and Connector Catalog");	swagger.setVersion(catalog.getCatalogVersion());	swagger.setContact("Apache Camel");	sf.getFeatures().add(swagger);	sf.setProvider(JacksonJsonProvider.class);	sf.setAddress("http: server = sf.create();	server.start();	
camelcatalog rest api started 

swagger.setSupportSwaggerUi(true);	swagger.setTitle("Camel Catalog and Connector Catalog REST Api");	swagger.setDescription("REST Api for the Camel Catalog and Connector Catalog");	swagger.setVersion(catalog.getCatalogVersion());	swagger.setContact("Apache Camel");	sf.getFeatures().add(swagger);	sf.setProvider(JacksonJsonProvider.class);	sf.setAddress("http: server = sf.create();	server.start();	LOGGER.info("");	
trest api base path http logger info 

swagger.setSupportSwaggerUi(true);	swagger.setTitle("Camel Catalog and Connector Catalog REST Api");	swagger.setDescription("REST Api for the Camel Catalog and Connector Catalog");	swagger.setVersion(catalog.getCatalogVersion());	swagger.setContact("Apache Camel");	sf.getFeatures().add(swagger);	sf.setProvider(JacksonJsonProvider.class);	sf.setAddress("http: server = sf.create();	server.start();	LOGGER.info("");	
camelconnectorcatalog rest api started 

swagger.setTitle("Camel Catalog and Connector Catalog REST Api");	swagger.setDescription("REST Api for the Camel Catalog and Connector Catalog");	swagger.setVersion(catalog.getCatalogVersion());	swagger.setContact("Apache Camel");	sf.getFeatures().add(swagger);	sf.setProvider(JacksonJsonProvider.class);	sf.setAddress("http: server = sf.create();	server.start();	LOGGER.info("");	LOGGER.info("");	
trest api base path http logger info 

swagger.setTitle("Camel Catalog and Connector Catalog REST Api");	swagger.setDescription("REST Api for the Camel Catalog and Connector Catalog");	swagger.setVersion(catalog.getCatalogVersion());	swagger.setContact("Apache Camel");	sf.getFeatures().add(swagger);	sf.setProvider(JacksonJsonProvider.class);	sf.setAddress("http: server = sf.create();	server.start();	LOGGER.info("");	LOGGER.info("");	
tswagger doc http logger info 

swagger.setTitle("Camel Catalog and Connector Catalog REST Api");	swagger.setDescription("REST Api for the Camel Catalog and Connector Catalog");	swagger.setVersion(catalog.getCatalogVersion());	swagger.setContact("Apache Camel");	sf.getFeatures().add(swagger);	sf.setProvider(JacksonJsonProvider.class);	sf.setAddress("http: server = sf.create();	server.start();	LOGGER.info("");	LOGGER.info("");	
press enter to stop 

swagger.setVersion(catalog.getCatalogVersion());	swagger.setContact("Apache Camel");	sf.getFeatures().add(swagger);	sf.setProvider(JacksonJsonProvider.class);	sf.setAddress("http: server = sf.create();	server.start();	LOGGER.info("");	LOGGER.info("");	Console console = System.console();	console.readLine();	
stopping 

sf.getFeatures().add(swagger);	sf.setProvider(JacksonJsonProvider.class);	sf.setAddress("http: server = sf.create();	server.start();	LOGGER.info("");	LOGGER.info("");	Console console = System.console();	console.readLine();	server.stop();	server.destroy();	
camelcatalog rest api stopped 

========================= camel sample_297 =========================

public void testRouteboxDirectProducerOnlyRequests() throws Exception {	template = new DefaultProducerTemplate(context);	template.start();	context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:start") .to(routeboxUri) .to("log:Routes operation performed?showAll=true");	}	});	context.start();	
beginning test testrouteboxdirectsyncrequests 

context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:start") .to(routeboxUri) .to("log:Routes operation performed?showAll=true");	}	});	context.start();	Book book = new Book("Sir Arthur Conan Doyle", "The Adventures of Sherlock Holmes");	String response = sendAddToCatalogRequest(template, "direct:start", "addToCatalog", book);	assertEquals("Book with Author " + book.getAuthor() + " and title " + book.getTitle() + " added to Catalog", response);	book = sendFindBookRequest(template, "direct:start", "findBook", "Sir Arthur Conan Doyle");	
received book with author and title 

public void configure() {	from("direct:start") .to(routeboxUri) .to("log:Routes operation performed?showAll=true");	}	});	context.start();	Book book = new Book("Sir Arthur Conan Doyle", "The Adventures of Sherlock Holmes");	String response = sendAddToCatalogRequest(template, "direct:start", "addToCatalog", book);	assertEquals("Book with Author " + book.getAuthor() + " and title " + book.getTitle() + " added to Catalog", response);	book = sendFindBookRequest(template, "direct:start", "findBook", "Sir Arthur Conan Doyle");	assertEquals("The Adventures of Sherlock Holmes", book.getTitle());	
completed test testrouteboxdirectsyncrequests 

========================= camel sample_14620 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<IgniteSetComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ignite-set.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ignite-set.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1173 =========================

public Boolean executeTest(ITestConfig config, String component) throws Exception {	
getting camel component 

public Boolean executeTest(ITestConfig config, String component) throws Exception {	org.apache.camel.Component comp = context.getComponent(component, true, config.getAutoStartComponent());	assertNotNull("Cannot get module with name: " + component, comp);	
found camel module instance with classname 

========================= camel sample_5999 =========================

public PullRequestConsumer(GitHubEndpoint endpoint, Processor processor) throws Exception {	super(endpoint, processor);	Registry registry = endpoint.getCamelContext().getRegistry();	Object service = registry.lookupByName(GitHubConstants.GITHUB_PULL_REQUEST_SERVICE);	if (service != null) {	
using pullrequestservice found in registry 

public PullRequestConsumer(GitHubEndpoint endpoint, Processor processor) throws Exception {	super(endpoint, processor);	Registry registry = endpoint.getCamelContext().getRegistry();	Object service = registry.lookupByName(GitHubConstants.GITHUB_PULL_REQUEST_SERVICE);	if (service != null) {	pullRequestService = (PullRequestService) service;	} else {	pullRequestService = new PullRequestService();	}	initService(pullRequestService);	
github pullrequestconsumer indexing current pull requests 

========================= camel sample_14270 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<WebsocketComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.atmosphere-websocket.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.atmosphere-websocket.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_444 =========================

public HttpServerSharedPipelineFactory(NettySharedHttpServerBootstrapConfiguration configuration, HttpServerConsumerChannelFactory channelFactory, ClassResolver classResolver) {	this.configuration = configuration;	this.channelFactory = channelFactory;	this.classResolver = classResolver != null ? classResolver : new DefaultClassResolver();	try {	this.sslContext = createSSLContext();	} catch (Exception e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	}	if (sslContext != null) {	
created sslcontext 

public ChannelPipeline getPipeline() throws Exception {	ChannelPipeline pipeline = Channels.pipeline();	SslHandler sslHandler = configureServerSSLOnDemand();	if (sslHandler != null) {	
server ssl handler configured and added as an interceptor against the channelpipeline 

private SSLContext createSSLContext() throws Exception {	if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext();	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	
keystorefile is null 

if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext();	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	
truststorefile is null 

}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext();	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	}	if (configuration.getPassphrase().toCharArray() == null) {	
passphrase is null 

========================= camel sample_8352 =========================

protected int poll() throws Exception {	Exchange exchange = super.getEndpoint().createExchange();	try {	
retrieving a message 

========================= camel sample_9955 =========================

StringBuilder regular = new StringBuilder();	regular.append("* Components\n");	for (ComponentModel model : models) {	if (!model.getLabel().contains("core")) {	String line = "\t* " + link(model) + "\n";	regular.append(line);	}	}	updated |= updateComponents(file, regular.toString());	if (updated) {	
updated user guide file 

regular.append("* Components\n");	for (ComponentModel model : models) {	if (!model.getLabel().contains("core")) {	String line = "\t* " + link(model) + "\n";	regular.append(line);	}	}	updated |= updateComponents(file, regular.toString());	if (updated) {	} else {	
no changes to user guide file 

Collections.sort(models, new OtherComparator());	File file = new File(userGuideDir, "SUMMARY.md");	StringBuilder other = new StringBuilder();	other.append("* Miscellaneous Components\n");	for (OtherModel model : models) {	String line = "\t* " + link(model) + "\n";	other.append(line);	}	boolean updated = updateOthers(file, other.toString());	if (updated) {	
updated user guide file 

File file = new File(userGuideDir, "SUMMARY.md");	StringBuilder other = new StringBuilder();	other.append("* Miscellaneous Components\n");	for (OtherModel model : models) {	String line = "\t* " + link(model) + "\n";	other.append(line);	}	boolean updated = updateOthers(file, other.toString());	if (updated) {	} else {	
no changes to user guide file 

Collections.sort(models, new DataFormatComparator());	File file = new File(userGuideDir, "SUMMARY.md");	StringBuilder dataFormats = new StringBuilder();	dataFormats.append("* Data Formats\n");	for (DataFormatModel model : models) {	String line = "\t* " + link(model) + "\n";	dataFormats.append(line);	}	boolean updated = updateDataFormats(file, dataFormats.toString());	if (updated) {	
updated user guide file 

File file = new File(userGuideDir, "SUMMARY.md");	StringBuilder dataFormats = new StringBuilder();	dataFormats.append("* Data Formats\n");	for (DataFormatModel model : models) {	String line = "\t* " + link(model) + "\n";	dataFormats.append(line);	}	boolean updated = updateDataFormats(file, dataFormats.toString());	if (updated) {	} else {	
no changes to user guide file 

Collections.sort(models, new LanguageComparator());	File file = new File(userGuideDir, "SUMMARY.md");	StringBuilder languages = new StringBuilder();	languages.append("* Expression Languages\n");	for (LanguageModel model : models) {	String line = "\t* " + link(model) + "\n";	languages.append(line);	}	boolean updated = updateLanguages(file, languages.toString());	if (updated) {	
updated user guide file 

File file = new File(userGuideDir, "SUMMARY.md");	StringBuilder languages = new StringBuilder();	languages.append("* Expression Languages\n");	for (LanguageModel model : models) {	String line = "\t* " + link(model) + "\n";	languages.append(line);	}	boolean updated = updateLanguages(file, languages.toString());	if (updated) {	} else {	
no changes to user guide file 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- core components: START -->");	String after = StringHelper.after(text, "<!-- core components: END -->");	text = before + "<!-- core components: START -->\n" + changed + "\n<!-- core components: END -->" + after;	writeText(file, text);	return true;	}	} else {	
cannot find markers in file 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- core components: START -->");	String after = StringHelper.after(text, "<!-- core components: END -->");	text = before + "<!-- core components: START -->\n" + changed + "\n<!-- core components: END -->" + after;	writeText(file, text);	return true;	}	} else {	
add the following markers 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- core components: START -->");	String after = StringHelper.after(text, "<!-- core components: END -->");	text = before + "<!-- core components: START -->\n" + changed + "\n<!-- core components: END -->" + after;	writeText(file, text);	return true;	}	} else {	
t core components start 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- core components: START -->");	String after = StringHelper.after(text, "<!-- core components: END -->");	text = before + "<!-- core components: START -->\n" + changed + "\n<!-- core components: END -->" + after;	writeText(file, text);	return true;	}	} else {	
t core components end 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- components: START -->");	String after = StringHelper.after(text, "<!-- components: END -->");	text = before + "<!-- components: START -->\n" + changed + "\n<!-- components: END -->" + after;	writeText(file, text);	return true;	}	} else {	
cannot find markers in file 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- components: START -->");	String after = StringHelper.after(text, "<!-- components: END -->");	text = before + "<!-- components: START -->\n" + changed + "\n<!-- components: END -->" + after;	writeText(file, text);	return true;	}	} else {	
add the following markers 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- components: START -->");	String after = StringHelper.after(text, "<!-- components: END -->");	text = before + "<!-- components: START -->\n" + changed + "\n<!-- components: END -->" + after;	writeText(file, text);	return true;	}	} else {	
t components start 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- components: START -->");	String after = StringHelper.after(text, "<!-- components: END -->");	text = before + "<!-- components: START -->\n" + changed + "\n<!-- components: END -->" + after;	writeText(file, text);	return true;	}	} else {	
t components end 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- others: START -->");	String after = StringHelper.after(text, "<!-- others: END -->");	text = before + "<!-- others: START -->\n" + changed + "\n<!-- others: END -->" + after;	writeText(file, text);	return true;	}	} else {	
cannot find markers in file 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- others: START -->");	String after = StringHelper.after(text, "<!-- others: END -->");	text = before + "<!-- others: START -->\n" + changed + "\n<!-- others: END -->" + after;	writeText(file, text);	return true;	}	} else {	
add the following markers 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- others: START -->");	String after = StringHelper.after(text, "<!-- others: END -->");	text = before + "<!-- others: START -->\n" + changed + "\n<!-- others: END -->" + after;	writeText(file, text);	return true;	}	} else {	
t others start 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- others: START -->");	String after = StringHelper.after(text, "<!-- others: END -->");	text = before + "<!-- others: START -->\n" + changed + "\n<!-- others: END -->" + after;	writeText(file, text);	return true;	}	} else {	
t others end 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- dataformats: START -->");	String after = StringHelper.after(text, "<!-- dataformats: END -->");	text = before + "<!-- dataformats: START -->\n" + changed + "\n<!-- dataformats: END -->" + after;	writeText(file, text);	return true;	}	} else {	
cannot find markers in file 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- dataformats: START -->");	String after = StringHelper.after(text, "<!-- dataformats: END -->");	text = before + "<!-- dataformats: START -->\n" + changed + "\n<!-- dataformats: END -->" + after;	writeText(file, text);	return true;	}	} else {	
add the following markers 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- dataformats: START -->");	String after = StringHelper.after(text, "<!-- dataformats: END -->");	text = before + "<!-- dataformats: START -->\n" + changed + "\n<!-- dataformats: END -->" + after;	writeText(file, text);	return true;	}	} else {	
t dataformats start 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- dataformats: START -->");	String after = StringHelper.after(text, "<!-- dataformats: END -->");	text = before + "<!-- dataformats: START -->\n" + changed + "\n<!-- dataformats: END -->" + after;	writeText(file, text);	return true;	}	} else {	
t dataformats end 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- languages: START -->");	String after = StringHelper.after(text, "<!-- languages: END -->");	text = before + "<!-- languages: START -->\n" + changed + "\n<!-- languages: END -->" + after;	writeText(file, text);	return true;	}	} else {	
cannot find markers in file 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- languages: START -->");	String after = StringHelper.after(text, "<!-- languages: END -->");	text = before + "<!-- languages: START -->\n" + changed + "\n<!-- languages: END -->" + after;	writeText(file, text);	return true;	}	} else {	
add the following markers 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- languages: START -->");	String after = StringHelper.after(text, "<!-- languages: END -->");	text = before + "<!-- languages: START -->\n" + changed + "\n<!-- languages: END -->" + after;	writeText(file, text);	return true;	}	} else {	
t languages start 

if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, "<!-- languages: START -->");	String after = StringHelper.after(text, "<!-- languages: END -->");	text = before + "<!-- languages: START -->\n" + changed + "\n<!-- languages: END -->" + after;	writeText(file, text);	return true;	}	} else {	
t languages end 

========================= camel sample_151 =========================

protected void doStart() throws Exception {	ObjectHelper.notNull(camelContext, "CamelContext", this);	camelContext.getManagementStrategy().addEventNotifier(eventNotifier);	if (!camelContext.getRoutePolicyFactories().contains(this)) {	camelContext.addRoutePolicyFactory(this);	}	if (spanReporter == null) {	if (spanCollector != null) {	} else if (endpoint != null) {	
configuring zipkin urlconnectionsender using endpoint 

ObjectHelper.notNull(camelContext, "CamelContext", this);	camelContext.getManagementStrategy().addEventNotifier(eventNotifier);	if (!camelContext.getRoutePolicyFactories().contains(this)) {	camelContext.addRoutePolicyFactory(this);	}	if (spanReporter == null) {	if (spanCollector != null) {	} else if (endpoint != null) {	spanReporter = AsyncReporter.create(URLConnectionSender.create(endpoint));	} else if (hostName != null && port > 0) {	
configuring zipkin scribespancollector using host and port 

if (spanReporter == null) {	if (spanCollector != null) {	} else if (endpoint != null) {	spanReporter = AsyncReporter.create(URLConnectionSender.create(endpoint));	} else if (hostName != null && port > 0) {	spanCollector = new ScribeSpanCollector(hostName, port);	} else {	String host = new ServiceHostPropertiesFunction().apply(ZIPKIN_COLLECTOR_HTTP_SERVICE);	String port = new ServicePortPropertiesFunction().apply(ZIPKIN_COLLECTOR_HTTP_SERVICE);	if (ObjectHelper.isNotEmpty(host) && ObjectHelper.isNotEmpty(port)) {	
auto configuring zipkin urlconnectionsender using host and port 

} else {	String host = new ServiceHostPropertiesFunction().apply(ZIPKIN_COLLECTOR_HTTP_SERVICE);	String port = new ServicePortPropertiesFunction().apply(ZIPKIN_COLLECTOR_HTTP_SERVICE);	if (ObjectHelper.isNotEmpty(host) && ObjectHelper.isNotEmpty(port)) {	int num = camelContext.getTypeConverter().mandatoryConvertTo(Integer.class, port);	String implicitEndpoint = "http: spanReporter = AsyncReporter.create(URLConnectionSender.create(implicitEndpoint));	} else {	host = new ServiceHostPropertiesFunction().apply(ZIPKIN_COLLECTOR_THRIFT_SERVICE);	port = new ServicePortPropertiesFunction().apply(ZIPKIN_COLLECTOR_THRIFT_SERVICE);	if (ObjectHelper.isNotEmpty(host) && ObjectHelper.isNotEmpty(port)) {	
auto configuring zipkin scribespancollector using host and port 

if (spanReporter == null && spanCollector == null) {	Set<Reporter> reporters = camelContext.getRegistry().findByType(Reporter.class);	if (reporters.size() == 1) {	spanReporter = reporters.iterator().next();	}	}	if (spanCollector == null) {	ObjectHelper.notNull(spanReporter, "Reporter<zipkin2.Span>", this);	}	if (clientServiceMappings.isEmpty() && serverServiceMappings.isEmpty()) {	
no service name s has been mapped in clientservicemappings or serverservicemappings camel will fallback and use endpoint uris as service names 

key = endpoint.getEndpointKey();	} else if (exchange.getFromEndpoint() != null) {	key = exchange.getFromEndpoint().getEndpointKey();	}	for (String pattern : excludePatterns) {	if (EndpointHelper.matchPattern(key, pattern)) {	return null;	}	}	if (LOG.isTraceEnabled() && key != null) {	
using servicename as fallback 

for (String pattern : excludePatterns) {	if (EndpointHelper.matchPattern(key, pattern)) {	return null;	}	}	if (LOG.isTraceEnabled() && key != null) {	}	return key;	} else {	if (LOG.isTraceEnabled() && answer != null) {	
using servicename 

private Brave getBrave(String serviceName) {	Brave brave = null;	if (serviceName != null) {	brave = braves.get(serviceName);	if (brave == null && useFallbackServiceNames) {	
creating brave assigned to servicename as fallback 

========================= camel sample_14335 =========================

public static ObjectInput toObjectInput(final InputStream stream, final Exchange exchange) throws IOException {	if (stream instanceof ObjectInput) {	return (ObjectInput) stream;	} else {	return new ObjectInputStream(IOHelper.buffered(stream)) {	protected Class<?> resolveClass(ObjectStreamClass objectStreamClass) throws IOException, ClassNotFoundException {	Class<?>  answer = null;	String name = objectStreamClass.getName();	if (exchange != null) {	
loading class using camel classresolver 

return (ObjectInput) stream;	} else {	return new ObjectInputStream(IOHelper.buffered(stream)) {	protected Class<?> resolveClass(ObjectStreamClass objectStreamClass) throws IOException, ClassNotFoundException {	Class<?>  answer = null;	String name = objectStreamClass.getName();	if (exchange != null) {	answer = exchange.getContext().getClassResolver().resolveClass(name);	}	if (answer == null) {	
loading class using jdk default implementation 

========================= camel sample_4234 =========================

public void testSimpleRouteWithHeaderPredicate() throws Exception {	List<Route> routes = buildSimpleRouteWithHeaderPredicate();	
created routes 

public void testSimpleRouteWithChoice() throws Exception {	List<Route> routes = buildSimpleRouteWithChoice();	
created routes 

protected List<Route> buildCustomProcessor() throws Exception {	myProcessor = new Processor() {	public void process(Exchange exchange) {	
called with exchange 

public void testCustomProcessorWithFilter() throws Exception {	List<Route> routes = buildCustomProcessorWithFilter();	
created routes 

public void testWireTap() throws Exception {	List<Route> routes = buildWireTap();	
created routes 

public void testRouteWithInterceptor() throws Exception {	List<Route> routes = buildRouteWithInterceptor();	
created routes 

public void testComplexExpressions() throws Exception {	RouteBuilder builder = new RouteBuilder() {	public void configure() {	errorHandler(deadLetterChannel("mock:error"));	from("direct:a") .filter(header("foo").isEqualTo(123)) .to("direct:b");	}	};	List<Route> routes = getRouteList(builder);	
created routes 

public void testRouteDynamicReceipentList() throws Exception {	List<Route> routes = buildDynamicRecipientList();	
created routes 

public void testSplitter() throws Exception {	List<Route> routes = buildSplitter();	
created routes 

public void testIdempotentConsumer() throws Exception {	List<Route> routes = buildIdempotentConsumer();	
created routes 

public void testThreads() throws Exception {	List<Route> routes = buildThreads();	
created routes 

========================= camel sample_3764 =========================

public void setUp() throws Exception {	log.info("********************************************************************************");	
testing 

private void doSetUp() throws Exception {	
setup test 

enableJMX();	} else {	disableJMX();	}	context = (ModelCamelContext)createCamelContext();	threadCamelContext.set(context);	assertNotNull("No context found!", context);	context.getShutdownStrategy().setTimeout(getShutdownTimeout());	if (isUseDebugger()) {	if (context.getStatus().equals(ServiceStatus.Started)) {	
cannot setting the debugger to the starting camelcontext stop the camelcontext now 

pc.setOverrideProperties(extra);	}	Boolean ignore = ignoreMissingLocationWithPropertiesComponent();	if (ignore != null) {	pc.setIgnoreMissingLocation(ignore);	}	postProcessTest();	if (isUseRouteBuilder()) {	RoutesBuilder[] builders = createRouteBuilders();	for (RoutesBuilder builder : builders) {	
using created route builder 

}	postProcessTest();	if (isUseRouteBuilder()) {	RoutesBuilder[] builders = createRouteBuilders();	for (RoutesBuilder builder : builders) {	context.addRoutes(builder);	}	replaceFromEndpoints();	boolean skip = "true".equalsIgnoreCase(System.getProperty("skipStartingCamelContext"));	if (skip) {	
skipping starting camelcontext as system property skipstartingcamelcontext is set to be true 

postProcessTest();	if (isUseRouteBuilder()) {	RoutesBuilder[] builders = createRouteBuilders();	for (RoutesBuilder builder : builders) {	context.addRoutes(builder);	}	replaceFromEndpoints();	boolean skip = "true".equalsIgnoreCase(System.getProperty("skipStartingCamelContext"));	if (skip) {	} else if (isUseAdviceWith()) {	
skipping starting camelcontext as isuseadvicewith is set to true 

}	replaceFromEndpoints();	boolean skip = "true".equalsIgnoreCase(System.getProperty("skipStartingCamelContext"));	if (skip) {	} else if (isUseAdviceWith()) {	} else {	startCamelContext();	}	} else {	replaceFromEndpoints();	
using route builder from the created context 

replaceFromEndpoints();	boolean skip = "true".equalsIgnoreCase(System.getProperty("skipStartingCamelContext"));	if (skip) {	} else if (isUseAdviceWith()) {	} else {	startCamelContext();	}	} else {	replaceFromEndpoints();	}	
routing rules are 

public void tearDown() throws Exception {	long time = watch.stop();	log.info("********************************************************************************");	
testing done 

public void tearDown() throws Exception {	long time = watch.stop();	log.info("********************************************************************************");	
took millis 

public void tearDown() throws Exception {	long time = watch.stop();	log.info("********************************************************************************");	if (isRouteCoverageEnabled()) {	String className = this.getClass().getSimpleName();	String dir = "target/camel-route-coverage";	String name = className + "-" + getTestMethodName() + ".xml";	ManagedCamelContextMBean managedCamelContext = context.getManagedCamelContext();	if (managedCamelContext == null) {	
cannot dump route coverage to file as jmx is not enabled override usejmx method to enable jmx in the unit test classes 

String name = className + "-" + getTestMethodName() + ".xml";	ManagedCamelContextMBean managedCamelContext = context.getManagedCamelContext();	if (managedCamelContext == null) {	} else {	logCoverageSummary(managedCamelContext);	String xml = managedCamelContext.dumpRoutesCoverageAsXml();	String combined = "<camelRouteCoverage>\n" + gatherTestDetailsAsXml() + xml + "\n</camelRouteCoverage>";	File file = new File(dir);	file.mkdirs();	file = new File(dir, name);	
dumping route coverage to file 

InputStream is = new ByteArrayInputStream(combined.getBytes());	OutputStream os = new FileOutputStream(file, false);	IOHelper.copyAndCloseInput(is, os);	IOHelper.close(os);	}	}	log.info("********************************************************************************");	if (isCreateCamelContextPerClass()) {	return;	}	
teardown test 

public static void tearDownAfterClass() throws Exception {	INIT.remove();	
teardownafterclass test 

protected Context createJndiContext() throws Exception {	Properties properties = new Properties();	InputStream in = getClass().getClassLoader().getResourceAsStream("jndi.properties");	if (in != null) {	
using jndi properties from classpath root 

========================= camel sample_6835 =========================

public void process(Exchange exchange) throws Exception {	Object body = exchange.getIn().getBody();	if (body != null) {	Address destinationAddress = exchange.getIn().getHeader(JGroupsEndpoint.HEADER_JGROUPS_DEST, Address.class);	Address sourceAddress = exchange.getIn().getHeader(JGroupsEndpoint.HEADER_JGROUPS_SRC, Address.class);	
posting to cluster 

public void process(Exchange exchange) throws Exception {	Object body = exchange.getIn().getBody();	if (body != null) {	Address destinationAddress = exchange.getIn().getHeader(JGroupsEndpoint.HEADER_JGROUPS_DEST, Address.class);	Address sourceAddress = exchange.getIn().getHeader(JGroupsEndpoint.HEADER_JGROUPS_SRC, Address.class);	if (destinationAddress != null) {	
posting to custom destination address 

public void process(Exchange exchange) throws Exception {	Object body = exchange.getIn().getBody();	if (body != null) {	Address destinationAddress = exchange.getIn().getHeader(JGroupsEndpoint.HEADER_JGROUPS_DEST, Address.class);	Address sourceAddress = exchange.getIn().getHeader(JGroupsEndpoint.HEADER_JGROUPS_SRC, Address.class);	if (destinationAddress != null) {	}	if (sourceAddress != null) {	
posting from custom source address 

Address destinationAddress = exchange.getIn().getHeader(JGroupsEndpoint.HEADER_JGROUPS_DEST, Address.class);	Address sourceAddress = exchange.getIn().getHeader(JGroupsEndpoint.HEADER_JGROUPS_SRC, Address.class);	if (destinationAddress != null) {	}	if (sourceAddress != null) {	}	Message message = new Message(destinationAddress, body);	message.setSrc(sourceAddress);	channel.send(message);	} else {	
body is null cannot post to channel 

========================= camel sample_16934 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SalesforceComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.salesforce.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.salesforce.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_794 =========================

public void testXSLTProxy() throws Exception {	send("http: StopWatch watch = new StopWatch();	
http log warn ms count watch taken 

========================= camel sample_6423 =========================

exchange.setException(new RuntimeCamelException("OData HTTP Request cancelled!"));	callback.done(false);	}	});	final ApiMethod method = findMethod(exchange, properties);	if (method == null) {	callback.done(true);	return true;	}	if (LOG.isDebugEnabled()) {	
invoking operation with 

========================= camel sample_15477 =========================

private static InputStream toInputStream(ExecResult execResult) throws FileNotFoundException {	if (execResult == null) {	
received a null execresult instance to convert 

private static InputStream toInputStream(ExecResult execResult) throws FileNotFoundException {	if (execResult == null) {	return null;	}	InputStream result;	if (execResult.getCommand().getOutFile() != null) {	result = new FileInputStream(execResult.getCommand().getOutFile());	} else {	if (execResult.getStdout() == null && execResult.getCommand().isUseStderrOnEmptyStdout()) {	
execresult has no stdout will fallback to use stderr 

private static void resetIfByteArrayInputStream(InputStream stream) {	if (stream instanceof ByteArrayInputStream) {	try {	stream.reset();	} catch (IOException ioe) {	
unable to reset the stream 

========================= camel sample_12218 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<MetricsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.metrics.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.metrics.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_452 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<IgniteCacheComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ignite-cache.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ignite-cache.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1165 =========================

public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {	Exchange exchange = oldExchange;	if (exchange == null) {	exchange = ExchangeHelper.createCorrelatedCopy(newExchange, true);	injector.prepareAggregationExchange(exchange);	}	if (conditionPredicate != null && !conditionPredicate.matches(newExchange)) {	
dropped exchange from aggregation as predicate was not matched 

}	E picked = null;	try {	picked = pickExpression.evaluate(newExchange, castAs);	} catch (TypeConversionException exception) {	if (!ignoreInvalidCasts) {	throw exception;	}	}	if (picked == null && !storeNulls) {	
dropped exchange from aggregation as pick expression returned null and storing nulls is not enabled 

private Collection<E> safeInsertIntoCollection(Exchange oldExchange, Collection<E> oldValue, E toInsert) {	Collection<E> collection = null;	try {	if (oldValue == null || oldExchange.getProperty(Exchange.AGGREGATED_COLLECTION_GUARD, Boolean.class) == null) {	try {	collection = collectionType.newInstance();	} catch (Exception e) {	
could not instantiate collection of type aborting aggregation 

========================= camel sample_4367 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<XMLTokenizeLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.xtokenize.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.xtokenize.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_901 =========================

public void process(final Exchange exchange) throws Exception {	org.springframework.messaging.Message<?> request = SpringIntegrationBinding.createSpringIntegrationMessage(exchange);	if (exchange.getPattern().isOutCapable()) {	exchange.getIn().getHeaders().put(MessageHeaders.REPLY_CHANNEL, replyChannel);	if (replyChannel == null) {	throw new IllegalArgumentException("ReplyChannel has not been configured on: " + this);	}	replyChannel.subscribe(new MessageHandler() {	public void handleMessage(Message<?> message) {	
received from replychannel 

========================= camel sample_11121 =========================

public void testDisruptorQueue() throws Exception {	final CountDownLatch latch = new CountDownLatch(1);	final CamelContext context = new DefaultCamelContext();	context.addRoutes(new RouteBuilder() {	public void configure() {	from("disruptor:test.a").to("disruptor:test.b");	from("disruptor:test.b").process(new Processor() {	public void process(final Exchange e) {	
received exchange 

public void testThatShowsEndpointResolutionIsNotConsistent() throws Exception {	final CountDownLatch latch = new CountDownLatch(1);	final CamelContext context = new DefaultCamelContext();	context.addRoutes(new RouteBuilder() {	public void configure() {	from("disruptor:test.a").to("disruptor:test.b");	from("disruptor:test.b").process(new Processor() {	public void process(final Exchange e) {	
received exchange 

========================= camel sample_10730 =========================

protected void doStart() throws Exception {	super.doStart();	DistributedGroup group = getAtomixEndpoint().getAtomix().getGroup( groupName, new DistributedGroup.Config(getAtomixEndpoint().getConfiguration().getResourceOptions(groupName)), new DistributedGroup.Options(getAtomixEndpoint().getConfiguration().getResourceConfig(groupName)) ).join();	this.localMember = group.join(memberName).join();	this.consumer = localMember.messaging().consumer(channelName);	
subscribe to group member channel 

========================= camel sample_10360 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<DrillComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.drill.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.drill.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_517 =========================

protected void doStart() throws Exception {	super.doStart();	if (transformerFactory == null) {	createTransformerFactory();	}	if (rules == null) {	try {	
reading schematron rules from class path 

protected void doStart() throws Exception {	super.doStart();	if (transformerFactory == null) {	createTransformerFactory();	}	if (rules == null) {	try {	InputStream schRules = ResourceHelper.resolveMandatoryResourceAsInputStream(getCamelContext(), path);	rules = TemplatesFactory.newInstance().getTemplates(schRules, transformerFactory);	} catch (Exception classPathException) {	
error loading schematron rules from class path attempting file system 

}	if (rules == null) {	try {	InputStream schRules = ResourceHelper.resolveMandatoryResourceAsInputStream(getCamelContext(), path);	rules = TemplatesFactory.newInstance().getTemplates(schRules, transformerFactory);	} catch (Exception classPathException) {	try {	InputStream schRules = FileUtils.openInputStream(new File(path));	rules = TemplatesFactory.newInstance().getTemplates(schRules, transformerFactory);	} catch (FileNotFoundException e) {	
schematron rules not found in the file system 

rules = TemplatesFactory.newInstance().getTemplates(schRules, transformerFactory);	} catch (Exception classPathException) {	try {	InputStream schRules = FileUtils.openInputStream(new File(path));	rules = TemplatesFactory.newInstance().getTemplates(schRules, transformerFactory);	} catch (FileNotFoundException e) {	throw classPathException;	}	}	if (rules == null) {	
failed to load schematron rules 

private void createTransformerFactory() throws ClassNotFoundException {	Class<TransformerFactory> factoryClass = getCamelContext().getClassResolver().resolveMandatoryClass(SAXON_TRANSFORMER_FACTORY_CLASS_NAME, TransformerFactory.class, SchematronComponent.class.getClassLoader());	
using transformerfactoryclass 

========================= camel sample_11988 =========================

File fileLocalPath = new File(localPath);	if (fileLocalPath.isFile()) {	if (entry != null) {	throw new DropboxException(dropboxPath + " exists on dropbox and is not a file!");	}	if (entry == null) {	if (dropboxPath.endsWith(DropboxConstants.DROPBOX_FILE_SEPARATOR)) {	dropboxPath = dropboxPath + fileLocalPath.getName();	}	}	
uploading 

if (uploadedFile == null) {	result = new DropboxFileUploadResult(dropboxPath, DropboxResultCode.KO);	} else {	result = new DropboxFileUploadResult(dropboxPath, DropboxResultCode.OK);	}	} catch (Exception ex) {	result = new DropboxFileUploadResult(dropboxPath, DropboxResultCode.KO);	}	return result;	} else if (fileLocalPath.isDirectory()) {	
uploading a dir 

HashMap<String, DropboxResultCode> resultMap = new HashMap<>(listFiles.size());	for (File file : listFiles) {	String absPath = file.getAbsolutePath();	int indexRemainingPath = localPath.length();	if (!localPath.endsWith("/")) {	indexRemainingPath += 1;	}	String remainingPath = absPath.substring(indexRemainingPath);	dropboxPath = dropboxPath + remainingPath;	try {	
uploading 

name = exchange.getIn().getHeader(Exchange.FILE_NAME, String.class);	}	if (name == null) {	name = exchange.getIn().getMessageId();	}	if (entry == null) {	if (dropboxPath.endsWith(DropboxConstants.DROPBOX_FILE_SEPARATOR)) {	dropboxPath = dropboxPath + name;	}	}	
uploading message body 

public DropboxSearchResult search(String remotePath, String query) throws DropboxException {	SearchResult listing;	List<SearchMatch> searchMatches;	if (query == null) {	
search no query 

List<SearchMatch> searchMatches;	if (query == null) {	try {	listing = client.files().search(remotePath, null);	searchMatches = listing.getMatches();	return new DropboxSearchResult(searchMatches);	} catch (DbxException e) {	throw new DropboxException(remotePath + " does not exist or can't obtain metadata");	}	} else {	
search by query 

for (Metadata entry : folderResult.getEntries()) {	returnMap.put(entry.getPathDisplay(), downloadSingleFile(entry.getPathDisplay()).getValue());	}	return returnMap;	} catch (ListFolderErrorException e) {	try {	DbxDownloader<FileMetadata> listing = client.files().download(path);	if (listing == null) {	return Collections.emptyMap();	} else {	
downloading a single file 

========================= camel sample_8485 =========================

public void testRedirect() throws Exception {	HttpGet get = new HttpGet("http: RequestConfig requestconfig = RequestConfig.custom().setRedirectsEnabled(false).build();	CloseableHttpClient client = HttpClientBuilder.create().setDefaultRequestConfig(requestconfig).build();	try {	HttpResponse response = client.execute(get);	for (Header header : response.getAllHeaders()) {	
header 

========================= camel sample_9294 =========================

Snapshots snapshots;	if (ObjectHelper.isNotEmpty(type)) {	if (type == DigitalOceanSnapshotTypes.droplet) {	snapshots = getEndpoint().getDigitalOceanClient().getAllDropletSnapshots(configuration.getPage(), configuration.getPerPage());	} else {	snapshots = getEndpoint().getDigitalOceanClient().getAllVolumeSnapshots(configuration.getPage(), configuration.getPerPage());	}	} else {	snapshots = getEndpoint().getDigitalOceanClient().getAvailableSnapshots(configuration.getPage(), configuration.getPerPage());	}	
all snapshots page per page 

private void getSnapshot(Exchange exchange) throws Exception {	String snapshotId = exchange.getIn().getHeader(DigitalOceanHeaders.ID, String.class);	if (ObjectHelper.isEmpty(snapshotId)) {	throw new IllegalArgumentException(DigitalOceanHeaders.ID + " must be specified");	}	Snapshot snapshot = getEndpoint().getDigitalOceanClient().getSnaphotInfo(snapshotId);	
snapshot 

private void deleteSnapshot(Exchange exchange) throws Exception {	String snapshotId = exchange.getIn().getHeader(DigitalOceanHeaders.ID, String.class);	if (ObjectHelper.isEmpty(snapshotId)) {	throw new IllegalArgumentException(DigitalOceanHeaders.ID + " must be specified");	}	Delete delete = getEndpoint().getDigitalOceanClient().deleteSnapshot(snapshotId);	
delete snapshot 

========================= camel sample_8893 =========================

public boolean process(final Exchange exchange, final AsyncCallback callback) {	executor.submit(new Callable<Object>() {	public Object call() throws Exception {	
simulating a task which takes millis to reply 

public boolean process(final Exchange exchange, final AsyncCallback callback) {	executor.submit(new Callable<Object>() {	public Object call() throws Exception {	Thread.sleep(getEndpoint().getDelay());	int count = counter.incrementAndGet();	if (getEndpoint().getFailFirstAttempts() >= count) {	
simulating a failure at attempt 

executor.submit(new Callable<Object>() {	public Object call() throws Exception {	Thread.sleep(getEndpoint().getDelay());	int count = counter.incrementAndGet();	if (getEndpoint().getFailFirstAttempts() >= count) {	exchange.setException(new CamelExchangeException("Simulated error at attempt " + count, exchange));	} else {	String reply = getEndpoint().getReply();	exchange.getOut().setBody(reply);	exchange.getOut().setHeaders(exchange.getIn().getHeaders());	
setting reply 

public Object call() throws Exception {	Thread.sleep(getEndpoint().getDelay());	int count = counter.incrementAndGet();	if (getEndpoint().getFailFirstAttempts() >= count) {	exchange.setException(new CamelExchangeException("Simulated error at attempt " + count, exchange));	} else {	String reply = getEndpoint().getReply();	exchange.getOut().setBody(reply);	exchange.getOut().setHeaders(exchange.getIn().getHeaders());	}	
callback done false 

exchange.setException(new CamelExchangeException("Simulated error at attempt " + count, exchange));	} else {	String reply = getEndpoint().getReply();	exchange.getOut().setBody(reply);	exchange.getOut().setHeaders(exchange.getIn().getHeaders());	}	callback.done(false);	return null;	}	});	
task submitted now tell camel routing engine to that this exchange is being continued asynchronously 

========================= camel sample_6927 =========================

protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {	Map<String, Endpoint> map = getLocalCamelContext().getEndpointMap();	if (LOG.isTraceEnabled()) {	
trying to lookup in local map 

endpoint = map.get(newUri);	if (endpoint != null) {	logUsingEndpoint(uri, endpoint);	return new ContextEndpoint(uri, this, endpoint);	}	}	}	throw new ResolveEndpointFailedException("Cannot find the endpoint with uri " + uri + " in the CamelContext " + getLocalCamelContext().getName());	}	protected void logUsingEndpoint(String uri, Endpoint endpoint) {	
mapping the uri to local endpoint 

========================= camel sample_12166 =========================

name = exchange.getContext().getName();	}	boolean match = true;	if (contextIdPattern != null) {	if ("#name#".equals(contextIdPattern)) {	match = name.equals(contextId);	} else {	match = EndpointHelper.matchPattern(name, contextIdPattern);	}	if (LOG.isDebugEnabled()) {	
match contextid with pattern 

if (LOG.isDebugEnabled()) {	}	}	if (!match) {	adapter.noContent();	} else {	support.renderResourceListing(adapter, swaggerConfig, name, route, json, yaml, exchange.getContext().getClassResolver(), configuration);	}	}	} catch (Exception e) {	
error rendering swagger api due 

========================= camel sample_17364 =========================

public void findScriptEngines() throws IOException {	Enumeration<URL> urls = getClass().getClassLoader().getResources(Activator.META_INF_SERVICES_DIR + "/" + Activator.SCRIPT_ENGINE_SERVICE_FILE);	assertThat(urls.hasMoreElements(), is(true));	while (urls.hasMoreElements()) {	URL url = urls.nextElement();	
found 

========================= camel sample_11199 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<VertxComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.vertx.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.vertx.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_956 =========================

public boolean startConsumer(Consumer consumer) throws Exception {	ServiceHelper.startService(consumer);	
started consumer 

public boolean stopConsumer(Consumer consumer) throws Exception {	ServiceHelper.stopAndShutdownServices(consumer);	
stopped consumer 

public boolean suspendOrStopConsumer(Consumer consumer) throws Exception {	if (consumer instanceof Suspendable) {	boolean suspended = ServiceHelper.suspendService(consumer);	if (suspended) {	
suspended consumer 

public boolean suspendOrStopConsumer(Consumer consumer) throws Exception {	if (consumer instanceof Suspendable) {	boolean suspended = ServiceHelper.suspendService(consumer);	if (suspended) {	} else {	
consumer already suspended 

public boolean suspendOrStopConsumer(Consumer consumer) throws Exception {	if (consumer instanceof Suspendable) {	boolean suspended = ServiceHelper.suspendService(consumer);	if (suspended) {	} else {	}	return suspended;	}	if (!ServiceHelper.isStopped(consumer)) {	ServiceHelper.stopService(consumer);	
stopped consumer 

public boolean resumeOrStartConsumer(Consumer consumer) throws Exception {	if (consumer instanceof Suspendable) {	boolean resumed = ServiceHelper.resumeService(consumer);	if (resumed) {	
resumed consumer 

public boolean resumeOrStartConsumer(Consumer consumer) throws Exception {	if (consumer instanceof Suspendable) {	boolean resumed = ServiceHelper.resumeService(consumer);	if (resumed) {	} else {	
consumer already resumed 

public boolean resumeOrStartConsumer(Consumer consumer) throws Exception {	if (consumer instanceof Suspendable) {	boolean resumed = ServiceHelper.resumeService(consumer);	if (resumed) {	} else {	}	return resumed;	}	if (!ServiceHelper.isStarted(consumer)) {	ServiceHelper.startService(consumer);	
started consumer 

========================= camel sample_5171 =========================

protected void doStart() throws Exception {	if (xmlMapper == null) {	xmlMapper = new XmlMapper();	}	if (enableJaxbAnnotationModule) {	JaxbAnnotationModule module = new JaxbAnnotationModule();	
registering module 

MapperFeature mf = getCamelContext().getTypeConverter().tryConvertTo(MapperFeature.class, disable);	if (mf != null) {	xmlMapper.disable(mf);	continue;	}	throw new IllegalArgumentException("Disable feature: " + disable + " cannot be converted to an accepted enum of types [SerializationFeature,DeserializationFeature,MapperFeature]");	}	}	if (modules != null) {	for (Module module : modules) {	
registering module 

for (Module module : modules) {	xmlMapper.registerModules(module);	}	}	if (moduleClassNames != null) {	Iterable<Object> it = ObjectHelper.createIterable(moduleClassNames);	for (Object o : it) {	String name = o.toString();	Class<Module> clazz = camelContext.getClassResolver().resolveMandatoryClass(name, Module.class);	Module module = camelContext.getInjector().newInstance(clazz);	
registering module 

}	}	if (moduleRefs != null) {	Iterable<Object> it = ObjectHelper.createIterable(moduleRefs);	for (Object o : it) {	String name = o.toString();	if (name.startsWith("#")) {	name = name.substring(1);	}	Module module = CamelContextHelper.mandatoryLookup(camelContext, name, Module.class);	
registering module 

for (Object o : it) {	String name = o.toString();	if (name.startsWith("#")) {	name = name.substring(1);	}	Module module = CamelContextHelper.mandatoryLookup(camelContext, name, Module.class);	xmlMapper.registerModule(module);	}	}	if (ObjectHelper.isNotEmpty(timezone)) {	
setting timezone to xml mapper 

========================= camel sample_10622 =========================

if (isTrimmingNeededAndEnabled(factory, myLine)) {	myLine = myLine.substring(0, factory.recordLength());	}	if ((myLine.length() < factory.recordLength() && !factory.isIgnoreMissingChars()) || (myLine.length() > factory.recordLength())) {	throw new java.lang.IllegalArgumentException("Size of the record: " + myLine.length() + " is not equal to the value provided in the model: " + factory.recordLength());	}	}	Map<String, Object> model = factory.factory();	factory.bind(getCamelContext(), myLine, model, count);	factory.link(model);	
graph of objects created 

========================= camel sample_7459 =========================

public void testSendMultipleMessages() throws Exception {	int messageCount = 500;	acknowledged.expectedMessageCount(messageCount);	timeout.expectedMessageCount(0);	frame.expectedMessageCount(0);	ae.expectedMessageCount(0);	ar.expectedMessageCount(0);	startCamelContext();	for (int i = 0; i < messageCount; ++i) {	
triggering message 

public void testSendMultipleMessages() throws Exception {	int messageCount = 500;	acknowledged.expectedMessageCount(messageCount);	timeout.expectedMessageCount(0);	frame.expectedMessageCount(0);	ae.expectedMessageCount(0);	ar.expectedMessageCount(0);	startCamelContext();	for (int i = 0; i < messageCount; ++i) {	Object response = template.requestBodyAndHeader(SOURCE_URI, Hl7TestMessageGenerator.generateMessage(i), "CamelMllpMessageControlId", String.format("%05d", i));	
response 

========================= camel sample_13848 =========================

public static boolean isOsgiContext(CamelContext camelContext) {	String contextType = camelContext.getClass().getSimpleName();	if (contextType.startsWith("Osgi") || contextType.equals("BlueprintCamelContext")) {	
used assuming running in the osgi container 

public static boolean isOsgiContext(CamelContext camelContext) {	String contextType = camelContext.getClass().getSimpleName();	if (contextType.startsWith("Osgi") || contextType.equals("BlueprintCamelContext")) {	return true;	} else {	
used assuming running in the osgi container 

========================= camel sample_4275 =========================

break;	case TRACE: if (log.isTraceEnabled()) {	log.trace(logMessage(exchange));	}	break;	case WARN: if (log.isWarnEnabled()) {	log.warn(logMessage(exchange));	}	break;	case OFF: break;	
unknown level when trying to log exchange 

break;	case TRACE: if (log.isTraceEnabled()) {	log.trace(logMessage(exchange), exception);	}	break;	case WARN: if (log.isWarnEnabled()) {	log.warn(logMessage(exchange), exception);	}	break;	case OFF: break;	
unknown level when trying to log exchange 

break;	case TRACE: if (log.isTraceEnabled()) {	log.trace(logMessage(exchange, message));	}	break;	case WARN: if (log.isWarnEnabled()) {	log.warn(logMessage(exchange, message));	}	break;	case OFF: break;	
unknown level when trying to log exchange 

========================= camel sample_4432 =========================

private RestClient connectToSalesforce() throws MojoExecutionException {	RestClient restClient = null;	try {	final SalesforceHttpClient httpClient = createHttpClient();	
logging in to salesforce 

RestClient restClient = null;	try {	final SalesforceHttpClient httpClient = createHttpClient();	final SalesforceSession session = httpClient.getSession();	try {	session.login(null);	} catch (final SalesforceException e) {	final String msg = "Salesforce login error " + e.getMessage();	throw new MojoExecutionException(msg, e);	}	
salesforce login successful 

private void disconnectFromSalesforce(final RestClient restClient) {	if (restClient == null) {	return;	}	try {	final SalesforceHttpClient httpClient = (SalesforceHttpClient) ((DefaultRestClient) restClient) .getHttpClient();	ServiceHelper.stopAndShutdownServices(restClient, httpClient.getSession(), httpClient);	} catch (final Exception e) {	
error stopping salesforce http client 

========================= camel sample_14925 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<Sjms2Component> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.sjms2.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.sjms2.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_612 =========================

mockEndpointB.expectedBodiesReceived(expectedBody);	invokeHttpEndpoint();	mockEndpointA.assertIsSatisfied();	mockEndpointB.assertIsSatisfied();	List<Exchange> list = mockEndpointA.getReceivedExchanges();	Exchange exchange = list.get(0);	assertNotNull("exchange", exchange);	Message in = exchange.getIn();	assertNotNull("in", in);	Map<String, Object> headers = in.getHeaders();	
headers 

========================= camel sample_10966 =========================

protected RouteBuilder createRouteBuilder() {	return new RouteBuilder() {	public void configure() {	
mock result 

========================= camel sample_3898 =========================

protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {	CxfEndpoint result;	Object value = parameters.remove("setDefaultBus");	if (value != null) {	
the option setdefaultbus is deprecated use name defaultbus instead 

========================= camel sample_7971 =========================

public void testSendMessageToBadLevel() throws Exception {	try {	template.sendBody("log:org.apache.camel.TEST?level=noSuchLevel", "<level>noSuchLevel</level>");	fail("Should have failed!");	} catch (Exception e) {	
caught expected exception 

========================= camel sample_3524 =========================

public Expression getTempFileName() {	
creation of temporary files not supported by the scp protocol 

========================= camel sample_9129 =========================

protected Component getComponent(String name, CamelContext context) throws Exception {	
finding component 

========================= camel sample_13075 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<AsteriskComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.asterisk.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.asterisk.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1149 =========================

public void doStart() throws Exception {	super.doStart();	s3Client = configuration.getAmazonS3Client() != null ? configuration.getAmazonS3Client() : createS3Client();	if (ObjectHelper.isNotEmpty(configuration.getAmazonS3Endpoint())) {	s3Client.setEndpoint(configuration.getAmazonS3Endpoint());	}	String fileName = getConfiguration().getFileName();	if (fileName != null) {	
file name requested so skipping bucket check 

super.doStart();	s3Client = configuration.getAmazonS3Client() != null ? configuration.getAmazonS3Client() : createS3Client();	if (ObjectHelper.isNotEmpty(configuration.getAmazonS3Endpoint())) {	s3Client.setEndpoint(configuration.getAmazonS3Endpoint());	}	String fileName = getConfiguration().getFileName();	if (fileName != null) {	return;	}	String bucketName = getConfiguration().getBucketName();	
querying whether bucket already exists 

s3Client.setEndpoint(configuration.getAmazonS3Endpoint());	}	String fileName = getConfiguration().getFileName();	if (fileName != null) {	return;	}	String bucketName = getConfiguration().getBucketName();	String prefix = getConfiguration().getPrefix();	try {	s3Client.listObjects(new ListObjectsRequest(bucketName, prefix, null, null, 0));	
bucket already exists 

String bucketName = getConfiguration().getBucketName();	String prefix = getConfiguration().getPrefix();	try {	s3Client.listObjects(new ListObjectsRequest(bucketName, prefix, null, null, 0));	return;	} catch (AmazonServiceException ase) {	if (ase.getStatusCode() != 404) {	throw ase;	}	}	
bucket doesn t exist yet 

String prefix = getConfiguration().getPrefix();	try {	s3Client.listObjects(new ListObjectsRequest(bucketName, prefix, null, null, 0));	return;	} catch (AmazonServiceException ase) {	if (ase.getStatusCode() != 404) {	throw ase;	}	}	CreateBucketRequest createBucketRequest = new CreateBucketRequest(getConfiguration().getBucketName());	
creating bucket in region with request 

try {	s3Client.listObjects(new ListObjectsRequest(bucketName, prefix, null, null, 0));	return;	} catch (AmazonServiceException ase) {	if (ase.getStatusCode() != 404) {	throw ase;	}	}	CreateBucketRequest createBucketRequest = new CreateBucketRequest(getConfiguration().getBucketName());	s3Client.createBucket(createBucketRequest);	
bucket created 

s3Client.listObjects(new ListObjectsRequest(bucketName, prefix, null, null, 0));	return;	} catch (AmazonServiceException ase) {	if (ase.getStatusCode() != 404) {	throw ase;	}	}	CreateBucketRequest createBucketRequest = new CreateBucketRequest(getConfiguration().getBucketName());	s3Client.createBucket(createBucketRequest);	if (configuration.getPolicy() != null) {	
updating bucket with policy 

return;	} catch (AmazonServiceException ase) {	if (ase.getStatusCode() != 404) {	throw ase;	}	}	CreateBucketRequest createBucketRequest = new CreateBucketRequest(getConfiguration().getBucketName());	s3Client.createBucket(createBucketRequest);	if (configuration.getPolicy() != null) {	s3Client.setBucketPolicy(bucketName, configuration.getPolicy());	
bucket policy updated 

public Exchange createExchange(ExchangePattern pattern, S3Object s3Object) {	
getting object with key from bucket 

public Exchange createExchange(ExchangePattern pattern, S3Object s3Object) {	ObjectMetadata objectMetadata = s3Object.getObjectMetadata();	
got object 

========================= camel sample_8692 =========================

public Source resolve(String href, String base) throws TransformerException {	if (ObjectHelper.isEmpty(href)) {	href = location;	}	if (ObjectHelper.isEmpty(href)) {	throw new TransformerException("include href is empty");	}	
resolving uri with href and base 

if (ObjectHelper.isEmpty(href)) {	throw new TransformerException("include href is empty");	}	String scheme = ResourceHelper.getScheme(href);	if (scheme != null) {	if ("file:".equals(scheme)) {	href = FileUtil.compactPath(href);	} else if ("classpath:".equals(scheme)) {	href = FileUtil.compactPath(href, '/');	}	
resolving uri from 

========================= camel sample_5624 =========================

resolverFactory = new DefaultXsltUriResolverFactory();	}	resolver = resolverFactory.createUriResolver(getCamelContext(), remaining);	}	endpoint.setUriResolver(resolver);	setProperties(endpoint, parameters);	String resourceUri = remaining;	if (ResourceHelper.isHttpUri(resourceUri)) {	resourceUri = ResourceHelper.appendParameters(resourceUri, parameters);	}	
using schema resource 

========================= camel sample_4936 =========================

public void testGetGroup() throws Exception {	final org.apache.camel.component.linkedin.api.model.Group result = requestBody("direct: assertNotNull("getGroup result", result);	
getgroup 

========================= camel sample_8850 =========================

String userName = configuration.getUsername();	Object userNameHeaderObj = headers.get(SshConstants.USERNAME_HEADER);	if (userNameHeaderObj instanceof String) {	userName = (String) headers.get(SshConstants.USERNAME_HEADER);	}	ConnectFuture connectFuture = client.connect(userName, configuration.getHost(), configuration.getPort());	connectFuture.await(configuration.getTimeout());	if (!connectFuture.isDone() || !connectFuture.isConnected()) {	throw new RuntimeCamelException("Failed to connect to " + configuration.getHost() + ":" + configuration.getPort() + " within timeout " + configuration.getTimeout() + "ms");	}	
connected to 

throw new RuntimeCamelException("Failed to connect to " + configuration.getHost() + ":" + configuration.getPort() + " within timeout " + configuration.getTimeout() + "ms");	}	ClientChannel channel = null;	ClientSession session = null;	try {	AuthFuture authResult;	session = connectFuture.getSession();	KeyPairProvider keyPairProvider;	final String certResource = configuration.getCertResource();	if (certResource != null) {	
attempting to authenticate using resourcekey 

AuthFuture authResult;	session = connectFuture.getSession();	KeyPairProvider keyPairProvider;	final String certResource = configuration.getCertResource();	if (certResource != null) {	keyPairProvider = new ResourceHelperKeyPairProvider(new String[]{certResource}, endpoint.getCamelContext().getClassResolver());	} else {	keyPairProvider = configuration.getKeyPairProvider();	}	if (keyPairProvider != null) {	
attempting to authenticate username using a key identity 

}	if (keyPairProvider != null) {	KeyPair pair = keyPairProvider.loadKey(configuration.getKeyType());	session.addPublicKeyIdentity(pair);	} else {	String password = configuration.getPassword();	Object passwordHeaderObj = headers.get(SshConstants.PASSWORD_HEADER);	if (passwordHeaderObj instanceof String) {	password = (String) headers.get(SshConstants.PASSWORD_HEADER);	}	
attempting to authenticate username using a password identity 

String password = configuration.getPassword();	Object passwordHeaderObj = headers.get(SshConstants.PASSWORD_HEADER);	if (passwordHeaderObj instanceof String) {	password = (String) headers.get(SshConstants.PASSWORD_HEADER);	}	session.addPasswordIdentity(password);	}	authResult = session.auth();	authResult.await(configuration.getTimeout());	if (!authResult.isDone() || authResult.isFailure()) {	
failed to authenticate 

========================= camel sample_10032 =========================

protected int poll() throws Exception {	Exchange exchange = endpoint.createExchange();	DropboxSearchResult result = new DropboxAPIFacade(configuration.getClient(), exchange) .search(configuration.getRemotePath(), configuration.getQuery());	StringBuilder fileExtracted = new StringBuilder();	for (SearchMatch entry : result.getFound()) {	fileExtracted.append(entry.getMetadata().getName()).append("-").append(entry.getMetadata().getPathDisplay()).append("\n");	}	exchange.getIn().setHeader(DropboxResultHeader.FOUND_FILES.name(), fileExtracted.toString());	exchange.getIn().setBody(result.getFound());	if (LOG.isDebugEnabled()) {	
downloaded 

========================= camel sample_8503 =========================

SalesforceUpsertContactComponent connector = new SalesforceUpsertContactComponent();	connector.setCamelContext(camelContext);	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, connector, parameters, false);	connector.setOptions(parameters);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ConnectorCustomizer<SalesforceUpsertContactComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.connector.customizer", "camel.connector.salesforce-upsert-contact.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.connector.customizer", "camel.connector.salesforce-upsert-contact.customizer");	if (useCustomizer) {	
configure connector with customizer 

SalesforceUpsertContactComponent connector = new SalesforceUpsertContactComponent( entry.getKey());	connector.setCamelContext(camelContext);	try {	IntrospectionSupport.getProperties(entry.getValue(), parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, connector, parameters, false);	connector.setOptions(parameters);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ConnectorCustomizer<SalesforceUpsertContactComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.connector.customizer", "camel.connector.salesforce-upsert-contact." + entry.getKey() + ".customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.connector.customizer", "camel.connector.salesforce-upsert-contact." + entry.getKey() + ".customizer");	if (useCustomizer) {	
configure connector with customizer 

========================= camel sample_35 =========================

public void testCapture() {	
testError 

========================= camel sample_10198 =========================

if (bean instanceof Component) {	return (Component) bean;	} else {	Component component = CamelContextHelper.convertTo(context, Component.class, bean);	if (component != null) {	return component;	}	}	}	if (bean != null) {	
found component with incompatible class 

public static DataFormat lookupDataFormatInRegistryWithFallback(CamelContext context, String name, LookupExceptionHandler exceptionHandler) {	Object bean = lookupInRegistry(context, DataFormat.class, false, exceptionHandler, name, name + DATA_FORMAT_FALLBACK_SUFFIX);	if (bean instanceof DataFormat) {	return (DataFormat) bean;	}	if (bean != null) {	
found dataformat with incompatible class 

public static DataFormatFactory lookupDataFormatFactoryInRegistryWithFallback(CamelContext context, String name, LookupExceptionHandler exceptionHandler) {	Object bean = lookupInRegistry(context, DataFormatFactory.class, false, exceptionHandler, name, name + DATA_FORMAT_FACTORY_FALLBACK_SUFFIX);	if (bean instanceof DataFormatFactory) {	return (DataFormatFactory) bean;	}	if (bean != null) {	
found dataformatfactory with incompatible class 

public static Language lookupLanguageInRegistryWithFallback(CamelContext context, String name, LookupExceptionHandler exceptionHandler) {	Object bean = lookupInRegistry(context, Language.class, false, exceptionHandler, name, name + LANGUAGE_FALLBACK_SUFFIX);	if (bean instanceof Language) {	return (Language) bean;	}	if (bean != null) {	
found language with incompatible class 

private static Object lookupInRegistry(CamelContext context, Class<?> type, boolean lookupByNameAndType, LookupExceptionHandler exceptionHandler, String... names) {	for (String name : names) {	try {	Object bean;	if (lookupByNameAndType) {	bean = context.getRegistry().lookupByNameAndType(name, type);	} else {	bean = context.getRegistry().lookupByName(name);	}	
lookup with name in registry found 

========================= camel sample_4259 =========================

public static void copy(MllpConfiguration source, MllpConfiguration target) {	if (source == null) {	
values were not copied by mllpconfiguration copy mllpconfiguration source mllpconfiguration target source argument is null 

public static void copy(MllpConfiguration source, MllpConfiguration target) {	if (source == null) {	} else if (target == null) {	
values were not copied by mllpconfiguration copy mllpconfiguration source mllpconfiguration target target argument is null 

========================= camel sample_13864 =========================

public int getPendingExchangesSize() {	int answer;	if (ShutdownRunningTask.CompleteAllTasks == shutdownRunningTask) {	answer = pendingExchanges;	} else {	answer = 0;	}	if (answer == 0 && isPolling()) {	
currently polling so returning as pending exchanges 

protected void processEmptyMessage() throws Exception {	Exchange exchange = getEndpoint().createExchange();	exchange.setProperty(Exchange.BATCH_INDEX, 0);	exchange.setProperty(Exchange.BATCH_SIZE, 1);	exchange.setProperty(Exchange.BATCH_COMPLETE, true);	
sending empty message as there were no messages from polling 

========================= camel sample_3965 =========================

public void testAsynchronous() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(100);	mock.expectsNoDuplicates(body());	StopWatch watch = new StopWatch();	for (int i = 0; i < 100; i++) {	template.sendBody("seda:start", "" + i);	}	assertMockEndpointsSatisfied(20, TimeUnit.SECONDS);	
took ms to process messages request reply over jms 

========================= camel sample_12326 =========================

public Object lookupByName(String name) {	notEmpty(name, "name");	
looking up bean with name 

public <T> T lookupByNameAndType(String name, Class<T> type) {	notEmpty(name, "name");	notNull(type, "type");	
looking up bean with name of type 

public <T> Map<String, T> findByTypeWithName(Class<T> type) {	notNull(type, "type");	
looking up named beans of type 

public <T> Set<T> findByType(Class<T> type) {	notNull(type, "type");	
looking up beans of type 

========================= camel sample_9938 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<XmlSignatureComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.xmlsecurity.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.xmlsecurity.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_583 =========================

public void oneMasterOneSlaveScenarioContolledByPolicy() throws Exception {	final String path = "oneMasterOneSlaveScenarioContolledByPolicy";	final String firstDestination = "first" + System.currentTimeMillis();	final String secondDestination = "second" + System.currentTimeMillis();	final CountDownLatch waitForSecondRouteCompletedLatch = new CountDownLatch(1);	final int activeNodesDesired = 1;	MultiMasterZookeeperPolicyEnforcedContext first = createEnforcedContext(firstDestination, activeNodesDesired, path);	DefaultCamelContext controlledContext = (DefaultCamelContext) first.controlledContext;	CuratorMultiMasterLeaderRoutePolicy routePolicy = (CuratorMultiMasterLeaderRoutePolicy) controlledContext.getRouteDefinition(firstDestination).getRoutePolicies().get(0);	assertWeHaveMasters(routePolicy);	
starting first camelcontext 

final int activeNodesDesired = 1;	MultiMasterZookeeperPolicyEnforcedContext first = createEnforcedContext(firstDestination, activeNodesDesired, path);	DefaultCamelContext controlledContext = (DefaultCamelContext) first.controlledContext;	CuratorMultiMasterLeaderRoutePolicy routePolicy = (CuratorMultiMasterLeaderRoutePolicy) controlledContext.getRouteDefinition(firstDestination).getRoutePolicies().get(0);	assertWeHaveMasters(routePolicy);	final MultiMasterZookeeperPolicyEnforcedContext[] arr = new MultiMasterZookeeperPolicyEnforcedContext[1];	new Thread() {	public void run() {	MultiMasterZookeeperPolicyEnforcedContext second = null;	try {	
starting second camelcontext in a separate thread 

final MultiMasterZookeeperPolicyEnforcedContext[] arr = new MultiMasterZookeeperPolicyEnforcedContext[1];	new Thread() {	public void run() {	MultiMasterZookeeperPolicyEnforcedContext second = null;	try {	second = createEnforcedContext(secondDestination, activeNodesDesired, path);	arr[0] = second;	second.sendMessageToEnforcedRoute("message for second", 0);	waitForSecondRouteCompletedLatch.countDown();	} catch (Exception e) {	
error in the thread controlling the second context 

arr[0] = second;	second.sendMessageToEnforcedRoute("message for second", 0);	waitForSecondRouteCompletedLatch.countDown();	} catch (Exception e) {	fail("Error in the thread controlling the second context: " + e.getMessage());	}	}	}.start();	first.sendMessageToEnforcedRoute("message for first", 1);	waitForSecondRouteCompletedLatch.await(2, TimeUnit.MINUTES);	
explicitly shutting down the first camel context 

arr[0] = second;	second.sendMessageToEnforcedRoute("message for second", 0);	waitForSecondRouteCompletedLatch.countDown();	} catch (Exception e) {	fail("Error in the thread controlling the second context: " + e.getMessage());	}	}	}.start();	first.sendMessageToEnforcedRoute("message for first", 1);	waitForSecondRouteCompletedLatch.await(2, TimeUnit.MINUTES);	
shutting down first con 

public void oneMasterOneSlaveAndFlippedAgainScenarioContolledByPolicy() throws Exception {	final String path = "oneMasterOneSlaveScenarioContolledByPolicy";	final String firstDestination = "first" + System.currentTimeMillis();	final String secondDestination = "second" + System.currentTimeMillis();	final CountDownLatch waitForSecondRouteCompletedLatch = new CountDownLatch(1);	final int activeNodeDesired = 1;	MultiMasterZookeeperPolicyEnforcedContext first = createEnforcedContext(firstDestination, activeNodeDesired, path);	DefaultCamelContext controlledContext = (DefaultCamelContext) first.controlledContext;	CuratorMultiMasterLeaderRoutePolicy routePolicy = (CuratorMultiMasterLeaderRoutePolicy) controlledContext.getRouteDefinition(firstDestination).getRoutePolicies().get(0);	assertWeHaveMasters(routePolicy);	
starting first camelcontext 

final int activeNodeDesired = 1;	MultiMasterZookeeperPolicyEnforcedContext first = createEnforcedContext(firstDestination, activeNodeDesired, path);	DefaultCamelContext controlledContext = (DefaultCamelContext) first.controlledContext;	CuratorMultiMasterLeaderRoutePolicy routePolicy = (CuratorMultiMasterLeaderRoutePolicy) controlledContext.getRouteDefinition(firstDestination).getRoutePolicies().get(0);	assertWeHaveMasters(routePolicy);	final MultiMasterZookeeperPolicyEnforcedContext[] arr = new MultiMasterZookeeperPolicyEnforcedContext[1];	new Thread() {	public void run() {	MultiMasterZookeeperPolicyEnforcedContext slave = null;	try {	
starting second camelcontext in a separate thread 

final MultiMasterZookeeperPolicyEnforcedContext[] arr = new MultiMasterZookeeperPolicyEnforcedContext[1];	new Thread() {	public void run() {	MultiMasterZookeeperPolicyEnforcedContext slave = null;	try {	slave = createEnforcedContext(secondDestination, activeNodeDesired, path);	arr[0] = slave;	slave.sendMessageToEnforcedRoute("message for second", 0);	waitForSecondRouteCompletedLatch.countDown();	} catch (Exception e) {	
error in the thread controlling the second context 

slave.sendMessageToEnforcedRoute("message for second", 0);	waitForSecondRouteCompletedLatch.countDown();	} catch (Exception e) {	fail("Error in the thread controlling the second context: " + e.getMessage());	}	}	}.start();	first.sendMessageToEnforcedRoute("message for first", 1);	waitForSecondRouteCompletedLatch.await(2, TimeUnit.MINUTES);	MultiMasterZookeeperPolicyEnforcedContext second = arr[0];	
explicitly shutting down the first camel context 

}	}	}.start();	first.sendMessageToEnforcedRoute("message for first", 1);	waitForSecondRouteCompletedLatch.await(2, TimeUnit.MINUTES);	MultiMasterZookeeperPolicyEnforcedContext second = arr[0];	first.shutdown();	DefaultCamelContext secondCamelContext = (DefaultCamelContext) second.controlledContext;	assertWeHaveMasters((CuratorMultiMasterLeaderRoutePolicy)secondCamelContext.getRouteDefinition(secondDestination).getRoutePolicies().get(0));	CountDownLatch restartFirstLatch = new CountDownLatch(1);	
start back first context 

}	}	}.start();	restartFirstLatch.await();	second.sendMessageToEnforcedRoute("message for second", 1);	first.mock.reset();	first.sendMessageToEnforcedRoute("message for first", 0);	second.shutdown();	controlledContext = (DefaultCamelContext) first.controlledContext;	routePolicy = (CuratorMultiMasterLeaderRoutePolicy) controlledContext.getRouteDefinition(firstDestination).getRoutePolicies().get(0);	
asserting route is up context 

public void oneMasterTwoSlavesScenarioContolledByPolicy() throws Exception {	final String path = "oneMasterTwoSlavesScenarioContolledByPolicy";	final String master = "master" + System.currentTimeMillis();	final String secondDestination = "second" + System.currentTimeMillis();	final String thirdDestination = "third" + System.currentTimeMillis();	final CountDownLatch waitForNonActiveRoutesLatch = new CountDownLatch(2);	final int activeNodesDesired = 1;	
starting first camelcontext 

final int activeNodesDesired = 1;	MultiMasterZookeeperPolicyEnforcedContext first = createEnforcedContext(master, activeNodesDesired, path);	DefaultCamelContext controlledContext = (DefaultCamelContext) first.controlledContext;	CuratorMultiMasterLeaderRoutePolicy routePolicy = (CuratorMultiMasterLeaderRoutePolicy) controlledContext.getRouteDefinition(master).getRoutePolicies().get(0);	assertWeHaveMasters(routePolicy);	final MultiMasterZookeeperPolicyEnforcedContext[] arr = new MultiMasterZookeeperPolicyEnforcedContext[2];	new Thread() {	public void run() {	MultiMasterZookeeperPolicyEnforcedContext second = null;	try {	
starting second camelcontext 

final MultiMasterZookeeperPolicyEnforcedContext[] arr = new MultiMasterZookeeperPolicyEnforcedContext[2];	new Thread() {	public void run() {	MultiMasterZookeeperPolicyEnforcedContext second = null;	try {	second = createEnforcedContext(secondDestination, activeNodesDesired, path);	arr[0] = second;	second.sendMessageToEnforcedRoute("message for second", 0);	waitForNonActiveRoutesLatch.countDown();	} catch (Exception e) {	
error in the thread controlling the second context 

waitForNonActiveRoutesLatch.countDown();	} catch (Exception e) {	fail("Error in the thread controlling the second context: " + e.getMessage());	}	}	}.start();	new Thread() {	public void run() {	MultiMasterZookeeperPolicyEnforcedContext third = null;	try {	
starting third camelcontext 

}.start();	new Thread() {	public void run() {	MultiMasterZookeeperPolicyEnforcedContext third = null;	try {	third = createEnforcedContext(thirdDestination, activeNodesDesired, path);	arr[1] = third;	third.sendMessageToEnforcedRoute("message for third", 0);	waitForNonActiveRoutesLatch.countDown();	} catch (Exception e) {	
error in the thread controlling the third context 

arr[1] = third;	third.sendMessageToEnforcedRoute("message for third", 0);	waitForNonActiveRoutesLatch.countDown();	} catch (Exception e) {	fail("Error in the thread controlling the third context: " + e.getMessage());	}	}	}.start();	first.sendMessageToEnforcedRoute("message for master", 1);	waitForNonActiveRoutesLatch.await();	
explicitly shutting down the first camel context 

first.shutdown();	CuratorMultiMasterLeaderRoutePolicy routePolicySecond = (CuratorMultiMasterLeaderRoutePolicy) arr[0].controlledContext.getRouteDefinition(secondDestination).getRoutePolicies().get(0);	CuratorMultiMasterLeaderRoutePolicy routePolicyThird = (CuratorMultiMasterLeaderRoutePolicy) arr[1].controlledContext.getRouteDefinition(thirdDestination).getRoutePolicies().get(0);	MultiMasterZookeeperPolicyEnforcedContext newMaster = null;	MultiMasterZookeeperPolicyEnforcedContext slave = null;	final int maxWait = 20;	for (int i = 0; i < maxWait; i++) {	if (routePolicySecond.getElection().isMaster()) {	newMaster = arr[0];	slave = arr[1];	
second is the new master 

MultiMasterZookeeperPolicyEnforcedContext slave = null;	final int maxWait = 20;	for (int i = 0; i < maxWait; i++) {	if (routePolicySecond.getElection().isMaster()) {	newMaster = arr[0];	slave = arr[1];	break;	} else if (routePolicyThird.getElection().isMaster()) {	newMaster = arr[1];	slave = arr[0];	
third is the new master 

if (routePolicySecond.getElection().isMaster()) {	newMaster = arr[0];	slave = arr[1];	break;	} else if (routePolicyThird.getElection().isMaster()) {	newMaster = arr[1];	slave = arr[0];	break;	} else {	Thread.sleep(2000);	
waiting for a new master to be elected 

CuratorMultiMasterLeaderRoutePolicy firstRoutePolicy = (CuratorMultiMasterLeaderRoutePolicy) firstControlledContext.getRouteDefinition(firstDestination).getRoutePolicies().get(0);	MultiMasterZookeeperPolicyEnforcedContext second = createEnforcedContext(secondDestination, activeNodeDesired, path);	DefaultCamelContext secondControlledContext = (DefaultCamelContext) second.controlledContext;	CuratorMultiMasterLeaderRoutePolicy secondRoutePolicy = (CuratorMultiMasterLeaderRoutePolicy) secondControlledContext.getRouteDefinition(secondDestination).getRoutePolicies().get(0);	assertWeHaveMasters(firstRoutePolicy, secondRoutePolicy);	final MultiMasterZookeeperPolicyEnforcedContext[] arr = new MultiMasterZookeeperPolicyEnforcedContext[1];	new Thread() {	public void run() {	MultiMasterZookeeperPolicyEnforcedContext third = null;	try {	
starting third camelcontext 

final MultiMasterZookeeperPolicyEnforcedContext[] arr = new MultiMasterZookeeperPolicyEnforcedContext[1];	new Thread() {	public void run() {	MultiMasterZookeeperPolicyEnforcedContext third = null;	try {	third = createEnforcedContext(thirdDestination, activeNodeDesired, path);	arr[0] = third;	third.sendMessageToEnforcedRoute("message for third", 0);	waitForThirdRouteCompletedLatch.countDown();	} catch (Exception e) {	
error in the thread controlling the third context 

third.sendMessageToEnforcedRoute("message for third", 0);	waitForThirdRouteCompletedLatch.countDown();	} catch (Exception e) {	fail("Error in the thread controlling the third context: " + e.getMessage());	}	}	}.start();	first.sendMessageToEnforcedRoute("message for first", 1);	second.sendMessageToEnforcedRoute("message for second", 1);	waitForThirdRouteCompletedLatch.await();	
explicitly shutting down the first camel context 

public void sendMessageToEnforcedRoute(String message, int expected) throws InterruptedException {	mock.expectedMessageCount(expected);	try {	
sending message to vm 

public void shutdown() throws Exception {	
stopping 

public void shutdown() throws Exception {	controlledContext.stop();	
stopped 

public void startup() throws Exception {	
starting 

public void startup() throws Exception {	controlledContext.start();	
started 

========================= camel sample_12633 =========================

private void setUriDereferencer(XMLCryptoContext context) {	if (getConfiguration().getUriDereferencer() != null) {	context.setURIDereferencer(getConfiguration().getUriDereferencer());	
uri dereferencer set 

private void setBaseUri(XMLCryptoContext context) {	if (getConfiguration().getBaseUri() != null) {	context.setBaseURI(getConfiguration().getBaseUri());	
base uri set 

protected void setCryptoContextProperties(XMLCryptoContext cryptoContext) {	Map<String, ? extends Object> props = getConfiguration().getCryptoContextProperties();	if (props == null) {	return;	}	for (String prop : props.keySet()) {	Object val = props.get(prop);	cryptoContext.setProperty(prop, val);	
context property set to value 

}	byte[] bytes = null;	try {	bytes = IOConverter.toBytes(is);	} finally {	IOHelper.close(is);	}	SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);	schemaFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);	schemaFactory.setResourceResolver(new DefaultLSResourceResolver(getConfiguration().getCamelContext(), getConfiguration() .getSchemaResourceUri()));	
instantiating schema for validation 

protected String getSchemaResourceUri(Message message) {	String schemaResourceUri = message.getHeader(XmlSignatureConstants.HEADER_SCHEMA_RESOURCE_URI, String.class);	if (schemaResourceUri == null) {	schemaResourceUri = getConfiguration().getSchemaResourceUri();	}	
schema resource uri 

========================= camel sample_6771 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<JibxDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.jibx.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.jibx.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_1221 =========================

public Producer createProducer() throws Exception {	
resolve producer digitalocean endpoint 

========================= camel sample_8903 =========================

if (idempotentRepository instanceof ExchangeIdempotentRepository) {	newKey = !((ExchangeIdempotentRepository<String>) idempotentRepository).contains(exchange, messageId);	} else {	newKey = !idempotentRepository.contains(messageId);	}	}	if (!newKey) {	exchange.setProperty(Exchange.DUPLICATE_MESSAGE, Boolean.TRUE);	onDuplicate(exchange, messageId);	if (skipDuplicate) {	
ignoring duplicate message with id for exchange 

========================= camel sample_4473 =========================

public void doBefore() {	
invoked the pre consumed method with address 

========================= camel sample_14088 =========================

if (body instanceof String[]) {	messageId = this.ironQueue.pushMessages((String[])body, configuration.getVisibilityDelay());	} else if (body instanceof String) {	if (configuration.isPreserveHeaders()) {	body = GsonUtil.getBodyFromMessage(exchange.getIn());	}	messageId = this.ironQueue.push((String)body, configuration.getVisibilityDelay());	} else {	throw new InvalidPayloadException(exchange, String.class);	}	
send request from exchange 

if (body instanceof String[]) {	messageId = this.ironQueue.pushMessages((String[])body, configuration.getVisibilityDelay());	} else if (body instanceof String) {	if (configuration.isPreserveHeaders()) {	body = GsonUtil.getBodyFromMessage(exchange.getIn());	}	messageId = this.ironQueue.push((String)body, configuration.getVisibilityDelay());	} else {	throw new InvalidPayloadException(exchange, String.class);	}	
received messageid 

========================= camel sample_14572 =========================

protected CacheManager createCacheManagerInstance() {	if (is == null) {	
creating cachemanager using ehcache defaults 

protected CacheManager createCacheManagerInstance() {	if (is == null) {	return EHCacheUtil.createCacheManager();	}	
creating cachemanager using camel cache configuration 

========================= camel sample_10531 =========================

public void initializeProcess() throws Exception {	if (LOG.isInfoEnabled()) {	
starting mongodb tailable cursor consumer binding to collection db col 

public void run() {	stoppedLatch = new CountDownLatch(1);	while (keepRunning) {	doRun();	if (keepRunning) {	cursor.close();	if (LOG.isDebugEnabled()) {	
regenerating cursor with lastval waiting ms first 

protected void stop() throws Exception {	if (LOG.isInfoEnabled()) {	
stopping mongodb tailable cursor consumer bound to collection db col 

protected void stop() throws Exception {	if (LOG.isInfoEnabled()) {	}	keepRunning = false;	if (cursor != null) {	cursor.close();	}	awaitStopped();	if (LOG.isInfoEnabled()) {	
stopped mongodb tailable cursor consumer bound to collection db col 

private void doRun() {	try {	while (cursor.hasNext() && keepRunning) {	Document dbObj = cursor.next();	Exchange exchange = endpoint.createMongoDbExchange(dbObj);	try {	if (LOG.isTraceEnabled()) {	
sending exchange objectid 

try {	if (LOG.isTraceEnabled()) {	}	consumer.getProcessor().process(exchange);	} catch (Exception e) {	}	tailTracking.setLastVal(dbObj);	}	} catch (MongoCursorNotFoundException e) {	if (keepRunning) {	
cursor not found exception from mongodb will regenerate cursor this is normal behaviour with tailable cursors 

private void awaitStopped() throws InterruptedException {	if (!stopped) {	
going to wait for stopping 

========================= camel sample_10474 =========================

return template.requestBody("direct:start", new SendEmail("user" + index + "@somewhere.org"), SendEmail.class);	}	});	responses.put(index, out);	}	assertMockEndpointsSatisfied(30, TimeUnit.SECONDS);	assertEquals(files, responses.size());	for (Future<SendEmail> future : responses.values()) {	SendEmail sendEmail = future.get();	assertNotNull(sendEmail);	
persisted the sendemail entity with the id and the address 

========================= camel sample_14067 =========================

Collections.addAll(methods, Method.OPTIONS);	if (endpoint.getRestletMethods() != null) {	Collections.addAll(methods, endpoint.getRestletMethods());	} else {	Collections.addAll(methods, endpoint.getRestletMethod());	}	for (Method method : methods) {	router.removeRoute(method);	}	if (LOG.isDebugEnabled()) {	
detached restlet uripattern method 

private MethodBasedRouter getMethodRouter(String uriPattern, boolean addIfEmpty) {	synchronized (routers) {	MethodBasedRouter result = routers.get(uriPattern);	if (result == null && addIfEmpty) {	result = new MethodBasedRouter(uriPattern);	
added method based router 

protected void addServerIfNecessary(RestletEndpoint endpoint) throws Exception {	String key = buildKey(endpoint);	RestletHost host;	synchronized (restletHostRegistry) {	host = restletHostRegistry.get(key);	if (host == null) {	host = createRestletHost();	host.configure(endpoint, component);	restletHostRegistry.put(key, host);	
added host 

Map<String, String> realm = endpoint.getRestletRealm();	if (realm != null && realm.size() > 0) {	ChallengeAuthenticator guard = new ChallengeAuthenticator(component.getContext() .createChildContext(), ChallengeScheme.HTTP_BASIC, "Camel-Restlet Endpoint Realm");	MapVerifier verifier = new MapVerifier();	for (Map.Entry<String, String> entry : realm.entrySet()) {	verifier.getLocalSecrets().put(entry.getKey(), entry.getValue().toCharArray());	}	guard.setVerifier(verifier);	guard.setNext(target);	target = guard;	
target has been set to guard 

}	List<Method> methods = new ArrayList<>();	Collections.addAll(methods, Method.OPTIONS);	if (endpoint.getRestletMethods() != null) {	Collections.addAll(methods, endpoint.getRestletMethods());	} else {	Collections.addAll(methods, endpoint.getRestletMethod());	}	for (Method method : methods) {	router.addRoute(method, target);	
attached restlet uripattern method 

if (endpoint.getRestletMethods() != null) {	Collections.addAll(methods, endpoint.getRestletMethods());	} else {	Collections.addAll(methods, endpoint.getRestletMethod());	}	for (Method method : methods) {	router.addRoute(method, target);	}	if (!router.hasBeenAttached()) {	component.getDefaultHost().attach( offsetPath == null ? uriPattern : offsetPath + uriPattern, router);	
attached methodrouter uripattern 

Collections.addAll(methods, endpoint.getRestletMethod());	}	for (Method method : methods) {	router.addRoute(method, target);	}	if (!router.hasBeenAttached()) {	component.getDefaultHost().attach( offsetPath == null ? uriPattern : offsetPath + uriPattern, router);	}	if (!router.isStarted()) {	router.start();	
started methodrouter uripattern 

private void deAttachUriPatternFromRestlet(String uriPattern, RestletEndpoint endpoint, Restlet target) throws Exception {	component.getDefaultHost().detach(target);	
de attached methodrouter uripattern 

========================= camel sample_9304 =========================

public static void writeBody(IoSession session, Object body, Exchange exchange, long writeTimeout) throws CamelExchangeException {	WriteFuture future = session.write(body);	
waiting for write to complete for body using session 

========================= camel sample_11635 =========================

for (int i = 1; i <= consumerRouteCount; i++) {	getMockEndpoint("mock:test.consumer." + i).expectedMessageCount(messageCount);	}	List<BatchMessage<String>> messages = new ArrayList<BatchMessage<String>>();	for (int i = 1; i <= messageCount; i++) {	String body = "Hello World " + i;	BatchMessage<String> message = new BatchMessage<String>(body, null);	messages.add(message);	}	try {	
send messages 

}	List<BatchMessage<String>> messages = new ArrayList<BatchMessage<String>>();	for (int i = 1; i <= messageCount; i++) {	String body = "Hello World " + i;	BatchMessage<String> message = new BatchMessage<String>(body, null);	messages.add(message);	}	try {	template.sendBody("direct:start", messages);	} catch (Exception e) {	
send again 

protected void addRoute(final String destinationName, final int consumerRouteCount, final CountDownLatch latch) throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:start") .id("producer.route") .log("Producer Route Body: ${body}") .to("mock:test.producer") .to(destinationName + "?transacted=true") .process(new Processor() {	private final AtomicInteger counter = new AtomicInteger(0);	public void process(Exchange exchange) throws Exception {	if (counter.getAndIncrement() == 0) {	
batchmessage received without redelivery rolling back 

========================= camel sample_12330 =========================

public static String generateInvalidPayloadExceptionMessage(final byte[] hl7Bytes, final int length) {	if (hl7Bytes == null) {	return "HL7 payload is null";	}	if (hl7Bytes.length <= 0) {	return "HL7 payload is empty";	}	if (length > hl7Bytes.length) {	
the length specified for the payload array is greater than the actual length of the array only validating bytes 

mllpSocketBuffer.write(fieldSeparator);	mllpSocketBuffer.write("ACK".getBytes(), 0, 3);	int msh92start = -1;	for (int j = fieldSeparatorIndexes.get(7) + 1; j < fieldSeparatorIndexes.get(8); ++j) {	if (componentSeparator == hl7MessageBytes[j]) {	msh92start = j;	break;	}	}	if (-1 == msh92start) {	
didn t find component separator for msh sending ack in msh 

========================= camel sample_13872 =========================

public Promise<String> execute(final String input) throws WorkflowException {	final Settable<String> result = new Settable<String>();	final AtomicReference<Promise<?>> methodResult = new AtomicReference<Promise<?>>();	new TryCatchFinally() {	protected void doTry() throws Throwable {	Object[] parameters = dataConverter.fromData(input, Object[].class);	long startTime = workflowClock.currentTimeMillis();	boolean replaying = contextProvider.getDecisionContext().getWorkflowClock().isReplaying();	
processing workflow execute 

public void signalRecieved(String signalName, String input) throws WorkflowException {	Object[] parameters = dataConverter.fromData(input, Object[].class);	try {	
processing workflow signalrecieved 

public String getWorkflowState() throws WorkflowException {	try {	
processing workflow getworkflowstate 

========================= camel sample_8796 =========================

public void testInvokingSimpleServerWithParams() throws Exception {	Exchange exchange = sendSimpleMessage();	org.apache.camel.Message out = exchange.getOut();	String result = out.getBody(String.class);	
received output text 

public void testInvokingJaxWsServerWithParams() throws Exception {	Exchange exchange = sendJaxWsMessage();	org.apache.camel.Message out = exchange.getOut();	String result = out.getBody(String.class);	
received output text 

========================= camel sample_7930 =========================

public void testExpression() throws Exception {	Language language = assertResolveLanguage(getLanguageName());	Expression expression = language.createExpression("SELECT * FROM org.apache.camel.builder.sql.Person where city = 'London'");	List<?> value = expression.evaluate(exchange, List.class);	assertEquals("List size", 2, value.size());	for (Object person : value) {	
found 

public void testExpressionWithHeaderVariable() throws Exception {	Language language = assertResolveLanguage(getLanguageName());	Expression expression = language.createExpression("SELECT * FROM org.apache.camel.builder.sql.Person where name = :fooHeader");	List<?> value = expression.evaluate(exchange, List.class);	assertEquals("List size", 1, value.size());	for (Object person : value) {	
found 

========================= camel sample_13464 =========================

MockEndpoint mockEndpoint = getMockEndpoint("mock:a");	mockEndpoint.expectedBodiesReceived("<b>Hello World</b>");	template.requestBodyAndHeader(uri, new ByteArrayInputStream("This is a test".getBytes()), "Content-Type", "application/xml");	mockEndpoint.assertIsSatisfied();	List<Exchange> list = mockEndpoint.getReceivedExchanges();	Exchange exchange = list.get(0);	assertNotNull("exchange", exchange);	Message in = exchange.getIn();	assertNotNull("in", in);	Map<String, Object> headers = in.getHeaders();	
headers 

========================= camel sample_11009 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	errorHandler(deadLetterChannel("mock:global") .maximumRedeliveries(2) .redeliveryDelay(5000));	
direct start mock exhausted seda foo 

========================= camel sample_3836 =========================

public Collection<BoxGroup> getAllGroups() {	try {	
getting all groups 

public void deleteGroup(String groupId) {	try {	
deleting group 

========================= camel sample_17427 =========================

private String sendAndReceiveUdpMessages(String input) throws Exception {	DatagramSocket socket = new DatagramSocket();	InetAddress address = InetAddress.getByName("127.0.0.1");	byte[] data = input.getBytes();	DatagramPacket packet = new DatagramPacket(data, data.length, address, getPort());	
sending data 

private String sendAndReceiveUdpMessages(String input) throws Exception {	DatagramSocket socket = new DatagramSocket();	InetAddress address = InetAddress.getByName("127.0.0.1");	byte[] data = input.getBytes();	DatagramPacket packet = new DatagramPacket(data, data.length, address, getPort());	socket.send(packet);	Thread.sleep(1000);	byte[] buf = new byte[128];	DatagramPacket receive = new DatagramPacket(buf, buf.length, address, getPort());	
receiveing data 

========================= camel sample_7658 =========================

public void testGrowIssue() throws Exception {	StringBuilder sb = new StringBuilder(size);	for (int i = 0; i < 1024; i++) {	sb.append("X");	}	final Buffer key = codec.marshallKey("foo");	for (int i = 0; i < size; i++) {	final Buffer data = codec.marshallKey(i + "-" + sb.toString());	
updating 

========================= camel sample_11727 =========================

protected void doStart() throws Exception {	ObjectHelper.notNull(camelContext, "camel context");	ObjectHelper.notNull(serviceDiscovery, "service discovery");	ObjectHelper.notNull(serviceChooser, "service chooser");	ObjectHelper.notNull(serviceFilter, "service serviceFilter");	
servicecall is using default load balancer with service discovery type service filter type and service chooser type 

========================= camel sample_4131 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<MyBatisComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mybatis.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mybatis.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_604 =========================

protected void initCustomRegistry(BlueprintCamelContext context) {	Registry registry = getBeanForType(Registry.class);	if (registry != null) {	
using custom registry 

public void afterPropertiesSet() throws Exception {	super.afterPropertiesSet();	ClassLoader cl = new BundleDelegatingClassLoader(bundleContext.getBundle());	
set the application context classloader to 

super.afterPropertiesSet();	ClassLoader cl = new BundleDelegatingClassLoader(bundleContext.getBundle());	getContext().setApplicationContextClassLoader(cl);	osgiCamelContextPublisher = new OsgiCamelContextPublisher(bundleContext);	osgiCamelContextPublisher.start();	getContext().getManagementStrategy().addEventNotifier(osgiCamelContextPublisher);	try {	getClass().getClassLoader().loadClass("org.osgi.service.event.EventAdmin");	getContext().getManagementStrategy().addEventNotifier(new OsgiEventAdminNotifier(bundleContext));	} catch (Throwable t) {	
eventadmin package is not available just don t use it 

========================= camel sample_8112 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	errorHandler(deadLetterChannel("mock:global") .maximumRedeliveries(2) .redeliveryDelay(5000));	
direct start mock exhausted seda foo 

========================= camel sample_3924 =========================

public void testThreadPoolTaskExecutor() throws Exception {	context.startRoute("threadPool");	Long beforeThreadCount = currentThreadCount();	getMockEndpoint("mock:result.threadPool").expectedMessageCount(1000);	doSendMessages("foo.threadPool", 500, 5, DefaultTaskExecutorType.ThreadPool);	Thread.sleep(100);	doSendMessages("foo.threadPool", 500, 5, DefaultTaskExecutorType.ThreadPool);	assertMockEndpointsSatisfied();	Long numberThreadsCreated = currentThreadCount() - beforeThreadCount;	
number of threads created testthreadpooltaskexecutor 

public void testSimpleAsyncTaskExecutor() throws Exception {	context.startRoute("simpleAsync");	Long beforeThreadCount = currentThreadCount();	getMockEndpoint("mock:result.simpleAsync").expectedMessageCount(1000);	doSendMessages("foo.simpleAsync", 500, 5, DefaultTaskExecutorType.SimpleAsync);	Thread.sleep(100);	doSendMessages("foo.simpleAsync", 500, 5, DefaultTaskExecutorType.SimpleAsync);	assertMockEndpointsSatisfied();	Long numberThreadsCreated = currentThreadCount() - beforeThreadCount;	
number of threads created testsimpleasynctaskexecutor 

public void testDefaultTaskExecutor() throws Exception {	context.startRoute("default");	Long beforeThreadCount = currentThreadCount();	getMockEndpoint("mock:result.default").expectedMessageCount(1000);	doSendMessages("foo.default", 500, 5, null);	Thread.sleep(100);	doSendMessages("foo.default", 500, 5, null);	assertMockEndpointsSatisfied();	Long numberThreadsCreated = currentThreadCount() - beforeThreadCount;	
number of threads created testdefaulttaskexecutor 

public void testDefaultTaskExecutorThreadPoolAtComponentConfig() throws Exception {	context.startRoute("default");	Long beforeThreadCount = currentThreadCount();	getMockEndpoint("mock:result.default").expectedMessageCount(1000);	doSendMessages("foo.default", 500, 5, DefaultTaskExecutorType.ThreadPool);	Thread.sleep(100);	doSendMessages("foo.default", 500, 5, DefaultTaskExecutorType.ThreadPool);	assertMockEndpointsSatisfied();	Long numberThreadsCreated = currentThreadCount() - beforeThreadCount;	
number of threads created testdefaulttaskexecutorthreadpoolatcomponentconfig 

========================= camel sample_7064 =========================

private String createCandidateName() {	StringBuilder builder = new StringBuilder();	try {	builder.append(InetAddress.getLocalHost().getCanonicalHostName());	} catch (UnknownHostException ex) {	
failed to get the local hostname 

private void awaitElectionResults() {	while (electionComplete.getCount() > 0) {	try {	
awaiting election results 

private ZooKeeperEndpoint createCandidateNode(CamelContext camelContext) {	
initializing zookeeperelection with uri 

private ZooKeeperEndpoint createCandidateNode(CamelContext camelContext) {	ZooKeeperEndpoint zep = camelContext.getEndpoint(uri, ZooKeeperEndpoint.class);	zep.getConfiguration().setCreate(true);	String fullpath = createFullPathToCandidate(zep);	Exchange e = zep.createExchange();	e.setPattern(ExchangePattern.InOut);	e.getIn().setHeader(ZooKeeperMessage.ZOOKEEPER_NODE, fullpath);	e.getIn().setHeader(ZooKeeperMessage.ZOOKEEPER_CREATE_MODE, CreateMode.EPHEMERAL_SEQUENTIAL);	producerTemplate.send(zep, e);	if (e.isFailed()) {	
error setting up election node 

ZooKeeperEndpoint zep = camelContext.getEndpoint(uri, ZooKeeperEndpoint.class);	zep.getConfiguration().setCreate(true);	String fullpath = createFullPathToCandidate(zep);	Exchange e = zep.createExchange();	e.setPattern(ExchangePattern.InOut);	e.getIn().setHeader(ZooKeeperMessage.ZOOKEEPER_NODE, fullpath);	e.getIn().setHeader(ZooKeeperMessage.ZOOKEEPER_CREATE_MODE, CreateMode.EPHEMERAL_SEQUENTIAL);	producerTemplate.send(zep, e);	if (e.isFailed()) {	} else {	
candidate node has been created 

Exchange e = zep.createExchange();	e.setPattern(ExchangePattern.InOut);	e.getIn().setHeader(ZooKeeperMessage.ZOOKEEPER_NODE, fullpath);	e.getIn().setHeader(ZooKeeperMessage.ZOOKEEPER_CREATE_MODE, CreateMode.EPHEMERAL_SEQUENTIAL);	producerTemplate.send(zep, e);	if (e.isFailed()) {	} else {	try {	camelContext.addRoutes(new ElectoralMonitorRoute(zep));	} catch (Exception ex) {	
error configuring zookeeperelection 

private void notifyElectionWatchers() {	for (ElectionWatcher watcher : watchers) {	try {	watcher.electionResultChanged();	} catch (Exception e) {	
election watcher of type threw an exception 

public void configure() throws Exception {	from(zep).id("election-route-" + candidateName).sort(body(), comparator).process(new Processor() {	public void process(Exchange e) throws Exception {	List<String> candidates = e.getIn().getMandatoryBody(List.class);	int location = findCandidateLocationInCandidatesList(candidates, candidateName);	if (location != -1) {	masterNode.set(location <= enabledCount);	
this node is number on the candidate list election is configured for the top this node will be enabled disabled 

========================= camel sample_12672 =========================

public <K, V> BasicCache<K, V> getCache(String cacheName) {	BasicCache<K, V> cache;	if (ObjectHelper.isEmpty(cacheName)) {	cache = cacheContainer.getCache();	cacheName = cache.getName();	} else {	cache = cacheContainer.getCache(cacheName);	}	
cache 

public <K, V> BasicCache<K, V> getCache(String cacheName, boolean forceReturnValue) {	if (isCacheContainerRemote()) {	BasicCache<K, V> cache;	if (ObjectHelper.isEmpty(cacheName)) {	cache = InfinispanUtil.asRemote(cacheContainer).getCache(forceReturnValue);	cacheName = cache.getName();	} else {	cache = InfinispanUtil.asRemote(cacheContainer).getCache(cacheName, forceReturnValue);	}	
cache 

========================= camel sample_13960 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	Processor myProcessor = new Processor() {	public void process(Exchange e) throws Exception {	
received exchange 

========================= camel sample_7121 =========================

public void testCxfEndpointHasCamelContext() throws Exception {	String s = "<GetPerson xmlns=\"http: Document xml = context.getTypeConverter().convertTo(Document.class, s);	
endpoints 

========================= camel sample_7855 =========================

public void unsubscribe() {	if (unsubscribed.compareAndSet(false, true)) {	if (consumer != null) {	workerPool.submit(new Runnable() {	public void run() {	try {	ServiceHelper.stopServices(consumer);	} catch (Exception e) {	
error stopping consumer due this exception is ignored 

========================= camel sample_11183 =========================

public static void startThriftServer() throws Exception {	processor = new Calculator.Processor(new CalculatorSyncServerImpl());	TSSLTransportFactory.TSSLTransportParameters sslParams = new TSSLTransportFactory.TSSLTransportParameters();	sslParams.setKeyStore(KEY_STORE_PATH, SECURITY_STORE_PASSWORD);	serverTransport = TSSLTransportFactory.getServerSocket(THRIFT_TEST_PORT, THRIFT_CLIENT_TIMEOUT, InetAddress.getByName("localhost"), sslParams);	TThreadPoolServer.Args args = new TThreadPoolServer.Args(serverTransport);	args.processor((TProcessor)processor);	server = new TThreadPoolServer(args);	Runnable simple = new Runnable() {	public void run() {	
thrift secured server started on port 

public static void stopThriftServer() throws IOException {	if (server != null) {	server.stop();	serverTransport.close();	
thrift secured server stoped 

public void testCalculateMethodInvocation() throws Exception {	
thrift calculate method sync test start 

public void testCalculateWithException() throws Exception {	
thrift calculate method with business exception sync test start 

public void testVoidMethodInvocation() throws Exception {	
thrift method with empty parameters and void output sync test start 

public void testOneWayMethodInvocation() throws Exception {	
thrift one way method sync test start 

public void testAllTypesMethodInvocation() throws Exception {	
thrift method with all possile types sync test start 

========================= camel sample_13014 =========================

resultEndpoint.expectedMessageCount(1);	PurchaseOrder expectedBody = new PurchaseOrder();	expectedBody.setAmount(20.0);	expectedBody.setName("Wine");	expectedBody.setPrice(5.0);	template.sendBody("direct:start", expectedBody);	resultEndpoint.assertIsSatisfied();	List<Exchange> list = resultEndpoint.getReceivedExchanges();	Exchange exchange = list.get(0);	Object actualBody = exchange.getIn().getBody();	
received 

protected RouteBuilder createRouteBuilder() {	return new RouteBuilder() {	public void configure() {	from("direct:start"). marshal().xstream(PurchaseOrder.class). process(new Processor() {	public void process(Exchange exchange) throws Exception {	
marshalled 

========================= camel sample_10268 =========================

public void execute() {	SelectRequest request = new SelectRequest() .withSelectExpression(determineSelectExpression()) .withConsistentRead(determineConsistentRead()) .withNextToken(determineNextToken());	
sending request for exchange 

public void execute() {	SelectRequest request = new SelectRequest() .withSelectExpression(determineSelectExpression()) .withConsistentRead(determineConsistentRead()) .withNextToken(determineNextToken());	SelectResult result = this.sdbClient.select(request);	
received result 

========================= camel sample_8759 =========================

context.setName("context-" + id);	context.addService(service);	context.addRoutes(new RouteBuilder() {	public void configure() throws Exception {	from("timer:zookeeper?delay=1s&period=1s") .routeId("route-" + id) .routePolicy(ClusteredRoutePolicy.forNamespace("my-ns")) .log("From ${routeId}") .process(e -> contextLatch.countDown());	}	});	Thread.sleep(ThreadLocalRandom.current().nextInt(500));	context.start();	contextLatch.await();	
shutting down node 

========================= camel sample_12605 =========================

public void start() {	if (getFile() == null) {	throw new IllegalArgumentException("A file must be configured");	}	if (LOG.isDebugEnabled()) {	
starting leveldb using file 

private DBFactory getFactory() {	String[] classNames = new String[] {	"org.fusesource.leveldbjni.JniDBFactory", "org.iq80.leveldb.impl.Iq80DBFactory" };	for (String cn : classNames) {	try {	Class<?> clz = getClass().getClassLoader().loadClass(cn);	DBFactory factory = (DBFactory) clz.newInstance();	if (LOG.isDebugEnabled()) {	
using implementation of org leveldb dbfactory 

public void stop() {	File file = getFile();	
stopping leveldb using file 

========================= camel sample_13917 =========================

public void testGetEnterpriseEvents() throws Exception {	Date before = new Date();	Date after = new Date();	after.setTime(before.getTime() - ONE_MINUTE_OF_MILLISECONDS);	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.position", null);	headers.put("CamelBox.after", after);	headers.put("CamelBox.before", before);	headers.put("CamelBox.types", null);	final java.util.List result = requestBodyAndHeaders("direct: assertNotNull("getEnterpriseEvents result", result);	
getenterpriseevents 

========================= camel sample_17407 =========================

public void process(Exchange exchange) throws Exception {	
received 

protected void assertDurableSubscriberEndpointIsValid(JmsEndpoint endpoint) throws Exception {	JmsConfiguration configuration = endpoint.getConfiguration();	assertEquals("getDurableSubscriptionName()", "James", configuration.getDurableSubscriptionName());	assertEquals("getClientId()", "ABC", configuration.getClientId());	assertEquals("isDeliveryPersistent()", true, configuration.isDeliveryPersistent());	JmsConsumer consumer = endpoint.createConsumer(new Processor() {	public void process(Exchange exchange) throws Exception {	
received 

========================= camel sample_7013 =========================

protected RouteBuilder createRouteBuilder() {	mllpClient.setMllpHost("localhost");	mllpClient.setMllpPort(AvailablePortFinder.getNextAvailable());	return new RouteBuilder() {	int connectTimeout = 500;	int responseTimeout = 5000;	public void configure() throws Exception {	String routeId = "mllp-test-receiver-route";	
test route complete mock oncompletion onfailureonly log logginglevel info routeid complete to mllp mllpclient getmllphost mllpclient getmllpport connecttimeout responsetimeout routeid routeid to result 

========================= camel sample_13852 =========================

public void test() throws Exception {	String result = template.requestBody("direct:out", "hello", String.class);	Assert.assertEquals("hello", result);	
sleeping for seconds and no netty exception should occur 

========================= camel sample_6602 =========================

public void testWSHttpCallEcho() throws Exception {	final List<String> received = new ArrayList<String>();	final CountDownLatch latch = new CountDownLatch(2);	DefaultAsyncHttpClient c = new DefaultAsyncHttpClient();	WebSocket websocket = c.prepareGet("ws: new WebSocketUpgradeHandler.Builder() .addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

========================= camel sample_13151 =========================

assertValidContext(context);	context.getShutdownStrategy().setTimeout(10);	template = context.createProducerTemplate();	template.start();	consumer = context.createConsumerTemplate();	consumer.start();	oneExchangeDone = event().whenDone(1).create();	if (isUseRouteBuilder()) {	RouteBuilder[] builders = createRouteBuilders();	for (RouteBuilder builder : builders) {	
using created route builder 

consumer = context.createConsumerTemplate();	consumer.start();	oneExchangeDone = event().whenDone(1).create();	if (isUseRouteBuilder()) {	RouteBuilder[] builders = createRouteBuilders();	for (RouteBuilder builder : builders) {	context.addRoutes(builder);	}	startCamelContext();	} else {	
isuseroutebuilder is false 

protected void tearDown() throws Exception {	
teardown test 

========================= camel sample_1597 =========================

};	List<Route> list = getRouteListWithCurrentContext(builder);	assertEquals("Number routes created" + list, 1, list.size());	for (Route route : list) {	Endpoint key = route.getEndpoint();	assertEquals("From endpoint", "seda: EventDrivenConsumerRoute consumerRoute = assertIsInstanceOf(EventDrivenConsumerRoute.class, route);	Processor processor = consumerRoute.getProcessor();	Channel channel = unwrapChannel(processor);	assertIsInstanceOf(LoggingErrorHandler.class, channel.getErrorHandler());	SendProcessor sendProcessor = assertIsInstanceOf(SendProcessor.class, channel.getNextProcessor());	
found sendprocessor 

========================= camel sample_3729 =========================

public boolean process(final Exchange exchange, final AsyncCallback callback) {	Exception e = exchange.getException();	Throwable caught = catches(exchange, e);	if (exchange.getProperty(Exchange.EXCEPTION_HANDLED) != null || caught == null) {	callback.done(true);	return true;	}	if (LOG.isTraceEnabled()) {	
this catchprocessor catches the exception caused by 

}	if (exchange.getProperty(Exchange.FAILURE_ENDPOINT) == null) {	exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));	}	exchange.setProperty(Exchange.EXCEPTION_HANDLED, true);	exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);	exchange.setException(null);	exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);	final boolean handled = handles(exchange);	if (LOG.isDebugEnabled()) {	
the exception is handled for the exception caused by 

========================= camel sample_4516 =========================

protected void doStart() throws Exception {	super.doStart();	loadCoreTypeConverters();	if (loadTypeConverters) {	int core = typeMappings.size();	loadTypeConverters();	int additional = typeMappings.size() - core;	
type converters loaded core classpath 

========================= camel sample_4003 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<XQueryComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.xquery.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.xquery.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1201 =========================

public void testLoadTestJdbcAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.setResultWaitTime(50 * 1000);	
staring to send messages 

public void testLoadTestJdbcAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.setResultWaitTime(50 * 1000);	for (int i = 0; i < SIZE; i++) {	final int value = 1;	HeaderDto headerDto = new HeaderDto("org", "company", 1);	
sending with id 

public void testLoadTestJdbcAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.setResultWaitTime(50 * 1000);	for (int i = 0; i < SIZE; i++) {	final int value = 1;	HeaderDto headerDto = new HeaderDto("org", "company", 1);	template.sendBodyAndHeader("seda:start?size=" + SIZE, value, "id", headerDto);	}	
sending all message done now waiting for aggregation to complete 

========================= camel sample_8923 =========================

public void process(Exchange exchange) throws Exception {	Sizes sizes = getEndpoint().getDigitalOceanClient().getAvailableSizes(configuration.getPage());	
all sizes page 

========================= camel sample_8889 =========================

totalIn.incrementAndGet();	}	boolean completeAllGroups = exchange.getIn().getHeader(Exchange.AGGREGATION_COMPLETE_ALL_GROUPS, false, boolean.class);	if (completeAllGroups) {	forceCompletionOfAllGroups();	return;	}	String key = correlationExpression.evaluate(exchange, String.class);	if (ObjectHelper.isEmpty(key)) {	if (isIgnoreInvalidCorrelationKeys()) {	
invalid correlation key this exchange will be ignored 

boolean exhaustedRetries = true;	int attempt = 0;	do {	attempt++;	Exchange copy = ExchangeHelper.createCorrelatedCopy(exchange, false);	try {	aggregated = doAggregation(key, copy);	exhaustedRetries = false;	break;	} catch (OptimisticLockingAggregationRepository.OptimisticLockingException e) {	
on attempt optimisticlockingaggregationrepository threw optimisticlockingexception while trying to add key and exchange 

private List<Exchange> doAggregation(String key, Exchange newExchange) throws CamelExchangeException {	
onaggregation start with correlation key 

answer = onAggregation(oldExchange, newExchange);	} catch (Throwable e) {	throw new CamelExchangeException("Error occurred during aggregation", newExchange, e);	}	if (answer == null) {	throw new CamelExchangeException("AggregationStrategy " + aggregationStrategy + " returned null which is not allowed", newExchange);	}	if (aggregationRepository instanceof RecoverableAggregationRepository) {	boolean valid = oldExchange == null || answer.getExchangeId().equals(oldExchange.getExchangeId());	if (!valid && aggregateRepositoryWarned.compareAndSet(false, true)) {	
aggregationstrategy should return the oldexchange instance instead of the newexchange whenever possible as otherwise this can lead to unexpected behavior with some recoverableaggregationrepository implementations 

complete = isCompleted(key, answer);	if (complete == null) {	trackTimeout(key, newExchange);	}	}	if (complete == null) {	doAggregationRepositoryAdd(newExchange.getContext(), key, originalExchange, answer);	} else {	doAggregationComplete(complete, list, key, originalExchange, answer);	}	
onaggregation end with correlation key 

protected void doAggregationRepositoryAdd(CamelContext camelContext, String key, Exchange oldExchange, Exchange newExchange) {	
in progress aggregated oldexchange newexchange with correlation key 

protected void onOptimisticLockingFailure(Exchange oldExchange, Exchange newExchange) {	AggregationStrategy strategy = aggregationStrategy;	if (strategy instanceof DelegateAggregationStrategy) {	strategy = ((DelegateAggregationStrategy) strategy).getDelegate();	}	if (strategy instanceof OptimisticLockingAwareAggregationStrategy) {	
onoptimisticlockfailure with aggregationstrategy oldexchange newexchange 

protected void trackTimeout(String key, Exchange exchange) {	boolean timeoutSet = false;	if (getCompletionTimeoutExpression() != null) {	Long value = getCompletionTimeoutExpression().evaluate(exchange, Long.class);	if (value != null && value > 0) {	if (LOG.isTraceEnabled()) {	
updating correlation key to timeout after ms as exchange received 

Long value = getCompletionTimeoutExpression().evaluate(exchange, Long.class);	if (value != null && value > 0) {	if (LOG.isTraceEnabled()) {	}	addExchangeToTimeoutMap(key, exchange, value);	timeoutSet = true;	}	}	if (!timeoutSet && getCompletionTimeout() > 0) {	if (LOG.isTraceEnabled()) {	
updating correlation key to timeout after ms as exchange received 

protected Exchange onCompletion(final String key, final Exchange original, final Exchange aggregated, boolean fromTimeout) {	if (original != null) {	original.setProperty(Exchange.AGGREGATED_CORRELATION_KEY, key);	}	aggregated.setProperty(Exchange.AGGREGATED_CORRELATION_KEY, key);	if (original != null) {	aggregationRepository.remove(aggregated.getContext(), key, original);	}	if (!fromTimeout && timeoutMap != null) {	
removing correlation key from timeout 

if (strategy instanceof DelegateAggregationStrategy) {	strategy = ((DelegateAggregationStrategy) strategy).getDelegate();	}	if (strategy instanceof TimeoutAwareAggregationStrategy) {	long timeout = getCompletionTimeout() > 0 ? getCompletionTimeout() : -1;	((TimeoutAwareAggregationStrategy) strategy).timeout(aggregated, -1, -1, timeout);	}	}	Exchange answer;	if (fromTimeout && isDiscardOnCompletionTimeout()) {	
aggregation for correlation key discarding aggregated exchange 

private void onSubmitCompletion(final String key, final Exchange exchange) {	
aggregation complete for correlation key sending aggregated exchange 

} else if ("predicate".equals(completedBy)) {	completedByPredicate.incrementAndGet();	} else if ("size".equals(completedBy)) {	completedBySize.incrementAndGet();	} else if ("strategy".equals(completedBy)) {	completedByStrategy.incrementAndGet();	}	}	executorService.submit(new Runnable() {	public void run() {	
processing aggregated exchange 

public void run() {	exchange.addOnCompletion(new AggregateOnCompletion(exchange.getExchangeId()));	try {	processor.process(exchange);	} catch (Throwable e) {	exchange.setException(e);	}	if (exchange.getException() != null) {	getExceptionHandler().handleException("Error processing aggregated exchange", exchange, exchange.getException());	} else {	
processing aggregated exchange complete 

protected void restoreTimeoutMapFromAggregationRepository() throws Exception {	Set<String> keys = aggregationRepository.getKeys();	if (keys == null || keys.isEmpty()) {	return;	}	StopWatch watch = new StopWatch();	
starting restoring completiontimeout for existing exchanges from the aggregation repository 

protected void restoreTimeoutMapFromAggregationRepository() throws Exception {	Set<String> keys = aggregationRepository.getKeys();	if (keys == null || keys.isEmpty()) {	return;	}	StopWatch watch = new StopWatch();	for (String key : keys) {	Exchange exchange = aggregationRepository.get(camelContext, key);	long timeout = exchange.hasProperties() ? exchange.getProperty(Exchange.AGGREGATED_TIMEOUT, 0, long.class) : 0;	if (timeout > 0) {	
restoring completiontimeout for exchangeid with timeout millis 

return;	}	StopWatch watch = new StopWatch();	for (String key : keys) {	Exchange exchange = aggregationRepository.get(camelContext, key);	long timeout = exchange.hasProperties() ? exchange.getProperty(Exchange.AGGREGATED_TIMEOUT, 0, long.class) : 0;	if (timeout > 0) {	addExchangeToTimeoutMap(key, exchange, timeout);	}	}	
restored completiontimeout conditions in the aggregationtimeoutchecker in 

public void onFailure(Exchange exchange) {	
aggregated exchange onfailure 

public void onComplete(Exchange exchange) {	
aggregated exchange oncomplete 

public boolean onEviction(String key, String exchangeId) {	
completion timeout triggered for correlation key 

public boolean onEviction(String key, String exchangeId) {	boolean inProgress = inProgressCompleteExchanges.contains(exchangeId);	if (inProgress) {	
aggregated exchange with id is already in progress 

try {	answer = onCompletion(key, answer, answer, true);	if (answer != null) {	onSubmitCompletion(key, answer);	}	} catch (OptimisticLockingAggregationRepository.OptimisticLockingException e) {	evictionStolen = true;	}	}	if (optimisticLocking && evictionStolen) {	
another camel instance has already successfully correlated or processed this timeout eviction for exchange with id and correlation id 

public void run() {	if (!camelContext.getStatus().isStarted()) {	
completion interval task cannot start due camelcontext has not been started yet 

public void run() {	if (!camelContext.getStatus().isStarted()) {	return;	}	
starting completion interval task 

if (!optimisticLocking) {	lock.lock();	}	try {	for (String key : keys) {	boolean stolenInterval = false;	Exchange exchange = aggregationRepository.get(camelContext, key);	if (exchange == null) {	stolenInterval = true;	} else {	
completion interval triggered for correlation key 

try {	Exchange answer = onCompletion(key, exchange, exchange, false);	if (answer != null) {	onSubmitCompletion(key, answer);	}	} catch (OptimisticLockingAggregationRepository.OptimisticLockingException e) {	stolenInterval = true;	}	}	if (optimisticLocking && stolenInterval) {	
another camel instance has already processed this interval aggregation for exchange with correlation id 

}	if (optimisticLocking && stolenInterval) {	}	}	} finally {	if (!optimisticLocking) {	lock.unlock();	}	}	}	
completion interval task complete 

public void run() {	if (!camelContext.getStatus().isStarted()) {	
recover check cannot start due camelcontext has not been started yet 

public void run() {	if (!camelContext.getStatus().isStarted()) {	return;	}	
starting recover check 

public void run() {	if (!camelContext.getStatus().isStarted()) {	return;	}	final Set<String> copyOfInProgress = new LinkedHashSet<String>(inProgressCompleteExchanges);	Set<String> exchangeIds = recoverable.scan(camelContext);	for (String exchangeId : exchangeIds) {	if (!isRunAllowed()) {	
we are shutting down so stop recovering 

for (String exchangeId : exchangeIds) {	if (!isRunAllowed()) {	return;	}	if (!optimisticLocking) {	lock.lock();	}	try {	boolean inProgress = copyOfInProgress.contains(exchangeId) || inProgressCompleteExchanges.contains(exchangeId);	if (inProgress) {	
aggregated exchange with id is already in progress 

if (!isRunAllowed()) {	return;	}	if (!optimisticLocking) {	lock.lock();	}	try {	boolean inProgress = copyOfInProgress.contains(exchangeId) || inProgressCompleteExchanges.contains(exchangeId);	if (inProgress) {	} else {	
loading aggregated exchange with id to be recovered 

try {	boolean inProgress = copyOfInProgress.contains(exchangeId) || inProgressCompleteExchanges.contains(exchangeId);	if (inProgress) {	} else {	Exchange exchange = recoverable.recover(camelContext, exchangeId);	if (exchange != null) {	String key = exchange.getProperty(Exchange.AGGREGATED_CORRELATION_KEY, String.class);	exchange.getIn().setHeader(Exchange.REDELIVERED, Boolean.TRUE);	RedeliveryData data = redeliveryState.get(exchange.getExchangeId());	if (data != null && recoverable.getMaximumRedeliveries() > 0 && data.redeliveryCounter >= recoverable.getMaximumRedeliveries()) {	
the recovered exchange is exhausted after attempts will now be moved to dead letter channel 

} else {	if (data == null) {	data = new RedeliveryData();	redeliveryState.put(exchange.getExchangeId(), data);	}	data.redeliveryCounter++;	exchange.getIn().setHeader(Exchange.REDELIVERY_COUNTER, data.redeliveryCounter);	if (recoverable.getMaximumRedeliveries() > 0) {	exchange.getIn().setHeader(Exchange.REDELIVERY_MAX_COUNTER, recoverable.getMaximumRedeliveries());	}	
delivery attempt to recover aggregated exchange with id 

onSubmitCompletion(key, exchange);	}	}	}	} finally {	if (!optimisticLocking) {	lock.unlock();	}	}	}	
recover check complete 

protected void doStart() throws Exception {	AggregationStrategy strategy = aggregationStrategy;	if (strategy instanceof DelegateAggregationStrategy) {	strategy = ((DelegateAggregationStrategy) strategy).getDelegate();	}	if (strategy instanceof CamelContextAware) {	((CamelContextAware) strategy).setCamelContext(camelContext);	}	if (strategy instanceof PreCompletionAwareAggregationStrategy) {	preCompletion = true;	
precompletionawareaggregationstrategy detected aggregator is in pre completion mode 

if (strategy instanceof PreCompletionAwareAggregationStrategy) {	preCompletion = true;	}	if (!preCompletion) {	if (getCompletionTimeout() <= 0 && getCompletionInterval() <= 0 && getCompletionSize() <= 0 && getCompletionPredicate() == null && !isCompletionFromBatchConsumer() && getCompletionTimeoutExpression() == null && getCompletionSizeExpression() == null) {	throw new IllegalStateException("At least one of the completions options" + " [completionTimeout, completionInterval, completionSize, completionPredicate, completionFromBatchConsumer] must be set");	}	}	if (getCloseCorrelationKeyOnCompletion() != null) {	if (getCloseCorrelationKeyOnCompletion() > 0) {	
using closedcorrelationkeys with a lrucache with a capacity of 

}	if (!preCompletion) {	if (getCompletionTimeout() <= 0 && getCompletionInterval() <= 0 && getCompletionSize() <= 0 && getCompletionPredicate() == null && !isCompletionFromBatchConsumer() && getCompletionTimeoutExpression() == null && getCompletionSizeExpression() == null) {	throw new IllegalStateException("At least one of the completions options" + " [completionTimeout, completionInterval, completionSize, completionPredicate, completionFromBatchConsumer] must be set");	}	}	if (getCloseCorrelationKeyOnCompletion() != null) {	if (getCloseCorrelationKeyOnCompletion() > 0) {	closedCorrelationKeys = LRUCacheFactory.newLRUCache(getCloseCorrelationKeyOnCompletion());	} else {	
using closedcorrelationkeys with unbounded capacity 

}	if (getCloseCorrelationKeyOnCompletion() != null) {	if (getCloseCorrelationKeyOnCompletion() > 0) {	closedCorrelationKeys = LRUCacheFactory.newLRUCache(getCloseCorrelationKeyOnCompletion());	} else {	closedCorrelationKeys = new ConcurrentHashMap<String, String>();	}	}	if (aggregationRepository == null) {	aggregationRepository = new MemoryAggregationRepository(optimisticLocking);	
defaulting to memoryaggregationrepository 

closedCorrelationKeys = new ConcurrentHashMap<String, String>();	}	}	if (aggregationRepository == null) {	aggregationRepository = new MemoryAggregationRepository(optimisticLocking);	}	if (optimisticLocking) {	if (!(aggregationRepository instanceof OptimisticLockingAggregationRepository)) {	throw new IllegalArgumentException("Optimistic locking cannot be enabled without using an AggregationRepository that implements OptimisticLockingAggregationRepository");	}	
optimistic locking is enabled 

ServiceHelper.startServices(aggregationStrategy, processor, aggregationRepository);	if (aggregationRepository instanceof RecoverableAggregationRepository) {	RecoverableAggregationRepository recoverable = (RecoverableAggregationRepository) aggregationRepository;	if (recoverable.isUseRecovery()) {	long interval = recoverable.getRecoveryIntervalInMillis();	if (interval <= 0) {	throw new IllegalArgumentException("AggregationRepository has recovery enabled and the RecoveryInterval option must be a positive number, was: " + interval);	}	recoverService = camelContext.getExecutorServiceManager().newScheduledThreadPool(this, "AggregateRecoverChecker", 1);	Runnable recoverTask = new RecoverTask(recoverable);	
using recoverableaggregationrepository by scheduling recover checker to run every millis 

throw new IllegalArgumentException("AggregationRepository has recovery enabled and the RecoveryInterval option must be a positive number, was: " + interval);	}	recoverService = camelContext.getExecutorServiceManager().newScheduledThreadPool(this, "AggregateRecoverChecker", 1);	Runnable recoverTask = new RecoverTask(recoverable);	recoverService.scheduleWithFixedDelay(recoverTask, 1000L, interval, TimeUnit.MILLISECONDS);	if (recoverable.getDeadLetterUri() != null) {	int max = recoverable.getMaximumRedeliveries();	if (max <= 0) {	throw new IllegalArgumentException("Option maximumRedeliveries must be a positive number, was: " + max);	}	
after failed redelivery attempts exchanges will be moved to deadletteruri 

throw new NoSuchEndpointException(recoverable.getDeadLetterUri());	}	deadLetterProducerTemplate = camelContext.createProducerTemplate();	}	}	}	if (getCompletionInterval() > 0 && getCompletionTimeout() > 0) {	throw new IllegalArgumentException("Only one of completionInterval or completionTimeout can be used, not both.");	}	if (getCompletionInterval() > 0) {	
using completioninterval to run every millis 

throw new IllegalArgumentException("Only one of completionInterval or completionTimeout can be used, not both.");	}	if (getCompletionInterval() > 0) {	if (getTimeoutCheckerExecutorService() == null) {	setTimeoutCheckerExecutorService(camelContext.getExecutorServiceManager().newScheduledThreadPool(this, AGGREGATE_TIMEOUT_CHECKER, 1));	shutdownTimeoutCheckerExecutorService = true;	}	getTimeoutCheckerExecutorService().scheduleAtFixedRate(new AggregationIntervalTask(), getCompletionInterval(), getCompletionInterval(), TimeUnit.MILLISECONDS);	}	if (getCompletionTimeout() > 0 || getCompletionTimeoutExpression() != null) {	
using completiontimeout to trigger after millis of inactivity 

private void doForceCompletionOnStop() {	int expected = forceCompletionOfAllGroups();	StopWatch watch = new StopWatch();	while (inProgressCompleteExchanges.size() > 0) {	
waiting for inflight exchanges to complete 

private void doForceCompletionOnStop() {	int expected = forceCompletionOfAllGroups();	StopWatch watch = new StopWatch();	while (inProgressCompleteExchanges.size() > 0) {	try {	Thread.sleep(100);	} catch (InterruptedException e) {	
interrupted while waiting for inflight exchanges to complete 

int expected = forceCompletionOfAllGroups();	StopWatch watch = new StopWatch();	while (inProgressCompleteExchanges.size() > 0) {	try {	Thread.sleep(100);	} catch (InterruptedException e) {	break;	}	}	if (expected > 0) {	
forcing completion of all groups with exchanges completed in 

public int forceCompletionOfGroup(String key) {	int total = 0;	if (!optimisticLocking) {	lock.lock();	}	try {	Exchange exchange = aggregationRepository.get(camelContext, key);	if (exchange != null) {	total = 1;	
force completion triggered for correlation key 

Exchange answer = onCompletion(key, exchange, exchange, false);	if (answer != null) {	onSubmitCompletion(key, answer);	}	}	} finally {	if (!optimisticLocking) {	lock.unlock();	}	}	
completed force completion of group 

if (answer != null) {	onSubmitCompletion(key, answer);	}	}	} finally {	if (!optimisticLocking) {	lock.unlock();	}	}	if (total > 0) {	
forcing completion of group with exchanges 

public int forceCompletionOfAllGroups() {	boolean allow = camelContext.getStatus().isStarted() || camelContext.getStatus().isStopping();	if (!allow) {	
cannot start force completion of all groups because camelcontext has not been started 

public int forceCompletionOfAllGroups() {	boolean allow = camelContext.getStatus().isStarted() || camelContext.getStatus().isStopping();	if (!allow) {	return 0;	}	
starting force completion of all groups task 

int total = 0;	if (keys != null && !keys.isEmpty()) {	if (!optimisticLocking) {	lock.lock();	}	total = keys.size();	try {	for (String key : keys) {	Exchange exchange = aggregationRepository.get(camelContext, key);	if (exchange != null) {	
force completion triggered for correlation key 

onSubmitCompletion(key, answer);	}	}	}	} finally {	if (!optimisticLocking) {	lock.unlock();	}	}	}	
completed force completion of all groups task 

}	}	}	} finally {	if (!optimisticLocking) {	lock.unlock();	}	}	}	if (total > 0) {	
forcing completion of all groups with exchanges 

========================= camel sample_4453 =========================

public void validate(Message message, DataType type) throws ValidationException {	Object body = message.getBody();	
validating 

public void validate(Message message, DataType type) throws ValidationException {	Object body = message.getBody();	if (body instanceof String && body.equals(greeting)) {	
OK 

========================= camel sample_17684 =========================

Set<ObjectName> set = mbeanServer.queryNames(new ObjectName("*:type=routes,*"), null);	assertEquals(1, set.size());	ObjectName on = set.iterator().next();	boolean registered = mbeanServer.isRegistered(on);	assertEquals("Should be registered", true, registered);	String uri = (String) mbeanServer.getAttribute(on, "EndpointUri");	assertEquals("direct: String state = (String) mbeanServer.getAttribute(on, "State");	assertEquals("Should be started", ServiceStatus.Started.name(), state);	String uptime = (String) mbeanServer.getAttribute(on, "Uptime");	assertNotNull(uptime);	
uptime 

========================= camel sample_2753 =========================

public OperationResult<String> getResult() {	try {	ZooKeeperHelper.mkdirs(connection, node, false, CreateMode.PERSISTENT);	String created = connection.create(node, data, permissions, createMode);	if (LOG.isDebugEnabled()) {	
created node s using mode s 

========================= camel sample_12652 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<HipchatComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hipchat.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hipchat.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_448 =========================

protected ServerConnectionMultiplexor createConnection(final ConnectionId id, final ServerOptions options) {	
create new server id 

========================= camel sample_6710 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<MQTTComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mqtt.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mqtt.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1190 =========================

protected CamelContext createCamelContext() throws Exception {	CamelContext camel = super.createCamelContext();	SjmsComponent sjms = new SjmsComponent();	
using live connection to existing activemq broker running on 

========================= camel sample_12347 =========================

public synchronized XMPPTCPConnection createConnection() throws InterruptedException, IOException, SmackException, XMPPException {	if (connection != null && connection.isConnected()) {	return connection;	}	connection = null;	
creating new connection 

return connection;	}	connection = null;	XMPPTCPConnection newConnection = createConnectionInternal();	newConnection.connect();	newConnection.addSyncStanzaListener(new XmppLogger("INBOUND"), stanza -> true);	newConnection.addSyncStanzaListener(new XmppLogger("OUTBOUND"), stanza -> true);	if (!newConnection.isAuthenticated()) {	if (user != null) {	if (LOG.isDebugEnabled()) {	
logging in to xmpp as user on connection 

connection = null;	XMPPTCPConnection newConnection = createConnectionInternal();	newConnection.connect();	newConnection.addSyncStanzaListener(new XmppLogger("INBOUND"), stanza -> true);	newConnection.addSyncStanzaListener(new XmppLogger("OUTBOUND"), stanza -> true);	if (!newConnection.isAuthenticated()) {	if (user != null) {	if (LOG.isDebugEnabled()) {	}	if (password == null) {	
no password configured for user on connection 

}	if (login) {	if (resource != null) {	newConnection.login(user, password, Resourcepart.from(resource));	} else {	newConnection.login(user, password);	}	}	} else {	if (LOG.isDebugEnabled()) {	
logging in anonymously to xmpp on connection 

} else {	newConnection.login(user, password);	}	}	} else {	if (LOG.isDebugEnabled()) {	}	newConnection.login();	}	}	
created new connection successfully 

========================= camel sample_12594 =========================

public void setUp() throws Exception {	
setup using bundlecontext 

public void tearDown() throws Exception {	
teardown 

protected void installCamelFeature(String mainFeature) throws Exception {	if (!mainFeature.startsWith("camel-")) {	mainFeature = "camel-" + mainFeature;	}	
install main feature 

if (currentProperties == null) {	currentProperties = newProps;	}	for (Enumeration<String> ek = currentProperties.keys(); ek.hasMoreElements();) {	String k = ek.nextElement();	newProps.put(k, currentProperties.get(k));	}	for (String p : props.stringPropertyNames()) {	newProps.put(p, props.getProperty(p));	}	
updating configadmin by overriding properties 

protected void testComponent(String mainFeature, String component) throws Exception {	
looking up camelcontext mycamel in osgi service registry 

protected void testComponent(String mainFeature, String component) throws Exception {	installCamelFeature(mainFeature);	CamelContext camelContext = getOsgiService(bundleContext, CamelContext.class, "(camel.context.name=myCamel)", SERVICE_TIMEOUT);	assertNotNull("Cannot find CamelContext with name myCamel", camelContext);	
getting camel component 

protected void testComponent(String mainFeature, String component) throws Exception {	installCamelFeature(mainFeature);	CamelContext camelContext = getOsgiService(bundleContext, CamelContext.class, "(camel.context.name=myCamel)", SERVICE_TIMEOUT);	assertNotNull("Cannot find CamelContext with name myCamel", camelContext);	Component comp = camelContext.getComponent(component, true, false);	assertNotNull("Cannot get component with name: " + component, comp);	
found camel component instance with classname 

protected void testDataFormat(String mainFeature, String dataFormat) throws Exception {	
looking up camelcontext mycamel in osgi service registry 

protected void testDataFormat(String mainFeature, String dataFormat) throws Exception {	installCamelFeature(mainFeature);	CamelContext camelContext = getOsgiService(bundleContext, CamelContext.class, "(camel.context.name=myCamel)", SERVICE_TIMEOUT);	assertNotNull("Cannot find CamelContext with name myCamel", camelContext);	
getting camel dataformat 

protected void testDataFormat(String mainFeature, String dataFormat) throws Exception {	installCamelFeature(mainFeature);	CamelContext camelContext = getOsgiService(bundleContext, CamelContext.class, "(camel.context.name=myCamel)", SERVICE_TIMEOUT);	assertNotNull("Cannot find CamelContext with name myCamel", camelContext);	DataFormat df = camelContext.resolveDataFormat(dataFormat);	assertNotNull("Cannot get dataformat with name: " + dataFormat, df);	
found camel dataformat instance with classname 

protected void testLanguage(String mainFeature, String language) throws Exception {	
looking up camelcontext mycamel in osgi service registry 

protected void testLanguage(String mainFeature, String language) throws Exception {	installCamelFeature(mainFeature);	CamelContext camelContext = getOsgiService(bundleContext, CamelContext.class, "(camel.context.name=myCamel)", 20000);	assertNotNull("Cannot find CamelContext with name myCamel", camelContext);	
getting camel language 

protected void testLanguage(String mainFeature, String language) throws Exception {	installCamelFeature(mainFeature);	CamelContext camelContext = getOsgiService(bundleContext, CamelContext.class, "(camel.context.name=myCamel)", 20000);	assertNotNull("Cannot find CamelContext with name myCamel", camelContext);	Language lan = camelContext.resolveLanguage(language);	assertNotNull("Cannot get language with name: " + language, lan);	
found camel language instance with classname 

List<String> camel = new ArrayList<>();	camel.add("camel");	if (extra != null && extra.length > 0) {	for (String e : extra) {	camel.add(e);	}	}	final String[] camelFeatures = camel.toArray(new String[camel.size()]);	switchPlatformEncodingToUTF8();	String karafVersion = getKarafVersion();	
apache karaf version is 

}	} else {	flt = "(" + Constants.OBJECTCLASS + "=" + type.getName() + ")";	}	Filter osgiFilter = FrameworkUtil.createFilter(flt);	tracker = new ServiceTracker(bundleContext, osgiFilter, null);	tracker.open(true);	Object svc = tracker.waitForService(timeout);	if (svc == null) {	Dictionary<?, ?> dic = bundleContext.getBundle().getHeaders();	
test bundle headers 

} else {	flt = "(" + Constants.OBJECTCLASS + "=" + type.getName() + ")";	}	Filter osgiFilter = FrameworkUtil.createFilter(flt);	tracker = new ServiceTracker(bundleContext, osgiFilter, null);	tracker.open(true);	Object svc = tracker.waitForService(timeout);	if (svc == null) {	Dictionary<?, ?> dic = bundleContext.getBundle().getHeaders();	for (ServiceReference ref : asCollection(bundleContext.getAllServiceReferences(null, null))) {	
servicereference bundle symbolicname 

}	Filter osgiFilter = FrameworkUtil.createFilter(flt);	tracker = new ServiceTracker(bundleContext, osgiFilter, null);	tracker.open(true);	Object svc = tracker.waitForService(timeout);	if (svc == null) {	Dictionary<?, ?> dic = bundleContext.getBundle().getHeaders();	for (ServiceReference ref : asCollection(bundleContext.getAllServiceReferences(null, null))) {	}	for (ServiceReference ref : asCollection(bundleContext.getAllServiceReferences(null, flt))) {	
filtered servicereference bundle symbolicname 

========================= camel sample_7697 =========================

public void prepareOnStartup(GenericFileOperations<File> operations, GenericFileEndpoint<File> endpoint) throws Exception {	this.endpoint = endpoint;	
using fileidempotentrepositoryreadlockstrategy on endpoint 

========================= camel sample_4812 =========================

public DataFormat resolveDataFormat(String name, CamelContext context) {	DataFormat dataFormat = null;	DataFormatResolver resolver = context.getRegistry().lookupByNameAndType(".camelBlueprint.dataformatResolver." + name, DataFormatResolver.class);	if (resolver != null) {	
found dataformat resolver in registry 

public DataFormat createDataFormat(String name, CamelContext context) {	DataFormatFactory factory = context.getRegistry().lookupByNameAndType(".camelBlueprint.dataformatFactory." + name, DataFormatFactory.class);	if (factory  != null) {	
found dataformat factory in registry 

========================= camel sample_8132 =========================

public void doSomething(String body) {	ObjectHelper.notNull(destination, "destination");	
received body 

========================= camel sample_15744 =========================

public void process(Exchange exchange) throws Exception {	String msg = exchange.getIn().getBody(String.class);	String queue = endpoint.getQueue();	if (msg != null) {	try {	
sending to message 

public void process(Exchange exchange) throws Exception {	String msg = exchange.getIn().getBody(String.class);	String queue = endpoint.getQueue();	if (msg != null) {	try {	memcachedClient.set(queue, 0, msg);	} catch (Exception e) {	throw new CamelExchangeException("Error sending to: " + queue, exchange, e);	}	} else {	
no message body to send to 

========================= camel sample_8077 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<JavaScriptLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.javascript.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.javascript.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_1256 =========================

public void propagateResponseHeadersToCamel(Message cxfMessage, Exchange exchange, HeaderFilterStrategy strategy) {	
propagating response headers from cxf message 

========================= camel sample_6593 =========================

protected Message run() throws Exception {	
running fallback processor with exchange 

protected Message run() throws Exception {	try {	processor.process(exchange);	} catch (Throwable e) {	exchange.setException(e);	}	if (exchange.getException() != null) {	throw exchange.getException();	}	
running fallback processor with exchange done 

========================= camel sample_11357 =========================

public Processor wrapProcessorInInterceptors(final CamelContext context, final ProcessorDefinition<?> definition, final Processor target, final Processor nextTarget) throws Exception {	if (definition instanceof DynamicRouterDefinition<?>) {	final DelegateAsyncProcessor delegateAsyncProcessor = new DelegateAsyncProcessor() {	public boolean process(final Exchange exchange, final AsyncCallback callback) {	
i m doing someting 

public Processor wrapProcessorInInterceptors(final CamelContext context, final ProcessorDefinition<?> definition, final Processor target, final Processor nextTarget) throws Exception {	if (definition instanceof DynamicRouterDefinition<?>) {	final DelegateAsyncProcessor delegateAsyncProcessor = new DelegateAsyncProcessor() {	public boolean process(final Exchange exchange, final AsyncCallback callback) {	return super.process(exchange, new AsyncCallback() {	public void done(final boolean doneSync) {	
i m done 

========================= camel sample_3791 =========================

protected boolean doDecode(IoSession session, IoBuffer in, ProtocolDecoderOutput out) throws Exception {	DecoderState state = decoderState(session);	in.position(state.current());	
received data checking from position to 

DecoderState state = decoderState(session);	in.position(state.current());	boolean messageDecoded = false;	while (in.hasRemaining()) {	int previousPosition = in.position();	byte current = in.get();	if (current == config.getEndByte2() && state.previous() == config.getEndByte1()) {	if (state.isStarted()) {	int currentPosition = in.position();	int currentLimit = in.limit();	
message ends at position with length 

boolean messageDecoded = false;	while (in.hasRemaining()) {	int previousPosition = in.position();	byte current = in.get();	if (current == config.getEndByte2() && state.previous() == config.getEndByte1()) {	if (state.isStarted()) {	int currentPosition = in.position();	int currentLimit = in.limit();	in.position(state.start());	in.limit(currentPosition);	
set start to position and limit to 

if (current == config.getEndByte2() && state.previous() == config.getEndByte1()) {	if (state.isStarted()) {	int currentPosition = in.position();	int currentLimit = in.limit();	in.position(state.start());	in.limit(currentPosition);	try {	out.write(config.isProduceString() ? parseMessageToString(in.slice(), charsetDecoder(session)) : parseMessageToByteArray(in.slice()));	messageDecoded = true;	} finally {	
resetting to position and limit to 

in.limit(currentPosition);	try {	out.write(config.isProduceString() ? parseMessageToString(in.slice(), charsetDecoder(session)) : parseMessageToByteArray(in.slice()));	messageDecoded = true;	} finally {	in.position(currentPosition);	in.limit(currentLimit);	state.reset();	}	} else {	
ignoring message end at position until start byte has been seen 

} else {	if (current == config.getStartByte()) {	state.markStart(previousPosition);	} else {	state.markPrevious(current);	}	messageDecoded = false;	}	}	if (!messageDecoded) {	
no complete message yet at position 

private Object parseMessageToByteArray(IoBuffer buf) throws CharacterCodingException {	int len = buf.limit() - 3;	
making byte array of length 

private Object parseMessageToByteArray(IoBuffer buf) throws CharacterCodingException {	int len = buf.limit() - 3;	byte[] dst = new byte[len];	buf.skip(1);	buf.get(dst, 0, len);	buf.skip(2);	if (config.isConvertLFtoCR()) {	
replacing lf by cr 

private Object parseMessageToString(IoBuffer buf, CharsetDecoder decoder) throws CharacterCodingException {	int len = buf.limit() - 3;	
making string of length using charset 

private Object parseMessageToString(IoBuffer buf, CharsetDecoder decoder) throws CharacterCodingException {	int len = buf.limit() - 3;	buf.skip(1);	String message = buf.getString(len, decoder);	buf.skip(2);	if (config.isConvertLFtoCR()) {	
replacing lf by cr 

========================= camel sample_11438 =========================

private CompletionStage<Void> updateValue(final Request<?> value) {	try {	final Exchange exchange = getEndpoint().createExchange();	exchange.setIn(mapMessage(value));	final CompletableFuture<Void> result = new CompletableFuture<>();	getAsyncProcessor().process(exchange, doneSync -> result.complete(null));	return result;	} catch (final Exception e) {	
failed to process message 

========================= camel sample_6706 =========================

public void testPropertyEditorTypeConverter() throws Exception {	MyBean bean = new MyBean();	bean.setBar("Hello");	StopWatch watch = new StopWatch();	for (int i = 0; i < 500; i++) {	String s = context.getTypeConverter().convertTo(String.class, bean);	log.debug(s);	assertNotNull(s);	}	
time taken 

========================= camel sample_1493 =========================

protected void doStart() throws Exception {	ObjectHelper.notNull(configuration, "configuration");	ObjectHelper.notNull(camelContext, "camel context");	if (serviceDiscovery != null) {	LOGGER.info("ServiceCall is using ribbon load balancer with service discovery type: {} and service filter: {}", serviceDiscovery.getClass(), serviceDiscovery != null ? serviceFilter.getClass() : "none");	} else {	
servicecall is using ribbon load balancer 

========================= camel sample_13055 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<IgniteComputeComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ignite-compute.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ignite-compute.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1169 =========================

public void assertMessageExpected(DataSetEndpoint dataSetEndpoint, Exchange expected, Exchange actual, long index) throws Exception {	Predicate predicate = PredicateBuilder.isEqualTo(expression, ExpressionBuilder.constantExpression(index));	
evaluating predicate 

========================= camel sample_3154 =========================

if (configuration.isNativeTransport()) {	clientBootstrap.channel(EpollSocketChannel.class);	} else {	clientBootstrap.channel(NioSocketChannel.class);	}	clientBootstrap.group(wg);	clientBootstrap.option(ChannelOption.SO_KEEPALIVE, configuration.isKeepAlive());	clientBootstrap.option(ChannelOption.TCP_NODELAY, configuration.isTcpNoDelay());	clientBootstrap.option(ChannelOption.SO_REUSEADDR, configuration.isReuseAddress());	clientBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, configuration.getConnectTimeout());	
created clientbootstrap 

clientBootstrap.channel(NioSocketChannel.class);	}	clientBootstrap.group(wg);	clientBootstrap.option(ChannelOption.SO_KEEPALIVE, configuration.isKeepAlive());	clientBootstrap.option(ChannelOption.TCP_NODELAY, configuration.isTcpNoDelay());	clientBootstrap.option(ChannelOption.SO_REUSEADDR, configuration.isReuseAddress());	clientBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, configuration.getConnectTimeout());	clientBootstrap.handler(pipelineFactory);	ChannelFuture channelFuture = clientBootstrap.connect(new InetSocketAddress(configuration.getHost(), configuration.getPort()));	if (LOG.isDebugEnabled()) {	
created new tcp client bootstrap connecting to with options 

}	clientBootstrap.group(wg);	clientBootstrap.option(ChannelOption.SO_KEEPALIVE, configuration.isKeepAlive());	clientBootstrap.option(ChannelOption.TCP_NODELAY, configuration.isTcpNoDelay());	clientBootstrap.option(ChannelOption.SO_REUSEADDR, configuration.isReuseAddress());	clientBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, configuration.getConnectTimeout());	clientBootstrap.handler(pipelineFactory);	ChannelFuture channelFuture = clientBootstrap.connect(new InetSocketAddress(configuration.getHost(), configuration.getPort()));	if (LOG.isDebugEnabled()) {	}	
clientmodeserverbootstrap binding to 

protected void stopServerBootstrap() {	
clientmodeserverbootstrap unbinding from 

protected void doReconnectIfNeeded() throws Exception {	if (channel == null || !channel.isActive()) {	
clientmodeserverbootstrap re connect to 

protected Channel openChannel(final ChannelFuture channelFuture) throws Exception {	if (LOG.isTraceEnabled()) {	
waiting for operation to complete for millis 

} else {	ConnectException cause = new ConnectException("Cannot connect to " + configuration.getAddress());	if (channelFuture.cause() != null) {	cause.initCause(channelFuture.cause());	}	throw cause;	}	}	Channel answer = channelFuture.channel();	if (LOG.isDebugEnabled()) {	
creating connector to address 

private void scheduleReconnect(final ChannelFuture channelFuture) {	final EventLoop loop = channelFuture.channel().eventLoop();	loop.schedule(new Runnable() {	public void run() {	try {	
re connecting to if needed 

private void scheduleReconnect(final ChannelFuture channelFuture) {	final EventLoop loop = channelFuture.channel().eventLoop();	loop.schedule(new Runnable() {	public void run() {	try {	doReconnectIfNeeded();	} catch (Exception e) {	
error during re connect to will attempt again in millis this exception is ignored 

========================= camel sample_10229 =========================

public void awaitConnection() {	if (LOG.isDebugEnabled()) {	
awaiting connection event from zookeeper cluster 

public void closeConnection() {	try {	if (zookeeper != null) {	zookeeper.close();	zookeeper = null;	}	if (LOG.isDebugEnabled()) {	
shutting down connection to zookeeper cluster 

public void closeConnection() {	try {	if (zookeeper != null) {	zookeeper.close();	zookeeper = null;	}	if (LOG.isDebugEnabled()) {	}	} catch (InterruptedException e) {	
error closing zookeeper connection this exception will be ignored 

========================= camel sample_12644 =========================

protected void doStart() throws Exception {	ObjectHelper.notNull(configuration, "setNettyServerBootstrapConfiguration() must be called with a NettyServerBootstrapConfiguration instance", this);	if (configuration.getPort() <= 0) {	throw new IllegalArgumentException("Port must be configured on NettySharedHttpServerBootstrapConfiguration " + configuration);	}	if (ObjectHelper.isEmpty(configuration.getHost())) {	throw new IllegalArgumentException("Host must be configured on NettySharedHttpServerBootstrapConfiguration " + configuration);	}	
nettysharedhttpserver using configuration 

channelFactory.init(configuration.getPort());	ChannelPipelineFactory pipelineFactory = new HttpServerSharedPipelineFactory(configuration, channelFactory, classResolver);	String port = Matcher.quoteReplacement("" + configuration.getPort());	String pattern = threadPattern;	pattern = pattern.replaceFirst("#port#", port);	ThreadFactory tf = new CamelThreadFactory(pattern, "NettySharedHttpServer", true);	bootstrapFactory = new HttpServerBootstrapFactory(channelFactory, false);	bootstrapFactory.init(tf, configuration, pipelineFactory);	ServiceHelper.startServices(channelFactory);	if (startServer) {	
starting nettysharedhttpserver on 

protected void doStop() throws Exception {	
stopping nettysharedhttpserver on 

========================= camel sample_8348 =========================

public void tearDown() throws Exception {	super.tearDown();	DefaultCamelContext dcc = (DefaultCamelContext)context;	while (!dcc.isStopped()) {	
waiting on the camel context to stop 

public void tearDown() throws Exception {	super.tearDown();	DefaultCamelContext dcc = (DefaultCamelContext)context;	while (!dcc.isStopped()) {	}	
closing jms session 

public void tearDown() throws Exception {	super.tearDown();	DefaultCamelContext dcc = (DefaultCamelContext)context;	while (!dcc.isStopped()) {	}	if (getSession() != null) {	getSession().close();	setSession(null);	}	
closing jms connection 

while (!dcc.isStopped()) {	}	if (getSession() != null) {	getSession().close();	setSession(null);	}	if (connection != null) {	connection.stop();	connection = null;	}	
stopping the activemq broker 

========================= camel sample_12351 =========================

public Processor wrapProcessorInInterceptors(final CamelContext context, final ProcessorDefinition<?> definition, final Processor target, final Processor nextTarget) throws Exception {	if (definition instanceof SplitDefinition) {	final DelegateAsyncProcessor delegateAsyncProcessor = new DelegateAsyncProcessor() {	public boolean process(final Exchange exchange, final AsyncCallback callback) {	
i m doing someting 

public Processor wrapProcessorInInterceptors(final CamelContext context, final ProcessorDefinition<?> definition, final Processor target, final Processor nextTarget) throws Exception {	if (definition instanceof SplitDefinition) {	final DelegateAsyncProcessor delegateAsyncProcessor = new DelegateAsyncProcessor() {	public boolean process(final Exchange exchange, final AsyncCallback callback) {	return super.process(exchange, new AsyncCallback() {	public void done(final boolean doneSync) {	
i m done 

========================= camel sample_3912 =========================

public void stop() {	
stopping excecutor service 

public void stop() {	List<Runnable> runnables = executor.shutdownNow();	log.info("{} Runnables were active", runnables == null ? 0 : runnables.size());	for (Runnable runnable : runnables) {	if (runnable instanceof TestRunnable) {	log.info(((TestRunnable)runnable).status());	} else {	
runnable is not instance of testrunnable 

========================= camel sample_13813 =========================

protected JAXBContext createContext(String contextPath) throws JAXBException {	ClassLoader cl = NotificationXmlFormatter.class.getClassLoader();	try {	
creating jaxbcontext with contextpath and classloader 

protected JAXBContext createContext(String contextPath) throws JAXBException {	ClassLoader cl = NotificationXmlFormatter.class.getClassLoader();	try {	return JAXBContext.newInstance(contextPath, cl);	} catch (Exception e) {	
creating jaxbcontext with contextpath 

========================= camel sample_12701 =========================

public void testProducerBlocksResumeTest() throws Exception {	context.suspendRoute("foo");	ExecutorService executor = Executors.newSingleThreadExecutor();	executor.submit(new Runnable() {	public void run() {	try {	Thread.sleep(200);	
resuming consumer 

========================= camel sample_3441 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<ICalDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.ical.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.ical.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_1186 =========================

public void init() throws Exception {	
init 

public void destroy() throws Exception {	
destroy 

public void destroy() throws Exception {	try {	bundleContext.removeServiceListener(this);	} catch (Exception e) {	
error removing servicelistener this exception is ignored 

public void destroy() throws Exception {	try {	bundleContext.removeServiceListener(this);	} catch (Exception e) {	}	if (registration != null) {	try {	registration.unregister();	} catch (Exception e) {	
error unregistering service registration this exception is ignored 

case BlueprintEvent.FAILURE: eventTypeString = "FAILURE";	break;	default: eventTypeString = "UNKNOWN";	break;	}	LOG.debug("Received BlueprintEvent[ replay={} type={} bundle={}] %s", event.isReplay(), eventTypeString, event.getBundle().getSymbolicName(), event.toString());	}	if (!event.isReplay() && this.getBundleContext().getBundle().getBundleId() == event.getBundle().getBundleId()) {	if (event.getType() == BlueprintEvent.CREATED) {	try {	
attempting to start camel context 

default: eventTypeString = "UNKNOWN";	break;	}	LOG.debug("Received BlueprintEvent[ replay={} type={} bundle={}] %s", event.isReplay(), eventTypeString, event.getBundle().getSymbolicName(), event.toString());	}	if (!event.isReplay() && this.getBundleContext().getBundle().getBundleId() == event.getBundle().getBundleId()) {	if (event.getType() == BlueprintEvent.CREATED) {	try {	this.maybeStart();	} catch (Exception startEx) {	
error occurred during starting camel context 

LOG.debug("Received BlueprintEvent[ replay={} type={} bundle={}] %s", event.isReplay(), eventTypeString, event.getBundle().getSymbolicName(), event.toString());	}	if (!event.isReplay() && this.getBundleContext().getBundle().getBundleId() == event.getBundle().getBundleId()) {	if (event.getType() == BlueprintEvent.CREATED) {	try {	this.maybeStart();	} catch (Exception startEx) {	}	} else if (event.getType() == BlueprintEvent.DESTROYING) {	try {	
stopping camel context 

if (!event.isReplay() && this.getBundleContext().getBundle().getBundleId() == event.getBundle().getBundleId()) {	if (event.getType() == BlueprintEvent.CREATED) {	try {	this.maybeStart();	} catch (Exception startEx) {	}	} else if (event.getType() == BlueprintEvent.DESTROYING) {	try {	this.stop();	} catch (Exception stopEx) {	
error occurred during stopping camel context 

break;	case ServiceEvent.MODIFIED: eventTypeString = "MODIFIED";	break;	case ServiceEvent.UNREGISTERING: eventTypeString = "UNREGISTERING";	break;	case ServiceEvent.MODIFIED_ENDMATCH: eventTypeString = "MODIFIED_ENDMATCH";	break;	default: eventTypeString = "UNKNOWN";	break;	}	
service changed to 

private void maybeStart() throws Exception {	
maybestart 

private void maybeStart() throws Exception {	if (!routeDefinitionValid.get()) {	
maybestart is skipping since camelroute definition is not correct 

for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {	if (notifier instanceof OsgiCamelContextPublisher) {	OsgiCamelContextPublisher publisher = (OsgiCamelContextPublisher) notifier;	publisher.registerCamelContext(this);	break;	}	}	}	boolean skip = "true".equalsIgnoreCase(System.getProperty("skipStartingCamelContext"));	if (skip) {	
maybestart is skipping as system property skipstartingcamelcontext is set 

publisher.registerCamelContext(this);	break;	}	}	}	boolean skip = "true".equalsIgnoreCase(System.getProperty("skipStartingCamelContext"));	if (skip) {	return;	}	if (!isStarted() && !isStarting()) {	
starting 

}	}	}	boolean skip = "true".equalsIgnoreCase(System.getProperty("skipStartingCamelContext"));	if (skip) {	return;	}	if (!isStarted() && !isStarting()) {	start();	} else {	
ignoring maybestart as is already started 

========================= camel sample_8124 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<NetWeaverComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.sap-netweaver.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.sap-netweaver.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_798 =========================

public void prepareOnStartup(GenericFileOperations<File> operations, GenericFileEndpoint<File> endpoint) throws Exception {	this.endpoint = endpoint;	
using fileidempotentrepositoryreadlockstrategy on endpoint 

========================= camel sample_4804 =========================

from("activemq:queue:foo") .transacted() .to("log:foo") .to("activemq:queue:bar");	from("activemq:queue:bar").to("mock:bar");	}	});	context.start();	MockEndpoint mock = getMockEndpoint("mock:bar");	mock.expectedMessageCount(0);	template.sendBody("activemq:queue:foo", "Hello World");	Exchange exch = consumer.receive("activemq:queue:foo", 250);	if (exch != null) {	
cleaned up orphaned message 

========================= camel sample_6993 =========================

while (keyIterator.hasNext() && index < max) {	Object key = keyIterator.next();	Object value = dataStore.get(key);	Exchange exchange = endpoint.createExchange();	exchange.setProperty(KratiConstants.KEY, key);	exchange.getIn().setBody(value);	queue.add(exchange);	index++;	}	if (index == max && keyIterator.hasNext()) {	
limiting to maximum messages to poll as there were more messages in this poll 

Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());	exchange.setProperty(Exchange.BATCH_INDEX, index);	exchange.setProperty(Exchange.BATCH_SIZE, total);	exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);	pendingExchanges = total - index - 1;	exchange.addOnCompletion(new Synchronization() {	public void onComplete(Exchange exchange) {	try {	dataStore.delete(exchange.getProperty(KratiConstants.KEY));	} catch (Exception e) {	
failed to remove from datastore this exception is ignored 

exchange.addOnCompletion(new Synchronization() {	public void onComplete(Exchange exchange) {	try {	dataStore.delete(exchange.getProperty(KratiConstants.KEY));	} catch (Exception e) {	}	}	public void onFailure(Exchange exchange) {	}	});	
processing exchange 

========================= camel sample_14006 =========================

public void testCircuitOpen() throws Exception {	
testcircuitopen start 

} catch (CamelExecutionException e) {	LOG.info(e.toString());	}	}	Thread.sleep(1500);	resetMocks();	getMockEndpoint("mock:result").expectedPropertyReceived(HYSTRIX_RESPONSE_SHORT_CIRCUITED, true);	route.throwException = false;	try {	template.requestBody("direct:start", "Request Body");	
instead circuit open expected 

LOG.info(e.toString());	}	}	Thread.sleep(1500);	resetMocks();	getMockEndpoint("mock:result").expectedPropertyReceived(HYSTRIX_RESPONSE_SHORT_CIRCUITED, true);	route.throwException = false;	try {	template.requestBody("direct:start", "Request Body");	} catch (CamelExecutionException e) {	
circuit open expected 

route.throwException = false;	try {	template.requestBody("direct:start", "Request Body");	} catch (CamelExecutionException e) {	}	assertMockEndpointsSatisfied();	Thread.sleep(500);	for (int i = 0; i < 2 * REQUEST_VOLUME_THRESHOLD; i++) {	try {	template.requestBody("direct:start", "Request Body");	
circuit has closed 

template.requestBody("direct:start", "Request Body");	} catch (CamelExecutionException e) {	}	assertMockEndpointsSatisfied();	Thread.sleep(500);	for (int i = 0; i < 2 * REQUEST_VOLUME_THRESHOLD; i++) {	try {	template.requestBody("direct:start", "Request Body");	} catch (CamelExecutionException e) {	Thread.sleep(i * 100);	
circuit will be closed soon 

public void configure() throws Exception {	from("direct:start") .hystrix() .hystrixConfiguration() .executionTimeoutInMilliseconds(100) .circuitBreakerRequestVolumeThreshold(REQUEST_VOLUME_THRESHOLD) .metricsRollingStatisticalWindowInMilliseconds(1000) .circuitBreakerSleepWindowInMilliseconds(2000) .end() .log("Hystrix processing start: ${threadName}") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	if (throwException) {	
will throw exception 

public void configure() throws Exception {	from("direct:start") .hystrix() .hystrixConfiguration() .executionTimeoutInMilliseconds(100) .circuitBreakerRequestVolumeThreshold(REQUEST_VOLUME_THRESHOLD) .metricsRollingStatisticalWindowInMilliseconds(1000) .circuitBreakerSleepWindowInMilliseconds(2000) .end() .log("Hystrix processing start: ${threadName}") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	if (throwException) {	throw new IOException("Route has failed");	} else {	
will not throw exception 

========================= camel sample_11341 =========================

public void applyRequestMetadata(MethodDescriptor<?, ?> method, Attributes attrs, Executor executor, MetadataApplier applier) {	String authority = attrs.get(ATTR_AUTHORITY);	
using authority for credentials 

public void applyRequestMetadata(MethodDescriptor<?, ?> method, Attributes attrs, Executor executor, MetadataApplier applier) {	String authority = attrs.get(ATTR_AUTHORITY);	executor.execute(new Runnable() {	public void run() {	try {	
start to apply for the jwt token header 

public void applyRequestMetadata(MethodDescriptor<?, ?> method, Attributes attrs, Executor executor, MetadataApplier applier) {	String authority = attrs.get(ATTR_AUTHORITY);	executor.execute(new Runnable() {	public void run() {	try {	Metadata headers = new Metadata();	Metadata.Key<String> jwtKey = GrpcConstants.GRPC_JWT_METADATA_KEY;	headers.put(jwtKey, jwtToken);	applier.apply(headers);	} catch (Throwable e) {	
unable to set metadata credentials header 

========================= camel sample_7510 =========================

public void send(MimeMessage mimeMessage) throws MessagingException {	Transport transport = getTransport(getSession());	
connecting to 

transport.connect(getHost(), getPort(), getUsername(), getPassword());	try {	if (mimeMessage.getSentDate() == null) {	mimeMessage.setSentDate(new Date());	}	String messageId = mimeMessage.getMessageID();	mimeMessage.saveChanges();	if (messageId != null) {	mimeMessage.setHeader("Message-ID", messageId);	}	
sending mimemessage using host 

String messageId = mimeMessage.getMessageID();	mimeMessage.saveChanges();	if (messageId != null) {	mimeMessage.setHeader("Message-ID", messageId);	}	transport.sendMessage(mimeMessage, mimeMessage.getAllRecipients());	} finally {	try {	transport.close();	} catch (MessagingException e) {	
error closing transport to host this exception will be ignored 

========================= camel sample_11896 =========================

protected <T> void doAddOption(Map<String, T> options, String name, T value) {	log.trace("Adding option: {}={}", name, value);	T val = options.put(name, value);	if (val != null) {	
options overridden old value was 

int after = parameters.size();	if (schedulerOptions != null && before != after) {	URI u = new URI(uri);	u = URISupport.createRemainingURI(u, parameters);	uri = u.toString();	}	Map<String, String> options = buildEndpointOptions(remaining, parameters);	String delegateUri = createEndpointUri(componentScheme, options);	Endpoint delegate = getCamelContext().getEndpoint(delegateUri);	if (log.isInfoEnabled()) {	
connector resolved 

public String createEndpointUri(String scheme, Map<String, String> options) throws URISyntaxException {	
creating endpoint uri with scheme 

throw new IllegalArgumentException("Camel connector must have outputDataType defined in camel-connector.json file");	}	if (model.getBaseScheme() == null) {	throw new IllegalArgumentException("Camel connector must have baseSchema defined in camel-connector.json file");	}	if (model.getBaseJavaType() == null) {	throw new IllegalArgumentException("Camel connector must have baseJavaType defined in camel-connector.json file");	}	Component component = createNewBaseComponent();	if (component != null) {	
register component type with scheme 

}	if (model.getBaseJavaType() == null) {	throw new IllegalArgumentException("Camel connector must have baseJavaType defined in camel-connector.json file");	}	Component component = createNewBaseComponent();	if (component != null) {	getCamelContext().removeComponent(this.componentScheme);	getCamelContext().addService(component, true, true);	getCamelContext().addComponent(this.componentScheme, component);	}	
starting connector 

protected void doStop() throws Exception {	
stopping connector 

========================= camel sample_3 =========================

public NewCommentConsumer(JIRAEndpoint endpoint, Processor processor) {	super(endpoint, processor);	
jira newcommentconsumer indexing current issue comments 

========================= camel sample_13002 =========================

String name = info.getterOrSetterShorthandName;	try {	method.setAccessible(true);	Object value = method.invoke(target);	if (value != null || includeNull) {	properties.put(optionPrefix + name, value);	rc = true;	}	} catch (Exception e) {	if (LOG.isTraceEnabled()) {	
error invoking getter method this exception is ignored 

continue;	}	}	}	try {	try {	if (value == null || isAssignableFrom(parameterType, ref.getClass())) {	setter.setAccessible(true);	setter.invoke(target, ref);	if (LOG.isDebugEnabled()) {	
configured property on bean with value 

setter.setAccessible(true);	setter.invoke(target, ref);	if (LOG.isDebugEnabled()) {	}	return true;	} else {	Object convertedValue = convert(typeConverter, parameterType, ref);	setter.setAccessible(true);	setter.invoke(target, convertedValue);	if (LOG.isDebugEnabled()) {	
configured property on bean with value 

}	}	} catch (SecurityException e) {	typeConversionFailed = e;	} catch (NoTypeConversionAvailableException e) {	typeConversionFailed = e;	} catch (IllegalArgumentException e) {	typeConversionFailed = e;	}	if (LOG.isTraceEnabled()) {	
setter with parameter type could not be used for type conversions of 

private static Set<Method> findSetterMethods(Class<?> clazz, String name, Object value, boolean allowBuilderPattern) {	Set<Method> candidates = findSetterMethods(clazz, name, allowBuilderPattern);	if (candidates.isEmpty()) {	return candidates;	} else if (candidates.size() == 1) {	return candidates;	} else {	
found suitable setter methods for setting 

private static Set<Method> findSetterMethods(Class<?> clazz, String name, Object value, boolean allowBuilderPattern) {	Set<Method> candidates = findSetterMethods(clazz, name, allowBuilderPattern);	if (candidates.isEmpty()) {	return candidates;	} else if (candidates.size() == 1) {	return candidates;	} else {	for (Method method : candidates) {	if (method.getParameterTypes()[0].isInstance(value)) {	
method is the best candidate as it has parameter with same instance type 

========================= camel sample_4296 =========================

protected void doStart() throws Exception {	ObjectHelper.notNull(configuration, "setNettyServerBootstrapConfiguration() must be called with a NettyServerBootstrapConfiguration instance", this);	if (configuration.getPort() <= 0) {	throw new IllegalArgumentException("Port must be configured on NettySharedHttpServerBootstrapConfiguration " + configuration);	}	if (ObjectHelper.isEmpty(configuration.getHost())) {	throw new IllegalArgumentException("Host must be configured on NettySharedHttpServerBootstrapConfiguration " + configuration);	}	
nettysharedhttpserver using configuration 

channelFactory.init(configuration.getPort());	ChannelInitializer<Channel> pipelineFactory = new HttpServerSharedInitializerFactory(configuration, channelFactory, classResolver);	String port = Matcher.quoteReplacement("" + configuration.getPort());	String pattern = threadPattern;	pattern = pattern.replaceFirst("#port#", port);	ThreadFactory tf = new CamelThreadFactory(pattern, "NettySharedHttpServer", true);	bootstrapFactory = new HttpServerBootstrapFactory(channelFactory, false);	bootstrapFactory.init(tf, configuration, pipelineFactory);	ServiceHelper.startServices(channelFactory);	if (startServer) {	
starting nettysharedhttpserver on 

protected void doStop() throws Exception {	
stopping nettysharedhttpserver on 

========================= camel sample_16650 =========================

protected void configureSSLContext(SSLContext context) throws GeneralSecurityException {	
configuring server side sslcontext parameters on sslcontext 

protected void configureSSLContext(SSLContext context) throws GeneralSecurityException {	if (this.getSessionTimeout() != null) {	
configuring server side sslcontext session timeout on sslcontext to 

protected void configureSSLContext(SSLContext context) throws GeneralSecurityException {	if (this.getSessionTimeout() != null) {	this.configureSessionContext(context.getServerSessionContext(), this.getSessionTimeout());	}	
configured server side sslcontext parameters on sslcontext 

protected List<Configurer<SSLEngine>> getSSLEngineConfigurers(SSLContext context) {	List<Configurer<SSLEngine>> sslEngineConfigurers = new LinkedList<Configurer<SSLEngine>>();	if (this.getClientAuthentication() != null) {	final ClientAuthentication clientAuthValue = ClientAuthentication.valueOf(this.parsePropertyValue(this.getClientAuthentication()));	Configurer<SSLEngine> sslEngineConfigurer = new Configurer<SSLEngine>() {	public SSLEngine configure(SSLEngine engine) {	
configuring client auth on sslengine to 

protected List<Configurer<SSLServerSocket>> getSSLServerSocketFactorySSLServerSocketConfigurers(SSLContext context) {	List<Configurer<SSLServerSocket>> sslServerSocketConfigurers = super.getSSLServerSocketFactorySSLServerSocketConfigurers(context);	if (this.getClientAuthentication() != null) {	final ClientAuthentication clientAuthValue = ClientAuthentication.valueOf(this.parsePropertyValue(this.getClientAuthentication()));	Configurer<SSLServerSocket> sslServerSocketConfigurer = new Configurer<SSLServerSocket>() {	public SSLServerSocket configure(SSLServerSocket socket) {	
configuring client auth on sslserversocket to 

========================= camel sample_4279 =========================

merchandise.setDescription__c("Merchandise for testing Streaming API updated on " + ZonedDateTime.now().toString());	merchandise.setPrice__c(9.99);	merchandise.setTotal_Inventory__c(1000.0);	CreateSObjectResult result = template().requestBody( "direct:upsertSObject", merchandise, CreateSObjectResult.class);	assertTrue("Merchandise test record not created",  result == null || result.getSuccess());	try {	mock.assertIsSatisfied();	final Message in = mock.getExchanges().get(0).getIn();	merchandise = in.getMandatoryBody(Merchandise__c.class);	assertNotNull("Missing event body", merchandise);	
merchandise notification 

========================= camel sample_14682 =========================

public void updateRouteFromXml(String xml) throws Exception {	RouteDefinition def = ModelHelper.createModelFromXml(context, xml, RouteDefinition.class);	if (def == null) {	return;	}	if (ObjectHelper.isEmpty(def.getId())) {	def.setId(getRouteId());	} else if (!def.getId().equals(getRouteId())) {	throw new IllegalArgumentException("Cannot update route from XML as routeIds does not match. routeId: " + getRouteId() + ", routeId from XML: " + def.getId());	}	
updating route from xml 

========================= camel sample_4629 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	String routeId = "mllp-sender";	public void configure() {	
connect error 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	String routeId = "mllp-sender";	public void configure() {	
write error 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	String routeId = "mllp-sender";	public void configure() {	
receive error 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	String routeId = "mllp-sender";	public void configure() {	
sending message mllp log logginglevel info routeid acknowledgement to complete 

========================= camel sample_13844 =========================

private String generateMessageIdHeader(Message message) {	
generatemessageidheader for msg 

private String generateMessageIdHeader(Message message) {	try {	String values[] = message.getHeader("Message-ID");	if (values != null && values.length > 0) {	String uid = values[0];	
message id header found 

private String generateMessageIdHeader(Message message) {	try {	String values[] = message.getHeader("Message-ID");	if (values != null && values.length > 0) {	String uid = values[0];	return uid;	}	} catch (MessagingException e) {	
cannot read headers from mail message this exception will be ignored 

public String generateMessageHash(Message message) {	
generatemessagehash for msg 

public String generateMessageHash(Message message) {	String uid = null;	StringBuilder buffer = new StringBuilder();	try {	Enumeration<?> it = message.getAllHeaders();	while (it.hasMoreElements()) {	Header header = (Header) it.nextElement();	buffer.append(header.getName()).append("=").append(header.getValue()).append("\n");	}	if (buffer.length() > 0) {	
generating uid from the following 

try {	Enumeration<?> it = message.getAllHeaders();	while (it.hasMoreElements()) {	Header header = (Header) it.nextElement();	buffer.append(header.getName()).append("=").append(header.getValue()).append("\n");	}	if (buffer.length() > 0) {	uid = UUID.nameUUIDFromBytes(buffer.toString().getBytes()).toString();	}	} catch (MessagingException e) {	
cannot read headers from mail message this exception will be ignored 

========================= camel sample_11879 =========================

return producer.createExchange();	}	public Exchange createExchange(ExchangePattern pattern) {	return producer.createExchange(pattern);	}	public Exchange createExchange(Exchange exchange) {	return producer.createExchange(exchange);	}	public boolean process(Exchange exchange, AsyncCallback callback) {	if (LOG.isDebugEnabled()) {	
sending to endpoint is intercepted and detoured to for exchange 

try {	producer.process(exchange);	} catch (Exception e) {	exchange.setException(e);	}	callback.done(true);	return true;	}	} else {	if (LOG.isDebugEnabled()) {	
stop means skip sending exchange to original intended destination for exchange 

========================= camel sample_3945 =========================

private void assertThrottlerTiming(final long elapsedTimeMs, final int throttle, final int intervalMs, final int messageCount) {	long minimum = calculateMinimum(intervalMs, throttle, messageCount) - 50;	long maximum = calculateMaximum(intervalMs, throttle, messageCount) + 50;	maximum += 500;	
sent exchanges in ms with throttle rate of per ms calculated min ms and max ms 

========================= camel sample_2657 =========================

public void testUnmarshal() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:beanio-unmarshal");	mock.expectedMessageCount(2);	template.sendBody("direct:unmarshal", FIXED_DATA);	mock.assertIsSatisfied();	List<Exchange> exchanges = mock.getExchanges();	if (verbose) {	for (Exchange exchange : exchanges) {	Object body = exchange.getIn().getBody();	
received message of class 

========================= camel sample_7286 =========================

public String sayHi(String text) {	
entering implementation code 

public String sayHi(String text) {	
leaving implementation code 

========================= camel sample_7793 =========================

private String sendAndReceiveUdpMessages(String input) throws Exception {	DatagramSocket socket = new DatagramSocket();	InetAddress address = InetAddress.getByName("127.0.0.1");	byte[] data = (input + "\n").getBytes();	DatagramPacket packet = new DatagramPacket(data, data.length, address, getPort());	
sending data 

private String sendAndReceiveUdpMessages(String input) throws Exception {	DatagramSocket socket = new DatagramSocket();	InetAddress address = InetAddress.getByName("127.0.0.1");	byte[] data = (input + "\n").getBytes();	DatagramPacket packet = new DatagramPacket(data, data.length, address, getPort());	socket.send(packet);	Thread.sleep(1000);	byte[] buf = new byte[128];	DatagramPacket receive = new DatagramPacket(buf, buf.length, address, getPort());	
receiving data 

protected RouteBuilder createRouteBuilder() {	return new RouteBuilder() {	public void configure() {	from("netty4:udp: public void process(Exchange exchange) throws Exception {	String s = exchange.getIn().getBody(String.class);	
server got 

========================= camel sample_10157 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<OgnlLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.ognl.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.ognl.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_720 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() {	from("cache: public void process(Exchange exchange) throws Exception {	String operation = (String) exchange.getIn().getHeader(CacheConstants.CACHE_OPERATION);	String key = (String) exchange.getIn().getHeader(CacheConstants.CACHE_KEY);	Object body = exchange.getIn().getBody();	String data = exchange.getContext().getTypeConverter().convertTo(String.class, body);	if (log.isDebugEnabled()) {	
cache event notification 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() {	from("cache: public void process(Exchange exchange) throws Exception {	String operation = (String) exchange.getIn().getHeader(CacheConstants.CACHE_OPERATION);	String key = (String) exchange.getIn().getHeader(CacheConstants.CACHE_KEY);	Object body = exchange.getIn().getBody();	String data = exchange.getContext().getTypeConverter().convertTo(String.class, body);	if (log.isDebugEnabled()) {	
received notification for the following activity in cache 

public void configure() {	from("cache: public void process(Exchange exchange) throws Exception {	String operation = (String) exchange.getIn().getHeader(CacheConstants.CACHE_OPERATION);	String key = (String) exchange.getIn().getHeader(CacheConstants.CACHE_KEY);	Object body = exchange.getIn().getBody();	String data = exchange.getContext().getTypeConverter().convertTo(String.class, body);	if (log.isDebugEnabled()) {	log.debug("Operation = {}", operation);	log.debug("key = {}", key);	log.debug("value = {}", data);	
end cache event notification 

========================= camel sample_10507 =========================

public void testList() throws Exception {	final com.google.api.services.calendar.model.Acl result = requestBody("direct: assertTrue(result.getItems().size() > 0);	
list 

========================= camel sample_11746 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<XmlRpcComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.xmlrpc.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.xmlrpc.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1217 =========================

public void test() throws Exception {	String version = "1.9.0";	
using apache ignite version 

========================= camel sample_6395 =========================

protected void doStart() throws Exception {	super.doStart();	this.map = getAtomixEndpoint() .getAtomix() .getMap( resourceName, new DistributedMap.Config(getAtomixEndpoint().getConfiguration().getResourceOptions(resourceName)), new DistributedMap.Options(getAtomixEndpoint().getConfiguration().getResourceConfig(resourceName))) .join();	Object key = getAtomixEndpoint().getConfiguration().getKey();	if (key == null) {	
subscribe to events for map 

protected void doStart() throws Exception {	super.doStart();	this.map = getAtomixEndpoint() .getAtomix() .getMap( resourceName, new DistributedMap.Config(getAtomixEndpoint().getConfiguration().getResourceOptions(resourceName)), new DistributedMap.Options(getAtomixEndpoint().getConfiguration().getResourceConfig(resourceName))) .join();	Object key = getAtomixEndpoint().getConfiguration().getKey();	if (key == null) {	this.listeners.add(this.map.onAdd(this::onEvent).join());	this.listeners.add(this.map.onRemove(this::onEvent).join());	this.listeners.add(this.map.onUpdate(this::onEvent).join());	} else {	
subscribe to events for map key 

========================= camel sample_10340 =========================

public Consumer createConsumer(Processor processor) throws Exception {	
creating a consumer 

public Producer createProducer() throws Exception {	
creating a producer 

========================= camel sample_9963 =========================

final CamelContext context = new DefaultCamelContext();	final CountDownLatch logonLatch = new CountDownLatch(1);	final String orderStatusServiceUrl = "http: RouteBuilder routes = new RouteBuilder() {	public void configure() throws Exception {	from("quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:TRADER->MARKET"). filter(header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.SessionLogon)). bean(new CountDownLatchDecrementer("logon", logonLatch));	from("quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:MARKET->TRADER&exchangePattern=InOut") .filter(header(QuickfixjEndpoint.MESSAGE_TYPE_KEY).isEqualTo(MsgType.ORDER_STATUS_REQUEST)) .to("log: .bean(new MarketOrderStatusService()) .bean(new QuickfixjMessageJsonPrinter());	from("jetty:" + orderStatusServiceUrl) .bean(new OrderStatusRequestTransformer()) .routingSlip(method(FixSessionRouter.class, "route")) .bean(new QuickfixjMessageJsonTransformer(), "transform(${body})");	}	};	context.addRoutes(routes);	
starting camel context 

String line = orderStatusReply.readLine();	if (!line.equals("\"message\": {")) {	throw new Exception("Don't appear to be a JSON response");	} else {	StringBuilder sb = new StringBuilder();	while (line != null) {	sb.append(line);	sb.append('\n');	line = orderStatusReply.readLine();	}	
web reply 

throw new Exception("Don't appear to be a JSON response");	} else {	StringBuilder sb = new StringBuilder();	while (line != null) {	sb.append(line);	sb.append('\n');	line = orderStatusReply.readLine();	}	}	orderStatusReply.close();	
shutting down camel context 

} else {	StringBuilder sb = new StringBuilder();	while (line != null) {	sb.append(line);	sb.append('\n');	line = orderStatusReply.readLine();	}	}	orderStatusReply.close();	context.stop();	
example complete 

}	}	orderStatusReply.close();	context.stop();	}	public static class OrderStatusRequestTransformer {	private static final Logger LOG = LoggerFactory.getLogger(OrderStatusRequestTransformer.class);	public void transform(Exchange exchange) throws FieldNotFound {	String requestSessionID = exchange.getIn().getHeader("sessionID", String.class);	String replySessionID = "FIX.4.2:MARKET->TRADER";	
given the requestsessionid calculated the replysessionid as 

========================= camel sample_10655 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<JuelLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.el.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.el.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_472 =========================

protected Class<?> findClass(String name) throws ClassNotFoundException {	
findclass 

protected URL findResource(String name) {	
findresource 

protected Enumeration findResources(String name) throws IOException {	
findresource 

protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {	
loadclass resolve 

========================= camel sample_13079 =========================

public boolean storeFile(String name, Exchange exchange, long size) throws GenericFileOperationFailedException {	ObjectHelper.notNull(session, "session");	ScpConfiguration cfg = endpoint.getConfiguration();	int timeout = cfg.getConnectTimeout();	if (LOG.isTraceEnabled()) {	
opening channel to with timeout ms no 

public boolean storeFile(String name, Exchange exchange, long size) throws GenericFileOperationFailedException {	ObjectHelper.notNull(session, "session");	ScpConfiguration cfg = endpoint.getConfiguration();	int timeout = cfg.getConnectTimeout();	if (LOG.isTraceEnabled()) {	}	String file = getRemoteFile(name, cfg);	InputStream is = null;	if (exchange.getIn().getBody() == null) {	if (endpoint.isAllowNullBody()) {	
writing empty file 

if (endpoint.isAllowNullBody()) {	is = new ByteArrayInputStream(new byte[]{});	} else {	throw new GenericFileOperationFailedException("Cannot write null body to file: " + name);	}	}	try {	channel = (ChannelExec) session.openChannel("exec");	channel.setCommand(getScpCommand(cfg, file));	channel.connect(timeout);	
channel connected to 

throw new GenericFileOperationFailedException("Cannot store file: " + name, e);	} catch (IOException e) {	throw new GenericFileOperationFailedException("Failed to write file " + file, e);	} finally {	IOHelper.close(is);	}	} catch (JSchException e) {	throw new GenericFileOperationFailedException("Failed to write file " + file, e);	} finally {	if (channel != null) {	
disconnecting exec scp channel 

throw new GenericFileOperationFailedException("Failed to write file " + file, e);	} finally {	IOHelper.close(is);	}	} catch (JSchException e) {	throw new GenericFileOperationFailedException("Failed to write file " + file, e);	} finally {	if (channel != null) {	channel.disconnect();	channel = null;	
channel disconnected from 

private Session createSession(ScpConfiguration config) {	ObjectHelper.notNull(config, "ScpConfiguration");	try {	final JSch jsch = new JSch();	if (ObjectHelper.isNotEmpty(config.getCiphers())) {	
using ciphers 

ObjectHelper.notNull(config, "ScpConfiguration");	try {	final JSch jsch = new JSch();	if (ObjectHelper.isNotEmpty(config.getCiphers())) {	Hashtable<String, String> ciphers = new Hashtable<String, String>();	ciphers.put("cipher.s2c", config.getCiphers());	ciphers.put("cipher.c2s", config.getCiphers());	JSch.setConfig(ciphers);	}	if (ObjectHelper.isNotEmpty(config.getPrivateKeyFile())) {	
using private keyfile 

name = "file:" + name;	}	try {	InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(endpoint.getCamelContext(), name);	byte[] data = endpoint.getCamelContext().getTypeConverter().mandatoryConvertTo(byte[].class, is);	jsch.addIdentity("camel-jsch", data, null, pkfp != null ? pkfp.getBytes() : null);	} catch (Exception e) {	throw new GenericFileOperationFailedException("Cannot load private keyfile: " + config.getPrivateKeyFile(), e);	}	} else if (ObjectHelper.isNotEmpty(config.getPrivateKeyBytes())) {	
using private key bytes 

try {	jsch.addIdentity("camel-jsch", data, null, pkfp != null ? pkfp.getBytes() : null);	} catch (Exception e) {	throw new GenericFileOperationFailedException("Cannot load private key bytes: " + config.getPrivateKeyBytes(), e);	}	}	String knownHostsFile = config.getKnownHostsFile();	if (knownHostsFile == null && config.isUseUserKnownHostsFile()) {	if (userKnownHostFile == null) {	userKnownHostFile = System.getProperty("user.home") + "/.ssh/known_hosts";	
known host file not configured using user known host file 

} catch (Exception e) {	throw new GenericFileOperationFailedException("Cannot load known host file: " + knownHostsFile, e);	}	} else {	jsch.setKnownHosts((String) null);	}	session = jsch.getSession(config.getUsername(), config.getHost(), config.getPort());	session.setTimeout(config.getTimeout());	session.setUserInfo(new SessionUserInfo(config));	if (ObjectHelper.isNotEmpty(config.getStrictHostKeyChecking())) {	
using strickhostkeychecking 

} else {	jsch.setKnownHosts((String) null);	}	session = jsch.getSession(config.getUsername(), config.getHost(), config.getPort());	session.setTimeout(config.getTimeout());	session.setUserInfo(new SessionUserInfo(config));	if (ObjectHelper.isNotEmpty(config.getStrictHostKeyChecking())) {	session.setConfig("StrictHostKeyChecking", config.getStrictHostKeyChecking());	}	if (ObjectHelper.isNotEmpty(config.getPreferredAuthentications())) {	
using preferredauthentications 

session = jsch.getSession(config.getUsername(), config.getHost(), config.getPort());	session.setTimeout(config.getTimeout());	session.setUserInfo(new SessionUserInfo(config));	if (ObjectHelper.isNotEmpty(config.getStrictHostKeyChecking())) {	session.setConfig("StrictHostKeyChecking", config.getStrictHostKeyChecking());	}	if (ObjectHelper.isNotEmpty(config.getPreferredAuthentications())) {	session.setConfig("PreferredAuthentications", config.getPreferredAuthentications());	}	int timeout = config.getConnectTimeout();	
connecting to with timeout ms no 

session.setConfig("PreferredAuthentications", config.getPreferredAuthentications());	}	int timeout = config.getConnectTimeout();	if (timeout > 0) {	session.connect(timeout);	} else {	session.connect();	}	} catch (JSchException e) {	session = null;	
could not create ssh session for 

private void writeFile(String filename, InputStream data, OutputStream os, InputStream is, ScpConfiguration cfg) throws IOException {	final int lineFeed = '\n';	String bytes;	int pos = filename.indexOf('/');	if (pos >= 0) {	String dir = filename.substring(0, pos);	bytes = "D0775 0 " + dir;	
scp sink 

int pos = filename.indexOf('/');	if (pos >= 0) {	String dir = filename.substring(0, pos);	bytes = "D0775 0 " + dir;	os.write(bytes.getBytes());	os.write(lineFeed);	os.flush();	readAck(is);	writeFile(filename.substring(pos + 1), data, os, is, cfg);	bytes = "E";	
scp sink 

int read;	int size = endpoint.getBufferSize();	byte[] reply = new byte[size];	BufferedInputStream buffer = new BufferedInputStream(data, size);	try {	buffer.mark(Integer.MAX_VALUE);	while ((read = buffer.read(reply)) != -1) {	count += read;	}	bytes = "C0" + cfg.getChmod() + " " + count + " " + filename;	
scp sink 

public String getPassphrase() {	
private key authentication not supported 

public String getPassword() {	
providing password for ssh authentication of user 

========================= camel sample_9125 =========================

public void addServiceFilterConfigurations() {	if (!(beanFactory instanceof ConfigurableBeanFactory)) {	
beanfactory is not of type configurablebeanfactory 

========================= camel sample_13429 =========================

private void doSelectOne(Exchange exchange, SqlSession session) throws Exception {	Object result;	Object in = getInput(exchange);	if (in != null) {	
selectone using statement 

private void doSelectOne(Exchange exchange, SqlSession session) throws Exception {	Object result;	Object in = getInput(exchange);	if (in != null) {	result = session.selectOne(statement, in);	} else {	
selectone using statement 

private void doSelectList(Exchange exchange, SqlSession session) throws Exception {	Object result;	Object in = getInput(exchange);	if (in != null) {	
selectlist using statement 

private void doSelectList(Exchange exchange, SqlSession session) throws Exception {	Object result;	Object in = getInput(exchange);	if (in != null) {	result = session.selectList(statement, in);	} else {	
selectlist using statement 

private void doInsert(Exchange exchange, SqlSession session) throws Exception {	Object result;	Object in = getInput(exchange);	if (in != null) {	Iterator<?> iter = ObjectHelper.createIterator(in);	while (iter.hasNext()) {	Object value = iter.next();	
inserting using statement 

Object result;	Object in = getInput(exchange);	if (in != null) {	Iterator<?> iter = ObjectHelper.createIterator(in);	while (iter.hasNext()) {	Object value = iter.next();	result = session.insert(statement, value);	doProcessResult(exchange, result, session);	}	} else {	
inserting using statement 

private void doInsertList(Exchange exchange, SqlSession session) throws Exception {	Object result;	Object in = getInput(exchange);	if (in != null) {	
inserting using statement 

private void doInsertList(Exchange exchange, SqlSession session) throws Exception {	Object result;	Object in = getInput(exchange);	if (in != null) {	result = session.insert(statement, in);	doProcessResult(exchange, result, session);	} else {	
inserting using statement 

private void doUpdate(Exchange exchange, SqlSession session) throws Exception {	Object result;	Object in = getInput(exchange);	if (in != null) {	Iterator<?> iter = ObjectHelper.createIterator(in);	while (iter.hasNext()) {	Object value = iter.next();	
updating using statement 

Object result;	Object in = getInput(exchange);	if (in != null) {	Iterator<?> iter = ObjectHelper.createIterator(in);	while (iter.hasNext()) {	Object value = iter.next();	result = session.update(statement, value);	doProcessResult(exchange, result, session);	}	} else {	
updating using statement 

private void doUpdateList(Exchange exchange, SqlSession session) throws Exception {	Object result;	Object in = getInput(exchange);	if (in != null) {	
updating using statement 

private void doUpdateList(Exchange exchange, SqlSession session) throws Exception {	Object result;	Object in = getInput(exchange);	if (in != null) {	result = session.update(statement, in);	doProcessResult(exchange, result, session);	} else {	
updating using statement 

private void doDelete(Exchange exchange, SqlSession session) throws Exception {	Object result;	Object in = getInput(exchange);	if (in != null) {	Iterator<?> iter = ObjectHelper.createIterator(in);	while (iter.hasNext()) {	Object value = iter.next();	
deleting using statement 

Object result;	Object in = getInput(exchange);	if (in != null) {	Iterator<?> iter = ObjectHelper.createIterator(in);	while (iter.hasNext()) {	Object value = iter.next();	result = session.delete(statement, value);	doProcessResult(exchange, result, session);	}	} else {	
deleting using statement 

private void doDeleteList(Exchange exchange, SqlSession session) throws Exception {	Object result;	Object in = getInput(exchange);	if (in != null) {	
deleting using statement 

private void doDeleteList(Exchange exchange, SqlSession session) throws Exception {	Object result;	Object in = getInput(exchange);	if (in != null) {	result = session.delete(statement, in);	doProcessResult(exchange, result, session);	} else {	
deleting using statement 

answer = exchange.getOut();	answer.getHeaders().putAll(exchange.getIn().getHeaders());	if (outputHeader != null) {	answer.setBody(exchange.getIn().getBody());	}	}	if (endpoint.getStatementType() == StatementType.SelectList || endpoint.getStatementType() == StatementType.SelectOne) {	MappedStatement ms = session.getConfiguration().getMappedStatement(statement);	if (ms != null && ms.getStatementType() == org.apache.ibatis.mapping.StatementType.CALLABLE) {	if (result == null) {	
setting result as existing body as mybatis statement type is callable and there was no result 

answer.setBody(exchange.getIn().getBody());	}	}	if (endpoint.getStatementType() == StatementType.SelectList || endpoint.getStatementType() == StatementType.SelectOne) {	MappedStatement ms = session.getConfiguration().getMappedStatement(statement);	if (ms != null && ms.getStatementType() == org.apache.ibatis.mapping.StatementType.CALLABLE) {	if (result == null) {	answer.setBody(exchange.getIn().getBody());	} else {	if (outputHeader != null) {	
setting result as header 

}	if (endpoint.getStatementType() == StatementType.SelectList || endpoint.getStatementType() == StatementType.SelectOne) {	MappedStatement ms = session.getConfiguration().getMappedStatement(statement);	if (ms != null && ms.getStatementType() == org.apache.ibatis.mapping.StatementType.CALLABLE) {	if (result == null) {	answer.setBody(exchange.getIn().getBody());	} else {	if (outputHeader != null) {	answer.setHeader(outputHeader, result);	} else {	
setting result as body 

} else {	if (outputHeader != null) {	answer.setHeader(outputHeader, result);	} else {	answer.setBody(result);	answer.setHeader(MyBatisConstants.MYBATIS_RESULT, result);	}	}	} else {	if (outputHeader != null) {	
setting result as header 

answer.setHeader(outputHeader, result);	} else {	answer.setBody(result);	answer.setHeader(MyBatisConstants.MYBATIS_RESULT, result);	}	}	} else {	if (outputHeader != null) {	answer.setHeader(outputHeader, result);	} else {	
setting result as body 

========================= camel sample_12957 =========================

public void process(Exchange exchange) throws Exception {	String q = query;	String location = exchange.getIn().getHeader(WeatherConstants.WEATHER_LOCATION, String.class);	if (location != null) {	q = getEndpoint().getConfiguration().getQuery(location);	}	HttpClient httpClient = ((WeatherComponent) getEndpoint().getComponent()).getHttpClient();	GetMethod method = new GetMethod(q);	try {	
going to execute the weather query 

q = getEndpoint().getConfiguration().getQuery(location);	}	HttpClient httpClient = ((WeatherComponent) getEndpoint().getComponent()).getHttpClient();	GetMethod method = new GetMethod(q);	try {	int statusCode = httpClient.executeMethod(method);	if (statusCode != HttpStatus.SC_OK) {	throw new IllegalStateException("Got the invalid http status value '" + method.getStatusLine() + "' as the result of the query '" + query + "'");	}	String weather = getEndpoint().getCamelContext().getTypeConverter().mandatoryConvertTo(String.class, method.getResponseBodyAsStream());	
got back the weather information 

========================= camel sample_11382 =========================

protected void debugBefore(Exchange exchange, Processor processor, ProcessorDefinition<?> definition, String id, String shortName) {	
before with body 

========================= camel sample_6815 =========================

}	private boolean doProceed(AsyncCallback callback) throws Exception {	if (dynamicRouter != null) {	if (!dynamicRouter.isStarted()) {	ServiceHelper.startService(dynamicRouter);	}	Expression expression = new DynamicRouterExpression(pojo);	return dynamicRouter.doRoutingSlip(exchange, expression, callback);	}	if (LOG.isTraceEnabled()) {	
invoking on bean with arguments for exchange 

if (!dynamicRouter.isStarted()) {	ServiceHelper.startService(dynamicRouter);	}	Expression expression = new DynamicRouterExpression(pojo);	return dynamicRouter.doRoutingSlip(exchange, expression, callback);	}	if (LOG.isTraceEnabled()) {	}	Object result = invoke(method, pojo, arguments, exchange);	if (result instanceof Callable) {	
method returned callback which will be called 

private void fillResult(Exchange exchange, Object result) {	
setting bean invocation result 

protected Expression[] createParameterExpressions() {	final int size = parameters.size();	
creating parameters expression for parameters 

protected Expression[] createParameterExpressions() {	final int size = parameters.size();	final Expression[] expressions = new Expression[size];	for (int i = 0; i < size; i++) {	Expression parameterExpression = parameters.get(i).getExpression();	expressions[i] = parameterExpression;	
parameter has expression 

for (Annotation annotation : annotations) {	Class<? extends Annotation> annotationType = annotation.annotationType();	if (annotation instanceof Pattern || annotationType.equals(annotatedElement)) {	continue;	} else {	Pattern another = getPatternAnnotation(annotationType, nextDepth);	if (pattern != null) {	if (answer == null) {	answer = another;	} else {	
duplicate pattern annotation found on annotation which will be ignored 

}	}	if (valid) {	if (parameterValue instanceof String) {	parameterValue = StringHelper.removeLeadingAndEndingQuotes((String) parameterValue);	}	if (parameterValue != null) {	try {	answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, exchange, parameterValue);	if (LOG.isTraceEnabled()) {	
parameter evaluated as type 

if (parameterValue instanceof String) {	parameterValue = StringHelper.removeLeadingAndEndingQuotes((String) parameterValue);	}	if (parameterValue != null) {	try {	answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, exchange, parameterValue);	if (LOG.isTraceEnabled()) {	}	} catch (Exception e) {	if (LOG.isDebugEnabled()) {	
cannot convert from type to type for parameter 

Object answer = null;	Object result = expression.evaluate(exchange, Object.class);	if (result != null) {	try {	if (parameterType.isInstance(result)) {	answer = result;	} else {	answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, result);	}	if (LOG.isTraceEnabled()) {	
parameter evaluated as type 

try {	if (parameterType.isInstance(result)) {	answer = result;	} else {	answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, result);	}	if (LOG.isTraceEnabled()) {	}	} catch (NoTypeConversionAvailableException e) {	if (LOG.isDebugEnabled()) {	
cannot convert from type to type for parameter 

answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, result);	}	if (LOG.isTraceEnabled()) {	}	} catch (NoTypeConversionAvailableException e) {	if (LOG.isDebugEnabled()) {	}	throw new ParameterBindingException(e, method, index, parameterType, result);	}	} else {	
parameter evaluated as null 

========================= camel sample_4828 =========================

public static void main(String[] args) {	
starting camel metrics example application 

public void beforeApplicationStart(CamelContext context) {	
configuring camel metrics on all routes 

========================= camel sample_17606 =========================

public void execute(Exchange exchange) throws SmppException {	SubmitMulti[] submitMulties = createSubmitMulti(exchange);	List<SubmitMultiResult> results = new ArrayList<SubmitMultiResult>(submitMulties.length);	for (SubmitMulti submitMulti : submitMulties) {	SubmitMultiResult result;	if (log.isDebugEnabled()) {	
sending multiple short messages for exchange id 

if (log.isDebugEnabled()) {	}	try {	result = session.submitMultiple( submitMulti.getServiceType(), TypeOfNumber.valueOf(submitMulti.getSourceAddrTon()), NumberingPlanIndicator.valueOf(submitMulti.getSourceAddrNpi()), submitMulti.getSourceAddr(), (Address[]) submitMulti.getDestAddresses(), new ESMClass(submitMulti.getEsmClass()), submitMulti.getProtocolId(), submitMulti.getPriorityFlag(), submitMulti.getScheduleDeliveryTime(), submitMulti.getValidityPeriod(), new RegisteredDelivery(submitMulti.getRegisteredDelivery()), new ReplaceIfPresentFlag(submitMulti.getReplaceIfPresentFlag()), DataCodings.newInstance(submitMulti.getDataCoding()), submitMulti.getSmDefaultMsgId(), submitMulti.getShortMessage(), submitMulti.getOptionalParameters());	results.add(result);	} catch (Exception e) {	throw new SmppException(e);	}	}	if (log.isDebugEnabled()) {	
sent multiple short messages for exchange id and received results 

========================= camel sample_16914 =========================

type = "silver";	} else if (i % 2 == 0) {	type = "gold";	} else {	type = "bronze";	}	template.sendBodyAndHeader("activemq:queue:inbox", "Message " + i, "type", type);	}	assertMockEndpointsSatisfied();	long delta = System.currentTimeMillis() - start;	
routeperformancepojotest sent took ms 

========================= camel sample_7029 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KubernetesReplicationControllersComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-replication-controllers.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-replication-controllers.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_560 =========================

public void tapSomething(String body) throws Exception {	try {	LATCH.await(5, TimeUnit.SECONDS);	Thread.sleep(100);	} catch (Exception e) {	fail("Should not be interrupted");	}	
wire tapping 

========================= camel sample_2381 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<CouchbaseComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.couchbase.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.couchbase.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_999 =========================

Component component = context.getComponent("seda");	ComponentConfiguration configuration = component.createComponentConfiguration();	assertNotNull("Should have created a ComponentConfiguration for component " + component, configuration);	configuration.setBaseUri("foo");	configuration.setParameter("concurrentConsumers", 5);	configuration.setParameter("size", 1000);	try {	configuration.setParameter("doesNotExist", 1000);	fail("Should have got InvalidPropertyException thrown!");	} catch (InvalidPropertyException e) {	
got expected exception 

SedaEndpoint endpoint = TestSupport .assertIsInstanceOf(SedaEndpoint.class, configuration.createEndpoint());	assertEquals("concurrentConsumers", 5, endpoint.getConcurrentConsumers());	assertEquals("size", 1000, endpoint.getSize());	assertEquals("endpoint uri", "foo?concurrentConsumers=5&size=1000", endpoint.getEndpointUri());	configuration.setEndpointParameter(endpoint, "concurrentConsumers", 6);	assertEquals("concurrentConsumers", 6, endpoint.getConcurrentConsumers());	try {	configuration.setEndpointParameter(endpoint, "doesNotExist", 1000);	fail("Should have got InvalidPropertyException thrown!");	} catch (InvalidPropertyException e) {	
got expected exception 

public void testCreateNewDefaultComponentEndpoint() throws Exception {	Component component = context.getComponent("cheese");	ComponentConfiguration configuration = component.createComponentConfiguration();	assertNotNull("Should have created a ComponentConfiguration for component " + component, configuration);	configuration.setBaseUri("something");	configuration.setParameter("foo", "xyz");	configuration.setParameter("bar", 5);	NonUriEndpoint endpoint = TestSupport .assertIsInstanceOf(NonUriEndpoint.class, configuration.createEndpoint());	assertEquals("foo", "xyz", endpoint.getFoo());	assertEquals("bar", 5, endpoint.getBar());	
created endpoint on uri 

configuration.setParameter("bar", 5);	NonUriEndpoint endpoint = TestSupport .assertIsInstanceOf(NonUriEndpoint.class, configuration.createEndpoint());	assertEquals("foo", "xyz", endpoint.getFoo());	assertEquals("bar", 5, endpoint.getBar());	configuration.setEndpointParameter(endpoint, "bar", 6);	assertEquals("bar", 6, endpoint.getBar());	try {	configuration.setEndpointParameter(endpoint, "doesNotExist", 1000);	fail("Should have got InvalidPropertyException thrown!");	} catch (InvalidPropertyException e) {	
got expected exception 

} catch (InvalidPropertyException e) {	}	ComponentConfiguration badConfiguration = component.createComponentConfiguration();	badConfiguration.setBaseUri(configuration.getBaseUri());	badConfiguration.setParameters(configuration.getParameters());	badConfiguration.setParameter("doesNotExist", 1000);	try {	badConfiguration.createEndpoint();	fail("Should have got ResolveEndpointFailedException thrown!");	} catch (ResolveEndpointFailedException e) {	
got expected exception 

public void testIntrospectSedaEndpointParameters() throws Exception {	Component component = context.getComponent("seda");	ComponentConfiguration configuration = component.createComponentConfiguration();	assertNotNull("Should have created a ComponentConfiguration for component " + component, configuration);	SortedMap<String, ParameterConfiguration> parameterMap = configuration.getParameterConfigurationMap();	assertTrue("getParameterConfigurationMap() should not be empty!", !parameterMap.isEmpty());	ParameterConfiguration concurrentConsumersConfig = parameterMap.get("concurrentConsumers");	assertNotNull("parameterMap[concurrentConsumers] should not be null!", concurrentConsumersConfig);	assertEquals("concurrentConsumersConfig.getName()", "concurrentConsumers", concurrentConsumersConfig.getName());	assertEquals("concurrentConsumersConfig.getParameterType()", int.class, concurrentConsumersConfig.getParameterType());	
has has configuration properties 

configuration.setEndpointParameter(endpoint, "concurrentConsumers", 10);	Object concurrentConsumers = configuration.getEndpointParameter(endpoint, "concurrentConsumers");	assertEquals("endpoint.concurrentConsumers", 10, concurrentConsumers);	configuration.setEndpointParameter(endpoint, "size", 1000);	Object size = configuration.getEndpointParameter(endpoint, "size");	assertEquals("endpoint.size", 1000, size);	try {	configuration.setEndpointParameter(endpoint, "doesNotExist", 1000);	fail("Should have got InvalidPropertyException thrown!");	} catch (InvalidPropertyException e) {	
got expected exception 

configuration.setEndpointParameter(endpoint, "bar", 10);	Object bar = configuration.getEndpointParameter(endpoint, "bar");	assertEquals("endpoint.bar", 10, bar);	configuration.setEndpointParameter(endpoint, "foo", "anotherThing");	Object foo = configuration.getEndpointParameter(endpoint, "foo");	assertEquals("endpoint.foo", "anotherThing", foo);	try {	configuration.setEndpointParameter(endpoint, "doesNotExist", 1000);	fail("Should have got InvalidPropertyException thrown!");	} catch (InvalidPropertyException e) {	
got expected exception 

========================= camel sample_1407 =========================

private void doTestGetVersions(String suffix) throws Exception {	Object o = template().requestBody("direct:getVersions" + suffix, (Object) null);	List<Version> versions = null;	if (o instanceof Versions) {	versions = ((Versions) o).getVersions();	} else {	versions = (List<Version>) o;	}	assertNotNull(versions);	
versions 

sslContextFactory.setSslContext(contextParameters.createSSLContext());	ServerConnector connector = new ServerConnector(server, sslContextFactory);	ServerConnector connector = new ServerConnector(server);	connector.setHost(HTTP_PROXY_HOST);	server.addConnector(connector);	final String authenticationString = "Basic " + B64Code.encode(HTTP_PROXY_USER_NAME + ":" + HTTP_PROXY_PASSWORD, StringUtil.__ISO_8859_1);	ConnectHandler connectHandler = new ConnectHandler() {	protected boolean handleAuthentication(HttpServletRequest request, HttpServletResponse response, String address) {	final String header = request.getHeader(PROXY_AUTHORIZATION.toString());	if (!authenticationString.equals(header)) {	
missing header 

connector.setHost(HTTP_PROXY_HOST);	server.addConnector(connector);	final String authenticationString = "Basic " + B64Code.encode(HTTP_PROXY_USER_NAME + ":" + HTTP_PROXY_PASSWORD, StringUtil.__ISO_8859_1);	ConnectHandler connectHandler = new ConnectHandler() {	protected boolean handleAuthentication(HttpServletRequest request, HttpServletResponse response, String address) {	final String header = request.getHeader(PROXY_AUTHORIZATION.toString());	if (!authenticationString.equals(header)) {	response.setHeader(PROXY_AUTHENTICATE.toString(), String.format("Basic realm=\"%s\"", HTTP_PROXY_REALM));	return false;	}	
request contains required header 

protected boolean handleAuthentication(HttpServletRequest request, HttpServletResponse response, String address) {	final String header = request.getHeader(PROXY_AUTHORIZATION.toString());	if (!authenticationString.equals(header)) {	response.setHeader(PROXY_AUTHENTICATE.toString(), String.format("Basic realm=\"%s\"", HTTP_PROXY_REALM));	return false;	}	return true;	}	};	server.setHandler(connectHandler);	
starting proxy server 

if (!authenticationString.equals(header)) {	response.setHeader(PROXY_AUTHENTICATE.toString(), String.format("Basic realm=\"%s\"", HTTP_PROXY_REALM));	return false;	}	return true;	}	};	server.setHandler(connectHandler);	server.start();	httpProxyPort = connector.getLocalPort();	
started proxy server on port 

public static void tearDownAfterClass() throws Exception {	CamelTestSupport.tearDownAfterClass();	
stopping proxy server 

public static void tearDownAfterClass() throws Exception {	CamelTestSupport.tearDownAfterClass();	server.stop();	
stopped proxy server 

========================= camel sample_14704 =========================

public void appendBuilders(List<RoutesBuilder> list) {	Map<String, RoutesBuilder> beans = applicationContext.getBeansOfType(RoutesBuilder.class, includeNonSingletons, true);	for (Entry<String, RoutesBuilder> entry : beans.entrySet()) {	Object bean = entry.getValue();	Object key = entry.getKey();	
found routebuilder with id 

public void appendBuilders(List<RoutesBuilder> list) {	Map<String, RoutesBuilder> beans = applicationContext.getBeansOfType(RoutesBuilder.class, includeNonSingletons, true);	for (Entry<String, RoutesBuilder> entry : beans.entrySet()) {	Object bean = entry.getValue();	Object key = entry.getKey();	if (shouldIgnoreBean(bean)) {	
ignoring routebuilder id 

public void appendBuilders(List<RoutesBuilder> list) {	Map<String, RoutesBuilder> beans = applicationContext.getBeansOfType(RoutesBuilder.class, includeNonSingletons, true);	for (Entry<String, RoutesBuilder> entry : beans.entrySet()) {	Object bean = entry.getValue();	Object key = entry.getKey();	if (shouldIgnoreBean(bean)) {	continue;	}	if (!isFilteredClass(bean)) {	
ignoring filtered routebuilder id as class 

Map<String, RoutesBuilder> beans = applicationContext.getBeansOfType(RoutesBuilder.class, includeNonSingletons, true);	for (Entry<String, RoutesBuilder> entry : beans.entrySet()) {	Object bean = entry.getValue();	Object key = entry.getKey();	if (shouldIgnoreBean(bean)) {	continue;	}	if (!isFilteredClass(bean)) {	continue;	}	
adding instantiated routebuilder id as class 

========================= camel sample_16369 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<LZFDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.lzf.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.lzf.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_1057 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<GzipDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.gzip.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.gzip.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_833 =========================

MockEndpoint mock = getMockEndpoint("mock:done");	mock.expectedMessageCount(number);	mock.expectsNoDuplicates(body());	createManyFiles(number);	context.startRoute("myRoute");	mock.setResultWaitTime(180 * 1000);	mock.assertIsSatisfied();	context.stop();	int found = 0;	log.info("=====================");	
printing duplicates 

public void process(Exchange exchange) throws Exception {	Integer integer = duplicate.get(exchange.toString());	if (integer == null) {	duplicate.put(exchange.toString(), 1);	} else {	integer++;	duplicate.put(exchange.toString(), integer);	}	
process called for 

========================= camel sample_3085 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<BindyKeyValuePairDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.bindy-kvp.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.bindy-kvp.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_976 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ChunkComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.chunk.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.chunk.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1112 =========================

public MllpTcpServerConsumer(MllpEndpoint endpoint, Processor processor) {	super(endpoint, processor);	
mllptcpserverconsumer endpoint processor 

public void closeConnections() {	for (TcpSocketConsumerRunnable consumerRunnable : consumerRunnables.keySet()) {	if (consumerRunnable != null) {	
close connection called via jmx for address 

public void resetConnections() {	for (TcpSocketConsumerRunnable consumerRunnable : consumerRunnables.keySet()) {	if (consumerRunnable != null) {	
reset connection called via jmx for address 

protected void doStop() throws Exception {	
dostop 

protected void doStart() throws Exception {	
dostart starting acceptor 

serverSocket.setSoTimeout(getConfiguration().getAcceptTimeout());	InetSocketAddress socketAddress;	if (null == getEndpoint().getHostname()) {	socketAddress = new InetSocketAddress(getEndpoint().getPort());	} else {	socketAddress = new InetSocketAddress(getEndpoint().getHostname(), getEndpoint().getPort());	}	long startTicks = System.currentTimeMillis();	if (getConfiguration().hasMaxReceiveTimeouts()) {	if (getConfiguration().hasIdleTimeout()) {	
both maxreceivedtimeouts and idletimeout uri options are specified idletimeout will be used 

if (null == getEndpoint().getHostname()) {	socketAddress = new InetSocketAddress(getEndpoint().getPort());	} else {	socketAddress = new InetSocketAddress(getEndpoint().getHostname(), getEndpoint().getPort());	}	long startTicks = System.currentTimeMillis();	if (getConfiguration().hasMaxReceiveTimeouts()) {	if (getConfiguration().hasIdleTimeout()) {	} else {	getConfiguration().setIdleTimeout(getConfiguration().getMaxReceiveTimeouts() * getConfiguration().getReceiveTimeout());	
deprecated uri option maxreceivedtimeouts specified idletimeout will be used 

}	do {	try {	if (getConfiguration().hasBacklog()) {	serverSocket.bind(socketAddress, getConfiguration().getBacklog());	} else {	serverSocket.bind(socketAddress);	}	} catch (BindException bindException) {	if (System.currentTimeMillis() > startTicks + getConfiguration().getBindTimeout()) {	
failed to bind to address within timeout 

try {	if (getConfiguration().hasBacklog()) {	serverSocket.bind(socketAddress, getConfiguration().getBacklog());	} else {	serverSocket.bind(socketAddress);	}	} catch (BindException bindException) {	if (System.currentTimeMillis() > startTicks + getConfiguration().getBindTimeout()) {	throw bindException;	} else {	
failed to bind to address retrying in milliseconds 

public void startConsumer(Socket clientSocket) {	TcpSocketConsumerRunnable client = new TcpSocketConsumerRunnable(this, clientSocket);	consumerRunnables.put(client, System.currentTimeMillis());	try {	
starting consumer for socket 

public void startConsumer(Socket clientSocket) {	TcpSocketConsumerRunnable client = new TcpSocketConsumerRunnable(this, clientSocket);	consumerRunnables.put(client, System.currentTimeMillis());	try {	consumerExecutor.submit(client);	} catch (RejectedExecutionException rejectedExecutionEx) {	
cannot start consumer max consumers already active 

========================= camel sample_13887 =========================

public static void startGrpcServer() throws Exception {	grpcServer = ServerBuilder.forPort(GRPC_TEST_PORT).addService(new PingPongImpl()).build().start();	
grpc server started on port 

public static void stopGrpcServer() throws IOException {	if (grpcServer != null) {	grpcServer.shutdown();	
grpc server stoped 

public void testPingSyncSyncMethodInvocation() throws Exception {	
grpc pingsyncsync method test start 

public void testPingSyncSyncMultipleInvocation() throws Exception {	final Stopwatch stopwatch = Stopwatch.createStarted();	for (int id = 0; id < MULTIPLE_RUN_TEST_COUNT; id++) {	PingRequest pingRequest = PingRequest.newBuilder().setPingName(GRPC_TEST_PING_VALUE + id).setPingId(id).build();	Object pongResponse = template.requestBody("direct:grpc-sync-sync", pingRequest);	assertEquals(((PongResponse)pongResponse).getPongId(), id);	}	
multiple sync invocation time milliseconds everage operations sec 

public void testPingSyncAsyncMethodInvocation() throws Exception {	
grpc pingsyncasync method test start 

========================= camel sample_7496 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	onException(IllegalArgumentException.class) .maximumRedeliveries(5).redeliveryDelay(0);	from("seda:start") .to("log:before") .to("mock:before") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	
processing at attempt 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	onException(IllegalArgumentException.class) .maximumRedeliveries(5).redeliveryDelay(0);	from("seda:start") .to("log:before") .to("mock:before") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String body = exchange.getIn().getBody(String.class);	if (body.contains("World")) {	if (++attempt <= 2) {	
processing failed will thrown an exception 

onException(IllegalArgumentException.class) .maximumRedeliveries(5).redeliveryDelay(0);	from("seda:start") .to("log:before") .to("mock:before") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String body = exchange.getIn().getBody(String.class);	if (body.contains("World")) {	if (++attempt <= 2) {	throw new IllegalArgumentException("Damn");	}	}	exchange.getIn().setBody("Hello " + body);	
processing at attempt complete 

========================= camel sample_1811 =========================

protected void doGetReplicationController(Exchange exchange, String operation) throws Exception {	ReplicationController rc = null;	String rcName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_REPLICATION_CONTROLLER_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(rcName)) {	
get a specific replication controller require specify a replication controller name 

protected void doGetReplicationController(Exchange exchange, String operation) throws Exception {	ReplicationController rc = null;	String rcName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_REPLICATION_CONTROLLER_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(rcName)) {	throw new IllegalArgumentException( "Get a specific replication controller require specify a replication controller name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
get a specific replication controller require specify a namespace name 

protected void doCreateReplicationController(Exchange exchange, String operation) throws Exception {	ReplicationController rc = null;	String rcName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_REPLICATION_CONTROLLER_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	ReplicationControllerSpec rcSpec = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_REPLICATION_CONTROLLER_SPEC, ReplicationControllerSpec.class);	if (ObjectHelper.isEmpty(rcName)) {	
create a specific replication controller require specify a replication controller name 

protected void doCreateReplicationController(Exchange exchange, String operation) throws Exception {	ReplicationController rc = null;	String rcName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_REPLICATION_CONTROLLER_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	ReplicationControllerSpec rcSpec = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_REPLICATION_CONTROLLER_SPEC, ReplicationControllerSpec.class);	if (ObjectHelper.isEmpty(rcName)) {	throw new IllegalArgumentException( "Create a specific replication controller require specify a replication controller name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
create a specific replication controller require specify a namespace name 

String rcName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_REPLICATION_CONTROLLER_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	ReplicationControllerSpec rcSpec = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_REPLICATION_CONTROLLER_SPEC, ReplicationControllerSpec.class);	if (ObjectHelper.isEmpty(rcName)) {	throw new IllegalArgumentException( "Create a specific replication controller require specify a replication controller name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	throw new IllegalArgumentException( "Create a specific replication controller require specify a namespace name");	}	if (ObjectHelper.isEmpty(rcSpec)) {	
create a specific replication controller require specify a replication controller spec bean 

protected void doDeleteReplicationController(Exchange exchange, String operation) throws Exception {	String rcName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_REPLICATION_CONTROLLER_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(rcName)) {	
delete a specific replication controller require specify a replication controller name 

protected void doDeleteReplicationController(Exchange exchange, String operation) throws Exception {	String rcName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_REPLICATION_CONTROLLER_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(rcName)) {	throw new IllegalArgumentException( "Delete a specific replication controller require specify a replication controller name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
delete a specific replication controller require specify a namespace name 

protected void doScaleReplicationController(Exchange exchange, String operation) throws Exception {	String rcName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_REPLICATION_CONTROLLER_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	Integer replicasNumber = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_REPLICATION_CONTROLLER_REPLICAS, Integer.class);	if (ObjectHelper.isEmpty(rcName)) {	
scale a specific replication controller require specify a replication controller name 

protected void doScaleReplicationController(Exchange exchange, String operation) throws Exception {	String rcName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_REPLICATION_CONTROLLER_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	Integer replicasNumber = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_REPLICATION_CONTROLLER_REPLICAS, Integer.class);	if (ObjectHelper.isEmpty(rcName)) {	throw new IllegalArgumentException( "Scale a specific replication controller require specify a replication controller name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
scale a specific replication controller require specify a namespace name 

String rcName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_REPLICATION_CONTROLLER_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	Integer replicasNumber = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_REPLICATION_CONTROLLER_REPLICAS, Integer.class);	if (ObjectHelper.isEmpty(rcName)) {	throw new IllegalArgumentException( "Scale a specific replication controller require specify a replication controller name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	throw new IllegalArgumentException( "Scale a specific replication controller require specify a namespace name");	}	if (ObjectHelper.isEmpty(replicasNumber)) {	
scale a specific replication controller require specify a replicas number 

========================= camel sample_13307 =========================

context.setName("context-" + id);	context.addService(service);	context.addRoutes(new RouteBuilder() {	public void configure() throws Exception {	from("timer:file-lock?delay=1s&period=1s") .routeId("route-" + id) .routePolicy(ClusteredRoutePolicy.forNamespace("my-ns")) .log("From ${routeId}") .process(e -> contextLatch.countDown());	}	});	Thread.sleep(ThreadLocalRandom.current().nextInt(500));	context.start();	contextLatch.await();	
shutting down node 

========================= camel sample_2944 =========================

public void warning(TransformerException e) throws TransformerException {	
warning parsing xslt file 

public void error(TransformerException e) throws TransformerException {	
error parsing xslt file 

public void fatalError(TransformerException e) throws TransformerException {	
fatal error parsing xslt file 

========================= camel sample_5628 =========================

public final synchronized void activate(final BundleContext bundleContext, final Map<String, String> props) throws Exception {	if (activated) {	return;	}	
activated 

public final synchronized void deactivate() {	if (!activated) {	return;	}	
deactivated 

if (started) {	return;	}	try {	if (!active) {	context.setAutoStartup(false);	}	context.start();	started = true;	} catch (Exception e) {	
failed to start camel context will try again when more camel components have been registered 

private void stopCamelContext() {	if (!started) {	return;	}	try {	context.stop();	} catch (Exception e) {	
failed to stop camel context 

protected final void gotCamelComponent(final ServiceReference serviceReference) {	
got a new camel component 

protected final void lostCamelComponent(final ServiceReference serviceReference) {	
lost a camel component 

========================= camel sample_12516 =========================

public void unscheduleTask() {	if (trigger != null) {	
unscheduling trigger 

map.put("routeId", routeId);	} else {	map.put("task", runnable);	}	map.put(QuartzConstants.QUARTZ_TRIGGER_TYPE, "cron");	map.put(QuartzConstants.QUARTZ_TRIGGER_CRON_EXPRESSION, getCron());	map.put(QuartzConstants.QUARTZ_TRIGGER_CRON_TIMEZONE, getTimeZone().getID());	job = JobBuilder.newJob(QuartzScheduledPollConsumerJob.class).usingJobData(map).build();	QuartzHelper.updateJobDataMap(getCamelContext(), job, null);	trigger = TriggerBuilder.newTrigger().withIdentity(id, triggerGroup) .withSchedule(CronScheduleBuilder.cronSchedule(getCron()).inTimeZone(getTimeZone())) .build();	
scheduling job with trigger 

}	map.put(QuartzConstants.QUARTZ_TRIGGER_TYPE, "cron");	map.put(QuartzConstants.QUARTZ_TRIGGER_CRON_EXPRESSION, getCron());	map.put(QuartzConstants.QUARTZ_TRIGGER_CRON_TIMEZONE, getTimeZone().getID());	job = JobBuilder.newJob(QuartzScheduledPollConsumerJob.class).usingJobData(map).build();	QuartzHelper.updateJobDataMap(getCamelContext(), job, null);	trigger = TriggerBuilder.newTrigger().withIdentity(id, triggerGroup) .withSchedule(CronScheduleBuilder.cronSchedule(getCron()).inTimeZone(getTimeZone())) .build();	quartzScheduler.scheduleJob(job, trigger);	} else {	checkTriggerIsNonConflicting(existingTrigger);	
trigger with key is already present in scheduler only updating it 

QuartzHelper.updateJobDataMap(getCamelContext(), job, null);	trigger = TriggerBuilder.newTrigger().withIdentity(id, triggerGroup) .withSchedule(CronScheduleBuilder.cronSchedule(getCron()).inTimeZone(getTimeZone())) .build();	quartzScheduler.scheduleJob(job, trigger);	} else {	checkTriggerIsNonConflicting(existingTrigger);	job = quartzScheduler.getJobDetail(existingTrigger.getJobKey());	JobDataMap jobData = job.getJobDataMap();	jobData.put(QuartzConstants.QUARTZ_TRIGGER_CRON_EXPRESSION, getCron());	jobData.put(QuartzConstants.QUARTZ_TRIGGER_CRON_TIMEZONE, getTimeZone().getID());	QuartzHelper.updateJobDataMap(getCamelContext(), job, null);	
updated jobdata map to 

quartzScheduler.scheduleJob(job, trigger);	} else {	checkTriggerIsNonConflicting(existingTrigger);	job = quartzScheduler.getJobDetail(existingTrigger.getJobKey());	JobDataMap jobData = job.getJobDataMap();	jobData.put(QuartzConstants.QUARTZ_TRIGGER_CRON_EXPRESSION, getCron());	jobData.put(QuartzConstants.QUARTZ_TRIGGER_CRON_TIMEZONE, getTimeZone().getID());	QuartzHelper.updateJobDataMap(getCamelContext(), job, null);	trigger = existingTrigger.getTriggerBuilder() .withSchedule(CronScheduleBuilder.cronSchedule(getCron()).inTimeZone(getTimeZone())) .build();	if (hasTriggerChanged(existingTrigger, trigger)) {	
re scheduling job with trigger 

checkTriggerIsNonConflicting(existingTrigger);	job = quartzScheduler.getJobDetail(existingTrigger.getJobKey());	JobDataMap jobData = job.getJobDataMap();	jobData.put(QuartzConstants.QUARTZ_TRIGGER_CRON_EXPRESSION, getCron());	jobData.put(QuartzConstants.QUARTZ_TRIGGER_CRON_TIMEZONE, getTimeZone().getID());	QuartzHelper.updateJobDataMap(getCamelContext(), job, null);	trigger = existingTrigger.getTriggerBuilder() .withSchedule(CronScheduleBuilder.cronSchedule(getCron()).inTimeZone(getTimeZone())) .build();	if (hasTriggerChanged(existingTrigger, trigger)) {	quartzScheduler.rescheduleJob(triggerKey, trigger);	} else {	
scheduling job with trigger 

protected void doStop() throws Exception {	if (trigger != null) {	
unscheduling trigger 

========================= camel sample_14991 =========================

Integer size = getSize() == Integer.MAX_VALUE ? null : getSize();	QueueReference ref = getComponent().getOrCreateQueue(this, size, isMultipleConsumers(), queueFactory);	queue = ref.getQueue();	String key = getComponent().getQueueKey(getEndpointUri());	LOG.info("Endpoint {} is using shared queue: {} with size: {}", new Object[]{this, key, ref.getSize() !=  null ? ref.getSize() : Integer.MAX_VALUE});	if (ref.getSize() != null) {	setSize(ref.getSize());	}	} else {	queue = createQueue();	
endpoint is using queue with size 

public void purgeQueue() {	
purging queue with exchanges 

public void stop() throws Exception {	if (getConsumers().isEmpty()) {	super.stop();	} else {	
there is still active consumers 

public void shutdown() throws Exception {	if (shutdown.get()) {	
service already shut down 

public void shutdown() throws Exception {	if (shutdown.get()) {	return;	}	if (getComponent() != null) {	getComponent().onShutdownEndpoint(this);	}	if (getConsumers().isEmpty()) {	super.shutdown();	} else {	
there is still active consumers 

========================= camel sample_4890 =========================

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyNewLineRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, false);	for (ParserResult result : list) {	
consumer 

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyNewLineRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, false);	for (ParserResult result : list) {	}	Assert.assertEquals("timer:foo", list.get(0).getElement());	list = CamelJavaParserHelper.parseCamelProducerUris(method, true, false);	for (ParserResult result : list) {	
producer 

========================= camel sample_219 =========================

public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {	File tarFile;	Exchange answer = oldExchange;	if (newExchange == null) {	return oldExchange;	}	if (oldExchange == null) {	try {	tarFile = FileUtil.createTempFile(this.filePrefix, this.fileSuffix, parentDir);	
created temporary file 

tos.putArchiveEntry(nextEntry);	IOUtils.copy(tin, tos);	tos.closeArchiveEntry();	}	TarArchiveEntry entry = new TarArchiveEntry(fileName == null ? file.getName() : fileName);	entry.setSize(file.length());	tos.putArchiveEntry(entry);	IOUtils.copy(in, tos);	tos.closeArchiveEntry();	IOHelper.close(fis, in, tin, tos);	
deleting temporary file 

tos.putArchiveEntry(nextEntry);	IOUtils.copy(tin, tos);	tos.closeArchiveEntry();	}	TarArchiveEntry entry = new TarArchiveEntry(entryName);	entry.setSize(length);	tos.putArchiveEntry(entry);	tos.write(buffer, 0, length);	tos.closeArchiveEntry();	IOHelper.close(fis, tin, tos);	
deleting temporary file 

public void onComplete(Exchange exchange) {	
deleting tar file on completion 

========================= camel sample_12453 =========================

public void init(CamelContext camelContext, NettyServerBootstrapConfiguration configuration, ChannelInitializer<Channel> pipelineFactory) {	super.init(camelContext, configuration, pipelineFactory);	this.port = configuration.getPort();	this.bootstrapConfiguration = configuration;	
bootstrapfactory on port is using bootstrap configuration 

public void addConsumer(NettyConsumer consumer) {	if (compatibleCheck) {	if (bootstrapConfiguration != consumer.getConfiguration() && !bootstrapConfiguration.compatible(consumer.getConfiguration())) {	throw new IllegalArgumentException("Bootstrap configuration must be identical when adding additional consumer: " + consumer.getEndpoint() + " on same port: " + port + ".\n  Existing " + bootstrapConfiguration.toStringBootstrapConfiguration() + "\n       New " + consumer.getConfiguration().toStringBootstrapConfiguration());	}	}	if (LOG.isDebugEnabled()) {	NettyHttpConsumer httpConsumer = (NettyHttpConsumer) consumer;	
bootstrapfactory on port is adding consumer with context path 

public void removeConsumer(NettyConsumer consumer) {	if (LOG.isDebugEnabled()) {	NettyHttpConsumer httpConsumer = (NettyHttpConsumer) consumer;	
bootstrapfactory on port is removing consumer with context path 

protected void doStart() throws Exception {	
bootstrapfactory on port is starting 

public void stop() throws Exception {	int consumers = channelFactory.consumers();	if (consumers == 0) {	
bootstrapfactory on port is stopping 

public void stop() throws Exception {	int consumers = channelFactory.consumers();	if (consumers == 0) {	super.stop();	} else {	
bootstrapfactory on port has registered consumers so cannot stop yet 

========================= camel sample_16685 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<CMISComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.cmis.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.cmis.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1041 =========================

}	boolean allowed = true;	synchronized (this) {	if (this.subscription != null) {	allowed = false;	} else {	this.subscription = subscription;	}	}	if (!allowed) {	
there is another active subscription cancelled 

}	}	if (target != null) {	target.process(exchange, doneSync -> {	synchronized (this) {	inflightCount--;	}	refill();	});	} else {	
message received in stream but no consumers were attached discarding 

public void onError(Throwable throwable) {	if (throwable == null) {	throw new NullPointerException("throwable is null");	}	
error in reactive stream 

public void onComplete() {	
reactive stream completed 

========================= camel sample_11510 =========================

protected void executeModel() throws MojoExecutionException, MojoFailureException {	getLog().info("================================================================================");	
copying all camel model json descriptors 

if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes/org/apache/camel/model");	PackageHelper.findJsonFiles(target, jsonFiles, new PackageHelper.CamelComponentsModelFilter());	}	if (springDir != null && springDir.isDirectory()) {	File target = new File(springDir, "target/classes/org/apache/camel/spring");	PackageHelper.findJsonFiles(target, jsonFiles, new PackageHelper.CamelComponentsModelFilter());	File target2 = new File(springDir, "target/classes/org/apache/camel/core/xml");	PackageHelper.findJsonFiles(target2, jsonFiles, new PackageHelper.CamelComponentsModelFilter());	}	
found model json files 

File target = new File(springDir, "target/classes/org/apache/camel/spring");	PackageHelper.findJsonFiles(target, jsonFiles, new PackageHelper.CamelComponentsModelFilter());	File target2 = new File(springDir, "target/classes/org/apache/camel/core/xml");	PackageHelper.findJsonFiles(target2, jsonFiles, new PackageHelper.CamelComponentsModelFilter());	}	modelsOutDir.mkdirs();	for (File file : jsonFiles) {	File to = new File(modelsOutDir, file.getName());	if (to.exists()) {	duplicateJsonFiles.add(to);	
duplicate model name detected 

protected Set<String> executeComponents() throws MojoExecutionException, MojoFailureException {	
copying all camel component json descriptors 

File target = new File(coreDir, "target/classes");	int before = componentFiles.size();	int before2 = jsonFiles.size();	findComponentFilesRecursive(target, jsonFiles, componentFiles, new CamelComponentsFileFilter());	int after = componentFiles.size();	int after2 = jsonFiles.size();	if (before != after && before2 == after2) {	missingComponents.add(coreDir);	}	}	
found component properties files 

File target = new File(coreDir, "target/classes");	int before = componentFiles.size();	int before2 = jsonFiles.size();	findComponentFilesRecursive(target, jsonFiles, componentFiles, new CamelComponentsFileFilter());	int after = componentFiles.size();	int after2 = jsonFiles.size();	if (before != after && before2 == after2) {	missingComponents.add(coreDir);	}	}	
found component json files 

if (before != after && before2 == after2) {	missingComponents.add(coreDir);	}	}	componentsOutDir.mkdirs();	Set<String> alternativeSchemes = new HashSet<>();	for (File file : jsonFiles) {	File to = new File(componentsOutDir, file.getName());	if (to.exists()) {	duplicateJsonFiles.add(to);	
duplicate component name detected 

protected Set<String> executeDataFormats() throws MojoExecutionException, MojoFailureException {	
copying all camel dataformat json descriptors 

File target = new File(dir, "target/classes");	findDataFormatFilesRecursive(target, jsonFiles, dataFormatFiles, new CamelDataFormatsFileFilter());	}	}	}	}	if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes");	findDataFormatFilesRecursive(target, jsonFiles, dataFormatFiles, new CamelDataFormatsFileFilter());	}	
found dataformat properties files 

File target = new File(dir, "target/classes");	findDataFormatFilesRecursive(target, jsonFiles, dataFormatFiles, new CamelDataFormatsFileFilter());	}	}	}	}	if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes");	findDataFormatFilesRecursive(target, jsonFiles, dataFormatFiles, new CamelDataFormatsFileFilter());	}	
found dataformat json files 

}	if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes");	findDataFormatFilesRecursive(target, jsonFiles, dataFormatFiles, new CamelDataFormatsFileFilter());	}	dataFormatsOutDir.mkdirs();	for (File file : jsonFiles) {	File to = new File(dataFormatsOutDir, file.getName());	if (to.exists()) {	duplicateJsonFiles.add(to);	
duplicate dataformat name detected 

protected Set<String> executeLanguages() throws MojoExecutionException, MojoFailureException {	
copying all camel language json descriptors 

File target = new File(dir, "target/classes");	findLanguageFilesRecursive(target, jsonFiles, languageFiles, new CamelLanguagesFileFilter());	}	}	}	}	if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes");	findLanguageFilesRecursive(target, jsonFiles, languageFiles, new CamelLanguagesFileFilter());	}	
found language properties files 

File target = new File(dir, "target/classes");	findLanguageFilesRecursive(target, jsonFiles, languageFiles, new CamelLanguagesFileFilter());	}	}	}	}	if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes");	findLanguageFilesRecursive(target, jsonFiles, languageFiles, new CamelLanguagesFileFilter());	}	
found language json files 

}	if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes");	findLanguageFilesRecursive(target, jsonFiles, languageFiles, new CamelLanguagesFileFilter());	}	languagesOutDir.mkdirs();	for (File file : jsonFiles) {	File to = new File(languagesOutDir, file.getName());	if (to.exists()) {	duplicateJsonFiles.add(to);	
duplicate language name detected 

private Set<String> executeOthers() throws MojoFailureException {	
copying all camel other json descriptors 

if (special || special2) {	continue;	}	if (dir.isDirectory() && !"target".equals(dir.getName())) {	File target = new File(dir, "target/classes");	findOtherFilesRecursive(target, jsonFiles, otherFiles, new CamelOthersFileFilter());	}	}	}	}	
found other properties files 

if (special || special2) {	continue;	}	if (dir.isDirectory() && !"target".equals(dir.getName())) {	File target = new File(dir, "target/classes");	findOtherFilesRecursive(target, jsonFiles, otherFiles, new CamelOthersFileFilter());	}	}	}	}	
found other json files 

findOtherFilesRecursive(target, jsonFiles, otherFiles, new CamelOthersFileFilter());	}	}	}	}	othersOutDir.mkdirs();	for (File file : jsonFiles) {	File to = new File(othersOutDir, file.getName());	if (to.exists()) {	duplicateJsonFiles.add(to);	
duplicate other name detected 

protected void executeArchetypes() throws MojoExecutionException, MojoFailureException {	
copying archetype catalog 

protected void executeXmlSchemas() throws MojoExecutionException, MojoFailureException {	
copying spring blueprint xml schemas 

protected void executeDocuments(Set<String> components, Set<String> dataformats, Set<String> languages, Set<String> others) throws MojoExecutionException, MojoFailureException {	
copying all camel documents ascii docs 

missingAdocFiles.add(dir);	}	}	}	}	}	if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "src/main/docs");	findAsciiDocFilesRecursive(target, adocFiles, new CamelAsciiDocFileFilter());	}	
found ascii document files 

File target = new File(coreDir, "src/main/docs");	findAsciiDocFilesRecursive(target, adocFiles, new CamelAsciiDocFileFilter());	}	documentsOutDir.mkdirs();	Asciidoctor asciidoctor = Asciidoctor.Factory.create();	int converted = 0;	for (File file : adocFiles) {	File to = new File(documentsOutDir, file.getName());	if (to.exists()) {	duplicateAdocFiles.add(to);	
duplicate document name detected 

duplicateAdocFiles.add(to);	}	try {	copyFile(file, to);	} catch (IOException e) {	throw new MojoFailureException("Cannot copy file from " + file + " -> " + to, e);	}	if (file.getName().endsWith(".adoc")) {	String newName = file.getName().substring(0, file.getName().length() - 5) + ".html";	File toHtml = new File(documentsOutDir, newName);	
converting ascii document to html 

output.add(line);	}	if (lines.size() != output.size()) {	FileUtils.writeLines(toHtml, output, false);	}	} catch (IOException e) {	}	}	}	if (converted > 0) {	
converted ascii documents to html 

private void printMissingDocumentsReport(Set<String> docs, Set<String> components, Set<String> dataformats, Set<String> languages, Set<String> others) {	getLog().info("");	
camel missing documents report 

} else if (component.equals("ftp") || component.equals("sftp") || component.equals("ftps")) {	component = "ftp";	}	String name = component + "-component";	if (!docs.contains(name) && (!component.equalsIgnoreCase("linkedin") && !component.equalsIgnoreCase("salesforce") && !component.equalsIgnoreCase("servicenow"))) {	missing.add(name);	}	}	if (!missing.isEmpty()) {	getLog().info("");	
tmissing adoc component documentation 

component = "ftp";	}	String name = component + "-component";	if (!docs.contains(name) && (!component.equalsIgnoreCase("linkedin") && !component.equalsIgnoreCase("salesforce") && !component.equalsIgnoreCase("servicenow"))) {	missing.add(name);	}	}	if (!missing.isEmpty()) {	getLog().info("");	for (String name : missing) {	
t t 

if (dataformat.startsWith("bindy")) {	dataformat = "bindy";	}	String name = dataformat + "-dataformat";	if (!docs.contains(name)) {	missing.add(name);	}	}	if (!missing.isEmpty()) {	getLog().info("");	
tmissing adoc dataformat documentation 

dataformat = "bindy";	}	String name = dataformat + "-dataformat";	if (!docs.contains(name)) {	missing.add(name);	}	}	if (!missing.isEmpty()) {	getLog().info("");	for (String name : missing) {	
t t 

}	missing.clear();	for (String language : languages) {	String name = language + "-language";	if (!docs.contains(name)) {	missing.add(name);	}	}	if (!missing.isEmpty()) {	getLog().info("");	
tmissing adoc language documentation 

missing.clear();	for (String language : languages) {	String name = language + "-language";	if (!docs.contains(name)) {	missing.add(name);	}	}	if (!missing.isEmpty()) {	getLog().info("");	for (String name : missing) {	
t t 

}	missing.clear();	for (String other : others) {	String name = other;	if (!docs.contains(name)) {	missing.add(name);	}	}	if (!missing.isEmpty()) {	getLog().info("");	
tmissing adoc other documentation 

missing.clear();	for (String other : others) {	String name = other;	if (!docs.contains(name)) {	missing.add(name);	}	}	if (!missing.isEmpty()) {	getLog().info("");	for (String name : missing) {	
t t 

private void printModelsReport(Set<File> json, Set<File> duplicate, Set<File> missingLabels, Map<String, Set<String>> usedLabels, Set<File> missingJavaDoc) {	getLog().info("================================================================================");	getLog().info("");	
camel model catalog report 

private void printModelsReport(Set<File> json, Set<File> duplicate, Set<File> missingLabels, Map<String, Set<String>> usedLabels, Set<File> missingJavaDoc) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	
tmodels found 

private void printModelsReport(Set<File> json, Set<File> duplicate, Set<File> missingLabels, Map<String, Set<String>> usedLabels, Set<File> missingJavaDoc) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	for (File file : json) {	
t t 

private void printModelsReport(Set<File> json, Set<File> duplicate, Set<File> missingLabels, Map<String, Set<String>> usedLabels, Set<File> missingJavaDoc) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	
tduplicate models detected 

private void printModelsReport(Set<File> json, Set<File> duplicate, Set<File> missingLabels, Map<String, Set<String>> usedLabels, Set<File> missingJavaDoc) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	
t t 

getLog().info("");	for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	}	}	if (!missingLabels.isEmpty()) {	getLog().info("");	
tmissing labels detected 

for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	}	}	if (!missingLabels.isEmpty()) {	getLog().info("");	for (File file : missingLabels) {	
t t 

for (File file : duplicate) {	}	}	if (!missingLabels.isEmpty()) {	getLog().info("");	for (File file : missingLabels) {	}	}	if (!usedLabels.isEmpty()) {	getLog().info("");	
tused labels 

}	}	if (!missingLabels.isEmpty()) {	getLog().info("");	for (File file : missingLabels) {	}	}	if (!usedLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedLabels.entrySet()) {	
t t 

}	if (!missingLabels.isEmpty()) {	getLog().info("");	for (File file : missingLabels) {	}	}	if (!usedLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedLabels.entrySet()) {	for (String name : entry.getValue()) {	
t t t 

}	if (!usedLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedLabels.entrySet()) {	for (String name : entry.getValue()) {	}	}	}	if (!missingJavaDoc.isEmpty()) {	getLog().info("");	
tmissing javadoc on models 

if (!usedLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedLabels.entrySet()) {	for (String name : entry.getValue()) {	}	}	}	if (!missingJavaDoc.isEmpty()) {	getLog().info("");	for (File file : missingJavaDoc) {	
t t 

private void printComponentsReport(Set<File> json, Set<File> duplicate, Set<File> missing, Map<String, Set<String>> usedComponentLabels, Set<String> usedOptionsLabels, Set<String> unusedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	
camel component catalog report 

private void printComponentsReport(Set<File> json, Set<File> duplicate, Set<File> missing, Map<String, Set<String>> usedComponentLabels, Set<String> usedOptionsLabels, Set<String> unusedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	
tcomponents found 

private void printComponentsReport(Set<File> json, Set<File> duplicate, Set<File> missing, Map<String, Set<String>> usedComponentLabels, Set<String> usedOptionsLabels, Set<String> unusedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	for (File file : json) {	
t t 

private void printComponentsReport(Set<File> json, Set<File> duplicate, Set<File> missing, Map<String, Set<String>> usedComponentLabels, Set<String> usedOptionsLabels, Set<String> unusedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	
tduplicate components detected 

private void printComponentsReport(Set<File> json, Set<File> duplicate, Set<File> missing, Map<String, Set<String>> usedComponentLabels, Set<String> usedOptionsLabels, Set<String> unusedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	
t t 

getLog().info("");	for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	}	}	if (!usedComponentLabels.isEmpty()) {	getLog().info("");	
tused component labels 

for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	}	}	if (!usedComponentLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedComponentLabels.entrySet()) {	
t t 

}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	}	}	if (!usedComponentLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedComponentLabels.entrySet()) {	for (String name : entry.getValue()) {	
t t t 

}	if (!usedComponentLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedComponentLabels.entrySet()) {	for (String name : entry.getValue()) {	}	}	}	if (!usedOptionsLabels.isEmpty()) {	getLog().info("");	
tused component endpoint options labels 

if (!usedComponentLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedComponentLabels.entrySet()) {	for (String name : entry.getValue()) {	}	}	}	if (!usedOptionsLabels.isEmpty()) {	getLog().info("");	for (String name : usedOptionsLabels) {	
t t t 

}	}	}	if (!usedOptionsLabels.isEmpty()) {	getLog().info("");	for (String name : usedOptionsLabels) {	}	}	if (!unusedLabels.isEmpty()) {	getLog().info("");	
tcomponent with more than unlabelled options 

}	}	if (!usedOptionsLabels.isEmpty()) {	getLog().info("");	for (String name : usedOptionsLabels) {	}	}	if (!unusedLabels.isEmpty()) {	getLog().info("");	for (String name : unusedLabels) {	
t t t 

for (String name : usedOptionsLabels) {	}	}	if (!unusedLabels.isEmpty()) {	getLog().info("");	for (String name : unusedLabels) {	}	}	if (!missing.isEmpty()) {	getLog().info("");	
tmissing components detected 

}	}	if (!unusedLabels.isEmpty()) {	getLog().info("");	for (String name : unusedLabels) {	}	}	if (!missing.isEmpty()) {	getLog().info("");	for (File name : missing) {	
t t 

for (String name : unusedLabels) {	}	}	if (!missing.isEmpty()) {	getLog().info("");	for (File name : missing) {	}	}	if (!missingFirstVersions.isEmpty()) {	getLog().info("");	
tcomponents without firstversion defined 

}	}	if (!missing.isEmpty()) {	getLog().info("");	for (File name : missing) {	}	}	if (!missingFirstVersions.isEmpty()) {	getLog().info("");	for (File name : missingFirstVersions) {	
t t 

private void printDataFormatsReport(Set<File> json, Set<File> duplicate, Map<String, Set<String>> usedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	
camel data format catalog report 

private void printDataFormatsReport(Set<File> json, Set<File> duplicate, Map<String, Set<String>> usedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	
tdataformats found 

private void printDataFormatsReport(Set<File> json, Set<File> duplicate, Map<String, Set<String>> usedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	for (File file : json) {	
t t 

private void printDataFormatsReport(Set<File> json, Set<File> duplicate, Map<String, Set<String>> usedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	
tduplicate dataformat detected 

private void printDataFormatsReport(Set<File> json, Set<File> duplicate, Map<String, Set<String>> usedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	
t t 

getLog().info("");	for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	}	}	if (!usedLabels.isEmpty()) {	getLog().info("");	
tused labels 

for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	}	}	if (!usedLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedLabels.entrySet()) {	
t t 

}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	}	}	if (!usedLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedLabels.entrySet()) {	for (String name : entry.getValue()) {	
t t t 

}	if (!usedLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedLabels.entrySet()) {	for (String name : entry.getValue()) {	}	}	}	if (!missingFirstVersions.isEmpty()) {	getLog().info("");	
tdataformats without firstversion defined 

if (!usedLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedLabels.entrySet()) {	for (String name : entry.getValue()) {	}	}	}	if (!missingFirstVersions.isEmpty()) {	getLog().info("");	for (File name : missingFirstVersions) {	
t t 

private void printLanguagesReport(Set<File> json, Set<File> duplicate, Map<String, Set<String>> usedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	
camel language catalog report 

private void printLanguagesReport(Set<File> json, Set<File> duplicate, Map<String, Set<String>> usedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	
tlanguages found 

private void printLanguagesReport(Set<File> json, Set<File> duplicate, Map<String, Set<String>> usedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	for (File file : json) {	
t t 

private void printLanguagesReport(Set<File> json, Set<File> duplicate, Map<String, Set<String>> usedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	
tduplicate language detected 

private void printLanguagesReport(Set<File> json, Set<File> duplicate, Map<String, Set<String>> usedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	
t t 

getLog().info("");	for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	}	}	if (!usedLabels.isEmpty()) {	getLog().info("");	
tused labels 

for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	}	}	if (!usedLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedLabels.entrySet()) {	
t t 

}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	}	}	if (!usedLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedLabels.entrySet()) {	for (String name : entry.getValue()) {	
t t t 

}	if (!usedLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedLabels.entrySet()) {	for (String name : entry.getValue()) {	}	}	}	if (!missingFirstVersions.isEmpty()) {	getLog().info("");	
tlanguages without firstversion defined 

if (!usedLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedLabels.entrySet()) {	for (String name : entry.getValue()) {	}	}	}	if (!missingFirstVersions.isEmpty()) {	getLog().info("");	for (File name : missingFirstVersions) {	
t t 

private void printOthersReport(Set<File> json, Set<File> duplicate, Map<String, Set<String>> usedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	
camel other catalog report 

private void printOthersReport(Set<File> json, Set<File> duplicate, Map<String, Set<String>> usedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	
tothers found 

private void printOthersReport(Set<File> json, Set<File> duplicate, Map<String, Set<String>> usedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	for (File file : json) {	
t t 

private void printOthersReport(Set<File> json, Set<File> duplicate, Map<String, Set<String>> usedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	
tduplicate other detected 

private void printOthersReport(Set<File> json, Set<File> duplicate, Map<String, Set<String>> usedLabels, Set<File> missingFirstVersions) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	
t t 

getLog().info("");	for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	}	}	if (!usedLabels.isEmpty()) {	getLog().info("");	
tused labels 

for (File file : json) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	}	}	if (!usedLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedLabels.entrySet()) {	
t t 

}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	}	}	if (!usedLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedLabels.entrySet()) {	for (String name : entry.getValue()) {	
t t t 

}	if (!usedLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedLabels.entrySet()) {	for (String name : entry.getValue()) {	}	}	}	if (!missingFirstVersions.isEmpty()) {	getLog().info("");	
tothers without firstversion defined 

if (!usedLabels.isEmpty()) {	getLog().info("");	for (Map.Entry<String, Set<String>> entry : usedLabels.entrySet()) {	for (String name : entry.getValue()) {	}	}	}	if (!missingFirstVersions.isEmpty()) {	getLog().info("");	for (File name : missingFirstVersions) {	
t t 

private void printDocumentsReport(Set<File> docs, Set<File> duplicate, Set<File> missing) {	getLog().info("================================================================================");	getLog().info("");	
camel document catalog report 

private void printDocumentsReport(Set<File> docs, Set<File> duplicate, Set<File> missing) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	
tdocuments found 

private void printDocumentsReport(Set<File> docs, Set<File> duplicate, Set<File> missing) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	for (File file : docs) {	
t t 

private void printDocumentsReport(Set<File> docs, Set<File> duplicate, Set<File> missing) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	for (File file : docs) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	
tduplicate document detected 

private void printDocumentsReport(Set<File> docs, Set<File> duplicate, Set<File> missing) {	getLog().info("================================================================================");	getLog().info("");	getLog().info("");	for (File file : docs) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	
t t 

for (File file : docs) {	}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	}	}	getLog().info("");	if (!missing.isEmpty()) {	getLog().info("");	
tmissing document detected 

}	if (!duplicate.isEmpty()) {	getLog().info("");	for (File file : duplicate) {	}	}	getLog().info("");	if (!missing.isEmpty()) {	getLog().info("");	for (File name : missing) {	
t t 

========================= camel sample_126 =========================

sizeToUse = bufferSize;	} else if (queueSize > 0) {	sizeToUse = queueSize;	} else {	sizeToUse = DEFAULT_BUFFER_SIZE;	}	sizeToUse = powerOfTwo(sizeToUse);	synchronized (this) {	DisruptorReference ref = getDisruptors().get(key);	if (ref == null) {	
creating new disruptor for key 

sizeToUse = powerOfTwo(sizeToUse);	synchronized (this) {	DisruptorReference ref = getDisruptors().get(key);	if (ref == null) {	ref = new DisruptorReference(this, uri, name, sizeToUse, producerType, waitStrategy);	getDisruptors().put(key, ref);	} else {	if (size != 0 && ref.getBufferSize() != sizeToUse) {	throw new IllegalArgumentException( "Cannot use existing queue " + key + " as the existing queue size " + ref.getBufferSize() + " does not match given queue size " + sizeToUse);	}	
reusing disruptor for key 

========================= camel sample_10751 =========================

Thread.currentThread().setContextClassLoader(ac);	}	if (endpoint.getReplyToType() != null) {	if (endpoint.getReplyTo() != null && endpoint.getReplyToType().equals(ReplyToType.Temporary.name())) {	throw new IllegalArgumentException("ReplyToType " + ReplyToType.Temporary + " is not supported when replyTo " + endpoint.getReplyTo() + " is also configured.");	}	}	if (endpoint.getReplyTo() != null) {	replyManager = createReplyManager(endpoint.getReplyTo());	if (LOG.isDebugEnabled()) {	
using jmsreplymanager to process replies from 

if (endpoint.getReplyTo() != null && endpoint.getReplyToType().equals(ReplyToType.Temporary.name())) {	throw new IllegalArgumentException("ReplyToType " + ReplyToType.Temporary + " is not supported when replyTo " + endpoint.getReplyTo() + " is also configured.");	}	}	if (endpoint.getReplyTo() != null) {	replyManager = createReplyManager(endpoint.getReplyTo());	if (LOG.isDebugEnabled()) {	}	} else {	replyManager = createReplyManager();	
using jmsreplymanager to process replies from temporary queue 

throw new RuntimeExchangeException("Failed to resolve replyTo destination", exchange);	}	JmsMessageHelper.setJMSReplyTo(answer, replyTo);	replyManager.setReplyToSelectorHeader(in, answer);	String correlationId = determineCorrelationId(answer, provisionalCorrelationId);	replyManager.registerReply(replyManager, exchange, callback, originalCorrelationId, correlationId, timeout);	if (correlationProperty != null) {	replyManager.setCorrelationProperty(correlationProperty);	}	if (LOG.isDebugEnabled()) {	
using jmsreplyto destination with request timeout ms 

}	JmsMessageHelper.setJMSReplyTo(answer, replyTo);	replyManager.setReplyToSelectorHeader(in, answer);	String correlationId = determineCorrelationId(answer, provisionalCorrelationId);	replyManager.registerReply(replyManager, exchange, callback, originalCorrelationId, correlationId, timeout);	if (correlationProperty != null) {	replyManager.setCorrelationProperty(correlationProperty);	}	if (LOG.isDebugEnabled()) {	}	
created javax jms message 

if (destination != null) {	destinationName = null;	}	final String to = destinationName != null ? destinationName : "" + destination;	MessageSentCallback messageSentCallback = getEndpoint().getConfiguration().isIncludeSentJMSMessageID() ? new InOnlyMessageSentCallback(exchange) : null;	MessageCreator messageCreator = new MessageCreator() {	public Message createMessage(Session session) throws JMSException {	Message answer = endpoint.getBinding().makeJmsMessage(exchange, in, session, null);	Object jmsReplyTo = JmsMessageHelper.getJMSReplyTo(answer);	if (endpoint.isDisableReplyTo()) {	
replyto is disabled on endpoint 

jmsReplyTo = resolveOrCreateDestination(replyTo, session);	}	Destination replyTo = null;	String replyToOverride = endpoint.getConfiguration().getReplyToOverride();	if (replyToOverride != null) {	replyTo = resolveOrCreateDestination(replyToOverride, session);	} else if (jmsReplyTo instanceof Destination) {	replyTo = (Destination)jmsReplyTo;	}	if (replyTo != null) {	
using jmsreplyto destination 

Destination replyTo = null;	String replyToOverride = endpoint.getConfiguration().getReplyToOverride();	if (replyToOverride != null) {	replyTo = resolveOrCreateDestination(replyToOverride, session);	} else if (jmsReplyTo instanceof Destination) {	replyTo = (Destination)jmsReplyTo;	}	if (replyTo != null) {	JmsMessageHelper.setJMSReplyTo(answer, replyTo);	} else {	
not using jmsreplyto 

if (replyToOverride != null) {	replyTo = resolveOrCreateDestination(replyToOverride, session);	} else if (jmsReplyTo instanceof Destination) {	replyTo = (Destination)jmsReplyTo;	}	if (replyTo != null) {	JmsMessageHelper.setJMSReplyTo(answer, replyTo);	} else {	JmsMessageHelper.setJMSReplyTo(answer, null);	}	
created javax jms message 

protected void doSend(boolean inOut, String destinationName, Destination destination, MessageCreator messageCreator, MessageSentCallback callback) {	CamelJmsTemplate template = (CamelJmsTemplate) (inOut ? getInOutTemplate() : getInOnlyTemplate());	if (LOG.isTraceEnabled()) {	
using jms template inOut inOnly 

protected Destination resolveOrCreateDestination(String destinationName, Session session) throws JMSException {	Destination dest = null;	boolean isPubSub = isTopicPrefix(destinationName) || (!isQueuePrefix(destinationName) && endpoint.isPubSubDomain());	if (endpoint.getDestinationResolver() != null) {	dest = endpoint.getDestinationResolver().resolveDestinationName(session, destinationName, isPubSub);	if (LOG.isDebugEnabled()) {	
resolved jmsreplyto destination using destinationresolver as pubsubdomain 

Destination dest = null;	boolean isPubSub = isTopicPrefix(destinationName) || (!isQueuePrefix(destinationName) && endpoint.isPubSubDomain());	if (endpoint.getDestinationResolver() != null) {	dest = endpoint.getDestinationResolver().resolveDestinationName(session, destinationName, isPubSub);	if (LOG.isDebugEnabled()) {	}	}	if (dest == null) {	String before = destinationName;	destinationName = normalizeDestinationName(destinationName);	
normalized jmsreplyto destination name 

boolean isPubSub = isTopicPrefix(destinationName) || (!isQueuePrefix(destinationName) && endpoint.isPubSubDomain());	if (endpoint.getDestinationResolver() != null) {	dest = endpoint.getDestinationResolver().resolveDestinationName(session, destinationName, isPubSub);	if (LOG.isDebugEnabled()) {	}	}	if (dest == null) {	String before = destinationName;	destinationName = normalizeDestinationName(destinationName);	if (isPubSub) {	
creating jmsreplyto topic 

dest = endpoint.getDestinationResolver().resolveDestinationName(session, destinationName, isPubSub);	if (LOG.isDebugEnabled()) {	}	}	if (dest == null) {	String before = destinationName;	destinationName = normalizeDestinationName(destinationName);	if (isPubSub) {	dest = session.createTopic(destinationName);	} else {	
creating jmsreplyto queue 

protected void setMessageId(Exchange exchange) {	if (exchange.hasOut()) {	JmsMessage out = exchange.getOut(JmsMessage.class);	try {	if (out != null && out.getJmsMessage() != null) {	out.setMessageId(out.getJmsMessage().getJMSMessageID());	}	} catch (JMSException e) {	
unable to retrieve jmsmessageid from outgoing jms message and set it into camel s messageid 

protected void testConnectionOnStartup() throws FailedToCreateProducerException {	try {	CamelJmsTemplate template = (CamelJmsTemplate) getInOnlyTemplate();	if (log.isDebugEnabled()) {	
testing jms connection on startup for destination 

protected void testConnectionOnStartup() throws FailedToCreateProducerException {	try {	CamelJmsTemplate template = (CamelJmsTemplate) getInOnlyTemplate();	if (log.isDebugEnabled()) {	}	Connection conn = template.getConnectionFactory().createConnection();	JmsUtils.closeConnection(conn);	
successfully tested jms connection on startup for destination 

========================= camel sample_7195 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	onException(Exception.class).handled(true) .redeliveryDelay(0) .maximumRedeliveries(4).logStackTrace(false) .setBody().constant("Error");	from("direct:start") .to("mock:foo") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	
invoking me 

========================= camel sample_2728 =========================

public void testList() throws Exception {	final com.google.api.services.drive.model.App result = requestBody("direct: assertNotNull("list result", result);	
list 

========================= camel sample_15416 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<JXPathLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.jxpath.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.jxpath.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_599 =========================

public void load(TypeConverterRegistry registry) throws TypeConverterLoaderException {	String[] packageNames;	
searching for services 

String[] packageNames;	try {	packageNames = findPackageNames();	if (packageNames == null || packageNames.length == 0) {	throw new TypeConverterLoaderException("Cannot find package names to be used for classpath scanning for annotated type converters.");	}	} catch (Exception e) {	throw new TypeConverterLoaderException("Cannot find package names to be used for classpath scanning for annotated type converters.", e);	}	if (packageNames.length == 1 && "org.apache.camel.core".equals(packageNames[0])) {	
no additional package names found in classpath for annotated type converters 

} catch (Exception e) {	throw new TypeConverterLoaderException("Cannot find package names to be used for classpath scanning for annotated type converters.", e);	}	if (packageNames.length == 1 && "org.apache.camel.core".equals(packageNames[0])) {	return;	}	packageNames = filterUnwantedPackage("org.apache.camel.core", packageNames);	Set<Class<?>> classes = new HashSet<Class<?>>();	packageNames = filterPackageNamesOnly(resolver, packageNames, classes);	if (!classes.isEmpty()) {	
loaded converter classes 

}	if (packageNames.length == 1 && "org.apache.camel.core".equals(packageNames[0])) {	return;	}	packageNames = filterUnwantedPackage("org.apache.camel.core", packageNames);	Set<Class<?>> classes = new HashSet<Class<?>>();	packageNames = filterPackageNamesOnly(resolver, packageNames, classes);	if (!classes.isEmpty()) {	}	if (packageNames != null && packageNames.length > 0) {	
found converter packages to scan 

packageNames = filterUnwantedPackage("org.apache.camel.core", packageNames);	Set<Class<?>> classes = new HashSet<Class<?>>();	packageNames = filterPackageNamesOnly(resolver, packageNames, classes);	if (!classes.isEmpty()) {	}	if (packageNames != null && packageNames.length > 0) {	Set<Class<?>> scannedClasses = resolver.findAnnotated(Converter.class, packageNames);	if (scannedClasses.isEmpty()) {	throw new TypeConverterLoaderException("Cannot find any type converter classes from the following packages: " + Arrays.asList(packageNames));	}	
found packages with converter classes to load 

}	if (packageNames != null && packageNames.length > 0) {	Set<Class<?>> scannedClasses = resolver.findAnnotated(Converter.class, packageNames);	if (scannedClasses.isEmpty()) {	throw new TypeConverterLoaderException("Cannot find any type converter classes from the following packages: " + Arrays.asList(packageNames));	}	classes.addAll(scannedClasses);	}	for (Class<?> type : classes) {	if (LOG.isTraceEnabled()) {	
loading converter class 

if (resolver.getClassLoaders().isEmpty()) {	return packageNames;	}	List<String> packages = new ArrayList<String>();	for (String name : packageNames) {	if (StringHelper.isClassName(name)) {	Class<?> clazz = null;	for (ClassLoader loader : resolver.getClassLoaders()) {	try {	clazz = ObjectHelper.loadClass(name, loader);	
loaded as class 

protected void findPackages(Set<String> packages, ClassLoader classLoader) throws IOException {	Enumeration<URL> resources = classLoader.getResources(META_INF_SERVICES);	while (resources.hasMoreElements()) {	URL url = resources.nextElement();	String path = url.getPath();	if (!visitedURIs.contains(path)) {	visitedURIs.add(path);	
loading file to retrieve list of packages from url 

loadConverterMethods(registry, superclass);	}	} catch (NoClassDefFoundError e) {	boolean ignore = false;	if (ObjectHelper.hasAnnotation(type, Converter.class, true)) {	if (type.getAnnotation(Converter.class) != null) {	ignore = type.getAnnotation(Converter.class).ignoreOnLoadError();	}	}	if (ignore) {	
ignoring converter type as a dependent class could not be found 

}	} catch (NoClassDefFoundError e) {	boolean ignore = false;	if (ObjectHelper.hasAnnotation(type, Converter.class, true)) {	if (type.getAnnotation(Converter.class) != null) {	ignore = type.getAnnotation(Converter.class).ignoreOnLoadError();	}	}	if (ignore) {	} else {	
ignoring converter type as a dependent class could not be found 

private CachingInjector<?> handleHasConverterAnnotation(TypeConverterRegistry registry, Class<?> type, CachingInjector<?> injector, Method method, boolean allowNull) {	if (isValidConverterMethod(method)) {	int modifiers = method.getModifiers();	if (isAbstract(modifiers) || !isPublic(modifiers)) {	
ignoring bad converter on type method as a converter method is not a public and concrete method 

private CachingInjector<?> handleHasConverterAnnotation(TypeConverterRegistry registry, Class<?> type, CachingInjector<?> injector, Method method, boolean allowNull) {	if (isValidConverterMethod(method)) {	int modifiers = method.getModifiers();	if (isAbstract(modifiers) || !isPublic(modifiers)) {	} else {	Class<?> toType = method.getReturnType();	if (toType.equals(Void.class)) {	
ignoring bad converter on type method as a converter method returns a void method 

registerTypeConverter(registry, method, toType, fromType, new StaticMethodTypeConverter(method, allowNull));	} else {	if (injector == null) {	injector = new CachingInjector<Object>(registry, CastUtils.cast(type, Object.class));	}	registerTypeConverter(registry, method, toType, fromType, new InstanceMethodTypeConverter(injector, method, registry, allowNull));	}	}	}	} else {	
ignoring bad converter on type method as a converter method should have one parameter 

private CachingInjector<?> handleHasFallbackConverterAnnotation(TypeConverterRegistry registry, Class<?> type, CachingInjector<?> injector, Method method, boolean allowNull) {	if (isValidFallbackConverterMethod(method)) {	int modifiers = method.getModifiers();	if (isAbstract(modifiers) || !isPublic(modifiers)) {	
ignoring bad fallback converter on type method as a fallback converter method is not a public and concrete method 

private CachingInjector<?> handleHasFallbackConverterAnnotation(TypeConverterRegistry registry, Class<?> type, CachingInjector<?> injector, Method method, boolean allowNull) {	if (isValidFallbackConverterMethod(method)) {	int modifiers = method.getModifiers();	if (isAbstract(modifiers) || !isPublic(modifiers)) {	} else {	Class<?> toType = method.getReturnType();	if (toType.equals(Void.class)) {	
ignoring bad fallback converter on type method as a fallback converter method returns a void method 

registerFallbackTypeConverter(registry, new StaticMethodFallbackTypeConverter(method, registry, allowNull), method);	} else {	if (injector == null) {	injector = new CachingInjector<Object>(registry, CastUtils.cast(type, Object.class));	}	registerFallbackTypeConverter(registry, new InstanceMethodFallbackTypeConverter(injector, method, registry, allowNull), method);	}	}	}	} else {	
ignoring bad fallback converter on type method as a fallback converter method should have one parameter 

========================= camel sample_3990 =========================

private void writeFiles() throws Exception {	
writing files 

private void writeFiles() throws Exception {	FileOutputStream fos = new FileOutputStream("target/marker/in/file1.dat");	FileOutputStream fos2 = new FileOutputStream("target/marker/in/file2.dat");	for (int i = 0; i < 20; i++) {	fos.write(("Line " + i + LS).getBytes());	fos2.write(("Line " + i + LS).getBytes());	
writing line 

========================= camel sample_3139 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<YammerComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.yammer.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.yammer.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1104 =========================

} else {	this.nullableArguments = Collections.emptyList();	}	final Map<Pattern, String> aliasPatterns = new HashMap<Pattern, String>();	for (Map.Entry<String, String> alias : aliases.entrySet()) {	if (alias.getKey() == null || alias.getValue() == null) {	throw new IllegalArgumentException("Alias pattern and replacement cannot be null");	}	aliasPatterns.put(Pattern.compile(alias.getKey()), alias.getValue());	}	
processing 

if (!ambiguousMethods.isEmpty()) {	throw new IllegalArgumentException( String.format("Ambiguous alias %s for methods %s", entry.getKey(), ambiguousMethods));	}	}	}	}	this.methodMap = Collections.unmodifiableMap(tmpMethodMap);	this.argumentsMap = Collections.unmodifiableMap(tmpArgumentsMap);	this.validArguments = Collections.unmodifiableMap(tmpValidArguments);	this.aliasesMap = Collections.unmodifiableMap(tmpAliasesMap);	
found unique method names in methods 

List<T> methods = methodMap.get(name);	if (methods == null) {	if (aliasesMap.containsKey(name)) {	methods = new ArrayList<T>();	for (String method : aliasesMap.get(name)) {	methods.addAll(methodMap.get(method));	}	}	}	if (methods == null) {	
no matching method for method 

for (String method : aliasesMap.get(name)) {	methods.addAll(methodMap.get(method));	}	}	}	if (methods == null) {	return Collections.emptyList();	}	int nArgs = argNames != null ? argNames.size() : 0;	if (nArgs == 0) {	
found methods for method 

}	if (methods == null) {	return Collections.emptyList();	}	int nArgs = argNames != null ? argNames.size() : 0;	if (nArgs == 0) {	return Collections.unmodifiableList(methods);	} else {	final List<ApiMethod> filteredSet = filterMethods(methods, MatchType.SUBSET, argNames);	if (LOG.isDebugEnabled()) {	
found filtered methods for 

public static Object invokeMethod(Object proxy, ApiMethod method, Map<String, Object> properties) throws RuntimeCamelException {	if (LOG.isDebugEnabled()) {	
invoking with arguments 

========================= camel sample_4306 =========================

public void testIrcMessages() throws Exception {	resultEndpoint = context.getEndpoint("mock:result", MockEndpoint.class);	resultEndpoint.expectedBodiesReceived(body1, body2, body3, body3);	resultEndpoint.assertIsSatisfied();	List<Exchange> list = resultEndpoint.getReceivedExchanges();	for (Exchange exchange : list) {	
received exchange headers 

========================= camel sample_12150 =========================

protected void onFirstMessage(ProcessContext context) {	if (!isStarted()) {	setTimeStarted(currentTime());	context.onStarted(this);	
activity first message 

protected void onExpectedMessage(ProcessContext context) {	if (!isCompleted()) {	setTimeCompleted(currentTime());	setTimeOverdue(null);	context.onCompleted(this);	
activity complete 

========================= camel sample_12500 =========================

public void process(Exchange exchange) {	exchange.getIn().setBody(new SendEmail("foo@bar.com"));	}	});	results = entityManager.createQuery(queryText).getResultList();	assertEquals("Should have results: " + results, 1, results.size());	SendEmail mail = (SendEmail) results.get(0);	assertEquals("address property", "foo@bar.com", mail.getAddress());	consumer = endpoint.createConsumer(new Processor() {	public void process(Exchange e) {	
received exchange 

========================= camel sample_14084 =========================

public void onInit(Route route) {	
oninit 

public void onRemove(Route route) {	
onremove 

public void onStart(Route route) {	
onstart 

public void onStop(Route route) {	
onstop 

public void onSuspend(Route route) {	
onsuspend 

public void onResume(Route route) {	
onresume 

public void onExchangeBegin(Route route, Exchange exchange) {	
onexchange start 

public void onExchangeDone(Route route, Exchange exchange) {	
onexchange end 

protected void doStart() throws Exception {	
doStart 

protected void doStop() throws Exception {	
doStop 

private void startRouteImpl(Route route) throws Exception {	ServiceStatus routeStatus = route.getRouteContext().getCamelContext().getRouteStatus(route.getId());	if (routeStatus == ServiceStatus.Stopped) {	
starting 

private void startRouteImpl(Route route) throws Exception {	ServiceStatus routeStatus = route.getRouteContext().getCamelContext().getRouteStatus(route.getId());	if (routeStatus == ServiceStatus.Stopped) {	startRoute(route);	} else if (routeStatus == ServiceStatus.Suspended) {	
resuming 

private void startRouteImpl(Route route) throws Exception {	ServiceStatus routeStatus = route.getRouteContext().getCamelContext().getRouteStatus(route.getId());	if (routeStatus == ServiceStatus.Stopped) {	startRoute(route);	} else if (routeStatus == ServiceStatus.Suspended) {	startConsumer(route.getConsumer());	} else {	
nothing to do is 

private void stopRouteImpl(Route route) throws Exception {	ServiceStatus routeStatus = route.getRouteContext().getCamelContext().getRouteStatus(route.getId());	if (routeStatus == ServiceStatus.Started) {	
stopping 

private void stopRouteImpl(Route route) throws Exception {	ServiceStatus routeStatus = route.getRouteContext().getCamelContext().getRouteStatus(route.getId());	if (routeStatus == ServiceStatus.Started) {	stopRoute(route);	} else {	
nothing to do is 

public void run() {	try {	if (dnsActivation.isActive()) {	startRoutes();	} else {	stopRoutes();	}	} catch (Exception e) {	
dnsactivation timertask failed 

========================= camel sample_6507 =========================

protected void doStart() throws Exception {	ObjectHelper.notNull(camelContext, "camelContext");	ObjectHelper.notNull(loadBalancerClient, "loadBalancerClient");	
servicecall is using cloud load balancer of type 

========================= camel sample_12916 =========================

String state = (String) mbeanServer.getAttribute(on, "State");	assertEquals("Should be started", ServiceStatus.Started.name(), state);	await().atMost(1, TimeUnit.SECONDS).untilAsserted(() -> {	Long completed = (Long) mbeanServer.getAttribute(on, "ExchangesCompleted");	assertEquals(1, completed.longValue());	});	Set<ObjectName> set = mbeanServer.queryNames(new ObjectName("*:type=consumers,*"), null);	assertEquals("Should be 1 consumer", 1, set.size());	set = mbeanServer.queryNames(new ObjectName("*:type=processors,*"), null);	assertEquals("Should be 2 processors", 2, set.size());	
invoking stop 

assertEquals("Should be started", ServiceStatus.Started.name(), state);	await().atMost(1, TimeUnit.SECONDS).untilAsserted(() -> {	Long completed = (Long) mbeanServer.getAttribute(on, "ExchangesCompleted");	assertEquals(1, completed.longValue());	});	Set<ObjectName> set = mbeanServer.queryNames(new ObjectName("*:type=consumers,*"), null);	assertEquals("Should be 1 consumer", 1, set.size());	set = mbeanServer.queryNames(new ObjectName("*:type=processors,*"), null);	assertEquals("Should be 2 processors", 2, set.size());	mbeanServer.invoke(on, "stop", null, null);	
invoking stop done 

set = mbeanServer.queryNames(new ObjectName("*:type=consumers,*"), null);	assertEquals("Should be 0 consumer", 0, set.size());	set = mbeanServer.queryNames(new ObjectName("*:type=processors,*"), null);	assertEquals("Should be 0 processor", 0, set.size());	mock.reset();	mock.expectedBodiesReceived("Bye World");	mock.setResultWaitTime(2000);	template.sendBodyAndHeader("file: mock.assertIsNotSatisfied();	mock.reset();	mock.expectedBodiesReceived("Bye World");	
invoking start 

assertEquals("Should be 0 consumer", 0, set.size());	set = mbeanServer.queryNames(new ObjectName("*:type=processors,*"), null);	assertEquals("Should be 0 processor", 0, set.size());	mock.reset();	mock.expectedBodiesReceived("Bye World");	mock.setResultWaitTime(2000);	template.sendBodyAndHeader("file: mock.assertIsNotSatisfied();	mock.reset();	mock.expectedBodiesReceived("Bye World");	mbeanServer.invoke(on, "start", null, null);	
invoking start done 

========================= camel sample_2817 =========================

private QuartzEndpoint lookupQuartzEndpoint(CamelContext camelContext, String endpointUri, Trigger trigger) throws JobExecutionException {	String targetTriggerName = trigger.getName();	String targetTriggerGroup = trigger.getGroup();	
looking up existing quartzendpoint with trigger 

try {	for (Route route : camelContext.getRoutes()) {	Endpoint endpoint = route.getEndpoint();	if (endpoint instanceof DelegateEndpoint) {	endpoint = ((DelegateEndpoint)endpoint).getEndpoint();	}	if (endpoint instanceof QuartzEndpoint) {	QuartzEndpoint quartzEndpoint = (QuartzEndpoint) endpoint;	String triggerName = quartzEndpoint.getTrigger().getName();	String triggerGroup = quartzEndpoint.getTrigger().getGroup();	
checking route trigger 

return (QuartzEndpoint) endpoint;	}	}	}	} catch (Exception e) {	throw new JobExecutionException("Error lookup up existing QuartzEndpoint with trigger: " + trigger, e);	}	if (camelContext.hasEndpoint(endpointUri) != null) {	return camelContext.getEndpoint(endpointUri, QuartzEndpoint.class);	} else {	
cannot find existing quartzendpoint with uri creating new endpoint instance 

========================= camel sample_17217 =========================

public void testSenderXmlData() throws Exception {	MockEndpoint result = getMockEndpoint("mock:result");	result.reset();	result.expectedMessageCount(4);	template.sendBody("direct:endpoint", xmlData);	assertMockEndpointsSatisfied();	int i = 0;	for (Exchange exchange : result.getExchanges()) {	Element element = (Element) exchange.getIn().getBody();	String message = CxfUtils.elementToString(element);	
the splited message is 

========================= camel sample_7746 =========================

app.start();	AbstractXmlApplicationContext app2 = new ClassPathXmlApplicationContext("org/apache/camel/routepolicy/quartz/SpringQuartzClusteredAppTwo.xml");	app2.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMessageCount(1);	mock.expectedBodiesReceived("clustering PINGS!");	Thread.sleep(5000);	app.getBean("template", ProducerTemplate.class).sendBody("direct:start", "clustering");	mock.assertIsSatisfied();	
the first app is going to crash now 

app2.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMessageCount(1);	mock.expectedBodiesReceived("clustering PINGS!");	Thread.sleep(5000);	app.getBean("template", ProducerTemplate.class).sendBody("direct:start", "clustering");	mock.assertIsSatisfied();	app.getBean(Scheduler.class).shutdown();	IOHelper.close(app);	
crashed 

app2.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMessageCount(1);	mock.expectedBodiesReceived("clustering PINGS!");	Thread.sleep(5000);	app.getBean("template", ProducerTemplate.class).sendBody("direct:start", "clustering");	mock.assertIsSatisfied();	app.getBean(Scheduler.class).shutdown();	IOHelper.close(app);	
crashed 

app2.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMessageCount(1);	mock.expectedBodiesReceived("clustering PINGS!");	Thread.sleep(5000);	app.getBean("template", ProducerTemplate.class).sendBody("direct:start", "clustering");	mock.assertIsSatisfied();	app.getBean(Scheduler.class).shutdown();	IOHelper.close(app);	
crashed 

========================= camel sample_17169 =========================

}	});	context.start();	deleteDirectory(FTP_ROOT_DIR);	createDirectory(FTP_ROOT_DIR + "/slowfile");	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(1);	template.sendBody("seda:start", "Create the slow file");	mock.assertIsSatisfied();	String body = mock.getReceivedExchanges().get(0).getIn().getBody(String.class);	
body is 

public void process(Exchange exchange) throws Exception {	
creating a slow file 

public void process(Exchange exchange) throws Exception {	File file = new File(FTP_ROOT_DIR + "/slowfile/hello.txt");	FileOutputStream fos = new FileOutputStream(file);	FileLock lock = fos.getChannel().lock();	fos.write("Hello World".getBytes());	for (int i = 0; i < 3; i++) {	Thread.sleep(1000);	fos.write(("Line #" + i).getBytes());	
appending to slowfile 

FileOutputStream fos = new FileOutputStream(file);	FileLock lock = fos.getChannel().lock();	fos.write("Hello World".getBytes());	for (int i = 0; i < 3; i++) {	Thread.sleep(1000);	fos.write(("Line #" + i).getBytes());	}	fos.write("Bye World".getBytes());	lock.release();	fos.close();	
done creating slowfile 

========================= camel sample_15154 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<FreemarkerComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.freemarker.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.freemarker.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_521 =========================

public void populateResponse(Exchange exchange, JettyContentExchange httpExchange) throws Exception {	int responseCode = httpExchange.getResponseStatus();	
http responsecode 

========================= camel sample_17493 =========================

config.timeBetweenEvictionRunsMillis = 30 * 1000L;	config.minEvictableIdleTimeMillis = configuration.getProducerPoolMinEvictableIdle();	config.whenExhaustedAction = GenericObjectPool.WHEN_EXHAUSTED_FAIL;	pool = new GenericObjectPool<Channel>(new NettyProducerPoolableObjectFactory(), config);	if (LOG.isDebugEnabled()) {	LOG.debug("Created NettyProducer pool[maxActive={}, minIdle={}, maxIdle={}, minEvictableIdleTimeMillis={}] -> {}", new Object[]{config.maxActive, config.minIdle, config.maxIdle, config.minEvictableIdleTimeMillis, pool});	}	} else {	pool = new SharedSingletonObjectPool<Channel>(new NettyProducerPoolableObjectFactory());	if (LOG.isDebugEnabled()) {	
created nettyproducer shared singleton pool 

protected void doStop() throws Exception {	
stopping producer at address 

protected void doStop() throws Exception {	
closing channels 

if (getConfiguration().getCharsetName() != null) {	exchange.setProperty(Exchange.CHARSET_NAME, IOHelper.normalizeCharset(getConfiguration().getCharsetName()));	}	if (LOG.isTraceEnabled()) {	LOG.trace("Pool[active={}, idle={}]", pool.getNumActive(), pool.getNumIdle());	}	Channel existing;	try {	existing = pool.borrowObject();	if (existing != null) {	
got channel from pool 

}	final Channel channel = existing;	final AsyncCallback producerCallback = new NettyProducerCallback(channel, callback);	channel.setAttachment(new NettyCamelState(producerCallback, exchange));	InetSocketAddress remoteAddress = null;	if (!isTcp()) {	remoteAddress = new InetSocketAddress(configuration.getHost(), configuration.getPort());	}	NettyHelper.writeBodyAsync(LOG, channel, remoteAddress, body, exchange, new ChannelFutureListener() {	public void operationComplete(ChannelFuture channelFuture) throws Exception {	
operation complete 

close = exchange.getOut().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);	} else {	close = exchange.getIn().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);	}	boolean disconnect = getConfiguration().isDisconnect();	if (close != null) {	disconnect = close;	}	if (disconnect) {	if (LOG.isTraceEnabled()) {	
closing channel when complete at address 

clientBootstrap.setOption("reuseAddress", configuration.isReuseAddress());	clientBootstrap.setOption("connectTimeoutMillis", configuration.getConnectTimeout());	if (configuration.getOptions() != null) {	for (Map.Entry<String, Object> entry : configuration.getOptions().entrySet()) {	clientBootstrap.setOption(entry.getKey(), entry.getValue());	}	}	clientBootstrap.setPipelineFactory(pipelineFactory);	answer = clientBootstrap.connect(new InetSocketAddress(configuration.getHost(), configuration.getPort()));	if (LOG.isDebugEnabled()) {	
created new tcp client bootstrap connecting to with options 

}	connectionlessClientBootstrap.setPipelineFactory(pipelineFactory);	if (!configuration.isUdpConnectionlessSending()) {	answer = connectionlessClientBootstrap.connect(new InetSocketAddress(configuration.getHost(), configuration.getPort()));	} else {	Channel channel = connectionlessClientBootstrap.bind(new InetSocketAddress(0));	allChannels.add(channel);	answer = new SucceededChannelFuture(channel);	}	if (LOG.isDebugEnabled()) {	
created new udp client bootstrap connecting to with options 

protected Channel openChannel(ChannelFuture channelFuture) throws Exception {	if (LOG.isTraceEnabled()) {	
waiting for operation to complete for millis 

if (!channelFuture.isDone() || !channelFuture.isSuccess()) {	ConnectException cause = new ConnectException("Cannot connect to " + configuration.getAddress());	if (channelFuture.getCause() != null) {	cause.initCause(channelFuture.getCause());	}	throw cause;	}	Channel answer = channelFuture.getChannel();	allChannels.add(answer);	if (LOG.isDebugEnabled()) {	
creating connector to address 

public void done(boolean doneSync) {	try {	if (channel.isConnected()) {	
putting channel back to pool 

public void done(boolean doneSync) {	try {	if (channel.isConnected()) {	pool.returnObject(channel);	}	} catch (Exception e) {	
error returning channel to pool this exception will be ignored 

public Channel makeObject() throws Exception {	ChannelFuture channelFuture = openConnection();	Channel answer = openChannel(channelFuture);	
created channel 

public void destroyObject(Channel channel) throws Exception {	
destroying channel 

public boolean validateObject(Channel channel) {	boolean answer = false;	if (configuration.isUdpConnectionlessSending()) {	answer = channel.isOpen();	} else {	answer = channel.isConnected();	}	
validating channel 

public void activateObject(Channel channel) throws Exception {	
activateobject channel 

public void passivateObject(Channel channel) throws Exception {	
passivateobject channel 

========================= camel sample_6679 =========================

public int read(@Body String body) {	
read method called with on 

========================= camel sample_3181 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<CometdComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.cometd.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.cometd.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_937 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<MasterComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.master.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.master.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1153 =========================

public void process(Exchange exchange) throws Exception {	Message in = exchange.getIn();	RepositoryCommit commit = (RepositoryCommit) in.getBody();	User author = commit.getAuthor();	if (log.isDebugEnabled()) {	
got commit with author sha 

========================= camel sample_14250 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<Jt400Component> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jt400.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jt400.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_464 =========================

public void testNettyRouteServerNotStarted() throws Exception {	try {	MockEndpoint receive = context.getEndpoint("mock:receive", MockEndpoint.class);	receive.expectedBodiesReceived("Bye Willem");	
starting camel route while netty server is not ready 

public void testNettyRouteServerNotStarted() throws Exception {	try {	MockEndpoint receive = context.getEndpoint("mock:receive", MockEndpoint.class);	receive.expectedBodiesReceived("Bye Willem");	context.startRoute("client");	Thread.sleep(500);	
starting netty server 

public void testNettyRouteServerNotStarted() throws Exception {	try {	MockEndpoint receive = context.getEndpoint("mock:receive", MockEndpoint.class);	receive.expectedBodiesReceived("Bye Willem");	context.startRoute("client");	Thread.sleep(500);	startNettyServer();	assertMockEndpointsSatisfied();	
routing done 

public void testNettyRouteServerNotStarted() throws Exception {	try {	MockEndpoint receive = context.getEndpoint("mock:receive", MockEndpoint.class);	receive.expectedBodiesReceived("Bye Willem");	context.startRoute("client");	Thread.sleep(500);	startNettyServer();	assertMockEndpointsSatisfied();	Thread.sleep(500);	} finally {	
shutting down netty server 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("netty4:tcp: .process(new Processor() {	public void process(final Exchange exchange) {	
processing exchange in netty server 

========================= camel sample_10213 =========================

indexObject = service.getIndexes().get(index);	if (indexObject == null) {	throw new RuntimeCamelException(String.format("cannot find index [%s]", index));	}	socket = indexObject.attach(args);	} else {	receiver = service.getReceiver();	socket = receiver.attach(args);	}	socket.setTcpNoDelay(true);	
created a socket on s 

========================= camel sample_14483 =========================

protected void onBeforeProcess(Exchange exchange, Processor processor, ProcessorDefinition<?> definition, Breakpoint breakpoint) {	try {	breakpoint.beforeProcess(exchange, processor, definition);	} catch (Throwable e) {	
exception occurred in breakpoint this exception will be ignored 

protected void onAfterProcess(Exchange exchange, Processor processor, ProcessorDefinition<?> definition, long timeTaken, Breakpoint breakpoint) {	try {	breakpoint.afterProcess(exchange, processor, definition, timeTaken);	} catch (Throwable e) {	
exception occurred in breakpoint this exception will be ignored 

LinkedList<MessageHistory> list = exchange.getProperty(Exchange.MESSAGE_HISTORY, LinkedList.class);	if (list != null && !list.isEmpty())  {	NamedNode node = list.getLast().getNode();	if (node instanceof ProcessorDefinition) {	definition = (ProcessorDefinition<?>) node;	}	}	try {	breakpoint.onEvent(exchange, event, definition);	} catch (Throwable e) {	
exception occurred in breakpoint this exception will be ignored 

========================= camel sample_4078 =========================

mock.expectedBodiesReceived(expected);	ProducerTemplate triggerTemplate = context.createProducerTemplate();	triggerTemplate.sendBody("vm:trigger", "");	assertMockEndpointsSatisfied();	long startFileDeletionCheckTime = System.currentTimeMillis();	boolean fileExists = true;	while (System.currentTimeMillis() - startFileDeletionCheckTime < 3000) {	File file = new File(FTP_ROOT_DIR + "/poll/hello.txt");	fileExists = file.exists();	if (fileExists) {	
will check that file has been deleted again in 

========================= camel sample_15292 =========================

private void doQueryForObject(Exchange exchange) throws Exception {	SqlMapClient client = endpoint.getSqlMapClient();	Object result;	Object in = exchange.getIn().getBody();	if (in != null) {	
queryforobject using statement 

private void doQueryForObject(Exchange exchange) throws Exception {	SqlMapClient client = endpoint.getSqlMapClient();	Object result;	Object in = exchange.getIn().getBody();	if (in != null) {	result = client.queryForObject(statement, in);	} else {	
queryforobject using statement 

private void doQueryForList(Exchange exchange) throws Exception {	SqlMapClient client = endpoint.getSqlMapClient();	Object result;	Object in = exchange.getIn().getBody();	if (in != null) {	
queryforlist using statement 

private void doQueryForList(Exchange exchange) throws Exception {	SqlMapClient client = endpoint.getSqlMapClient();	Object result;	Object in = exchange.getIn().getBody();	if (in != null) {	result = client.queryForList(statement, in);	} else {	
queryforlist using statement 

private void doInsert(Exchange exchange) throws Exception {	SqlMapClient client = endpoint.getSqlMapClient();	Object result;	Object in = exchange.getIn().getBody();	if (in != null) {	Iterator<?> iter = ObjectHelper.createIterator(in);	while (iter.hasNext()) {	Object value = iter.next();	
inserting using statement 

Object result;	Object in = exchange.getIn().getBody();	if (in != null) {	Iterator<?> iter = ObjectHelper.createIterator(in);	while (iter.hasNext()) {	Object value = iter.next();	result = client.insert(statement, value);	doProcessResult(exchange, result);	}	} else {	
inserting using statement 

private void doUpdate(Exchange exchange) throws Exception {	SqlMapClient client = endpoint.getSqlMapClient();	Object result;	Object in = exchange.getIn().getBody();	if (in != null) {	Iterator<?> iter = ObjectHelper.createIterator(in);	while (iter.hasNext()) {	Object value = iter.next();	
updating using statement 

Object result;	Object in = exchange.getIn().getBody();	if (in != null) {	Iterator<?> iter = ObjectHelper.createIterator(in);	while (iter.hasNext()) {	Object value = iter.next();	result = client.update(statement, value);	doProcessResult(exchange, result);	}	} else {	
updating using statement 

private void doDelete(Exchange exchange) throws Exception {	SqlMapClient client = endpoint.getSqlMapClient();	Object result;	Object in = exchange.getIn().getBody();	if (in != null) {	Iterator<?> iter = ObjectHelper.createIterator(in);	while (iter.hasNext()) {	Object value = iter.next();	
deleting using statement 

Object result;	Object in = exchange.getIn().getBody();	if (in != null) {	Iterator<?> iter = ObjectHelper.createIterator(in);	while (iter.hasNext()) {	Object value = iter.next();	result = client.delete(statement, value);	doProcessResult(exchange, result);	}	} else {	
deleting using statement 

========================= camel sample_17305 =========================

public SmppProducer(SmppEndpoint endpoint, SmppConfiguration config) {	super(endpoint);	this.configuration = config;	this.internalSessionStateListener = new SessionStateListener() {	public void onStateChange(SessionState newState, SessionState oldState, Session source) {	if (configuration.getSessionStateListener() != null) {	configuration.getSessionStateListener().onStateChange(newState, oldState, source);	}	if (newState.equals(SessionState.CLOSED)) {	
lost connection to trying to reconnect 

private SMPPSession createSession() throws IOException {	
connecting to 

private SMPPSession createSession() throws IOException {	SMPPSession session = createSMPPSession();	session.setEnquireLinkTimer(this.configuration.getEnquireLinkTimer());	session.setTransactionTimer(this.configuration.getTransactionTimer());	session.addSessionStateListener(internalSessionStateListener);	session.connectAndBind( this.configuration.getHost(), this.configuration.getPort(), new BindParameter( BindType.BIND_TX, this.configuration.getSystemId(), this.configuration.getPassword(), this.configuration.getSystemType(), TypeOfNumber.valueOf(configuration.getTypeOfNumber()), NumberingPlanIndicator.valueOf(configuration.getNumberingPlanIndicator()), ""));	
connected to 

public void process(Exchange exchange) throws Exception {	if (session == null) {	if (this.configuration.isLazySessionCreation()) {	if (connectLock.tryLock()) {	try {	if (session == null) {	Message in = exchange.getIn();	String systemId = in.getHeader(SmppConstants.SYSTEM_ID, String.class);	String password = in.getHeader(SmppConstants.PASSWORD, String.class);	if (systemId != null && password != null) {	
using the system id to connect to the smsc 

protected void doStop() throws Exception {	
disconnecting from 

protected void doStop() throws Exception {	super.doStop();	closeSession();	
disconnected from 

private void reconnect(final long initialReconnectDelay) {	if (connectLock.tryLock()) {	try {	Runnable r = new Runnable() {	public void run() {	boolean reconnected = false;	
schedule reconnect after millis 

public void run() {	boolean reconnected = false;	try {	Thread.sleep(initialReconnectDelay);	} catch (InterruptedException e) {	}	int attempt = 0;	while (!(isStopping() || isStopped()) && (session == null || session.getSessionState().equals(SessionState.CLOSED)) && attempt < configuration.getMaxReconnect()) {	try {	attempt++;	
trying to reconnect to attempt 

Thread.sleep(initialReconnectDelay);	} catch (InterruptedException e) {	}	int attempt = 0;	while (!(isStopping() || isStopped()) && (session == null || session.getSessionState().equals(SessionState.CLOSED)) && attempt < configuration.getMaxReconnect()) {	try {	attempt++;	session = createSession();	reconnected = true;	} catch (IOException e) {	
failed to reconnect to 

reconnected = true;	} catch (IOException e) {	closeSession();	try {	Thread.sleep(configuration.getReconnectDelay());	} catch (InterruptedException ee) {	}	}	}	if (reconnected) {	
reconnected to 

========================= camel sample_16902 =========================

public Object unmarshal(Exchange exchange, InputStream stream) throws Exception {	Document encodedDocument = exchange.getContext().getTypeConverter().convertTo(Document.class, exchange, stream);	if (null != keyCipherAlgorithm && (keyCipherAlgorithm.equals(XMLCipher.RSA_v1dot5) || keyCipherAlgorithm.equals(XMLCipher.RSA_OAEP) || keyCipherAlgorithm.equals(XMLCipher.RSA_OAEP_11))) {	return decodeWithAsymmetricKey(exchange, encodedDocument);	} else {	
no known asymmetric keycipheralgorithm specified attempting to decrypt using a symmetric key 

SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(algorithm);	secretKey = keyFactory.generateSecret(keySpec);	} else if (algorithm.equalsIgnoreCase("SEED")) {	secretKey = new SecretKeySpec(passPhrase, "SEED");	} else if (algorithm.equalsIgnoreCase("CAMELLIA")) {	secretKey = new SecretKeySpec(passPhrase, "CAMELLIA");	} else {	secretKey = new SecretKeySpec(passPhrase, "AES");	}	if (Arrays.equals(passPhrase, DEFAULT_KEY.getBytes())) {	
using the default encryption key is not secure 

========================= camel sample_6803 =========================

} finally {	lock.writeLock().unlock();	}	}	}	MessageHandlerAsyncCallback callback = new MessageHandlerAsyncCallback(exchange, messageProducer);	if (exchange.isFailed()) {	return;	} else {	if (isTransacted() || isSynchronous()) {	
synchronous processing message destination 

} else {	if (isTransacted() || isSynchronous()) {	try {	getProcessor().process(exchange);	} catch (Exception e) {	exchange.setException(e);	} finally {	callback.done(true);	}	} else {	
asynchronous processing message destination 

callback.done(true);	}	} else {	getProcessor().process(exchange, callback);	}	}	} catch (Exception e) {	exchange.setException(e);	}	if (log.isDebugEnabled()) {	
sjmsmessageconsumer invoked for exchange id 

public void close() {	for (final Map.Entry<String, MessageProducer> entry : producerCache.entrySet()) {	try {	entry.getValue().close();	} catch (JMSException e) {	
cached messageproducer with key threw an unexpected exception 

========================= camel sample_12412 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ServletComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.servlet.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.servlet.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_608 =========================

public void process(Exchange exchange) throws Exception {	MongoDbOperation operation = endpoint.getOperation();	Object header = exchange.getIn().getHeader(MongoDbConstants.OPERATION_HEADER);	if (header != null) {	
overriding default operation with operation specified on header 

return endpoint.getMongoDatabase();	}	String dynamicDB = exchange.getIn().getHeader(MongoDbConstants.DATABASE, String.class);	MongoDatabase db;	if (dynamicDB == null) {	db = endpoint.getMongoDatabase();	} else {	db = endpoint.getMongoConnection().getDatabase(dynamicDB);	}	if (LOG.isDebugEnabled()) {	
dynamic database selected 

} else {	dbCol = db.getCollection(dynamicCollection, BasicDBObject.class);	if (dynamicIndex == null) {	endpoint.ensureIndex(dbCol, endpoint.createIndex());	} else {	endpoint.ensureIndex(dbCol, dynamicIndex);	}	}	}	if (LOG.isDebugEnabled()) {	
dynamic database and or collection selected 

========================= camel sample_16451 =========================

public void validate(Message message, DataType type) throws ValidationException {	message.getExchange().setProperty(VALIDATOR_INVOKED, OtherXOrderValidator.class);	assertEquals("name=XOrder", message.getBody());	
java validation other xorder 

public void validate(Message message, DataType type) throws ValidationException {	message.getExchange().setProperty(VALIDATOR_INVOKED, OtherXOrderResponseValidator.class);	assertEquals("name=XOrderResponse", message.getBody());	
java validation other xorderresponse 

========================= camel sample_1295 =========================

public void process(Exchange exchange) throws Exception {	String toUsername = user;	if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(TwitterConstants.TWITTER_USER, String.class))) {	toUsername = exchange.getIn().getHeader(TwitterConstants.TWITTER_USER, String.class);	}	String text = exchange.getIn().getBody(String.class);	if (toUsername.isEmpty()) {	throw new CamelExchangeException("Username not configured on TwitterEndpoint", exchange);	} else {	
sending to message 

========================= camel sample_14196 =========================

public void appendBuilders(List<RoutesBuilder> list) throws IllegalAccessException, InstantiationException {	Set<Class<?>> classes = resolver.findImplementations(RoutesBuilder.class, packages);	for (Class<?> aClass : classes) {	
found routebuilder class 

public void appendBuilders(List<RoutesBuilder> list) throws IllegalAccessException, InstantiationException {	Set<Class<?>> classes = resolver.findImplementations(RoutesBuilder.class, packages);	for (Class<?> aClass : classes) {	if (shouldIgnoreBean(aClass)) {	
ignoring routebuilder class 

public void appendBuilders(List<RoutesBuilder> list) throws IllegalAccessException, InstantiationException {	Set<Class<?>> classes = resolver.findImplementations(RoutesBuilder.class, packages);	for (Class<?> aClass : classes) {	if (shouldIgnoreBean(aClass)) {	continue;	}	if (!isValidClass(aClass)) {	
ignoring invalid routebuilder class 

if (shouldIgnoreBean(aClass)) {	continue;	}	if (!isValidClass(aClass)) {	continue;	}	RoutesBuilder builder = instantiateBuilder((Class<? extends RoutesBuilder>) aClass);	if (beanPostProcessor != null) {	beanPostProcessor.postProcessBeforeInitialization(builder, builder.toString());	}	
adding instantiated routebuilder 

========================= camel sample_16350 =========================

public int poll() throws Exception {	if (!prepareOnStartup) {	endpoint.getGenericFileProcessStrategy().prepareOnStartup(operations, endpoint);	prepareOnStartup = true;	}	fileExpressionResult = null;	shutdownRunningTask = null;	pendingExchanges = 0;	if (!prePollCheck()) {	
skipping poll as pre poll check returned false 

if (!prePollCheck()) {	return 0;	}	List<GenericFile<T>> files = new ArrayList<GenericFile<T>>();	String name = endpoint.getConfiguration().getDirectory();	StopWatch stop = new StopWatch();	boolean limitHit;	try {	limitHit = !pollDirectory(name, files, 0);	} catch (Exception e) {	
error occurred during poll directory due removing files marked as in progress 

StopWatch stop = new StopWatch();	boolean limitHit;	try {	limitHit = !pollDirectory(name, files, 0);	} catch (Exception e) {	removeExcessiveInProgressFiles(files);	throw e;	}	long delta = stop.taken();	if (log.isDebugEnabled()) {	
took to poll 

try {	limitHit = !pollDirectory(name, files, 0);	} catch (Exception e) {	removeExcessiveInProgressFiles(files);	throw e;	}	long delta = stop.taken();	if (log.isDebugEnabled()) {	}	if (limitHit) {	
limiting maximum messages to poll at files as there were more messages in this poll 

}	if (endpoint.getSortBy() != null) {	exchanges.sort(endpoint.getSortBy());	}	if (endpoint.isShuffle()) {	Collections.shuffle(exchanges);	}	Deque<Exchange> q = exchanges;	if (!eagerLimitMaxMessagesPerPoll && maxMessagesPerPoll > 0) {	if (files.size() > maxMessagesPerPoll) {	
limiting maximum messages to poll at files as there were more messages in this poll 

Collections.shuffle(exchanges);	}	Deque<Exchange> q = exchanges;	if (!eagerLimitMaxMessagesPerPoll && maxMessagesPerPoll > 0) {	if (files.size() > maxMessagesPerPoll) {	removeExcessiveInProgressFiles(q, maxMessagesPerPoll);	}	}	int total = exchanges.size();	if (total > 0) {	
total files to consume 

public int processBatch(Queue<Object> exchanges) {	int total = exchanges.size();	int answer = total;	if (maxMessagesPerPoll > 0 && total > maxMessagesPerPoll) {	
limiting to maximum messages to poll as there were messages in this poll 

protected boolean processExchange(final Exchange exchange) {	GenericFile<T> file = getExchangeFileProperty(exchange);	
processing file 

final GenericFileProcessStrategy<T> processStrategy = endpoint.getGenericFileProcessStrategy();	Exception beginCause = null;	boolean begin = false;	try {	begin = processStrategy.begin(operations, endpoint, exchange, file);	} catch (Exception e) {	beginCause = e;	}	if (!begin) {	Exception abortCause = null;	
cannot begin processing file 

String msg2 = endpoint + " cannot abort processing file: " + file + " due to: " + abortCause.getMessage();	handleException(msg2, abortCause);	}	return false;	}	final GenericFile<T> target = getExchangeFileProperty(exchange);	updateFileHeaders(target, exchange.getIn());	final String name = target.getAbsoluteFilePath();	try {	if (isRetrieveFile()) {	
retrieving file from 

boolean retrieved;	Exception cause = null;	try {	retrieved = operations.retrieveFile(name, exchange, target.getFileLength());	} catch (Exception e) {	retrieved = false;	cause = e;	}	if (!retrieved) {	if (ignoreCannotRetrieveFile(name, exchange, cause)) {	
cannot retrieve file maybe it does not exists ignoring 

endpoint.getInProgressRepository().remove(absoluteFileName);	return false;	} else {	if (cause instanceof GenericFileOperationFailedException) {	throw cause;	} else {	throw new GenericFileOperationFailedException("Cannot retrieve file: " + file + " from: " + endpoint, cause);	}	}	}	
retrieved file from 

return false;	} else {	if (cause instanceof GenericFileOperationFailedException) {	throw cause;	} else {	throw new GenericFileOperationFailedException("Cannot retrieve file: " + file + " from: " + endpoint, cause);	}	}	}	} else {	
skipped retrieval of file from 

throw cause;	} else {	throw new GenericFileOperationFailedException("Cannot retrieve file: " + file + " from: " + endpoint, cause);	}	}	}	} else {	exchange.getIn().setBody(null);	}	exchange.addOnCompletion(new GenericFileOnCompletion<T>(endpoint, operations, target, absoluteFileName));	
about to process file using exchange 

protected boolean customProcessExchange(final Exchange exchange, final Processor processor) {	GenericFile<T> file = getExchangeFileProperty(exchange);	
custom processing file 

protected boolean customProcessExchange(final Exchange exchange, final Processor processor) {	GenericFile<T> file = getExchangeFileProperty(exchange);	String absoluteFileName = file.getAbsoluteFilePath();	try {	processor.process(exchange);	} catch (Exception e) {	if (log.isDebugEnabled()) {	
error custom processing due to this exception will be ignored 

protected boolean isValidFile(GenericFile<T> file, boolean isDirectory, List<T> files) {	String absoluteFilePath = file.getAbsoluteFilePath();	if (!isMatched(file, isDirectory, files)) {	
file did not match will skip this file 

protected boolean isValidFile(GenericFile<T> file, boolean isDirectory, List<T> files) {	String absoluteFilePath = file.getAbsoluteFilePath();	if (!isMatched(file, isDirectory, files)) {	return false;	}	if (isDirectory) {	return true;	}	if (endpoint.getInProgressRepository().contains(absoluteFilePath)) {	if (log.isTraceEnabled()) {	
skipping as file is already in progress 

}	return false;	}	if (endpoint.isIdempotent()) {	String key = file.getAbsoluteFilePath();	if (endpoint.getIdempotentKey() != null) {	Exchange dummy = endpoint.createExchange(file);	key = endpoint.getIdempotentKey().evaluate(dummy, String.class);	}	if (key != null && endpoint.getIdempotentRepository().contains(key)) {	
this consumer is idempotent and the file has been consumed before matching idempotentkey will skip this file 

Exchange dummy = endpoint.createExchange(file);	boolean matches = endpoint.getFilterFile().matches(dummy);	if (!matches) {	return false;	}	}	if (endpoint.getDoneFileName() != null) {	String doneFileName = endpoint.createDoneFileName(file.getAbsoluteFilePath());	StringHelper.notEmpty(doneFileName, "doneFileName", endpoint);	if (endpoint.isDoneFile(file.getFileNameOnly())) {	
skipping done file 

========================= camel sample_4796 =========================

private void doTestWSHttpCall() throws Exception {	final List<Object> received = new ArrayList<Object>();	final CountDownLatch latch = new CountDownLatch(1);	AsyncHttpClient c = new DefaultAsyncHttpClient();	WebSocket websocket = c.prepareGet("ws: .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

========================= camel sample_13152 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	String routeId = "mllp-sender";	public void configure() {	
ar acknowledgement 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	String routeId = "mllp-sender";	public void configure() {	
ae acknowledgement 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	String routeId = "mllp-sender";	public void configure() {	
acknowledgement receive failed 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	String routeId = "mllp-sender";	public void configure() {	
acknowledgement receive timeout 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	String routeId = "mllp-sender";	public void configure() {	
invalid acknowledgement 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	String routeId = "mllp-sender";	public void configure() {	
exchange failed 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	String routeId = "mllp-sender";	public void configure() {	
sending message mllp log logginglevel info routeid acknowledgement to aa 

========================= camel sample_13851 =========================

try {	classpathElements = project.getTestClasspathElements();	} catch (org.apache.maven.artifact.DependencyResolutionRequiredException e) {	throw new MojoExecutionException(e.getMessage(), e);	}	final URL[] urls = new URL[classpathElements.size()];	int i = 0;	for (Iterator it = classpathElements.iterator(); it.hasNext(); i++) {	try {	urls[i] = new File((String) it.next()).toURI().toURL();	
adding project path 

========================= camel sample_109 =========================

}	MimeMessage mimeMessage;	final Object body = exchange.getIn().getBody();	if (body instanceof MimeMessage) {	mimeMessage = (MimeMessage) body;	} else {	mimeMessage = new MimeMessage(sender.getSession());	getEndpoint().getBinding().populateMailMessage(getEndpoint(), mimeMessage, exchange);	}	if (LOG.isDebugEnabled()) {	
sending mimemessage 

========================= camel sample_11883 =========================

ObjectHelper.notNull(configuration.getKeyCertChainResource(), "serviceAccountResource");	ClassResolver classResolver = endpoint.getCamelContext().getClassResolver();	Credentials creds = GoogleCredentials.fromStream(ResourceHelper.resolveResourceAsInputStream(classResolver, configuration.getServiceAccountResource()));	callCreds = MoreCallCredentials.from(creds);	} else if (configuration.getAuthenticationType() == GrpcAuthType.JWT) {	ObjectHelper.notNull(configuration.getJwtSecret(), "jwtSecret");	String jwtToken = JwtHelper.createJwtToken(configuration.getJwtAlgorithm(), configuration.getJwtSecret(), configuration.getJwtIssuer(), configuration.getJwtSubject());	callCreds = new JwtCallCredentials(jwtToken);	}	if (endpoint.isSynchronous()) {	
getting synchronous method stub from channel 

Credentials creds = GoogleCredentials.fromStream(ResourceHelper.resolveResourceAsInputStream(classResolver, configuration.getServiceAccountResource()));	callCreds = MoreCallCredentials.from(creds);	} else if (configuration.getAuthenticationType() == GrpcAuthType.JWT) {	ObjectHelper.notNull(configuration.getJwtSecret(), "jwtSecret");	String jwtToken = JwtHelper.createJwtToken(configuration.getJwtAlgorithm(), configuration.getJwtSecret(), configuration.getJwtIssuer(), configuration.getJwtSubject());	callCreds = new JwtCallCredentials(jwtToken);	}	if (endpoint.isSynchronous()) {	grpcStub = GrpcUtils.constructGrpcBlockingStub(endpoint.getServicePackage(), endpoint.getServiceName(), channel, callCreds, endpoint.getCamelContext());	} else {	
getting asynchronous method stub from channel 

protected void doStop() throws Exception {	if (channel != null) {	forwarder.shutdown();	forwarder = null;	
terminating channel to the remote grpc server 

protected void initializeChannel() throws Exception {	NettyChannelBuilder channelBuilder = null;	if (!ObjectHelper.isEmpty(configuration.getHost()) && !ObjectHelper.isEmpty(configuration.getPort())) {	
creating channel to the remote grpc server 

========================= camel sample_7505 =========================

context.addService(service);	context.addRoutePolicyFactory(ClusteredRoutePolicyFactory.forNamespace("my-ns"));	context.addRoutes(new RouteBuilder() {	public void configure() throws Exception {	from("timer:zookeeper?delay=1s&period=1s") .routeId("route-" + id) .log("From ${routeId}") .process(e -> contextLatch.countDown());	}	});	Thread.sleep(ThreadLocalRandom.current().nextInt(500));	context.start();	contextLatch.await();	
shutting down node 

========================= camel sample_12606 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<AtomixValueComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.atomix-value.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.atomix-value.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1081 =========================

protected void configureSSLContext(SSLContext context) throws GeneralSecurityException {	
configuring client and server side sslcontext parameters on sslcontext 

protected void configureSSLContext(SSLContext context) throws GeneralSecurityException {	if (this.getSessionTimeout() != null) {	
configuring client and server side sslcontext session timeout on sslcontext to 

protected void configureSSLContext(SSLContext context) throws GeneralSecurityException {	if (this.getSessionTimeout() != null) {	this.configureSessionContext(context.getClientSessionContext(), this.getSessionTimeout());	this.configureSessionContext(context.getServerSessionContext(), this.getSessionTimeout());	}	
configured client and server side sslcontext parameters on sslcontext 

public SSLContextDecorator(SSLContextSpiDecorator decorator) {	super(decorator, decorator.getDelegate().getProvider(), decorator.getDelegate().getProtocol());	
sslcontextdecorator decorating sslcontext 

protected SSLEngine engineCreateSSLEngine() {	SSLEngine engine = this.context.createSSLEngine();	
sslengine created from sslcontext 

protected SSLEngine engineCreateSSLEngine(String peerHost, int peerPort) {	SSLEngine engine = this.context.createSSLEngine(peerHost, peerPort);	
sslengine created from sslcontext 

protected SSLServerSocketFactory engineGetServerSocketFactory() {	SSLServerSocketFactory factory = this.context.getServerSocketFactory();	
sslserversocketfactoryengine created from sslcontext 

protected SSLSocketFactory engineGetSocketFactory() {	SSLSocketFactory factory = this.context.getSocketFactory();	
sslsocketfactory created from sslcontext 

private ServerSocket configureSocket(ServerSocket s) {	SSLServerSocket workingSocket = (SSLServerSocket) s;	
created serversocket from sslserversocketfactory 

private Socket configureSocket(Socket s) {	SSLSocket workingSocket = (SSLSocket) s;	
created socket from socketfactory 

========================= camel sample_4283 =========================

public HttpClientInitializerFactory(NettyHttpProducer nettyProducer) {	this.producer = nettyProducer;	try {	this.sslContext = createSSLContext(producer);	} catch (Exception e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	}	if (sslContext != null) {	
created sslcontext 

protected void initChannel(Channel ch) throws Exception {	ChannelPipeline pipeline = ch.pipeline();	SslHandler sslHandler = configureClientSSLOnDemand();	if (sslHandler != null) {	
client ssl handler configured and added as an interceptor against the channelpipeline 

for (int x = 0; x < decoders.size(); x++) {	ChannelHandler decoder = decoders.get(x);	if (decoder instanceof ChannelHandlerFactory) {	decoder = ((ChannelHandlerFactory) decoder).newChannelHandler();	}	pipeline.addLast("decoder-" + x, decoder);	}	pipeline.addLast("aggregator", new HttpObjectAggregator(configuration.getChunkedMaxContentLength()));	if (producer.getConfiguration().getRequestTimeout() > 0) {	if (LOG.isTraceEnabled()) {	
using request timeout millis 

private SSLContext createSSLContext(NettyProducer producer) throws Exception {	NettyConfiguration configuration = producer.getConfiguration();	if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(producer.getContext());	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	
keystorefile is null 

if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(producer.getContext());	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	
truststorefile is null 

}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(producer.getContext());	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	}	if (configuration.getPassphrase().toCharArray() == null) {	
passphrase is null 

========================= camel sample_16645 =========================

public void startThriftClient() throws IOException, TTransportException {	if (transport == null) {	
connecting to the thrift server on port 

public void stopThriftClient() throws Exception {	if (transport != null) {	transport.close();	transport = null;	
connection to the thrift server closed 

========================= camel sample_13017 =========================

public boolean process(Exchange exchange, AsyncCallback callback) {	DirectVmConsumer consumer = endpoint.getComponent().getConsumer(endpoint);	if (consumer == null) {	if (endpoint.isFailIfNoConsumers()) {	exchange.setException(new DirectVmConsumerNotAvailableException("No consumers available on endpoint: " + endpoint, exchange));	} else {	
message ignored no consumers available on endpoint 

========================= camel sample_4903 =========================

if (httpClientAPI == null) {	httpClientAPI = ((CxfRsEndpoint) getEndpoint()).isHttpClientAPI();	}	if (httpClientAPI.booleanValue()) {	invokeAsyncHttpClient(exchange, callback);	} else {	invokeAsyncProxyClient(exchange, callback);	}	return false;	} catch (Exception exception) {	
error invoking request 

Map<String, String> maps = null;	if (requestURL != null && matrixStart > 0) {	matrixParam = requestURL.substring(matrixStart + 1, matrixEnd);	if (matrixParam != null) {	maps = getMatrixParametersFromMatrixString(matrixParam, IOHelper.getCharsetName(exchange));	}	}	if (maps != null) {	for (Map.Entry<String, String> entry : maps.entrySet()) {	client.matrix(entry.getKey(), entry.getValue());	
matrix param 

if (genericType != null && !genericType.equals(Void.TYPE)) {	GenericType genericType = new GenericType(this.genericType);	exchange.getOut().setBody(binding.bindResponseToCamelBody(response.readEntity(genericType), exchange));	} else if (responseClass != null && !responseClass.equals(Void.TYPE)) {	exchange.getOut().setBody(binding.bindResponseToCamelBody(response.readEntity(responseClass), exchange));	} else {	exchange.getOut().setBody(binding.bindResponseToCamelBody(response, exchange));	}	exchange.getOut().setHeader(Exchange.HTTP_RESPONSE_CODE, response.getStatus());	} catch (Exception exception) {	
error while processing response 

public void failed(Throwable throwable) {	
failed request 

public void failed(Throwable throwable) {	try {	saveCookies(exchange, client, cxfRsEndpoint.getCookieHandler());	fail(throwable);	} catch (Exception error) {	
error while processing failed request 

if (!exchange.getPattern().isOutCapable()) {	return;	}	LOG.trace("Response body = {}", response);	exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());	final CxfRsBinding binding = cxfRsEndpoint.getBinding();	exchange.getOut().getHeaders().putAll(binding.bindResponseHeadersToCamelHeaders(response, exchange));	exchange.getOut().setBody(binding.bindResponseToCamelBody(body, exchange));	exchange.getOut().setHeader(Exchange.HTTP_RESPONSE_CODE, response.getStatus());	} catch (Exception exception) {	
error while processing response 

public void failed(Throwable throwable) {	
failed request 

public void failed(Throwable throwable) {	try {	saveCookies(exchange, client, cxfRsEndpoint.getCookieHandler());	fail(throwable);	} catch (Exception error) {	
error while processing failed request 

public JAXRSClientFactoryBean get(String address) throws Exception {	JAXRSClientFactoryBean retVal = null;	synchronized (cache) {	retVal = cache.get(address);	if (retVal == null) {	retVal = ((CxfRsEndpoint)getEndpoint()).createJAXRSClientFactoryBean(address);	cache.put(address, retVal);	
created client factory bean and add to cache for address 

public JAXRSClientFactoryBean get(String address) throws Exception {	JAXRSClientFactoryBean retVal = null;	synchronized (cache) {	retVal = cache.get(address);	if (retVal == null) {	retVal = ((CxfRsEndpoint)getEndpoint()).createJAXRSClientFactoryBean(address);	cache.put(address, retVal);	} else {	
retrieved client factory bean from cache for address 

========================= camel sample_8023 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<FtpComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ftp.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ftp.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_735 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<XQueryLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.xquery.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.xquery.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_1202 =========================

Date startDate = new Date();	Date endDate = new Date(startDate.getTime() + 3600000);	DateTime start = new DateTime(startDate, TimeZone.getTimeZone("UTC"));	event.setStart(new EventDateTime().setDateTime(start));	DateTime end = new DateTime(endDate, TimeZone.getTimeZone("UTC"));	event.setEnd(new EventDateTime().setDateTime(end));	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelGoogleCalendar.calendarId", getCalendar().getId());	headers.put("CamelGoogleCalendar.content", event);	final com.google.api.services.calendar.model.Event result = requestBodyAndHeaders("direct: assertEquals("Feed the Camel", result.getSummary());	
insert 

========================= camel sample_11753 =========================

protected void doListPodsByLabel(Exchange exchange, String operation) {	Map<String, String> labels = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_PODS_LABELS, Map.class);	if (ObjectHelper.isEmpty(labels)) {	
get pods by labels require specify a labels set 

protected void doGetPod(Exchange exchange, String operation) throws Exception {	Pod pod = null;	String podName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_POD_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(podName)) {	
get a specific pod require specify a pod name 

protected void doGetPod(Exchange exchange, String operation) throws Exception {	Pod pod = null;	String podName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_POD_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(podName)) {	throw new IllegalArgumentException( "Get a specific pod require specify a pod name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
get a specific pod require specify a namespace name 

protected void doCreatePod(Exchange exchange, String operation) throws Exception {	Pod pod = null;	String podName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_POD_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	PodSpec podSpec = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_POD_SPEC, PodSpec.class);	if (ObjectHelper.isEmpty(podName)) {	
create a specific pod require specify a pod name 

protected void doCreatePod(Exchange exchange, String operation) throws Exception {	Pod pod = null;	String podName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_POD_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	PodSpec podSpec = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_POD_SPEC, PodSpec.class);	if (ObjectHelper.isEmpty(podName)) {	throw new IllegalArgumentException( "Create a specific pod require specify a pod name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
create a specific pod require specify a namespace name 

String podName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_POD_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	PodSpec podSpec = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_POD_SPEC, PodSpec.class);	if (ObjectHelper.isEmpty(podName)) {	throw new IllegalArgumentException( "Create a specific pod require specify a pod name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	throw new IllegalArgumentException( "Create a specific pod require specify a namespace name");	}	if (ObjectHelper.isEmpty(podSpec)) {	
create a specific pod require specify a pod spec bean 

protected void doDeletePod(Exchange exchange, String operation) throws Exception {	String podName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_POD_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(podName)) {	
delete a specific pod require specify a pod name 

protected void doDeletePod(Exchange exchange, String operation) throws Exception {	String podName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_POD_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(podName)) {	throw new IllegalArgumentException( "Delete a specific pod require specify a pod name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
delete a specific pod require specify a namespace name 

========================= camel sample_13294 =========================

public EmbeddedServletContainerCustomizer containerCustomizer() {	return container -> {	try (ServerSocket socket = new ServerSocket(0)) {	
server port 

========================= camel sample_17668 =========================

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyCdiConcatRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	
consumer 

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyCdiConcatRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	}	Assert.assertEquals("timer:foo?period=4999", list.get(0).getElement());	list = CamelJavaParserHelper.parseCamelProducerUris(method, true, true);	for (ParserResult result : list) {	
producer 

========================= camel sample_220 =========================

public void removeWebSocket(String connectionKey) {	Object obj = values.remove(connectionKey);	if (obj != null) {	keys.remove(obj);	}	
removed websocket 

public void removeWebSocket(WebSocket websocket) {	Object obj = keys.remove(websocket);	if (obj != null) {	values.remove(obj);	}	
removed websocket 

========================= camel sample_10007 =========================

public void process(Exchange exchange) throws Exception {	String message = exchange.getIn().getBody(String.class);	if (null != message) {	String msh = message.substring(0, message.indexOf('\r'));	
processing msh 

public void process(Exchange exchange) throws Exception {	String message = exchange.getIn().getBody(String.class);	if (null != message) {	String msh = message.substring(0, message.indexOf('\r'));	}	
null inbound message body 

========================= camel sample_13806 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<BeanIODataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.beanio.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.beanio.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_1039 =========================

public Boolean executeTest(ITestConfig config, String dataFormat) throws Exception {	
getting camel dataformat 

public Boolean executeTest(ITestConfig config, String dataFormat) throws Exception {	DataFormat df = context.resolveDataFormat(dataFormat);	assertNotNull("Cannot get dataformat with name: " + dataFormat, df);	
found camel dataformat instance with classname 

========================= camel sample_5996 =========================

public void channelRead(final ChannelHandlerContext ctx, final Object msg) throws Exception {	if (msg instanceof AbstractMessage) {	final AbstractMessage amsg = (AbstractMessage)msg;	final Cause cause = amsg.getHeader().getCauseOfTransmission().getCause();	if (this.discards.contains(cause)) {	
discarding 

========================= camel sample_6713 =========================

public void testWSHttpCall() throws Exception {	AsyncHttpClient c = createAsyncHttpSSLClient();	WebSocket websocket = c.prepareGet("wss: new WebSocketUpgradeHandler.Builder() .addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

========================= camel sample_17453 =========================

private CellMappingStrategy loadStrategyFromClassName(String strategyClassName) {	ClassLoader classLoader = Thread.currentThread().getContextClassLoader();	if (classLoader != null) {	try {	Class<?> clazz = classLoader.loadClass(strategyClassName);	return (CellMappingStrategy) clazz.newInstance();	} catch (Throwable e) {	
failed to load hbase cell mapping strategy from class 

========================= camel sample_14506 =========================

Person person = new Person();	person.setFirstName("Christian");	person.setLastName("Mueller");	person.setAge(Integer.valueOf(36));	person.setAddress(address);	long start = System.currentTimeMillis();	for (int i = 0; i < testCount; i++) {	template.sendBody("seda:marshall", person);	}	assertMockEndpointsSatisfied();	
validation of messages took ms 

public void concurrentUnmarshall() throws Exception {	mockUnmarshall.expectedMessageCount(testCount);	String xml = new StringBuilder("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>") .append("<person xmlns=\"person.jaxb.converter.camel.apache.org\" xmlns:ns2=\"address.jaxb.converter.camel.apache.org\">") .append("<firstName>Christian</firstName>") .append("<lastName>Mueller</lastName>") .append("<age>36</age>") .append("<address>") .append("<ns2:addressLine1>Hauptstr. 1; 01129 Entenhausen</ns2:addressLine1>") .append("</address>") .append("</person>") .toString();	long start = System.currentTimeMillis();	for (int i = 0; i < testCount; i++) {	template.sendBody("seda:unmarshall", xml);	}	assertMockEndpointsSatisfied(20, TimeUnit.SECONDS);	
validation of messages took ms 

========================= camel sample_13739 =========================

public void processEvent(BestSolutionChangedEvent<Object> event) {	Exchange exchange = getEndpoint().createExchange();	exchange.getOut().setHeader(OptaPlannerConstants.BEST_SOLUTION, event.getNewBestSolution());	try {	getProcessor().process(exchange);	} catch (Exception e) {	
error processing event 

========================= camel sample_11704 =========================

protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {	if (metricRegistry == null) {	Registry camelRegistry = getCamelContext().getRegistry();	metricRegistry = getOrCreateMetricRegistry(camelRegistry, METRIC_REGISTRY_NAME);	}	String metricsName = getMetricsName(remaining);	MetricsType metricsType = getMetricsType(remaining);	
metrics type name 

========================= camel sample_13693 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<PhpLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.php.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.php.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_1255 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<StringTemplateComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.string-template.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.string-template.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_762 =========================

public MemcachedClient getMemcachedClient(KestrelConfiguration config, String queue) {	String key = config.getAddressesAsString() + "/" + queue;	MemcachedClient memcachedClient = memcachedClientCache.get(key);	if (memcachedClient != null) {	return memcachedClient;	}	synchronized (memcachedClientCache) {	if ((memcachedClient = memcachedClientCache.get(key)) == null) {	
creating memcachedclient for 

public void closeMemcachedClient(String key, MemcachedClient memcachedClient) {	try {	
closing client connection to 

public void closeMemcachedClient(String key, MemcachedClient memcachedClient) {	try {	memcachedClient.shutdown();	memcachedClientCache.remove(key);	} catch (Exception e) {	
failed to close client connection to 

========================= camel sample_8074 =========================

ServerChannel channel = bayeux.getChannel(channelName);	ServerSession serverSession = getServerSession();	try {	if (channel != null) {	logDelivery(exchange, channel);	ServerMessage.Mutable mutable = binding.createCometdMessage(channel, serverSession, exchange.getIn());	channel.publish(serverSession, mutable);	}	} finally {	if (disconnectLocalSession && serverSession.isLocalSession()) {	
disconnection local session 

========================= camel sample_12578 =========================

public void testShutdown() throws Exception {	
using shutdown strategy 

========================= camel sample_10050 =========================

if (endpoint.getRoom() == null) {	privateChat = chatManager.chatWith(JidCreate.entityBareFrom(endpoint.getChatId()));	} else {	final AndFilter packetFilter = new AndFilter(new StanzaTypeFilter(Presence.class));	connection.addSyncStanzaListener(this, packetFilter);	MultiUserChatManager mucm = MultiUserChatManager.getInstanceFor(connection);	muc = mucm.getMultiUserChat(JidCreate.entityBareFrom(endpoint.resolveRoom(connection)));	muc.addMessageListener(this);	MucEnterConfiguration mucc = muc.getEnterConfigurationBuilder(Resourcepart.from(endpoint.getNickname())) .requestNoHistory() .build();	muc.join(mucc);	
joined room as 

protected void scheduleDelayedStart() throws Exception {	Runnable startRunnable = new Runnable() {	public void run() {	try {	doStart();	} catch (Exception e) {	
ignoring an exception caught in the startup connection poller thread 

protected void scheduleDelayedStart() throws Exception {	Runnable startRunnable = new Runnable() {	public void run() {	try {	doStart();	} catch (Exception e) {	}	}	};	
delaying xmpp consumer startup for endpoint trying again in seconds 

private void startRobustConnectionMonitor() throws Exception {	Runnable connectionCheckRunnable = new Runnable() {	public void run() {	try {	checkConnection();	} catch (Exception e) {	
ignoring an exception caught in the connection poller thread 

private void checkConnection() throws Exception {	if (!connection.isConnected()) {	
attempting to reconnect to 

private void checkConnection() throws Exception {	if (!connection.isConnected()) {	try {	connection.connect();	
successfully connected to xmpp server through 

private void checkConnection() throws Exception {	if (!connection.isConnected()) {	try {	connection.connect();	} catch (SmackException e) {	
connection to xmpp server failed will try to reconnect later again 

protected void doStop() throws Exception {	super.doStop();	if (scheduledExecutor != null) {	getEndpoint().getCamelContext().getExecutorServiceManager().shutdownNow(scheduledExecutor);	scheduledExecutor = null;	}	if (muc != null) {	
leaving room 

public void processMessage(Chat chat, Message message) {	if (LOG.isDebugEnabled()) {	
received xmpp message for from 

}	try {	getProcessor().process(exchange);	} catch (Exception e) {	exchange.setException(e);	} finally {	if (muc != null) {	try {	muc.pollMessage();	} catch (MultiUserChatException.MucNotJoinedException e) {	
error while polling message from multiuserchat this exception will be ignored 

========================= camel sample_12597 =========================

public static void subnumbers(int val1, int val2, int[] ret) {	
calling addnumbers 

public static void batchfn(String val1) {	
calling batchfn 

public static void niladic() {	
nilacid called 

========================= camel sample_8998 =========================

initRouteAndContextScopedExceptionPolicies(exceptionPolicies, routeScoped, contextScoped);	boolean exactMatch = false;	Iterator<Throwable> it = createExceptionIterator(exception);	while (!exactMatch && it.hasNext()) {	exactMatch = findMatchedExceptionPolicy(routeScoped, exchange, it.next(), candidates);	}	it = createExceptionIterator(exception);	while (!exactMatch && it.hasNext()) {	exactMatch = findMatchedExceptionPolicy(contextScoped, exchange, it.next(), candidates);	}	
found candidates 

private boolean findMatchedExceptionPolicy(Map<ExceptionPolicyKey, OnExceptionDefinition> exceptionPolicies, Exchange exchange, Throwable exception, Map<Integer, OnExceptionDefinition> candidates) {	if (LOG.isTraceEnabled()) {	
finding best suited exception policy for thrown exception 

int candidateDiff = Integer.MAX_VALUE;	Set<Map.Entry<ExceptionPolicyKey, OnExceptionDefinition>> entries = exceptionPolicies.entrySet();	for (Map.Entry<ExceptionPolicyKey, OnExceptionDefinition> entry : entries) {	Class<?> clazz = entry.getKey().getExceptionClass();	OnExceptionDefinition type = entry.getValue();	if (exchange != null && exchange.getUnitOfWork() != null && type.isRouteScoped()) {	RouteDefinition route = exchange.getUnitOfWork().getRouteContext() != null ? exchange.getUnitOfWork().getRouteContext().getRoute() : null;	RouteDefinition typeRoute = ProcessorDefinitionHelper.getRoute(type);	if (route != null && typeRoute != null && route != typeRoute) {	if (LOG.isTraceEnabled()) {	
the type is scoped for route however exchange is at route 

RouteDefinition route = exchange.getUnitOfWork().getRouteContext() != null ? exchange.getUnitOfWork().getRouteContext().getRoute() : null;	RouteDefinition typeRoute = ProcessorDefinitionHelper.getRoute(type);	if (route != null && typeRoute != null && route != typeRoute) {	if (LOG.isTraceEnabled()) {	}	continue;	}	}	if (filter(type, clazz, exception)) {	if (!matchesWhen(type, exchange)) {	
the type did not match when 

int level = getInheritanceLevel(clazz);	int diff = targetLevel - level;	if (diff < candidateDiff) {	candidate = type;	candidateDiff = diff;	}	}	}	if (candidate != null) {	if (!candidates.containsKey(candidateDiff)) {	
adding as candidate at level 

candidate = type;	candidateDiff = diff;	}	}	}	if (candidate != null) {	if (!candidates.containsKey(candidateDiff)) {	candidates.put(candidateDiff, candidate);	} else {	if (LOG.isTraceEnabled()) {	
existing candidate takes precedence over at level 

if (candidate != null) {	if (!candidates.containsKey(candidateDiff)) {	candidates.put(candidateDiff, candidate);	} else {	if (LOG.isTraceEnabled()) {	}	}	}	boolean exactMatch = candidateDiff == 0;	if (LOG.isTraceEnabled() && exactMatch) {	
exact match found for candidate 

========================= camel sample_4542 =========================

CommunityTarget communityTarget = new CommunityTarget();	communityTarget.setCommunity(convertToOctetString(endpoint.getSnmpCommunity()));	communityTarget.setAddress(targetAddress);	communityTarget.setRetries(endpoint.getRetries());	communityTarget.setTimeout(endpoint.getTimeout());	communityTarget.setVersion(endpoint.getSnmpVersion());	this.target = communityTarget;	this.pdu = new PDU();	}	if (LOG.isDebugEnabled()) {	
starting oid poller on using protocol 

communityTarget.setRetries(endpoint.getRetries());	communityTarget.setTimeout(endpoint.getTimeout());	communityTarget.setVersion(endpoint.getSnmpVersion());	this.target = communityTarget;	this.pdu = new PDU();	}	if (LOG.isDebugEnabled()) {	}	this.transport.listen();	if (LOG.isInfoEnabled()) {	
started oid poller on using protocol 

protected void doStop() throws Exception {	if (this.transport != null && this.transport.isListening()) {	
stopping oid poller on 

protected void doStop() throws Exception {	if (this.transport != null && this.transport.isListening()) {	this.transport.close();	
stopped oid poller on 

public void onResponse(ResponseEvent event) {	((Snmp)event.getSource()).cancel(event.getRequest(), this);	if (event.getRequest() == null || event.getResponse() == null) {	
received invalid snmp event request response 

public void processPDU(PDU pdu) {	if (LOG.isDebugEnabled()) {	
received response event for 

========================= camel sample_8832 =========================

defaultErrorHandlerBuilder.redeliveryDelay(0);	defaultErrorHandlerBuilder.maximumRedeliveries(2);	context.setErrorHandlerBuilder(defaultErrorHandlerBuilder);	context.addRoutes(new RouteBuilder() {	public void configure() throws Exception {	context.setTracing(false);	onException(OrderFailedException.class) .maximumRedeliveries(0) .continued(true);	from("direct:dead").to("log:dead", "mock:dead");	from("direct:order") .to("mock:one") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	
first processor invoked 

public void configure() throws Exception {	context.setTracing(false);	onException(OrderFailedException.class) .maximumRedeliveries(0) .continued(true);	from("direct:dead").to("log:dead", "mock:dead");	from("direct:order") .to("mock:one") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	throw new OrderFailedException("First Processor Failure");	}	}) .to("mock:two") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	
second processor invoked 

from("direct:dead").to("log:dead", "mock:dead");	from("direct:order") .to("mock:one") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	throw new OrderFailedException("First Processor Failure");	}	}) .to("mock:two") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	}	}) .to("mock:three") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	
third processor invoked 

}	}) .to("mock:two") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	}	}) .to("mock:three") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	throw new RuntimeException("Some Runtime Exception");	}	}) .to("mock:four") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	
fourth processor invoked 

========================= camel sample_3911 =========================

public Exchange add(final CamelContext camelContext, final String key, final Exchange exchange) {	
adding an exchange with id for key in a thread safe manner 

public void remove(CamelContext camelContext, String key, Exchange exchange) {	
removing an exchange with id for key 

public void confirm(CamelContext camelContext, String exchangeId) {	
confirming an exchange with id 

public Set<String> scan(CamelContext camelContext) {	
scanning for exchanges to recover in context 

public Set<String> scan(CamelContext camelContext) {	Set<String> scanned = Collections.unmodifiableSet(cache.keySet());	
found keys for exchanges to recover in context 

public Exchange recover(CamelContext camelContext, String exchangeId) {	
recovering an exchange with id 

========================= camel sample_13955 =========================

private void readFromStream() throws Exception {	long index = 0;	String line;	BufferedReader br = initializeStream();	if (endpoint.isScanStream()) {	while (isRunAllowed()) {	if (br != null) {	line = br.readLine();	
read line 

String line2 = null;	while (!eos && isRunAllowed()) {	if (endpoint.getPromptMessage() != null) {	doPromptMessage();	}	if (line2 == null) {	line = br.readLine();	} else {	line = line2;	}	
read line 

private InputStream resolveStreamFromUrl() throws IOException {	String u = endpoint.getUrl();	ObjectHelper.notEmpty(u, "url");	
about to read from url 

private InputStream resolveStreamFromFile() throws IOException {	String fileName = endpoint.getFileName();	ObjectHelper.notEmpty(fileName, "fileName");	FileInputStream fileStream;	File file = new File(fileName);	if (LOG.isDebugEnabled()) {	
file to be scanned path 

========================= camel sample_11968 =========================

public void testWSHttpCall() throws Exception {	AsyncHttpClient c = new DefaultAsyncHttpClient();	WebSocket websocket = c.prepareGet("ws: new WebSocketUpgradeHandler.Builder() .addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

========================= camel sample_17445 =========================

protected void loadResource(String resourceUri) throws TransformerException, IOException {	
loading schema resource 

========================= camel sample_4368 =========================

public CommitConsumer(GitHubEndpoint endpoint, Processor processor, String branchName) throws Exception {	super(endpoint, processor);	Registry registry = endpoint.getCamelContext().getRegistry();	Object service = registry.lookupByName(GitHubConstants.GITHUB_COMMIT_SERVICE);	if (service != null) {	
using commitservice found in registry 

public CommitConsumer(GitHubEndpoint endpoint, Processor processor, String branchName) throws Exception {	super(endpoint, processor);	Registry registry = endpoint.getCamelContext().getRegistry();	Object service = registry.lookupByName(GitHubConstants.GITHUB_COMMIT_SERVICE);	if (service != null) {	commitService = (CommitService) service;	} else {	commitService = new CommitService();	}	initService(commitService);	
github commitconsumer indexing current commits 

========================= camel sample_14269 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<TwitterComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.twitter.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.twitter.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_774 =========================

private void clearCachedSchema() throws Exception {	Collection<Endpoint> endpoints = context.getEndpoints();	for (Endpoint endpoint : endpoints) {	
endpoint uri 

private void clearCachedSchema() throws Exception {	Collection<Endpoint> endpoints = context.getEndpoints();	for (Endpoint endpoint : endpoints) {	if (endpoint.getEndpointUri().startsWith("validator:")) {	ValidatorEndpoint xsltEndpoint = (ValidatorEndpoint)endpoint;	xsltEndpoint.clearCachedSchema();	
schema cache cleared 

========================= camel sample_2896 =========================

protected void assertMessageReceived(MockEndpoint masterEndpoint, MockEndpoint standbyEndpoint) throws InterruptedException {	masterEndpoint.reset();	standbyEndpoint.reset();	String expectedBody = createNextExpectedBody();	masterEndpoint.expectedBodiesReceived(expectedBody);	standbyEndpoint.expectedMessageCount(0);	template.sendBody("direct:start", expectedBody);	
expecting master and standby 

========================= camel sample_9673 =========================

public int processBatch(Queue<Object> exchanges) throws Exception {	int total = exchanges.size();	if (maxMessagesPerPoll > 0 && total > maxMessagesPerPoll) {	
limiting to maximum messages to poll as there were messages in this poll 

int total = exchanges.size();	if (maxMessagesPerPoll > 0 && total > maxMessagesPerPoll) {	total = maxMessagesPerPoll;	}	for (int index = 0; index < total && isBatchAllowed(); index++) {	Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());	exchange.setProperty(Exchange.BATCH_INDEX, index);	exchange.setProperty(Exchange.BATCH_SIZE, total);	exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);	pendingExchanges = total - index - 1;	
processing exchange 

========================= camel sample_14510 =========================

partitionDecorator = tmpPartitionDecorator;	suffix = tmpSuffix;	tableId = tmpTableId;	}	processGroup.add(ex);	}	if (!processGroup.isEmpty()) {	totalProcessed += process(tableId, partitionDecorator, suffix, processGroup, exchange.getExchangeId());	}	if (totalProcessed == 0) {	
the incoming message is either null or empty for exchange 

if (apiRequestRows.isEmpty()) {	return 0;	}	GoogleBigQueryEndpoint endpoint = getEndpoint();	TableDataInsertAllRequest apiRequestData = new TableDataInsertAllRequest().setRows(apiRequestRows);	Bigquery.Tabledata.InsertAll apiRequest = bigquery .tabledata() .insertAll(configuration.getProjectId(), configuration.getDatasetId(), tableIdWithPartition, apiRequestData);	if (suffix != null) {	apiRequest.set("template_suffix", suffix);	}	if (log.isTraceEnabled()) {	
sending messages to bigquery table suffix partition 

if (suffix != null) {	apiRequest.set("template_suffix", suffix);	}	if (log.isTraceEnabled()) {	}	TableDataInsertAllResponse apiResponse = apiRequest.execute();	if (apiResponse.getInsertErrors() != null && !apiResponse.getInsertErrors().isEmpty()) {	throw new Exception("InsertAll into " + tableId + " failed: " + apiResponse.getInsertErrors());	}	if (log.isTraceEnabled()) {	
sent messages to bigquery table suffix partition 

}	if (log.isTraceEnabled()) {	}	TableDataInsertAllResponse apiResponse = apiRequest.execute();	if (apiResponse.getInsertErrors() != null && !apiResponse.getInsertErrors().isEmpty()) {	throw new Exception("InsertAll into " + tableId + " failed: " + apiResponse.getInsertErrors());	}	if (log.isTraceEnabled()) {	}	if (log.isDebugEnabled()) {	
uploader thread id api call completed 

========================= camel sample_9366 =========================

while (retries > 0 && !deleted) {	retries--;	if (operations.deleteFile(file.getAbsoluteFilePath())) {	deleted = true;	break;	}	boolean exits = operations.existsFile(file.getAbsoluteFilePath());	if (!exits) {	deleted = true;	} else {	
file was not deleted at this attempt will try again in sec 

========================= camel sample_4807 =========================

if (index != -1) {	path = uri.substring(index + 1);	index = path.indexOf('?');	if (index != -1) {	path = path.substring(0, index);	}	path = path.replaceAll(":", "");	try {	path = URLDecoder.decode(path, "UTF-8");	} catch (UnsupportedEncodingException e) {	
failed to decode url path ignoring exception 

========================= camel sample_10416 =========================

ServerConnector connector;	server = createServer();	if ("cometds".equals(endpoint.getProtocol())) {	connector = getSslSocketConnector(server);	} else {	connector = new ServerConnector(server);	}	connector.setPort(endpoint.getPort());	connector.setHost(endpoint.getUri().getHost());	if ("localhost".equalsIgnoreCase(endpoint.getUri().getHost())) {	
you use localhost interface it means that no external connections will be available don t you want to use instead all network interfaces 

protected CometDServlet createServletForConnector(Server server, Connector connector, CometdEndpoint endpoint) throws Exception {	CometDServlet servlet = new CometDServlet();	ServletContextHandler context = new ServletContextHandler(server, "/", ServletContextHandler.NO_SECURITY | ServletContextHandler.NO_SESSIONS);	ServletHolder holder = new ServletHolder();	holder.setServlet(servlet);	holder.setAsyncSupported(true);	if (endpoint.getBaseResource() != null) {	String[] resources = endpoint.getBaseResource().split(":");	if (LOG.isDebugEnabled()) {	
protocol found and resource 

========================= camel sample_12581 =========================

public void onSubscriptionTransferFailed(final UaSubscription subscription, final StatusCode statusCode) {	
transfer failed 

public void onStatusChanged(final UaSubscription subscription, final StatusCode status) {	
subscription status changed 

private CompletableFuture<UShort> lookupNamespaceIndex(final String namespaceUri) {	
looking up namespace 

private CompletableFuture<UShort> lookupNamespaceIndex(final String namespaceUri) {	{	final UShort result = this.namespaceCache.get(namespaceUri);	if (result != null) {	
found namespace in cache 

private CompletableFuture<UShort> lookupNamespaceIndex(final String namespaceUri) {	{	final UShort result = this.namespaceCache.get(namespaceUri);	if (result != null) {	return CompletableFuture.completedFuture(result);	}	}	
looking up namespace on server 

public CompletableFuture<StatusCode> write(final NamespaceId namespaceId, final PartialNodeId partialNodeId, final DataValue value) {	final CompletableFuture<UShort> future;	
namespace 

public CompletableFuture<StatusCode> write(final NamespaceId namespaceId, final PartialNodeId partialNodeId, final DataValue value) {	final CompletableFuture<UShort> future;	if (namespaceId.isNumeric()) {	
using provided index 

public CompletableFuture<StatusCode> write(final NamespaceId namespaceId, final PartialNodeId partialNodeId, final DataValue value) {	final CompletableFuture<UShort> future;	if (namespaceId.isNumeric()) {	future = CompletableFuture.completedFuture(namespaceId.getNumeric());	} else {	
looking up namespace 

public CompletableFuture<StatusCode> write(final NamespaceId namespaceId, final PartialNodeId partialNodeId, final DataValue value) {	final CompletableFuture<UShort> future;	if (namespaceId.isNumeric()) {	future = CompletableFuture.completedFuture(namespaceId.getNumeric());	} else {	future = lookupNamespaceIndex(namespaceId.getUri());	}	return future.thenCompose(index -> {	final NodeId nodeId = partialNodeId.toNodeId(index);	
node partial full 

future = CompletableFuture.completedFuture(namespaceId.getNumeric());	} else {	future = lookupNamespaceIndex(namespaceId.getUri());	}	return future.thenCompose(index -> {	final NodeId nodeId = partialNodeId.toNodeId(index);	return this.client.writeValue(nodeId, value).whenComplete((status, error) -> {	if (status != null) {	LOG.debug("Write to ns={}/{}, id={} = {} -> {}", namespaceId, index, nodeId, value, status);	} else {	
failed to write 

private synchronized void handleConnectionFailue(final Throwable e) {	if (this.connected != null) {	this.connected.dispose();	this.connected = null;	}	
connection failed 

private void connect() {	
starting connect 

private void performAndEvalConnect() {	try {	final Connected connected = performConnect();	
connect call done 

private void performAndEvalConnect() {	try {	final Connected connected = performConnect();	synchronized (this) {	if (this.disposed) {	return;	}	try {	
setting subscriptions 

private void performAndEvalConnect() {	try {	final Connected connected = performConnect();	synchronized (this) {	if (this.disposed) {	return;	}	try {	connected.putSubscriptions(this.subscriptions);	
update state 

final Connected connected = performConnect();	synchronized (this) {	if (this.disposed) {	return;	}	try {	connected.putSubscriptions(this.subscriptions);	final Connected oldConnected = this.connected;	this.connected = connected;	if (oldConnected != null) {	
dispose old state 

return;	}	try {	connected.putSubscriptions(this.subscriptions);	final Connected oldConnected = this.connected;	this.connected = connected;	if (oldConnected != null) {	oldConnected.dispose();	}	} catch (final Exception e) {	
failed to set subscriptions 

this.connected = connected;	if (oldConnected != null) {	oldConnected.dispose();	}	} catch (final Exception e) {	connected.dispose();	throw e;	}	}	} catch (final Exception e) {	
failed to connect 

private Connected performConnect() throws Exception {	final EndpointDescription endpoint = UaTcpStackClient.getEndpoints(this.configuration.getEndpointUri()).thenApply(endpoints -> {	if (LOG.isDebugEnabled()) {	
found enpoints 

private Connected performConnect() throws Exception {	final EndpointDescription endpoint = UaTcpStackClient.getEndpoints(this.configuration.getEndpointUri()).thenApply(endpoints -> {	if (LOG.isDebugEnabled()) {	for (final EndpointDescription ep : endpoints) {	
t 

private Connected performConnect() throws Exception {	final EndpointDescription endpoint = UaTcpStackClient.getEndpoints(this.configuration.getEndpointUri()).thenApply(endpoints -> {	if (LOG.isDebugEnabled()) {	for (final EndpointDescription ep : endpoints) {	}	}	return findEndpoint(endpoints);	}).get();	
selected endpoint 

}	}	return findEndpoint(endpoints);	}).get();	final URI uri = URI.create(this.configuration.getEndpointUri());	final List<IdentityProvider> providers = new LinkedList<>();	final String user = uri.getUserInfo();	if (user != null && !user.isEmpty()) {	final String[] creds = user.split(":", 2);	if (creds != null && creds.length == 2) {	
enable username password provider 

private synchronized void triggerReconnect(final boolean immediate) {	
trigger re connect immediate 

private synchronized void triggerReconnect(final boolean immediate) {	if (this.reconnectJob != null) {	
re connect already scheduled 

handleConnectionFailue(e);	}	return null;	}, this.executor);	}	}	if (await && future != null) {	try {	future.get();	} catch (InterruptedException | ExecutionException e) {	
failed to wait for completion 

========================= camel sample_17279 =========================

public void execute(Exchange exchange) throws SmppException {	QuerySm querySm = createQuerySm(exchange);	if (log.isDebugEnabled()) {	
querying for a short message for exchange id and message id 

QuerySm querySm = createQuerySm(exchange);	if (log.isDebugEnabled()) {	}	QuerySmResult querySmResult;	try {	querySmResult = session.queryShortMessage( querySm.getMessageId(), TypeOfNumber.valueOf(querySm.getSourceAddrTon()), NumberingPlanIndicator.valueOf(querySm.getSourceAddrNpi()), querySm.getSourceAddr());	} catch (Exception e) {	throw new SmppException(e);	}	if (log.isDebugEnabled()) {	
query for a short message for exchange id and message id 

========================= camel sample_16891 =========================

public void beforeJob(JobExecution jobExecution) {	
sending before job execution event 

public void beforeJob(JobExecution jobExecution) {	producerTemplate.sendBodyAndHeader(endpointUri, jobExecution, EventType.HEADER_KEY, EventType.BEFORE.name());	
sent before job execution event 

public void afterJob(JobExecution jobExecution) {	
sending after job execution event 

public void afterJob(JobExecution jobExecution) {	producerTemplate.sendBodyAndHeader(endpointUri, jobExecution, EventType.HEADER_KEY, EventType.AFTER.name());	
sent after job execution event 

========================= camel sample_12755 =========================

context.setName("context-" + address.port());	context.addService(service);	context.addRoutes(new RouteBuilder() {	public void configure() throws Exception {	from("timer:atomix?delay=1s&period=1s") .routeId("route-" + address.port()) .routePolicy(ClusteredRoutePolicy.forNamespace("my-ns")) .log("From ${routeId}") .process(e -> contextLatch.countDown());	}	});	Thread.sleep(ThreadLocalRandom.current().nextInt(500));	context.start();	contextLatch.await();	
shutting down node 

========================= camel sample_10292 =========================

public void testAddGroupMembership() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.groupId", testGroup.getID());	headers.put("CamelBox.userId", testUser.getID());	headers.put("CamelBox.role", null);	final com.box.sdk.BoxGroupMembership result = requestBodyAndHeaders("direct: headers);	assertNotNull("addGroupMembership result", result);	
addgroupmembership 

public void testCreateGroup() throws Exception {	com.box.sdk.BoxGroup result = null;	try {	result = requestBody("direct: assertNotNull("createGroup result", result);	assertEquals(CAMEL_TEST_CREATE_GROUP_NAME, result.getInfo().getName());	
creategroup 

public void testDeleteGroup() throws Exception {	requestBody("direct: testGroup = null;	Iterable<BoxGroup.Info> it = BoxGroup.getAllGroups(getConnection());	int searchResults = sizeOfIterable(it);	boolean exists = searchResults > 0 ? true : false;	assertEquals("deleteGroup exists", false, exists);	
deletegroup exists 

public void testGetAllGroups() throws Exception {	assertNotNull("getAllGroups result", result);	
getallgroups 

public void testGetGroupInfo() throws Exception {	final com.box.sdk.BoxGroup.Info result = requestBody("direct: assertNotNull("getGroupInfo result", result);	
getgroupinfo 

public void testUpdateGroupInfo() throws Exception {	BoxGroup.Info info = testGroup.getInfo();	info.setDescription(CAMEL_TEST_GROUP_DESCRIPTION);	try {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.groupId", testGroup.getID());	headers.put("CamelBox.groupInfo", info);	final com.box.sdk.BoxGroup result = requestBodyAndHeaders("direct: assertNotNull("updateGroupInfo result", result);	
updategroupinfo 

public void testGetGroupMembershipInfo() throws Exception {	BoxGroupMembership.Info info = testGroup.addMembership(testUser, BoxGroupMembership.Role.MEMBER);	final com.box.sdk.BoxGroupMembership.Info result = requestBody("direct: assertNotNull("getGroupMembershipInfo result", result);	
getgroupmembershipinfo 

public void testGetGroupMemberships() throws Exception {	assertNotNull("getGroupMemberships result", result);	
getgroupmemberships 

public void testUpdateGroupMembershipInfo() throws Exception {	BoxGroupMembership.Info info = testGroup.addMembership(testUser, BoxGroupMembership.Role.MEMBER);	info.setRole(BoxGroupMembership.Role.ADMIN);	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.groupMemebershipId", info.getID());	headers.put("CamelBox.info", info);	final com.box.sdk.BoxGroupMembership result = requestBodyAndHeaders("direct: headers);	assertNotNull("updateGroupMembershipInfo result", result);	
updategroupmembershipinfo 

========================= camel sample_17412 =========================

exchange.setException(new RuntimeCamelException("OData HTTP Request cancelled!"));	callback.done(false);	}	});	final ApiMethod method = findMethod(exchange, properties);	if (method == null) {	callback.done(true);	return true;	}	if (LOG.isDebugEnabled()) {	
invoking operation with 

========================= camel sample_14547 =========================

public void testGet() throws Exception {	com.google.api.services.calendar.model.Colors result = requestBody("direct: assertNotNull("get result", result);	
get 

========================= camel sample_11745 =========================

public <K, V> Cache<K, V> getCache(String name, Class<K> keyType, Class<V> valueType) throws Exception {	Cache<K, V> cache = cacheManager.getCache(name, keyType, valueType);	if (cache == null && configuration != null && configuration.isCreateCacheIfNotExist()) {	CacheConfiguration<K, V> cacheConfiguration = null;	if (configuration.hasConfiguration(name)) {	
using custom cache configuration for cache 

public <K, V> Cache<K, V> getCache(String name, Class<K> keyType, Class<V> valueType) throws Exception {	Cache<K, V> cache = cacheManager.getCache(name, keyType, valueType);	if (cache == null && configuration != null && configuration.isCreateCacheIfNotExist()) {	CacheConfiguration<K, V> cacheConfiguration = null;	if (configuration.hasConfiguration(name)) {	cacheConfiguration = CacheConfiguration.class.cast(configuration.getConfigurations().get(name));	} else  if (configuration.hasConfiguration()) {	
using global cache configuration for cache 

if (cache == null && configuration != null && configuration.isCreateCacheIfNotExist()) {	CacheConfiguration<K, V> cacheConfiguration = null;	if (configuration.hasConfiguration(name)) {	cacheConfiguration = CacheConfiguration.class.cast(configuration.getConfigurations().get(name));	} else  if (configuration.hasConfiguration()) {	cacheConfiguration = CacheConfiguration.class.cast(configuration.getConfiguration());	}	if (cacheConfiguration != null) {	cache = cacheManager.createCache(name, cacheConfiguration);	} else {	
using a usermanagedcache for cache as no configuration has been found 

========================= camel sample_9624 =========================

protected void processEntity(Exchange exchange, ProcessInstance process) throws Exception {	
processing process instance 

========================= camel sample_12493 =========================

appMessageCount++;	if (0 != (appMessageCount % 2)) {	return;	}	InterceptorChain chain = message.getInterceptorChain();	ListIterator<Interceptor<? extends Message>> it = chain.getIterator();	while (it.hasNext()) {	PhaseInterceptor<?> pi = (PhaseInterceptor<?>)it.next();	if (MessageSenderInterceptor.class.getName().equals(pi.getId())) {	chain.remove(pi);	
removed messagesenderinterceptor from interceptor chain 

protected void onFirstWrite() throws IOException {	if (LOG.isDebugEnabled()) {	Long nr = RMContextUtils.retrieveRMProperties(outMessage, true).getSequence().getMessageNumber();	
losing message 

========================= camel sample_7790 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<HazelcastTopicComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-topic.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-topic.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_689 =========================

LOG.trace("OpenTracing: start client span=" + span);	}	sd.post(span, ese.getExchange(), ese.getEndpoint());	span.finish();	ActiveSpanManager.deactivate(ese.getExchange());	} else {	LOG.warn("OpenTracing: could not find managed span for exchange=" + ese.getExchange());	}	}	} catch (Throwable t) {	
opentracing failed to capture tracing data 

return;	}	SpanDecorator sd = getSpanDecorator(route.getEndpoint());	Span span = tracer.buildSpan(sd.getOperationName(exchange, route.getEndpoint())) .asChildOf(tracer.extract(Format.Builtin.TEXT_MAP, new CamelHeadersExtractAdapter(exchange.getIn().getHeaders()))) .withTag(Tags.SPAN_KIND.getKey(), sd.getReceiverSpanKind()) .start();	sd.pre(span, exchange, route.getEndpoint());	ActiveSpanManager.activate(exchange, span);	if (LOG.isTraceEnabled()) {	LOG.trace("OpenTracing: start server span=" + span);	}	} catch (Throwable t) {	
opentracing failed to capture tracing data 

LOG.trace("OpenTracing: finish server span=" + span);	}	SpanDecorator sd = getSpanDecorator(route.getEndpoint());	sd.post(span, exchange, route.getEndpoint());	span.finish();	ActiveSpanManager.deactivate(exchange);	} else {	LOG.warn("OpenTracing: could not find managed span for exchange=" + exchange);	}	} catch (Throwable t) {	
opentracing failed to capture tracing data 

========================= camel sample_10441 =========================

protected void setLeader(boolean isLeader) {	if (isLeader && leader.compareAndSet(false, isLeader)) {	
leadership taken 

protected void setLeader(boolean isLeader) {	if (isLeader && leader.compareAndSet(false, isLeader)) {	startAllStoppedConsumers();	} else {	if (!leader.getAndSet(isLeader) && isLeader) {	
leadership lost 

private void stopConsumer(Route route) {	synchronized (lock) {	try {	if (!suspendedRoutes.contains(route)) {	
stopping consumer for 

private void startAllStoppedConsumers() {	synchronized (lock) {	try {	for (Route route : suspendedRoutes) {	
starting consumer for 

public void onComplete(ConsulResponse<Optional<Value>> consulResponse) {	if (isRunAllowed()) {	Optional<Value> value = consulResponse.getResponse();	if (value.isPresent()) {	Optional<String> sid = value.get().getSession();	if (sid.isPresent() && ObjectHelper.isNotEmpty(sid.get())) {	
try to take leadership 

========================= camel sample_14402 =========================

public synchronized void addSynchronization(Synchronization synchronization) {	if (synchronizations == null) {	synchronizations = new ArrayList<Synchronization>();	}	
adding synchronization 

}	Iterator<Synchronization> it = synchronizations.iterator();	while (it.hasNext()) {	Synchronization synchronization = it.next();	boolean handover = true;	if (synchronization instanceof SynchronizationVetoable) {	SynchronizationVetoable veto = (SynchronizationVetoable) synchronization;	handover = veto.allowHandover();	}	if (handover && (filter == null || filter.test(synchronization))) {	
handover synchronization to 

Synchronization synchronization = it.next();	boolean handover = true;	if (synchronization instanceof SynchronizationVetoable) {	SynchronizationVetoable veto = (SynchronizationVetoable) synchronization;	handover = veto.allowHandover();	}	if (handover && (filter == null || filter.test(synchronization))) {	target.addOnCompletion(synchronization);	it.remove();	} else {	
handover not allow for synchronization 

public void done(Exchange exchange) {	
unitofwork done for exchangeid with 

public void done(Exchange exchange) {	boolean failed = exchange.isFailed();	UnitOfWorkHelper.doneSynchronizations(exchange, synchronizations, log);	try {	SubUnitOfWorkCallback uowCallback = getSubUnitOfWorkCallback();	if (uowCallback != null) {	uowCallback.onDone(exchange);	}	} catch (Throwable e) {	
exception occurred during savepoint ondone this exception will be ignored 

if (exchange.getContext() != null) {	exchange.getContext().getInflightRepository().remove(exchange);	}	try {	if (failed) {	EventHelper.notifyExchangeFailed(exchange.getContext(), exchange);	} else {	EventHelper.notifyExchangeDone(exchange.getContext(), exchange);	}	} catch (Throwable e) {	
exception occurred during event notification this exception will be ignored 

public void beforeRoute(Exchange exchange, Route route) {	if (log.isTraceEnabled()) {	
unitofwork beforeroute for exchangeid with 

public void afterRoute(Exchange exchange, Route route) {	if (log.isTraceEnabled()) {	
unitofwork afterroute for exchangeid with 

public void beginSubUnitOfWork(Exchange exchange) {	if (log.isTraceEnabled()) {	
beginsubunitofwork exchangeid 

public void endSubUnitOfWork(Exchange exchange) {	if (log.isTraceEnabled()) {	
endsubunitofwork exchangeid 

========================= camel sample_4153 =========================

public void testCreateRouteFromCamelContext() throws Exception {	List<RouteDefinition> list = context.getRouteDefinitions();	assertEquals("Size of list " + list, 1, list.size());	RouteDefinition routeType = list.get(0);	
found route 

protected void dump(Object object) throws Exception {	JAXBContext jaxbContext = XmlTestSupport.createJaxbContext();	Marshaller marshaller = jaxbContext.createMarshaller();	marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);	StringWriter buffer = new StringWriter();	marshaller.marshal(object, buffer);	
created 

========================= camel sample_3696 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<QuartzComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.quartz2.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.quartz2.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1146 =========================

protected void doStart() throws Exception {	super.doStart();	
netty consumer binding to 

nettyServerBootstrapFactory = new ClientModeTCPNettyServerBootstrapFactory();	} else {	nettyServerBootstrapFactory = new SingleTCPNettyServerBootstrapFactory();	}	} else {	nettyServerBootstrapFactory = new SingleUDPNettyServerBootstrapFactory();	}	nettyServerBootstrapFactory.init(context, configuration, pipelineFactory);	}	ServiceHelper.startServices(nettyServerBootstrapFactory);	
netty consumer bound to 

protected void doStop() throws Exception {	
netty consumer unbinding from 

protected void doStop() throws Exception {	ServiceHelper.stopService(nettyServerBootstrapFactory);	
netty consumer unbound from 

========================= camel sample_6683 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<RestComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.rest.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.rest.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_888 =========================

private Message getNextElement() {	if (zipInputStream == null) {	return null;	}	try {	ZipEntry current = getNextEntry();	if (current != null) {	
read zipentry 

try {	ZipEntry current = getNextEntry();	if (current != null) {	Message answer = new DefaultMessage(exchange.getContext());	answer.getHeaders().putAll(exchange.getIn().getHeaders());	answer.setHeader("zipFileName", current.getName());	answer.setHeader(Exchange.FILE_NAME, current.getName());	answer.setBody(new ZipInputStreamWrapper(zipInputStream));	return answer;	} else {	
close zipinputstream 

========================= camel sample_17486 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KubernetesResourcesQuotaComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-resources-quota.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-resources-quota.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_534 =========================

result.setHost(host);	}	if (sslcf != null) {	if (getSslSocketConnectorProperties() != null && "https".equals(endpoint.getProtocol())) {	Map<String, Object> properties = new HashMap<String, Object>(getSslSocketConnectorProperties());	IntrospectionSupport.setProperties(sslcf, properties);	if (properties.size() > 0) {	throw new IllegalArgumentException("There are " + properties.size() + " parameters that couldn't be set on the SocketConnector." + " Check the uri if the parameters are spelt correctly and that they are properties of the SelectChannelConnector." + " Unknown parameters=[" + properties + "]");	}	}	
connector on port is using includeciphersuites excludeciphersuites includeprotocols excludeprotocols 

========================= camel sample_11102 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SedaComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.seda.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.seda.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_867 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<GoogleCalendarComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.google-calendar.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.google-calendar.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1003 =========================

}	if (nameStyle == null) {	nameStyle = FacebookNameStyle.SEARCH;	} else if (candidates.size() > nGetMethods) {	nameStyle = FacebookNameStyle.GET_AND_SEARCH;	}	}	if (LOG.isDebugEnabled()) {	final Set<String> missing = getMissingProperties(method, nameStyle, arguments);	if (!missing.isEmpty()) {	
method could use one or more properties from 

========================= camel sample_9599 =========================

public void run() {	jmsConsumerExecutors = getEndpoint().getCamelContext().getExecutorServiceManager().newFixedThreadPool(this, "SjmsBatchConsumer", consumerCount);	consumersShutdownLatchRef.set(new CountDownLatch(consumerCount));	if (completionInterval > 0) {	
using completioninterval to run every millis 

if (completionInterval > 0) {	if (timeoutCheckerExecutorService == null) {	setTimeoutCheckerExecutorService(getEndpoint().getCamelContext().getExecutorServiceManager().newScheduledThreadPool(this, SJMS_BATCH_TIMEOUT_CHECKER, 1));	shutdownTimeoutCheckerExecutorService = true;	}	}	while (isRunAllowed() && !running.get()) {	Connection localConnection = null;	try {	attempt++;	
attempt starting consumer s for 

for (int i = 0; i < consumerCount; i++) {	BatchConsumptionLoop loop = new BatchConsumptionLoop();	loop.setKeepAliveDelay(keepAliveDelay);	triggers.add(loop.getCompletionTimeoutTrigger());	jmsConsumerExecutors.submit(loop);	}	if (completionInterval > 0) {	timeoutCheckerExecutorService.scheduleAtFixedRate(new CompletionIntervalTask(triggers), completionInterval, completionInterval, TimeUnit.MILLISECONDS);	}	if (attempt > 1) {	
successfully refreshed connection after attempts 

BatchConsumptionLoop loop = new BatchConsumptionLoop();	loop.setKeepAliveDelay(keepAliveDelay);	triggers.add(loop.getCompletionTimeoutTrigger());	jmsConsumerExecutors.submit(loop);	}	if (completionInterval > 0) {	timeoutCheckerExecutorService.scheduleAtFixedRate(new CompletionIntervalTask(triggers), completionInterval, completionInterval, TimeUnit.MILLISECONDS);	}	if (attempt > 1) {	}	
started consumer s for 

}	} catch (Throwable t) {	}	if (recoveryEnabled) {	getExceptionHandler().handleException("Error starting consumer after " + attempt + " attempts. Will try again in " + recoveryInterval + " millis.", e);	} else {	throw ObjectHelper.wrapRuntimeCamelException(e);	}	}	try {	
attempt sleeping before next attempt to recover 

protected void doStop() throws Exception {	super.doStop();	running.set(false);	CountDownLatch consumersShutdownLatch = consumersShutdownLatchRef.get();	if (consumersShutdownLatch != null) {	
stop signalled waiting on consumers to shut down 

protected void doStop() throws Exception {	super.doStop();	running.set(false);	CountDownLatch consumersShutdownLatch = consumersShutdownLatchRef.get();	if (consumersShutdownLatch != null) {	if (consumersShutdownLatch.await(60, TimeUnit.SECONDS)) {	
timeout waiting on consumer threads to signal completion shutting down 

protected void doStop() throws Exception {	super.doStop();	running.set(false);	CountDownLatch consumersShutdownLatch = consumersShutdownLatchRef.get();	if (consumersShutdownLatch != null) {	if (consumersShutdownLatch.await(60, TimeUnit.SECONDS)) {	} else {	
all consumers have been shutdown 

protected void doStop() throws Exception {	super.doStop();	running.set(false);	CountDownLatch consumersShutdownLatch = consumersShutdownLatchRef.get();	if (consumersShutdownLatch != null) {	if (consumersShutdownLatch.await(60, TimeUnit.SECONDS)) {	} else {	}	} else {	
stop signalled while there are no consumers yet so no need to wait for consumers 

super.doStop();	running.set(false);	CountDownLatch consumersShutdownLatch = consumersShutdownLatchRef.get();	if (consumersShutdownLatch != null) {	if (consumersShutdownLatch.await(60, TimeUnit.SECONDS)) {	} else {	}	} else {	}	try {	
shutting down jms connection 

public void run() {	if (!getEndpoint().getCamelContext().getStatus().isStarted()) {	
completion interval task cannot start due camelcontext has not been started yet 

private void closeJmsConsumer(MessageConsumer consumer) {	try {	consumer.close();	} catch (JMSException ex2) {	if (log.isDebugEnabled()) {	
exception caught closing consumer 

private void closeJmsConsumer(MessageConsumer consumer) {	try {	consumer.close();	} catch (JMSException ex2) {	if (log.isDebugEnabled()) {	}	
exception caught closing consumer this exception is ignored 

private void closeJmsSession(Session session) {	try {	session.close();	} catch (JMSException ex2) {	if (log.isDebugEnabled()) {	
exception caught closing session 

private void closeJmsSession(Session session) {	try {	session.close();	} catch (JMSException ex2) {	if (log.isDebugEnabled()) {	}	
exception caught closing session this exception is ignored 

private void consumeBatchesOnLoop(final Session session, final MessageConsumer consumer) throws JMSException {	final boolean usingTimeout = completionTimeout > 0;	
batchconsumptiontask start 

private void consumeBatchesOnLoop(final Session session, final MessageConsumer consumer) throws JMSException {	final boolean usingTimeout = completionTimeout > 0;	while (running.get()) {	
batchconsumptiontask running 

private void consumeBatchesOnLoop(final Session session, final MessageConsumer consumer) throws JMSException {	final boolean usingTimeout = completionTimeout > 0;	while (running.get()) {	if (timeout.compareAndSet(true, false) || timeoutInterval.compareAndSet(true, false)) {	
completion batch due timeout 

private void consumeBatchesOnLoop(final Session session, final MessageConsumer consumer) throws JMSException {	final boolean usingTimeout = completionTimeout > 0;	while (running.get()) {	if (timeout.compareAndSet(true, false) || timeoutInterval.compareAndSet(true, false)) {	completionBatch(session);	reset();	continue;	}	if (completionSize > 0 && messageCount >= completionSize) {	
completion batch due size 

}	if (completionSize > 0 && messageCount >= completionSize) {	completionBatch(session);	reset();	continue;	}	long waitTime = (usingTimeout && (timeElapsed > 0)) ? getReceiveWaitTime(timeElapsed) : pollDuration;	Message message = consumer.receive(waitTime);	if (running.get()) {	if (message == null) {	
no message received 

completionBatch(session);	reset();	continue;	}	long waitTime = (usingTimeout && (timeElapsed > 0)) ? getReceiveWaitTime(timeElapsed) : pollDuration;	Message message = consumer.receive(waitTime);	if (running.get()) {	if (message == null) {	} else {	messageCount++;	
messages received 

aggregatedExchange.setProperty(Exchange.BATCH_SIZE, messageCount);	if (completionPredicate != null) {	try {	boolean complete;	if (eagerCheckCompletion) {	complete = completionPredicate.matches(exchange);	} else {	complete = completionPredicate.matches(aggregatedExchange);	}	if (complete) {	
completion batch due predicate 

if (eagerCheckCompletion) {	complete = completionPredicate.matches(exchange);	} else {	complete = completionPredicate.matches(aggregatedExchange);	}	if (complete) {	completionBatch(session);	reset();	}	} catch (Exception e) {	
error during evaluation of completion predicate this exception is ignored 

} catch (Exception e) {	}	}	}	if (usingTimeout && startTime > 0) {	long currentTime = new Date().getTime();	timeElapsed = currentTime - startTime;	if (timeElapsed > completionTimeout) {	timeout.set(true);	} else {	
this batch has more time until the timeout elapsed timeout 

}	if (usingTimeout && startTime > 0) {	long currentTime = new Date().getTime();	timeElapsed = currentTime - startTime;	if (timeElapsed > completionTimeout) {	timeout.set(true);	} else {	}	}	} else {	
shutdown signal received rolling back batch 

timeElapsed = currentTime - startTime;	if (timeElapsed > completionTimeout) {	timeout.set(true);	} else {	}	}	} else {	session.rollback();	}	}	
batchconsumptiontask end 

private long getReceiveWaitTime(long timeElapsed) {	long timeRemaining = getTimeRemaining(timeElapsed);	if (timeRemaining <= 0) {	timeRemaining = 1;	}	final long waitTime = Math.min(timeRemaining, pollDuration);	
waiting for 

private long getTimeRemaining(long timeElapsed) {	long timeRemaining = completionTimeout - timeElapsed;	if (LOG.isDebugEnabled() && timeElapsed > 0) {	
time remaining this batch 

private void processEmptyMessage() {	Exchange exchange = getEndpoint().createExchange();	
sending empty message as there were no messages from polling 

========================= camel sample_12407 =========================

public void onAcceptAlertNotification(AlertNotification alertNotification) {	
received an alertnotification 

public void onAcceptDeliverSm(DeliverSm deliverSm) throws ProcessRequestException {	
received a deliversm 

public DataSmResult onAcceptDataSm(DataSm dataSm, Session session) throws ProcessRequestException {	
received a datasm 

========================= camel sample_16917 =========================

protected int poll() throws Exception {	shutdownRunningTask = null;	pendingExchanges = 0;	MyBatisEndpoint endpoint = getEndpoint();	
polling 

public int processBatch(Queue<Object> exchanges) throws Exception {	final MyBatisEndpoint endpoint = getEndpoint();	int total = exchanges.size();	if (maxMessagesPerPoll > 0 && total > maxMessagesPerPoll) {	
limiting to maximum messages to poll as there were messages in this poll 

total = maxMessagesPerPoll;	}	for (int index = 0; index < total && isBatchAllowed(); index++) {	DataHolder holder = ObjectHelper.cast(DataHolder.class, exchanges.poll());	Exchange exchange = holder.exchange;	Object data = holder.data;	exchange.setProperty(Exchange.BATCH_INDEX, index);	exchange.setProperty(Exchange.BATCH_SIZE, total);	exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);	pendingExchanges = total - index - 1;	
processing exchange with properties 

========================= camel sample_12954 =========================

protected void doStart() throws Exception {	if (producerCache == null) {	producerCache = new ProducerCache(this, camelContext, new HashMap<String, Producer>(1));	}	ServiceHelper.startService(producerCache);	Endpoint lookup = camelContext.hasEndpoint(destination.getEndpointKey());	if (lookup instanceof InterceptSendToEndpoint) {	if (LOG.isDebugEnabled()) {	
intercepted sending to 

========================= camel sample_4578 =========================

private List<SplunkEvent> savedSearch(SplunkResultProcessor callback) throws Exception {	
saved search start 

private List<SplunkEvent> nonBlockingSearch(SplunkResultProcessor callback) throws Exception {	
non block search start 

private List<SplunkEvent> realtimeSearch(SplunkResultProcessor callback) throws Exception {	
realtime search start 

private List<SplunkEvent> runQuery(JobArgs queryArgs, boolean realtime, SplunkResultProcessor callback) throws Exception {	Service service = endpoint.getService();	Job job = service.getJobs().create(getSearch(), queryArgs);	
running search with queryargs 

========================= camel sample_14479 =========================

private List<String> assertCompletion(MBeanServer mbeanServer, ObjectName on, String componentName, Map<String, Object> properties, String completionText) throws Exception {	Object[] params = {componentName, properties, completionText};	String[] signature = {"java.lang.String",  "java.util.Map",  "java.lang.String"};	List<?> completions = assertIsInstanceOf(List.class, mbeanServer.invoke(on, "completeEndpointPath", params, signature));	
component with returned 

private String assertParameterJsonSchema(MBeanServer mbeanServer, ObjectName on, String componentName) throws Exception {	Object[] params = {componentName};	String[] signature = {"java.lang.String"};	String answer = assertIsInstanceOf(String.class, mbeanServer.invoke(on, "componentParameterJsonSchema", params, signature));	
component returned json 

private String assertParameterJsonSchema(MBeanServer mbeanServer, ObjectName on, String componentName) throws Exception {	Object[] params = {componentName};	String[] signature = {"java.lang.String"};	String answer = assertIsInstanceOf(String.class, mbeanServer.invoke(on, "componentParameterJsonSchema", params, signature));	ObjectMapper mapper = new ObjectMapper();	HashMap data = mapper.readValue(answer, HashMap.class);	
read json 

========================= camel sample_2855 =========================

protected synchronized void doWarmUp() throws Exception {	if (endpointDone.compareAndSet(false, true)) {	for (Route route : routes) {	ServiceHelper.startService(route.getEndpoint());	}	}	if (warmUpDone.compareAndSet(false, true)) {	for (Route route : routes) {	try (MDCHelper mdcHelper = new MDCHelper(route.getId())) {	route.warmUp();	
starting services on route 

protected void doStop() throws Exception {	boolean isShutdownCamelContext = camelContext.isStopping();	if (isShutdownCamelContext || isRemovingRoutes()) {	for (LifecycleStrategy strategy : camelContext.getLifecycleStrategies()) {	strategy.onRoutesRemove(routes);	}	}	for (Route route : routes) {	try (MDCHelper mdcHelper = new MDCHelper(route.getId())) {	
stopping services on route 

protected void doShutdown() throws Exception {	for (Route route : routes) {	try (MDCHelper mdcHelper = new MDCHelper(route.getId())) {	
shutting down services on route 

protected void startChildService(Route route, List<Service> services) throws Exception {	for (Service service : services) {	
starting child service on route 

protected void stopChildService(Route route, Set<Service> services, boolean shutdown) throws Exception {	for (Service service : services) {	
child service on route shutting down Stopping 

========================= camel sample_4082 =========================

AhcEndpoint endpoint = createAhcEndpoint(uri, this, null);	setEndpointHeaderFilterStrategy(endpoint);	endpoint.setClient(getClient());	endpoint.setClientConfig(getClientConfig());	endpoint.setBinding(getBinding());	endpoint.setSslContextParameters(ssl);	setProperties(endpoint, parameters);	if (IntrospectionSupport.hasProperties(parameters, CLIENT_CONFIG_PREFIX)) {	DefaultAsyncHttpClientConfig.Builder builder = endpoint.getClientConfig() == null ? new DefaultAsyncHttpClientConfig.Builder() : AhcComponent.cloneConfig(endpoint.getClientConfig());	if (endpoint.getClient() != null) {	
the user explicitly set an asynchttpclient instance on the component or endpoint but this endpoint uri contains client configuration parameters are you sure that this is what was intended the asynchttpclient will be used and the uri parameters will be ignored 

setEndpointHeaderFilterStrategy(endpoint);	endpoint.setClient(getClient());	endpoint.setClientConfig(getClientConfig());	endpoint.setBinding(getBinding());	endpoint.setSslContextParameters(ssl);	setProperties(endpoint, parameters);	if (IntrospectionSupport.hasProperties(parameters, CLIENT_CONFIG_PREFIX)) {	DefaultAsyncHttpClientConfig.Builder builder = endpoint.getClientConfig() == null ? new DefaultAsyncHttpClientConfig.Builder() : AhcComponent.cloneConfig(endpoint.getClientConfig());	if (endpoint.getClient() != null) {	} else if (endpoint.getClientConfig() != null) {	
the user explicitly set an asynchttpclientconfig instance on the component or endpoint but this endpoint uri contains client configuration parameters are you sure that this is what was intended the uri parameters will be applied to a clone of the supplied asynchttpclientconfig in order to prevent unintended modification of the explicitly configured asynchttpclientconfig that is the uri parameters override the settings on the explicitly configured asynchttpclientconfig for this endpoint 

========================= camel sample_16501 =========================

public void testEndpoint() throws Exception {	mockEndpoint.reset();	mockEndpoint.expectedBodiesReceived(expectedBody);	template.sendBodyAndHeader("https: mockEndpoint.assertIsSatisfied();	List<Exchange> list = mockEndpoint.getReceivedExchanges();	Exchange exchange = list.get(0);	Assert.assertNotNull("exchange", exchange);	Message in = exchange.getIn();	assertNotNull("in", in);	Map<String, Object> headers = in.getHeaders();	
headers 

========================= camel sample_10986 =========================

}	if (statistics.isStatisticsEnabled()) {	attemptCounter.increment();	}	Object result = optimisedTypeConverter.convertTo(type, exchange, value);	if (result != null) {	if (statistics.isStatisticsEnabled()) {	baseHitCounter.increment();	}	if (log.isTraceEnabled()) {	
using optimised core converter to convert 

if (log.isTraceEnabled()) {	}	return result;	}	TypeMapping key = new TypeMapping(type, value.getClass());	if (misses.containsKey(key)) {	return Void.TYPE;	}	TypeConverter converter = getOrFindTypeConverter(key);	if (converter != null) {	
using converter to convert 

}	if (rc == null && tc.allowNull()) {	return null;	}	if (Void.TYPE.equals(rc)) {	return Void.TYPE;	}	if (rc != null) {	if (fallback.isCanPromote()) {	if (log.isDebugEnabled()) {	
promoting fallback type converter as a known type converter to convert from to for the fallback converter 

if (Void.TYPE.equals(rc)) {	return Void.TYPE;	}	if (rc != null) {	if (fallback.isCanPromote()) {	if (log.isDebugEnabled()) {	}	addTypeConverter(type, value.getClass(), fallback.getFallbackTypeConverter());	}	if (log.isTraceEnabled()) {	
fallback type converter converted type from to 

public void addTypeConverter(Class<?> toType, Class<?> fromType, TypeConverter typeConverter) {	
adding type converter 

public void addTypeConverters(TypeConverters typeConverters) {	
adding type converters 

public boolean removeTypeConverter(Class<?> toType, Class<?> fromType) {	
removing type converter from to 

public void addFallbackTypeConverter(TypeConverter typeConverter, boolean canPromote) {	
adding fallback type converter which can promote 

private void addCoreFallbackTypeConverterToList(TypeConverter typeConverter, boolean canPromote, List<FallbackTypeConverter> converters) {	
adding core fallback type converter which can promote 

========================= camel sample_3985 =========================

public MllpTcpClientProducer(MllpEndpoint endpoint) throws SocketException {	super(endpoint);	
constructing mllptcpclientproducer for endpoint uri 

public void closeConnection() {	
close connection for address called via jmx 

public void resetConnection() {	
reset connection for address requested via jmx 

public synchronized void process(Exchange exchange) throws Exception {	
processing exchange 

Charset tmpCharset = getEndpoint().determineCharset(tmpHl7MessageBytes, null);	exchange.setProperty(Exchange.CHARSET_NAME, tmpCharset.name());	if (tmpCharset != null && tmpCharset != MllpProtocolConstants.DEFAULT_CHARSET) {	hl7MessageBytes = stringBody.getBytes(tmpCharset);	exchange.setProperty(Exchange.CHARSET_NAME, tmpCharset.name());	} else {	hl7MessageBytes = tmpHl7MessageBytes;	exchange.setProperty(Exchange.CHARSET_NAME, MllpProtocolConstants.DEFAULT_CHARSET.name());	}	}	
sending message to external system 

} else {	hl7MessageBytes = tmpHl7MessageBytes;	exchange.setProperty(Exchange.CHARSET_NAME, MllpProtocolConstants.DEFAULT_CHARSET.name());	}	}	getEndpoint().updateLastConnectionEstablishedTicks();	try {	mllpBuffer.setEnvelopedMessage(hl7MessageBytes);	mllpBuffer.writeTo(socket);	} catch (MllpSocketException writeEx) {	
exception encountered reading acknowledgement attempting reconnect 

exchange.setProperty(Exchange.CHARSET_NAME, MllpProtocolConstants.DEFAULT_CHARSET.name());	}	}	getEndpoint().updateLastConnectionEstablishedTicks();	try {	mllpBuffer.setEnvelopedMessage(hl7MessageBytes);	mllpBuffer.writeTo(socket);	} catch (MllpSocketException writeEx) {	try {	checkConnection();	
reconnected succeeded resending payload 

mllpBuffer.writeTo(socket);	} catch (MllpSocketException writeEx) {	try {	checkConnection();	try {	mllpBuffer.writeTo(socket);	} catch (MllpSocketException retryWriteEx) {	exchange.setException(retryWriteEx);	}	} catch (IOException reconnectEx) {	
reconnected failed sending exception to exchange 

try {	mllpBuffer.writeTo(socket);	} catch (MllpSocketException retryWriteEx) {	exchange.setException(retryWriteEx);	}	} catch (IOException reconnectEx) {	exchange.setException(reconnectEx);	}	}	if (exchange.getException() == null) {	
reading acknowledgement from external system 

}	} catch (IOException reconnectEx) {	exchange.setException(reconnectEx);	}	}	if (exchange.getException() == null) {	try {	mllpBuffer.reset();	mllpBuffer.readFrom(socket);	} catch (MllpSocketException receiveAckEx) {	
exception encountered reading acknowledgement attempting reconnect 

}	}	if (exchange.getException() == null) {	try {	mllpBuffer.reset();	mllpBuffer.readFrom(socket);	} catch (MllpSocketException receiveAckEx) {	try {	checkConnection();	} catch (IOException reconnectEx) {	
reconnected failed sending original exception to exchange 

try {	mllpBuffer.reset();	mllpBuffer.readFrom(socket);	} catch (MllpSocketException receiveAckEx) {	try {	checkConnection();	} catch (IOException reconnectEx) {	exchange.setException(new MllpAcknowledgementReceiveException("Exception encountered reading acknowledgement", hl7MessageBytes, receiveAckEx));	}	if (exchange.getException() == null) {	
reconnected succeeded resending payload 

exchange.setException(new MllpAcknowledgementReceiveException("Exception encountered reading acknowledgement", hl7MessageBytes, receiveAckEx));	}	if (exchange.getException() == null) {	try {	mllpBuffer.setEnvelopedMessage(hl7MessageBytes);	mllpBuffer.writeTo(socket);	} catch (MllpSocketException writeRetryEx) {	exchange.setException(new MllpWriteException("Failed to write HL7 message to socket", hl7MessageBytes, writeRetryEx));	}	if (exchange.getException() == null) {	
resend succeeded reading acknowledgement 

exchange.setException(new MllpAcknowledgementTimeoutException("Timeout receiving HL7 Acknowledgement", hl7MessageBytes, timeoutEx));	} else {	exchange.setException(new MllpAcknowledgementTimeoutException("Timeout receiving complete HL7 Acknowledgement", hl7MessageBytes, mllpBuffer.toByteArray(), timeoutEx));	mllpBuffer.reset();	}	mllpBuffer.resetSocket(socket);	}	if (exchange.getException() == null) {	if (mllpBuffer.hasCompleteEnvelope()) {	byte[] acknowledgementBytes = mllpBuffer.toMllpPayload();	
populating message headers with the acknowledgement from the external system 

} else {	message.setHeader(MllpConstants.MLLP_ACKNOWLEDGEMENT_STRING, "");	}	if (getConfiguration().isValidatePayload()) {	String exceptionMessage = Hl7Util.generateInvalidPayloadExceptionMessage(acknowledgementBytes);	if (exceptionMessage != null) {	exchange.setException(new MllpInvalidAcknowledgementException(exceptionMessage, hl7MessageBytes, acknowledgementBytes));	}	}	if (exchange.getException() == null) {	
processing the acknowledgement from the external system 

public synchronized void run() {	if (getConfiguration().hasIdleTimeout()) {	if (null != socket && !socket.isClosed() && socket.isConnected()) {	if (lastProcessCallTicks > 0) {	long idleTime = System.currentTimeMillis() - lastProcessCallTicks;	if (log.isDebugEnabled()) {	
checking for idle connection 

public synchronized void run() {	if (getConfiguration().hasIdleTimeout()) {	if (null != socket && !socket.isClosed() && socket.isConnected()) {	if (lastProcessCallTicks > 0) {	long idleTime = System.currentTimeMillis() - lastProcessCallTicks;	if (log.isDebugEnabled()) {	}	if (idleTime >= getConfiguration().getIdleTimeout()) {	
mllp connection idle time of milliseconds met or exceeded the idle producer timeout of milliseconds resetting conection 

if (lastProcessCallTicks > 0) {	long idleTime = System.currentTimeMillis() - lastProcessCallTicks;	if (log.isDebugEnabled()) {	}	if (idleTime >= getConfiguration().getIdleTimeout()) {	mllpBuffer.resetSocket(socket);	} else {	long minDelay = 100;	long delay = Long.min(Long.max(minDelay, getConfiguration().getIdleTimeout() - idleTime), getConfiguration().getIdleTimeout());	if (log.isDebugEnabled()) {	
scheduling idle producer connection check of in milliseconds 

if (idleTime >= getConfiguration().getIdleTimeout()) {	mllpBuffer.resetSocket(socket);	} else {	long minDelay = 100;	long delay = Long.min(Long.max(minDelay, getConfiguration().getIdleTimeout() - idleTime), getConfiguration().getIdleTimeout());	if (log.isDebugEnabled()) {	}	idleTimeoutExecutor.schedule(this, delay, TimeUnit.MILLISECONDS);	}	} else {	
scheduling idle producer connection check in milliseconds 

========================= camel sample_13884 =========================

public void testList() throws Exception {	File testFile = uploadTestFile();	String fileId = testFile.getId();	final com.google.api.services.drive.model.RevisionList result = requestBody("direct: assertNotNull("list result", result);	
list 

========================= camel sample_15403 =========================

interceptProperties(properties);	final ApiMethod method = findMethod(exchange, properties);	if (method == null) {	callback.done(true);	return true;	}	Runnable invocation = new Runnable() {	public void run() {	try {	if (log.isDebugEnabled()) {	
invoking operation with 

final List<ApiMethod> candidates = endpoint.getCandidates();	if (processInBody(exchange, properties)) {	final Set<String> argNames = properties.keySet();	final List<ApiMethod> filteredMethods = methodHelper.filterMethods( candidates, ApiMethodHelper.MatchType.SUPER_SET, argNames);	if (filteredMethods.isEmpty()) {	throw new RuntimeCamelException(String.format("Missing properties for %s, need one or more from %s", endpoint.getMethodName(), methodHelper.getMissingProperties(endpoint.getMethodName(), argNames)) );	} else if (filteredMethods.size() == 1) {	method = filteredMethods.get(0);	} else {	method = ApiMethodHelper.getHighestPriorityMethod(filteredMethods);	
calling highest priority operation from operations 

} catch (Exception e) {	exchange.setException(new RuntimeCamelException(String.format( "Error converting value %s to property %s: %s", value, inBodyProperty, e.getMessage()), e));	return false;	}	} else {	if (!methodHelper.getNullableArguments().contains(inBodyProperty)) {	exchange.setException(new NullPointerException(inBodyProperty));	return false;	}	}	
property has message body value 

========================= camel sample_4313 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<StringDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.string.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.string.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_830 =========================

public String getMessageSelector() {	String id = null;	if (fixedMessageSelector != null) {	id = fixedMessageSelector;	} else if (creator != null) {	id = creator.get();	}	
using messageselector 

========================= camel sample_7180 =========================

public void testSendingCamelExchangeToEndpointResultsInValidApplicationEventAfterTheRefreshEvent() throws Exception {	MockEndpoint result = resolveMandatoryEndpoint("mock:result", MockEndpoint.class);	result.expectedMessageCount(2);	template.sendBodyAndHeader(uri, expectedBody, "cheese", 123);	result.assertIsSatisfied();	Exchange exchange = result.getReceivedExchanges().get(0);	Object body = exchange.getIn().getBody(ContextRefreshedEvent.class);	
received body 

public void testSendingCamelExchangeToEndpointResultsInValidApplicationEventAfterTheRefreshEvent() throws Exception {	MockEndpoint result = resolveMandatoryEndpoint("mock:result", MockEndpoint.class);	result.expectedMessageCount(2);	template.sendBodyAndHeader(uri, expectedBody, "cheese", 123);	result.assertIsSatisfied();	Exchange exchange = result.getReceivedExchanges().get(0);	Object body = exchange.getIn().getBody(ContextRefreshedEvent.class);	assertNotNull(body);	exchange = result.getReceivedExchanges().get(1);	body = exchange.getIn().getBody();	
received body 

========================= camel sample_15546 =========================

private void process(final SynchronizedExchange synchronizedExchange) {	try {	Exchange exchange = synchronizedExchange.getExchange();	final boolean ignore = exchange.hasProperties() && exchange .getProperties().containsKey(DisruptorEndpoint.DISRUPTOR_IGNORE_EXCHANGE);	if (ignore) {	
ignoring exchange 

========================= camel sample_10744 =========================

public void tapSomething(String body) throws Exception {	try {	LATCH.await(5, TimeUnit.SECONDS);	Thread.sleep(100);	} catch (Exception e) {	fail("Should not be interrupted");	}	
wire tapping 

========================= camel sample_2382 =========================

try {	Field f = ProducerConfig.class.getDeclaredField("PARTITIONER_CLASS_CONFIG");	if (f != null) {	loadParitionerClass(resolver, props);	}	} catch (NoSuchFieldException e) {	} catch (SecurityException e) {	}	}	} catch (Throwable t) {	
problem loading classes for serializers 

========================= camel sample_16413 =========================

protected URLConnection openConnection(URL u) throws IOException {	if (getCounter() == 0) {	
resolved 

incrementCounter();	return new URLConnection(u) {	public void connect() throws IOException {	connected = true;	}	public InputStream getInputStream() throws IOException {	return new ByteArrayInputStream(xsd1);	}	};	} else {	
resolved 

========================= camel sample_3710 =========================

soTimeout = getConfiguration().getSoTimeout();	}	dataTimeout = getConfiguration().getTimeout();	if (getConfiguration().getActivePortRange() != null) {	String[] parts = getConfiguration().getActivePortRange().split("-");	if (parts.length != 2) {	throw new IllegalArgumentException("The option activePortRange should have syntax: min-max");	}	int min = getCamelContext().getTypeConverter().mandatoryConvertTo(int.class, parts[0]);	int max = getCamelContext().getTypeConverter().mandatoryConvertTo(int.class, parts[1]);	
using active port range 

if (ftpClientConfig == null) {	ftpClientConfig = new FTPClientConfig();	}	Map<String, Object> localConfigParameters = new HashMap<String, Object>(ftpClientConfigParameters);	setProperties(ftpClientConfig, localConfigParameters);	}	if (dataTimeout > 0) {	client.setDataTimeout(dataTimeout);	}	if (log.isDebugEnabled()) {	
created ftpclient connecttimeout sotimeout datatimeout buffersize receivedatasocketbuffersize senddatasocketbuffersize 

========================= camel sample_15395 =========================

protected void doGetConfigMap(Exchange exchange, String operation) throws Exception {	ConfigMap configMap = null;	String cfMapName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_CONFIGMAP_NAME, String.class);	if (ObjectHelper.isEmpty(cfMapName)) {	
get a specific configmap require specify a configmap name 

protected void doCreateConfigMap(Exchange exchange, String operation) throws Exception {	ConfigMap configMap = null;	String cfMapName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_CONFIGMAP_NAME, String.class);	String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	HashMap<String, String> configMapData = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_CONFIGMAP_DATA, HashMap.class);	if (ObjectHelper.isEmpty(cfMapName)) {	
create a specific configmap require specify a configmap name 

protected void doCreateConfigMap(Exchange exchange, String operation) throws Exception {	ConfigMap configMap = null;	String cfMapName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_CONFIGMAP_NAME, String.class);	String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	HashMap<String, String> configMapData = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_CONFIGMAP_DATA, HashMap.class);	if (ObjectHelper.isEmpty(cfMapName)) {	throw new IllegalArgumentException("Create a specific configMap require specify a configMap name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
create a specific configmap require specify a namespace name 

String cfMapName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_CONFIGMAP_NAME, String.class);	String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	HashMap<String, String> configMapData = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_CONFIGMAP_DATA, HashMap.class);	if (ObjectHelper.isEmpty(cfMapName)) {	throw new IllegalArgumentException("Create a specific configMap require specify a configMap name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	throw new IllegalArgumentException("Create a specific configMap require specify a namespace name");	}	if (ObjectHelper.isEmpty(configMapData)) {	
create a specific configmap require specify a data map 

protected void doDeleteConfigMap(Exchange exchange, String operation) throws Exception {	String configMapName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_CONFIGMAP_NAME, String.class);	String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(configMapName)) {	
delete a specific config map require specify a config map name 

protected void doDeleteConfigMap(Exchange exchange, String operation) throws Exception {	String configMapName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_CONFIGMAP_NAME, String.class);	String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(configMapName)) {	throw new IllegalArgumentException("Delete a specific config map require specify a config map name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
delete a specific config map require specify a namespace name 

========================= camel sample_13304 =========================

public void testFutureEchoException() throws Exception {	Echo service = ProxyHelper.createProxy(context.getEndpoint("direct:echo"), Echo.class);	Future<String> future = service.asText(4);	
got future 

public void testFutureEchoException() throws Exception {	Echo service = ProxyHelper.createProxy(context.getEndpoint("direct:echo"), Echo.class);	Future<String> future = service.asText(4);	
waiting for future to be done 

========================= camel sample_3205 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<GlanceComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.openstack-glance.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.openstack-glance.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1238 =========================

public void testSuspendResume() throws Exception {	assertFalse(context.isSuspended());	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceived("A");	template.sendBody("seda:foo", "A");	assertMockEndpointsSatisfied();	
Suspending 

mock.expectedBodiesReceived("A");	template.sendBody("seda:foo", "A");	assertMockEndpointsSatisfied();	resetMocks();	mock.expectedMessageCount(0);	context.suspend();	Thread.sleep(100);	template.sendBody("seda:foo", "B");	mock.assertIsSatisfied(1000);	assertTrue(context.isSuspended());	
Resuming 

========================= camel sample_1392 =========================

processed.setMessageId(messageId);	processed.setCreatedAt(new Date());	entityManager.persist(processed);	entityManager.flush();	entityManager.close();	return Boolean.TRUE;	} else {	return Boolean.FALSE;	}	} catch (Exception ex) {	
something went wrong trying to add message to repository 

} finally {	try {	if (entityManager.isOpen()) {	entityManager.close();	}	} catch (Exception e) {	}	}	}	});	
add 

entityManager.joinTransaction();	}	List<?> list = query(entityManager, messageId);	if (list.isEmpty()) {	return Boolean.FALSE;	} else {	return Boolean.TRUE;	}	}	});	
contains 

if (list.isEmpty()) {	return Boolean.FALSE;	} else {	MessageProcessed processed = (MessageProcessed) list.get(0);	entityManager.remove(processed);	entityManager.flush();	entityManager.close();	return Boolean.TRUE;	}	} catch (Exception ex) {	
something went wrong trying to remove message to repository 

} finally {	try {	if (entityManager.isOpen()) {	entityManager.close();	}	} catch (Exception e) {	}	}	}	});	
remove 

public boolean confirm(final Exchange exchange, String messageId) {	
confirm true 

Iterator it = list.iterator();	while (it.hasNext()) {	Object item = it.next();	entityManager.remove(item);	}	entityManager.flush();	entityManager.close();	}	return Boolean.TRUE;	} catch (Exception ex) {	
something went wrong trying to clear the repository 

} finally {	try {	if (entityManager.isOpen()) {	entityManager.close();	}	} catch (Exception e) {	}	}	}	});	
clear the store 

========================= camel sample_14091 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<TarFileDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.tarfile.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.tarfile.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_1107 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<CassandraComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.cql.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.cql.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_963 =========================

private synchronized void createSessionAndRegisterListener() throws RepositoryException {	
createsessionandregisterlistener start 

if (!"".equals(nodeTypeNames)) {	nodeTypeName = nodeTypeNames.split(",");	}	}	boolean noLocal = getJcrEndpoint().isNoLocal();	eventListener = new EndpointEventListener(getJcrEndpoint(), getProcessor());	if (LOG.isDebugEnabled()) {	LOG.debug("Adding JCR Event Listener, {}, on {}. eventTypes=" + eventTypes + ", isDeep=" + isDeep + ", uuid=" + Arrays.toString(uuid) + ", nodeTypeName=" + Arrays.toString(nodeTypeName) + ", noLocal=" + noLocal, eventListener, absPath);	}	session.getWorkspace().getObservationManager() .addEventListener(eventListener, eventTypes, absPath, isDeep, uuid, nodeTypeName, noLocal);	
createsessionandregisterlistener end 

public void run() {	
jcrconsumersessionlistenerchecker starts 

public void run() {	boolean isSessionLive = false;	synchronized (this) {	if (JcrConsumer.this.session != null) {	try {	isSessionLive = JcrConsumer.this.session.isLive();	} catch (Exception e) {	
exception while checking jcr session 

try {	isSessionLive = JcrConsumer.this.session.isLive();	} catch (Exception e) {	}	}	}	if (!isSessionLive) {	try {	createSessionAndRegisterListener();	} catch (RepositoryException e) {	
failed to create session and register listener 

} catch (Exception e) {	}	}	}	if (!isSessionLive) {	try {	createSessionAndRegisterListener();	} catch (RepositoryException e) {	}	}	
jcrconsumersessionlistenerchecker stops 

========================= camel sample_11456 =========================

protected void verify(InputStream input, final Message out) throws Exception {	
verification of xml signature document started 

try {	coreValidity = signature.validate(valContext);	} catch (XMLSignatureException se) {	throw getConfiguration().getValidationFailedHandler().onXMLSignatureException(se);	}	boolean goon = coreValidity;	if (!coreValidity) {	goon = handleSignatureValidationFailed(valContext, signature);	}	if (goon) {	
xml signature verified 

private NodeList getSignatureNodes(Document doc) throws IOException, ParserConfigurationException, XmlSignatureFormatException {	NodeList nl = doc.getElementsByTagNameNS(XMLSignature.XMLNS, "Signature");	if (nl.getLength() == 0) {	throw new XmlSignatureFormatException( "Message is not a correct XML signature document: 'Signature' element is missing. Check the sent message.");	}	
signature elements found 

protected boolean handleSignatureValidationFailed(DOMValidateContext valContext, XMLSignature signature) throws Exception {	ValidationFailedHandler handler = getConfiguration().getValidationFailedHandler();	
handlesignaturevalidationfailed called 

boolean refValid = ref.validate(valContext);	if (!refValid) {	handler.manifestReferenceValidationFailed(ref);	}	}	}	}	}	}	boolean goon = handler.ignoreCoreValidationFailure();	
ignore core validation failure 

========================= camel sample_6768 =========================

result.whenAnyExchangeReceived(new Processor() {	public void process(Exchange exchange) throws Exception {	String msg = exchange.getIn().getBody(String.class);	exchange.setException(new ThrottlingException(msg));	}	});	sendMessage("Message One");	sendMessage("Message Two");	final ServiceSupport consumer = (ServiceSupport) context.getRoute("foo").getConsumer();	await().atMost(2, TimeUnit.SECONDS).until(consumer::isSuspended);	
sending message three 

sendMessage("Message Two");	final ServiceSupport consumer = (ServiceSupport) context.getRoute("foo").getConsumer();	await().atMost(2, TimeUnit.SECONDS).until(consumer::isSuspended);	sendMessage("Message Three");	assertMockEndpointsSatisfied();	result.reset();	result.expectedMessageCount(2);	bodies = Arrays.asList("Message Three", "Message Four");	result.expectedBodiesReceivedInAnyOrder(bodies);	await().atMost(2, TimeUnit.SECONDS).until(consumer::isStarted);	
sending message four 

protected void sendMessage(String bodyText) {	try {	template.sendBody(url, bodyText);	} catch (Exception e) {	
error sending 

========================= camel sample_1804 =========================

public String rewrite(String url, HttpServletRequest request) throws Exception {	RewrittenUrl response = urlRewriter.processRequest(request, null);	if (response != null) {	String answer = response.getTarget();	
rewrite url 

public String rewrite(String url, HttpServletRequest request) throws Exception {	RewrittenUrl response = urlRewriter.processRequest(request, null);	if (response != null) {	String answer = response.getTarget();	return answer;	} else {	
rewrite using original url 

protected void doStart() throws Exception {	ObjectHelper.notNull(camelContext, "camelContext");	if (conf == null) {	if (modRewriteConfFile != null) {	
using mod rewrite config file as config for urlrewrite 

}	try {	String text = camelContext.getTypeConverter().mandatoryConvertTo(String.class, is);	ModRewriteConfLoader loader = new ModRewriteConfLoader();	conf = new Conf();	loader.process(text, conf);	} finally {	IOHelper.close(is);	}	} else if (modRewriteConfText != null) {	
using modrewriteconftext as config for urlrewrite 

conf = new Conf();	loader.process(text, conf);	} finally {	IOHelper.close(is);	}	} else if (modRewriteConfText != null) {	ModRewriteConfLoader loader = new ModRewriteConfLoader();	conf = new Conf();	loader.process(modRewriteConfText, conf);	} else if (configFile != null) {	
using config file as config for urlrewrite 

protected void doShutdown() throws Exception {	
shutting down urlrewrite 

========================= camel sample_15045 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<HdfsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hdfs2.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hdfs2.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_430 =========================

protected void executeComponents(Set<String> features) throws MojoExecutionException, MojoFailureException {	
copying all camel component json descriptors 

}	findComponentFilesRecursive(target, jsonFiles, componentFiles, new CamelComponentsFileFilter());	}	}	}	}	if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes");	findComponentFilesRecursive(target, jsonFiles, componentFiles, new CamelComponentsFileFilter());	}	
found component properties files 

}	findComponentFilesRecursive(target, jsonFiles, componentFiles, new CamelComponentsFileFilter());	}	}	}	}	if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes");	findComponentFilesRecursive(target, jsonFiles, componentFiles, new CamelComponentsFileFilter());	}	
found component json files 

protected void executeDataFormats(Set<String> features) throws MojoExecutionException, MojoFailureException {	
copying all camel dataformat json descriptors 

File target = new File(dir, "target/classes");	findDataFormatFilesRecursive(target, jsonFiles, dataFormatFiles, new CamelDataFormatsFileFilter());	}	}	}	}	if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes");	findDataFormatFilesRecursive(target, jsonFiles, dataFormatFiles, new CamelDataFormatsFileFilter());	}	
found dataformat properties files 

File target = new File(dir, "target/classes");	findDataFormatFilesRecursive(target, jsonFiles, dataFormatFiles, new CamelDataFormatsFileFilter());	}	}	}	}	if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes");	findDataFormatFilesRecursive(target, jsonFiles, dataFormatFiles, new CamelDataFormatsFileFilter());	}	
found dataformat json files 

protected void executeLanguages(Set<String> features) throws MojoExecutionException, MojoFailureException {	
copying all camel language json descriptors 

File target = new File(dir, "target/classes");	findLanguageFilesRecursive(target, jsonFiles, languageFiles, new CamelLanguagesFileFilter());	}	}	}	}	if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes");	findLanguageFilesRecursive(target, jsonFiles, languageFiles, new CamelLanguagesFileFilter());	}	
found language properties files 

File target = new File(dir, "target/classes");	findLanguageFilesRecursive(target, jsonFiles, languageFiles, new CamelLanguagesFileFilter());	}	}	}	}	if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes");	findLanguageFilesRecursive(target, jsonFiles, languageFiles, new CamelLanguagesFileFilter());	}	
found language json files 

protected void executeOthers(Set<String> features) throws MojoExecutionException, MojoFailureException {	
copying all camel other json descriptors 

if (special || special2) {	continue;	}	if (dir.isDirectory() && !"target".equals(dir.getName())) {	File target = new File(dir, "target/classes");	findOtherFilesRecursive(target, jsonFiles, otherFiles, new CamelOthersFileFilter());	}	}	}	}	
found other properties files 

if (special || special2) {	continue;	}	if (dir.isDirectory() && !"target".equals(dir.getName())) {	File target = new File(dir, "target/classes");	findOtherFilesRecursive(target, jsonFiles, otherFiles, new CamelOthersFileFilter());	}	}	}	}	
found other json files 

========================= camel sample_125 =========================

public Object processActivity(Object[] inputParameters, String taskToken) throws Exception {	
processing activity task 

========================= camel sample_8799 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SpringBatchComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.spring-batch.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.spring-batch.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_575 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ServerComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.iec60870-server.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.iec60870-server.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_826 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<TikaComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.tika.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.tika.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1042 =========================

public void run() {	try {	if (LoggingLevel.ERROR == runLoggingLevel) {	
scheduled task started on 

public void run() {	try {	if (LoggingLevel.ERROR == runLoggingLevel) {	} else if (LoggingLevel.WARN == runLoggingLevel) {	
scheduled task started on 

public void run() {	try {	if (LoggingLevel.ERROR == runLoggingLevel) {	} else if (LoggingLevel.WARN == runLoggingLevel) {	} else if (LoggingLevel.INFO == runLoggingLevel) {	
scheduled task started on 

public void run() {	try {	if (LoggingLevel.ERROR == runLoggingLevel) {	} else if (LoggingLevel.WARN == runLoggingLevel) {	} else if (LoggingLevel.INFO == runLoggingLevel) {	} else if (LoggingLevel.DEBUG == runLoggingLevel) {	
scheduled task started on 

public void run() {	try {	if (LoggingLevel.ERROR == runLoggingLevel) {	} else if (LoggingLevel.WARN == runLoggingLevel) {	} else if (LoggingLevel.INFO == runLoggingLevel) {	} else if (LoggingLevel.DEBUG == runLoggingLevel) {	} else {	
scheduled task started on 

public void run() {	try {	if (LoggingLevel.ERROR == runLoggingLevel) {	} else if (LoggingLevel.WARN == runLoggingLevel) {	} else if (LoggingLevel.INFO == runLoggingLevel) {	} else if (LoggingLevel.DEBUG == runLoggingLevel) {	} else {	}	doRun();	if (LoggingLevel.ERROR == runLoggingLevel) {	
scheduled task completed on 

try {	if (LoggingLevel.ERROR == runLoggingLevel) {	} else if (LoggingLevel.WARN == runLoggingLevel) {	} else if (LoggingLevel.INFO == runLoggingLevel) {	} else if (LoggingLevel.DEBUG == runLoggingLevel) {	} else {	}	doRun();	if (LoggingLevel.ERROR == runLoggingLevel) {	} else if (LoggingLevel.WARN == runLoggingLevel) {	
scheduled task completed on 

if (LoggingLevel.ERROR == runLoggingLevel) {	} else if (LoggingLevel.WARN == runLoggingLevel) {	} else if (LoggingLevel.INFO == runLoggingLevel) {	} else if (LoggingLevel.DEBUG == runLoggingLevel) {	} else {	}	doRun();	if (LoggingLevel.ERROR == runLoggingLevel) {	} else if (LoggingLevel.WARN == runLoggingLevel) {	} else if (LoggingLevel.INFO == runLoggingLevel) {	
scheduled task completed on 

} else if (LoggingLevel.WARN == runLoggingLevel) {	} else if (LoggingLevel.INFO == runLoggingLevel) {	} else if (LoggingLevel.DEBUG == runLoggingLevel) {	} else {	}	doRun();	if (LoggingLevel.ERROR == runLoggingLevel) {	} else if (LoggingLevel.WARN == runLoggingLevel) {	} else if (LoggingLevel.INFO == runLoggingLevel) {	} else if (LoggingLevel.DEBUG == runLoggingLevel) {	
scheduled task completed on 

} else if (LoggingLevel.INFO == runLoggingLevel) {	} else if (LoggingLevel.DEBUG == runLoggingLevel) {	} else {	}	doRun();	if (LoggingLevel.ERROR == runLoggingLevel) {	} else if (LoggingLevel.WARN == runLoggingLevel) {	} else if (LoggingLevel.INFO == runLoggingLevel) {	} else if (LoggingLevel.DEBUG == runLoggingLevel) {	} else {	
scheduled task completed on 

} else {	}	doRun();	if (LoggingLevel.ERROR == runLoggingLevel) {	} else if (LoggingLevel.WARN == runLoggingLevel) {	} else if (LoggingLevel.INFO == runLoggingLevel) {	} else if (LoggingLevel.DEBUG == runLoggingLevel) {	} else {	}	} catch (Error e) {	
error occurred during running scheduled task on due 

private void doRun() {	if (isSuspended()) {	
cannot start to poll as its suspended 

private void doRun() {	if (isSuspended()) {	return;	}	if (backoffMultiplier > 0 && (idleCounter >= (backoffIdleThreshold > 0 ? backoffIdleThreshold : Integer.MAX_VALUE)) || errorCounter >= (backoffErrorThreshold > 0 ? backoffErrorThreshold : Integer.MAX_VALUE)) {	if (backoffCounter++ < backoffMultiplier) {	if (idleCounter > 0) {	
dorun backoff due subsequent idles backoff at 

private void doRun() {	if (isSuspended()) {	return;	}	if (backoffMultiplier > 0 && (idleCounter >= (backoffIdleThreshold > 0 ? backoffIdleThreshold : Integer.MAX_VALUE)) || errorCounter >= (backoffErrorThreshold > 0 ? backoffErrorThreshold : Integer.MAX_VALUE)) {	if (backoffCounter++ < backoffMultiplier) {	if (idleCounter > 0) {	} else {	
dorun backoff due subsequent errors backoff at 

if (backoffMultiplier > 0 && (idleCounter >= (backoffIdleThreshold > 0 ? backoffIdleThreshold : Integer.MAX_VALUE)) || errorCounter >= (backoffErrorThreshold > 0 ? backoffErrorThreshold : Integer.MAX_VALUE)) {	if (backoffCounter++ < backoffMultiplier) {	if (idleCounter > 0) {	} else {	}	return;	} else {	idleCounter = 0;	errorCounter = 0;	backoffCounter = 0;	
dorun backoff finished resetting counters 

int retryCounter = -1;	boolean done = false;	Throwable cause = null;	int polledMessages = 0;	while (!done) {	try {	cause = null;	done = true;	if (isPollAllowed()) {	if (retryCounter == -1) {	
starting to poll 

boolean done = false;	Throwable cause = null;	int polledMessages = 0;	while (!done) {	try {	cause = null;	done = true;	if (isPollAllowed()) {	if (retryCounter == -1) {	} else {	
retrying attempt to poll 

if (isPollAllowed()) {	if (retryCounter == -1) {	} else {	}	polling = true;	try {	boolean begin = pollStrategy.begin(this, getEndpoint());	if (begin) {	retryCounter++;	polledMessages = poll();	
polled messages 

if (begin) {	retryCounter++;	polledMessages = poll();	if (polledMessages == 0 && isSendEmptyMessageWhenIdle()) {	processEmptyMessage();	}	pollStrategy.commit(this, getEndpoint(), polledMessages);	if (polledMessages > 0 && isGreedy()) {	done = false;	retryCounter = -1;	
greedy polling after processing messages 

polledMessages = poll();	if (polledMessages == 0 && isSendEmptyMessageWhenIdle()) {	processEmptyMessage();	}	pollStrategy.commit(this, getEndpoint(), polledMessages);	if (polledMessages > 0 && isGreedy()) {	done = false;	retryCounter = -1;	}	} else {	
cannot begin polling as pollstrategy returned false 

if (polledMessages > 0 && isGreedy()) {	done = false;	retryCounter = -1;	}	} else {	}	} finally {	polling = false;	}	}	
finished polling 

done = true;	}	} catch (Throwable t) {	cause = t;	done = true;	}	if (cause != null && isRunAllowed()) {	try {	getExceptionHandler().handleException("Consumer " + this + " failed polling endpoint: " + getEndpoint() + ". Will try again at next poll", cause);	} catch (Throwable e) {	
error handling exception this exception will be ignored 

protected void processEmptyMessage() throws Exception {	Exchange exchange = getEndpoint().createExchange();	
sending empty message as there were no messages from polling 

public long beforePoll(long timeout) throws Exception {	
before poll 

public void afterPoll() throws Exception {	
after poll 

========================= camel sample_4169 =========================

try {	lock.lock();	this.currentLeader = leader;	this.currentMembers = members;	this.timestamp = timestamp;	this.lease = lease;	version = ++changeCounter;	} finally {	lock.unlock();	}	
updated leader to at version version 

this.timestamp = timestamp;	this.lease = lease;	version = ++changeCounter;	} finally {	lock.unlock();	}	this.executor.execute(() -> checkAndNotify(version));	if (leader.isPresent()) {	long time = System.currentTimeMillis();	long delay = Math.max(timestamp + lease + FIXED_DELAY - time, FIXED_DELAY);	
setting expiration in millis for version 

private void expiration(long version) {	try {	lock.lock();	if (version != this.changeCounter) {	return;	}	long time = System.currentTimeMillis();	if (time < this.timestamp + this.lease) {	long delay = this.timestamp + this.lease - time;	
delaying expiration by millis at version version 

if (time >= this.timestamp + this.lease) {	leader = Optional.empty();	}	}	} finally {	lock.unlock();	}	final Optional<String> newLeader = leader;	if (!newLeader.equals(lastCommunicatedLeader)) {	lastCommunicatedLeader = newLeader;	
the cluster has a new leader 

final Optional<String> newLeader = leader;	if (!newLeader.equals(lastCommunicatedLeader)) {	lastCommunicatedLeader = newLeader;	try {	handler.onKubernetesClusterEvent(new KubernetesClusterEvent.KubernetesClusterLeaderChangedEvent() {	public Optional<String> getData() {	return newLeader;	}	});	} catch (Throwable t) {	
error while communicating the new leader to the handler 

public Optional<String> getData() {	return newLeader;	}	});	} catch (Throwable t) {	}	}	final Set<String> newMembers = members;	if (!newMembers.equals(lastCommunicatedMembers)) {	lastCommunicatedMembers = newMembers;	
the list of cluster members has changed 

final Set<String> newMembers = members;	if (!newMembers.equals(lastCommunicatedMembers)) {	lastCommunicatedMembers = newMembers;	try {	handler.onKubernetesClusterEvent(new KubernetesClusterEvent.KubernetesClusterMemberListChangedEvent() {	public Set<String> getData() {	return newMembers;	}	});	} catch (Throwable t) {	
error while communicating the cluster members to the handler 

========================= camel sample_13257 =========================

final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.fields", "");	headers.put("CamelLinkedIn.keywords", "linkedin");	headers.put("CamelLinkedIn.hq_only", null);	headers.put("CamelLinkedIn.facet", null);	headers.put("CamelLinkedIn.facets", null);	headers.put("CamelLinkedIn.start", null);	headers.put("CamelLinkedIn.count", null);	headers.put("CamelLinkedIn.sort", null);	final org.apache.camel.component.linkedin.api.model.CompanySearch result = requestBodyAndHeaders("direct: assertNotNull("searchCompanies result", result);	
searchcompanies 

headers.put("CamelLinkedIn.job_title", null);	headers.put("CamelLinkedIn.country_code", null);	headers.put("CamelLinkedIn.postal_code", null);	headers.put("CamelLinkedIn.distance", null);	headers.put("CamelLinkedIn.facet", null);	headers.put("CamelLinkedIn.facets", null);	headers.put("CamelLinkedIn.start", null);	headers.put("CamelLinkedIn.count", null);	headers.put("CamelLinkedIn.sort", null);	final org.apache.camel.component.linkedin.api.model.JobSearch result = requestBodyAndHeaders("direct: assertNotNull("searchJobs result", result);	
searchjobs 

headers.put("CamelLinkedIn.current_school", null);	headers.put("CamelLinkedIn.country_code", null);	headers.put("CamelLinkedIn.postal_code", null);	headers.put("CamelLinkedIn.distance", null);	headers.put("CamelLinkedIn.facet", null);	headers.put("CamelLinkedIn.facets", null);	headers.put("CamelLinkedIn.start", null);	headers.put("CamelLinkedIn.count", null);	headers.put("CamelLinkedIn.sort", null);	final org.apache.camel.component.linkedin.api.model.PeopleSearch result = requestBodyAndHeaders("direct: assertNotNull("searchPeople result", result);	
searchpeople 

========================= camel sample_8849 =========================

public void checkContextsHaveCorrectEndpointsAndRoutes() throws Exception {	assertNotNull("camelContexts not injected!", camelContexts);	for (CamelContext camelContext : camelContexts) {	
camelcontext has endpoints 

========================= camel sample_6441 =========================

public void testChunkPerformance() throws Exception {	int messageCount = 10000;	endSimpleMock.expectedMessageCount(messageCount);	StopWatch stopwatch = new StopWatch(true);	for (int i = 0; i < messageCount; i++) {	startSimpleProducerTemplate.sendBodyAndHeader("The Body", "name", "Andrew");	}	assertMockEndpointsSatisfied();	
chunk performance ms for messages 

========================= camel sample_10494 =========================

public synchronized IRCConnection getIRCConnection(IrcConfiguration configuration) {	final IRCConnection connection;	if (connectionCache.containsKey(configuration.getCacheKey())) {	if (LOG.isDebugEnabled()) {	
returning cached connection to 

protected IRCConnection createConnection(IrcConfiguration configuration) {	IRCConnection conn = null;	IRCEventListener ircLogger;	if (configuration.getUsingSSL()) {	if (LOG.isDebugEnabled()) {	
creating ssl connection to destination s nick user 

}	if (sslParams != null) {	conn = new CamelSSLIRCConnection(configuration.getHostname(), configuration.getPorts(), configuration.getPassword(), configuration.getNickname(), configuration.getUsername(), configuration.getRealname(), sslParams, getCamelContext());	} else {	SSLIRCConnection sconn = new SSLIRCConnection(configuration.getHostname(), configuration.getPorts(), configuration.getPassword(), configuration.getNickname(), configuration.getUsername(), configuration.getRealname());	sconn.addTrustManager(configuration.getTrustManager());	conn = sconn;	}	} else {	if (LOG.isDebugEnabled()) {	
creating connection to destination s nick user 

}	} else {	if (LOG.isDebugEnabled()) {	}	conn = new IRCConnection(configuration.getHostname(), configuration.getPorts(), configuration.getPassword(), configuration.getNickname(), configuration.getUsername(), configuration.getRealname());	}	conn.setEncoding("UTF-8");	conn.setColors(configuration.isColors());	conn.setPong(true);	if (LOG.isDebugEnabled()) {	
adding irc event logging listener 

public void closeConnection(String key, IRCConnection connection) {	try {	connection.doQuit();	connection.close();	} catch (Exception e) {	
error during closing connection 

========================= camel sample_12153 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<DisruptorVmComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.disruptor-vm.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.disruptor-vm.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_719 =========================

GetQueueUrlRequest getQueueUrlRequest = new GetQueueUrlRequest();	getQueueUrlRequest.setQueueName(configuration.getQueueName());	getQueueUrlRequest.setQueueOwnerAWSAccountId(configuration.getQueueOwnerAWSAccountId());	GetQueueUrlResult getQueueUrlResult = client.getQueueUrl(getQueueUrlRequest);	queueUrl = getQueueUrlResult.getQueueUrl();	} else {	ListQueuesResult listQueuesResult = client.listQueues();	for (String url : listQueuesResult.getQueueUrls()) {	if (url.endsWith("/" + configuration.getQueueName())) {	queueUrl = url;	
queue available at 

for (String url : listQueuesResult.getQueueUrls()) {	if (url.endsWith("/" + configuration.getQueueName())) {	queueUrl = url;	break;	}	}	}	if (queueUrl == null) {	createQueue(client);	} else {	
using amazon sqs queue url 

protected void createQueue(AmazonSQS client) {	
queue doesn t exist will create it 

}	if (getConfiguration().getPolicy() != null) {	request.getAttributes().put(QueueAttributeName.Policy.name(), String.valueOf(getConfiguration().getPolicy()));	}	if (getConfiguration().getReceiveMessageWaitTimeSeconds() != null) {	request.getAttributes().put(QueueAttributeName.ReceiveMessageWaitTimeSeconds.name(), String.valueOf(getConfiguration().getReceiveMessageWaitTimeSeconds()));	}	if (getConfiguration().getRedrivePolicy() != null) {	request.getAttributes().put(QueueAttributeName.RedrivePolicy.name(), getConfiguration().getRedrivePolicy());	}	
creating queue with request 

request.getAttributes().put(QueueAttributeName.Policy.name(), String.valueOf(getConfiguration().getPolicy()));	}	if (getConfiguration().getReceiveMessageWaitTimeSeconds() != null) {	request.getAttributes().put(QueueAttributeName.ReceiveMessageWaitTimeSeconds.name(), String.valueOf(getConfiguration().getReceiveMessageWaitTimeSeconds()));	}	if (getConfiguration().getRedrivePolicy() != null) {	request.getAttributes().put(QueueAttributeName.RedrivePolicy.name(), getConfiguration().getRedrivePolicy());	}	CreateQueueResult queueResult = client.createQueue(request);	queueUrl = queueResult.getQueueUrl();	
queue created and available at 

if (getConfiguration().getPolicy() != null) {	request.getAttributes().put(QueueAttributeName.Policy.name(), String.valueOf(getConfiguration().getPolicy()));	}	if (getConfiguration().getReceiveMessageWaitTimeSeconds() != null) {	request.getAttributes().put(QueueAttributeName.ReceiveMessageWaitTimeSeconds.name(), String.valueOf(getConfiguration().getReceiveMessageWaitTimeSeconds()));	}	if (getConfiguration().getRedrivePolicy() != null) {	request.getAttributes().put(QueueAttributeName.RedrivePolicy.name(), getConfiguration().getRedrivePolicy());	}	if (!request.getAttributes().isEmpty()) {	
updating queue with the provided queue attributes 

request.getAttributes().put(QueueAttributeName.Policy.name(), String.valueOf(getConfiguration().getPolicy()));	}	if (getConfiguration().getReceiveMessageWaitTimeSeconds() != null) {	request.getAttributes().put(QueueAttributeName.ReceiveMessageWaitTimeSeconds.name(), String.valueOf(getConfiguration().getReceiveMessageWaitTimeSeconds()));	}	if (getConfiguration().getRedrivePolicy() != null) {	request.getAttributes().put(QueueAttributeName.RedrivePolicy.name(), getConfiguration().getRedrivePolicy());	}	if (!request.getAttributes().isEmpty()) {	client.setQueueAttributes(request);	
queue updated and available at 

========================= camel sample_8721 =========================

private void startClient() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, UnknownHostException {	if (client == null) {	
connecting to the elasticsearch cluster 

private void startClient() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, UnknownHostException {	if (client == null) {	if (configuration.getHostAddressesList() != null && !configuration.getHostAddressesList().isEmpty()) {	client = createClient();	} else {	
incorrect ip address and port parameters settings for elasticsearch cluster 

protected void doStop() throws Exception {	if (client != null) {	
disconnecting from elasticsearch cluster 

========================= camel sample_9999 =========================

public void onlyManageProcessorWithCustomId(boolean flag) {	
using deprecated option onlymanageprocessorwithcustomid on managementstrategy configure this on managementagent instead 

public void setStatisticsLevel(ManagementStatisticsLevel level) {	
using deprecated option statisticslevel on managementstrategy configure this on managementagent instead 

public void setLoadStatisticsEnabled(boolean loadStatisticsEnabled) {	
using deprecated option loadstatisticsenabled on managementstrategy configure this on managementagent instead 

protected void doStart() throws Exception {	
jmx is disabled 

========================= camel sample_4702 =========================

public synchronized List<PullRequest> getPullRequests(IRepositoryIdProvider repository, String state) {	List<PullRequest> result = new ArrayList<PullRequest>();	for (Long id : pullRequests.keySet()) {	PullRequest pr = pullRequests.get(id);	if (pr.getState().equals(state)) {	result.add(pr);	}	}	
returning list of pull requests with state 

========================= camel sample_14253 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<GoraComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.gora.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.gora.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1150 =========================

public void undeploy(Archive<?> archive) throws DeploymentException {	
undeploying 

public void undeploy(Archive<?> archive) throws DeploymentException {	if (!keepDeploymentArchives) {	for (File materializedFile : materializedFiles) {	if (materializedFile.isDirectory()) {	try {	FileDeploymentUtils.deleteRecursively(materializedFile.toPath());	} catch (IOException e) {	
could not delete materialized directory 

public ProtocolMetaData deploy(final Archive<?> archive) throws DeploymentException {	
deploying 

========================= camel sample_5955 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ZendeskComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.zendesk.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.zendesk.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1015 =========================

public void setUp() throws Exception {	super.setUp();	byte[] iso = payload.getBytes("iso-8859-1");	byte[] utf = payload.getBytes("utf-8");	
iso iso 

public void setUp() throws Exception {	super.setUp();	byte[] iso = payload.getBytes("iso-8859-1");	byte[] utf = payload.getBytes("utf-8");	
utf utf 

public void setUp() throws Exception {	super.setUp();	byte[] iso = payload.getBytes("iso-8859-1");	byte[] utf = payload.getBytes("utf-8");	for (byte b : iso) {	
iso byte 

public void setUp() throws Exception {	super.setUp();	byte[] iso = payload.getBytes("iso-8859-1");	byte[] utf = payload.getBytes("utf-8");	for (byte b : iso) {	}	for (byte b : utf) {	
utf byte 

========================= camel sample_15157 =========================

protected void doStart() throws Exception {	super.doStart();	this.set = getAtomixEndpoint() .getAtomix() .getSet( resourceName, new DistributedSet.Config(getAtomixEndpoint().getConfiguration().getResourceOptions(resourceName)), new DistributedSet.Options(getAtomixEndpoint().getConfiguration().getResourceConfig(resourceName))) .join();	
subscribe to events for set 

========================= camel sample_10355 =========================

Class<?> processorClass = processorDefinition.getClass();	String shortName = processorDefinition.getShortName();	if (processorDefinition instanceof BeanDefinition) {	BeanProcessor beanProcessor = (BeanProcessor) nextTarget;	processorClass = beanProcessor.getBean().getClass();	} else if (processorDefinition instanceof ProcessDefinition) {	DelegateSyncProcessor syncProcessor = (DelegateSyncProcessor) nextTarget;	processorClass = syncProcessor.getProcessor().getClass();	}	if (!processorClass.isAnnotationPresent(XRayTrace.class)) {	
does not contain an trace annotation skipping interception 

if (processorDefinition instanceof BeanDefinition) {	BeanProcessor beanProcessor = (BeanProcessor) nextTarget;	processorClass = beanProcessor.getBean().getClass();	} else if (processorDefinition instanceof ProcessDefinition) {	DelegateSyncProcessor syncProcessor = (DelegateSyncProcessor) nextTarget;	processorClass = syncProcessor.getProcessor().getClass();	}	if (!processorClass.isAnnotationPresent(XRayTrace.class)) {	return new DelegateAsyncProcessor(target);	}	
wrapping process definition of target in order for recording its trace 

}	Annotation annotation = processorClass.getAnnotation(XRayTrace.class);	XRayTrace trace = (XRayTrace)annotation;	String metricName = trace.metricName();	if ("".equals(metricName)) {	metricName = processorClass.getSimpleName();	}	final Class<?> type = processorClass;	final String name = shortName + ":" + metricName;	return new DelegateAsyncProcessor((Exchange exchange) -> {	
creating new subsegment for of type eip 

XRayTrace trace = (XRayTrace)annotation;	String metricName = trace.metricName();	if ("".equals(metricName)) {	metricName = processorClass.getSimpleName();	}	final Class<?> type = processorClass;	final String name = shortName + ":" + metricName;	return new DelegateAsyncProcessor((Exchange exchange) -> {	Subsegment subsegment = AWSXRay.beginSubsegment(sanitizeName(name));	try {	
processing eip 

if ("".equals(metricName)) {	metricName = processorClass.getSimpleName();	}	final Class<?> type = processorClass;	final String name = shortName + ":" + metricName;	return new DelegateAsyncProcessor((Exchange exchange) -> {	Subsegment subsegment = AWSXRay.beginSubsegment(sanitizeName(name));	try {	target.process(exchange);	} catch (Exception ex) {	
handling exception thrown by invoked eip 

final Class<?> type = processorClass;	final String name = shortName + ":" + metricName;	return new DelegateAsyncProcessor((Exchange exchange) -> {	Subsegment subsegment = AWSXRay.beginSubsegment(sanitizeName(name));	try {	target.process(exchange);	} catch (Exception ex) {	subsegment.addException(ex);	throw ex;	} finally {	
closing down subsegment for 

========================= camel sample_8234 =========================

protected void doStart() throws Exception {	
starting couchbase consumer 

protected void doStop() throws Exception {	
stopping couchbase consumer 

protected synchronized int poll() throws Exception {	ViewResponse result = client.query(view, query);	
received result set from couchbase 

String designDocumentName = endpoint.getDesignDocumentName();	String viewName = endpoint.getViewName();	Exchange exchange = endpoint.createExchange();	exchange.getIn().setBody(doc);	exchange.getIn().setHeader(HEADER_ID, id);	exchange.getIn().setHeader(HEADER_KEY, key);	exchange.getIn().setHeader(HEADER_DESIGN_DOCUMENT_NAME, designDocumentName);	exchange.getIn().setHeader(HEADER_VIEWNAME, viewName);	if ("delete".equalsIgnoreCase(consumerProcessedStrategy)) {	if (log.isTraceEnabled()) {	
deleting doc with id 

exchange.getIn().setHeader(HEADER_ID, id);	exchange.getIn().setHeader(HEADER_KEY, key);	exchange.getIn().setHeader(HEADER_DESIGN_DOCUMENT_NAME, designDocumentName);	exchange.getIn().setHeader(HEADER_VIEWNAME, viewName);	if ("delete".equalsIgnoreCase(consumerProcessedStrategy)) {	if (log.isTraceEnabled()) {	}	client.delete(id);	} else if ("filter".equalsIgnoreCase(consumerProcessedStrategy)) {	if (log.isTraceEnabled()) {	
filtering out id 

exchange.getIn().setHeader(HEADER_DESIGN_DOCUMENT_NAME, designDocumentName);	exchange.getIn().setHeader(HEADER_VIEWNAME, viewName);	if ("delete".equalsIgnoreCase(consumerProcessedStrategy)) {	if (log.isTraceEnabled()) {	}	client.delete(id);	} else if ("filter".equalsIgnoreCase(consumerProcessedStrategy)) {	if (log.isTraceEnabled()) {	}	} else {	
no strategy set for already processed docs beware of duplicates 

========================= camel sample_7712 =========================

public void handleMessage(final Exchange exchange) {	if (log.isDebugEnabled()) {	
handling inonly message 

public void handleMessage(final Exchange exchange) {	if (log.isDebugEnabled()) {	}	if (!exchange.isFailed()) {	NoOpAsyncCallback callback = new NoOpAsyncCallback();	if (isTransacted() || isSynchronous()) {	if (log.isDebugEnabled()) {	
synchronous processing message destination 

if (log.isDebugEnabled()) {	}	try {	getProcessor().process(exchange);	} catch (Exception e) {	exchange.setException(e);	} finally {	callback.done(true);	}	} else {	
asynchronous processing message destination 

public void done(boolean sync) {	
noopasynccallback inonly exchange complete 

========================= camel sample_12411 =========================

private Pubsub buildClient(HttpTransport httpTransport) throws Exception {	GoogleCredential credential = null;	if (!Strings.isNullOrEmpty(serviceAccount) && !Strings.isNullOrEmpty(serviceAccountKey)) {	if (logger.isDebugEnabled()) {	
service account and key have been set explicitly initialising pubsub using service account 

private Pubsub buildClient(HttpTransport httpTransport) throws Exception {	GoogleCredential credential = null;	if (!Strings.isNullOrEmpty(serviceAccount) && !Strings.isNullOrEmpty(serviceAccountKey)) {	if (logger.isDebugEnabled()) {	}	credential = createFromAccountKeyPair(httpTransport);	}	if (credential == null && !Strings.isNullOrEmpty(credentialsFileLocation)) {	if (logger.isDebugEnabled()) {	
key file name has been set explicitly initialising pubsub using key file 

}	credential = createFromAccountKeyPair(httpTransport);	}	if (credential == null && !Strings.isNullOrEmpty(credentialsFileLocation)) {	if (logger.isDebugEnabled()) {	}	credential = createFromFile();	}	if (credential == null) {	if (logger.isDebugEnabled()) {	
no explicit service account or key file name have been provided initialising pubsub using defaults 

========================= camel sample_17243 =========================

public void myMethod(@Headers Map<String, Object> headers, Object body) {	this.headers = headers;	this.body = body;	
mymethod method called on 

========================= camel sample_3244 =========================

private void getUserImages(Exchange exchange) throws Exception {	Images images = getEndpoint().getDigitalOceanClient().getUserImages(configuration.getPage(), configuration.getPerPage());	
user images page per page 

private void getImages(Exchange exchange) throws Exception {	DigitalOceanImageTypes type = exchange.getIn().getHeader(DigitalOceanHeaders.TYPE, DigitalOceanImageTypes.class);	Images images;	if (ObjectHelper.isNotEmpty(type)) {	images = getEndpoint().getDigitalOceanClient().getAvailableImages(configuration.getPage(), configuration.getPerPage(), ActionType.valueOf(type.name()));	} else {	images = getEndpoint().getDigitalOceanClient().getAvailableImages(configuration.getPage(), configuration.getPerPage());	}	
all images page per page 

Integer imageId = exchange.getIn().getHeader(DigitalOceanHeaders.ID, Integer.class);	String slug = exchange.getIn().getHeader(DigitalOceanHeaders.DROPLET_IMAGE, String.class);	Image image;	if (ObjectHelper.isNotEmpty(imageId)) {	image = getEndpoint().getDigitalOceanClient().getImageInfo(imageId);	} else if (ObjectHelper.isNotEmpty(slug)) {	image = getEndpoint().getDigitalOceanClient().getImageInfo(slug);	} else {	throw new IllegalArgumentException(DigitalOceanHeaders.ID + " or " + DigitalOceanHeaders.DROPLET_IMAGE + " must be specified");	}	
image 

private void getImageActions(Exchange exchange) throws Exception {	Integer imageId = exchange.getIn().getHeader(DigitalOceanHeaders.ID, Integer.class);	if (ObjectHelper.isEmpty(imageId)) {	throw new IllegalArgumentException(DigitalOceanHeaders.ID + " must be specified");	}	Actions actions = getEndpoint().getDigitalOceanClient().getAvailableImageActions(imageId, configuration.getPage(), configuration.getPerPage());	
actions for image page per page 

throw new IllegalArgumentException(DigitalOceanHeaders.ID + " must be specified");	}	String name = exchange.getIn().getHeader(DigitalOceanHeaders.NAME, String.class);	if (ObjectHelper.isEmpty(name)) {	throw new IllegalArgumentException(DigitalOceanHeaders.NAME + " must be specified");	}	Image image = new Image();	image.setId(imageId);	image.setName(name);	image = getEndpoint().getDigitalOceanClient().updateImage(image);	
update image 

private void deleteImage(Exchange exchange) throws Exception {	Integer imageId = exchange.getIn().getHeader(DigitalOceanHeaders.ID, Integer.class);	if (ObjectHelper.isEmpty(imageId)) {	throw new IllegalArgumentException(DigitalOceanHeaders.ID + " must be specified");	}	Delete delete = getEndpoint().getDigitalOceanClient().deleteImage(imageId);	
delete image 

private void transferImage(Exchange exchange) throws Exception {	Integer imageId = exchange.getIn().getHeader(DigitalOceanHeaders.ID, Integer.class);	if (ObjectHelper.isEmpty(imageId)) {	throw new IllegalArgumentException(DigitalOceanHeaders.ID + " must be specified");	}	String region = exchange.getIn().getHeader(DigitalOceanHeaders.REGION, String.class);	if (ObjectHelper.isEmpty(region)) {	throw new IllegalArgumentException(DigitalOceanHeaders.REGION + " must be specified");	}	Action action = getEndpoint().getDigitalOceanClient().transferImage(imageId, region);	
transfer image to region 

private void convertImageToSnapshot(Exchange exchange) throws Exception {	Integer imageId = exchange.getIn().getHeader(DigitalOceanHeaders.ID, Integer.class);	if (ObjectHelper.isEmpty(imageId)) {	throw new IllegalArgumentException(DigitalOceanHeaders.ID + " must be specified");	}	Action action = getEndpoint().getDigitalOceanClient().convertImage(imageId);	
convert image 

========================= camel sample_8886 =========================

public void testEndpointConfiguration() throws Exception {	Endpoint endpoint = getMandatoryBean(Endpoint.class, "endpoint1");	assertEquals("endpoint URI", "direct: DummyBean dummyBean = getMandatoryBean(DummyBean.class, "mybean");	assertNotNull("The bean should have an endpoint injected", dummyBean.getEndpoint());	
endpoint uri direct log debug dummybean 

public void testEndpointConfigurationAfterEnsuringThatTheStatementRouteBuilderWasCreated() throws Exception {	String[] names = applicationContext.getBeanDefinitionNames();	for (String name : names) {	
found bean name 

========================= camel sample_16130 =========================

public void start() throws Exception {	
starting server 

public static void main(String args[]) throws Exception {	Server server = new Server();	
server ready 

public static void main(String args[]) throws Exception {	Server server = new Server();	server.start();	Thread.sleep(5 * 60 * 1000);	
server exiting 

========================= camel sample_6031 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<RestletComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.restlet.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.restlet.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_739 =========================

public Producer createProducer() throws Exception {	
creating spark producer 

public Producer createProducer() throws Exception {	if (endpointType == EndpointType.rdd) {	
about to create rdd producer 

public Producer createProducer() throws Exception {	if (endpointType == EndpointType.rdd) {	return new RddSparkProducer(this);	} else if (endpointType == EndpointType.dataframe) {	
about to create dataframe producer 

public Producer createProducer() throws Exception {	if (endpointType == EndpointType.rdd) {	return new RddSparkProducer(this);	} else if (endpointType == EndpointType.dataframe) {	return new DataFrameSparkProducer(this);	} else {	
about to create hive producer 

========================= camel sample_12523 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from(uri) .aggregate(constant(true), new AggregationStrategy() {	public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {	Exchange answer = oldExchange != null ? oldExchange : newExchange;	COUNTER.getAndIncrement();	Integer newIndex = newExchange.getIn().getHeader("index", Integer.class);	int total = SUM.addAndGet(newIndex);	answer.getIn().setHeader("total", total);	
index total so far 

========================= camel sample_1961 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KubernetesPodsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-pods.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-pods.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_555 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<FopComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.fop.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.fop.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1062 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SdbComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-sdb.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-sdb.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1127 =========================

exchange.setProperty("Timeout", true);	timeoutLatch.countDown();	}	}) .completionAware(new CompletionAwareMixin() {	public void onCompletion(Exchange exchange) {	completionLatch.countDown();	}	});	from("direct:start.timeoutAndCompletionAware") .aggregate(timeoutCompletionStrategy).constant(true) .completionTimeout(500).completionSize(2) .to("mock:result.timeoutAndCompletionAware");	from("direct:start.xpath1") .aggregate(AggregationStrategies.flexible(Node.class) .pick(xpath(" .accumulateInCollection(ArrayList.class)) .constant(true).completionSize(3) .to("mock:result.xpath1");	
direct linkedlist before the first split the body is body and has class body getclass during the first split the body is body and has class body getclass before the second split the body is body and has class body getclass during the second split the body is body and has class body getclass after the second split the body is body and has class body getclass 

exchange.setProperty("Timeout", true);	timeoutLatch.countDown();	}	}) .completionAware(new CompletionAwareMixin() {	public void onCompletion(Exchange exchange) {	completionLatch.countDown();	}	});	from("direct:start.timeoutAndCompletionAware") .aggregate(timeoutCompletionStrategy).constant(true) .completionTimeout(500).completionSize(2) .to("mock:result.timeoutAndCompletionAware");	from("direct:start.xpath1") .aggregate(AggregationStrategies.flexible(Node.class) .pick(xpath(" .accumulateInCollection(ArrayList.class)) .constant(true).completionSize(3) .to("mock:result.xpath1");	
direct hashset before the first split the body is body and has class body getclass during the first split the body is body and has class body getclass before the second split the body is body and has class body getclass during the second split the body is body and has class body getclass after the second split the body is body and has class body getclass 

========================= camel sample_1577 =========================

public void testAddUserEmailAlias() throws Exception {	com.box.sdk.EmailAlias result = null;	try {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.userId", testUser.getID());	headers.put("CamelBox.email", CAMEL_TEST_USER_EMAIL_ALIAS);	result = requestBodyAndHeaders("direct: assertNotNull("addUserEmailAlias result", result);	
adduseremailalias 

public void testCreateAppUser() throws Exception {	com.box.sdk.BoxUser result = null;	try {	CreateUserParams params = new CreateUserParams();	params.setSpaceAmount(1073741824);	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.name", CAMEL_TEST_CREATE_APP_USER_NAME);	headers.put("CamelBox.params", params);	result = requestBodyAndHeaders("direct: assertNotNull("createAppUser result", result);	
createappuser 

public void testCreateEnterpriseUser() throws Exception {	com.box.sdk.BoxUser result = null;	try {	CreateUserParams params = new CreateUserParams();	params.setSpaceAmount(1073741824);	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.login", CAMEL_TEST_CREATE_ENTERPRISE_USER_LOGIN);	headers.put("CamelBox.name", CAMEL_TEST_CREATE_ENTERPRISE_USER_NAME);	headers.put("CamelBox.params", params);	result = requestBodyAndHeaders("direct: assertNotNull("createEnterpriseUser result", result);	
createenterpriseuser 

public void testDeleteUser() throws Exception {	BoxUser.Info info = BoxUser.createAppUser(getConnection(), CAMEL_TEST_CREATE_APP_USER_NAME);	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.userId", info.getID());	headers.put("CamelBox.notifyUser", Boolean.FALSE);	headers.put("CamelBox.force", Boolean.FALSE);	requestBodyAndHeaders("direct: Iterable<BoxUser.Info> it = BoxUser.getAllEnterpriseUsers(getConnection(), CAMEL_TEST_CREATE_APP_USER_NAME);	int searchResults = sizeOfIterable(it);	boolean exists = searchResults > 0 ? true : false;	assertEquals("deleteUser exists", false, exists);	
deleteuser exists 

public void testGetAllEnterpriseOrExternalUsers() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.filterTerm", null);	headers.put("CamelBox.fields", null);	final java.util.List result = requestBodyAndHeaders("direct: assertNotNull("getAllEnterpriseOrExternalUsers result", result);	
getallenterpriseorexternalusers 

public void testGetCurrentUser() throws Exception {	final com.box.sdk.BoxUser result = requestBody("direct: assertNotNull("getCurrentUser result", result);	
getcurrentuser 

public void testGetUserEmailAlias() throws Exception {	final java.util.Collection result = requestBody("direct: assertNotNull("getUserEmailAlias result", result);	
getuseremailalias 

public void testGetUserInfo() throws Exception {	final com.box.sdk.BoxUser.Info result = requestBody("direct: assertNotNull("getUserInfo result", result);	
getuserinfo 

public void testUpdateUserInfo() throws Exception {	BoxUser.Info info = testUser.getInfo();	info.setJobTitle(CAMEL_TEST_USER_JOB_TITLE);	try {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.userId", testUser.getID());	headers.put("CamelBox.info", info);	final com.box.sdk.BoxUser result = requestBodyAndHeaders("direct: assertNotNull("updateUserInfo result", result);	
updateuserinfo 

========================= camel sample_17408 =========================

public Exchange add(final CamelContext camelContext, final String key, final Exchange exchange) {	
adding key 

public Exchange add(final CamelContext camelContext, final String key, final Exchange exchange) {	try {	byte[] lDbKey = keyBuilder(repositoryName, key);	final Buffer exchangeBuffer = codec.marshallExchange(camelContext, exchange, allowSerializedHeaders);	byte[] rc = null;	if (isReturnOldExchange()) {	rc = levelDBFile.getDb().get(lDbKey);	}	
adding key index for repository 

public Exchange add(final CamelContext camelContext, final String key, final Exchange exchange) {	try {	byte[] lDbKey = keyBuilder(repositoryName, key);	final Buffer exchangeBuffer = codec.marshallExchange(camelContext, exchange, allowSerializedHeaders);	byte[] rc = null;	if (isReturnOldExchange()) {	rc = levelDBFile.getDb().get(lDbKey);	}	levelDBFile.getDb().put(lDbKey, exchangeBuffer.toByteArray(), levelDBFile.getWriteOptions());	
added key index 

public Exchange get(final CamelContext camelContext, final String key) {	Exchange answer = null;	try {	byte[] lDbKey = keyBuilder(repositoryName, key);	
getting key index 

Exchange answer = null;	try {	byte[] lDbKey = keyBuilder(repositoryName, key);	byte[] rc = levelDBFile.getDb().get(lDbKey);	if (rc != null) {	answer = codec.unmarshallExchange(camelContext, new Buffer(rc));	}	} catch (IOException e) {	throw new RuntimeException("Error getting key " + key + " from repository " + repositoryName, e);	}	
getting key 

public void remove(final CamelContext camelContext, final String key, final Exchange exchange) {	
removing key 

public void remove(final CamelContext camelContext, final String key, final Exchange exchange) {	try {	byte[] lDbKey = keyBuilder(repositoryName, key);	final String exchangeId = exchange.getExchangeId();	final Buffer exchangeBuffer = codec.marshallExchange(camelContext, exchange, allowSerializedHeaders);	byte[] rc = levelDBFile.getDb().get(lDbKey);	if (rc != null) {	WriteBatch batch = levelDBFile.getDb().createWriteBatch();	try {	batch.delete(lDbKey);	
removed key index 

byte[] lDbKey = keyBuilder(repositoryName, key);	final String exchangeId = exchange.getExchangeId();	final Buffer exchangeBuffer = codec.marshallExchange(camelContext, exchange, allowSerializedHeaders);	byte[] rc = levelDBFile.getDb().get(lDbKey);	if (rc != null) {	WriteBatch batch = levelDBFile.getDb().createWriteBatch();	try {	batch.delete(lDbKey);	byte[] confirmedLDBKey = keyBuilder(getRepositoryNameCompleted(), exchangeId);	batch.put(confirmedLDBKey, exchangeBuffer.toByteArray());	
added confirm index for repository 

public void confirm(final CamelContext camelContext, final String exchangeId) {	
confirming exchangeid 

public void confirm(final CamelContext camelContext, final String exchangeId) {	byte[] confirmedLDBKey = keyBuilder(getRepositoryNameCompleted(), exchangeId);	byte[] rc = levelDBFile.getDb().get(confirmedLDBKey);	if (rc != null) {	levelDBFile.getDb().delete(confirmedLDBKey);	
removed confirm index 

String prefix = repositoryName + '\0';	for (it.seek(keyBuilder(repositoryName, "")); it.hasNext(); it.next()) {	if (!isRunAllowed()) {	break;	}	keyBuffer = asString(it.peekNext().getKey());	if (!keyBuffer.startsWith(prefix)) {	break;	}	String key = keyBuffer.substring(prefix.length());	
getkey 

DBIterator it = levelDBFile.getDb().iterator();	String keyBuffer;	try {	String prefix = getRepositoryNameCompleted() + '\0';	for (it.seek(keyBuilder(getRepositoryNameCompleted(), "")); it.hasNext(); it.next()) {	keyBuffer = asString(it.peekNext().getKey());	if (!keyBuffer.startsWith(prefix)) {	break;	}	String exchangeId = keyBuffer.substring(prefix.length());	
scan exchangeid 

if (!keyBuffer.startsWith(prefix)) {	break;	}	String exchangeId = keyBuffer.substring(prefix.length());	answer.add(exchangeId);	}	} finally {	IOHelper.close(it);	}	if (answer.size() == 0) {	
scanned and found no exchange to recover 

}	String exchangeId = keyBuffer.substring(prefix.length());	answer.add(exchangeId);	}	} finally {	IOHelper.close(it);	}	if (answer.size() == 0) {	} else {	if (LOG.isDebugEnabled()) {	
scanned and found exchange s to recover note some of them may already be in progress 

Exchange answer = null;	try {	byte[] completedLDBKey = keyBuilder(getRepositoryNameCompleted(), exchangeId);	byte[] rc = levelDBFile.getDb().get(completedLDBKey);	if (rc != null) {	answer = codec.unmarshallExchange(camelContext, new Buffer(rc));	}	} catch (IOException e) {	throw new RuntimeException("Error recovering exchangeId " + exchangeId + " from repository " + repositoryName, e);	}	
recovering exchangeid 

try {	for (it.seek(keyBuilder(repositoryName, "")); it.hasNext(); it.next()) {	if (!asString(it.peekNext().getKey()).startsWith(prefix)) {	break;	}	count++;	}	} finally {	IOHelper.close(it);	}	
size of repository 

levelDBFile = new LevelDBFile();	levelDBFile.setSync(isSync());	levelDBFile.setFileName(persistentFileName);	}	ObjectHelper.notNull(levelDBFile, "Either set a persistentFileName or a levelDBFile");	ObjectHelper.notNull(repositoryName, "repositoryName");	ServiceHelper.startService(levelDBFile);	int current = size(getRepositoryName());	int completed = size(getRepositoryNameCompleted());	if (current > 0) {	
on startup there are aggregate exchanges not completed in repository 

levelDBFile.setSync(isSync());	levelDBFile.setFileName(persistentFileName);	}	ObjectHelper.notNull(levelDBFile, "Either set a persistentFileName or a levelDBFile");	ObjectHelper.notNull(repositoryName, "repositoryName");	ServiceHelper.startService(levelDBFile);	int current = size(getRepositoryName());	int completed = size(getRepositoryNameCompleted());	if (current > 0) {	} else {	
on startup there are no existing aggregate exchanges not completed in repository 

}	ObjectHelper.notNull(levelDBFile, "Either set a persistentFileName or a levelDBFile");	ObjectHelper.notNull(repositoryName, "repositoryName");	ServiceHelper.startService(levelDBFile);	int current = size(getRepositoryName());	int completed = size(getRepositoryNameCompleted());	if (current > 0) {	} else {	}	if (completed > 0) {	
on startup there are completed exchanges to be recovered in repository 

ObjectHelper.notNull(levelDBFile, "Either set a persistentFileName or a levelDBFile");	ObjectHelper.notNull(repositoryName, "repositoryName");	ServiceHelper.startService(levelDBFile);	int current = size(getRepositoryName());	int completed = size(getRepositoryNameCompleted());	if (current > 0) {	} else {	}	if (completed > 0) {	} else {	
on startup there are no completed exchanges to be recovered in repository 

========================= camel sample_13918 =========================

public void start() throws Exception {	if (isStarting() || isStarted()) {	
service already started 

public void start() throws Exception {	if (isStarting() || isStarted()) {	return;	}	if (starting.compareAndSet(false, true)) {	
starting service 

public void stop() throws Exception {	if (isStopped()) {	
service already stopped 

public void stop() throws Exception {	if (isStopped()) {	return;	}	if (isStopping()) {	
service already stopping 

public void shutdown() throws Exception {	if (shutdown.get()) {	
service already shut down 

========================= camel sample_5164 =========================

public void process(Exchange exchange) throws Exception {	
process exchange in the sync way 

methodName = endpoint.getDefaultMethodName();	}	if (ObjectHelper.isEmpty(methodName)) {	throw new IllegalArgumentException("CamelXmlRpcMethodName header is empty, please set the message header or defaultMethodName option on the endpoint.");	}	try {	Object result = client.execute(methodName, in.getBody(List.class));	exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());	exchange.getOut().setBody(result);	} catch (Exception ex) {	
got an exception when invoke the xmlrpc service 

public boolean process(Exchange exchange, AsyncCallback callback) {	
process exchange in the async way 

========================= camel sample_17326 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<JMXComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jmx.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jmx.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_781 =========================

protected ConnectionResource createConnectionResource(Object source) {	if (getConnectionFactory() == null) {	throw new IllegalArgumentException(String.format("ConnectionResource or ConnectionFactory must be configured for %s", this));	}	try {	
creating connectionresource with connectioncount using connectionfactory 

========================= camel sample_12431 =========================

retryRequest(origRequest, client, retries, conversation, true);	return;	}	final int status = response.getStatus();	final String reason = response.getReason();	if (retries >= maxAuthenticationRetries) {	forwardSuccessComplete(request, response);	return;	}	if (status == HttpStatus.UNAUTHORIZED_401) {	
retrying on salesforce authentication error 

if (retries >= maxAuthenticationRetries) {	forwardSuccessComplete(request, response);	return;	}	if (status == HttpStatus.UNAUTHORIZED_401) {	retryLogin(request, retries);	} else if (status < HttpStatus.OK_200 || status >= HttpStatus.MULTIPLE_CHOICES_300) {	final InputStream inputStream = getContent().length == 0 ? null : getContentAsInputStream();	final SalesforceException cause = client != null ? client.createRestException(response, inputStream) : null;	if (status == HttpStatus.BAD_REQUEST_400 && cause != null && isInvalidSessionError(cause)) {	
retrying on bulk api salesforce authentication error 

protected void retryOnFailure(SalesforceHttpRequest request, HttpConversation conversation, Integer retries, AbstractClientBase client, Throwable failure) {	
retrying on salesforce authentication failure 

========================= camel sample_14766 =========================

public void testFileToCxfMessageDataFormat() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(1);	template.sendBodyAndHeader("file:target/filetocxf", createBody(), Exchange.FILE_NAME, "payload.xml");	assertMockEndpointsSatisfied();	String out = mock.getReceivedExchanges().get(0).getIn().getBody(String.class);	assertNotNull(out);	
reply payload as a string 

========================= camel sample_7948 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<ThriftDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.thrift.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.thrift.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_1035 =========================

protected void setUp() throws Exception {	utf = "ABC\u00e6".getBytes("utf-8");	iso = "ABC\u00e6".getBytes("iso-8859-1");	deleteDirectory("target/charset");	createDirectory("target/charset/input");	
utf utf 

protected void setUp() throws Exception {	utf = "ABC\u00e6".getBytes("utf-8");	iso = "ABC\u00e6".getBytes("iso-8859-1");	deleteDirectory("target/charset");	createDirectory("target/charset/input");	
iso iso 

protected void setUp() throws Exception {	utf = "ABC\u00e6".getBytes("utf-8");	iso = "ABC\u00e6".getBytes("iso-8859-1");	deleteDirectory("target/charset");	createDirectory("target/charset/input");	for (byte b : utf) {	
utf byte 

protected void setUp() throws Exception {	utf = "ABC\u00e6".getBytes("utf-8");	iso = "ABC\u00e6".getBytes("iso-8859-1");	deleteDirectory("target/charset");	createDirectory("target/charset/input");	for (byte b : utf) {	}	for (byte b : iso) {	
iso byte 

========================= camel sample_3008 =========================

private void doInsert(Exchange exchange, String dataBaseName, String retentionPolicy) throws InvalidPayloadException {	if (!endpoint.isBatch()) {	Point p = exchange.getIn().getMandatoryBody(Point.class);	try {	
writing point 

private void doInsert(Exchange exchange, String dataBaseName, String retentionPolicy) throws InvalidPayloadException {	if (!endpoint.isBatch()) {	Point p = exchange.getIn().getMandatoryBody(Point.class);	try {	if (!connection.databaseExists(dataBaseName)) {	
database doesn t exist creating it 

if (!connection.databaseExists(dataBaseName)) {	connection.createDatabase(dataBaseName);	}	connection.write(dataBaseName, retentionPolicy, p);	} catch (Exception ex) {	exchange.setException(new CamelInfluxDbException(ex));	}	} else {	BatchPoints batchPoints = exchange.getIn().getMandatoryBody(BatchPoints.class);	try {	
writing batchpoints 

========================= camel sample_11134 =========================

protected CamelContext createCamelContext() throws Exception {	SimpleRegistry registry = new SimpleRegistry();	registry.put("testStrategy", new ListAggregationStrategy());	CamelContext camel = new DefaultCamelContext(registry);	SjmsBatchComponent sjms = new SjmsBatchComponent();	sjms.setAsyncStartListener(true);	
using live connection to existing activemq broker running on 

========================= camel sample_12348 =========================

} else if (message instanceof quickfix.fix42.NewOrderSingle) {	onMessage((quickfix.fix42.NewOrderSingle) message, sessionID);	} else if (message instanceof quickfix.fix43.NewOrderSingle) {	onMessage((quickfix.fix43.NewOrderSingle) message, sessionID);	} else if (message instanceof quickfix.fix44.NewOrderSingle) {	onMessage((quickfix.fix44.NewOrderSingle) message, sessionID);	} else if (message instanceof quickfix.fix50.NewOrderSingle) {	onMessage((quickfix.fix50.NewOrderSingle) message, sessionID);	}	} catch (Exception e) {	
error submitting execution task 

private void validateOrder(Message order) throws IncorrectTagValue, FieldNotFound {	OrdType ordType = new OrdType(order.getChar(OrdType.FIELD));	if (!validOrderTypes.contains(Character.toString(ordType.getValue()))) {	
order type not in validordertypes setting 

private void validateOrder(Message order) throws IncorrectTagValue, FieldNotFound {	OrdType ordType = new OrdType(order.getChar(OrdType.FIELD));	if (!validOrderTypes.contains(Character.toString(ordType.getValue()))) {	throw new IncorrectTagValue(ordType.getField());	}	if (ordType.getValue() == OrdType.MARKET && marketQuoteProvider == null) {	
defaultmarketprice setting not specified for market order 

========================= camel sample_10660 =========================

public void testRouteboxUsingDefaultContextAndRouteBuilder() throws Exception {	template = new DefaultProducerTemplate(context);	template.start();	context.addRoutes(new RouteBuilder() {	public void configure() {	from(routeboxUri) .to("log:Routes operation performed?showAll=true");	}	});	context.start();	
beginning test testrouteboxusingdefaultcontextandroutebuilder 

context.addRoutes(new RouteBuilder() {	public void configure() {	from(routeboxUri) .to("log:Routes operation performed?showAll=true");	}	});	context.start();	Book book = new Book("Sir Arthur Conan Doyle", "The Adventures of Sherlock Holmes");	String response = sendAddToCatalogRequest(template, routeboxUri, "addToCatalog", book);	assertEquals("Book with Author " + book.getAuthor() + " and title " + book.getTitle() + " added to Catalog", response);	book = sendFindBookRequest(template, routeboxUri, "findBook", "Sir Arthur Conan Doyle");	
received book with author and title 

public void configure() {	from(routeboxUri) .to("log:Routes operation performed?showAll=true");	}	});	context.start();	Book book = new Book("Sir Arthur Conan Doyle", "The Adventures of Sherlock Holmes");	String response = sendAddToCatalogRequest(template, routeboxUri, "addToCatalog", book);	assertEquals("Book with Author " + book.getAuthor() + " and title " + book.getTitle() + " added to Catalog", response);	book = sendFindBookRequest(template, routeboxUri, "findBook", "Sir Arthur Conan Doyle");	assertEquals("The Adventures of Sherlock Holmes", book.getTitle());	
completed test testrouteboxusingdefaultcontextandroutebuilder 

========================= camel sample_14623 =========================

public void eventReceived(Object event) {	if (eventClass == null || eventClass.isAssignableFrom(event.getClass())) {	doEventReceived(event);	} else {	if (log.isDebugEnabled()) {	
cannot process event as its class type is not assignable with 

========================= camel sample_9110 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<IgniteQueueComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ignite-queue.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ignite-queue.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1170 =========================

public void notify(EventObject event) throws Exception {	
event 

========================= camel sample_4688 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<TwitterSearchComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.twitter-search.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.twitter-search.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_778 =========================

Message message = exchange.getIn();	message.setHeader(JCacheConstants.EVENT_TYPE, event.getEventType().name());	message.setHeader(JCacheConstants.KEY, event.getKey());	message.setBody(event.getValue());	if (event.isOldValueAvailable()) {	message.setHeader(JCacheConstants.OLD_VALUE, event.getOldValue());	}	try {	getProcessor().process(exchange);	} catch (Exception e) {	
error processing event 

========================= camel sample_12562 =========================

public static synchronized int getNextAvailable(int fromPort) {	if (fromPort < currentMinPort.get() || fromPort > MAX_PORT_NUMBER) {	throw new IllegalArgumentException("From port number not in valid range: " + fromPort);	}	for (int i = fromPort; i <= MAX_PORT_NUMBER; i++) {	if (available(i)) {	
getnextavailable 

========================= camel sample_6836 =========================

public void viewAccepted(View view) {	if (endpoint.isEnableViewMessages()) {	Exchange exchange = endpoint.createExchange(view);	try {	
processing view 

Exchange exchange = endpoint.createExchange(view);	try {	processor.process(exchange, new AsyncCallback() {	public void done(boolean doneSync) {	}	});	} catch (Exception e) {	throw new JGroupsException("Error in consumer while dispatching exchange containing view " + view, e);	}	} else {	
option enableviewmessages is set to false skipping processing of the view 

public void receive(Message message) {	Exchange exchange = endpoint.createExchange(message);	try {	
processing message 

========================= camel sample_16937 =========================

public void testJettyAsync() throws Exception {	getMockEndpoint("mock:result").expectedMessageCount(5);	template.asyncRequestBody("jetty:http: template.asyncRequestBody("jetty:http: template.asyncRequestBody("jetty:http: template.asyncRequestBody("jetty:http: template.asyncRequestBody("jetty:http: assertMockEndpointsSatisfied();	for (int i = 0; i < 5; i++) {	Exchange exchange = getMockEndpoint("mock:result").getReceivedExchanges().get(i);	
reply 

========================= camel sample_10949 =========================

public void onNext(Statistics statistics) {	
received docker statistics event 

public void onNext(Statistics statistics) {	final Exchange exchange = getEndpoint().createExchange();	Message message = exchange.getIn();	message.setBody(statistics);	try {	
processing exchange 

public void onNext(Statistics statistics) {	final Exchange exchange = getEndpoint().createExchange();	Message message = exchange.getIn();	message.setBody(statistics);	try {	getAsyncProcessor().process(exchange, new AsyncCallback() {	public void done(boolean doneSync) {	
done processing exchange 

========================= camel sample_6565 =========================

public void process(Exchange exchange) throws Exception {	NatsConfiguration config = getEndpoint().getNatsConfiguration();	String body = exchange.getIn().getMandatoryBody(String.class);	
publishing to topic 

protected void doStart() throws Exception {	super.doStart();	
starting nats producer 

protected void doStart() throws Exception {	super.doStart();	
getting nats connection 

protected void doStop() throws Exception {	super.doStop();	
stopping nats producer 

protected void doStop() throws Exception {	super.doStop();	
closing nats connection 

protected void doStop() throws Exception {	super.doStop();	if (connection != null && !connection.isClosed()) {	if (getEndpoint().getNatsConfiguration().isFlushConnection()) {	
flushing nats connection 

========================= camel sample_12974 =========================

public void testOverloadingTheHandlerOnASingleRoute() throws Exception {	RouteBuilder builder = new RouteBuilder() {	public void configure() {	
seda a com mycompany foo seda b 

public void configure() {	
seda a foo bar seda b 

========================= camel sample_3767 =========================

protected void doStart() throws Exception {	super.doStart();	this.targetAddress = GenericAddress.parse(this.endpoint.getAddress());	
targetaddress 

public void process(final Exchange exchange) throws Exception {	Snmp snmp = null;	TransportMapping<? extends Address> transport = null;	try {	
starting snmp trap producer on 

TransportMapping<? extends Address> transport = null;	try {	if ("tcp".equals(this.endpoint.getProtocol())) {	transport = new DefaultTcpTransportMapping();	} else if ("udp".equals(this.endpoint.getProtocol())) {	transport = new DefaultUdpTransportMapping();	} else {	throw new IllegalArgumentException("Unknown protocol: {} " + this.endpoint.getProtocol());	}	snmp = new Snmp(transport);	
snmptrap getting pdu from body 

snmp = new Snmp(transport);	PDU trap = exchange.getIn().getBody(PDU.class);	trap.setErrorIndex(0);	trap.setErrorStatus(0);	trap.setMaxRepetitions(0);	if (this.endpoint.getSnmpVersion() == SnmpConstants.version1) {	trap.setType(PDU.V1TRAP);	} else {	trap.setType(PDU.TRAP);	}	
snmptrap sending 

PDU trap = exchange.getIn().getBody(PDU.class);	trap.setErrorIndex(0);	trap.setErrorStatus(0);	trap.setMaxRepetitions(0);	if (this.endpoint.getSnmpVersion() == SnmpConstants.version1) {	trap.setType(PDU.V1TRAP);	} else {	trap.setType(PDU.TRAP);	}	snmp.send(trap, this.target);	
snmptrap sent 

========================= camel sample_8828 =========================

protected void executeComponents(Set<String> starters) throws MojoExecutionException, MojoFailureException {	
copying all camel component json descriptors 

}	findComponentFilesRecursive(target, jsonFiles, componentFiles, new CamelComponentsFileFilter());	}	}	}	}	if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes");	findComponentFilesRecursive(target, jsonFiles, componentFiles, new CamelComponentsFileFilter());	}	
found component properties files 

}	findComponentFilesRecursive(target, jsonFiles, componentFiles, new CamelComponentsFileFilter());	}	}	}	}	if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes");	findComponentFilesRecursive(target, jsonFiles, componentFiles, new CamelComponentsFileFilter());	}	
found component json files 

protected void executeDataFormats(Set<String> starters) throws MojoExecutionException, MojoFailureException {	
copying all camel dataformat json descriptors 

File target = new File(dir, "target/classes");	findDataFormatFilesRecursive(target, jsonFiles, dataFormatFiles, new CamelDataFormatsFileFilter());	}	}	}	}	if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes");	findDataFormatFilesRecursive(target, jsonFiles, dataFormatFiles, new CamelDataFormatsFileFilter());	}	
found dataformat properties files 

File target = new File(dir, "target/classes");	findDataFormatFilesRecursive(target, jsonFiles, dataFormatFiles, new CamelDataFormatsFileFilter());	}	}	}	}	if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes");	findDataFormatFilesRecursive(target, jsonFiles, dataFormatFiles, new CamelDataFormatsFileFilter());	}	
found dataformat json files 

protected void executeLanguages(Set<String> starters) throws MojoExecutionException, MojoFailureException {	
copying all camel language json descriptors 

File target = new File(dir, "target/classes");	findLanguageFilesRecursive(target, jsonFiles, languageFiles, new CamelLanguagesFileFilter());	}	}	}	}	if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes");	findLanguageFilesRecursive(target, jsonFiles, languageFiles, new CamelLanguagesFileFilter());	}	
found language properties files 

File target = new File(dir, "target/classes");	findLanguageFilesRecursive(target, jsonFiles, languageFiles, new CamelLanguagesFileFilter());	}	}	}	}	if (coreDir != null && coreDir.isDirectory()) {	File target = new File(coreDir, "target/classes");	findLanguageFilesRecursive(target, jsonFiles, languageFiles, new CamelLanguagesFileFilter());	}	
found language json files 

protected void executeOthers(Set<String> starters) throws MojoExecutionException, MojoFailureException {	
copying all camel other json descriptors 

if (special || special2) {	continue;	}	if (dir.isDirectory() && !"target".equals(dir.getName())) {	File target = new File(dir, "target/classes");	findOtherFilesRecursive(target, jsonFiles, otherFiles, new CamelOthersFileFilter());	}	}	}	}	
found other properties files 

if (special || special2) {	continue;	}	if (dir.isDirectory() && !"target".equals(dir.getName())) {	File target = new File(dir, "target/classes");	findOtherFilesRecursive(target, jsonFiles, otherFiles, new CamelOthersFileFilter());	}	}	}	}	
found other json files 

========================= camel sample_144 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<TestComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.test.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.test.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_847 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<LinkedInComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.linkedin.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.linkedin.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1023 =========================

protected RouteBuilder createRouteBuilder() {	return new RouteBuilder() {	public void configure() {	from(String.format("mina2:tcp: public void process(Exchange e) throws InterruptedException {	
enter processor 

protected RouteBuilder createRouteBuilder() {	return new RouteBuilder() {	public void configure() {	from(String.format("mina2:tcp: public void process(Exchange e) throws InterruptedException {	assertNotNull(e.getIn().getBody());	
enter processor 

protected RouteBuilder createRouteBuilder() {	return new RouteBuilder() {	public void configure() {	from(String.format("mina2:tcp: public void process(Exchange e) throws InterruptedException {	assertNotNull(e.getIn().getBody());	assertNotNull(e.getIn().getHeaders());	
enter processor 

protected RouteBuilder createRouteBuilder() {	return new RouteBuilder() {	public void configure() {	from(String.format("mina2:tcp: public void process(Exchange e) throws InterruptedException {	assertNotNull(e.getIn().getBody());	assertNotNull(e.getIn().getHeaders());	assertNotNull(e.getProperties());	
enter processor 

protected RouteBuilder createRouteBuilder() {	return new RouteBuilder() {	public void configure() {	from(String.format("mina2:tcp: public void process(Exchange e) throws InterruptedException {	assertNotNull(e.getIn().getBody());	assertNotNull(e.getIn().getHeaders());	assertNotNull(e.getProperties());	assertEquals("Hello!", e.getIn().getBody());	
enter processor 

protected RouteBuilder createRouteBuilder() {	return new RouteBuilder() {	public void configure() {	from(String.format("mina2:tcp: public void process(Exchange e) throws InterruptedException {	assertNotNull(e.getIn().getBody());	assertNotNull(e.getIn().getHeaders());	assertNotNull(e.getProperties());	assertEquals("Hello!", e.getIn().getBody());	assertEquals("feta", e.getIn().getHeader("cheese"));	
enter processor 

protected RouteBuilder createRouteBuilder() {	return new RouteBuilder() {	public void configure() {	from(String.format("mina2:tcp: public void process(Exchange e) throws InterruptedException {	assertNotNull(e.getIn().getBody());	assertNotNull(e.getIn().getHeaders());	assertNotNull(e.getProperties());	assertEquals("Hello!", e.getIn().getBody());	assertEquals("feta", e.getIn().getHeader("cheese"));	assertEquals("old", e.getProperty("ham"));	
enter processor 

return new RouteBuilder() {	public void configure() {	from(String.format("mina2:tcp: public void process(Exchange e) throws InterruptedException {	assertNotNull(e.getIn().getBody());	assertNotNull(e.getIn().getHeaders());	assertNotNull(e.getProperties());	assertEquals("Hello!", e.getIn().getBody());	assertEquals("feta", e.getIn().getHeader("cheese"));	assertEquals("old", e.getProperty("ham"));	assertEquals(ExchangePattern.InOut, e.getPattern());	
enter processor 

if (setException) {	e.getOut().setFault(true);	e.getOut().setBody(new InterruptedException());	e.getOut().setHeader("hello", "nihao");	} else {	e.getOut().setBody("Goodbye!");	e.getOut().setHeader("cheese", "cheddar");	}	e.setProperty("salami", "fresh");	e.setProperty("Charset", Charset.defaultCharset());	
exit processor 

========================= camel sample_11572 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<TokenizeLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.tokenize.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.tokenize.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_902 =========================

public void doEventReceived(Object event) {	
received event 

public void doEventReceived(Object event) {	final Exchange exchange = eventBusEndpoint.createExchange(event);	
processing event 

========================= camel sample_9106 =========================

protected ChangeModel createChangeModel() {	if (ServerInstance.this.options.getBufferingPeriod() != null && ServerInstance.this.options.getBufferingPeriod() > 0) {	
creating buffering change model ms 

protected ChangeModel createChangeModel() {	if (ServerInstance.this.options.getBufferingPeriod() != null && ServerInstance.this.options.getBufferingPeriod() > 0) {	return makeBufferingChangeModel(ServerInstance.this.options.getBufferingPeriod());	} else {	
creating instant change model 

protected BackgroundModel createBackgroundModel() {	if (ServerInstance.this.options.getBackgroundScanPeriod() > 0) {	
creating background scan model ms 

protected BackgroundModel createBackgroundModel() {	if (ServerInstance.this.options.getBackgroundScanPeriod() > 0) {	return makeDefaultBackgroundModel();	}	
not creating background scan model 

========================= camel sample_6709 =========================

public void testWSHttpCall() throws Exception {	AsyncHttpClient c = createAsyncHttpSSLClient();	WebSocket websocket = c.prepareGet("wss: new WebSocketUpgradeHandler.Builder() .addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

========================= camel sample_17449 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<MongoDbComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mongodb.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mongodb.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_451 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<HazelcastSedaComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-seda.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-seda.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_685 =========================

protected void doGetDeployment(Exchange exchange, String operation) throws Exception {	Deployment deployment = null;	String deploymentName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_DEPLOYMENT_NAME, String.class);	if (ObjectHelper.isEmpty(deploymentName)) {	
get a specific deployment require specify a deployment name 

protected void doDeleteDeployment(Exchange exchange, String operation) {	String deploymentName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_DEPLOYMENT_NAME, String.class);	String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(deploymentName)) {	
delete a specific deployment require specify a deployment name 

protected void doDeleteDeployment(Exchange exchange, String operation) {	String deploymentName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_DEPLOYMENT_NAME, String.class);	String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(deploymentName)) {	throw new IllegalArgumentException("Delete a specific deployment require specify a deployment name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
delete a specific deployment require specify a namespace name 

protected void doCreateDeployment(Exchange exchange, String operation) throws Exception {	Deployment deployment = null;	String deploymentName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_DEPLOYMENT_NAME, String.class);	String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	DeploymentSpec deSpec = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_DEPLOYMENT_SPEC, DeploymentSpec.class);	if (ObjectHelper.isEmpty(deploymentName)) {	
create a specific deployment require specify a deployment name 

protected void doCreateDeployment(Exchange exchange, String operation) throws Exception {	Deployment deployment = null;	String deploymentName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_DEPLOYMENT_NAME, String.class);	String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	DeploymentSpec deSpec = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_DEPLOYMENT_SPEC, DeploymentSpec.class);	if (ObjectHelper.isEmpty(deploymentName)) {	throw new IllegalArgumentException("Create a specific pod require specify a pod name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
create a specific pod require specify a namespace name 

String deploymentName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_DEPLOYMENT_NAME, String.class);	String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	DeploymentSpec deSpec = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_DEPLOYMENT_SPEC, DeploymentSpec.class);	if (ObjectHelper.isEmpty(deploymentName)) {	throw new IllegalArgumentException("Create a specific pod require specify a pod name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	throw new IllegalArgumentException("Create a specific pod require specify a namespace name");	}	if (ObjectHelper.isEmpty(deSpec)) {	
create a specific deployment require specify a deployment spec bean 

========================= camel sample_13324 =========================

public String greetMe(String me) {	
executing operation greetme 

public String greetMe(String me) {	
executing operation greetme 

public String greetMe(String me) {	
message received 

public void greetMeOneWay(String me) {	
executing operation greetmeoneway 

public void greetMeOneWay(String me) {	
executing operation greetmeoneway 

public void greetMeOneWay(String me) {	
hello there 

public String sayHi() {	
executing operation sayhi 

public String sayHi() {	
executing operation sayhi 

public void pingMe(String messageIn) throws PingMeFault {	FaultDetail faultDetail = new FaultDetail();	faultDetail.setMajor((short)2);	faultDetail.setMinor((short)1);	LOG.info("Executing operation pingMe, throwing PingMeFault exception, message = " + messageIn);	
executing operation pingme throwing pingmefault exception 

========================= camel sample_6027 =========================

private EhcacheManager createCacheManager(EhcacheConfiguration configuration) throws IOException {	ObjectHelper.notNull(configuration, "Camel Ehcache configuration");	if (configuration.hasCacheManager()) {	
ehcachemanager configured with supplied cachemanager 

private EhcacheManager createCacheManager(EhcacheConfiguration configuration) throws IOException {	ObjectHelper.notNull(configuration, "Camel Ehcache configuration");	if (configuration.hasCacheManager()) {	return managers.computeIfAbsent( configuration.getCacheManager(), m -> new EhcacheManager( CacheManager.class.cast(m), false, configuration) );	}	if (configuration.hasCacheManagerConfiguration()) {	
ehcachemanager configured with supplied cachemanagerconfiguration 

if (configuration.hasCacheManager()) {	return managers.computeIfAbsent( configuration.getCacheManager(), m -> new EhcacheManager( CacheManager.class.cast(m), false, configuration) );	}	if (configuration.hasCacheManagerConfiguration()) {	return managers.computeIfAbsent( configuration.getCacheManagerConfiguration(), c -> new EhcacheManager( CacheManagerBuilder.newCacheManager(Configuration.class.cast(c)), true, configuration ) );	}	if (configuration.hasConfigurationUri()) {	String configurationUri = configuration.getConfigurationUri();	ClassResolver classResolver = getCamelContext().getClassResolver();	URL url = ResourceHelper.resolveMandatoryResourceAsUrl(classResolver, configurationUri);	
ehcachemanager configured with supplied uri 

}	if (configuration.hasCacheManagerConfiguration()) {	return managers.computeIfAbsent( configuration.getCacheManagerConfiguration(), c -> new EhcacheManager( CacheManagerBuilder.newCacheManager(Configuration.class.cast(c)), true, configuration ) );	}	if (configuration.hasConfigurationUri()) {	String configurationUri = configuration.getConfigurationUri();	ClassResolver classResolver = getCamelContext().getClassResolver();	URL url = ResourceHelper.resolveMandatoryResourceAsUrl(classResolver, configurationUri);	return managers.computeIfAbsent( url, u -> new EhcacheManager( CacheManagerBuilder.newCacheManager(new XmlConfiguration(URL.class.cast(u))), true, configuration ) );	}	
ehcachemanager configured with default builder 

========================= camel sample_9628 =========================

public void process(Exchange exchange) throws Exception {	Regions regions = getEndpoint().getDigitalOceanClient().getAvailableRegions(configuration.getPage());	
all regions page 

========================= camel sample_8890 =========================

public void handleEvent(Event event) {	Exchange exchange = endpoint.createExchange();	exchange.getIn().setBody(event);	
eventadmin is firing 

========================= camel sample_12866 =========================

public void testGet() throws Exception {	final com.google.api.services.calendar.model.Setting result = requestBody("direct: assertNotNull("get result", result);	
get 

public void testList() throws Exception {	final com.google.api.services.calendar.model.Settings result = requestBody("direct: assertNotNull("list result", result);	
list 

========================= camel sample_11749 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("direct:start") .inOut("activemq:queue:foo?replyTo=queue:bar&requestTimeout=2000") .to("mock:result");	from("activemq:queue:foo") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String body = exchange.getIn().getBody(String.class);	if ("World".equals(body)) {	
sleeping for sec to force a timeout 

========================= camel sample_6861 =========================

String name = exchange.getIn().getHeader(OpenShiftConstants.APPLICATION, getEndpoint().getApplication(), String.class);	if (name == null) {	throw new CamelExchangeException("Application not specified", exchange);	}	IApplication app = domain.getApplicationByName(name);	if (app == null) {	throw new CamelExchangeException("Application with id " + name + " not found.", exchange);	} else {	ApplicationScale scale = app.getApplicationScale();	if (scale.getValue().equals(ApplicationScale.NO_SCALE.getValue())) {	
scaling on application with id is not enabled 

========================= camel sample_12020 =========================

if (oldExchange == null) {	return newExchange;	}	String body = oldExchange.getIn().getBody(String.class);	if (body != null) {	Message newIn = newExchange.getIn();	String newBody = newIn.getBody(String.class);	if (newBody != null) {	body += " " + newBody;	}	
invoked my strategy with result 

========================= camel sample_15835 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<QualifiedContextComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.context.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.context.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1074 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KubernetesNodesComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-nodes.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-nodes.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_543 =========================

public static SocketFactory getDefault() {	
camel is using dummysslsocketfactory as sslsocketfactory only to be used for testing purpose 

========================= camel sample_11876 =========================

protected int poll() throws Exception {	GetRecordsResult result;	try {	GetRecordsRequest req = new GetRecordsRequest() .withShardIterator(shardIteratorHandler.getShardIterator(null)) .withLimit(getEndpoint().getConfiguration().getMaxResultsPerRequest());	result = getClient().getRecords(req);	} catch (ExpiredIteratorException e) {	
expired shard iterator attempting to resume from 

public int processBatch(Queue<Object> exchanges) throws Exception {	int processedExchanges = 0;	while (!exchanges.isEmpty()) {	final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());	
processing exchange started 

public int processBatch(Queue<Object> exchanges) throws Exception {	int processedExchanges = 0;	while (!exchanges.isEmpty()) {	final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());	getAsyncProcessor().process(exchange, new AsyncCallback() {	public void done(boolean doneSync) {	
processing exchange done 

========================= camel sample_8740 =========================

public Instant deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException {	try {	Long unixTimestamp = Long.parseLong(jsonParser.getText());	return Instant.ofEpochSecond(unixTimestamp);	} catch (Exception e) {	
unable to deserialize the unix timestamp 

========================= camel sample_11933 =========================

public void process(Exchange exchange) throws Exception {	CmisObject cmisObject = createNode(exchange);	
created node with id 

private Folder storeFolder(Folder parentFolder, Map<String, Object> cmisProperties) throws Exception {	if (!cmisProperties.containsKey(PropertyIds.OBJECT_TYPE_ID)) {	cmisProperties.put(PropertyIds.OBJECT_TYPE_ID, CamelCMISConstants.CMIS_FOLDER);	}	
creating folder with properties 

private Document storeDocument(Folder parentFolder, Map<String, Object> cmisProperties, ContentStream contentStream) throws Exception {	if (!cmisProperties.containsKey(PropertyIds.OBJECT_TYPE_ID)) {	cmisProperties.put(PropertyIds.OBJECT_TYPE_ID, CamelCMISConstants.CMIS_DOCUMENT);	}	VersioningState versioningState = VersioningState.NONE;	if (getSessionFacade().isObjectTypeVersionable((String) cmisProperties.get(PropertyIds.OBJECT_TYPE_ID))) {	versioningState = VersioningState.MAJOR;	}	
creating document with properties 

========================= camel sample_9151 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<MQComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-mq.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-mq.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1131 =========================

protected List<Status> doDirect() throws TwitterException {	
dodirect gethometimeline 

========================= camel sample_14232 =========================

public void start(BundleContext context) throws Exception {	Activator.context = context;	
camel script activator starting 

public void start(BundleContext context) throws Exception {	Activator.context = context;	tracker = new BundleTracker(context, Bundle.ACTIVE, this);	tracker.open();	context.addServiceListener(this, "(&(resolver=default)(objectClass=org.apache.camel.spi.LanguageResolver))");	
camel script activator started 

public void stop(BundleContext context) throws Exception {	
camel script activator stopping 

public void stop(BundleContext context) throws Exception {	tracker.close();	context.removeServiceListener(this);	if (registration != null) {	registration.unregister();	}	
camel script activator stopped 

public void removedBundle(Bundle bundle, BundleEvent event, Object object) {	
bundle stopped 

registration.unregister();	registration = null;	}	ref = references.iterator().next();	LanguageResolver resolver = context.getService(ref);	Dictionary props = new Hashtable();	props.put("language", getAvailableScriptNames());	registration = context.registerService(LanguageResolver.class, resolver, props);	}	} catch (InvalidSyntaxException e) {	
invalid syntax for languageresolver service reference filter 

public static ScriptEngine resolveScriptEngine(String scriptEngineName) throws InvalidSyntaxException {	ServiceReference<?>[] refs = context.getServiceReferences(ScriptEngineResolver.class.getName(), null);	if (refs == null) {	
no osgi script engine resolvers available 

public static ScriptEngine resolveScriptEngine(String scriptEngineName) throws InvalidSyntaxException {	ServiceReference<?>[] refs = context.getServiceReferences(ScriptEngineResolver.class.getName(), null);	if (refs == null) {	return null;	}	
found osgi scriptengineresolver services 

public static ScriptEngine resolveScriptEngine(String scriptEngineName) throws InvalidSyntaxException {	ServiceReference<?>[] refs = context.getServiceReferences(ScriptEngineResolver.class.getName(), null);	if (refs == null) {	return null;	}	for (ServiceReference<?> ref : refs) {	ScriptEngineResolver resolver = (ScriptEngineResolver) context.getService(ref);	ScriptEngine engine = resolver.resolveScriptEngine(scriptEngineName);	context.ungetService(ref);	
osgi resolver produced engine 

protected void registerScriptEngines(Bundle bundle, List<BundleScriptEngineResolver> resolvers) {	try {	for (Enumeration<?> e = bundle.adapt(BundleWiring.class).getClassLoader().getResources(META_INF_SERVICES_DIR + "/" + SCRIPT_ENGINE_SERVICE_FILE); e != null && e.hasMoreElements();) {	URL configURL = (URL) e.nextElement();	
found scriptenginefactory in bundle 

protected void registerScriptEngines(Bundle bundle, List<BundleScriptEngineResolver> resolvers) {	try {	for (Enumeration<?> e = bundle.adapt(BundleWiring.class).getClassLoader().getResources(META_INF_SERVICES_DIR + "/" + SCRIPT_ENGINE_SERVICE_FILE); e != null && e.hasMoreElements();) {	URL configURL = (URL) e.nextElement();	resolvers.add(new BundleScriptEngineResolver(bundle, configURL));	}	} catch (IOException e) {	
error loading script engine factory 

break;	}	}	in.close();	Class<?> cls = bundle.loadClass(className);	if (!ScriptEngineFactory.class.isAssignableFrom(cls)) {	return null;	}	return (ScriptEngineFactory) cls.newInstance();	} catch (Exception e) {	
cannot create the scriptenginefactory 

for (String test : names) {	if (test.equals(name)) {	ClassLoader old = Thread.currentThread().getContextClassLoader();	ScriptEngine engine;	try {	Thread.currentThread().setContextClassLoader(factory.getClass().getClassLoader());	engine = factory.getScriptEngine();	} finally {	Thread.currentThread().setContextClassLoader(old);	}	
resolved scriptenginefactory for expected name 

ScriptEngine engine;	try {	Thread.currentThread().setContextClassLoader(factory.getClass().getClassLoader());	engine = factory.getScriptEngine();	} finally {	Thread.currentThread().setContextClassLoader(old);	}	return engine;	}	}	
scriptenginefactory does not match expected name 

engine = factory.getScriptEngine();	} finally {	Thread.currentThread().setContextClassLoader(old);	}	return engine;	}	}	return null;	}	} catch (Exception e) {	
cannot create scriptenginefactory 

========================= camel sample_11227 =========================

private void fetchSpecifiedDescriptions(final String[] includes, final String includePattern, final String[] excludes, final String excludePattern, final Log log) throws MojoExecutionException {	final ObjectMapper mapper = JsonUtils.createObjectMapper();	final Set<String> objectNames = new TreeSet<>();	final SyncResponseCallback callback = new SyncResponseCallback();	try {	
getting salesforce objects 

final GlobalObjects globalObjects = mapper.readValue(callback.getResponse(), GlobalObjects.class);	for (final SObject sObject : globalObjects.getSobjects()) {	objectNames.add(sObject.getName());	}	} catch (final Exception e) {	throw new MojoExecutionException("Error getting global Objects: " + e.getMessage(), e);	}	if (includes != null && includes.length > 0 || excludes != null && excludes.length > 0 || ObjectHelper.isNotEmpty(includePattern) || ObjectHelper.isNotEmpty(excludePattern)) {	filterObjectNames(objectNames, includes, includePattern, excludes, excludePattern, log);	} else {	
generating java classes for all s objects this may take a while 

for (final SObject sObject : globalObjects.getSobjects()) {	objectNames.add(sObject.getName());	}	} catch (final Exception e) {	throw new MojoExecutionException("Error getting global Objects: " + e.getMessage(), e);	}	if (includes != null && includes.length > 0 || excludes != null && excludes.length > 0 || ObjectHelper.isNotEmpty(includePattern) || ObjectHelper.isNotEmpty(excludePattern)) {	filterObjectNames(objectNames, includes, includePattern, excludes, excludePattern, log);	} else {	}	
retrieving object descriptions 

private static void filterObjectNames(final Set<String> objectNames, final String[] includes, final String includePattern, final String[] excludes, final String excludePattern, final Log log) throws MojoExecutionException {	
looking for matching object names 

excPattern = Defaults.MATCH_NOTHING_PATTERN;	}	final Set<String> acceptedNames = new HashSet<>();	for (final String name : objectNames) {	if ((includedNames.contains(name) || incPattern.matcher(name).matches()) && !excludedNames.contains(name) && !excPattern.matcher(name).matches()) {	acceptedNames.add(name);	}	}	objectNames.clear();	objectNames.addAll(acceptedNames);	
found s matching objects 

========================= camel sample_14926 =========================

public void testGuice() throws Exception {	Injector injector = Guice.createInjector(new CamelModuleWithMatchingRoutes());	Cheese cheese = injector.getInstance(Cheese.class);	assertNotNull("Should have cheese", cheese);	assertNotNull("Should have camelContext", cheese.getCamelContext());	
got 

========================= camel sample_8412 =========================

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyRouteEmptyUriTest.java"));	MethodSource<JavaClassSource> method = CamelJavaParserHelper.findConfigureMethod(clazz);	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, false);	for (ParserResult result : list) {	
consumer 

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyRouteEmptyUriTest.java"));	MethodSource<JavaClassSource> method = CamelJavaParserHelper.findConfigureMethod(clazz);	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, false);	for (ParserResult result : list) {	}	Assert.assertEquals("direct:foo", list.get(0).getElement());	list = CamelJavaParserHelper.parseCamelProducerUris(method, true, false);	Assert.assertEquals(1, list.size());	for (ParserResult result : list) {	
producer 

========================= camel sample_187 =========================

public void processEvent(ClientCacheEntryCreatedEvent<Object> event) {	
received clientevent 

public void processEvent(ClientCacheEntryModifiedEvent<Object> event) {	
received clientevent 

public void processEvent(ClientCacheEntryRemovedEvent<Object> event) {	
received clientevent 

public void processEvent(ClientCacheFailoverEvent event) {	
received clientevent 

public void processEvent(ClientCacheEntryExpiredEvent<Object> event) {	
received clientevent 

========================= camel sample_13975 =========================

public void process(final Exchange exchange) throws Exception {	Thread thread = new Thread() {	public void run() {	try {	
stopping camel 

public void process(final Exchange exchange) throws Exception {	Thread thread = new Thread() {	public void run() {	try {	exchange.getContext().stop();	
stopped camel complete 

========================= camel sample_3874 =========================

public void notify(EventObject event) throws Exception {	if (event instanceof CamelContextStartedEvent) {	CamelContext context = ((CamelContextStartedEvent) event).getContext();	registerCamelContext(context);	} else if (event instanceof CamelContextStoppingEvent) {	CamelContext context = ((CamelContextStoppingEvent) event).getContext();	ServiceRegistration<?> reg = registrations.remove(context);	if (reg != null) {	if (log.isDebugEnabled()) {	
unregistering camelcontext from osgi registry 

registerCamelContext(context);	} else if (event instanceof CamelContextStoppingEvent) {	CamelContext context = ((CamelContextStoppingEvent) event).getContext();	ServiceRegistration<?> reg = registrations.remove(context);	if (reg != null) {	if (log.isDebugEnabled()) {	}	try {	reg.unregister();	} catch (Exception e) {	
error unregistering camelcontext from osgi registry this exception will be ignored 

if (!lookupCamelContext(bundleContext, symbolicName, name)) {	Version bundleVersion = getBundleVersion(bundleContext.getBundle());	Dictionary<String, Object > props = new Hashtable<String, Object>();	props.put(CONTEXT_SYMBOLIC_NAME_PROPERTY, symbolicName);	props.put(CONTEXT_VERSION_PROPERTY, bundleVersion);	props.put(CONTEXT_NAME_PROPERTY, name);	if (managementName != null) {	props.put(CONTEXT_MANAGEMENT_NAME_PROPERTY, managementName);	}	if (log.isDebugEnabled()) {	
registering camelcontext of in osgi registry 

========================= camel sample_13076 =========================

public static void stopService(Object value) throws Exception {	if (isStopped(value)) {	
service already stopped 

public static void stopService(Object value) throws Exception {	if (isStopped(value)) {	return;	}	if (value instanceof Service) {	Service service = (Service)value;	
stopping service 

public static void stopServices(Collection<?> services) throws Exception {	if (services == null) {	return;	}	Exception firstException = null;	for (Object value : services) {	try {	stopService(value);	} catch (Exception e) {	if (LOG.isDebugEnabled()) {	
caught exception stopping service 

public static void stopAndShutdownService(Object value) throws Exception {	stopService(value);	if (value instanceof ShutdownableService) {	ShutdownableService service = (ShutdownableService)value;	
shutting down service 

public static void stopAndShutdownServices(Collection<?> services) throws Exception {	if (services == null) {	return;	}	Exception firstException = null;	for (Object value : services) {	try {	stopService(value);	if (value instanceof ShutdownableService) {	ShutdownableService service = (ShutdownableService)value;	
shutting down service 

Exception firstException = null;	for (Object value : services) {	try {	stopService(value);	if (value instanceof ShutdownableService) {	ShutdownableService service = (ShutdownableService)value;	service.shutdown();	}	} catch (Exception e) {	if (LOG.isDebugEnabled()) {	
caught exception shutting down service 

return;	}	Exception firstException = null;	for (Object value : services) {	if (value instanceof Service) {	Service service = (Service)value;	try {	resumeService(service);	} catch (Exception e) {	if (LOG.isDebugEnabled()) {	
caught exception resuming service 

public static boolean resumeService(Object service) throws Exception {	if (service instanceof Suspendable && service instanceof SuspendableService) {	SuspendableService ss = (SuspendableService) service;	if (ss.isSuspended()) {	
resuming service 

return;	}	Exception firstException = null;	for (Object value : services) {	if (value instanceof Service) {	Service service = (Service)value;	try {	suspendService(service);	} catch (Exception e) {	if (LOG.isDebugEnabled()) {	
caught exception suspending service 

public static boolean suspendService(Object service) throws Exception {	if (service instanceof Suspendable && service instanceof SuspendableService) {	SuspendableService ss = (SuspendableService) service;	if (!ss.isSuspended()) {	
suspending service 

========================= camel sample_4348 =========================

public void process(Exchange exchange) throws Exception {	Message in = exchange.getIn();	Comment comment = (Comment) in.getBody();	
got comment from user 

========================= camel sample_14249 =========================

public Facebook getFacebook() throws FacebookException {	if (facebook == null) {	final Configuration configuration = getConfiguration();	FacebookFactory factory = new FacebookFactory(configuration);	if (this.oAuthAccessToken == null) {	facebook = factory.getInstance(new OAuthAuthorization(configuration));	facebook.getOAuthAppAccessToken();	
login with app id and secret access to some apis is restricted 

public Facebook getFacebook() throws FacebookException {	if (facebook == null) {	final Configuration configuration = getConfiguration();	FacebookFactory factory = new FacebookFactory(configuration);	if (this.oAuthAccessToken == null) {	facebook = factory.getInstance(new OAuthAuthorization(configuration));	facebook.getOAuthAppAccessToken();	} else {	facebook = factory.getInstance();	facebook.getOAuthAccessToken();	
login with app id secret and token all apis accessible 

========================= camel sample_9595 =========================

protected void doStart() throws Exception {	
starting producer 

protected void doStart() throws Exception {	kieSession = runtimeEngine.getKieSession();	taskService = runtimeEngine.getTaskService();	super.doStart();	
started producer 

========================= camel sample_8384 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<WeatherComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.weather.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.weather.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_492 =========================

exchange.getIn().setBody(entry.getValue());	}	} else {	StringBuilder pathsExtracted = new StringBuilder();	for (Map.Entry<String, Object> entry : map.entrySet()) {	pathsExtracted.append(entry.getKey()).append("\n");	}	exchange.getIn().setHeader(DropboxResultHeader.DOWNLOADED_FILES.name(), pathsExtracted.toString());	exchange.getIn().setBody(map);	}	
downloaded 

========================= camel sample_8500 =========================

public boolean acquireExclusiveReadLock(GenericFileOperations<ChannelSftp.LsEntry> operations, GenericFile<ChannelSftp.LsEntry> file, Exchange exchange) throws Exception {	boolean exclusive = false;	
waiting for exclusive read lock to file 

CamelLogger.log(LOG, readLockLoggingLevel, "Cannot acquire read lock within " + timeout + " millis. Will skip the file: " + file);	return false;	}	}	long newLastModified = 0;	long newLength = 0;	List<ChannelSftp.LsEntry> files;	if (fastExistsCheck) {	String path = file.getAbsoluteFilePath();	if (path.equals("/") || path.equals("\\")) {	
using fast exists to update file information in home directory 

}	}	long newLastModified = 0;	long newLength = 0;	List<ChannelSftp.LsEntry> files;	if (fastExistsCheck) {	String path = file.getAbsoluteFilePath();	if (path.equals("/") || path.equals("\\")) {	files = operations.listFiles();	} else {	
using fast exists to update file information for 

if (fastExistsCheck) {	String path = file.getAbsoluteFilePath();	if (path.equals("/") || path.equals("\\")) {	files = operations.listFiles();	} else {	files = operations.listFiles(path);	}	} else {	String path = file.getParent();	if (path.equals("/") || path.equals("\\")) {	
using full directory listing in home directory to update file information consider enabling fastexistscheck option 

if (path.equals("/") || path.equals("\\")) {	files = operations.listFiles();	} else {	files = operations.listFiles(path);	}	} else {	String path = file.getParent();	if (path.equals("/") || path.equals("\\")) {	files = operations.listFiles();	} else {	
using full directory listing to update file information for consider enabling fastexistscheck option 

files = operations.listFiles(path);	}	} else {	String path = file.getParent();	if (path.equals("/") || path.equals("\\")) {	files = operations.listFiles();	} else {	files = operations.listFiles(path);	}	}	
list files found files 

if (fastExistsCheck) {	match = f.getFilename().equals(file.getAbsoluteFilePath()) || f.getFilename().equals(file.getFileNameOnly());	} else {	match = f.getFilename().equals(file.getFileNameOnly());	}	if (match) {	newLastModified = f.getAttrs().getMTime() * 1000L;	newLength = f.getAttrs().getSize();	}	}	
previous last modified new last modified 

if (fastExistsCheck) {	match = f.getFilename().equals(file.getAbsoluteFilePath()) || f.getFilename().equals(file.getFileNameOnly());	} else {	match = f.getFilename().equals(file.getFileNameOnly());	}	if (match) {	newLastModified = f.getAttrs().getMTime() * 1000L;	newLength = f.getAttrs().getSize();	}	}	
previous length new length 

match = f.getFilename().equals(file.getAbsoluteFilePath()) || f.getFilename().equals(file.getFileNameOnly());	} else {	match = f.getFilename().equals(file.getFileNameOnly());	}	if (match) {	newLastModified = f.getAttrs().getMTime() * 1000L;	newLength = f.getAttrs().getSize();	}	}	long newOlderThan = startTime + watch.taken() - minAge;	
new older than threshold 

} else {	match = f.getFilename().equals(file.getFileNameOnly());	}	if (match) {	newLastModified = f.getAttrs().getMTime() * 1000L;	newLength = f.getAttrs().getSize();	}	}	long newOlderThan = startTime + watch.taken() - minAge;	if (newLength >= minLength && ((minAge == 0 && newLastModified == lastModified && newLength == length) || (minAge != 0 && newLastModified < newOlderThan))) {	
read lock acquired 

private boolean sleep() {	
exclusive read lock not granted sleeping for millis 

private boolean sleep() {	try {	Thread.sleep(checkInterval);	return false;	} catch (InterruptedException e) {	
sleep interrupted while waiting for exclusive read lock so breaking out 

========================= camel sample_15399 =========================

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyFieldRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	
consumer 

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyFieldRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	}	Assert.assertEquals("timer:foo", list.get(0).getElement());	list = CamelJavaParserHelper.parseCamelProducerUris(method, true, true);	for (ParserResult result : list) {	
producer 

========================= camel sample_216 =========================

protected Restlet createRestlet() {	return new Restlet() {	public void handle(Request request, Response response) {	super.handle(request, response);	
consumer restlet handle request method 

========================= camel sample_9311 =========================

public void testGetComment() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.comment_id", null);	headers.put("CamelLinkedIn.fields", null);	final org.apache.camel.component.linkedin.api.model.Comment result = requestBodyAndHeaders("direct: assertNotNull("getComment result", result);	
getcomment 

========================= camel sample_8853 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KeystoneComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.openstack-keystone.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.openstack-keystone.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1234 =========================

public void setReplyTo(String replyTo) {	
replyto destination 

public String getReplyTo() {	if (replyTo != null) {	return replyTo;	}	try {	
waiting for replyto to be set 

public String getReplyTo() {	if (replyTo != null) {	return replyTo;	}	try {	boolean done = replyToLatch.await(replyToTimeout, TimeUnit.MILLISECONDS);	if (!done) {	
replyto destination was not set and timeout occurred 

public String getReplyTo() {	if (replyTo != null) {	return replyTo;	}	try {	boolean done = replyToLatch.await(replyToTimeout, TimeUnit.MILLISECONDS);	if (!done) {	} else {	
waiting for replyto to be set done 

protected abstract ReplyHandler createReplyHandler(ReplyManager replyManager, Exchange exchange, AsyncCallback callback, String originalCorrelationId, String correlationId, long requestTimeout);	public void cancelCorrelationId(String correlationId) {	ReplyHandler handler = correlation.get(correlationId);	if (handler != null) {	
cancelling correlationid 

public void onMessage(AMQP.BasicProperties properties, byte[] message) {	String correlationID = properties.getCorrelationId();	if (correlationID == null) {	
ignoring message with no correlationid 

public void onMessage(AMQP.BasicProperties properties, byte[] message) {	String correlationID = properties.getCorrelationId();	if (correlationID == null) {	return;	}	
received reply message with correlationid 

public void processReply(ReplyHolder holder) {	if (holder != null && isRunAllowed()) {	try {	Exchange exchange = holder.getExchange();	boolean timeout = holder.isTimeout();	if (timeout) {	if (log.isWarnEnabled()) {	
timeout occurred after millis waiting for reply message with correlationid on destination setting exchangetimedoutexception on and continue routing 

protected abstract void handleReplyMessage(String correlationID, AMQP.BasicProperties properties, byte[] message);	protected abstract Connection createListenerContainer() throws Exception;	protected ReplyHandler waitForProvisionCorrelationToBeUpdated(String correlationID, byte[] message) {	if (log.isWarnEnabled()) {	
early reply received with correlationid 

protected abstract void handleReplyMessage(String correlationID, AMQP.BasicProperties properties, byte[] message);	protected abstract Connection createListenerContainer() throws Exception;	protected ReplyHandler waitForProvisionCorrelationToBeUpdated(String correlationID, byte[] message) {	if (log.isWarnEnabled()) {	}	ReplyHandler answer = null;	boolean done = false;	int counter = 0;	while (!done && counter++ < 50) {	
early reply not found handler at attempt waiting a bit longer 

int counter = 0;	while (!done && counter++ < 50) {	try {	Thread.sleep(100);	} catch (InterruptedException e) {	}	answer = correlation.get(correlationID);	done = answer != null;	if (answer != null) {	if (log.isTraceEnabled()) {	
early reply with correlationid has been matched after attempts and can be processed using handler 

protected void doStart() throws Exception {	ObjectHelper.notNull(executorService, "executorService", this);	ObjectHelper.notNull(endpoint, "endpoint", this);	
using timeout checker interval with millis 

protected void doStart() throws Exception {	ObjectHelper.notNull(executorService, "executorService", this);	ObjectHelper.notNull(endpoint, "endpoint", this);	correlation = new CorrelationTimeoutMap(executorService, endpoint.getRequestTimeoutCheckerInterval());	ServiceHelper.startService(correlation);	listenerContainer = createListenerContainer();	
using executor 

protected void doStop() throws Exception {	ServiceHelper.stopService(correlation);	if (listenerContainer != null) {	
closing connection with timeout ms 

========================= camel sample_14137 =========================

protected void doStop() throws Exception {	super.doStop();	
stopping kubernetes replication controllers consumer 

========================= camel sample_13308 =========================

if (executorService == null) {	executorService = camelContext.getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "DefaultHealthCheckService");	}	if (future != null) {	future.cancel(true);	}	if (registry == null) {	registry = camelContext.getHealthCheckRegistry();	}	if (ObjectHelper.isNotEmpty(registry) && ObjectHelper.isEmpty(future)) {	
schedule health checks to be executed every d s 

future.cancel(true);	}	if (registry == null) {	registry = camelContext.getHealthCheckRegistry();	}	if (ObjectHelper.isNotEmpty(registry) && ObjectHelper.isEmpty(future)) {	future = executorService.scheduleAtFixedRate( () -> {	if (!isRunAllowed()) {	return;	}	
invoke health checks scheduled 

private HealthCheck.Result invoke(HealthCheck check, Map<String, Object> options) {	return LockHelper.supplyWithWriteLock( lock, () -> {	
invoke health check 

========================= camel sample_4036 =========================

public void testSharedThreadPool() throws Exception {	int delta = Thread.activeCount() - before;	
created threads 

========================= camel sample_10174 =========================

public XsltEndpoint findOrCreateEndpoint(String uri, String newResourceUri) {	String newUri = uri.replace(resourceUri, newResourceUri);	
getting endpoint with uri 

protected void loadResource(String resourceUri) throws TransformerException, IOException {	
loading schema resource 

protected void doStart() throws Exception {	super.doStart();	final CamelContext ctx = getCamelContext();	final ClassResolver resolver = ctx.getClassResolver();	final Injector injector = ctx.getInjector();	
using schema resource 

xslt.setConverter(converter);	}	boolean useSaxon = false;	if (transformerFactoryClass == null && (saxon || saxonExtensionFunctions != null)) {	useSaxon = true;	transformerFactoryClass = SAXON_TRANSFORMER_FACTORY_CLASS_NAME;	}	TransformerFactory factory = transformerFactory;	if (factory == null && transformerFactoryClass != null) {	Class<TransformerFactory> factoryClass = resolver.resolveMandatoryClass(transformerFactoryClass, TransformerFactory.class, XsltComponent.class.getClassLoader());	
using transformerfactoryclass 

if (factory == null && transformerFactoryClass != null) {	Class<TransformerFactory> factoryClass = resolver.resolveMandatoryClass(transformerFactoryClass, TransformerFactory.class, XsltComponent.class.getClassLoader());	factory = injector.newInstance(factoryClass);	if (useSaxon) {	XsltHelper.registerSaxonConfiguration(ctx, factoryClass, factory, saxonConfiguration);	XsltHelper.registerSaxonConfigurationProperties(ctx, factoryClass, factory, saxonConfigurationProperties);	XsltHelper.registerSaxonExtensionFunctions(ctx, factoryClass, factory, saxonExtensionFunctions);	}	}	if (factory != null) {	
using transformerfactory 

========================= camel sample_4935 =========================

public void testCalculateMethodInvocation() throws Exception {	
thrift calculate method sync test start 

public void testAddMethodInvocation() throws Exception {	
thrift add method primitive parameters only sync test start 

public void testCalculateWithException() throws Exception {	
thrift calculate method with business exception sync test start 

public void testVoidMethodInvocation() throws Exception {	
thrift method with empty parameters and void output sync test start 

public void testOneWayMethodInvocation() throws Exception {	
thrift one way method sync test start 

public void testAllTypesMethodInvocation() throws Exception {	
thrift method with all possile types sync test start 

public void testEchoMethodInvocation() throws Exception {	
thrift echo method return output as pass input parameter sync test start 

========================= camel sample_13021 =========================

protected JndiRegistry createRegistry() throws Exception {	JndiRegistry registry = new JndiRegistry(createJndiContext());	registry.bind("A", new Processor() {	public void process(Exchange exchange) throws Exception {	
a headers 

protected JndiRegistry createRegistry() throws Exception {	JndiRegistry registry = new JndiRegistry(createJndiContext());	registry.bind("A", new Processor() {	public void process(Exchange exchange) throws Exception {	}	});	registry.bind("B", new Processor() {	public void process(Exchange exchange) throws Exception {	
b headers 

public void process(Exchange exchange) throws Exception {	if ("ExchangeTimedOutException".equals(exchange.getIn().getBody(String.class))) {	throw new ExchangeTimedOutException(exchange, 1);	} else if ("Exception".equals(exchange.getIn().getBody(String.class))) {	throw new Exception();	}	}	});	registry.bind("C", new Processor() {	public void process(Exchange exchange) throws Exception {	
c headers 

========================= camel sample_3823 =========================

public void listen(EventListener listener, Long startingPosition) {	try {	LOG.debug("Listening for events with listener=" + listener + " at startingPosition=" + startingPosition);	if (listener == null) {	
parameter listener is null will not listen for events 

========================= camel sample_17432 =========================

public void startGrpcServer() throws Exception {	pingPongServer = new PingPongImpl();	grpcServer = ServerBuilder.forPort(GRPC_TEST_PORT).addService(pingPongServer).build().start();	
grpc server started on port 

public void stopGrpcServer() throws IOException {	if (grpcServer != null) {	grpcServer.shutdown();	
grpc server stopped 

if ("error".equals(request.getPingName())) {	PingPongImpl.this.streamRequests.add(streamRequests);	responseObserver.onError(new RuntimeException("Requested error"));	} else {	PongResponse response = PongResponse.newBuilder().setPongName("Hello " + request.getPingName()).build();	responseObserver.onNext(response);	}	}	public void onError(Throwable t) {	PingPongImpl.this.streamRequests.add(streamRequests);	
error in pingasyncasync 

========================= camel sample_7499 =========================

public void testSynchronous() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(100);	mock.expectsNoDuplicates(body());	StopWatch watch = new StopWatch();	for (int i = 0; i < 100; i++) {	template.sendBody("seda:start", "" + i);	}	assertMockEndpointsSatisfied(20, TimeUnit.SECONDS);	
took ms to process messages request reply over jms 

========================= camel sample_12325 =========================

protected void initHdfs() {	try {	URL.setURLStreamHandlerFactory(new FsUrlStreamHandlerFactory());	} catch (Throwable e) {	
cannot set urlstreamhandlerfactory due this exception will be ignored 

static Configuration getJAASConfiguration() {	Configuration auth = null;	try {	auth = Configuration.getConfiguration();	
existing jaas configuration 

static Configuration getJAASConfiguration() {	Configuration auth = null;	try {	auth = Configuration.getConfiguration();	} catch (SecurityException e) {	
cannot load existing jaas configuration 

static void setJAASConfiguration(Configuration auth) {	if (auth != null) {	
restoring existing jaas configuration 

static void setJAASConfiguration(Configuration auth) {	if (auth != null) {	try {	Configuration.setConfiguration(auth);	} catch (SecurityException e) {	
cannot restore jaas configuration this exception is ignored 

static void setJAASConfiguration(Configuration auth) {	if (auth != null) {	try {	Configuration.setConfiguration(auth);	} catch (SecurityException e) {	}	} else {	
no jaas configuration to restore 

========================= camel sample_11159 =========================

public CamelContext getOrLookupCamelContext() {	if (camelContext == null) {	if (camelId != null) {	
looking up camelcontext by id from spring applicationcontext 

public CamelContext getOrLookupCamelContext() {	if (camelContext == null) {	if (camelId != null) {	camelContext = applicationContext.getBean(camelId, CamelContext.class);	} else {	
looking up camelcontext by type from spring applicationcontext 

} else {	return applicationContext.isSingleton(beanName);	}	}	protected void startService(Service service, CamelContext context, Object bean, String beanName) throws Exception {	if (isSingleton(bean, beanName)) {	getCamelContext().addService(service);	} else {	ServiceHelper.startService(service);	if (prototypeBeans.add(beanName)) {	
the bean with id is prototype scoped and cannot stop the injected service when bean is destroyed you may want to stop the service manually from the bean 

========================= camel sample_16366 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<RmiComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.rmi.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.rmi.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_996 =========================

public void onMessage(Message message) {	
base called 

========================= camel sample_6158 =========================

public void notify(EventObject event) throws Exception {	if (event instanceof ExchangeSentEvent) {	ExchangeSentEvent sent = (ExchangeSentEvent) event;	
took millis to send to 

========================= camel sample_1737 =========================

public void process(Exchange exchange) throws Exception {	RestletEndpoint endpoint = (RestletEndpoint) getEndpoint();	final RestletBinding binding = endpoint.getRestletBinding();	Request request;	String resourceUri = buildUri(endpoint, exchange);	URI uri = new URI(resourceUri);	request = new Request(endpoint.getRestletMethod(), resourceUri);	binding.populateRestletRequestFromExchange(request, exchange);	loadCookies(exchange, uri, request);	
sending request synchronously for exchangeid 

public void process(Exchange exchange) throws Exception {	RestletEndpoint endpoint = (RestletEndpoint) getEndpoint();	final RestletBinding binding = endpoint.getRestletBinding();	Request request;	String resourceUri = buildUri(endpoint, exchange);	URI uri = new URI(resourceUri);	request = new Request(endpoint.getRestletMethod(), resourceUri);	binding.populateRestletRequestFromExchange(request, exchange);	loadCookies(exchange, uri, request);	Response response = client.handle(request);	
received response synchronously for exchangeid 

RestletEndpoint endpoint = (RestletEndpoint) getEndpoint();	if (endpoint.isSynchronous()) {	try {	process(exchange);	} catch (Throwable e) {	exchange.setException(e);	}	callback.done(true);	return true;	}	
processing asynchronously 

String resourceUri = buildUri(endpoint, exchange);	URI uri = new URI(resourceUri);	request = new Request(endpoint.getRestletMethod(), resourceUri);	binding.populateRestletRequestFromExchange(request, exchange);	loadCookies(exchange, uri, request);	} catch (Throwable e) {	exchange.setException(e);	callback.done(true);	return true;	}	
sending request asynchronously for exchangeid 

request = new Request(endpoint.getRestletMethod(), resourceUri);	binding.populateRestletRequestFromExchange(request, exchange);	loadCookies(exchange, uri, request);	} catch (Throwable e) {	exchange.setException(e);	callback.done(true);	return true;	}	client.handle(request, new Uniform() {	public void handle(Request request, Response response) {	
received response asynchronously for exchangeid 

private static String buildUri(RestletEndpoint endpoint, Exchange exchange) throws Exception {	String uri = (String) exchange.getIn().removeHeader(Exchange.REST_HTTP_URI);	if (uri == null) {	uri = endpoint.getProtocol() + ": }	
substituting value placeholders in uri 

if (uri == null) {	uri = endpoint.getProtocol() + ": }	Matcher matcher = PATTERN.matcher(uri);	while (matcher.find()) {	String key = matcher.group(1);	String header = exchange.getIn().getHeader(key, String.class);	if (header == null) {	throw new CamelExchangeException("Header with key: " + key + " not found in Exchange", exchange);	}	if (LOG.isTraceEnabled()) {	
replacing with header value 

matcher.reset(uri);	}	if (endpoint.getQueryParameters() != null) {	uri = URISupport.appendParametersToURI(uri, endpoint.getQueryParameters());	}	String query = (String) exchange.getIn().removeHeader(Exchange.REST_HTTP_QUERY);	if (query == null) {	query = exchange.getIn().getHeader(Exchange.HTTP_QUERY, String.class);	}	if (query != null) {	
adding query to uri 

if (endpoint.getQueryParameters() != null) {	uri = URISupport.appendParametersToURI(uri, endpoint.getQueryParameters());	}	String query = (String) exchange.getIn().removeHeader(Exchange.REST_HTTP_QUERY);	if (query == null) {	query = exchange.getIn().getHeader(Exchange.HTTP_QUERY, String.class);	}	if (query != null) {	uri = addQueryToUri(uri, query);	}	
using uri 

========================= camel sample_9307 =========================

protected void doStart() throws Exception {	super.doStart();	if (configuration.isClientMode() && configuration.getProtocol().equals("tcp")) {	connector.setHandler(new ReceiveHandler());	ConnectFuture future = connector.connect(address);	future.awaitUninterruptibly();	session = future.getSession();	
connected to server address using connector timeout millis 

protected void doStart() throws Exception {	super.doStart();	if (configuration.isClientMode() && configuration.getProtocol().equals("tcp")) {	connector.setHandler(new ReceiveHandler());	ConnectFuture future = connector.connect(address);	future.awaitUninterruptibly();	session = future.getSession();	} else {	acceptor.setHandler(new ReceiveHandler());	acceptor.bind(address);	
bound to server address using acceptor 

protected void doStop() throws Exception {	if (configuration.isClientMode() && configuration.getProtocol().equals("tcp")) {	
disconnect from server address using connector 

protected void doStop() throws Exception {	if (configuration.isClientMode() && configuration.getProtocol().equals("tcp")) {	if (session != null) {	CloseFuture closeFuture = session.closeNow();	closeFuture.awaitUninterruptibly();	}	connector.dispose(true);	} else {	
unbinding from server address using acceptor 

protected void doStop() throws Exception {	if (configuration.isClientMode() && configuration.getProtocol().equals("tcp")) {	if (session != null) {	CloseFuture closeFuture = session.closeNow();	closeFuture.awaitUninterruptibly();	}	connector.dispose(true);	} else {	if (address instanceof InetSocketAddress) {	if ("0.0.0.0".equals(((InetSocketAddress)address).getAddress().getHostAddress())) {	
unbind the server address 

boolean minaLogger = configuration.isMinaLogger();	List<IoFilter> filters = configuration.getFilters();	address = new VmPipeAddress(configuration.getPort());	acceptor = new VmPipeAcceptor();	configureCodecFactory("Mina2Consumer", acceptor, configuration);	if (minaLogger) {	acceptor.getFilterChain().addLast("logger", new LoggingFilter());	}	appendIoFiltersToChain(filters, acceptor.getFilterChain());	if (configuration.getSslContextParameters() != null) {	
using vm protocol but an sslcontextparameters instance was provided sslcontextparameters is only supported on the tcp protocol 

protected void setupSocketProtocol(String uri, Mina2Configuration configuration) throws Exception {	
createSocketEndpoint 

LineDelimiter delimiter = getLineDelimiterParameter(configuration.getTextlineDelimiter());	Mina2TextLineCodecFactory codecFactory = new Mina2TextLineCodecFactory(charset, delimiter);	if (configuration.getEncoderMaxLineLength() > 0) {	codecFactory.setEncoderMaxLineLength(configuration.getEncoderMaxLineLength());	}	if (configuration.getDecoderMaxLineLength() > 0) {	codecFactory.setDecoderMaxLineLength(configuration.getDecoderMaxLineLength());	}	addCodecFactory(service, codecFactory);	if (LOG.isDebugEnabled()) {	
using textlinecodecfactory using encoding line delimiter 

LineDelimiter delimiter = getLineDelimiterParameter(configuration.getTextlineDelimiter());	Mina2TextLineCodecFactory codecFactory = new Mina2TextLineCodecFactory(charset, delimiter);	if (configuration.getEncoderMaxLineLength() > 0) {	codecFactory.setEncoderMaxLineLength(configuration.getEncoderMaxLineLength());	}	if (configuration.getDecoderMaxLineLength() > 0) {	codecFactory.setDecoderMaxLineLength(configuration.getDecoderMaxLineLength());	}	addCodecFactory(service, codecFactory);	if (LOG.isDebugEnabled()) {	
encoder maximum line length decoder maximum line length 

}	if (configuration.getDecoderMaxLineLength() > 0) {	codecFactory.setDecoderMaxLineLength(configuration.getDecoderMaxLineLength());	}	addCodecFactory(service, codecFactory);	if (LOG.isDebugEnabled()) {	}	} else {	ObjectSerializationCodecFactory codecFactory = new ObjectSerializationCodecFactory();	addCodecFactory(service, codecFactory);	
using objectserializationcodecfactory 

workerPool = new OrderedThreadPoolExecutor(configuration.getMaximumPoolSize());	} else {	workerPool = new UnorderedThreadPoolExecutor(configuration.getMaximumPoolSize());	}	acceptor.getFilterChain().addLast("threadPool", new ExecutorFilter(workerPool));	if (minaLogger) {	acceptor.getFilterChain().addLast("logger", new LoggingFilter());	}	appendIoFiltersToChain(filters, acceptor.getFilterChain());	if (configuration.getSslContextParameters() != null) {	
using datagram protocol but an sslcontextparameters instance was provided sslcontextparameters is only supported on the tcp protocol 

protected void configureDataGramCodecFactory(final String type, final IoService service, final Mina2Configuration configuration) {	ProtocolCodecFactory codecFactory = configuration.getCodec();	if (codecFactory == null) {	codecFactory = new Mina2UdpProtocolCodecFactory(this.getEndpoint().getCamelContext());	if (LOG.isDebugEnabled()) {	
using codecfactory 

private Charset getEncodingParameter(String type, Mina2Configuration configuration) {	String encoding = configuration.getEncoding();	if (encoding == null) {	encoding = Charset.defaultCharset().name();	configuration.setEncoding(encoding);	
no encoding parameter using default charset 

public void exceptionCaught(IoSession session, Throwable cause) throws Exception {	if (cause instanceof IOException) {	
ioexceptions are automatically handled by mina 

public void exceptionCaught(IoSession session, Throwable cause) throws Exception {	if (cause instanceof IOException) {	return;	}	if (session != null) {	
closing session as an exception was thrown from mina 

public void messageReceived(IoSession session, Object object) throws Exception {	if (LOG.isDebugEnabled()) {	Object in = object;	if (in instanceof byte[]) {	in = getEndpoint().getCamelContext().getTypeConverter().convertTo(String.class, in);	}	
received body 

}	boolean failed = exchange.isFailed();	if (failed && !getEndpoint().getConfiguration().isTransferExchange()) {	if (exchange.getException() != null) {	response = exchange.getException();	} else {	response = exchange.getOut().getBody();	}	}	if (response != null) {	
writing body 

if (failed && !getEndpoint().getConfiguration().isTransferExchange()) {	if (exchange.getException() != null) {	response = exchange.getException();	} else {	response = exchange.getOut().getBody();	}	}	if (response != null) {	Mina2Helper.writeBody(session, response, exchange, configuration.getWriteTimeout());	} else {	
writing no response 

Boolean close;	if (ExchangeHelper.isOutCapable(exchange)) {	close = exchange.getOut().getHeader(Mina2Constants.MINA_CLOSE_SESSION_WHEN_COMPLETE, Boolean.class);	} else {	close = exchange.getIn().getHeader(Mina2Constants.MINA_CLOSE_SESSION_WHEN_COMPLETE, Boolean.class);	}	if (close != null) {	disconnect = close;	}	if (disconnect) {	
closing session when complete at address 

========================= camel sample_11636 =========================

} catch (Exception e) {	exchange.setException(e);	callback.done(true);	return true;	}	final Exchange wireTapExchange = target;	executorService.submit(new Callable<Exchange>() {	public Exchange call() throws Exception {	taskCount.increment();	try {	
wiretap 

callback.done(true);	return true;	}	final Exchange wireTapExchange = target;	executorService.submit(new Callable<Exchange>() {	public Exchange call() throws Exception {	taskCount.increment();	try {	processor.process(wireTapExchange);	} catch (Throwable e) {	
error occurred during processing wiretap to this exception will be ignored 

========================= camel sample_4535 =========================

public void testEndpointCreatedWithCorrectUri() throws Exception {	assertNotNull("foo", endpoint);	assertEquals("foo.getEndpointUri()", "foo:bar", endpoint.getEndpointUri());	
found endpoint with uri 

========================= camel sample_15675 =========================

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyLocalAddRouteBuilderTest.java"));	MethodSource<JavaClassSource> method = CamelJavaParserHelper.findConfigureMethod(clazz);	Assert.assertNull(method);	List<MethodSource<JavaClassSource>> methods = CamelJavaParserHelper.findInlinedConfigureMethods(clazz);	Assert.assertEquals(1, methods.size());	method = methods.get(0);	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	
consumer 

MethodSource<JavaClassSource> method = CamelJavaParserHelper.findConfigureMethod(clazz);	Assert.assertNull(method);	List<MethodSource<JavaClassSource>> methods = CamelJavaParserHelper.findInlinedConfigureMethods(clazz);	Assert.assertEquals(1, methods.size());	method = methods.get(0);	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	}	list = CamelJavaParserHelper.parseCamelProducerUris(method, true, true);	for (ParserResult result : list) {	
producer 

========================= camel sample_200 =========================

public void onJobExecute(final JobExecutionContext jobExecutionContext) throws JobExecutionException {	boolean run = true;	LoadBalancer balancer = getLoadBalancer();	if (balancer instanceof ServiceSupport) {	run = ((ServiceSupport) balancer).isRunAllowed();	}	if (!run) {	
cannot execute quartz job with context because processor is not started 

public void onJobExecute(final JobExecutionContext jobExecutionContext) throws JobExecutionException {	boolean run = true;	LoadBalancer balancer = getLoadBalancer();	if (balancer instanceof ServiceSupport) {	run = ((ServiceSupport) balancer).isRunAllowed();	}	if (!run) {	return;	}	
firing quartz job with context 

if (!run) {	return;	}	Exchange exchange = createExchange(jobExecutionContext);	try {	balancer.process(exchange);	if (exchange.getException() != null) {	throw new JobExecutionException(exchange.getException());	}	} catch (Exception e) {	
error processing exchange 

public synchronized void consumerStarted(final QuartzConsumer consumer) throws SchedulerException {	ObjectHelper.notNull(trigger, "trigger");	
adding consumer 

public synchronized void consumerStopped(final QuartzConsumer consumer) throws SchedulerException {	ObjectHelper.notNull(trigger, "trigger");	if (started) {	pauseTrigger(getTrigger());	started = false;	}	
removing consumer 

========================= camel sample_17218 =========================

setToHost((String) settings.get("toHost"));	}	if (settings.containsKey("toPort")) {	setToPort(Integer.parseInt((String) settings.get("toPort")));	}	}	}	implementationDebugLogFile = component.getAndRemoveParameter(parameters, "implementationDebugLogFile", String.class, null);	implementationServerLogFile = component.getAndRemoveParameter(parameters, "implementationServerLogFile", String.class, null);	implementationTraceLevel = component.getAndRemoveParameter(parameters, "implementationTraceLevel", String.class, "0");	
consumer stackname 

setToHost((String) settings.get("toHost"));	}	if (settings.containsKey("toPort")) {	setToPort(Integer.parseInt((String) settings.get("toPort")));	}	}	}	implementationDebugLogFile = component.getAndRemoveParameter(parameters, "implementationDebugLogFile", String.class, null);	implementationServerLogFile = component.getAndRemoveParameter(parameters, "implementationServerLogFile", String.class, null);	implementationTraceLevel = component.getAndRemoveParameter(parameters, "implementationTraceLevel", String.class, "0");	
from user from host from port 

========================= camel sample_8516 =========================

protected void doStart() throws Exception {	super.doStart();	createConsumerCacheConnection();	
initialize the cache 

========================= camel sample_10532 =========================

public Object invoke(Exchange cxfExchange, Object o) {	
received cxf request 

public Object invoke(Exchange cxfExchange, Object o) {	Continuation continuation;	if (!endpoint.isSynchronous() && isAsyncInvocationSupported(cxfExchange) && (continuation = getContinuation(cxfExchange)) != null) {	
calling the camel async processors 

public Object invoke(Exchange cxfExchange, Object o) {	Continuation continuation;	if (!endpoint.isSynchronous() && isAsyncInvocationSupported(cxfExchange) && (continuation = getContinuation(cxfExchange)) != null) {	return asyncInvoke(cxfExchange, continuation);	} else {	
calling the camel sync processors 

private Object asyncInvoke(Exchange cxfExchange, final Continuation continuation) {	synchronized (continuation) {	if (continuation.isNew()) {	final org.apache.camel.Exchange camelExchange = prepareCamelExchange(cxfExchange);	
suspending continuation of exchangeid 

private Object asyncInvoke(Exchange cxfExchange, final Continuation continuation) {	synchronized (continuation) {	if (continuation.isNew()) {	final org.apache.camel.Exchange camelExchange = prepareCamelExchange(cxfExchange);	continuation.suspend(cxfEndpoint.getContinuationTimeout());	continuation.setObject(camelExchange);	getAsyncProcessor().process(camelExchange, new AsyncCallback() {	public void done(boolean doneSync) {	synchronized (continuation) {	
resuming continuation of exchangeid 

private Object syncInvoke(Exchange cxfExchange) {	org.apache.camel.Exchange camelExchange = prepareCamelExchange(cxfExchange);	try {	try {	
processing start 

private Object syncInvoke(Exchange cxfExchange) {	org.apache.camel.Exchange camelExchange = prepareCamelExchange(cxfExchange);	try {	try {	getProcessor().process(camelExchange);	} catch (Exception e) {	throw new Fault(e);	}	
processing end 

org.apache.camel.Exchange camelExchange = endpoint.createExchange();	cxfExchange.put(org.apache.camel.Exchange.class, camelExchange);	DataFormat dataFormat = endpoint.getDataFormat();	BindingOperationInfo boi = cxfExchange.getBindingOperationInfo();	if (boi != null && dataFormat == DataFormat.PAYLOAD && boi.isUnwrapped()) {	boi = boi.getWrappedOperation();	cxfExchange.put(BindingOperationInfo.class, boi);	}	if (boi != null) {	camelExchange.setProperty(BindingOperationInfo.class.getName(), boi);	
set exchange property bindingoperationinfo 

if (endpoint.getMergeProtocolHeaders()) {	camelExchange.setProperty(CxfConstants.CAMEL_CXF_PROTOCOL_HEADERS_MERGED, Boolean.TRUE);	}	binding.populateExchangeFromCxfRequest(cxfExchange, camelExchange);	Map<String, Object> context = new HashMap<String, Object>();	binding.extractJaxWsContext(cxfExchange, context);	camelExchange.setProperty(CxfConstants.JAXWS_CONTEXT, context);	try {	CxfConsumer.this.createUoW(camelExchange);	} catch (Exception e) {	
error processing request 

========================= camel sample_8003 =========================

if (exchange.getProperty(Exchange.ASYNC_WAIT) != null) {	wait = exchange.getProperty(Exchange.ASYNC_WAIT, WaitForTaskToComplete.class);	}	if (wait == WaitForTaskToComplete.Always || (wait == WaitForTaskToComplete.IfReplyExpected && ExchangeHelper.isOutCapable(exchange))) {	Exchange copy = prepareCopy(exchange, false);	final CountDownLatch latch = new CountDownLatch(1);	copy.addOnCompletion(new SynchronizationAdapter() {	public void onDone(Exchange response) {	if (latch.getCount() == 0) {	if (log.isTraceEnabled()) {	
timeout occurred so response will be ignored 

Exchange copy = prepareCopy(exchange, false);	final CountDownLatch latch = new CountDownLatch(1);	copy.addOnCompletion(new SynchronizationAdapter() {	public void onDone(Exchange response) {	if (latch.getCount() == 0) {	if (log.isTraceEnabled()) {	}	return;	} else {	if (log.isTraceEnabled()) {	
with response 

}	}	}	public boolean allowHandover() {	return false;	}	public String toString() {	return "onDone at endpoint: " + endpoint;	}	});	
adding exchange to queue 

});	try {	addToQueue(copy, false);	} catch (SedaConsumerNotAvailableException e) {	exchange.setException(e);	callback.done(true);	return true;	}	if (timeout > 0) {	if (log.isTraceEnabled()) {	
waiting for task to complete using timeout ms at 

done = latch.await(timeout, TimeUnit.MILLISECONDS);	} catch (InterruptedException e) {	}	if (!done) {	exchange.setException(new ExchangeTimedOutException(exchange, timeout));	endpoint.getQueue().remove(copy);	latch.countDown();	}	} else {	if (log.isTraceEnabled()) {	
waiting for task to complete blocking at 

queue = queueReference.getQueue();	}	if (queue == null) {	throw new SedaConsumerNotAvailableException("No queue available on endpoint: " + endpoint, exchange);	}	boolean empty = !queueReference.hasConsumers();	if (empty) {	if (endpoint.isFailIfNoConsumers()) {	throw new SedaConsumerNotAvailableException("No consumers available on endpoint: " + endpoint, exchange);	} else if (endpoint.isDiscardIfNoConsumers()) {	
discard message as no active consumers on endpoint 

if (endpoint.isFailIfNoConsumers()) {	throw new SedaConsumerNotAvailableException("No consumers available on endpoint: " + endpoint, exchange);	} else if (endpoint.isDiscardIfNoConsumers()) {	return;	}	}	Exchange target = exchange;	if (copy) {	target = prepareCopy(exchange, true);	}	
adding exchange to queue 

}	}	Exchange target = exchange;	if (copy) {	target = prepareCopy(exchange, true);	}	if (blockWhenFull) {	try {	queue.put(target);	} catch (InterruptedException e) {	
put interrupted are we stopping 

========================= camel sample_4889 =========================

protected void doStop() throws Exception {	int count = size();	if (count > 0) {	
shutting down while there are still inflight exchanges 

protected void doStop() throws Exception {	int count = size();	if (count > 0) {	} else {	
shutting down with no inflight exchanges 

========================= camel sample_4020 =========================

if (cache.containsKey(key)) {	return false;	} else {	cache.put(key, key);	boolean containsInFile = containsStore(key);	if (containsInFile) {	return false;	}	appendToStore(key);	if (maxFileStoreSize > 0 && fileStore.length() > maxFileStoreSize) {	
maximum capacity of file store hit at bytes dropping oldest entries from the file store 

protected void appendToStore(final String key) {	
appending to idempotent filestore 

protected void appendToStore(final String key) {	FileOutputStream fos = null;	try {	File storeParentDirectory = fileStore.getParentFile();	if (storeParentDirectory != null && !storeParentDirectory.exists()) {	
parent directory of file store doesn t exist creating 

protected void appendToStore(final String key) {	FileOutputStream fos = null;	try {	File storeParentDirectory = fileStore.getParentFile();	if (storeParentDirectory != null && !storeParentDirectory.exists()) {	if (fileStore.getParentFile().mkdirs()) {	
parent directory of filestore successfully created 

protected void appendToStore(final String key) {	FileOutputStream fos = null;	try {	File storeParentDirectory = fileStore.getParentFile();	if (storeParentDirectory != null && !storeParentDirectory.exists()) {	if (fileStore.getParentFile().mkdirs()) {	} else {	
parent directory of filestore cannot be created 

protected synchronized void removeFromStore(String key) {	
removing from idempotent filestore 

}	}	} catch (IOException e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	} finally {	if (scanner != null) {	scanner.close();	}	}	if (found) {	
rewriting idempotent filestore due to key removed 

protected synchronized void trunkStore() {	if (fileStore == null || !fileStore.exists()) {	return;	}	
trunking oldest entries from idempotent filestore 

}	}	} catch (IOException e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	} finally {	if (scanner != null) {	scanner.close();	}	}	if (!lines.isEmpty()) {	
rewriting idempotent filestore with entries 

for (String line : lines) {	fos.write(line.getBytes());	fos.write(STORE_DELIMITER.getBytes());	}	} catch (IOException e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	} finally {	IOHelper.close(fos, "Rewriting file idempotent repository", LOG);	}	} else {	
clearing idempotent filestore 

protected void loadStore() throws IOException {	if (!fileStore.exists()) {	
creating filestore 

if (!fileStore.exists()) {	File parent = fileStore.getParentFile();	if (parent != null) {	parent.mkdirs();	}	boolean created = FileUtil.createNewFile(fileStore);	if (!created) {	throw new IOException("Cannot create filestore: " + fileStore);	}	}	
loading to level cache from idempotent filestore 

String line = scanner.nextLine();	cache.put(line, line);	}	} catch (IOException e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	} finally {	if (scanner != null) {	scanner.close();	}	}	
loaded to the level cache from idempotent filestore 

========================= camel sample_4470 =========================

public Destination getReplyTo() {	try {	destResolver.destinationReady();	} catch (InterruptedException e) {	
interrupted while waiting for jmsreplyto destination refresh 

public void updateCorrelationId(String correlationId, String newCorrelationId, long requestTimeout) {	
updated provisional correlationid to expected correlationid 

protected void handleReplyMessage(String correlationID, Message message, Session session) {	ReplyHandler handler = correlation.get(correlationID);	if (handler == null && endpoint.isUseMessageIDAsCorrelationID()) {	handler = waitForProvisionCorrelationToBeUpdated(correlationID, message);	}	if (handler != null) {	correlation.remove(correlationID);	handler.onReply(correlationID, message, session);	} else {	
reply received for unknown correlationid the message will be ignored 

answer.setErrorHandler(new DefaultSpringErrorHandler(endpoint.getCamelContext(), TemporaryQueueReplyManager.class, endpoint.getErrorHandlerLoggingLevel(), endpoint.isErrorHandlerLogStackTrace()));	}	if (endpoint.getReceiveTimeout() >= 0) {	answer.setReceiveTimeout(endpoint.getReceiveTimeout());	}	if (endpoint.getRecoveryInterval() >= 0) {	answer.setRecoveryInterval(endpoint.getRecoveryInterval());	}	if (endpoint.getTaskExecutor() != null) {	if (log.isDebugEnabled()) {	
using custom taskexecutor on listener container 

answer.setRecoveryInterval(endpoint.getRecoveryInterval());	}	if (endpoint.getTaskExecutor() != null) {	if (log.isDebugEnabled()) {	}	answer.setTaskExecutor(endpoint.getTaskExecutor());	}	String name = "TemporaryQueueReplyManager[" + endpoint.getDestinationName() + "]";	answer.setBeanName(name);	if (answer.getConcurrentConsumers() > 1) {	
using concurrent consumers on 

public void onException(JMSException exception) {	
exception inside the dmlc for temporary replyto queue for destination refreshing replyto destination 

public Destination resolveDestinationName(Session session, String destinationName, boolean pubSubDomain) throws JMSException {	synchronized (refreshWanted) {	if (queue == null || refreshWanted.compareAndSet(true, false)) {	queue = session.createTemporaryQueue();	setReplyTo(queue);	if (log.isDebugEnabled()) {	
refreshed temporary replyto queue new queue 

public void destinationReady() throws InterruptedException {	if (refreshWanted.get()) {	synchronized (refreshWanted) {	
waiting for new temporary replyto queue to be assigned before we can continue 

========================= camel sample_7175 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<SoapJaxbDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.soapjaxb.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.soapjaxb.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_596 =========================

await().atMost(2, TimeUnit.SECONDS).until(() -> {	Long num = (Long) mbeanServer.getAttribute(on, "ExchangesInflight");	return num != null && num == 2;	});	inflight = (Long) mbeanServer.getAttribute(on, "ExchangesInflight");	assertEquals(2, inflight.longValue());	ts = (Long) mbeanServer.getAttribute(on, "OldestInflightDuration");	assertNotNull(ts);	id = (String) mbeanServer.getAttribute(on, "OldestInflightExchangeId");	assertNotNull(id);	
oldest exchange id duration 

ts = (Long) mbeanServer.getAttribute(on, "OldestInflightDuration");	assertNotNull(ts);	id = (String) mbeanServer.getAttribute(on, "OldestInflightExchangeId");	assertNotNull(id);	latch1.countDown();	Thread.sleep(200);	Long ts2 = (Long) mbeanServer.getAttribute(on, "OldestInflightDuration");	assertNotNull(ts2);	String id2 = (String) mbeanServer.getAttribute(on, "OldestInflightExchangeId");	assertNotNull(id2);	
oldest exchange id duration 

========================= camel sample_2727 =========================

public void testExpression() throws Exception {	Expression expression = sql("SELECT * FROM org.apache.camel.builder.sql.Person where city = 'London'");	List<?> value = expression.evaluate(exchange, List.class);	assertEquals("List size", 2, value.size());	for (Object person : value) {	
found 

public void testExpressionWithHeaderVariable() throws Exception {	Expression expression = sql("SELECT * FROM org.apache.camel.builder.sql.Person where name = :fooHeader");	List<?> value = expression.evaluate(exchange, List.class);	assertEquals("List size", 1, value.size());	for (Object person : value) {	
found 

========================= camel sample_13467 =========================

private void writeSlowFile() throws Exception {	
writing slow file 

private void writeSlowFile() throws Exception {	FileOutputStream fos = new FileOutputStream("target/changed/in/slowfile.dat");	for (int i = 0; i < 20; i++) {	fos.write(("Line " + i + LS).getBytes());	
writing line 

private void writeSlowFile() throws Exception {	FileOutputStream fos = new FileOutputStream("target/changed/in/slowfile.dat");	for (int i = 0; i < 20; i++) {	fos.write(("Line " + i + LS).getBytes());	Thread.sleep(50);	}	fos.flush();	fos.close();	
writing slow file done 

========================= camel sample_3136 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SqlComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.sql.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.sql.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_980 =========================

CountDownLatch latch = new CountDownLatch((totalRedeliverdFalse * routeCount) + (totalRedeliveredTrue * routeCount));	for (int i = 1; i <= routeCount; i++) {	addRoute(destinationName, i, batchCount, consumerCount, maxAttemptsCount, latch);	getMockEndpoint("mock:test.before." + i).expectedMessageCount(totalRedeliverdFalse);	getMockEndpoint("mock:test.after." + i).expectedMessageCount(totalRedeliveredTrue);	}	getMockEndpoint("mock:test.after").expectedMessageCount(0);	for (int i = 1; i <= messageCount; i++) {	String message = "Hello World " + i;	template.sendBody("direct:start", message);	
sending message 

protected void addRoute(final String destinationName, final int routeNumber, final int batchCount, final int consumerCount, final int maxAttemptsCount, final CountDownLatch latch) throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	if (context.getRoute("direct.route") == null) {	from("direct:start") .id("direct.route") .to(destinationName);	}	from(destinationName + "?transacted=true&transactionBatchCount=" + batchCount + "&consumerCount=" + consumerCount) .id("consumer.route." + routeNumber) .choice().when(header("JMSRedelivered").isEqualTo("false")) .log("Route " + routeNumber + " 1st attempt Body: ${body} | Redeliverd: ${header.JMSRedelivered}") .to("mock:test.before." + routeNumber) .process(new Processor() {	private final AtomicInteger counter = new AtomicInteger(0);	public void process(Exchange exchange) throws Exception {	if (counter.incrementAndGet() == maxAttemptsCount) {	
messages have been processed failing the exchange to force a rollback of the transaction 

========================= camel sample_12333 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<GridFsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mongodb-gridfs.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mongodb-gridfs.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_579 =========================

}	count++;	model = factory.factory();	String[] tokens = line.split(separator, factory.getAutospanLine() ? factory.getMaxpos() : -1);	List<String> result = Arrays.asList(tokens);	result = unquoteTokens(result, separator, quote);	if (result.size() == 0 || result.isEmpty()) {	throw new java.lang.IllegalArgumentException("No records have been defined in the CSV");	} else {	if (LOG.isDebugEnabled()) {	
size of the record splitted 

List<String> result = Arrays.asList(tokens);	result = unquoteTokens(result, separator, quote);	if (result.size() == 0 || result.isEmpty()) {	throw new java.lang.IllegalArgumentException("No records have been defined in the CSV");	} else {	if (LOG.isDebugEnabled()) {	}	factory.bind(getCamelContext(), result, model, count);	factory.link(model);	models.add(model);	
graph of objects created 

========================= camel sample_7460 =========================

models.add(model);	}	}	Collections.sort(models, new ExampleComparator());	long deprecated = models.stream() .filter(m -> "true".equals(m.getDeprecated())) .count();	File file = new File(".", "README.adoc");	boolean exists = file.exists();	String changed = templateExamples(models, deprecated);	boolean updated = updateExamples(file, changed);	if (updated) {	
updated readme adoc file 

}	}	Collections.sort(models, new ExampleComparator());	long deprecated = models.stream() .filter(m -> "true".equals(m.getDeprecated())) .count();	File file = new File(".", "README.adoc");	boolean exists = file.exists();	String changed = templateExamples(models, deprecated);	boolean updated = updateExamples(file, changed);	if (updated) {	} else if (exists) {	
no changes to readme adoc file 

}	Collections.sort(models, new ExampleComparator());	long deprecated = models.stream() .filter(m -> "true".equals(m.getDeprecated())) .count();	File file = new File(".", "README.adoc");	boolean exists = file.exists();	String changed = templateExamples(models, deprecated);	boolean updated = updateExamples(file, changed);	if (updated) {	} else if (exists) {	} else {	
no readme adoc file 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
cannot find markers in file 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
add the following markers 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
t getlog warn 

========================= camel sample_129 =========================

public void process(Exchange exchange) throws Exception {	
processing workflow task 

========================= camel sample_8795 =========================

private List<Dependency> filter(List<Dependency> dependencyList) {	List<Dependency> outDependencies = new ArrayList<>();	DependencyMatcher inclusions = new DependencyMatcher(dependencies.getIncludes());	DependencyMatcher exclusions = new DependencyMatcher(dependencies.getExcludes());	for (Dependency dep : dependencyList) {	boolean accept = inclusions.matches(dep) && !exclusions.matches(dep);	
included in the bom excluded from bom 

========================= camel sample_77 =========================

}	boolean pattern = true;	boolean filter = true;	if (patterns != null) {	pattern = shouldTracePattern(definition);	}	if (predicate != null) {	filter = shouldTraceFilter(exchange);	}	if (LOG.isTraceEnabled()) {	
should trace evaluated pattern filter 

========================= camel sample_4562 =========================

public void xxTestXPatPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(60, TimeUnit.SECONDS);	
processed file with elements in 

public void xxTestXPatPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(60, TimeUnit.SECONDS);	
processed tiny messages 

public void xxTestXPatPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(60, TimeUnit.SECONDS);	
processed small messages 

public void xxTestXPatPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(60, TimeUnit.SECONDS);	
processed medium messages 

public void xxTestXPatPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(60, TimeUnit.SECONDS);	
processed large messages 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("file:target/data?initialDelay=0&delay=10&noop=true") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	
starting to process file 

from("file:target/data?initialDelay=0&delay=10&noop=true") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	watch.restart();	}	}) .split().xpath("/orders/order").streaming() .choice() .when().xpath("/order/amount < 10") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String xml = exchange.getIn().getBody(String.class);	assertTrue(xml, xml.contains("<amount>3</amount>"));	int num = tiny.incrementAndGet();	if (num % 100 == 0) {	
processed tiny messages 

if (num % 100 == 0) {	log.debug(xml);	}	}	}) .when().xpath("/order/amount < 50") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String xml = exchange.getIn().getBody(String.class);	assertTrue(xml, xml.contains("<amount>44</amount>"));	int num = small.incrementAndGet();	if (num % 100 == 0) {	
processed small messages 

if (num % 100 == 0) {	log.debug(xml);	}	}	}) .when().xpath("/order/amount < 100") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String xml = exchange.getIn().getBody(String.class);	assertTrue(xml, xml.contains("<amount>88</amount>"));	int num = med.incrementAndGet();	if (num % 100 == 0) {	
processed medium messages 

if (num % 100 == 0) {	log.debug(xml);	}	}	}) .otherwise() .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String xml = exchange.getIn().getBody(String.class);	assertTrue(xml, xml.contains("<amount>123</amount>"));	int num = large.incrementAndGet();	if (num % 100 == 0) {	
processed large messages 

========================= camel sample_3618 =========================

public void myMethod(String foo, int bar, String x) {	this.foo = foo;	this.bar = bar;	this.x = x;	
mymethod method called on 

========================= camel sample_3248 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<GoogleMailComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.google-mail.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.google-mail.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_742 =========================

public void requestResource() {	
requested to become active from 

public void requestResource() {	try {	lease = leaderSelector.acquire();	} catch (Exception e) {	throw new RuntimeException("Unable to obtain access to become a leader node.");	}	
is now active 

private String createCandidateName() {	StringBuilder builder = new StringBuilder();	try {	builder.append(InetAddress.getLocalHost().getCanonicalHostName());	} catch (UnknownHostException ex) {	
failed to get the local hostname 

private void notifyElectionWatchers() {	for (ElectionWatcher watcher : watchers) {	try {	watcher.electionResultChanged();	} catch (Exception e) {	
election watcher of type threw an exception 

public void stateChanged(CuratorFramework curatorFramework, ConnectionState connectionState) {	switch (connectionState) {	
received state from connection giving up lock 

public void stateChanged(CuratorFramework curatorFramework, ConnectionState connectionState) {	switch (connectionState) {	try {	leaderSelector.returnLease(lease);	} finally {	this.activeNode.set(false);	notifyElectionWatchers();	}	break;	
connection state changed 

========================= camel sample_12671 =========================

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyRouteDuplicateIdTest.java"));	MethodSource<JavaClassSource> method = CamelJavaParserHelper.findConfigureMethod(clazz);	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, false);	for (ParserResult result : list) {	
consumer 

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyRouteDuplicateIdTest.java"));	MethodSource<JavaClassSource> method = CamelJavaParserHelper.findConfigureMethod(clazz);	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, false);	for (ParserResult result : list) {	}	Assert.assertEquals(3, list.size());	list = CamelJavaParserHelper.parseCamelRouteIds(method);	for (ParserResult result : list) {	
route id 

========================= camel sample_191 =========================

PumpStreamHandler handler = new PumpStreamHandler(out, err, command.getInput());	executor.setStreamHandler(handler);	CommandLine cl = toCommandLine(command);	try {	int exitValue = executor.execute(cl);	InputStream stdout = out.size() == 0 ? null : new ByteArrayInputStream(out.toByteArray());	InputStream stderr = err.size() == 0 ? null : new ByteArrayInputStream(err.toByteArray());	ExecResult result = new ExecResult(command, stdout, stderr, exitValue);	return result;	} catch (ExecuteException ee) {	
execexception while executing command 

throw new ExecException("Failed to execute command " + command, stdout, stderr, ee.getExitValue(), ee);	} catch (IOException ioe) {	InputStream stdout = out.size() == 0 ? null : new ByteArrayInputStream(out.toByteArray());	InputStream stderr = err.size() == 0 ? null : new ByteArrayInputStream(err.toByteArray());	int exitValue = 0;	if (executor instanceof ExecDefaultExecutor) {	exitValue = ((ExecDefaultExecutor) executor).getExitValue();	}	String msg = ioe.getMessage();	if (msg != null && "stream closed".equals(msg.toLowerCase(Locale.ENGLISH))) {	
ignoring stream closed ioexception 

InputStream stderr = err.size() == 0 ? null : new ByteArrayInputStream(err.toByteArray());	int exitValue = 0;	if (executor instanceof ExecDefaultExecutor) {	exitValue = ((ExecDefaultExecutor) executor).getExitValue();	}	String msg = ioe.getMessage();	if (msg != null && "stream closed".equals(msg.toLowerCase(Locale.ENGLISH))) {	ExecResult result = new ExecResult(command, stdout, stderr, exitValue);	return result;	}	
ioexception while executing command 

========================= camel sample_12221 =========================

protected void before() throws Throwable {	
starting embedded broker on 

protected void after() {	try {	
stopping embedded broker 

========================= camel sample_12364 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<MllpComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mllp.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mllp.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_939 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<RefLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.ref.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.ref.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_893 =========================

public void addServiceDiscoveryConfigurations() {	if (!(beanFactory instanceof ConfigurableBeanFactory)) {	
beanfactory is not of type configurablebeanfactory 

========================= camel sample_13431 =========================

private void startAllStoppedConsumers() {	try {	lock.lock();	if (!suspendedRoutes.isEmpty()) {	if (log.isDebugEnabled()) {	
have been stopped previously by policy restarting 

========================= camel sample_12670 =========================

public void testFoo() throws Exception {	
adding a route locally 

========================= camel sample_190 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<BeanstalkComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.beanstalk.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.beanstalk.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_485 =========================

public void testSendMessagesThenBrowseQueue() throws Exception {	for (int i = 0; i < expectedBodies.length; i++) {	Object expectedBody = expectedBodies[i];	template.sendBodyAndHeader("activemq:test.b", expectedBody, "counter", i);	}	JmsQueueEndpoint endpoint = getMandatoryEndpoint("activemq:test.b?maximumBrowseSize=6", JmsQueueEndpoint.class);	assertEquals(6, endpoint.getMaximumBrowseSize());	List<Exchange> list = endpoint.getExchanges();	
received 

Object expectedBody = expectedBodies[i];	template.sendBodyAndHeader("activemq:test.b", expectedBody, "counter", i);	}	JmsQueueEndpoint endpoint = getMandatoryEndpoint("activemq:test.b?maximumBrowseSize=6", JmsQueueEndpoint.class);	assertEquals(6, endpoint.getMaximumBrowseSize());	List<Exchange> list = endpoint.getExchanges();	assertEquals("Size of list", 6, endpoint.getExchanges().size());	int index = -1;	for (Exchange exchange : list) {	String actual = exchange.getIn().getBody(String.class);	
received body 

public void testSendMessagesThenBrowseQueueLimitNotHit() throws Exception {	for (int i = 0; i < expectedBodies.length; i++) {	Object expectedBody = expectedBodies[i];	template.sendBodyAndHeader("activemq:test.b", expectedBody, "counter", i);	}	JmsQueueEndpoint endpoint = getMandatoryEndpoint("activemq:test.b?maximumBrowseSize=10", JmsQueueEndpoint.class);	assertEquals(10, endpoint.getMaximumBrowseSize());	List<Exchange> list = endpoint.getExchanges();	
received 

Object expectedBody = expectedBodies[i];	template.sendBodyAndHeader("activemq:test.b", expectedBody, "counter", i);	}	JmsQueueEndpoint endpoint = getMandatoryEndpoint("activemq:test.b?maximumBrowseSize=10", JmsQueueEndpoint.class);	assertEquals(10, endpoint.getMaximumBrowseSize());	List<Exchange> list = endpoint.getExchanges();	assertEquals("Size of list", 8, endpoint.getExchanges().size());	int index = -1;	for (Exchange exchange : list) {	String actual = exchange.getIn().getBody(String.class);	
received body 

public void testSendMessagesThenBrowseQueueNoMax() throws Exception {	for (int i = 0; i < expectedBodies.length; i++) {	Object expectedBody = expectedBodies[i];	template.sendBodyAndHeader("activemq:test.b", expectedBody, "counter", i);	}	JmsQueueEndpoint endpoint = getMandatoryEndpoint("activemq:test.b", JmsQueueEndpoint.class);	assertEquals(-1, endpoint.getMaximumBrowseSize());	List<Exchange> list = endpoint.getExchanges();	
received 

Object expectedBody = expectedBodies[i];	template.sendBodyAndHeader("activemq:test.b", expectedBody, "counter", i);	}	JmsQueueEndpoint endpoint = getMandatoryEndpoint("activemq:test.b", JmsQueueEndpoint.class);	assertEquals(-1, endpoint.getMaximumBrowseSize());	List<Exchange> list = endpoint.getExchanges();	assertEquals("Size of list", 8, endpoint.getExchanges().size());	int index = -1;	for (Exchange exchange : list) {	String actual = exchange.getIn().getBody(String.class);	
received body 

========================= camel sample_7066 =========================

assertMockEndpointsSatisfied();	for (int i = 0; i < 50; i++) {	context.stopRoute("foo");	context.startRoute("foo");	}	resetMocks();	getMockEndpoint("mock:foo").expectedMessageCount(1);	template.sendBodyAndHeader("file:target/leak", "Bye World", Exchange.FILE_NAME, "bye.txt");	assertMockEndpointsSatisfied();	int active = Thread.activeCount() - before;	
active threads after restarts 

========================= camel sample_3025 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<QueueServiceComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.azure-queue.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.azure-queue.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1018 =========================

public DefaultServerPipelineFactory(NettyServerBootstrapConfiguration configuration) {	this.consumer = null;	try {	this.sslContext = createSSLContext(null, configuration);	} catch (Exception e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	}	if (sslContext != null) {	
created sslcontext 

public DefaultServerPipelineFactory(NettyConsumer consumer) {	this.consumer = consumer;	try {	this.sslContext = createSSLContext(consumer.getContext(), consumer.getConfiguration());	} catch (Exception e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	}	if (sslContext != null) {	
created sslcontext 

public ChannelPipeline getPipeline() throws Exception {	ChannelPipeline channelPipeline = Channels.pipeline();	SslHandler sslHandler = configureServerSSLOnDemand();	if (sslHandler != null) {	sslHandler.setCloseOnSSLException(true);	
server ssl handler configured and added as an interceptor against the channelpipeline 

for (int x = 0; x < decoders.size(); x++) {	ChannelHandler decoder = decoders.get(x);	if (decoder instanceof ChannelHandlerFactory) {	decoder = ((ChannelHandlerFactory) decoder).newChannelHandler();	}	addToPipeline("decoder-" + x, channelPipeline, decoder);	}	if (consumer.getConfiguration().isOrderedThreadPoolExecutor()) {	ExecutionHandler executionHandler = new ExecutionHandler(consumer.getEndpoint().getComponent().getExecutorService());	addToPipeline("executionHandler", channelPipeline, executionHandler);	
using orderedmemoryawarethreadpoolexecutor with core pool size 

if (decoder instanceof ChannelHandlerFactory) {	decoder = ((ChannelHandlerFactory) decoder).newChannelHandler();	}	addToPipeline("decoder-" + x, channelPipeline, decoder);	}	if (consumer.getConfiguration().isOrderedThreadPoolExecutor()) {	ExecutionHandler executionHandler = new ExecutionHandler(consumer.getEndpoint().getComponent().getExecutorService());	addToPipeline("executionHandler", channelPipeline, executionHandler);	}	addToPipeline("handler", channelPipeline, new ServerChannelHandler(consumer));	
created channelpipeline 

private SSLContext createSSLContext(CamelContext camelContext, NettyServerBootstrapConfiguration configuration) throws Exception {	if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(camelContext);	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	
keystorefile is null 

if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(camelContext);	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	
truststorefile is null 

}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(camelContext);	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	}	if (configuration.getPassphrase().toCharArray() == null) {	
passphrase is null 

========================= camel sample_6677 =========================

public void start() throws Exception {	if (queue == null) {	AS400 system = endpoint.getSystem();	if (endpoint.isKeyed()) {	queue = new KeyedDataQueue(system, endpoint.getObjectPath());	} else {	queue = new DataQueue(system, endpoint.getObjectPath());	}	}	if (!queue.getSystem().isConnected(AS400.DATAQUEUE)) {	
connecting to 

public void stop() throws Exception {	if (queue != null) {	
releasing connection to 

========================= camel sample_16776 =========================

public void setUp() throws Exception {	log.info("*******************************************************************");	
test 

========================= camel sample_5688 =========================

exchange = pollingConsumer.receiveNoWait();	} else if (timeout < 0) {	exchange = pollingConsumer.receive();	} else {	exchange = pollingConsumer.receive(timeout);	}	if (exchange == null) {	break;	}	messagesPolled++;	
polled 

========================= camel sample_4099 =========================

private Runnable createTask(boolean maxMessagesHit) {	return () -> {	try {	String tail;	if (maxMessagesHit) {	tail = " due max messages " + getMaxMessages() + " processed";	} else {	tail = " due max seconds " + getMaxSeconds();	}	if (action == Action.STOP_CAMEL_CONTEXT) {	
stopping camelcontext 

try {	String tail;	if (maxMessagesHit) {	tail = " due max messages " + getMaxMessages() + " processed";	} else {	tail = " due max seconds " + getMaxSeconds();	}	if (action == Action.STOP_CAMEL_CONTEXT) {	camelContext.stop();	} else if (action == Action.STOP_ROUTE) {	
stopping route 

if (maxMessagesHit) {	tail = " due max messages " + getMaxMessages() + " processed";	} else {	tail = " due max seconds " + getMaxSeconds();	}	if (action == Action.STOP_CAMEL_CONTEXT) {	camelContext.stop();	} else if (action == Action.STOP_ROUTE) {	camelContext.stopRoute(routeId);	} else if (action == Action.SUSPEND_ROUTE) {	
suspending route 

} else {	tail = " due max seconds " + getMaxSeconds();	}	if (action == Action.STOP_CAMEL_CONTEXT) {	camelContext.stop();	} else if (action == Action.STOP_ROUTE) {	camelContext.stopRoute(routeId);	} else if (action == Action.SUSPEND_ROUTE) {	camelContext.suspendRoute(routeId);	} else if (action == Action.SUSPEND_ALL_ROUTES) {	
suspending all routes 

if (action == Action.STOP_CAMEL_CONTEXT) {	camelContext.stop();	} else if (action == Action.STOP_ROUTE) {	camelContext.stopRoute(routeId);	} else if (action == Action.SUSPEND_ROUTE) {	camelContext.suspendRoute(routeId);	} else if (action == Action.SUSPEND_ALL_ROUTES) {	camelContext.suspend();	}	} catch (Throwable e) {	
error performing action 

========================= camel sample_4133 =========================

protected void doStart() throws Exception {	ObjectHelper.notNull(camelContext, "CamelContext");	if (curator == null) {	try {	CuratorFramework aCurator = getCamelContext().getRegistry().lookupByNameAndType("curator", CuratorFramework.class);	if (aCurator != null) {	
curatorframework found in camelregistry 

connectString = zkHost + ":" + (zkPort == null ? "2181" : zkPort);	}	}	if (connectString == null) {	connectString = System.getProperty(ZOOKEEPER_URL, "localhost:2181");	}	String password = getZooKeeperPassword();	if (password == null) {	System.getProperty(ZOOKEEPER_PASSWORD);	}	
creating new curatorframework with connection 

}	String password = getZooKeeperPassword();	if (password == null) {	System.getProperty(ZOOKEEPER_PASSWORD);	}	CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder() .connectString(connectString) .retryPolicy(new RetryOneTime(1000)) .connectionTimeoutMs(getMaximumConnectionTimeout());	if (password != null && !password.isEmpty()) {	builder.authorization("digest", ("fabric:" + password).getBytes());	}	curator = builder.build();	
starting curatorframework 

public void stateChanged(CuratorFramework client, ConnectionState newState) {	
curatorframework state changed 

========================= camel sample_9701 =========================

request.withPlacement(placement);	}	if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(EC2Constants.SUBNET_ID))) {	String subnetId = exchange.getIn().getHeader(EC2Constants.SUBNET_ID, String.class);	request.withSubnetId(subnetId);	}	RunInstancesResult result;	try {	result = ec2Client.runInstances(request);	} catch (AmazonServiceException ase) {	
run instances command returned the error code 

if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(EC2Constants.SUBNET_ID))) {	String subnetId = exchange.getIn().getHeader(EC2Constants.SUBNET_ID, String.class);	request.withSubnetId(subnetId);	}	RunInstancesResult result;	try {	result = ec2Client.runInstances(request);	} catch (AmazonServiceException ase) {	throw ase;	}	
creating and running instances with ami and instance type 

if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(EC2Constants.INSTANCES_IDS))) {	instanceIds = exchange.getIn().getHeader(EC2Constants.INSTANCES_IDS, Collection.class);	request.withInstanceIds(instanceIds);	} else {	throw new IllegalArgumentException("Instances Ids must be specified");	}	StartInstancesResult result;	try {	result = ec2Client.startInstances(request);	} catch (AmazonServiceException ase) {	
start instances command returned the error code 

request.withInstanceIds(instanceIds);	} else {	throw new IllegalArgumentException("Instances Ids must be specified");	}	StartInstancesResult result;	try {	result = ec2Client.startInstances(request);	} catch (AmazonServiceException ase) {	throw ase;	}	
starting instances with ids 

if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(EC2Constants.INSTANCES_IDS))) {	instanceIds = exchange.getIn().getHeader(EC2Constants.INSTANCES_IDS, Collection.class);	request.withInstanceIds(instanceIds);	} else {	throw new IllegalArgumentException("Instances Ids must be specified");	}	StopInstancesResult result;	try {	result = ec2Client.stopInstances(request);	} catch (AmazonServiceException ase) {	
stop instances command returned the error code 

request.withInstanceIds(instanceIds);	} else {	throw new IllegalArgumentException("Instances Ids must be specified");	}	StopInstancesResult result;	try {	result = ec2Client.stopInstances(request);	} catch (AmazonServiceException ase) {	throw ase;	}	
stopping instances with ids 

if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(EC2Constants.INSTANCES_IDS))) {	instanceIds = exchange.getIn().getHeader(EC2Constants.INSTANCES_IDS, Collection.class);	request.withInstanceIds(instanceIds);	} else {	throw new IllegalArgumentException("Instances Ids must be specified");	}	TerminateInstancesResult result;	try {	result = ec2Client.terminateInstances(request);	} catch (AmazonServiceException ase) {	
terminate instances command returned the error code 

request.withInstanceIds(instanceIds);	} else {	throw new IllegalArgumentException("Instances Ids must be specified");	}	TerminateInstancesResult result;	try {	result = ec2Client.terminateInstances(request);	} catch (AmazonServiceException ase) {	throw ase;	}	
terminating instances with ids 

Collection instanceIds;	DescribeInstancesRequest request = new DescribeInstancesRequest();	if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(EC2Constants.INSTANCES_IDS))) {	instanceIds = exchange.getIn().getHeader(EC2Constants.INSTANCES_IDS, Collection.class);	request.withInstanceIds(instanceIds);	}	DescribeInstancesResult result;	try {	result = ec2Client.describeInstances(request);	} catch (AmazonServiceException ase) {	
describe instances command returned the error code 

Collection instanceIds;	DescribeInstanceStatusRequest request = new DescribeInstanceStatusRequest();	if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(EC2Constants.INSTANCES_IDS))) {	instanceIds = exchange.getIn().getHeader(EC2Constants.INSTANCES_IDS, Collection.class);	request.withInstanceIds(instanceIds);	}	DescribeInstanceStatusResult result;	try {	result = ec2Client.describeInstanceStatus(request);	} catch (AmazonServiceException ase) {	
describe instances status command returned the error code 

private void rebootInstances(AmazonEC2Client ec2Client, Exchange exchange) {	Collection instanceIds;	RebootInstancesRequest request = new RebootInstancesRequest();	if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(EC2Constants.INSTANCES_IDS))) {	instanceIds = exchange.getIn().getHeader(EC2Constants.INSTANCES_IDS, Collection.class);	request.withInstanceIds(instanceIds);	} else {	throw new IllegalArgumentException("Instances Ids must be specified");	}	try {	
rebooting instances with ids 

RebootInstancesRequest request = new RebootInstancesRequest();	if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(EC2Constants.INSTANCES_IDS))) {	instanceIds = exchange.getIn().getHeader(EC2Constants.INSTANCES_IDS, Collection.class);	request.withInstanceIds(instanceIds);	} else {	throw new IllegalArgumentException("Instances Ids must be specified");	}	try {	ec2Client.rebootInstances(request);	} catch (AmazonServiceException ase) {	
reboot instances command returned the error code 

if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(EC2Constants.INSTANCES_IDS))) {	instanceIds = exchange.getIn().getHeader(EC2Constants.INSTANCES_IDS, Collection.class);	request.withInstanceIds(instanceIds);	} else {	throw new IllegalArgumentException("Instances Ids must be specified");	}	MonitorInstancesResult result;	try {	result = ec2Client.monitorInstances(request);	} catch (AmazonServiceException ase) {	
monitor instances command returned the error code 

request.withInstanceIds(instanceIds);	} else {	throw new IllegalArgumentException("Instances Ids must be specified");	}	MonitorInstancesResult result;	try {	result = ec2Client.monitorInstances(request);	} catch (AmazonServiceException ase) {	throw ase;	}	
start monitoring instances with ids 

if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(EC2Constants.INSTANCES_IDS))) {	instanceIds = exchange.getIn().getHeader(EC2Constants.INSTANCES_IDS, Collection.class);	request.withInstanceIds(instanceIds);	} else {	throw new IllegalArgumentException("Instances Ids must be specified");	}	UnmonitorInstancesResult result;	try {	result = ec2Client.unmonitorInstances(request);	} catch (AmazonServiceException ase) {	
unmonitor instances command returned the error code 

request.withInstanceIds(instanceIds);	} else {	throw new IllegalArgumentException("Instances Ids must be specified");	}	UnmonitorInstancesResult result;	try {	result = ec2Client.unmonitorInstances(request);	} catch (AmazonServiceException ase) {	throw ase;	}	
stop monitoring instances with ids 

if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(EC2Constants.INSTANCES_TAGS))) {	tags = exchange.getIn().getHeader(EC2Constants.INSTANCES_TAGS, Collection.class);	request.withTags(tags);	} else {	throw new IllegalArgumentException("Tags must be specified");	}	CreateTagsResult result = new CreateTagsResult();	try {	result = ec2Client.createTags(request);	} catch (AmazonServiceException ase) {	
create tags command returned the error code 

request.withTags(tags);	} else {	throw new IllegalArgumentException("Tags must be specified");	}	CreateTagsResult result = new CreateTagsResult();	try {	result = ec2Client.createTags(request);	} catch (AmazonServiceException ase) {	throw ase;	}	
created tags on resources with ids 

if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(EC2Constants.INSTANCES_TAGS))) {	tags = exchange.getIn().getHeader(EC2Constants.INSTANCES_TAGS, Collection.class);	request.withTags(tags);	} else {	throw new IllegalArgumentException("Tags must be specified");	}	DeleteTagsResult result = new DeleteTagsResult();	try {	result = ec2Client.deleteTags(request);	} catch (AmazonServiceException ase) {	
delete tags command returned the error code 

request.withTags(tags);	} else {	throw new IllegalArgumentException("Tags must be specified");	}	DeleteTagsResult result = new DeleteTagsResult();	try {	result = ec2Client.deleteTags(request);	} catch (AmazonServiceException ase) {	throw ase;	}	
delete tags on resources with ids 

========================= camel sample_8813 =========================

public void testBeanOgnlPerformance() throws Exception {	StopWatch watch = new StopWatch();	getMockEndpoint("mock:result").expectedMessageCount(size);	for (int i = 0; i < size; i++) {	template.sendBody("direct:start", "Hello World");	}	assertMockEndpointsSatisfied();	
took millis 

========================= camel sample_3249 =========================

outputs = new HashMap<String, Map<String, String>>();	}	if (getCamelContext().getManagementStrategy().getManagementAgent() != null) {	extended = getCamelContext().getManagementStrategy().getManagementAgent().getStatisticsLevel().isExtended();	}	if (extended) {	inputUtilization = new DefaultEndpointUtilizationStatistics(limit);	outputUtilization = new DefaultEndpointUtilizationStatistics(limit);	}	if (extended) {	
runtime endpoint registry is in extended mode gathering usage statistics of all incoming and outgoing endpoints cache limit 

}	if (getCamelContext().getManagementStrategy().getManagementAgent() != null) {	extended = getCamelContext().getManagementStrategy().getManagementAgent().getStatisticsLevel().isExtended();	}	if (extended) {	inputUtilization = new DefaultEndpointUtilizationStatistics(limit);	outputUtilization = new DefaultEndpointUtilizationStatistics(limit);	}	if (extended) {	} else {	
runtime endpoint registry is in normal mode gathering information of all incoming and outgoing endpoints cache limit 

========================= camel sample_4076 =========================

} catch (Exception e) {	e.printStackTrace();	break;	}	}	}	});	thread.start();	for (int i = 0; i < numberOfMessages; i++) {	if (i == 5) {	
stopping mqtt transport 

}	});	thread.start();	for (int i = 0; i < numberOfMessages; i++) {	if (i == 5) {	brokerService.getTransportConnectorByScheme("mqtt").stop();	Thread starter = new Thread(new Runnable() {	public void run() {	try {	Thread.sleep(3000);	
starting mqtt transport again 

========================= camel sample_16849 =========================

public Drive makeClient(String clientId, String clientSecret, Collection<String> scopes, String applicationName, String refreshToken, String accessToken) {	Credential credential;	try {	credential = authorize(clientId, clientSecret, scopes);	return new Drive.Builder(transport, jsonFactory, credential).setApplicationName(applicationName).build();	} catch (Exception e) {	
could not create google drive client 

========================= camel sample_15418 =========================

public void serve() {	try {	serverTransport_.listen();	} catch (TTransportException ttx) {	
error occurred during listening 

retryCount++;	try {	if (remainTimeInMillis > 0) {	long sleepTimeInMillis = ((long)(random.nextDouble() * (1L << Math.min(retryCount, 20)))) * beBackoffSlotInMillis;	sleepTimeInMillis = Math.min(sleepTimeInMillis, remainTimeInMillis);	TimeUnit.MILLISECONDS.sleep(sleepTimeInMillis);	remainTimeInMillis = remainTimeInMillis - sleepTimeInMillis;	} else {	client.close();	wp = null;	
task has been rejected by executorservice times till timedout reason 

long sleepTimeInMillis = ((long)(random.nextDouble() * (1L << Math.min(retryCount, 20)))) * beBackoffSlotInMillis;	sleepTimeInMillis = Math.min(sleepTimeInMillis, remainTimeInMillis);	TimeUnit.MILLISECONDS.sleep(sleepTimeInMillis);	remainTimeInMillis = remainTimeInMillis - sleepTimeInMillis;	} else {	client.close();	wp = null;	break;	}	} catch (InterruptedException e) {	
interrupted while waiting to place client on executor queue 

} else {	client.close();	wp = null;	break;	}	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	break;	}	} else if (t instanceof Error) {	
executorservice threw error 

wp = null;	break;	}	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	break;	}	} else if (t instanceof Error) {	throw (Error)t;	} else {	
executorservice threw error 

} else if (t instanceof Error) {	throw (Error)t;	} else {	break;	}	}	}	} catch (TTransportException ttx) {	if (!stopped_) {	++failureCount;	
transport error occurred during acceptance of message 

if (eventHandler != null) {	eventHandler.processContext(connectionContext, inputTransport, outputTransport);	}	if (stopped_ || !processor.process(inputProtocol, outputProtocol)) {	break;	}	}	} catch (TSaslTransportException ttx) {	} catch (TTransportException ttx) {	} catch (TException tx) {	
thrift error occurred during processing of message 

eventHandler.processContext(connectionContext, inputTransport, outputTransport);	}	if (stopped_ || !processor.process(inputProtocol, outputProtocol)) {	break;	}	}	} catch (TSaslTransportException ttx) {	} catch (TTransportException ttx) {	} catch (TException tx) {	} catch (Exception x) {	
error occurred during processing of message 

========================= camel sample_13036 =========================

public void populateCamelHeaders(HttpServerExchange httpExchange, Map<String, Object> headersMap, Exchange exchange) throws Exception {	
populatecamelheaders 

if (endpoint.getHttpURI() != null) {	String endpointPath = endpoint.getHttpURI().getPath();	String matchPath = path.toLowerCase(Locale.US);	String match = endpointPath.toLowerCase(Locale.US);	if (matchPath.startsWith(match)) {	path = path.substring(endpointPath.length());	}	}	headersMap.put(Exchange.HTTP_PATH, path);	if (LOG.isTraceEnabled()) {	
http method 

if (endpoint.getHttpURI() != null) {	String endpointPath = endpoint.getHttpURI().getPath();	String matchPath = path.toLowerCase(Locale.US);	String match = endpointPath.toLowerCase(Locale.US);	if (matchPath.startsWith(match)) {	path = path.substring(endpointPath.length());	}	}	headersMap.put(Exchange.HTTP_PATH, path);	if (LOG.isTraceEnabled()) {	
http uri 

String value = httpExchange.getRequestHeaders().get(name).toString();	if (value != null && value.trim().startsWith("Basic")) {	if (headerFilterStrategy != null && !headerFilterStrategy.applyFilterToExternalHeaders(Exchange.AUTHENTICATION, "Basic", exchange)) {	UndertowHelper.appendHeader(headersMap, Exchange.AUTHENTICATION, "Basic");	}	}	}	Iterator<?> it = httpExchange.getRequestHeaders().get(name).iterator();	while (it.hasNext()) {	Object value = it.next();	
http header 

}	}	Map<String, Deque<String>> pathParameters = httpExchange.getQueryParameters();	if (!pathParameters.isEmpty()) {	for (Map.Entry<String, Deque<String>> entry : pathParameters.entrySet()) {	String name = entry.getKey();	Object values = entry.getValue();	Iterator<?> it = ObjectHelper.createIterator(values);	while (it.hasNext()) {	Object value = it.next();	
uri parameter 

if (headerFilterStrategy != null && !headerFilterStrategy.applyFilterToExternalHeaders(name, value, exchange)) {	UndertowHelper.appendHeader(headersMap, name, value);	}	}	}	}	Map<String, Object> predicateContextParams = httpExchange.getAttachment(Predicate.PREDICATE_CONTEXT);	if (predicateContextParams != null) {	predicateContextParams.remove("remaining");	for (String paramName : predicateContextParams.keySet()) {	
rest template variable 

public void populateCamelHeaders(ClientResponse response, Map<String, Object> headersMap, Exchange exchange) throws Exception {	
populatecamelheaders 

String value = response.getResponseHeaders().get(name).toString();	if (value != null && value.trim().startsWith("Basic")) {	if (headerFilterStrategy != null && !headerFilterStrategy.applyFilterToExternalHeaders(Exchange.AUTHENTICATION, "Basic", exchange)) {	UndertowHelper.appendHeader(headersMap, Exchange.AUTHENTICATION, "Basic");	}	}	}	Iterator<?> it = response.getResponseHeaders().get(name).iterator();	while (it.hasNext()) {	Object value = it.next();	
http header 

PrintWriter pw = new PrintWriter(sw);	exception.printStackTrace(pw);	body = ByteBuffer.wrap(sw.toString().getBytes());	message.setHeader(Exchange.CONTENT_TYPE, "text/plain");	}	ExchangeHelper.setFailureHandled(message.getExchange());	}	String contentType = MessageHelper.getContentType(message);	if (contentType != null) {	httpExchange.getResponseHeaders().put(Headers.CONTENT_TYPE, contentType);	
content type 

public Object toHttpRequest(ClientRequest clientRequest, Message message) {	Object body = message.getBody();	final HeaderMap requestHeaders = clientRequest.getRequestHeaders();	String contentType = MessageHelper.getContentType(message);	if (contentType != null) {	requestHeaders.put(Headers.CONTENT_TYPE, contentType);	
content type 

========================= camel sample_13173 =========================

public void testSuccess() throws Exception {	sendMessage();	assertTrue("Exchange did not complete.", doneLatch.await(5, TimeUnit.SECONDS));	assertNull("Should not have failed", failed);	assertNotNull("Should have received completed notification", completed);	assertEquals("Should have propagated the header inside the Synchronization.onComplete() callback", "bar", foo);	assertNull("The Synchronization.onFailure() callback should have not been invoked", baz);	
received completed 

public void testFail() throws Exception {	sendMessage();	assertTrue("Exchange did not complete.", doneLatch.await(5, TimeUnit.SECONDS));	assertNull("Should not have completed", completed);	assertNotNull("Should have received failed notification", failed);	assertEquals("Should have propagated the header inside the Synchronization.onFailure() callback", "bat", baz);	assertNull("The Synchronization.onComplete() callback should have not been invoked", foo);	
received fail 

public void testException() throws Exception {	sendMessage();	assertTrue("Exchange did not complete.", doneLatch.await(5, TimeUnit.SECONDS));	assertNull("Should not have completed", completed);	assertNotNull("Should have received failed notification", failed);	assertEquals("Should have propagated the header inside the Synchronization.onFailure() callback", "bat", baz);	assertNull("The Synchronization.onComplete() callback should have not been invoked", foo);	
received fail 

protected RouteBuilder createRouteBuilder() {	return new RouteBuilder() {	public void configure() {	from("seda:async").to("direct:foo");	from("direct:foo").process(new Processor() {	public void process(Exchange exchange) throws Exception {	
received 

protected RouteBuilder createRouteBuilder() {	return new RouteBuilder() {	public void configure() {	from("seda:async").to("direct:foo");	from("direct:foo").process(new Processor() {	public void process(Exchange exchange) throws Exception {	exchange.getUnitOfWork().addSynchronization(synchronization);	String name = getName();	if (name.equals("testFail")) {	
failing test 

public void configure() {	from("seda:async").to("direct:foo");	from("direct:foo").process(new Processor() {	public void process(Exchange exchange) throws Exception {	exchange.getUnitOfWork().addSynchronization(synchronization);	String name = getName();	if (name.equals("testFail")) {	exchange.getOut().setFault(true);	exchange.getOut().setBody("testFail() should always fail with a fault!");	} else if (name.equals("testException")) {	
throwing exception 

========================= camel sample_2233 =========================

public void test() throws Exception {	CamelContext context = new DefaultCamelContext();	context.addRoutes(createRouteBuilder());	SjmsComponent component = context.getComponent("sjms", SjmsComponent.class);	component.setConnectionFactory(CamelJmsTestHelper.createConnectionFactory());	try {	context.start();	} catch (Throwable t) {	
exception was thrown as expected 

========================= camel sample_12332 =========================

type = "silver";	} else if (i % 2 == 0) {	type = "gold";	} else {	type = "bronze";	}	template.sendBodyAndHeader("activemq:queue:inbox", "Message " + i, "type", type);	}	assertMockEndpointsSatisfied();	long delta = System.currentTimeMillis() - start;	
routeperformancetest sent took ms 

========================= camel sample_7031 =========================

public void initAnnotatedFields() {	for (Class<?> cl : models) {	List<Field> linkFields = new ArrayList<Field>();	for (Field field : cl.getDeclaredFields()) {	KeyValuePairField keyValuePairField = field.getAnnotation(KeyValuePairField.class);	if (keyValuePairField != null) {	if (LOG.isDebugEnabled()) {	
key declared in the class key field 

KeyValuePairField keyValuePairField = field.getAnnotation(KeyValuePairField.class);	if (keyValuePairField != null) {	if (LOG.isDebugEnabled()) {	}	keyValuePairFields.put(keyValuePairField.tag(), keyValuePairField);	annotatedFields.put(keyValuePairField.tag(), field);	}	Link linkField = field.getAnnotation(Link.class);	if (linkField != null) {	if (LOG.isDebugEnabled()) {	
class linked field 

public void bind(CamelContext camelContext, List<String> data, Map<String, Object> model, int line, Map<String, List<Object>> lists) throws Exception {	Map<Integer, List<String>> results = new HashMap<Integer, List<String>>();	
key value pairs data 

public void bind(CamelContext camelContext, List<String> data, Map<String, Object> model, int line, Map<String, List<Object>> lists) throws Exception {	Map<Integer, List<String>> results = new HashMap<Integer, List<String>>();	ObjectHelper.notNull(keyValuePairSeparator, "Key Value Pair not defined in the @Message annotation");	for (String s : data) {	String[] keyValuePair = s.split(getKeyValuePairSeparator());	if (keyValuePair.length > 1) {	int key = Integer.parseInt(keyValuePair[0]);	String value = keyValuePair[1];	
key value 

}	} else {	if (values.size() >= 1) {	if (obj != null) {	value = values.get(0);	Object result = null;	if (value != null) {	FormattingOptions formattingOptions = ConverterUtils.convert(keyValuePairField, field.getType(), field.getAnnotation(BindyConverter.class), getLocale());	Format<?> format = formatFactory.getFormat(formattingOptions);	result = formatField(format, value, key, line);	
value formated 

for (int i = 0; i < values.size(); i++) {	if ((!l.isEmpty()) && (l.size() > i)) {	obj = l.get(i);	} else {	obj = clazz.newInstance();	}	value = values.get(i);	FormattingOptions formattingOptions = ConverterUtils.convert(keyValuePairField, field.getType(), field.getAnnotation(BindyConverter.class), getLocale());	Format<?> format = formatFactory.getFormat(formattingOptions);	Object result = formatField(format, value, key, line);	
value formated 

public String unbind(CamelContext camelContext, Map<String, Object> model) throws Exception {	StringBuilder builder = new StringBuilder();	Map<Integer, KeyValuePairField> keyValuePairFieldsSorted = new TreeMap<Integer, KeyValuePairField>(keyValuePairFields);	Iterator<Integer> it = keyValuePairFieldsSorted.keySet().iterator();	Map<Integer, String> positions = new TreeMap<Integer, String>();	ObjectHelper.notNull(this.pairSeparator, "The pair separator has not been instantiated or property not defined in the @Message annotation");	char separator = ConverterUtils.getCharDelimiter(this.getPairSeparator());	if (LOG.isDebugEnabled()) {	
separator converted from 

ObjectHelper.notNull(this.pairSeparator, "The pair separator has not been instantiated or property not defined in the @Message annotation");	char separator = ConverterUtils.getCharDelimiter(this.getPairSeparator());	if (LOG.isDebugEnabled()) {	}	while (it.hasNext()) {	KeyValuePairField keyValuePairField = keyValuePairFieldsSorted.get(it.next());	ObjectHelper.notNull(keyValuePairField, "KeyValuePair");	Field field = annotatedFields.get(keyValuePairField.tag());	field.setAccessible(true);	if (LOG.isDebugEnabled()) {	
tag field type class 

}	Class<?> type = field.getType();	FormattingOptions formattingOptions = ConverterUtils.convert(keyValuePairField, field.getType(), field.getAnnotation(BindyConverter.class), getLocale());	Format<Object> format = (Format<Object>) formatFactory.getFormat(formattingOptions);	Object obj = model.get(field.getDeclaringClass().getName());	if (obj != null) {	Object keyValue = field.get(obj);	if (this.isMessageOrdered()) {	Integer key1 = sections.get(obj.getClass().getName());	Integer key2 = keyValuePairField.position();	
key of the section and the field 

FormattingOptions formattingOptions = ConverterUtils.convert(keyValuePairField, field.getType(), field.getAnnotation(BindyConverter.class), getLocale());	Format<Object> format = (Format<Object>) formatFactory.getFormat(formattingOptions);	Object obj = model.get(field.getDeclaringClass().getName());	if (obj != null) {	Object keyValue = field.get(obj);	if (this.isMessageOrdered()) {	Integer key1 = sections.get(obj.getClass().getName());	Integer key2 = keyValuePairField.position();	Integer keyGenerated = generateKey(key1, key2);	if (LOG.isDebugEnabled()) {	
key generated for section 

}	if (keyValue != null) {	String valueFormatted;	try {	valueFormatted = format.format(keyValue);	} catch (Exception e) {	throw new IllegalArgumentException("Formatting error detected for the tag: " + keyValuePairField.tag(), e);	}	String value = keyValuePairField.tag() + this.getKeyValuePairSeparator() + valueFormatted;	if (LOG.isDebugEnabled()) {	
value to be formatted for the tag and its formatted value 

try {	valueFormatted = format.format(keyValue);	} catch (Exception e) {	throw new IllegalArgumentException("Formatting error detected for the tag: " + keyValuePairField.tag(), e);	}	String value = keyValuePairField.tag() + this.getKeyValuePairSeparator() + valueFormatted;	if (LOG.isDebugEnabled()) {	}	positions.put(keyGenerated, value);	if (LOG.isDebugEnabled()) {	
positions size 

if (keyValue != null) {	String valueFormatted;	try {	valueFormatted = format.format(keyValue);	} catch (Exception e) {	throw new IllegalArgumentException("Formatting error detected for the tag: " + keyValuePairField.tag(), e);	}	String value = keyValuePairField.tag() + this.getKeyValuePairSeparator() + valueFormatted + separator;	builder.append(value);	if (LOG.isDebugEnabled()) {	
value added 

}	}	}	}	}	if (this.isMessageOrdered()) {	Iterator<Integer> posit = positions.keySet().iterator();	while (posit.hasNext()) {	String value = positions.get(posit.next());	if (LOG.isDebugEnabled()) {	
value added at the position 

private void initMessageParameters() {	if ((pairSeparator == null) || (keyValuePairSeparator == null)) {	for (Class<?> cl : models) {	Message message = cl.getAnnotation(Message.class);	Section section = cl.getAnnotation(Section.class);	if (message != null) {	ObjectHelper.notNull(message.pairSeparator(), "No Pair Separator has been defined in the @Message annotation");	pairSeparator = message.pairSeparator();	
pair separator defined for the message 

private void initMessageParameters() {	if ((pairSeparator == null) || (keyValuePairSeparator == null)) {	for (Class<?> cl : models) {	Message message = cl.getAnnotation(Message.class);	Section section = cl.getAnnotation(Section.class);	if (message != null) {	ObjectHelper.notNull(message.pairSeparator(), "No Pair Separator has been defined in the @Message annotation");	pairSeparator = message.pairSeparator();	ObjectHelper.notNull(message.keyValuePairSeparator(), "No Key Value Pair Separator has been defined in the @Message annotation");	keyValuePairSeparator = message.keyValuePairSeparator();	
key value pair separator defined for the message 

if ((pairSeparator == null) || (keyValuePairSeparator == null)) {	for (Class<?> cl : models) {	Message message = cl.getAnnotation(Message.class);	Section section = cl.getAnnotation(Section.class);	if (message != null) {	ObjectHelper.notNull(message.pairSeparator(), "No Pair Separator has been defined in the @Message annotation");	pairSeparator = message.pairSeparator();	ObjectHelper.notNull(message.keyValuePairSeparator(), "No Key Value Pair Separator has been defined in the @Message annotation");	keyValuePairSeparator = message.keyValuePairSeparator();	crlf = message.crlf();	
carriage return defined for the message 

for (Class<?> cl : models) {	Message message = cl.getAnnotation(Message.class);	Section section = cl.getAnnotation(Section.class);	if (message != null) {	ObjectHelper.notNull(message.pairSeparator(), "No Pair Separator has been defined in the @Message annotation");	pairSeparator = message.pairSeparator();	ObjectHelper.notNull(message.keyValuePairSeparator(), "No Key Value Pair Separator has been defined in the @Message annotation");	keyValuePairSeparator = message.keyValuePairSeparator();	crlf = message.crlf();	messageOrdered = message.isOrdered();	
is the message ordered in output 

========================= camel sample_7461 =========================

consumerConfig.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);	}	if (producerConfig == null) {	producerConfig = new Properties();	StringHelper.notEmpty(bootstrapServers, "bootstrapServers");	producerConfig.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);	}	ObjectHelper.notNull(consumerConfig, "consumerConfig");	ObjectHelper.notNull(producerConfig, "producerConfig");	String groupId = UUID.randomUUID().toString();	
creating consumer with 

consumer = new KafkaConsumer<>(consumerConfig);	producerConfig.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());	producerConfig.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());	producerConfig.putIfAbsent(ProducerConfig.ACKS_CONFIG, "1");	producerConfig.putIfAbsent(ProducerConfig.BATCH_SIZE_CONFIG, "0");	producer = new KafkaProducer<>(producerConfig);	cacheReadyLatch = new CountDownLatch(1);	topicPoller = new TopicPoller(consumer, cacheReadyLatch, pollDurationMs);	executorService = camelContext.getExecutorServiceManager().newSingleThreadExecutor(this, "KafkaIdempotentRepository");	executorService.submit(topicPoller);	
warming up cache from topic 

producerConfig.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());	producerConfig.putIfAbsent(ProducerConfig.ACKS_CONFIG, "1");	producerConfig.putIfAbsent(ProducerConfig.BATCH_SIZE_CONFIG, "0");	producer = new KafkaProducer<>(producerConfig);	cacheReadyLatch = new CountDownLatch(1);	topicPoller = new TopicPoller(consumer, cacheReadyLatch, pollDurationMs);	executorService = camelContext.getExecutorServiceManager().newSingleThreadExecutor(this, "KafkaIdempotentRepository");	executorService.submit(topicPoller);	try {	if (cacheReadyLatch.await(30, TimeUnit.SECONDS)) {	
cache ok 

producerConfig.putIfAbsent(ProducerConfig.ACKS_CONFIG, "1");	producerConfig.putIfAbsent(ProducerConfig.BATCH_SIZE_CONFIG, "0");	producer = new KafkaProducer<>(producerConfig);	cacheReadyLatch = new CountDownLatch(1);	topicPoller = new TopicPoller(consumer, cacheReadyLatch, pollDurationMs);	executorService = camelContext.getExecutorServiceManager().newSingleThreadExecutor(this, "KafkaIdempotentRepository");	executorService.submit(topicPoller);	try {	if (cacheReadyLatch.await(30, TimeUnit.SECONDS)) {	} else {	
timeout waiting for cache warm up from topic proceeding anyway duplicate records may not be detected 

producer = new KafkaProducer<>(producerConfig);	cacheReadyLatch = new CountDownLatch(1);	topicPoller = new TopicPoller(consumer, cacheReadyLatch, pollDurationMs);	executorService = camelContext.getExecutorServiceManager().newSingleThreadExecutor(this, "KafkaIdempotentRepository");	executorService.submit(topicPoller);	try {	if (cacheReadyLatch.await(30, TimeUnit.SECONDS)) {	} else {	}	} catch (InterruptedException e) {	
interrupted while warming up cache this exception is ignored 

protected void doStop() {	topicPoller.setRunning(false);	try {	if (topicPoller.getShutdownLatch().await(30, TimeUnit.SECONDS)) {	
cache from topic shutdown successfully 

protected void doStop() {	topicPoller.setRunning(false);	try {	if (topicPoller.getShutdownLatch().await(30, TimeUnit.SECONDS)) {	} else {	
timeout waiting for cache to shutdown from topic proceeding anyway 

protected void doStop() {	topicPoller.setRunning(false);	try {	if (topicPoller.getShutdownLatch().await(30, TimeUnit.SECONDS)) {	} else {	}	} catch (InterruptedException e) {	
interrupted waiting on shutting down cache due this exception is ignored 

private void broadcastAction(String key, CacheAction action) {	try {	
broadcasting action for key 

public boolean contains(String key) {	
checking cache for key 

public void run() {	
subscribing consumer to 

public void run() {	consumer.subscribe(Collections.singleton(topic));	
seeking to beginning 

public void run() {	consumer.subscribe(Collections.singleton(topic));	consumer.seekToBeginning(consumer.assignment());	POLL_LOOP: while (running.get()) {	
Polling 

public void run() {	consumer.subscribe(Collections.singleton(topic));	consumer.seekToBeginning(consumer.assignment());	POLL_LOOP: while (running.get()) {	ConsumerRecords<String, String> consumerRecords = consumer.poll(pollDurationMs);	if (consumerRecords.isEmpty()) {	
messages fetched on poll 

public void run() {	consumer.subscribe(Collections.singleton(topic));	consumer.seekToBeginning(consumer.assignment());	POLL_LOOP: while (running.get()) {	ConsumerRecords<String, String> consumerRecords = consumer.poll(pollDurationMs);	if (consumerRecords.isEmpty()) {	if (cacheReadyLatch.getCount() > 0) {	
cache warmed up 

if (consumerRecords.isEmpty()) {	if (cacheReadyLatch.getCount() > 0) {	cacheReadyLatch.countDown();	}	}	for (ConsumerRecord<String, String> consumerRecord: consumerRecords) {	CacheAction action;	try {	action = CacheAction.valueOf(consumerRecord.value());	} catch (IllegalArgumentException iax) {	
unexpected action value received on topic partition offset shutting down 

for (ConsumerRecord<String, String> consumerRecord: consumerRecords) {	CacheAction action;	try {	action = CacheAction.valueOf(consumerRecord.value());	} catch (IllegalArgumentException iax) {	setRunning(false);	continue POLL_LOOP;	}	String messageId = consumerRecord.key();	if (action == CacheAction.add) {	
adding to cache messageid 

try {	action = CacheAction.valueOf(consumerRecord.value());	} catch (IllegalArgumentException iax) {	setRunning(false);	continue POLL_LOOP;	}	String messageId = consumerRecord.key();	if (action == CacheAction.add) {	cache.put(messageId, messageId);	} else if (action == CacheAction.remove) {	
removing from cache messageid 

continue POLL_LOOP;	}	String messageId = consumerRecord.key();	if (action == CacheAction.add) {	cache.put(messageId, messageId);	} else if (action == CacheAction.remove) {	cache.remove(messageId);	} else if (action == CacheAction.clear) {	cache.clear();	} else {	
no idea how to a record shutting down 

} else if (action == CacheAction.remove) {	cache.remove(messageId);	} else if (action == CacheAction.clear) {	cache.clear();	} else {	setRunning(false);	continue POLL_LOOP;	}	}	}	
topicpoller finished triggering shutdown latch 

========================= camel sample_16408 =========================

public void testRouteAddSecondRoute() throws Exception {	if (isPlatform("aix")) {	return;	}	MBeanServer mbeanServer = getMBeanServer();	ObjectName route1 = ObjectName.getInstance("org.apache.camel:context=camel-1,type=routes,name=\"foo\"");	String state = (String) mbeanServer.getAttribute(route1, "State");	assertEquals("Should be started", ServiceStatus.Started.name(), state);	
adding route 

}	MBeanServer mbeanServer = getMBeanServer();	ObjectName route1 = ObjectName.getInstance("org.apache.camel:context=camel-1,type=routes,name=\"foo\"");	String state = (String) mbeanServer.getAttribute(route1, "State");	assertEquals("Should be started", ServiceStatus.Started.name(), state);	context.addRoutes(new RouteBuilder() {	public void configure() throws Exception {	from("direct:bar").routeId("bar").to("mock:bar");	}	});	
adding route done 

========================= camel sample_2819 =========================

public void testQuartzPersistentStoreClusteredApp() throws Exception {	AbstractXmlApplicationContext db = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzConsumerClusteredAppDatabase.xml");	AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzConsumerRecoveryClusteredAppOne.xml");	
the first app is going to crash now 

public void testQuartzPersistentStoreClusteredApp() throws Exception {	AbstractXmlApplicationContext db = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzConsumerClusteredAppDatabase.xml");	AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzConsumerRecoveryClusteredAppOne.xml");	IOHelper.close(app);	
crashed 

public void testQuartzPersistentStoreClusteredApp() throws Exception {	AbstractXmlApplicationContext db = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzConsumerClusteredAppDatabase.xml");	AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzConsumerRecoveryClusteredAppOne.xml");	IOHelper.close(app);	
crashed 

public void testQuartzPersistentStoreClusteredApp() throws Exception {	AbstractXmlApplicationContext db = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzConsumerClusteredAppDatabase.xml");	AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz2/SpringQuartzConsumerRecoveryClusteredAppOne.xml");	IOHelper.close(app);	
crashed 

========================= camel sample_14966 =========================

public void assertIsSatisfied(long timeoutForEmptyEndpoints) throws InterruptedException {	
asserting is satisfied 

public void assertIsSatisfied(long timeoutForEmptyEndpoints) throws InterruptedException {	doAssertIsSatisfied(timeoutForEmptyEndpoints);	if (assertPeriod > 0) {	Thread.sleep(assertPeriod);	
re asserting is satisfied after millis 

protected void doAssertIsSatisfied(long timeoutForEmptyEndpoints) throws InterruptedException {	if (expectedCount == 0) {	if (timeoutForEmptyEndpoints > 0) {	
sleeping for millis to check there really are no messages received 

}	if (expectedMinimumCount >= 0) {	int receivedCounter = getReceivedCounter();	assertTrue("Received message count " + receivedCounter + ", expected at least " + expectedMinimumCount, expectedMinimumCount <= receivedCounter);	}	for (Runnable test : tests) {	test.run();	}	for (Throwable failure : failures) {	if (failure != null) {	
caught on exception 

public void assertIsNotSatisfied() throws InterruptedException {	boolean failed = false;	try {	assertIsSatisfied();	failed = true;	} catch (AssertionError e) {	
caught expected failure 

public void assertIsNotSatisfied(long timeoutForEmptyEndpoints) throws InterruptedException {	boolean failed = false;	try {	assertIsSatisfied(timeoutForEmptyEndpoints);	failed = true;	} catch (AssertionError e) {	
caught expected failure 

protected void waitForCompleteLatch() throws InterruptedException {	if (latch == null) {	fail("Should have a latch!");	}	StopWatch watch = new StopWatch();	waitForCompleteLatch(resultWaitTime);	long delta = watch.taken();	
took millis to complete latch 

protected void waitForCompleteLatch(long timeout) throws InterruptedException {	long waitTime = timeout == 0 ? 10000L : timeout;	
waiting on the latch for millis 

protected void fail(Object message) {	if (LOG.isDebugEnabled()) {	List<Exchange> list = getReceivedExchanges();	int index = 0;	for (Exchange exchange : list) {	
failed and received 

========================= camel sample_4867 =========================

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyMethodCallRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	
consumer 

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyMethodCallRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	}	Assert.assertEquals("timer:foo", list.get(0).getElement());	list = CamelJavaParserHelper.parseCamelProducerUris(method, true, true);	for (ParserResult result : list) {	
producer 

========================= camel sample_201 =========================

protected QuartzEndpoint createEndpoint(final String uri, final String remaining, final Map<String, Object> parameters) throws Exception {	URI u = new URI(uri);	String path = ObjectHelper.after(u.getPath(), "/");	String host = u.getHost();	String cron = getAndRemoveParameter(parameters, "cron", String.class);	boolean fireNow = getAndRemoveParameter(parameters, "fireNow", Boolean.class, Boolean.FALSE);	Integer startDelayedSeconds = getAndRemoveParameter(parameters, "startDelayedSeconds", Integer.class);	if (startDelayedSeconds != null) {	if (scheduler.isStarted()) {	
a quartz job is already started cannot apply the startdelayedseconds configuration 

protected QuartzEndpoint createEndpoint(final String uri, final String remaining, final Map<String, Object> parameters) throws Exception {	URI u = new URI(uri);	String path = ObjectHelper.after(u.getPath(), "/");	String host = u.getHost();	String cron = getAndRemoveParameter(parameters, "cron", String.class);	boolean fireNow = getAndRemoveParameter(parameters, "fireNow", Boolean.class, Boolean.FALSE);	Integer startDelayedSeconds = getAndRemoveParameter(parameters, "startDelayedSeconds", Integer.class);	if (startDelayedSeconds != null) {	if (scheduler.isStarted()) {	} else if (this.startDelayedSeconds != 0 && !(this.startDelayedSeconds == startDelayedSeconds)) {	
a quartz job is already configured with a different startdelayedseconds configuration all quartz jobs must share the same startdelayedseconds configuration cannot apply the startdelayedseconds configuration 

public void onCamelContextStarted(CamelContext camelContext, boolean alreadyStarted) throws Exception {	if (scheduler != null) {	String uid = QuartzHelper.getQuartzContextName(camelContext);	scheduler.getContext().put(QuartzConstants.QUARTZ_CAMEL_CONTEXT + "-" + uid, camelContext);	}	if (!isAutoStartScheduler()) {	
quartzcomponent configured to not auto start quartz scheduler 

protected void doStop() throws Exception {	super.doStop();	if (scheduler != null) {	AtomicInteger number = (AtomicInteger) scheduler.getContext().get("CamelJobs");	if (number != null && number.get() > 0) {	
cannot shutdown quartz scheduler as there are still jobs registered 

protected void doStop() throws Exception {	super.doStop();	if (scheduler != null) {	AtomicInteger number = (AtomicInteger) scheduler.getContext().get("CamelJobs");	if (number != null && number.get() > 0) {	} else {	
there are no more jobs registered so shutting down quartz scheduler 

private void doAddJob(JobDetail job, Trigger trigger) throws SchedulerException {	Trigger existingTrigger = getScheduler().getTrigger(trigger.getName(), trigger.getGroup());	if (existingTrigger == null) {	
adding job using trigger 

private void doAddJob(JobDetail job, Trigger trigger) throws SchedulerException {	Trigger existingTrigger = getScheduler().getTrigger(trigger.getName(), trigger.getGroup());	if (existingTrigger == null) {	getScheduler().scheduleJob(job, trigger);	} else if (hasTriggerChanged(existingTrigger, trigger)) {	
trigger already exists and will be updated by quartz 

getScheduler().scheduleJob(job, trigger);	} else if (hasTriggerChanged(existingTrigger, trigger)) {	trigger.setStartTime(new Date());	scheduler.unscheduleJob(trigger.getName(), trigger.getGroup());	scheduler.addJob(job, true);	trigger.setJobName(job.getName());	trigger.setJobGroup(job.getGroup());	scheduler.scheduleJob(trigger);	} else {	if (!isClustered()) {	
trigger already exists and will be resumed by quartz 

scheduler.scheduleJob(trigger);	} else {	if (!isClustered()) {	trigger.setStartTime(new Date());	scheduler.unscheduleJob(trigger.getName(), trigger.getGroup());	scheduler.addJob(job, true);	trigger.setJobName(job.getName());	trigger.setJobGroup(job.getGroup());	scheduler.scheduleJob(trigger);	} else {	
trigger already exists and is already scheduled by clustered jobstore 

public void pauseJob(Trigger trigger) throws SchedulerException {	if (isClustered()) {	
cannot pause job using trigger as the jobstore is clustered 

public void pauseJob(Trigger trigger) throws SchedulerException {	if (isClustered()) {	} else {	
pausing job using trigger 

public void deleteJob(String name, String group) throws SchedulerException {	if (isClustered()) {	
cannot delete job using trigger as the jobstore is clustered 

public void deleteJob(String name, String group) throws SchedulerException {	if (isClustered()) {	} else {	Trigger trigger = getScheduler().getTrigger(name, group);	if (trigger != null) {	
deleting job using trigger 

public void shutdownScheduler() throws SchedulerException {	if (scheduler != null) {	
forcing shutdown of quartz scheduler 

public boolean isClustered() throws SchedulerException {	try {	return getScheduler().getMetaData().isJobStoreClustered();	} catch (NoSuchMethodError e) {	
job clustering is only supported since quartz isclustered returning false 

public void startScheduler() throws SchedulerException {	for (JobToAdd add : jobsToAdd) {	doAddJob(add.getJob(), add.getTrigger());	}	jobsToAdd.clear();	if (!getScheduler().isStarted()) {	if (getStartDelayedSeconds() > 0) {	
starting quartz scheduler delayed seconds 

public void startScheduler() throws SchedulerException {	for (JobToAdd add : jobsToAdd) {	doAddJob(add.getJob(), add.getTrigger());	}	jobsToAdd.clear();	if (!getScheduler().isStarted()) {	if (getStartDelayedSeconds() > 0) {	try {	getScheduler().startDelayed(getStartDelayedSeconds());	} catch (NoSuchMethodError e) {	
your version of quartz is too old to support delayed startup starting quartz scheduler immediately 

}	jobsToAdd.clear();	if (!getScheduler().isStarted()) {	if (getStartDelayedSeconds() > 0) {	try {	getScheduler().startDelayed(getStartDelayedSeconds());	} catch (NoSuchMethodError e) {	getScheduler().start();	}	} else {	
starting quartz scheduler 

protected Properties loadProperties() throws SchedulerException {	Properties answer = getProperties();	if (answer == null && getPropertiesFile() != null) {	
loading quartz properties file from 

prop.setProperty(StdSchedulerFactory.PROP_SCHED_INSTANCE_NAME, instName);	prop.put("org.quartz.scheduler.skipUpdateCheck", "true");	if (enableJmx && !prop.containsKey("org.quartz.scheduler.jmx.export")) {	prop.put("org.quartz.scheduler.jmx.export", "true");	LOG.info("Setting org.quartz.scheduler.jmx.export=true to ensure QuartzScheduler(s) will be enlisted in JMX.");	}	answer = new StdSchedulerFactory(prop);	}	if (LOG.isDebugEnabled()) {	String name = prop.getProperty(StdSchedulerFactory.PROP_SCHED_INSTANCE_NAME);	
creating schedulerfactory with properties 

protected Scheduler createScheduler() throws SchedulerException {	Scheduler scheduler = getFactory().getScheduler();	if (LOG.isDebugEnabled()) {	
using schedulerfactory to get create scheduler 

========================= camel sample_17219 =========================

public synchronized CacheManager getInstance() {	if (cacheManager == null) {	cacheManager = createCacheManagerInstance();	
turning off ehcache update checker 

public synchronized CacheManager getInstance() {	if (cacheManager == null) {	cacheManager = createCacheManagerInstance();	Configuration config = cacheManager.getConfiguration();	try {	System.setProperty("net.sf.ehcache.skipUpdateCheck", "true");	ReflectionHelper.setField(config.getClass().getDeclaredField("updateCheck"), config, false);	LOG.info("Turned off EHCache update checker. updateCheck={}", config.getUpdateCheck());	} catch (Throwable e) {	
error turning off ehcache update checker beware information sent over the internet 

protected synchronized void doStop() throws Exception {	if (cacheManager != null) {	int size = cacheManager.getCacheNames().length;	if (size <= 0) {	
shutting down cachemanager as its no longer in use 

protected synchronized void doStop() throws Exception {	if (cacheManager != null) {	int size = cacheManager.getCacheNames().length;	if (size <= 0) {	cacheManager.shutdown();	cacheManager = null;	} else {	
cannot stop cachemanager as its still in use by clients 

========================= camel sample_10533 =========================

public void activate() {	if (LOG.isDebugEnabled()) {	
activating cxfbeandestination 

public void activate() {	if (LOG.isDebugEnabled()) {	}	endpoint = cxfBeanComponent.getEndpoint(getCamelDestinationUri());	if (endpoint == null) {	
failed to find endpoint 

public void process(Exchange camelExchange) throws Exception {	
received request 

========================= camel sample_8002 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ServiceNowComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.servicenow.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.servicenow.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_714 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<JoltComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jolt.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jolt.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1223 =========================

protected int poll() throws Exception {	shutdownRunningTask = null;	pendingExchanges = 0;	try {	Messages messages = null;	
receiving messages with request messageperpoll timeout 

protected int poll() throws Exception {	shutdownRunningTask = null;	pendingExchanges = 0;	try {	Messages messages = null;	messages = this.ironQueue.reserve(getMaxMessagesPerPoll(), getEndpoint().getConfiguration().getTimeout(), getEndpoint().getConfiguration().getWait());	
received messages 

protected int poll() throws Exception {	shutdownRunningTask = null;	pendingExchanges = 0;	try {	Messages messages = null;	messages = this.ironQueue.reserve(getMaxMessagesPerPoll(), getEndpoint().getConfiguration().getTimeout(), getEndpoint().getConfiguration().getWait());	Queue<Exchange> exchanges = createExchanges(messages.getMessages());	int noProcessed = processBatch(CastUtils.cast(exchanges));	if (getEndpoint().getConfiguration().isBatchDelete()) {	
batch deleting messages 

protected Queue<Exchange> createExchanges(Message[] messages) {	
received messages in this poll 

processCommit(exchange, messageid, reservationId);	}	public void onFailure(Exchange exchange) {	processRollback(exchange);	}	public String toString() {	return "IronMQConsumerOnCompletion";	}	});	}	
processing exchange 

protected void processCommit(Exchange exchange, String messageid, String reservationId) {	try {	
deleting message with messageid and reservationid 

protected void processCommit(Exchange exchange, String messageid, String reservationId) {	try {	this.ironQueue.deleteMessage(messageid, reservationId);	
message deleted 

protected void processRollback(Exchange exchange) {	Exception cause = exchange.getException();	if (cause != null) {	
exchange failed so rolling back message status 

protected void processRollback(Exchange exchange) {	Exception cause = exchange.getException();	if (cause != null) {	} else {	
exchange failed so rolling back message status 

========================= camel sample_14570 =========================

public Producer createProducer() throws Exception {	IgniteAtomicSequence atomicSeq = ignite().atomicSequence(name, initialValue, false);	if (atomicSeq == null) {	atomicSeq = ignite().atomicSequence(name, initialValue, true);	
created atomicsequence of id generator with name 

========================= camel sample_11288 =========================

public static void startThriftServer() throws Exception {	processor = new Calculator.Processor(new CalculatorSyncServerImpl());	serverTransport = new TServerSocket(new InetSocketAddress(InetAddress.getByName("localhost"), THRIFT_TEST_PORT), THRIFT_CLIENT_TIMEOUT);	TThreadPoolServer.Args args = new TThreadPoolServer.Args(serverTransport);	args.processor((TProcessor)processor);	args.protocolFactory(new TBinaryProtocol.Factory());	args.transportFactory((TTransportFactory)new TZlibTransport.Factory());	server = new TThreadPoolServer(args);	Runnable simple = new Runnable() {	public void run() {	
thrift server with zlib compression started on port 

public static void stopThriftServer() throws IOException {	if (server != null) {	server.stop();	serverTransport.close();	
thrift server with zlib compression stoped 

public void testCalculateMethodInvocation() throws Exception {	
thrift calculate method sync test start 

public void testVoidMethodInvocation() throws Exception {	
thrift method with empty parameters and void output sync test start 

========================= camel sample_13020 =========================

public BoxUser getCurrentUser() {	try {	
getting current user 

========================= camel sample_17433 =========================

public void testWithEnableTLS() throws Exception {	
grpc pingasyncsync method aync test with tls enable start 

public void testWithCorrectJWT() throws Exception {	
grpc pingasyncsync method aync test with correct jwt start 

public void testWithIncorrectJWT() throws Exception {	
grpc pingasyncsync method aync test with correct jwt start 

public void onError(Throwable t) {	
Exception 

========================= camel sample_7498 =========================

public void onMessage(Message message, Session session) throws JMSException {	
onmessage start 

public void onMessage(Message message, Session session) throws JMSException {	
consumer received jms message 

public void onMessage(Message message, Session session) throws JMSException {	boolean sendReply;	RuntimeCamelException rce;	try {	Object replyDestination = getReplyToDestination(message);	sendReply = replyDestination != null && !disableReplyTo;	Destination destination = JmsMessageHelper.getJMSDestination(message);	if (destination != null && sendReply && !endpoint.isReplyToSameDestinationAllowed() && destination.equals(replyDestination)) {	
jmsdestination and jmsreplyto is the same will skip sending a reply message to itself 

Destination destination = JmsMessageHelper.getJMSDestination(message);	if (destination != null && sendReply && !endpoint.isReplyToSameDestinationAllowed() && destination.equals(replyDestination)) {	sendReply = false;	}	final Exchange exchange = createExchange(message, session, replyDestination);	if (eagerLoadingOfProperties) {	exchange.getIn().getHeaders();	}	String correlationId = message.getJMSCorrelationID();	if (correlationId != null) {	
received message has jmscorrelationid 

if (destination != null && sendReply && !endpoint.isReplyToSameDestinationAllowed() && destination.equals(replyDestination)) {	sendReply = false;	}	final Exchange exchange = createExchange(message, session, replyDestination);	if (eagerLoadingOfProperties) {	exchange.getIn().getHeaders();	}	String correlationId = message.getJMSCorrelationID();	if (correlationId != null) {	}	
onmessage process start 

if (eagerLoadingOfProperties) {	exchange.getIn().getHeaders();	}	String correlationId = message.getJMSCorrelationID();	if (correlationId != null) {	}	AsyncCallback callback = new EndpointMessageListenerAsyncCallback(message, exchange, endpoint, sendReply, replyDestination);	boolean forceSync = endpoint.isSynchronous() || endpoint.isTransacted();	if (forceSync || !isAsync()) {	if (LOG.isTraceEnabled()) {	
processing exchange synchronously 

}	try {	processor.process(exchange);	} catch (Exception e) {	exchange.setException(e);	} finally {	callback.done(true);	}	} else {	if (LOG.isTraceEnabled()) {	
processing exchange asynchronously 

boolean sync = processor.process(exchange, callback);	if (!sync) {	return;	}	}	rce = exchange.getException(RuntimeCamelException.class);	} catch (Exception e) {	rce = wrapRuntimeCamelException(e);	}	if (rce != null) {	
onmessage end throwing exception 

return;	}	}	rce = exchange.getException(RuntimeCamelException.class);	} catch (Exception e) {	rce = wrapRuntimeCamelException(e);	}	if (rce != null) {	throw rce;	}	
onmessage end 

public void done(boolean doneSync) {	
onmessage process end 

if (sendReply && exchange.getPattern().isOutCapable()) {	if (exchange.hasOut()) {	body = exchange.getOut();	} else {	body = exchange.getIn();	}	cause = null;	}	}	if (rce == null && sendReply && (body != null || cause != null)) {	
onmessage sendreply start 

}	cause = null;	}	}	if (rce == null && sendReply && (body != null || cause != null)) {	if (replyDestination instanceof Destination) {	sendReply((Destination)replyDestination, message, exchange, body, cause);	} else {	sendReply((String)replyDestination, message, exchange, body, cause);	}	
onmessage sendreply end 

protected void sendReply(Destination replyDestination, final Message message, final Exchange exchange, final org.apache.camel.Message out, final Exception cause) {	if (replyDestination == null) {	
cannot send reply message as there is no replydestination for 

protected void sendReply(Destination replyDestination, final Message message, final Exchange exchange, final org.apache.camel.Message out, final Exception cause) {	if (replyDestination == null) {	return;	}	getTemplate().send(replyDestination, new MessageCreator() {	public Message createMessage(Session session) throws JMSException {	Message reply = endpoint.getBinding().makeJmsMessage(exchange, out, session, cause);	final String correlationID = determineCorrelationId(message);	reply.setJMSCorrelationID(correlationID);	if (LOG.isDebugEnabled()) {	
sending reply jms message correlationid 

protected void sendReply(String replyDestination, final Message message, final Exchange exchange, final org.apache.camel.Message out, final Exception cause) {	if (replyDestination == null) {	
cannot send reply message as there is no replydestination for 

protected void sendReply(String replyDestination, final Message message, final Exchange exchange, final org.apache.camel.Message out, final Exception cause) {	if (replyDestination == null) {	return;	}	getTemplate().send(replyDestination, new MessageCreator() {	public Message createMessage(Session session) throws JMSException {	Message reply = endpoint.getBinding().makeJmsMessage(exchange, out, session, cause);	final String correlationID = determineCorrelationId(message);	reply.setJMSCorrelationID(correlationID);	if (LOG.isDebugEnabled()) {	
sending reply jms message correlationid 

========================= camel sample_7162 =========================

private void stopConsumer(Route route) {	synchronized (lock) {	try {	if (!suspendedRoutes.contains(route)) {	
stopping consumer for 

private void startAllStoppedConsumers() {	synchronized (lock) {	try {	for (Route route : suspendedRoutes) {	
starting consumer for 

} else {	try {	EtcdKeysResponse response = promise.get();	EtcdHelper.setIndex(index, response);	if (response.node.value == null) {	setLeader(tryTakeLeadership());	} else if (!ObjectHelper.equal(serviceName, response.node.value) && leader.get()) {	setLeader(false);	}	} catch (TimeoutException e) {	
timeout watching for 

========================= camel sample_12261 =========================

protected void doStart() throws Exception {	if (!localMember.hasJoined()) {	
get group 

protected void doStart() throws Exception {	if (!localMember.hasJoined()) {	group = this.atomix.getGroup( getNamespace(), new DistributedGroup.Config(configuration.getResourceConfig(getNamespace())), new DistributedGroup.Options(configuration.getResourceOptions(getNamespace())) ).get();	
listen election events 

protected void doStart() throws Exception {	if (!localMember.hasJoined()) {	group = this.atomix.getGroup( getNamespace(), new DistributedGroup.Config(configuration.getResourceConfig(getNamespace())), new DistributedGroup.Options(configuration.getResourceOptions(getNamespace())) ).get();	group.election().onElection(term -> {	if (isRunAllowed()) {	fireLeadershipChangedEvent(Optional.of(toClusterMember(term.leader())));	}	});	
listen join events 

group.election().onElection(term -> {	if (isRunAllowed()) {	fireLeadershipChangedEvent(Optional.of(toClusterMember(term.leader())));	}	});	group.onJoin(member -> {	if (isRunAllowed()) {	fireMemberAddedEvent(toClusterMember(member));	}	});	
listen leave events 

group.onJoin(member -> {	if (isRunAllowed()) {	fireMemberAddedEvent(toClusterMember(member));	}	});	group.onLeave(member -> {	if (isRunAllowed()) {	fireMemberRemovedEvent(toClusterMember(member));	}	});	
join group 

========================= camel sample_10319 =========================

public void testSynchronous() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(100);	mock.expectsNoDuplicates(body());	StopWatch watch = new StopWatch();	for (int i = 0; i < 100; i++) {	template.sendBody("seda:start", "" + i);	}	assertMockEndpointsSatisfied(20, TimeUnit.SECONDS);	
took ms to process messages request reply over jms 

========================= camel sample_12324 =========================

protected boolean useJmx() {	boolean enable = "testStreamResequencerTypeWithJmx".equals(getName());	
going to jmx for the test enable disable 

========================= camel sample_2225 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<CryptoCmsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.crypto-cms.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.crypto-cms.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_997 =========================

}	} else {	StringBuilder pathsExtracted = new StringBuilder();	for (Map.Entry<String, Object> entry : map.entrySet()) {	pathsExtracted.append(entry.getKey()).append("\n");	}	exchange.getIn().setHeader(DropboxResultHeader.DOWNLOADED_FILES.name(), pathsExtracted.toString());	exchange.getIn().setBody(map);	}	if (LOG.isDebugEnabled()) {	
downloaded 

========================= camel sample_8501 =========================

public Exchange call() throws Exception {	if (client == null) {	throw new RuntimeCamelException("Beanstalk client not initialized");	}	try {	final Job job = client.reserve(noWait);	if (job == null) {	return null;	}	if (LOG.isDebugEnabled()) {	
received job id d data length d 

public void onComplete(final Exchange exchange) {	try {	executor.submit(new RunCommand(successCommand, exchange)).get();	} catch (Exception e) {	
could not run completion of exchange s 

public void onFailure(final Exchange exchange) {	try {	executor.submit(new RunCommand(failureCommand, exchange)).get();	} catch (Exception e) {	
s could not run failure of exchange s 

public void run() {	try {	try {	command.act(client, exchange);	} catch (BeanstalkException e) {	
post processing s of exchange s failed retrying 

public void run() {	try {	try {	command.act(client, exchange);	} catch (BeanstalkException e) {	resetClient();	command.act(client, exchange);	}	} catch (final Exception e) {	
s could not post process exchange s 

========================= camel sample_8151 =========================

public void begin() {	
recipientprocessorexchangepair begin 

public void begin() {	exchange.setProperty(Exchange.RECIPIENT_LIST_ENDPOINT, endpoint.getEndpointUri());	MessageHelper.resetStreamCache(exchange.getIn());	if (pattern != null) {	originalPattern = exchange.getPattern();	
using exchangepattern on exchange 

public void done() {	
recipientprocessorexchangepair done 

public void done() {	try {	if (originalPattern != null) {	exchange.setPattern(originalPattern);	}	producerCache.releaseProducer(endpoint, producer);	} catch (Exception e) {	if (LOG.isDebugEnabled()) {	
error releasing producer this exception will be ignored 

Endpoint endpoint;	Producer producer;	ExchangePattern pattern;	try {	endpoint = resolveEndpoint(exchange, recipient);	pattern = resolveExchangePattern(recipient);	producer = producerCache.acquireProducer(endpoint);	} catch (Exception e) {	if (isIgnoreInvalidEndpoints()) {	if (LOG.isDebugEnabled()) {	
endpoint uri is invalid this exception will be ignored 

========================= camel sample_4522 =========================

protected void throttle(Route route, Exchange exchange) {	Consumer consumer = route.getConsumer();	int size = getSize(route, exchange);	boolean stop = maxInflightExchanges > 0 && size > maxInflightExchanges;	if (log.isTraceEnabled()) {	
evaluated as 

========================= camel sample_4172 =========================

public void testRedeliveryErrorHandlerOnExceptionAllOptions() throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() throws Exception {	
mock handled 

========================= camel sample_1665 =========================

public void testPutAndGetNotFound() {	Exchange exchange = new DefaultExchange(context);	exchange.getIn().setBody("Hello World");	
created 

public void testPutAndGetNotFound() {	Exchange exchange = new DefaultExchange(context);	exchange.getIn().setBody("Hello World");	repo.add(context, exchange.getExchangeId(), exchange);	Exchange out = repo.get(context, exchange.getExchangeId());	assertNotNull("Should find exchange", out);	Exchange exchange2 = new DefaultExchange(context);	exchange2.getIn().setBody("Bye World");	
created 

========================= camel sample_8917 =========================

public static Map<String, Object> getExchangeProperties(Exchange exchange, Map<String, Object> properties) {	int nProperties = 0;	for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {	if (entry.getKey().startsWith(FacebookConstants.FACEBOOK_PROPERTY_PREFIX)) {	properties.put(entry.getKey().substring(FacebookConstants.FACEBOOK_PROPERTY_PREFIX.length()), entry.getValue());	nProperties++;	}	}	
found properties in exchange 

public static void getEndpointProperties(FacebookEndpointConfiguration configuration, Map<String, Object> properties) {	if (IntrospectionSupport.getProperties(configuration, properties, null, false)) {	final Set<String> names = properties.keySet();	names.removeAll(COMPONENT_CONFIG_FIELDS);	}	if (LOG.isDebugEnabled()) {	final Set<String> names = properties.keySet();	
found endpoint properties 

========================= camel sample_9605 =========================

assertEquals("CamelHystrix", groupKey);	Thread.sleep(1000);	Long totalRequests = (Long) mbeanServer.getAttribute(on, "HystrixTotalRequests");	assertEquals(1, totalRequests.longValue());	Long errorCount = (Long) mbeanServer.getAttribute(on, "HystrixErrorCount");	assertEquals(0, errorCount.longValue());	Boolean open = (Boolean) mbeanServer.getAttribute(on, "CircuitBreakerOpen");	assertEquals(false, open.booleanValue());	Thread.sleep(1000);	String latest = stream.oldestMetricsAsJSon();	
oldest json stream 

Long totalRequests = (Long) mbeanServer.getAttribute(on, "HystrixTotalRequests");	assertEquals(1, totalRequests.longValue());	Long errorCount = (Long) mbeanServer.getAttribute(on, "HystrixErrorCount");	assertEquals(0, errorCount.longValue());	Boolean open = (Boolean) mbeanServer.getAttribute(on, "CircuitBreakerOpen");	assertEquals(false, open.booleanValue());	Thread.sleep(1000);	String latest = stream.oldestMetricsAsJSon();	Stream<String> jsons = stream.streamMetrics();	jsons.forEach(s -> {	
json 

========================= camel sample_11334 =========================

System.arraycopy(intAsByteArray, 0, result, index, 4);	index += 4;	System.arraycopy(sshDss, 0, result, index, sshDss.length);	index += sshDss.length;	intAsByteArray = ByteBuffer.allocate(4).putInt(signature.length).array();	System.arraycopy(intAsByteArray, 0, result, index, 4);	index += 4;	System.arraycopy(signature, 0, result, index, signature.length);	return result;	} catch (NoSuchAlgorithmException e) {	
cannot sign 

index += 4;	System.arraycopy(sshDss, 0, result, index, sshDss.length);	index += sshDss.length;	intAsByteArray = ByteBuffer.allocate(4).putInt(signature.length).array();	System.arraycopy(intAsByteArray, 0, result, index, 4);	index += 4;	System.arraycopy(signature, 0, result, index, signature.length);	return result;	} catch (NoSuchAlgorithmException e) {	} catch (InvalidKeyException e) {	
cannot sign 

System.arraycopy(sshDss, 0, result, index, sshDss.length);	index += sshDss.length;	intAsByteArray = ByteBuffer.allocate(4).putInt(signature.length).array();	System.arraycopy(intAsByteArray, 0, result, index, 4);	index += 4;	System.arraycopy(signature, 0, result, index, signature.length);	return result;	} catch (NoSuchAlgorithmException e) {	} catch (InvalidKeyException e) {	} catch (SignatureException e) {	
cannot sign 

========================= camel sample_15377 =========================

public void testIrcMessages() throws Exception {	resultEndpoint = context.getEndpoint("mock:result", MockEndpoint.class);	resultEndpoint.expectedBodiesReceived(resultEnd);	resultEndpoint.assertIsSatisfied();	List<Exchange> list = resultEndpoint.getReceivedExchanges();	for (Exchange exchange : list) {	
received exchange headers 

========================= camel sample_12148 =========================

Method method = factoryClass.getMethod("getConfiguration");	if (method != null) {	Object configuration = method.invoke(factory, null);	if (configuration != null) {	Class<?> extensionClass = camelContext.getClassResolver().resolveMandatoryClass( SAXON_EXTENDED_FUNCTION_DEFINITION_CLASS_NAME, XsltComponent.class.getClassLoader() );	method = configuration.getClass().getMethod("registerExtensionFunction", extensionClass);	if (method != null) {	factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);	for (Object extensionFunction : saxonExtensionFunctions) {	if (extensionClass.isInstance(extensionFunction)) {	
saxon registerextensionfunction 

Class<?> extensionClass = camelContext.getClassResolver().resolveMandatoryClass( SAXON_EXTENDED_FUNCTION_DEFINITION_CLASS_NAME, XsltComponent.class.getClassLoader() );	method = configuration.getClass().getMethod("registerExtensionFunction", extensionClass);	if (method != null) {	factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);	for (Object extensionFunction : saxonExtensionFunctions) {	if (extensionClass.isInstance(extensionFunction)) {	method.invoke(configuration, extensionFunction);	}	}	} else {	
unable to get reference to method registerextensionfunction on 

if (method != null) {	factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);	for (Object extensionFunction : saxonExtensionFunctions) {	if (extensionClass.isInstance(extensionFunction)) {	method.invoke(configuration, extensionFunction);	}	}	} else {	}	} else {	
unable to get saxon configuration on 

for (Object extensionFunction : saxonExtensionFunctions) {	if (extensionClass.isInstance(extensionFunction)) {	method.invoke(configuration, extensionFunction);	}	}	} else {	}	} else {	}	} else {	
unable to get reference to method getconfiguration on 

========================= camel sample_4934 =========================

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyCdiRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	
consumer 

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyCdiRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	}	Assert.assertEquals("timer:foo?period=4999", list.get(0).getElement());	list = CamelJavaParserHelper.parseCamelProducerUris(method, true, true);	for (ParserResult result : list) {	
producer 

========================= camel sample_186 =========================

Endpoint endpoint = context.getEndpoint("direct:input");	ITestPojo proxy = ProxyHelper.createProxy(endpoint, ITestPojo.class);	Request req = new Request();	long start = System.currentTimeMillis();	for (int i = 0; i < 100; ++i) {	req.setPayload("REQUEST " + i);	Reply reply = proxy.method(req);	assertTrue(reply.getPayload().equals("REPLY for REQUEST " + i));	}	long stop = System.currentTimeMillis();	
took milliseconds 

ITestPojo proxy = ProxyHelper.createProxy(endpoint, ITestPojo.class);	FutureTask<Reply> task = new FutureTask<Reply>(new PojoCallable(req, proxy));	tasks.add(task);	es.submit(task);	}	int i = 0;	for (FutureTask<Reply> futureTask : tasks) {	assertTrue(futureTask.get().getPayload().equals("REPLY for REQUEST " + i++));	}	long stop = System.currentTimeMillis();	
took milliseconds 

========================= camel sample_15009 =========================

public void testSplitParallelBigFile() throws Exception {	StopWatch watch = new StopWatch();	NotifyBuilder builder = new NotifyBuilder(context).whenDone(lines + 1).create();	boolean done = builder.matches(120, TimeUnit.SECONDS);	
took 

========================= camel sample_2337 =========================

}	String cannedAcl = exchange.getIn().getHeader(S3Constants.CANNED_ACL, String.class);	if (cannedAcl != null) {	CannedAccessControlList objectAcl = CannedAccessControlList.valueOf(cannedAcl);	initRequest.setCannedACL(objectAcl);	}	AccessControlList acl = exchange.getIn().getHeader(S3Constants.ACL, AccessControlList.class);	if (acl != null) {	initRequest.setAccessControlList(acl);	}	
initiating multipart upload from exchange 

final InitiateMultipartUploadResult initResponse = getEndpoint().getS3Client().initiateMultipartUpload(initRequest);	final long contentLength = objectMetadata.getContentLength();	final List<PartETag> partETags = new ArrayList<PartETag>();	long partSize = getConfiguration().getPartSize();	CompleteMultipartUploadResult uploadResult = null;	long filePosition = 0;	try {	for (int part = 1; filePosition < contentLength; part++) {	partSize = Math.min(partSize, contentLength - filePosition);	UploadPartRequest uploadRequest = new UploadPartRequest().withBucketName(getConfiguration().getBucketName()).withKey(keyName) .withUploadId(initResponse.getUploadId()).withPartNumber(part).withFileOffset(filePosition).withFile(filePayload).withPartSize(partSize);	
uploading part for 

}	String cannedAcl = exchange.getIn().getHeader(S3Constants.CANNED_ACL, String.class);	if (cannedAcl != null) {	CannedAccessControlList objectAcl = CannedAccessControlList.valueOf(cannedAcl);	putObjectRequest.setCannedAcl(objectAcl);	}	AccessControlList acl = exchange.getIn().getHeader(S3Constants.ACL, AccessControlList.class);	if (acl != null) {	putObjectRequest.setAccessControlList(acl);	}	
put object from exchange 

String cannedAcl = exchange.getIn().getHeader(S3Constants.CANNED_ACL, String.class);	if (cannedAcl != null) {	CannedAccessControlList objectAcl = CannedAccessControlList.valueOf(cannedAcl);	putObjectRequest.setCannedAcl(objectAcl);	}	AccessControlList acl = exchange.getIn().getHeader(S3Constants.ACL, AccessControlList.class);	if (acl != null) {	putObjectRequest.setAccessControlList(acl);	}	PutObjectResult putObjectResult = getEndpoint().getS3Client().putObject(putObjectRequest);	
received result 

========================= camel sample_8690 =========================

protected static void setupClient() throws Exception {	olingoApp = new Olingo4AppImpl(getRealServiceUrl(TEST_SERVICE_BASE_URL));	olingoApp.setContentType(TEST_FORMAT_STRING);	
read edm 

protected static void setupClient() throws Exception {	olingoApp = new Olingo4AppImpl(getRealServiceUrl(TEST_SERVICE_BASE_URL));	olingoApp.setContentType(TEST_FORMAT_STRING);	final TestOlingo4ResponseHandler<Edm> responseHandler = new TestOlingo4ResponseHandler<Edm>();	olingoApp.read(null, Constants.METADATA, null, null, responseHandler);	edm = responseHandler.await();	
read default entitycontainer 

public void testServiceDocument() throws Exception {	final TestOlingo4ResponseHandler<ClientServiceDocument> responseHandler = new TestOlingo4ResponseHandler<ClientServiceDocument>();	olingoApp.read(null, "", null, null, responseHandler);	final ClientServiceDocument serviceDocument = responseHandler.await();	final Map<String, URI> entitySets = serviceDocument.getEntitySets();	assertEquals("Service Entity Sets", 4, entitySets.size());	
service document entries 

public void testReadEntitySet() throws Exception {	final TestOlingo4ResponseHandler<ClientEntitySet> responseHandler = new TestOlingo4ResponseHandler<ClientEntitySet>();	olingoApp.read(edm, PEOPLE, null, null, responseHandler);	final ClientEntitySet entitySet = responseHandler.await();	assertNotNull(entitySet);	assertEquals("Entity set count", 20, entitySet.getEntities().size());	
entities 

public void testReadUnparsedEntitySet() throws Exception {	final TestOlingo4ResponseHandler<InputStream> responseHandler = new TestOlingo4ResponseHandler<InputStream>();	olingoApp.uread(edm, PEOPLE, null, null, responseHandler);	final InputStream rawEntitySet = responseHandler.await();	assertNotNull("Data entity set", rawEntitySet);	final ClientEntitySet entitySet = reader.readEntitySet(rawEntitySet, TEST_FORMAT);	assertEquals("Entity set count", 20, entitySet.getEntities().size());	
entries 

public void testReadEntity() throws Exception {	final TestOlingo4ResponseHandler<ClientEntity> responseHandler = new TestOlingo4ResponseHandler<ClientEntity>();	olingoApp.read(edm, TEST_AIRLINE, null, null, responseHandler);	ClientEntity entity = responseHandler.await();	assertEquals("Shanghai Airline", entity.getProperty("Name").getValue().toString());	
single entity 

public void testReadEntity() throws Exception {	final TestOlingo4ResponseHandler<ClientEntity> responseHandler = new TestOlingo4ResponseHandler<ClientEntity>();	olingoApp.read(edm, TEST_AIRLINE, null, null, responseHandler);	ClientEntity entity = responseHandler.await();	assertEquals("Shanghai Airline", entity.getProperty("Name").getValue().toString());	responseHandler.reset();	olingoApp.read(edm, TEST_PEOPLE, null, null, responseHandler);	entity = responseHandler.await();	assertEquals("Russell", entity.getProperty("FirstName").getValue().toString());	
single entry 

assertEquals("Shanghai Airline", entity.getProperty("Name").getValue().toString());	responseHandler.reset();	olingoApp.read(edm, TEST_PEOPLE, null, null, responseHandler);	entity = responseHandler.await();	assertEquals("Russell", entity.getProperty("FirstName").getValue().toString());	responseHandler.reset();	final Map<String, String> queryParams = new HashMap<String, String>();	queryParams.put(SystemQueryOptionKind.EXPAND.toString(), TRIPS);	olingoApp.read(edm, TEST_PEOPLE, queryParams, null, responseHandler);	ClientEntity entityExpanded = responseHandler.await();	
single people entiry with expanded trips relation 

public void testReadUnparsedEntity() throws Exception {	final TestOlingo4ResponseHandler<InputStream> responseHandler = new TestOlingo4ResponseHandler<InputStream>();	olingoApp.uread(edm, TEST_AIRLINE, null, null, responseHandler);	InputStream rawEntity = responseHandler.await();	assertNotNull("Data entity", rawEntity);	ClientEntity entity = reader.readEntity(rawEntity, TEST_FORMAT);	assertEquals("Shanghai Airline", entity.getProperty("Name").getValue().toString());	
single entity 

olingoApp.uread(edm, TEST_AIRLINE, null, null, responseHandler);	InputStream rawEntity = responseHandler.await();	assertNotNull("Data entity", rawEntity);	ClientEntity entity = reader.readEntity(rawEntity, TEST_FORMAT);	assertEquals("Shanghai Airline", entity.getProperty("Name").getValue().toString());	responseHandler.reset();	olingoApp.uread(edm, TEST_PEOPLE, null, null, responseHandler);	rawEntity = responseHandler.await();	entity = reader.readEntity(rawEntity, TEST_FORMAT);	assertEquals("Russell", entity.getProperty("FirstName").getValue().toString());	
single entity 

olingoApp.uread(edm, TEST_PEOPLE, null, null, responseHandler);	rawEntity = responseHandler.await();	entity = reader.readEntity(rawEntity, TEST_FORMAT);	assertEquals("Russell", entity.getProperty("FirstName").getValue().toString());	responseHandler.reset();	final Map<String, String> queryParams = new HashMap<String, String>();	queryParams.put(SystemQueryOptionKind.EXPAND.toString(), TRIPS);	olingoApp.uread(edm, TEST_PEOPLE, queryParams, null, responseHandler);	rawEntity = responseHandler.await();	entity = reader.readEntity(rawEntity, TEST_FORMAT);	
single people entiry with expanded trips relation 

public void testReadUpdateProperties() throws Exception {	final TestOlingo4ResponseHandler<ClientPrimitiveValue> propertyHandler = new TestOlingo4ResponseHandler<ClientPrimitiveValue>();	olingoApp.read(edm, TEST_AIRPORTS_SIMPLE_PROPERTY, null, null, propertyHandler);	ClientPrimitiveValue name = (ClientPrimitiveValue)propertyHandler.await();	assertEquals("San Francisco International Airport", name.toString());	
airport name property value 

public void testReadUpdateProperties() throws Exception {	final TestOlingo4ResponseHandler<ClientPrimitiveValue> propertyHandler = new TestOlingo4ResponseHandler<ClientPrimitiveValue>();	olingoApp.read(edm, TEST_AIRPORTS_SIMPLE_PROPERTY, null, null, propertyHandler);	ClientPrimitiveValue name = (ClientPrimitiveValue)propertyHandler.await();	assertEquals("San Francisco International Airport", name.toString());	final TestOlingo4ResponseHandler<ClientPrimitiveValue> valueHandler = new TestOlingo4ResponseHandler<ClientPrimitiveValue>();	olingoApp.read(edm, TEST_AIRPORTS_SIMPLE_PROPERTY_VALUE, null, null, valueHandler);	ClientPrimitiveValue nameValue = valueHandler.await();	assertEquals("San Francisco International Airport", name.toString());	
airport name property value 

final TestOlingo4ResponseHandler<ClientPrimitiveValue> valueHandler = new TestOlingo4ResponseHandler<ClientPrimitiveValue>();	olingoApp.read(edm, TEST_AIRPORTS_SIMPLE_PROPERTY_VALUE, null, null, valueHandler);	ClientPrimitiveValue nameValue = valueHandler.await();	assertEquals("San Francisco International Airport", name.toString());	TestOlingo4ResponseHandler<HttpStatusCode> statusHandler = new TestOlingo4ResponseHandler<HttpStatusCode>();	ClientEntity clientEntity = objFactory.newEntity(null);	clientEntity.getProperties().add(objFactory.newPrimitiveProperty("MiddleName", objFactory.newPrimitiveValueBuilder().buildString("Middle")));	olingoApp.update(edm, TEST_PEOPLE, null, clientEntity, statusHandler);	HttpStatusCode statusCode = statusHandler.await();	assertEquals(HttpStatusCode.NO_CONTENT, statusCode);	
name property updated with status 

TestOlingo4ResponseHandler<HttpStatusCode> statusHandler = new TestOlingo4ResponseHandler<HttpStatusCode>();	ClientEntity clientEntity = objFactory.newEntity(null);	clientEntity.getProperties().add(objFactory.newPrimitiveProperty("MiddleName", objFactory.newPrimitiveValueBuilder().buildString("Middle")));	olingoApp.update(edm, TEST_PEOPLE, null, clientEntity, statusHandler);	HttpStatusCode statusCode = statusHandler.await();	assertEquals(HttpStatusCode.NO_CONTENT, statusCode);	final TestOlingo4ResponseHandler<ClientEntity> responseHandler = new TestOlingo4ResponseHandler<ClientEntity>();	olingoApp.read(edm, TEST_PEOPLE, null, null, responseHandler);	ClientEntity entity = responseHandler.await();	assertEquals("Middle", entity.getProperty("MiddleName").getValue().toString());	
updated single entity 

public void testReadCount() throws Exception {	final TestOlingo4ResponseHandler<Long> countHandler = new TestOlingo4ResponseHandler<Long>();	olingoApp.read(edm, PEOPLE + COUNT_OPTION, null, null, countHandler);	Long count = countHandler.await();	assertEquals(20, count.intValue());	
people count 

public void testCreateUpdateDeleteEntity() throws Exception {	final TestOlingo4ResponseHandler<ClientEntity> entryHandler = new TestOlingo4ResponseHandler<ClientEntity>();	olingoApp.create(edm, PEOPLE, null, createEntity(), entryHandler);	ClientEntity createdEntity = entryHandler.await();	
created entity 

olingoApp.update(edm, TEST_CREATE_PEOPLE, null, updateEntity, statusHandler);	statusHandler.await();	statusHandler.reset();	updateEntity = createEntity();	updateEntity.getProperties().add(objFactory.newPrimitiveProperty("MiddleName", objFactory.newPrimitiveValueBuilder().buildString("Middle Patched")));	olingoApp.patch(edm, TEST_CREATE_PEOPLE, null, updateEntity, statusHandler);	statusHandler.await();	entryHandler.reset();	olingoApp.read(edm, TEST_CREATE_PEOPLE, null, null, entryHandler);	ClientEntity updatedEntity = entryHandler.await();	
updated entity successfully 

updateEntity = createEntity();	updateEntity.getProperties().add(objFactory.newPrimitiveProperty("MiddleName", objFactory.newPrimitiveValueBuilder().buildString("Middle Patched")));	olingoApp.patch(edm, TEST_CREATE_PEOPLE, null, updateEntity, statusHandler);	statusHandler.await();	entryHandler.reset();	olingoApp.read(edm, TEST_CREATE_PEOPLE, null, null, entryHandler);	ClientEntity updatedEntity = entryHandler.await();	statusHandler.reset();	olingoApp.delete(TEST_CREATE_PEOPLE, null, statusHandler);	HttpStatusCode statusCode = statusHandler.await();	
deletion of entity was successful 

updateEntity.getProperties().add(objFactory.newPrimitiveProperty("MiddleName", objFactory.newPrimitiveValueBuilder().buildString("Middle Patched")));	olingoApp.patch(edm, TEST_CREATE_PEOPLE, null, updateEntity, statusHandler);	statusHandler.await();	entryHandler.reset();	olingoApp.read(edm, TEST_CREATE_PEOPLE, null, null, entryHandler);	ClientEntity updatedEntity = entryHandler.await();	statusHandler.reset();	olingoApp.delete(TEST_CREATE_PEOPLE, null, statusHandler);	HttpStatusCode statusCode = statusHandler.await();	try {	
verify delete entity 

ClientEntity updatedEntity = entryHandler.await();	statusHandler.reset();	olingoApp.delete(TEST_CREATE_PEOPLE, null, statusHandler);	HttpStatusCode statusCode = statusHandler.await();	try {	entryHandler.reset();	olingoApp.read(edm, TEST_CREATE_PEOPLE, null, null, entryHandler);	entryHandler.await();	fail("Entity not deleted!");	} catch (Exception e) {	
deleted entity not found 

batchParts.add(Olingo4BatchChangeRequest.resourcePath(TEST_CREATE_PEOPLE).resourceUri(TEST_SERVICE_BASE_URL).contentId(TEST_UPDATE_RESOURCE_CONTENT_ID) .operation(Operation.UPDATE).body(clientEntity).build());	batchParts.add(Olingo4BatchChangeRequest.resourcePath(TEST_CREATE_PEOPLE).resourceUri(TEST_SERVICE_BASE_URL).operation(Operation.DELETE).build());	batchParts.add(Olingo4BatchQueryRequest.resourcePath(TEST_CREATE_PEOPLE).resourceUri(TEST_SERVICE_BASE_URL).build());	final TestOlingo4ResponseHandler<List<Olingo4BatchResponse>> responseHandler = new TestOlingo4ResponseHandler<List<Olingo4BatchResponse>>();	olingoApp.batch(edm, null, batchParts, responseHandler);	final List<Olingo4BatchResponse> responseParts = responseHandler.await(15, TimeUnit.MINUTES);	assertEquals("Batch responses expected", 8, responseParts.size());	assertNotNull(responseParts.get(0).getBody());	final ClientEntitySet clientEntitySet = (ClientEntitySet)responseParts.get(1).getBody();	assertNotNull(clientEntitySet);	
batch entity set 

batchParts.add(Olingo4BatchQueryRequest.resourcePath(TEST_CREATE_PEOPLE).resourceUri(TEST_SERVICE_BASE_URL).build());	final TestOlingo4ResponseHandler<List<Olingo4BatchResponse>> responseHandler = new TestOlingo4ResponseHandler<List<Olingo4BatchResponse>>();	olingoApp.batch(edm, null, batchParts, responseHandler);	final List<Olingo4BatchResponse> responseParts = responseHandler.await(15, TimeUnit.MINUTES);	assertEquals("Batch responses expected", 8, responseParts.size());	assertNotNull(responseParts.get(0).getBody());	final ClientEntitySet clientEntitySet = (ClientEntitySet)responseParts.get(1).getBody();	assertNotNull(clientEntitySet);	ClientEntity returnClientEntity = (ClientEntity)responseParts.get(2).getBody();	assertNotNull(returnClientEntity);	
batch read entity 

olingoApp.batch(edm, null, batchParts, responseHandler);	final List<Olingo4BatchResponse> responseParts = responseHandler.await(15, TimeUnit.MINUTES);	assertEquals("Batch responses expected", 8, responseParts.size());	assertNotNull(responseParts.get(0).getBody());	final ClientEntitySet clientEntitySet = (ClientEntitySet)responseParts.get(1).getBody();	assertNotNull(clientEntitySet);	ClientEntity returnClientEntity = (ClientEntity)responseParts.get(2).getBody();	assertNotNull(returnClientEntity);	returnClientEntity = (ClientEntity)responseParts.get(3).getBody();	assertNotNull(returnClientEntity);	
batch read entity with expand 

assertNotNull(responseParts.get(0).getBody());	final ClientEntitySet clientEntitySet = (ClientEntitySet)responseParts.get(1).getBody();	assertNotNull(clientEntitySet);	ClientEntity returnClientEntity = (ClientEntity)responseParts.get(2).getBody();	assertNotNull(returnClientEntity);	returnClientEntity = (ClientEntity)responseParts.get(3).getBody();	assertNotNull(returnClientEntity);	ClientEntity createdClientEntity = (ClientEntity)responseParts.get(4).getBody();	assertNotNull(createdClientEntity);	assertEquals(TEST_CREATE_RESOURCE_CONTENT_ID, responseParts.get(4).getContentId());	
batch created entity 

public void onResponse(T response, Map<String, String> responseHeaders) {	this.response = response;	if (LOG.isDebugEnabled()) {	if (response instanceof ClientEntitySet) {	
received response 

public void onResponse(T response, Map<String, String> responseHeaders) {	this.response = response;	if (LOG.isDebugEnabled()) {	if (response instanceof ClientEntitySet) {	} else if (response instanceof ClientEntity) {	
received response 

public void onResponse(T response, Map<String, String> responseHeaders) {	this.response = response;	if (LOG.isDebugEnabled()) {	if (response instanceof ClientEntitySet) {	} else if (response instanceof ClientEntity) {	} else {	
received response 

========================= camel sample_15459 =========================

if (isSendToAllSet(in)) {	sendToAll(store, message, exchange);	} else {	String connectionKey = in.getHeader(WebsocketConstants.CONNECTION_KEY, String.class);	if (connectionKey != null) {	String pathSpec = "";	if (endpoint.getResourceUri() != null) {	pathSpec = WebsocketComponent.createPathSpec(endpoint.getResourceUri());	}	DefaultWebsocket websocket = store.get(connectionKey + pathSpec);	
sending to connection key 

protected void handleSleepInterruptedException(InterruptedException e, Exchange exchange) throws InterruptedException {	if (log.isDebugEnabled()) {	
sleep interrupted are we stopping 

========================= camel sample_17464 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<XsltComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.xslt.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.xslt.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_885 =========================

public void process(Exchange exchange) throws Exception {	Message in = exchange.getIn();	PullRequest pullRequest = (PullRequest) in.getBody();	User pullRequestUser = pullRequest.getUser();	pullRequest.getTitle();	pullRequest.getHtmlUrl();	pullRequest.getUser().getLogin();	pullRequest.getUser().getHtmlUrl();	
got pullrequest from 

========================= camel sample_14248 =========================

public ChannelPipeline getPipeline() throws Exception {	ChannelPipeline channelPipeline = Channels.pipeline();	SslHandler sslHandler = configureClientSSLOnDemand();	if (sslHandler != null) {	sslHandler.setCloseOnSSLException(true);	
client ssl handler configured and added to the channelpipeline 

List<ChannelHandler> encoders = producer.getConfiguration().getEncoders();	for (int x = 0; x < encoders.size(); x++) {	ChannelHandler encoder = encoders.get(x);	if (encoder instanceof ChannelHandlerFactory) {	encoder = ((ChannelHandlerFactory) encoder).newChannelHandler();	}	addToPipeline("encoder-" + x, channelPipeline, encoder);	}	if (producer.getConfiguration().getRequestTimeout() > 0) {	if (LOG.isTraceEnabled()) {	
using request timeout millis 

}	addToPipeline("encoder-" + x, channelPipeline, encoder);	}	if (producer.getConfiguration().getRequestTimeout() > 0) {	if (LOG.isTraceEnabled()) {	}	ChannelHandler timeout = new ReadTimeoutHandler(producer.getEndpoint().getTimer(), producer.getConfiguration().getRequestTimeout(), TimeUnit.MILLISECONDS);	addToPipeline("timeout", channelPipeline, timeout);	}	addToPipeline("handler", channelPipeline, new ClientChannelHandler(producer));	
created channelpipeline 

private SSLContext createSSLContext(NettyProducer producer) throws Exception {	NettyConfiguration configuration = producer.getConfiguration();	if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(producer.getContext());	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	
keystorefile is null 

if (!configuration.isSsl()) {	return null;	}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(producer.getContext());	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	
truststorefile is null 

}	SSLContext answer;	if (configuration.getSslContextParameters() != null) {	answer = configuration.getSslContextParameters().createSSLContext(producer.getContext());	} else {	if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {	}	if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {	}	if (configuration.getPassphrase().toCharArray() == null) {	
passphrase is null 

========================= camel sample_6661 =========================

protected void checkName(Object value, String name) {	if (ObjectHelper.isEmpty(value)) {	
the of is empty cxf will try to load the first one in wsdl for you 

========================= camel sample_7973 =========================

public void testQuartzPersistentStoreRestart() throws Exception {	AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz/SpringQuartzPersistentStoreTest.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMinimumMessageCount(2);	mock.assertIsSatisfied();	app.stop();	
restarting 

public void testQuartzPersistentStoreRestart() throws Exception {	AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz/SpringQuartzPersistentStoreTest.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMinimumMessageCount(2);	mock.assertIsSatisfied();	app.stop();	
restarting 

public void testQuartzPersistentStoreRestart() throws Exception {	AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz/SpringQuartzPersistentStoreTest.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMinimumMessageCount(2);	mock.assertIsSatisfied();	app.stop();	
restarting 

========================= camel sample_17171 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KubernetesServiceAccountsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-service-accounts.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-service-accounts.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_539 =========================

protected int poll() throws Exception {	try {	if (endpoint.getConfiguration().isStreaming()) {	dataReader.read(new SplunkResultProcessor() {	public void process(SplunkEvent splunkEvent) {	final Exchange exchange = getEndpoint().createExchange();	Message message = exchange.getIn();	message.setBody(splunkEvent);	try {	
processing exchange 

try {	if (endpoint.getConfiguration().isStreaming()) {	dataReader.read(new SplunkResultProcessor() {	public void process(SplunkEvent splunkEvent) {	final Exchange exchange = getEndpoint().createExchange();	Message message = exchange.getIn();	message.setBody(splunkEvent);	try {	getAsyncProcessor().process(exchange, new AsyncCallback() {	public void done(boolean doneSync) {	
done processing exchange 

protected Queue<Exchange> createExchanges(List<SplunkEvent> splunkEvents) {	
received messages in this poll 

public int processBatch(Queue<Object> exchanges) throws Exception {	int total = exchanges.size();	for (int index = 0; index < total && isBatchAllowed(); index++) {	Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());	exchange.setProperty(Exchange.BATCH_INDEX, index);	exchange.setProperty(Exchange.BATCH_SIZE, total);	exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);	try {	
processing exchange 

========================= camel sample_14474 =========================

result = new DOMResult();	} else if (source instanceof SAXSource) {	result = new SAXResult();	} else if (source instanceof StAXSource || source instanceof StreamSource) {	result = null;	}	if (source != null) {	ValidatorErrorHandler handler = errorHandler.getClass().newInstance();	validator.setErrorHandler(handler);	try {	
validating 

========================= camel sample_4575 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<StompComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.stomp.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.stomp.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_755 =========================

protected void checkWeatherContent(String weather) {	
the weather in format is 

========================= camel sample_11363 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<UniVocityFixedWidthDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.univocity-fixed.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.univocity-fixed.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_1262 =========================

String foundEscaped = found.replace("$", "\\$").replace("{", "\\{").replace("}", "\\}");	Matcher paramMatcher = Pattern.compile("\\:\\?in\\:" + foundEscaped, Pattern.MULTILINE).matcher(query);	query = paramMatcher.replaceAll(replace);	}	}	}	answer = REPLACE_PATTERN.matcher(query).replaceAll("\\?");	} else {	answer = query;	}	
prepared query 

}	final Object[] args = new Object[expectedParams];	int i = 0;	int argNumber = 1;	while (iterator != null && iterator.hasNext()) {	Object value = iterator.next();	if (value instanceof CompositeIterator) {	Iterator it = (Iterator) value;	while (it.hasNext()) {	Object val = it.next();	
setting parameter with value 

Iterator it = (Iterator) value;	while (it.hasNext()) {	Object val = it.next();	if (argNumber <= expectedParams) {	args[i] = val;	}	argNumber++;	i++;	}	} else {	
setting parameter with value 

========================= camel sample_9015 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<JingComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jing.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jing.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1075 =========================

public void testWSHttpCall() throws Exception {	final CountDownLatch latch = new CountDownLatch(1);	AsyncHttpClient c = new DefaultAsyncHttpClient();	final List<Object> received = Collections.synchronizedList(new ArrayList<Object>());	WebSocket websocket = c.prepareGet("ws: .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

========================= camel sample_13149 =========================

public BatchGoogleDriveClientFactory(String proxyHost, int proxyPort) {	try {	Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(InetAddress.getByName(proxyHost), proxyPort));	this.transport = new NetHttpTransport.Builder().setProxy(proxy).build();	this.jsonFactory = new JacksonFactory();	} catch (UnknownHostException e) {	
unknow proxy host 

========================= camel sample_15422 =========================

public void testUsingContextComponent() throws Exception {	Object accounts = applicationContext.getBean("accounts");	
found accounts 

public void testUsingContextComponent() throws Exception {	Object accounts = applicationContext.getBean("accounts");	resultEndpoint.expectedHeaderReceived("received", "true");	resultEndpoint.expectedMessageCount(2);	template.sendBody("<purchaseOrder>one</purchaseOrder>");	template.sendBody("<purchaseOrder>two</purchaseOrder>");	resultEndpoint.assertIsSatisfied();	List<Exchange> receivedExchanges = resultEndpoint.getReceivedExchanges();	for (Exchange exchange : receivedExchanges) {	Message in = exchange.getIn();	
received from headers body 

========================= camel sample_12164 =========================

protected void doStop() throws Exception {	super.doStop();	
stopping kubernetes deployments consumer 

========================= camel sample_13325 =========================

public static void startServer() throws Exception {	Object implementor = new GreeterImpl();	String address = "http: endpoint = Endpoint.publish(address, implementor);	
the ws endpoint is published 

========================= camel sample_6026 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<XmlRpcDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.xmlrpc.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.xmlrpc.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_1219 =========================

private void getVolumes(Exchange exchange) throws Exception {	String region = exchange.getIn().getHeader(DigitalOceanHeaders.REGION, String.class);	if (ObjectHelper.isEmpty(region)) {	throw new IllegalArgumentException(DigitalOceanHeaders.REGION + " must be specified");	}	Volumes volumes = getEndpoint().getDigitalOceanClient().getAvailableVolumes(region);	
all volumes for region 

volume.setRegion(new Region(in.getHeader(DigitalOceanHeaders.REGION, String.class)));	} else {	throw new IllegalArgumentException(DigitalOceanHeaders.REGION + " must be specified");	}	if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(DigitalOceanHeaders.DESCRIPTION))) {	volume.setDescription(in.getHeader(DigitalOceanHeaders.DESCRIPTION, String.class));	} else {	throw new IllegalArgumentException(DigitalOceanHeaders.DESCRIPTION + " must be specified");	}	volume = getEndpoint().getDigitalOceanClient().createVolume(volume);	
volume created 

if (ObjectHelper.isEmpty(name) && ObjectHelper.isEmpty(region)) {	throw new IllegalArgumentException(DigitalOceanHeaders.ID + " or " + DigitalOceanHeaders.NAME + " and " + DigitalOceanHeaders.REGION + " must be specified");	}	List<Volume> volumes = getEndpoint().getDigitalOceanClient().getVolumeInfo(name, region).getVolumes();	if (volumes.size() > 0) {	volume = volumes.get(1);	}	} else {	volume = getEndpoint().getDigitalOceanClient().getVolumeInfo(volumeId);	}	
volume 

private void getVolumeSnapshots(Exchange exchange) throws Exception {	String volumeId = exchange.getIn().getHeader(DigitalOceanHeaders.ID, String.class);	if (ObjectHelper.isEmpty(volumeId)) {	throw new IllegalArgumentException(DigitalOceanHeaders.ID + " must be specified");	}	Snapshots snapshots = getEndpoint().getDigitalOceanClient().getVolumeSnapshots(volumeId, configuration.getPage(), configuration.getPerPage());	
all snapshots for volume 

if (ObjectHelper.isEmpty(volumeId)) {	String name = exchange.getIn().getHeader(DigitalOceanHeaders.NAME, String.class);	String region = exchange.getIn().getHeader(DigitalOceanHeaders.REGION, String.class);	if (ObjectHelper.isEmpty(name) && ObjectHelper.isEmpty(region)) {	throw new IllegalArgumentException(DigitalOceanHeaders.ID + " or " + DigitalOceanHeaders.NAME + " and " + DigitalOceanHeaders.REGION + " must be specified");	}	delete = getEndpoint().getDigitalOceanClient().deleteVolume(name, region);	} else {	delete = getEndpoint().getDigitalOceanClient().deleteVolume(volumeId);	}	
delete volume 

String region = exchange.getIn().getHeader(DigitalOceanHeaders.REGION, String.class);	if (ObjectHelper.isEmpty(dropletId)) {	throw new IllegalArgumentException(DigitalOceanHeaders.DROPLET_ID + " must be specified");	}	if (ObjectHelper.isEmpty(region)) {	throw new IllegalArgumentException(DigitalOceanHeaders.REGION + " must be specified");	}	Action action;	if (ObjectHelper.isNotEmpty(volumeName)) {	action = getEndpoint().getDigitalOceanClient().attachVolumeByName(dropletId, volumeName, region);	
attach volume to droplet 

throw new IllegalArgumentException(DigitalOceanHeaders.DROPLET_ID + " must be specified");	}	if (ObjectHelper.isEmpty(region)) {	throw new IllegalArgumentException(DigitalOceanHeaders.REGION + " must be specified");	}	Action action;	if (ObjectHelper.isNotEmpty(volumeName)) {	action = getEndpoint().getDigitalOceanClient().attachVolumeByName(dropletId, volumeName, region);	} else if (ObjectHelper.isNotEmpty(volumeId)) {	action = getEndpoint().getDigitalOceanClient().attachVolume(dropletId, volumeId, region);	
attach volume to droplet 

String region = exchange.getIn().getHeader(DigitalOceanHeaders.REGION, String.class);	if (ObjectHelper.isEmpty(dropletId)) {	throw new IllegalArgumentException(DigitalOceanHeaders.DROPLET_ID + " must be specified");	}	if (ObjectHelper.isEmpty(region)) {	throw new IllegalArgumentException(DigitalOceanHeaders.REGION + " must be specified");	}	Action action;	if (ObjectHelper.isNotEmpty(volumeName)) {	action = getEndpoint().getDigitalOceanClient().detachVolumeByName(dropletId, volumeName, region);	
detach volume to droplet 

throw new IllegalArgumentException(DigitalOceanHeaders.DROPLET_ID + " must be specified");	}	if (ObjectHelper.isEmpty(region)) {	throw new IllegalArgumentException(DigitalOceanHeaders.REGION + " must be specified");	}	Action action;	if (ObjectHelper.isNotEmpty(volumeName)) {	action = getEndpoint().getDigitalOceanClient().detachVolumeByName(dropletId, volumeName, region);	} else if (ObjectHelper.isNotEmpty(volumeId)) {	action = getEndpoint().getDigitalOceanClient().detachVolume(dropletId, volumeId, region);	
detach volume to droplet 

}	String region = exchange.getIn().getHeader(DigitalOceanHeaders.REGION, String.class);	if (ObjectHelper.isEmpty(region)) {	throw new IllegalArgumentException(DigitalOceanHeaders.REGION + " must be specified");	}	Double size = exchange.getIn().getHeader(DigitalOceanHeaders.VOLUME_SIZE_GIGABYTES, Double.class);	if (ObjectHelper.isEmpty(size)) {	throw new IllegalArgumentException(DigitalOceanHeaders.VOLUME_SIZE_GIGABYTES + " must be specified");	}	Action action = getEndpoint().getDigitalOceanClient().resizeVolume(volumeId, region, size);	
resize volume 

private void getVolumeActions(Exchange exchange) throws Exception {	String volumeId = exchange.getIn().getHeader(DigitalOceanHeaders.ID, String.class);	if (ObjectHelper.isEmpty(volumeId)) {	throw new IllegalArgumentException(DigitalOceanHeaders.ID + " must be specified");	}	Actions actions = getEndpoint().getDigitalOceanClient().getAvailableVolumeActions(volumeId);	
actions for volume 

========================= camel sample_8891 =========================

private static String formatDate(Date date) {	if (date == null) {	return null;	}	try {	return new SimpleDateFormat(DATE_TIME_FORMAT).format(date);	} catch (Exception e) {	
unable to format date using format 

private static Date getLocalTimestamp(ConfigMap configMap, String group) {	String timestamp = getConfigMapValue(configMap, LOCAL_TIMESTAMP_PREFIX + group);	if (timestamp == null) {	return null;	}	try {	return new SimpleDateFormat(DATE_TIME_FORMAT).parse(timestamp);	} catch (Exception e) {	
unable to parse time string using format 

========================= camel sample_13260 =========================

public void testClientInvocation() throws Exception {	String out = template.requestBodyAndHeader("jms:queue:loan", null, Constants.PROPERTY_SSN, "Client-A", String.class);	
result 

========================= camel sample_17673 =========================

final Result<Transaction> createResult = requestBody( "direct: new TransactionRequest() .amount(new BigDecimal("100.00")) .paymentMethodNonce("fake-valid-nonce") .options() .submitForSettlement(true) .done(), Result.class );	assertNotNull("sale result", createResult);	assertTrue(createResult.isSuccess());	String createId = createResult.getTarget().getId();	final Result<Transaction> settleResult = this.gateway.testing().settle(createId);	assertNotNull("settle result", settleResult);	assertTrue(settleResult.isSuccess());	final Result<Transaction> result = requestBody( "direct: createId, Result.class );	assertNotNull("Request Refund result", result);	assertTrue(result.isSuccess());	
refund id s created for transaction id s 

final Result<Transaction> createResult = requestBody( "direct: new TransactionRequest() .amount(new BigDecimal("100.00")) .paymentMethodNonce("fake-valid-nonce") .options() .submitForSettlement(true) .done(), Result.class );	assertNotNull("sale result", createResult);	assertTrue(createResult.isSuccess());	String createId = createResult.getTarget().getId();	final Result<Transaction> settleResult = this.gateway.testing().settle(createId);	assertNotNull("settle result", settleResult);	assertTrue(settleResult.isSuccess());	final Result<Transaction> result = requestBodyAndHeaders( "direct: null, new BraintreeHeaderBuilder() .add("id", createId) .add("amount", new BigDecimal("99.00")) .build(), Result.class );	assertNotNull("Request Refund result", result);	assertTrue(result.isSuccess());	
refund id s created for transaction id s 

final Result<Transaction> createResult = requestBody( "direct: new TransactionRequest() .amount(new BigDecimal("100.00")) .paymentMethodNonce("fake-valid-nonce") .options() .submitForSettlement(true) .done(), Result.class );	assertNotNull("sale result", createResult);	assertTrue(createResult.isSuccess());	String createId = createResult.getTarget().getId();	final Result<Transaction> settleResult = this.gateway.testing().settle(createId);	assertNotNull("settle result", settleResult);	assertTrue(settleResult.isSuccess());	final Result<Transaction> result = requestBodyAndHeaders( "direct: null, new BraintreeHeaderBuilder() .add("id", createId) .add("refundRequest", new TransactionRefundRequest() .amount(new BigDecimal("100.00"))) .build(), Result.class );	assertNotNull("Request Refund result", result);	assertTrue(result.isSuccess());	
refund id s created for transaction id s 

public void testCancelRelease() throws Exception {	final com.braintreegateway.Result result = requestBody("direct: assertNotNull("cancelRelease result", result);	
cancelrelease 

public void testCredit() throws Exception {	final com.braintreegateway.Result result = requestBody("direct: assertNotNull("credit result", result);	
credit 

public void testHoldInEscrow() throws Exception {	final com.braintreegateway.Result result = requestBody("direct: assertNotNull("holdInEscrow result", result);	
holdinescrow 

public void testReleaseFromEscrow() throws Exception {	final com.braintreegateway.Result result = requestBody("direct: assertNotNull("releaseFromEscrow result", result);	
releasefromescrow 

public void testSearch() throws Exception {	final com.braintreegateway.ResourceCollection result = requestBody("direct: assertNotNull("search result", result);	
search 

public void testSubmitForPartialSettlement() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBraintree.id", null);	headers.put("CamelBraintree.amount", null);	final com.braintreegateway.Result result = requestBodyAndHeaders("direct: assertNotNull("submitForPartialSettlement result", result);	
submitforpartialsettlement 

public void testVoidTransaction() throws Exception {	final com.braintreegateway.Result result = requestBody("direct: assertNotNull("voidTransaction result", result);	
voidtransaction 

========================= camel sample_17389 =========================

public void process(final Exchange exchange) throws Exception {	if (exchange.getPattern().isOutCapable()) {	if (inputChannel == null) {	throw new IllegalArgumentException("InputChannel has not been configured on " + getEndpoint());	}	exchange.getIn().getHeaders().put(MessageHeaders.REPLY_CHANNEL, inputChannel);	inputChannel.subscribe(new MessageHandler() {	public void handleMessage(Message<?> message) {	
received from inputchannel 

throw new IllegalArgumentException("InputChannel has not been configured on " + getEndpoint());	}	exchange.getIn().getHeaders().put(MessageHeaders.REPLY_CHANNEL, inputChannel);	inputChannel.subscribe(new MessageHandler() {	public void handleMessage(Message<?> message) {	SpringIntegrationBinding.storeToCamelMessage(message, exchange.getOut());	}	});	}	org.springframework.messaging.Message<?> siOutmessage = SpringIntegrationBinding.createSpringIntegrationMessage(exchange);	
sending to outputchannel 

========================= camel sample_11123 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<ZipFileDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.zipfile.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.zipfile.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_1188 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<IgniteIdGenComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ignite-idgen.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ignite-idgen.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1167 =========================

public Processor wrapProcessorInInterceptors(final CamelContext context, final ProcessorDefinition<?> definition, final Processor target, final Processor nextTarget) throws Exception {	return new Processor() {	public void process(Exchange exchange) throws Exception {	count++;	
i am the container wide interceptor intercepted total count 

========================= camel sample_16259 =========================

protected void doStart() throws Exception {	super.doStart();	
registering event handler to eventbus 

protected void doStop() throws Exception {	
unregistering event handler from eventbus 

public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {	if (method.getAnnotation(Subscribe.class) != null) {	delegateHandler.doEventReceived(args[0]);	} else {	
non subscribe method called on listenerinterface proxy 

========================= camel sample_9107 =========================

exchange.getOut().setHeader(InfinispanConstants.EVENT_TYPE, eventType);	exchange.getOut().setHeader(InfinispanConstants.IS_PRE, isPre);	exchange.getOut().setHeader(InfinispanConstants.CACHE_NAME, cacheName);	exchange.getOut().setHeader(InfinispanConstants.KEY, key);	if (eventData != null) {	exchange.getOut().setHeader(InfinispanConstants.EVENT_DATA, eventData);	}	try {	getProcessor().process(exchange);	} catch (Exception e) {	
error processing event 

========================= camel sample_13958 =========================

public void process(Exchange exchange) throws Exception {	Message in = exchange.getIn();	Object message = in.getBody();	if (message != null) {	
sending out 

========================= camel sample_13722 =========================

public boolean process(final Exchange exchange, final AsyncCallback callback) {	executor.submit(new Callable<Object>() {	public Object call() throws Exception {	
simulating a task which takes millis to reply 

public boolean process(final Exchange exchange, final AsyncCallback callback) {	executor.submit(new Callable<Object>() {	public Object call() throws Exception {	Thread.sleep(getEndpoint().getDelay());	int count = counter.incrementAndGet();	if (getEndpoint().getFailFirstAttempts() >= count) {	
simulating a failure at attempt 

executor.submit(new Callable<Object>() {	public Object call() throws Exception {	Thread.sleep(getEndpoint().getDelay());	int count = counter.incrementAndGet();	if (getEndpoint().getFailFirstAttempts() >= count) {	exchange.setException(new CamelExchangeException("Simulated error at attempt " + count, exchange));	} else {	String reply = getEndpoint().getReply();	exchange.getOut().setBody(reply);	exchange.getOut().setHeaders(exchange.getIn().getHeaders());	
setting reply 

public Object call() throws Exception {	Thread.sleep(getEndpoint().getDelay());	int count = counter.incrementAndGet();	if (getEndpoint().getFailFirstAttempts() >= count) {	exchange.setException(new CamelExchangeException("Simulated error at attempt " + count, exchange));	} else {	String reply = getEndpoint().getReply();	exchange.getOut().setBody(reply);	exchange.getOut().setHeaders(exchange.getIn().getHeaders());	}	
callback done false 

exchange.setException(new CamelExchangeException("Simulated error at attempt " + count, exchange));	} else {	String reply = getEndpoint().getReply();	exchange.getOut().setBody(reply);	exchange.getOut().setHeaders(exchange.getIn().getHeaders());	}	callback.done(false);	return null;	}	});	
task submitted now tell camel routing engine to that this exchange is being continued asynchronously 

========================= camel sample_6071 =========================

protected boolean classPathHasSpaces() {	ClassLoader cl = getClass().getClassLoader();	if (cl instanceof URLClassLoader) {	URLClassLoader ucl = (URLClassLoader)cl;	URL[] urls = ucl.getURLs();	for (URL url : urls) {	if (url.getPath().contains(" ")) {	log.error("=======================================================================");	
test skipped 

protected boolean classPathHasSpaces() {	ClassLoader cl = getClass().getClassLoader();	if (cl instanceof URLClassLoader) {	URLClassLoader ucl = (URLClassLoader)cl;	URL[] urls = ucl.getURLs();	for (URL url : urls) {	if (url.getPath().contains(" ")) {	log.error("=======================================================================");	
your probably on windows we detected that the classpath 

protected boolean classPathHasSpaces() {	ClassLoader cl = getClass().getClassLoader();	if (cl instanceof URLClassLoader) {	URLClassLoader ucl = (URLClassLoader)cl;	URL[] urls = ucl.getURLs();	for (URL url : urls) {	if (url.getPath().contains(" ")) {	log.error("=======================================================================");	
has a space in it try running maven with the following option 

========================= camel sample_9384 =========================

public ByteSource encrypt() throws Exception {	if (passPhrase == bits128) {	
using the default encryption key is not secure 

========================= camel sample_12133 =========================

resultEndpoint.expectedMessageCount(1);	Map<String, Object> body = new LinkedHashMap<String, Object>();	body.put("foo", "abc");	body.put("bar", 123);	template.sendBody("direct:start", body);	resultEndpoint.assertIsSatisfied();	List<Exchange> list = resultEndpoint.getReceivedExchanges();	for (Exchange exchange : list) {	Message in = exchange.getIn();	String text = in.getBody(String.class);	
received 

Map<String, Object> body2 = new LinkedHashMap<String, Object>();	body2.put("foo", "def");	body2.put("bar", 456);	body2.put("baz", 789);	template.sendBody("direct:startMulti", body1);	template.sendBody("direct:startMulti", body2);	resultEndpoint.assertIsSatisfied();	List<Exchange> list = resultEndpoint.getReceivedExchanges();	Message in1 = list.get(0).getIn();	String text1 = in1.getBody(String.class);	
received 

body2.put("baz", 789);	template.sendBody("direct:startMulti", body1);	template.sendBody("direct:startMulti", body2);	resultEndpoint.assertIsSatisfied();	List<Exchange> list = resultEndpoint.getReceivedExchanges();	Message in1 = list.get(0).getIn();	String text1 = in1.getBody(String.class);	assertTrue("First CSV body has wrong value", Pattern.matches("(abc,123)|(123,abc)", text1.trim()));	Message in2 = list.get(1).getIn();	String text2 = in2.getBody(String.class);	
received 

Map<String, Object> body2 = new LinkedHashMap<String, Object>();	body2.put("foo", "def");	body2.put("bar", 456);	body2.put("baz", 789);	body2.put("buz", "000");	template.sendBody("direct:startMultiCustom", body1);	template.sendBody("direct:startMultiCustom", body2);	List<Exchange> list = resultEndpoint.getReceivedExchanges();	Message in1 = list.get(0).getIn();	String text1 = in1.getBody(String.class);	
received 

body2.put("baz", 789);	body2.put("buz", "000");	template.sendBody("direct:startMultiCustom", body1);	template.sendBody("direct:startMultiCustom", body2);	List<Exchange> list = resultEndpoint.getReceivedExchanges();	Message in1 = list.get(0).getIn();	String text1 = in1.getBody(String.class);	assertEquals("First CSV body has wrong value", "abc;;123", text1.trim());	Message in2 = list.get(1).getIn();	String text2 = in2.getBody(String.class);	
received 

public void testUnMarshal() throws Exception {	MockEndpoint endpoint = getMockEndpoint("mock:daltons");	endpoint.expectedMessageCount(1);	endpoint.assertIsSatisfied();	Exchange exchange = endpoint.getExchanges().get(0);	List<List<String>> data = (List<List<String>>) exchange.getIn().getBody();	for (List<String> line : data) {	
s has an iq of s and is currently s 

========================= camel sample_12076 =========================

from("direct:start"). setHeader("QUERY", constant("Rodney Dangerfield")). process(new LuceneQueryProcessor("target/stdindexDir", analyzer, null, 20)). to("direct:next");	} catch (Exception e) {	e.printStackTrace();	}	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	Hits hits = exchange.getIn().getBody(Hits.class);	printResults(hits);	}	private void printResults(Hits hits) {	
number of hits 

} catch (Exception e) {	e.printStackTrace();	}	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	Hits hits = exchange.getIn().getBody(Hits.class);	printResults(hits);	}	private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	
hit index location 

} catch (Exception e) {	e.printStackTrace();	}	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	Hits hits = exchange.getIn().getBody(Hits.class);	printResults(hits);	}	private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	
hit score 

} catch (Exception e) {	e.printStackTrace();	}	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	Hits hits = exchange.getIn().getBody(Hits.class);	printResults(hits);	}	private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	
hit data 

printResults(hits);	}	private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	}	}	}).to("mock:searchResult");	}	});	context.start();	
beginning phrase standard analyzer search test 

private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	}	}	}).to("mock:searchResult");	}	});	context.start();	sendRequest();	mockSearchEndpoint.assertIsSatisfied();	
completed phrase standard analyzer search test 

from("direct:start"). setHeader("QUERY", constant("Carl*")). process(new LuceneQueryProcessor("target/simpleindexDir", analyzer, null, 20)). to("direct:next");	} catch (Exception e) {	e.printStackTrace();	}	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	Hits hits = exchange.getIn().getBody(Hits.class);	printResults(hits);	}	private void printResults(Hits hits) {	
number of hits 

} catch (Exception e) {	e.printStackTrace();	}	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	Hits hits = exchange.getIn().getBody(Hits.class);	printResults(hits);	}	private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	
hit index location 

} catch (Exception e) {	e.printStackTrace();	}	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	Hits hits = exchange.getIn().getBody(Hits.class);	printResults(hits);	}	private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	
hit score 

} catch (Exception e) {	e.printStackTrace();	}	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	Hits hits = exchange.getIn().getBody(Hits.class);	printResults(hits);	}	private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	
hit data 

printResults(hits);	}	private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	}	}	}).to("mock:searchResult");	}	});	context.start();	
beginning wildcard simple analyzer phrase searcher test 

private void printResults(Hits hits) {	for (int i = 0; i < hits.getNumberOfHits(); i++) {	}	}	}).to("mock:searchResult");	}	});	context.start();	sendRequest();	mockSearchEndpoint.assertIsSatisfied();	
completed wildcard simple analyzer phrase searcher test 

========================= camel sample_6837 =========================

public void onNext(Event event) {	
received docker event 

public void onNext(Event event) {	final Exchange exchange = getEndpoint().createExchange();	Message message = exchange.getIn();	message.setBody(event);	try {	
processing exchange 

public void onNext(Event event) {	final Exchange exchange = getEndpoint().createExchange();	Message message = exchange.getIn();	message.setBody(event);	try {	getAsyncProcessor().process(exchange, new AsyncCallback() {	public void done(boolean doneSync) {	
done processing exchange 

========================= camel sample_6564 =========================

public boolean process(final Exchange exchange, final AsyncCallback callback) {	executor.submit(new Callable<Object>() {	public Object call() throws Exception {	
simulating a task which takes millis to reply 

public boolean process(final Exchange exchange, final AsyncCallback callback) {	executor.submit(new Callable<Object>() {	public Object call() throws Exception {	Thread.sleep(getEndpoint().getDelay());	int count = counter.incrementAndGet();	if (getEndpoint().getFailFirstAttempts() >= count) {	
simulating a failure at attempt 

public boolean process(final Exchange exchange, final AsyncCallback callback) {	executor.submit(new Callable<Object>() {	public Object call() throws Exception {	Thread.sleep(getEndpoint().getDelay());	int count = counter.incrementAndGet();	if (getEndpoint().getFailFirstAttempts() >= count) {	exchange.setException(new CamelExchangeException("Simulated error at attempt " + count, exchange));	} else {	String reply = getEndpoint().getReply();	exchange.getOut().setBody(reply);	
setting reply 

executor.submit(new Callable<Object>() {	public Object call() throws Exception {	Thread.sleep(getEndpoint().getDelay());	int count = counter.incrementAndGet();	if (getEndpoint().getFailFirstAttempts() >= count) {	exchange.setException(new CamelExchangeException("Simulated error at attempt " + count, exchange));	} else {	String reply = getEndpoint().getReply();	exchange.getOut().setBody(reply);	}	
callback done false 

if (getEndpoint().getFailFirstAttempts() >= count) {	exchange.setException(new CamelExchangeException("Simulated error at attempt " + count, exchange));	} else {	String reply = getEndpoint().getReply();	exchange.getOut().setBody(reply);	}	callback.done(false);	return null;	}	});	
task submitted now tell camel routing engine to that this exchange is being continued asynchronously 

========================= camel sample_10948 =========================

public void process(Exchange exchange) throws Exception {	String operation = getOperation(exchange);	Object key = getKey(exchange);	
processing operation on 

exchange.getOut().setAttachments(exchange.getIn().getAttachments());	exchange.getOut().setHeader(KratiConstants.KRATI_OPERATION_STATUS, KratiConstants.KRATI_OPERATION_FAILURE);	}	} else if (KratiConstants.KRATI_OPERATION_DELETEALL.equals(operation)) {	try {	dataStore.clear();	exchange.getOut().setHeaders(exchange.getIn().getHeaders());	exchange.getOut().setAttachments(exchange.getIn().getAttachments());	exchange.getOut().setHeader(KratiConstants.KRATI_OPERATION_STATUS, KratiConstants.KRATI_OPERATION_SUCESSFUL);	} catch (Exception e) {	
error clearing all entries from store 

========================= camel sample_14008 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<FileComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.file.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.file.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_850 =========================

private void doCreateQueue(CloudQueue client, QueueServiceRequestOptions opts, Exchange exchange) throws Exception {	
creating the queue from exchange 

private void deleteQueue(Exchange exchange) throws Exception {	
deleting the queue from exchange 

private void addMessage(Exchange exchange) throws Exception {	
putting the message into the queue from exchange 

private void updateMessage(Exchange exchange) throws Exception {	CloudQueue client = QueueServiceUtil.createQueueClient(getConfiguration());	QueueServiceRequestOptions opts = QueueServiceUtil.getRequestOptions(exchange);	CloudQueueMessage message = getCloudQueueMessage(exchange);	
updating the message in the queue from exchange 

private void deleteMessage(Exchange exchange) throws Exception {	
deleting the message from the queue from exchange 

========================= camel sample_9957 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<JsonDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.json-xstream.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.json-xstream.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_503 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ElasticsearchComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.elasticsearch5-rest.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.elasticsearch5-rest.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_446 =========================

resultEndpoint.expectedMessageCount(2);	String badHtml = TidyMarkupTestSupport.loadFileAsString(new File( "src/test/resources/org/apache/camel/dataformat/tagsoup/testfile1.html"));	String evilHtml = TidyMarkupTestSupport.loadFileAsString(new File( "src/test/resources/org/apache/camel/dataformat/tagsoup/testfile2-evilHtml.html"));	template.sendBody("direct:start", badHtml);	template.sendBody("direct:start", evilHtml);	resultEndpoint.assertIsSatisfied();	List<Exchange> list = resultEndpoint.getReceivedExchanges();	for (Exchange exchange : list) {	Message in = exchange.getIn();	String response = in.getBody(String.class);	
received 

========================= camel sample_11973 =========================

public void testRouteboxUsingDispatchMap() throws Exception {	template = new DefaultProducerTemplate(context);	template.start();	context.addRoutes(new RouteBuilder() {	public void configure() {	from(routeboxUri) .to("log:Routes operation performed?showAll=true");	}	});	context.start();	
beginning test testrouteboxusingdispatchmap 

context.addRoutes(new RouteBuilder() {	public void configure() {	from(routeboxUri) .to("log:Routes operation performed?showAll=true");	}	});	context.start();	Book book = new Book("Sir Arthur Conan Doyle", "The Adventures of Sherlock Holmes");	String response = sendAddToCatalogRequest(template, routeboxUri, "addToCatalog", book);	assertEquals("Book with Author " + book.getAuthor() + " and title " + book.getTitle() + " added to Catalog", response);	book = sendFindBookRequest(template, routeboxUri, "findBook", "Sir Arthur Conan Doyle");	
received book with author and title 

public void configure() {	from(routeboxUri) .to("log:Routes operation performed?showAll=true");	}	});	context.start();	Book book = new Book("Sir Arthur Conan Doyle", "The Adventures of Sherlock Holmes");	String response = sendAddToCatalogRequest(template, routeboxUri, "addToCatalog", book);	assertEquals("Book with Author " + book.getAuthor() + " and title " + book.getTitle() + " added to Catalog", response);	book = sendFindBookRequest(template, routeboxUri, "findBook", "Sir Arthur Conan Doyle");	assertEquals("The Adventures of Sherlock Holmes", book.getTitle());	
completed test testrouteboxusingdispatchmap 

========================= camel sample_14622 =========================

public boolean isManaged(Object managedObject, Object name) {	try {	ObjectName objectName = getObjectName(managedObject, name);	if (objectName != null) {	return getManagementAgent().isRegistered(objectName);	}	} catch (Exception e) {	
cannot check whether the managed object is registered this exception will be ignored 

protected void doStart() throws Exception {	
jmx is enabled 

========================= camel sample_4689 =========================

protected void checkWeatherContent(String weather) {	
the weather in format is 

========================= camel sample_11359 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<PythonLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.python.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.python.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_1258 =========================

public void testTokenize() throws InterruptedException {	template.setDefaultEndpointUri("direct:tokenize");	execute(1);	resetMock(count);	StopWatch watch = new StopWatch();	execute(1);	assertMockEndpointsSatisfied();	
ran tests in ms 

========================= camel sample_6437 =========================

}	});	mockRecovery.assertIsSatisfied();	mockResult.assertIsSatisfied();	List<Exchange> list = mockRecovery.getReceivedExchanges();	Exchange exchange = list.get(0);	assertNotNull("exchange", exchange);	Message in = exchange.getIn();	assertNotNull("in", in);	Map<String, Object> headers = in.getHeaders();	
headers 

mockRecovery.assertIsSatisfied();	mockResult.assertIsSatisfied();	List<Exchange> list = mockRecovery.getReceivedExchanges();	Exchange exchange = list.get(0);	assertNotNull("exchange", exchange);	Message in = exchange.getIn();	assertNotNull("in", in);	Map<String, Object> headers = in.getHeaders();	assertTrue("Should be more than one header but was: " + headers, headers.size() > 0);	String body = in.getBody(String.class);	
body 

========================= camel sample_12826 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<TwitterTimelineComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.twitter-timeline.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.twitter-timeline.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_780 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KubernetesBuildConfigsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-build-configs.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-build-configs.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_554 =========================

public static void warmUp() {	if (INIT.compareAndSet(false, true)) {	Runnable task = () -> {	StopWatch watch = new StopWatch();	
warming up lrucache 

public static void warmUp() {	if (INIT.compareAndSet(false, true)) {	Runnable task = () -> {	StopWatch watch = new StopWatch();	newLRUCache(16);	
warming up lrucache complete in millis 

public static LRUCache newLRUCache(int maximumCacheSize) {	
creating lrucache with maximumcachesize 

public static LRUCache newLRUCache(int initialCapacity, int maximumCacheSize) {	
creating lrucache with initialcapacity maximumcachesize 

public static LRUCache newLRUCache(int initialCapacity, int maximumCacheSize, boolean stopOnEviction) {	
creating lrucache with initialcapacity maximumcachesize stoponeviction 

public static LRUSoftCache newLRUSoftCache(int maximumCacheSize) {	
creating lrusoftcache with maximumcachesize 

public static LRUWeakCache newLRUWeakCache(int maximumCacheSize) {	
creating lruweakcache with maximumcachesize 

========================= camel sample_4261 =========================

public HdfsOsgiHelper(Map<String, String> fileSystems) {	try {	ClassLoader cl = getClass().getClassLoader();	Configuration conf = new Configuration();	conf.setClassLoader(cl);	for (String key : fileSystems.keySet()) {	URI uri = URI.create(key);	conf.setClass(String.format("fs.%s.impl", uri.getScheme()), cl.loadClass(fileSystems.get(key)), FileSystem.class);	
successfully loaded class 

public HdfsOsgiHelper(Map<String, String> fileSystems) {	try {	ClassLoader cl = getClass().getClassLoader();	Configuration conf = new Configuration();	conf.setClassLoader(cl);	for (String key : fileSystems.keySet()) {	URI uri = URI.create(key);	conf.setClass(String.format("fs.%s.impl", uri.getScheme()), cl.loadClass(fileSystems.get(key)), FileSystem.class);	FileSystem.get(uri, conf);	
successfully got uri from filesystem object 

========================= camel sample_11162 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<OptaPlannerComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.optaplanner.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.optaplanner.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1063 =========================

public void getBasicApiJsonSchema() throws Exception {	
basic api schema 

public void getSObjectJsonSchema() throws Exception {	SObjectDescription description = new Account().description();	
sobject schema 

========================= camel sample_14730 =========================

public Exchange receiveNoWait() {	if (LOG.isTraceEnabled()) {	
receivenowait polling file 

public Exchange receive() {	if (LOG.isTraceEnabled()) {	
receive polling file 

public Exchange receive(long timeout) {	if (LOG.isTraceEnabled()) {	
receive polling file 

int polledMessages = 0;	PollingConsumerPollStrategy pollStrategy = getConsumer().getPollStrategy();	boolean sendEmptyMessageWhenIdle = getConsumer() instanceof ScheduledBatchPollingConsumer && getConsumer().isSendEmptyMessageWhenIdle();	StopWatch watch = new StopWatch();	while (!done) {	try {	cause = null;	done = true;	if (isRunAllowed()) {	if (retryCounter == -1) {	
starting to poll 

PollingConsumerPollStrategy pollStrategy = getConsumer().getPollStrategy();	boolean sendEmptyMessageWhenIdle = getConsumer() instanceof ScheduledBatchPollingConsumer && getConsumer().isSendEmptyMessageWhenIdle();	StopWatch watch = new StopWatch();	while (!done) {	try {	cause = null;	done = true;	if (isRunAllowed()) {	if (retryCounter == -1) {	} else {	
retrying attempt to poll 

cause = null;	done = true;	if (isRunAllowed()) {	if (retryCounter == -1) {	} else {	}	boolean begin = pollStrategy.begin(getConsumer(), getEndpoint());	if (begin) {	retryCounter++;	polledMessages = getConsumer().poll();	
polled messages 

if (begin) {	retryCounter++;	polledMessages = getConsumer().poll();	if (polledMessages == 0 && sendEmptyMessageWhenIdle) {	processEmptyMessage();	} else if (polledMessages == 0 && timeout > 0) {	done = false;	}	pollStrategy.commit(getConsumer(), getEndpoint(), polledMessages);	} else {	
cannot begin polling as pollstrategy returned false 

polledMessages = getConsumer().poll();	if (polledMessages == 0 && sendEmptyMessageWhenIdle) {	processEmptyMessage();	} else if (polledMessages == 0 && timeout > 0) {	done = false;	}	pollStrategy.commit(getConsumer(), getEndpoint(), polledMessages);	} else {	}	}	
finished polling 

public void process(Exchange exchange) throws Exception {	Object name = exchange.getIn().getHeader(Exchange.FILE_NAME);	if (name != null) {	
received file 

protected void processEmptyMessage() throws Exception {	Exchange exchange = getEndpoint().createExchange();	
sending empty message as there were no messages from polling 

private static void sleep(long delay) throws InterruptedException {	if (delay <= 0) {	return;	}	
sleeping for millis 

========================= camel sample_4774 =========================

public void testCopyFile() throws Exception {	com.box.sdk.BoxFile result = null;	try {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.fileId", testFile.getID());	headers.put("CamelBox.destinationFolderId", "0");	headers.put("CamelBox.newName", CAMEL_TEST_COPY_FILE_NAME);	result = requestBodyAndHeaders("direct: assertNotNull("copyFile result", result);	assertEquals("copyFile name", CAMEL_TEST_COPY_FILE_NAME, result.getInfo().getName());	
copyfile 

public void testCreateFileMetadata() throws Exception {	Metadata metadata = new Metadata();	metadata.add("/foo", "bar");	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.fileId", testFile.getID());	headers.put("CamelBox.metadata", metadata);	headers.put("CamelBox.typeName", null);	final com.box.sdk.Metadata result = requestBodyAndHeaders("direct: assertNotNull("createFileMetadata result", result);	assertEquals("createFileMetadata result", "bar", result.get("/foo"));	
createfilemetadata 

public void testCreateFileSharedLink() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.fileId", testFile.getID());	headers.put("CamelBox.access", BoxSharedLink.Access.DEFAULT);	headers.put("CamelBox.unshareDate", null);	headers.put("CamelBox.permissions", null);	final com.box.sdk.BoxSharedLink result = requestBodyAndHeaders("direct: assertNotNull("createFileSharedLink result", result);	
createfilesharedlink 

public void testDeleteFile() throws Exception {	requestBody("direct: BoxFolder rootFolder = BoxFolder.getRootFolder(getConnection());	Iterable<BoxItem.Info> it = rootFolder.search("^" + CAMEL_TEST_FILE + "$");	int searchResults = sizeOfIterable(it);	boolean exists = searchResults > 0 ? true : false;	assertEquals("deleteFile exists", false, exists);	
deletefile exists 

public void testDownloadFile() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.fileId", testFile.getID());	ByteArrayOutputStream output = new ByteArrayOutputStream();	headers.put("CamelBox.output", output);	headers.put("CamelBox.rangeStart", null);	headers.put("CamelBox.rangeEnd", null);	headers.put("CamelBox.listener", null);	final java.io.OutputStream result = requestBodyAndHeaders("direct: assertNotNull("downloadFile result", result);	
downloadfile 

public void testDownloadPreviousFileVersion() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.fileId", testFile.getID());	headers.put("CamelBox.version", 0);	ByteArrayOutputStream output = new ByteArrayOutputStream();	headers.put("CamelBox.output", output);	headers.put("CamelBox.listener", null);	final java.io.OutputStream result = requestBodyAndHeaders("direct: headers);	assertNotNull("downloadPreviousFileVersion result", result);	
downloadpreviousfileversion 

public void testGetDownloadURL() throws Exception {	final java.net.URL result = requestBody("direct: assertNotNull("getDownloadURL result", result);	
getdownloadurl 

public void testGetFileInfo() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.fileId", testFile.getID());	headers.put("CamelBox.fields", null);	final com.box.sdk.BoxFile.Info result = requestBodyAndHeaders("direct: assertNotNull("getFileInfo result", result);	
getfileinfo 

public void testGetFileMetadata() throws Exception {	testFile.createMetadata(new Metadata());	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.fileId", testFile.getID());	headers.put("CamelBox.typeName", null);	final com.box.sdk.Metadata result = requestBodyAndHeaders("direct: assertNotNull("getFileMetadata result", result);	
getfilemetadata 

public void testGetFilePreviewLink() throws Exception {	final java.net.URL result = requestBody("direct: assertNotNull("getFilePreviewLink result", result);	
getfilepreviewlink 

public void testGetFileThumbnail() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.fileId", testFile.getID());	headers.put("CamelBox.fileType", ThumbnailFileType.JPG);	headers.put("CamelBox.minWidth", 32);	headers.put("CamelBox.minHeight", 32);	headers.put("CamelBox.maxWidth", 32);	headers.put("CamelBox.maxHeight", 32);	final byte[] result = requestBodyAndHeaders("direct: assertNotNull("getFileThumbnail result", result);	
getfilethumbnail 

public void testGetFileVersions() throws Exception {	final java.util.Collection result = requestBody("direct: assertNotNull("getFileVersions result", result);	
getfileversions 

public void testMoveFile() throws Exception {	com.box.sdk.BoxFile result = null;	try {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.fileId", testFile.getID());	headers.put("CamelBox.destinationFolderId", "0");	headers.put("CamelBox.newName", CAMEL_TEST_MOVE_FILE_NAME);	result = requestBodyAndHeaders("direct: assertNotNull("moveFile result", result);	assertEquals("moveFile name", CAMEL_TEST_MOVE_FILE_NAME, result.getInfo().getName());	
movefile 

public void testPromoteFileVersion() throws Exception {	testFile.uploadVersion(getClass().getResourceAsStream(CAMEL_TEST_FILE));	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.fileId", testFile.getID());	headers.put("CamelBox.version", 1);	final com.box.sdk.BoxFileVersion result = requestBodyAndHeaders("direct: assertNotNull("promoteFileVersion result", result);	
promotefileversion 

public void testRenameFile() throws Exception {	com.box.sdk.BoxFile result = null;	try {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.fileId", testFile.getID());	headers.put("CamelBox.newFileName", CAMEL_TEST_RENAME_FILE_NAME);	result = requestBodyAndHeaders("direct: assertNotNull("renameFile result", result);	assertEquals("renameFile name", CAMEL_TEST_RENAME_FILE_NAME, result.getInfo().getName());	
renamefile 

public void testUpdateFileInfo() throws Exception {	BoxFile.Info info = testFile.getInfo();	info.setDescription(CAMEL_TEST_FILE_DESCRIPTION);	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.fileId", testFile.getID());	headers.put("CamelBox.info", info);	final com.box.sdk.BoxFile result = requestBodyAndHeaders("direct: assertNotNull("updateFileInfo result", result);	assertEquals("updateFileInfo info", CAMEL_TEST_FILE_DESCRIPTION, result.getInfo().getDescription());	
updatefileinfo 

public void testUpdateFileMetadata() throws Exception {	Metadata metadata = new Metadata();	metadata = testFile.createMetadata(metadata);	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.fileId", testFile.getID());	headers.put("CamelBox.metadata", metadata);	final com.box.sdk.Metadata result = requestBodyAndHeaders("direct: assertNotNull("updateFileMetadata result", result);	
updatefilemetadata 

try {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.parentFolderId", "0");	headers.put("CamelBox.content", getClass().getResourceAsStream(CAMEL_TEST_FILE));	headers.put("CamelBox.fileName", CAMEL_TEST_UPLOAD_FILE_NAME);	headers.put("CamelBox.created", null);	headers.put("CamelBox.modified", null);	headers.put("CamelBox.size", null);	headers.put("CamelBox.listener", null);	result = requestBodyAndHeaders("direct: assertNotNull("uploadFile result", result);	
uploadfile 

public void testUploadNewFileVersion() throws Exception {	com.box.sdk.BoxFile result = null;	try {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.fileId", testFile.getID());	headers.put("CamelBox.fileContent", getClass().getResourceAsStream(CAMEL_TEST_FILE));	headers.put("CamelBox.modified", null);	headers.put("CamelBox.fileSize", null);	headers.put("CamelBox.listener", null);	result = requestBodyAndHeaders("direct: assertNotNull("uploadNewFileVersion result", result);	
uploadnewfileversion 

========================= camel sample_17409 =========================

public void doStart() throws Exception {	super.doStart();	sdbClient = configuration.getAmazonSDBClient() != null ? configuration.getAmazonSDBClient() : createSdbClient();	String domainName = getConfiguration().getDomainName();	
querying whether domain already exists 

public void doStart() throws Exception {	super.doStart();	sdbClient = configuration.getAmazonSDBClient() != null ? configuration.getAmazonSDBClient() : createSdbClient();	String domainName = getConfiguration().getDomainName();	try {	sdbClient.domainMetadata(new DomainMetadataRequest(domainName));	
domain already exists 

public void doStart() throws Exception {	super.doStart();	sdbClient = configuration.getAmazonSDBClient() != null ? configuration.getAmazonSDBClient() : createSdbClient();	String domainName = getConfiguration().getDomainName();	try {	sdbClient.domainMetadata(new DomainMetadataRequest(domainName));	return;	} catch (NoSuchDomainException ase) {	
domain doesn t exist yet 

public void doStart() throws Exception {	super.doStart();	sdbClient = configuration.getAmazonSDBClient() != null ? configuration.getAmazonSDBClient() : createSdbClient();	String domainName = getConfiguration().getDomainName();	try {	sdbClient.domainMetadata(new DomainMetadataRequest(domainName));	return;	} catch (NoSuchDomainException ase) {	
creating domain 

public void doStart() throws Exception {	super.doStart();	sdbClient = configuration.getAmazonSDBClient() != null ? configuration.getAmazonSDBClient() : createSdbClient();	String domainName = getConfiguration().getDomainName();	try {	sdbClient.domainMetadata(new DomainMetadataRequest(domainName));	return;	} catch (NoSuchDomainException ase) {	sdbClient.createDomain(new CreateDomainRequest(domainName));	
domain created 

========================= camel sample_8757 =========================

public void validateConfiguration() {	for (ChannelHandler encoder : encoders) {	if (encoder instanceof ChannelHandlerFactory) {	continue;	}	if (ObjectHelper.getAnnotation(encoder, ChannelHandler.Sharable.class) != null) {	continue;	}	
the encoder is not shareable or an channelhandlerfactory instance the encoder cannot safely be used 

continue;	}	}	for (ChannelHandler decoder : decoders) {	if (decoder instanceof ChannelHandlerFactory) {	continue;	}	if (ObjectHelper.getAnnotation(decoder, ChannelHandler.Sharable.class) != null) {	continue;	}	
the decoder is not shareable or an channelhandlerfactory instance the decoder cannot safely be used 

continue;	}	if (ObjectHelper.getAnnotation(decoder, ChannelHandler.Sharable.class) != null) {	continue;	}	}	if (sslHandler != null) {	boolean factory = sslHandler instanceof ChannelHandlerFactory;	boolean shareable = ObjectHelper.getAnnotation(sslHandler, ChannelHandler.Sharable.class) != null;	if (!factory && !shareable) {	
the sslhandler is not shareable or an channelhandlerfactory instance the sslhandler cannot safely be used 

if ("udp".equalsIgnoreCase(protocol)) {	encoders.add(ChannelHandlerFactories.newDatagramPacketEncoder());	}	if (isTextline()) {	Charset charset = getEncoding() != null ? Charset.forName(getEncoding()) : CharsetUtil.UTF_8;	encoders.add(ChannelHandlerFactories.newStringEncoder(charset, protocol));	ByteBuf[] delimiters = delimiter == TextLineDelimiter.LINE ? Delimiters.lineDelimiter() : Delimiters.nulDelimiter();	decoders.add(ChannelHandlerFactories.newDelimiterBasedFrameDecoder(decoderMaxLineLength, delimiters, protocol));	decoders.add(ChannelHandlerFactories.newStringDecoder(charset, protocol));	if (LOG.isDebugEnabled()) {	
using textline encoders and decoders with charset delimiter and decodermaxlinelength 

decoders.add(ChannelHandlerFactories.newDelimiterBasedFrameDecoder(decoderMaxLineLength, delimiters, protocol));	decoders.add(ChannelHandlerFactories.newStringDecoder(charset, protocol));	if (LOG.isDebugEnabled()) {	}	} else if ("udp".equalsIgnoreCase(protocol) && isUdpByteArrayCodec()) {	encoders.add(ChannelHandlerFactories.newByteArrayEncoder(protocol));	decoders.add(ChannelHandlerFactories.newByteArrayDecoder(protocol));	} else {	encoders.add(ChannelHandlerFactories.newObjectEncoder(protocol));	decoders.add(ChannelHandlerFactories.newObjectDecoder(protocol));	
using object encoders and decoders 

encoders.add(ChannelHandlerFactories.newByteArrayEncoder(protocol));	decoders.add(ChannelHandlerFactories.newByteArrayDecoder(protocol));	} else {	encoders.add(ChannelHandlerFactories.newObjectEncoder(protocol));	decoders.add(ChannelHandlerFactories.newObjectDecoder(protocol));	}	if ("udp".equalsIgnoreCase(protocol)) {	decoders.add(ChannelHandlerFactories.newDatagramPacketDecoder());	}	} else {	
no encoders and decoders will be used 

} else {	encoders.add(ChannelHandlerFactories.newObjectEncoder(protocol));	decoders.add(ChannelHandlerFactories.newObjectDecoder(protocol));	}	if ("udp".equalsIgnoreCase(protocol)) {	decoders.add(ChannelHandlerFactories.newDatagramPacketDecoder());	}	} else {	}	} else {	
using configured encoders and or decoders 

========================= camel sample_10266 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<HazelcastMapComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-map.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-map.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_692 =========================

public void testAsyncJmsInOut() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(100);	mock.expectsNoDuplicates(body());	StopWatch watch = new StopWatch();	for (int i = 0; i < 100; i++) {	template.sendBody("seda:start", "" + i);	}	assertMockEndpointsSatisfied(20, TimeUnit.SECONDS);	
took ms to process messages request reply over jms 

========================= camel sample_6933 =========================

private void createJDBCConnection() throws ClassNotFoundException, SQLException {	Class.forName(DrillConstants.DRILL_DRIVER);	
connection url 

========================= camel sample_12037 =========================

public String greetMe(String me) {	
executing operation greetme 

public String greetMe(String me) {	
message received 

public void greetMeOneWay(String me) {	
executing operation greetmeoneway 

public void greetMeOneWay(String me) {	
hello there 

public String sayHi() {	
executing operation sayhi 

========================= camel sample_7764 =========================

private void start() throws IOException {	int port = 50051;	server = ServerBuilder.forPort(port).addService(new HelloCamelImpl()).build().start();	
server started i m listening on 

========================= camel sample_17665 =========================

public void configure() throws Exception {	
foo 

public void configure() throws Exception {	
foo 

public void configure() throws Exception {	
foo 

========================= camel sample_3727 =========================

protected void doGetSecret(Exchange exchange, String operation) throws Exception {	Secret secret = null;	String secretName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SECRET_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(secretName)) {	
get a specific secret require specify a secret name 

protected void doGetSecret(Exchange exchange, String operation) throws Exception {	Secret secret = null;	String secretName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SECRET_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(secretName)) {	throw new IllegalArgumentException( "Get a specific Secret require specify a Secret name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
get a specific secret require specify a namespace name 

protected void doCreateSecret(Exchange exchange, String operation) throws Exception {	Secret secret = null;	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	Secret secretToCreate = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SECRET, Secret.class);	if (ObjectHelper.isEmpty(namespaceName)) {	
create a specific secret require specify a namespace name 

protected void doCreateSecret(Exchange exchange, String operation) throws Exception {	Secret secret = null;	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	Secret secretToCreate = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SECRET, Secret.class);	if (ObjectHelper.isEmpty(namespaceName)) {	throw new IllegalArgumentException( "Create a specific secret require specify a namespace name");	}	if (ObjectHelper.isEmpty(secretToCreate)) {	
create a specific secret require specify a secret bean 

protected void doDeleteSecret(Exchange exchange, String operation) throws Exception {	String secretName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SECRET_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(secretName)) {	
delete a specific secret require specify a secret name 

protected void doDeleteSecret(Exchange exchange, String operation) throws Exception {	String secretName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SECRET_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(secretName)) {	throw new IllegalArgumentException( "Delete a specific secret require specify a secret name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
delete a specific secret require specify a namespace name 

========================= camel sample_13276 =========================

protected void execute(Runnable runnable) {	try {	runnable.run();	} catch (WebApplicationException e) {	final org.apache.camel.component.linkedin.api.model.Error error = e.getResponse().readEntity(Error.class);	assertNotNull(error);	
error 

========================= camel sample_8868 =========================

public void onInit(Route route) {	
initializing throttlingexceptionroutepolicy route policy 

public void onExchangeDone(Route route, Exchange exchange) {	if (keepOpen.get()) {	if (state.get() != STATE_OPEN) {	
opening circuit b c keepopen is on 

for (Class<?> exception : throttledExceptions) {	if (exchange.getException(exception) != null) {	answer = true;	break;	}	}	}	}	if (LOG.isDebugEnabled()) {	String exceptionName = exchange.getException() == null ? "none" : exchange.getException().getClass().getSimpleName();	
hasfailed with throttled exception for exchangeid 

private void calculateState(Route route) {	boolean failureLimitReached = isThresholdExceeded();	if (state.get() == STATE_CLOSED) {	if (failureLimitReached) {	
opening circuit 

private void calculateState(Route route) {	boolean failureLimitReached = isThresholdExceeded();	if (state.get() == STATE_CLOSED) {	if (failureLimitReached) {	openCircuit(route);	}	} else if (state.get() == STATE_HALF_OPEN) {	if (failureLimitReached) {	
opening circuit 

private void calculateState(Route route) {	boolean failureLimitReached = isThresholdExceeded();	if (state.get() == STATE_CLOSED) {	if (failureLimitReached) {	openCircuit(route);	}	} else if (state.get() == STATE_HALF_OPEN) {	if (failureLimitReached) {	openCircuit(route);	} else {	
closing circuit 

} else if (state.get() == STATE_HALF_OPEN) {	if (failureLimitReached) {	openCircuit(route);	} else {	closeCircuit(route);	}	} else if (state.get() == STATE_OPEN) {	if (!keepOpen.get()) {	long elapsedTimeSinceOpened = System.currentTimeMillis() - openedAt;	if (halfOpenAfter <= elapsedTimeSinceOpened) {	
checking an open circuit 

openCircuit(route);	} else {	closeCircuit(route);	}	} else if (state.get() == STATE_OPEN) {	if (!keepOpen.get()) {	long elapsedTimeSinceOpened = System.currentTimeMillis() - openedAt;	if (halfOpenAfter <= elapsedTimeSinceOpened) {	if (halfOpenHandler != null) {	if (halfOpenHandler.isReadyToBeClosed()) {	
closing circuit 

closeCircuit(route);	}	} else if (state.get() == STATE_OPEN) {	if (!keepOpen.get()) {	long elapsedTimeSinceOpened = System.currentTimeMillis() - openedAt;	if (halfOpenAfter <= elapsedTimeSinceOpened) {	if (halfOpenHandler != null) {	if (halfOpenHandler.isReadyToBeClosed()) {	closeCircuit(route);	} else {	
opening circuit 

if (!keepOpen.get()) {	long elapsedTimeSinceOpened = System.currentTimeMillis() - openedAt;	if (halfOpenAfter <= elapsedTimeSinceOpened) {	if (halfOpenHandler != null) {	if (halfOpenHandler.isReadyToBeClosed()) {	closeCircuit(route);	} else {	openCircuit(route);	}	} else {	
half opening circuit 

if (halfOpenHandler != null) {	if (halfOpenHandler.isReadyToBeClosed()) {	closeCircuit(route);	} else {	openCircuit(route);	}	} else {	halfOpenCircuit(route);	}	} else {	
keeping circuit open time not elapsed 

closeCircuit(route);	} else {	openCircuit(route);	}	} else {	halfOpenCircuit(route);	}	} else {	}	} else {	
keeping circuit open keepopen is true 

public void setKeepOpen(boolean keepOpen) {	
keep open 

========================= camel sample_4095 =========================

if (SmppUtils.is8Bit(alphabet)) {	return shortMessage;	}	String encoding = IOHelper.getCharsetName(getExchange(), false);	if (ObjectHelper.isEmpty(encoding) || !Charset.isSupported(encoding)) {	encoding = configuration.getEncoding();	}	try {	return new String(shortMessage, encoding);	} catch (UnsupportedEncodingException e) {	
unsupported encoding using system default encoding 

========================= camel sample_16900 =========================

if (consumers == null) {	consumers = new GenericObjectPool<MessageConsumerResources>(new MessageConsumerResourcesFactory());	consumers.setMaxActive(getConsumerCount());	consumers.setMaxIdle(getConsumerCount());	if (getEndpoint().isAsyncStartListener()) {	asyncStart = getEndpoint().getComponent().getAsyncStartStopExecutorService().submit(new Runnable() {	public void run() {	try {	fillConsumersPool();	} catch (Throwable e) {	
error starting listener container on destination this exception will be ignored 

asyncStart.cancel(true);	}	if (consumers != null) {	if (getEndpoint().isAsyncStopListener()) {	getEndpoint().getComponent().getAsyncStartStopExecutorService().submit(new Runnable() {	public void run() {	try {	consumers.close();	consumers = null;	} catch (Throwable e) {	
error stopping listener container on destination this exception will be ignored 

MessageConsumerResources answer;	ConnectionResource connectionResource = getOrCreateConnectionResource();	Connection conn = connectionResource.borrowConnection();	try {	Session session = conn.createSession(isTransacted(), isTransacted() ? Session.SESSION_TRANSACTED : Session.AUTO_ACKNOWLEDGE);	MessageConsumer messageConsumer = getEndpoint().getJmsObjectFactory().createMessageConsumer(session, getEndpoint());	MessageListener handler = createMessageHandler(session);	messageConsumer.setMessageListener(handler);	answer = new MessageConsumerResources(session, messageConsumer);	} catch (Exception e) {	
unable to create the messageconsumer 

========================= camel sample_12410 =========================

public void notify(EventObject event) throws Exception {	CamelContext context = ((CamelContextStoppingEvent) event).getContext();	try {	String className = this.getClass().getSimpleName();	String dir = "target/camel-route-coverage";	String testName = (String) testMethodName.apply(this);	String name = className + "-" + testName + ".xml";	ManagedCamelContextMBean managedCamelContext = context.getManagedCamelContext();	if (managedCamelContext == null) {	
cannot dump route coverage to file as jmx is not enabled override usejmx method to enable jmx in the unit test classes 

String testName = (String) testMethodName.apply(this);	String name = className + "-" + testName + ".xml";	ManagedCamelContextMBean managedCamelContext = context.getManagedCamelContext();	if (managedCamelContext == null) {	} else {	String xml = managedCamelContext.dumpRoutesCoverageAsXml();	String combined = "<camelRouteCoverage>\n" + gatherTestDetailsAsXml(testName) + xml + "\n</camelRouteCoverage>";	File file = new File(dir);	file.mkdirs();	file = new File(dir, name);	
dumping route coverage to file 

String combined = "<camelRouteCoverage>\n" + gatherTestDetailsAsXml(testName) + xml + "\n</camelRouteCoverage>";	File file = new File(dir);	file.mkdirs();	file = new File(dir, name);	InputStream is = new ByteArrayInputStream(combined.getBytes());	OutputStream os = new FileOutputStream(file, false);	IOHelper.copyAndCloseInput(is, os);	IOHelper.close(os);	}	} catch (Exception e) {	
error during dumping route coverage statistic this exception is ignored 

========================= camel sample_10587 =========================

public void testGetProfile() throws Exception {	final com.google.api.services.gmail.model.Profile result = requestBody("direct: assertNotNull("getProfile result", result);	assertNotNull("Should be email address associated with current account", result.getEmailAddress());	
getprofile 

========================= camel sample_12040 =========================

public void testIntegerMessage() throws Exception {	record = "10000,25.10";	template.sendBody(record);	result.expectedMessageCount(1);	result.assertIsSatisfied();	Object data = result.getReceivedExchanges().get(0).getIn().getBody();	
model generated 

========================= camel sample_7343 =========================

public void read(String body, @XPath("/soap:Envelope/soap:Body/foo/text()") String foo) {	this.foo = foo;	this.body = body;	
read method called on 

========================= camel sample_2454 =========================

protected int poll() throws Exception {	shutdownRunningTask = null;	pendingExchanges = 0;	IBatisEndpoint endpoint = getEndpoint();	
polling 

public int processBatch(Queue<Object> exchanges) throws Exception {	final IBatisEndpoint endpoint = getEndpoint();	int total = exchanges.size();	if (maxMessagesPerPoll > 0 && total > maxMessagesPerPoll) {	
limiting to maximum messages to poll as there were messages in this poll 

total = maxMessagesPerPoll;	}	for (int index = 0; index < total && isBatchAllowed(); index++) {	DataHolder holder = ObjectHelper.cast(DataHolder.class, exchanges.poll());	Exchange exchange = holder.exchange;	Object data = holder.data;	exchange.setProperty(Exchange.BATCH_INDEX, index);	exchange.setProperty(Exchange.BATCH_SIZE, total);	exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);	pendingExchanges = total - index - 1;	
processing exchange 

========================= camel sample_17307 =========================

}	final AtomicInteger total = new AtomicInteger(0);	final Iterator<ProcessorExchangePair> it = pairs.iterator();	if (it.hasNext()) {	final AtomicBoolean running = new AtomicBoolean(true);	final AtomicBoolean allTasksSubmitted = new AtomicBoolean();	final CountDownLatch aggregationOnTheFlyDone = new CountDownLatch(1);	final AtomicException executionException = new AtomicException();	final AggregateOnTheFlyTask aggregateOnTheFlyTask = new AggregateOnTheFlyTask(result, original, total, completion, running, aggregationOnTheFlyDone, allTasksSubmitted, executionException);	final AtomicBoolean aggregationTaskSubmitted = new AtomicBoolean();	
starting to submit parallel tasks 

}	Integer number = getExchangeIndex(subExchange);	boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, "Parallel processing failed for number " + number, LOG);	if (stopOnException && !continueProcessing) {	running.set(false);	if (subExchange.getException() != null) {	CamelExchangeException cause = new CamelExchangeException("Parallel processing failed for number " + number, subExchange, subExchange.getException());	subExchange.setException(cause);	}	}	
parallel processing complete for exchange 

});	total.incrementAndGet();	}	} catch (Throwable e) {	if (e instanceof Exception) {	executionException.set((Exception) e);	} else {	executionException.set(ObjectHelper.wrapRuntimeCamelException(e));	}	}	
signaling that all tasks has been submitted 

total.incrementAndGet();	}	} catch (Throwable e) {	if (e instanceof Exception) {	executionException.set((Exception) e);	} else {	executionException.set(ObjectHelper.wrapRuntimeCamelException(e));	}	}	allTasksSubmitted.set(true);	
waiting for on the fly aggregation to complete aggregating responses for exchangeid 

if (e instanceof Exception) {	executionException.set((Exception) e);	} else {	executionException.set(ObjectHelper.wrapRuntimeCamelException(e));	}	}	allTasksSubmitted.set(true);	aggregationOnTheFlyDone.await();	if (executionException.get() != null) {	if (LOG.isDebugEnabled()) {	
parallel processing failed due 

}	}	allTasksSubmitted.set(true);	aggregationOnTheFlyDone.await();	if (executionException.get() != null) {	if (LOG.isDebugEnabled()) {	}	throw executionException.get();	}	}	
done parallel processing exchanges 

public void run() {	
aggregate on the fly task started for exchangeid 

public void run() {	try {	aggregateOnTheFly();	} catch (Throwable e) {	if (e instanceof Exception) {	executionException.set((Exception) e);	} else {	executionException.set(ObjectHelper.wrapRuntimeCamelException(e));	}	} finally {	
signaling we are done aggregating on the fly for exchangeid 

public void run() {	try {	aggregateOnTheFly();	} catch (Throwable e) {	if (e instanceof Exception) {	executionException.set((Exception) e);	} else {	executionException.set(ObjectHelper.wrapRuntimeCamelException(e));	}	} finally {	
aggregate on the fly task done for exchangeid 

private void aggregateOnTheFly() throws InterruptedException, ExecutionException {	final AtomicBoolean timedOut = new AtomicBoolean();	boolean stoppedOnException = false;	final StopWatch watch = new StopWatch();	final AtomicInteger aggregated = new AtomicInteger();	boolean done = false;	while (!done) {	if (allTasksSubmitted.get() && aggregated.intValue() >= total.get()) {	
done aggregating exchanges on the fly 

final StopWatch watch = new StopWatch();	final AtomicInteger aggregated = new AtomicInteger();	boolean done = false;	while (!done) {	if (allTasksSubmitted.get() && aggregated.intValue() >= total.get()) {	break;	}	Future<Exchange> future;	if (timedOut.get()) {	future = completion.poll();	
polled completion task after timeout to grab already completed tasks 

break;	}	Future<Exchange> future;	if (timedOut.get()) {	future = completion.poll();	} else if (timeout > 0) {	long left = timeout - watch.taken();	if (left < 0) {	left = 0;	}	
polling completion task using timeout millis 

Future<Exchange> future;	if (timedOut.get()) {	future = completion.poll();	} else if (timeout > 0) {	long left = timeout - watch.taken();	if (left < 0) {	left = 0;	}	future = completion.poll(left, TimeUnit.MILLISECONDS);	} else {	
polling completion task 

ParallelAggregateTask task = new ParallelAggregateTask(result, subExchange, aggregated);	if (parallelAggregate) {	aggregateExecutorService.submit(task);	} else {	task.run();	}	}	}	if (timedOut.get() || stoppedOnException) {	if (timedOut.get()) {	
cancelling tasks due timeout after millis 

aggregateExecutorService.submit(task);	} else {	task.run();	}	}	}	if (timedOut.get() || stoppedOnException) {	if (timedOut.get()) {	}	if (stoppedOnException) {	
cancelling tasks due stoponexception 

if (strategy instanceof DelegateAggregationStrategy) {	strategy = ((DelegateAggregationStrategy) strategy).getDelegate();	}	if (strategy instanceof TimeoutAwareAggregationStrategy) {	Exchange oldExchange = result.get();	if (oldExchange == null) {	oldExchange = original;	}	((TimeoutAwareAggregationStrategy) strategy).timeout(oldExchange, aggregated.intValue(), total.intValue(), timeout);	} else {	
parallel processing timed out after millis for number this task will be cancelled and will not be aggregated 

strategy = ((DelegateAggregationStrategy) strategy).getDelegate();	}	if (strategy instanceof TimeoutAwareAggregationStrategy) {	Exchange oldExchange = result.get();	if (oldExchange == null) {	oldExchange = original;	}	((TimeoutAwareAggregationStrategy) strategy).timeout(oldExchange, aggregated.intValue(), total.intValue(), timeout);	} else {	}	
timeout occurred after millis for number task 

while (it.hasNext()) {	ProcessorExchangePair pair = it.next();	if (pair == null) {	continue;	}	Exchange subExchange = pair.getExchange();	updateNewExchange(subExchange, total.get(), pairs, it);	boolean sync = doProcessSequential(original, result, pairs, it, pair, callback, total);	if (!sync) {	if (LOG.isTraceEnabled()) {	
processing exchangeid is continued being processed asynchronously 

}	Exchange subExchange = pair.getExchange();	updateNewExchange(subExchange, total.get(), pairs, it);	boolean sync = doProcessSequential(original, result, pairs, it, pair, callback, total);	if (!sync) {	if (LOG.isTraceEnabled()) {	}	return false;	}	if (LOG.isTraceEnabled()) {	
processing exchangeid is continued being processed synchronously 

}	boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, "Sequential processing failed for number " + total.get(), LOG);	if (stopOnException && !continueProcessing) {	if (subExchange.getException() != null) {	CamelExchangeException cause = new CamelExchangeException("Sequential processing failed for number " + total.get(), subExchange, subExchange.getException());	subExchange.setException(cause);	}	result.set(subExchange);	return true;	}	
sequential processing complete for number exchange 

result.set(subExchange);	return true;	}	if (parallelAggregate) {	doAggregateInternal(getAggregationStrategy(subExchange), result, subExchange);	} else {	doAggregate(getAggregationStrategy(subExchange), result, subExchange);	}	total.incrementAndGet();	}	
done sequential processing exchanges 

doDone(original, subExchange, pairs, callback, false, true);	return;	}	total.incrementAndGet();	while (it.hasNext()) {	ProcessorExchangePair pair = it.next();	subExchange = pair.getExchange();	updateNewExchange(subExchange, total.get(), pairs, it);	boolean sync = doProcessSequential(original, result, pairs, it, pair, callback, total);	if (!sync) {	
processing exchangeid is continued being processed asynchronously 

protected Processor createErrorHandler(RouteContext routeContext, Exchange exchange, Processor processor) {	Processor answer;	boolean tryBlock = exchange.getProperty(Exchange.TRY_ROUTE_BLOCK, false, boolean.class);	if (!tryBlock && routeContext != null) {	final PreparedErrorHandler key = new PreparedErrorHandler(routeContext, processor);	answer = errorHandlers.get(key);	if (answer != null) {	
using existing error handler for 

protected Processor createErrorHandler(RouteContext routeContext, Exchange exchange, Processor processor) {	Processor answer;	boolean tryBlock = exchange.getProperty(Exchange.TRY_ROUTE_BLOCK, false, boolean.class);	if (!tryBlock && routeContext != null) {	final PreparedErrorHandler key = new PreparedErrorHandler(routeContext, processor);	answer = errorHandlers.get(key);	if (answer != null) {	return answer;	}	
creating error handler for 

========================= camel sample_4580 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<CaffeineCacheComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.caffeine-cache.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.caffeine-cache.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_466 =========================

public void process(Exchange exchange) throws Exception {	String body = exchange.getIn().getBody(String.class);	SendMessageRequest request = new SendMessageRequest(getQueueUrl(), body);	request.setMessageAttributes(translateAttributes(exchange.getIn().getHeaders(), exchange));	addDelay(request, exchange);	configureFifoAttributes(request, exchange);	
sending request from exchange 

public void process(Exchange exchange) throws Exception {	String body = exchange.getIn().getBody(String.class);	SendMessageRequest request = new SendMessageRequest(getQueueUrl(), body);	request.setMessageAttributes(translateAttributes(exchange.getIn().getHeaders(), exchange));	addDelay(request, exchange);	configureFifoAttributes(request, exchange);	SendMessageResult result = getClient().sendMessage(request);	
received result 

private void addDelay(SendMessageRequest request, Exchange exchange) {	Integer headerValue = exchange.getIn().getHeader(SqsConstants.DELAY_HEADER, Integer.class);	Integer delayValue;	if (headerValue == null) {	
using the config delay 

private void addDelay(SendMessageRequest request, Exchange exchange) {	Integer headerValue = exchange.getIn().getHeader(SqsConstants.DELAY_HEADER, Integer.class);	Integer delayValue;	if (headerValue == null) {	delayValue = getEndpoint().getConfiguration().getDelaySeconds();	} else {	
using the header delay 

private void addDelay(SendMessageRequest request, Exchange exchange) {	Integer headerValue = exchange.getIn().getHeader(SqsConstants.DELAY_HEADER, Integer.class);	Integer delayValue;	if (headerValue == null) {	delayValue = getEndpoint().getConfiguration().getDelaySeconds();	} else {	delayValue = headerValue;	}	
found delay 

========================= camel sample_8720 =========================

if (exchange == null) {	break;	} else {	processor.process(exchange);	}	}	} finally {	try {	ServiceHelper.stopAndShutdownService(consumer);	} catch (Exception e) {	
failed to stop pollingconsumer this example is ignored 

========================= camel sample_4353 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ElsqlComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.elsql.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.elsql.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_935 =========================

public List<RepositoryTag> getTags(IRepositoryIdProvider repository) throws IOException {	
in mockrepositoryservice returning tags 

========================= camel sample_14252 =========================

public void find(PackageScanFilter test, String packageName, Set<Class<?>> classes) {	packageName = packageName.replace('.', '/');	int classesSize = classes.size();	loadImplementationsInBundle(test, packageName, classes);	if (classes.size() == classesSize) {	
cannot find any classes in bundles not trying regular classloaders scanning 

private Set<String> getImplementationsInBundle(PackageScanFilter test, String packageName) {	Bundle[] bundles;	if (bundle.getBundleContext() != null) {	bundles = bundle.getBundleContext().getBundles();	} else {	bundles = new Bundle[]{bundle};	}	Set<String> urls = new LinkedHashSet<String>();	for (Bundle bd : bundles) {	
searching in bundle 

}	Set<String> urls = new LinkedHashSet<String>();	for (Bundle bd : bundles) {	try {	Enumeration<URL> paths = bd.findEntries("/" + packageName, "*.class", true);	while (paths != null && paths.hasMoreElements()) {	URL path = paths.nextElement();	String pathString = path.getPath();	String urlString = pathString.substring(pathString.indexOf(packageName));	urls.add(urlString);	
added url 

for (Bundle bd : bundles) {	try {	Enumeration<URL> paths = bd.findEntries("/" + packageName, "*.class", true);	while (paths != null && paths.hasMoreElements()) {	URL path = paths.nextElement();	String pathString = path.getPath();	String urlString = pathString.substring(pathString.indexOf(packageName));	urls.add(urlString);	}	} catch (Throwable t) {	
cannot search in bundle for classes matching criteria due this exception will be ignored 

========================= camel sample_13082 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SagaComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.saga.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.saga.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_870 =========================

public SolrCloudFixture(String solrHome) throws Exception {	String xml = IOHelper.loadText(new FileInputStream(new File(solrHome, "solr-no-core.xml")));	miniCluster = new MiniSolrCloudCluster(1, "/solr", new File("target/tmp").toPath(), xml, null, null);	String zkAddr = miniCluster.getZkServer().getZkAddress();	String zkHost = miniCluster.getZkServer().getZkHost();	buildZooKeeper(zkHost, zkAddr, new File(solrHome), "solrconfig.xml", "schema.xml");	List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();	for (JettySolrRunner jetty : jettys) {	if (!jetty.isRunning()) {	
jetty not running 

public SolrCloudFixture(String solrHome) throws Exception {	String xml = IOHelper.loadText(new FileInputStream(new File(solrHome, "solr-no-core.xml")));	miniCluster = new MiniSolrCloudCluster(1, "/solr", new File("target/tmp").toPath(), xml, null, null);	String zkAddr = miniCluster.getZkServer().getZkAddress();	String zkHost = miniCluster.getZkServer().getZkHost();	buildZooKeeper(zkHost, zkAddr, new File(solrHome), "solrconfig.xml", "schema.xml");	List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();	for (JettySolrRunner jetty : jettys) {	if (!jetty.isRunning()) {	} else {	
jetty running at port 

public static void putConfig(String confName, SolrZkClient zkClient, File solrhome, final String srcName, String destName) throws Exception {	File file = new File(solrhome, "collection1" + File.separator + "conf" + File.separator + srcName);	if (!file.exists()) {	
zk skipping because it doesn t exist 

public static void putConfig(String confName, SolrZkClient zkClient, File solrhome, final String srcName, String destName) throws Exception {	File file = new File(solrhome, "collection1" + File.separator + "conf" + File.separator + srcName);	if (!file.exists()) {	return;	}	String destPath = "/configs/" + confName + "/" + destName;	
zk put to 

========================= camel sample_13981 =========================

Map<String, List<?>> brothers = new HashMap<String, List<?>>();	brothers.put(newExchange.getIn().getHeader(SURNAME_HEADER, String.class), newExchange.getIn().getBody(List.class));	newExchange.getIn().setBody(brothers);	}	debugOut("Brothers Aggregator", answer);	return answer;	}	};	private void debugIn(String stringId, Exchange oldExchange, Exchange newExchange) {	if (oldExchange != null) {	
old headers in 

Map<String, List<?>> brothers = new HashMap<String, List<?>>();	brothers.put(newExchange.getIn().getHeader(SURNAME_HEADER, String.class), newExchange.getIn().getBody(List.class));	newExchange.getIn().setBody(brothers);	}	debugOut("Brothers Aggregator", answer);	return answer;	}	};	private void debugIn(String stringId, Exchange oldExchange, Exchange newExchange) {	if (oldExchange != null) {	
old body in 

brothers.put(newExchange.getIn().getHeader(SURNAME_HEADER, String.class), newExchange.getIn().getBody(List.class));	newExchange.getIn().setBody(brothers);	}	debugOut("Brothers Aggregator", answer);	return answer;	}	};	private void debugIn(String stringId, Exchange oldExchange, Exchange newExchange) {	if (oldExchange != null) {	}	
new headers in 

brothers.put(newExchange.getIn().getHeader(SURNAME_HEADER, String.class), newExchange.getIn().getBody(List.class));	newExchange.getIn().setBody(brothers);	}	debugOut("Brothers Aggregator", answer);	return answer;	}	};	private void debugIn(String stringId, Exchange oldExchange, Exchange newExchange) {	if (oldExchange != null) {	}	
new body in 

}	debugOut("Brothers Aggregator", answer);	return answer;	}	};	private void debugIn(String stringId, Exchange oldExchange, Exchange newExchange) {	if (oldExchange != null) {	}	}	private void debugOut(String stringId, Exchange exchange) {	
old headers out 

}	debugOut("Brothers Aggregator", answer);	return answer;	}	};	private void debugIn(String stringId, Exchange oldExchange, Exchange newExchange) {	if (oldExchange != null) {	}	}	private void debugOut(String stringId, Exchange exchange) {	
old body out 

========================= camel sample_1917 =========================

}	if (type == TransactedPolicy.class) {	answer = routeContext.lookup(PROPAGATION_REQUIRED, TransactedPolicy.class);	}	if (answer == null && type == TransactedPolicy.class) {	Class<?> tmClazz = routeContext.getCamelContext().getClassResolver().resolveClass("org.springframework.transaction.PlatformTransactionManager");	if (tmClazz != null) {	Map<String, ?> maps = routeContext.lookupByType(tmClazz);	if (maps.size() == 1) {	Object transactionManager = maps.values().iterator().next();	
one instance of platformtransactionmanager found in registry 

answer = routeContext.lookup(PROPAGATION_REQUIRED, TransactedPolicy.class);	}	if (answer == null && type == TransactedPolicy.class) {	Class<?> tmClazz = routeContext.getCamelContext().getClassResolver().resolveClass("org.springframework.transaction.PlatformTransactionManager");	if (tmClazz != null) {	Map<String, ?> maps = routeContext.lookupByType(tmClazz);	if (maps.size() == 1) {	Object transactionManager = maps.values().iterator().next();	Class<?> txClazz = routeContext.getCamelContext().getClassResolver().resolveClass("org.apache.camel.spring.spi.SpringTransactionPolicy");	if (txClazz != null) {	
creating a new temporary springtransactionpolicy using the platformtransactionmanager 

========================= camel sample_5329 =========================

public ServiceNowClient query(Class<?> model) {	if (model != null) {	String name;	String value;	for (ServiceNowSysParm parm : model.getAnnotationsByType(ServiceNowSysParm.class)) {	name = parm.name();	value = parm.value();	if (ObjectHelper.isNotEmpty(name) && ObjectHelper.isNotEmpty(value)) {	
replace query param with value 

========================= camel sample_13606 =========================

public boolean matches(Exchange exchange) {	boolean matches = predicate.matches(exchange);	
filter matches for exchange 

========================= camel sample_4538 =========================

public EmbeddedKafkaBroker(int brokerId, int port, String zkConnection, Properties baseProperties) {	this.brokerId = brokerId;	this.port = port;	this.zkConnection = zkConnection;	this.baseProperties = baseProperties;	
starting broker on port 

logDir = constructTempDir(perTest("kafka-log"));	Properties properties = new Properties();	properties.putAll(baseProperties);	properties.setProperty("zookeeper.connect", zkConnection);	properties.setProperty("broker.id", brokerId.toString());	properties.setProperty("host.name", "localhost");	properties.setProperty("port", Integer.toString(port));	properties.setProperty("log.dir", logDir.getAbsolutePath());	properties.setProperty("num.partitions", String.valueOf(1));	properties.setProperty("auto.create.topics.enable", String.valueOf(Boolean.TRUE));	
log directory 

public void after() {	kafkaServer.shutdown();	try {	TestUtils.deleteFile(logDir);	} catch (FileNotFoundException e) {	
could not delete not found 

========================= camel sample_16404 =========================

assertEquals("james@localhost", it.next().trim());	} else {	assertEquals("bar@localhost", it.next().trim());	}	i++;	}	Enumeration<Header> iter = CastUtils.cast(inMessage.getAllHeaders());	while (iter.hasMoreElements()) {	Header header = iter.nextElement();	String[] value = message.getHeader(header.getName());	
header has value 

========================= camel sample_11791 =========================

exchange.setException(e);	callback.done(true);	return true;	}	}	try {	engine.insert(exchange);	delivery.request();	} catch (Exception e) {	if (isIgnoreInvalidExchanges()) {	
invalid exchange this exchange will be ignored 

========================= camel sample_4492 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("file: .setProperty("PartitionID").simple("${file:name}") .convertBodyTo(String.class) .inOut("direct:source") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	
the exchange s in body as string is 

========================= camel sample_2950 =========================

for (int i = 0; i < payloads.length; i++) {	final int finalI = i;	pool.execute(new Runnable() {	public void run() {	template.sendBody(payloads[finalI]);	}	});	}	latch.await();	long end = System.currentTimeMillis();	
sending messages to took ms 

for (int i = 0; i < payloads.length; i++) {	final int finalI = i;	pool.execute(new Runnable() {	public void run() {	template.sendBody(payloads[finalI]);	}	});	}	latch.await();	long end = System.currentTimeMillis();	
sending messages to took ms 

========================= camel sample_13743 =========================

protected void assertValidContext(CamelContext context) {	assertNotNull("No context found!", context);	List<RouteDefinition> routes = ((ModelCamelContext)context).getRouteDefinitions();	
found routes 

========================= camel sample_15697 =========================

protected void doStop() throws Exception {	if (connection != null) {	for (IrcChannel channel : endpoint.getConfiguration().getChannels()) {	
parting 

protected void doStart() throws Exception {	super.doStart();	listener = getListener();	connection.addIRCEventListener(listener);	if (ObjectHelper.isNotEmpty(configuration.getNickPassword())) {	try {	
sleeping for seconds before identifying to nickserv 

protected void doStart() throws Exception {	super.doStart();	listener = getListener();	connection.addIRCEventListener(listener);	if (ObjectHelper.isNotEmpty(configuration.getNickPassword())) {	try {	Thread.sleep(5000);	} catch (InterruptedException ex) {	}	
identifying and enforcing nick with nickserv 

========================= camel sample_12152 =========================

public static ProcessDefinition getRefreshedProcessDefinition(EntityManagerTemplate entityManagerTemplate, ProcessDefinition definition) {	ObjectHelper.notNull(definition, "definition");	final Long id = definition.getId();	if (id == null) {	
no primary key is available 

========================= camel sample_12502 =========================

public final List<ApiMethodModel> parse() {	List<ApiMethodModel> result = new ArrayList<ApiMethodModel>();	for (String signature : signatures) {	if (signature.startsWith("##") || ObjectHelper.isEmpty(signature)) {	continue;	}	signature = signature.replaceAll(METHOD_PREFIX, "$4 $5(");	signature = signature.replaceAll("(\\(|,\\s*)final\\s+", "$1");	signature = signature.replaceAll("\\s*<\\s*", "<").replaceAll("\\s*>", ">");	
processing 

final int nArgsCompare = nArgs1 - model2.arguments.size();	if (nArgsCompare != 0) {	return nArgsCompare;	} else {	for (int i = 0; i < nArgs1; i++) {	final int argCompare = model1.arguments.get(i).getName().compareTo(model2.arguments.get(i).getName());	if (argCompare != 0) {	return argCompare;	}	}	
duplicate methods found 

========================= camel sample_4304 =========================

public static void beforeClass() {	
embedded zookeeper connection 

public static void beforeClass() {	
embedded kafka cluster broker list 

protected Properties getDefaultProperties() {	Properties props = new Properties();	
connecting to kafka port 

========================= camel sample_16392 =========================

public BoxFolder getRootFolder() {	try {	
getting root folder 

========================= camel sample_17429 =========================

protected void rollback(boolean isNew) throws Exception {	try {	if (isNew) {	transactionManager.rollback();	} else {	transactionManager.setRollbackOnly();	}	} catch (Throwable e) {	
could not rollback transaction 

protected void resumeTransaction(final Transaction suspendedTransaction) {	if (suspendedTransaction == null) {	return;	}	try {	transactionManager.resume(suspendedTransaction);	} catch (Throwable e) {	
could not resume transaction 

========================= camel sample_9865 =========================

public void process(Exchange exchange) throws Exception {	PutRecordRequest request = createRequest(exchange);	
sending request from exchange 

public void process(Exchange exchange) throws Exception {	PutRecordRequest request = createRequest(exchange);	PutRecordResult putRecordResult = getEndpoint().getClient().putRecord(request);	
received result 

========================= camel sample_8777 =========================

public void testLoadTestLevelDBAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.setResultWaitTime(50 * 1000);	
staring to send messages 

public void testLoadTestLevelDBAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.setResultWaitTime(50 * 1000);	for (int i = 0; i < SIZE; i++) {	final int value = 1;	HeaderDto headerDto = new HeaderDto("test", "company", 1);	char id = 'A';	
sending with id 

mock.expectedMinimumMessageCount(1);	mock.setResultWaitTime(50 * 1000);	for (int i = 0; i < SIZE; i++) {	final int value = 1;	HeaderDto headerDto = new HeaderDto("test", "company", 1);	char id = 'A';	Map<String, Object> headers = new HashMap<String, Object>();	headers.put("id", headerDto);	template.sendBodyAndHeaders("seda:start?size=" + SIZE, value, headers);	}	
sending all message done now waiting for aggregation to complete 

========================= camel sample_13893 =========================

public void execute() throws MojoExecutionException, MojoFailureException {	if (!validate) {	
validation disabled 

public void execute() throws MojoExecutionException, MojoFailureException {	if (!validate) {	} else {	final Set<File> jsonFiles = new TreeSet<File>();	PackageHelper.findJsonFiles(outDir, jsonFiles, new CamelComponentsFileFilter());	boolean failed = false;	for (File file : jsonFiles) {	final String name = asName(file);	final ErrorDetail detail = new ErrorDetail();	
validating file 

} else {	final Set<File> jsonFiles = new TreeSet<File>();	PackageHelper.findJsonFiles(outDir, jsonFiles, new CamelComponentsFileFilter());	boolean failed = false;	for (File file : jsonFiles) {	final String name = asName(file);	final ErrorDetail detail = new ErrorDetail();	validate(file, detail);	if (detail.hasErrors()) {	failed = true;	
the has validation errors 

final Set<File> jsonFiles = new TreeSet<File>();	PackageHelper.findJsonFiles(outDir, jsonFiles, new CamelComponentsFileFilter());	boolean failed = false;	for (File file : jsonFiles) {	final String name = asName(file);	final ErrorDetail detail = new ErrorDetail();	validate(file, detail);	if (detail.hasErrors()) {	failed = true;	if (detail.isMissingDescription()) {	
missing description on 

boolean failed = false;	for (File file : jsonFiles) {	final String name = asName(file);	final ErrorDetail detail = new ErrorDetail();	validate(file, detail);	if (detail.hasErrors()) {	failed = true;	if (detail.isMissingDescription()) {	}	if (detail.isMissingLabel()) {	
missing label on 

final String name = asName(file);	final ErrorDetail detail = new ErrorDetail();	validate(file, detail);	if (detail.hasErrors()) {	failed = true;	if (detail.isMissingDescription()) {	}	if (detail.isMissingLabel()) {	}	if (detail.isMissingSyntax()) {	
missing syntax on endpoint 

validate(file, detail);	if (detail.hasErrors()) {	failed = true;	if (detail.isMissingDescription()) {	}	if (detail.isMissingLabel()) {	}	if (detail.isMissingSyntax()) {	}	if (detail.isMissingUriPath()) {	
missing uripath on endpoint 

failed = true;	if (detail.isMissingDescription()) {	}	if (detail.isMissingLabel()) {	}	if (detail.isMissingSyntax()) {	}	if (detail.isMissingUriPath()) {	}	if (!detail.getMissingComponentDocumentation().isEmpty()) {	
missing component documentation for the following options t 

}	if (detail.isMissingLabel()) {	}	if (detail.isMissingSyntax()) {	}	if (detail.isMissingUriPath()) {	}	if (!detail.getMissingComponentDocumentation().isEmpty()) {	}	if (!detail.getMissingEndpointDocumentation().isEmpty()) {	
missing endpoint documentation for the following options t 

}	if (!detail.getMissingComponentDocumentation().isEmpty()) {	}	if (!detail.getMissingEndpointDocumentation().isEmpty()) {	}	}	}	if (failed) {	throw new MojoFailureException("Validating failed, see errors above!");	} else {	
validation complete 

========================= camel sample_124 =========================

public void start() throws Exception {	if (cacheExpression == null && cachePredicate == null && getCamelContext() != null) {	int maxSize = CamelContextHelper.getMaximumSimpleCacheSize(getCamelContext());	if (maxSize > 0) {	cacheExpression = LRUCacheFactory.newLRUCache(16, maxSize, false);	cachePredicate = LRUCacheFactory.newLRUCache(16, maxSize, false);	
simple language predicate expression cache size 

public void start() throws Exception {	if (cacheExpression == null && cachePredicate == null && getCamelContext() != null) {	int maxSize = CamelContextHelper.getMaximumSimpleCacheSize(getCamelContext());	if (maxSize > 0) {	cacheExpression = LRUCacheFactory.newLRUCache(16, maxSize, false);	cachePredicate = LRUCacheFactory.newLRUCache(16, maxSize, false);	} else {	
simple language disabled predicate expression cache 

========================= camel sample_5000 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<PdfComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.pdf.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.pdf.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_574 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ClientComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.iec60870-client.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.iec60870-client.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_827 =========================

public void testPollEnrichCustomAggregationStrategyBody() throws Exception {	getMockEndpoint("mock:start").expectedBodiesReceived("Start");	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceived("Big file");	mock.expectedFileExists("target/enrich/.done/AAA.fin");	mock.expectedFileExists("target/enrichdata/.done/AAA.dat");	
file log info file 

public void testPollEnrichCustomAggregationStrategyBody() throws Exception {	getMockEndpoint("mock:start").expectedBodiesReceived("Start");	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceived("Big file");	mock.expectedFileExists("target/enrich/.done/AAA.fin");	mock.expectedFileExists("target/enrichdata/.done/AAA.dat");	Thread.sleep(500);	
file log info done 

========================= camel sample_1686 =========================

public void testReceiveTraps() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMinimumMessageCount(1);	mock.assertIsSatisfied();	List<Exchange> events = mock.getExchanges();	if (LOG.isInfoEnabled()) {	for (Exchange e : events) {	
asterisk events 

========================= camel sample_12902 =========================

public void setUp() throws Exception {	
starting jetty server at port 

response.setContentType("text/xml");	response.setContentLength(RESPONSE_MESSAGE.length());	response.setStatus(HttpServletResponse.SC_OK);	baseRequest.setHandled(true);	PrintWriter pw = response.getWriter();	pw.write(RESPONSE_MESSAGE);	pw.close();	}	});	server.start();	
start routing scenario at port 

========================= camel sample_7752 =========================

public void process(Exchange exchange) throws Exception {	
cache name 

private void performCacheOperation(Exchange exchange, String operation, String key) throws Exception {	if (checkIsEqual(operation, CacheConstants.CACHE_OPERATION_URL_ADD)) {	
adding an element with key into the cache 

private void performCacheOperation(Exchange exchange, String operation, String key) throws Exception {	if (checkIsEqual(operation, CacheConstants.CACHE_OPERATION_URL_ADD)) {	Element element = createElementFromBody(key, exchange, CacheConstants.CACHE_OPERATION_ADD);	cache.put(element);	} else if (checkIsEqual(operation, CacheConstants.CACHE_OPERATION_URL_UPDATE)) {	
updating an element with key into the cache 

private void performCacheOperation(Exchange exchange, String operation, String key) throws Exception {	if (checkIsEqual(operation, CacheConstants.CACHE_OPERATION_URL_ADD)) {	Element element = createElementFromBody(key, exchange, CacheConstants.CACHE_OPERATION_ADD);	cache.put(element);	} else if (checkIsEqual(operation, CacheConstants.CACHE_OPERATION_URL_UPDATE)) {	Element element = createElementFromBody(key, exchange, CacheConstants.CACHE_OPERATION_UPDATE);	cache.put(element);	} else if (checkIsEqual(operation, CacheConstants.CACHE_OPERATION_URL_DELETEALL)) {	
deleting all elements from the cache 

private void performCacheOperation(Exchange exchange, String operation, String key) throws Exception {	if (checkIsEqual(operation, CacheConstants.CACHE_OPERATION_URL_ADD)) {	Element element = createElementFromBody(key, exchange, CacheConstants.CACHE_OPERATION_ADD);	cache.put(element);	} else if (checkIsEqual(operation, CacheConstants.CACHE_OPERATION_URL_UPDATE)) {	Element element = createElementFromBody(key, exchange, CacheConstants.CACHE_OPERATION_UPDATE);	cache.put(element);	} else if (checkIsEqual(operation, CacheConstants.CACHE_OPERATION_URL_DELETEALL)) {	cache.removeAll();	} else if (checkIsEqual(operation, CacheConstants.CACHE_OPERATION_URL_DELETE)) {	
deleting an element with key into the cache 

Element element = createElementFromBody(key, exchange, CacheConstants.CACHE_OPERATION_ADD);	cache.put(element);	} else if (checkIsEqual(operation, CacheConstants.CACHE_OPERATION_URL_UPDATE)) {	Element element = createElementFromBody(key, exchange, CacheConstants.CACHE_OPERATION_UPDATE);	cache.put(element);	} else if (checkIsEqual(operation, CacheConstants.CACHE_OPERATION_URL_DELETEALL)) {	cache.removeAll();	} else if (checkIsEqual(operation, CacheConstants.CACHE_OPERATION_URL_DELETE)) {	cache.remove(key);	} else if (checkIsEqual(operation, CacheConstants.CACHE_OPERATION_URL_GET)) {	
quering an element with key from the cache 

cache.remove(key);	} else if (checkIsEqual(operation, CacheConstants.CACHE_OPERATION_URL_GET)) {	Element element = cache.get(key);	if (element != null) {	exchange.getIn().setHeader(CacheConstants.CACHE_ELEMENT_WAS_FOUND, true);	exchange.getIn().setBody(element.getObjectValue());	} else {	exchange.getIn().removeHeader(CacheConstants.CACHE_ELEMENT_WAS_FOUND);	}	} else if (checkIsEqual(operation, CacheConstants.CACHE_OPERATION_URL_CHECK)) {	
querying an element with key from the cache 

========================= camel sample_10529 =========================

public void setUp() throws Exception {	log.info("*******************************************************************");	
test 

========================= camel sample_12514 =========================

protected abstract Trigger createTrigger(Action action, Route route) throws Exception;	protected void onJobExecute(Action action, Route route) throws Exception {	
scheduled event notification received performing action on route 

if (action == Action.START) {	if (routeStatus == ServiceStatus.Stopped) {	startRoute(route);	} else if (ServiceHelper.isSuspended(route.getConsumer())) {	resumeOrStartConsumer(route.getConsumer());	}	} else if (action == Action.STOP) {	if ((routeStatus == ServiceStatus.Started) || (routeStatus == ServiceStatus.Suspended)) {	stopRoute(route, getRouteStopGracePeriod(), getTimeUnit());	} else {	
route is not in a started suspended state and cannot be stopped the current route state is 

}	} else if (action == Action.STOP) {	if ((routeStatus == ServiceStatus.Started) || (routeStatus == ServiceStatus.Suspended)) {	stopRoute(route, getRouteStopGracePeriod(), getTimeUnit());	} else {	}	} else if (action == Action.SUSPEND) {	if (routeStatus == ServiceStatus.Started) {	suspendOrStopConsumer(route.getConsumer());	} else {	
route is not in a started state and cannot be suspended the current route state is 

} else if (action == Action.SUSPEND) {	if (routeStatus == ServiceStatus.Started) {	suspendOrStopConsumer(route.getConsumer());	} else {	}	} else if (action == Action.RESUME) {	if (routeStatus == ServiceStatus.Started) {	if (ServiceHelper.isSuspended(route.getConsumer())) {	resumeOrStartConsumer(route.getConsumer());	} else {	
the consumer is not suspended and cannot be resumed 

suspendOrStopConsumer(route.getConsumer());	} else {	}	} else if (action == Action.RESUME) {	if (routeStatus == ServiceStatus.Started) {	if (ServiceHelper.isSuspended(route.getConsumer())) {	resumeOrStartConsumer(route.getConsumer());	} else {	}	} else {	
route is not in a started state and cannot be resumed the current route state is 

public void scheduleRoute(Action action, Route route) throws Exception {	JobDetail jobDetail = createJobDetail(action, route);	Trigger trigger = createTrigger(action, route);	updateScheduledRouteDetails(action, jobDetail, trigger, route);	loadCallbackDataIntoSchedulerContext(jobDetail, action, route);	boolean isClustered = route.getRouteContext().getCamelContext().getComponent("quartz2", QuartzComponent.class).isClustered();	if (isClustered) {	JobDetail existingJobDetail = getScheduler().getJobDetail(jobDetail.getKey());	if (jobDetail.equals(existingJobDetail)) {	if (LOG.isInfoEnabled()) {	
skipping to schedule the job for action on route as the job already existing inside the cluster 

if (isClustered) {	JobDetail existingJobDetail = getScheduler().getJobDetail(jobDetail.getKey());	if (jobDetail.equals(existingJobDetail)) {	if (LOG.isInfoEnabled()) {	}	return;	}	}	getScheduler().scheduleJob(jobDetail, trigger);	if (LOG.isInfoEnabled()) {	
scheduled trigger for action on route 

public void pauseRouteTrigger(Action action, String routeId) throws SchedulerException {	TriggerKey triggerKey = retrieveTriggerKey(action, routeId);	getScheduler().pauseTrigger(triggerKey);	
scheduled trigger is paused 

public void resumeRouteTrigger(Action action, String routeId) throws SchedulerException {	TriggerKey triggerKey = retrieveTriggerKey(action, routeId);	getScheduler().resumeTrigger(triggerKey);	
scheduled trigger is resumed 

public void deleteRouteJob(Action action, ScheduledRouteDetails scheduledRouteDetails) throws SchedulerException {	JobKey jobKey = retrieveJobKey(action, scheduledRouteDetails);	if (!getScheduler().isShutdown()) {	getScheduler().deleteJob(jobKey);	}	
scheduled job is deleted 

========================= camel sample_14993 =========================

public void prepareShutdown(boolean suspendOnly, boolean forced) {	if (suspendOnly) {	
skip preparing to shutdown as consumer is being suspended 

public void prepareShutdown(boolean suspendOnly, boolean forced) {	if (suspendOnly) {	return;	}	shutdownPending = true;	forceShutdown = forced;	if (latch != null) {	
preparing to shutdown waiting for consumer threads to complete 

public void run() {	taskCount.incrementAndGet();	try {	doRun();	} finally {	taskCount.decrementAndGet();	latch.countDown();	
ending this polling consumer thread there are still consumer threads left 

protected void doRun() {	BlockingQueue<Exchange> queue = endpoint.getQueue();	while (queue != null && isRunAllowed()) {	if (getEndpoint().getCamelContext().getStatus().isStarting()) {	
camelcontext is starting so skip polling 

protected void doRun() {	BlockingQueue<Exchange> queue = endpoint.getQueue();	while (queue != null && isRunAllowed()) {	if (getEndpoint().getCamelContext().getStatus().isStarting()) {	try {	Thread.sleep(Math.min(pollTimeout, 1000));	} catch (InterruptedException e) {	
sleep interrupted are we stopping 

while (queue != null && isRunAllowed()) {	if (getEndpoint().getCamelContext().getStatus().isStarting()) {	try {	Thread.sleep(Math.min(pollTimeout, 1000));	} catch (InterruptedException e) {	}	continue;	}	if (isSuspending() || isSuspended() || isStarting()) {	if (shutdownPending && queue.isEmpty()) {	
consumer is suspended and shutdown is pending so this consumer thread is breaking out because the task queue is empty 

try {	Thread.sleep(Math.min(pollTimeout, 1000));	} catch (InterruptedException e) {	}	continue;	}	if (isSuspending() || isSuspended() || isStarting()) {	if (shutdownPending && queue.isEmpty()) {	break;	} else {	
consumer is suspended so skip polling 

}	continue;	}	if (isSuspending() || isSuspended() || isStarting()) {	if (shutdownPending && queue.isEmpty()) {	break;	} else {	try {	Thread.sleep(Math.min(pollTimeout, 1000));	} catch (InterruptedException e) {	
sleep interrupted are we stopping 

Thread.sleep(Math.min(pollTimeout, 1000));	} catch (InterruptedException e) {	}	continue;	}	}	Exchange exchange = null;	try {	exchange = queue.poll(pollTimeout, TimeUnit.MILLISECONDS);	if (LOG.isTraceEnabled()) {	
polled queue with timeout ms 

exchange.setIn(newExchange.getIn());	}	if (newExchange.getException() != null) {	exchange.setException(newExchange.getException());	getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException());	}	} catch (Exception e) {	getExceptionHandler().handleException("Error processing exchange", exchange, e);	}	} else if (shutdownPending && queue.isEmpty()) {	
shutdown is pending so this consumer thread is breaking out because the task queue is empty 

exchange.setException(newExchange.getException());	getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException());	}	} catch (Exception e) {	getExceptionHandler().handleException("Error processing exchange", exchange, e);	}	} else if (shutdownPending && queue.isEmpty()) {	break;	}	} catch (InterruptedException e) {	
sleep interrupted are we stopping 

protected void sendToConsumers(final Exchange exchange) throws Exception {	int size = endpoint.getConsumers().size();	if (size > 1 && !endpoint.isMultipleConsumersSupported()) {	throw new IllegalStateException("Multiple consumers for the same endpoint is not allowed: " + endpoint);	}	if (endpoint.isMultipleConsumersSupported()) {	if (LOG.isTraceEnabled()) {	
multicasting to consumers for exchange 

private void setupTasks() {	int poolSize = endpoint.getConcurrentConsumers();	if (executor == null) {	executor = endpoint.getCamelContext().getExecutorServiceManager().newFixedThreadPool(this, endpoint.getEndpointUri(), poolSize);	}	int tasks = poolSize - taskCount.get();	
creating consumer tasks with poll timeout ms 

========================= camel sample_4892 =========================

public void beforeGoToNextStep(Exchange exchange) {	Assert.assertNotNull(exchange);	
calling beforegotonextstep 

public void goToNextStep() {	setStep(getStep() + 1);	
invoked the completion complete method now updated the step to 

========================= camel sample_14090 =========================

config.timeBetweenEvictionRunsMillis = 30 * 1000L;	config.minEvictableIdleTimeMillis = configuration.getProducerPoolMinEvictableIdle();	config.whenExhaustedAction = GenericObjectPool.WHEN_EXHAUSTED_FAIL;	pool = new GenericObjectPool<ChannelFuture>(new NettyProducerPoolableObjectFactory(), config);	if (LOG.isDebugEnabled()) {	LOG.debug("Created NettyProducer pool[maxActive={}, minIdle={}, maxIdle={}, minEvictableIdleTimeMillis={}] -> {}", new Object[]{config.maxActive, config.minIdle, config.maxIdle, config.minEvictableIdleTimeMillis, pool});	}	} else {	pool = new SharedSingletonObjectPool<ChannelFuture>(new NettyProducerPoolableObjectFactory());	if (LOG.isDebugEnabled()) {	
created nettyproducer shared singleton pool 

protected void doStop() throws Exception {	
stopping producer at address 

protected void doStop() throws Exception {	
closing channels 

}	ChannelFuture channelFuture = null;	Channel channel = null;	try {	if (getConfiguration().isReuseChannel()) {	channel = exchange.getProperty(NettyConstants.NETTY_CHANNEL, Channel.class);	}	if (channel == null) {	channelFuture = pool.borrowObject();	if (channelFuture != null) {	
got channel request from pool 

if (ExchangeHelper.isOutCapable(exchange)) {	close = exchange.getOut().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);	} else {	close = exchange.getIn().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);	}	boolean disconnect = getConfiguration().isDisconnect();	if (close != null) {	disconnect = close;	}	if (disconnect) {	
closing channel as routing the exchange is done 

} else {	producerCallback = new NettyProducerCallback(channelFuture, callback.getOriginalCallback());	}	putState(channel, new NettyCamelState(producerCallback, exchange));	InetSocketAddress remoteAddress = null;	if (!isTcp()) {	remoteAddress = new InetSocketAddress(configuration.getHost(), configuration.getPort());	}	NettyHelper.writeBodyAsync(LOG, channel, remoteAddress, body, exchange, new ChannelFutureListener() {	public void operationComplete(ChannelFuture channelFuture) throws Exception {	
operation complete 

close = exchange.getOut().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);	} else {	close = exchange.getIn().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);	}	boolean disconnect = getConfiguration().isDisconnect();	if (close != null) {	disconnect = close;	}	if (!configuration.isReuseChannel() && disconnect) {	if (LOG.isTraceEnabled()) {	
closing channel when complete at address 

clientBootstrap.option(ChannelOption.TCP_NODELAY, configuration.isTcpNoDelay());	clientBootstrap.option(ChannelOption.SO_REUSEADDR, configuration.isReuseAddress());	clientBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, configuration.getConnectTimeout());	if (configuration.getOptions() != null) {	for (Map.Entry<String, Object> entry : configuration.getOptions().entrySet()) {	clientBootstrap.setOption(entry.getKey(), entry.getValue());	}	}*/ clientBootstrap.handler(pipelineFactory);	answer = clientBootstrap.connect(new InetSocketAddress(configuration.getHost(), configuration.getPort()));	if (LOG.isDebugEnabled()) {	
created new tcp client bootstrap connecting to with options 

}	}*/ connectionlessClientBootstrap.handler(pipelineFactory);	if (!configuration.isUdpConnectionlessSending()) {	answer = connectionlessClientBootstrap.connect(new InetSocketAddress(configuration.getHost(), configuration.getPort()));	} else {	answer = connectionlessClientBootstrap.bind(new InetSocketAddress(0)).sync();	Channel channel = answer.channel();	allChannels.add(channel);	}	if (LOG.isDebugEnabled()) {	
created new udp client bootstrap connecting to with options 

protected void notifyChannelOpen(ChannelFuture channelFuture) throws Exception {	if (LOG.isTraceEnabled()) {	
channel open finished with 

protected void notifyChannelOpen(ChannelFuture channelFuture) throws Exception {	if (LOG.isTraceEnabled()) {	}	if (channelFuture.isSuccess()) {	Channel answer = channelFuture.channel();	allChannels.add(answer);	if (LOG.isDebugEnabled()) {	
creating connector to address 

protected void releaseChannel(ChannelFuture channelFuture) {	Channel channel = channelFuture.channel();	try {	if (channel.isActive()) {	
putting channel back to pool 

protected void releaseChannel(ChannelFuture channelFuture) {	Channel channel = channelFuture.channel();	try {	if (channel.isActive()) {	pool.returnObject(channelFuture);	} else {	
invalidating channel from pool 

protected void releaseChannel(ChannelFuture channelFuture) {	Channel channel = channelFuture.channel();	try {	if (channel.isActive()) {	pool.returnObject(channelFuture);	} else {	pool.invalidateObject(channelFuture);	}	} catch (Exception e) {	
error returning channel to pool this exception will be ignored 

public ChannelFuture makeObject() throws Exception {	ChannelFuture channelFuture = openConnection().addListener(new ChannelFutureListener() {	public void operationComplete(ChannelFuture future) throws Exception {	notifyChannelOpen(future);	}	});	
requested channel 

public void destroyObject(ChannelFuture channelFuture) throws Exception {	
destroying channel request 

public boolean validateObject(ChannelFuture channelFuture) {	if (!channelFuture.isDone()) {	
validating connecting channel request 

public boolean validateObject(ChannelFuture channelFuture) {	if (!channelFuture.isDone()) {	return true;	}	if (!channelFuture.isSuccess()) {	
validating unsuccessful channel request 

public boolean validateObject(ChannelFuture channelFuture) {	if (!channelFuture.isDone()) {	return true;	}	if (!channelFuture.isSuccess()) {	return false;	}	Channel channel = channelFuture.channel();	boolean answer = channel.isActive();	
validating channel 

public void activateObject(ChannelFuture channelFuture) throws Exception {	
activateobject channel request 

public void passivateObject(ChannelFuture channelFuture) throws Exception {	
passivateobject channel request 

========================= camel sample_10250 =========================

interceptPropertyNames(arguments);	candidates = new ArrayList<>();	candidates.addAll(methodHelper.getCandidateMethods(methodName, arguments));	candidates = Collections.unmodifiableList(candidates);	if (candidates.isEmpty()) {	throw new IllegalArgumentException( String.format("No matching method for %s/%s, with arguments %s", apiName.getName(), methodName, arguments));	}	if (log.isDebugEnabled()) {	final Set<String> missing = methodHelper.getMissingProperties(methodName, arguments);	if (!missing.isEmpty()) {	
method could use one or more properties from 

========================= camel sample_4312 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ElasticsearchComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.elasticsearch5.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.elasticsearch5.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1110 =========================

count = endpoint.getProperties().getCount();	}	if (ObjectHelper.isNotEmpty(count)) {	query.setCount(count);	}	Integer numberOfPages = exchange.getIn().getHeader(TwitterConstants.TWITTER_NUMBER_OF_PAGES, Integer.class);	if (numberOfPages == null) {	numberOfPages = endpoint.getProperties().getNumberOfPages();	}	Twitter twitter = endpoint.getProperties().getTwitter();	
searching twitter with keywords 

if (numberOfPages == null) {	numberOfPages = endpoint.getProperties().getNumberOfPages();	}	Twitter twitter = endpoint.getProperties().getTwitter();	QueryResult results = twitter.search(query);	List<Status> list = results.getTweets();	for (int i = 1; i < numberOfPages; i++) {	if (!results.hasNext()) {	break;	}	
fetching page 

========================= camel sample_14213 =========================

public void testBatchLifecycle(BatchTest request) throws Exception {	
testing batch lifecycle with content 

BatchInfo batchInfo  = template().requestBodyAndHeaders("direct:createBatch", request.stream, headers, BatchInfo.class);	assertNotNull("Null batch", batchInfo);	assertNotNull("Null batch id", batchInfo.getId());	List<BatchInfo> batches = template().requestBody("direct:getAllBatches", jobInfo, List.class);	assertNotNull("Null batches", batches);	assertFalse("Empty batch list", batches.isEmpty());	batchInfo = batches.get(0);	batchInfo = getBatchInfo(batchInfo);	InputStream requestStream  = template().requestBody("direct:getRequest", batchInfo, InputStream.class);	assertNotNull("Null batch request", requestStream);	
waiting for batch to finish 

assertNotNull("Null batches", batches);	assertFalse("Empty batch list", batches.isEmpty());	batchInfo = batches.get(0);	batchInfo = getBatchInfo(batchInfo);	InputStream requestStream  = template().requestBody("direct:getRequest", batchInfo, InputStream.class);	assertNotNull("Null batch request", requestStream);	while (!batchProcessed(batchInfo)) {	Thread.sleep(5000);	batchInfo = getBatchInfo(batchInfo);	}	
batch finished with state 

========================= camel sample_14706 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<JacksonXMLDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.jacksonxml.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.jacksonxml.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_1055 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<ZipDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.zip.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.zip.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_831 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KubernetesServicesComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-services.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-services.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_562 =========================

private int getMbeanCount(final String name) throws MalformedObjectNameException {	MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();	Set<ObjectInstance> mbeans = mbs.queryMBeans(new ObjectName("org.apache.camel:type=threadpools,*"), null);	
mbeans size 

private int getMbeanCount(final String name) throws MalformedObjectNameException {	MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();	Set<ObjectInstance> mbeans = mbs.queryMBeans(new ObjectName("org.apache.camel:type=threadpools,*"), null);	int count = 0;	for (ObjectInstance mbean : mbeans) {	
mbean 

========================= camel sample_12328 =========================

if (listener != null) {	listener.onEviction(key);	}	} catch (Throwable e) {	}	final Runnable task = new Runnable() {	public void run() {	try {	value.onTimeout(key);	} catch (Throwable e) {	
error processing ontimeout for correlationid due this exception is ignored 

value.onTimeout(key);	} catch (Throwable e) {	}	}	};	if (executorService != null) {	executorService.submit(task);	} else {	task.run();	}	
evicted correlationid 

listener.onPut(key);	}	} catch (Throwable e) {	}	ReplyHandler result;	if (timeoutMillis <= 0) {	result = super.put(key, value, Integer.MAX_VALUE);	} else {	result = super.put(key, value, timeoutMillis);	}	
added correlationid to timeout after millis 

}	} catch (Throwable e) {	}	ReplyHandler result;	if (timeoutMillis <= 0) {	result = super.putIfAbsent(key, value, Integer.MAX_VALUE);	} else {	result = super.putIfAbsent(key, value, timeoutMillis);	}	if (result == null) {	
added correlationid to timeout after millis 

} catch (Throwable e) {	}	ReplyHandler result;	if (timeoutMillis <= 0) {	result = super.putIfAbsent(key, value, Integer.MAX_VALUE);	} else {	result = super.putIfAbsent(key, value, timeoutMillis);	}	if (result == null) {	} else {	
duplicate correlationid detected 

========================= camel sample_7181 =========================

public void onComplete(Exchange exchange) {	try {	
Committing 

public void onComplete(Exchange exchange) {	try {	session.commit();	} catch (JMSException ex) {	
exception caught while committing jms session 

public void onFailure(Exchange exchange) {	try {	
rolling back 

public void onFailure(Exchange exchange) {	try {	session.rollback();	} catch (JMSException ex) {	
exception caught while rolling back jms session 

========================= camel sample_12406 =========================

protected void debugBefore(Exchange exchange, Processor processor, ProcessorDefinition<?> definition, String id, String shortName) {	
before with body 

========================= camel sample_6817 =========================

public void execute(Exchange exchange) throws SmppException {	byte[] message = getShortMessage(exchange.getIn());	ReplaceSm replaceSm = createReplaceSmTempate(exchange);	replaceSm.setShortMessage(message);	if (log.isDebugEnabled()) {	
sending replacement command for a short message for exchange id and message id 

ReplaceSm replaceSm = createReplaceSmTempate(exchange);	replaceSm.setShortMessage(message);	if (log.isDebugEnabled()) {	}	try {	session.replaceShortMessage( replaceSm.getMessageId(), TypeOfNumber.valueOf(replaceSm.getSourceAddrTon()), NumberingPlanIndicator.valueOf(replaceSm.getSourceAddrNpi()), replaceSm.getSourceAddr(), replaceSm.getScheduleDeliveryTime(), replaceSm.getValidityPeriod(), new RegisteredDelivery(replaceSm.getRegisteredDelivery()), replaceSm.getSmDefaultMsgId(), replaceSm.getShortMessage());	} catch (Exception e) {	throw new SmppException(e);	}	if (log.isDebugEnabled()) {	
sent replacement command for a short message for exchange id and message id 

========================= camel sample_16916 =========================

if (endpoint == null) {	continue;	}	} catch (Exception e) {	current.setException(e);	break;	}	boolean sync = processExchange(endpoint, current, exchange, originalCallback, iter);	current = prepareExchangeForRoutingSlip(current, endpoint);	if (!sync) {	
processing exchangeid is continued being processed asynchronously 

}	} catch (Exception e) {	current.setException(e);	break;	}	boolean sync = processExchange(endpoint, current, exchange, originalCallback, iter);	current = prepareExchangeForRoutingSlip(current, endpoint);	if (!sync) {	return false;	}	
processing exchangeid is continued being processed synchronously 

}	boolean sync = processExchange(endpoint, current, exchange, originalCallback, iter);	current = prepareExchangeForRoutingSlip(current, endpoint);	if (!sync) {	return false;	}	if (isIgnoreInvalidEndpoints()) {	FailedToCreateProducerException e = current.getException(FailedToCreateProducerException.class);	if (e != null) {	if (log.isDebugEnabled()) {	
endpoint uri is invalid this exception will be ignored 

if (e != null) {	if (log.isDebugEnabled()) {	}	current.setException(null);	}	}	if (!continueProcessing(current, "so breaking out of the routing slip", log)) {	break;	}	}	
processing complete for exchangeid 

protected Endpoint resolveEndpoint(RoutingSlipIterator iter, Exchange exchange) throws Exception {	Object nextRecipient = iter.next(exchange);	Endpoint endpoint = null;	try {	endpoint = ExchangeHelper.resolveEndpoint(exchange, nextRecipient);	} catch (Exception e) {	if (isIgnoreInvalidEndpoints()) {	
endpoint uri is invalid this exception will be ignored 

protected boolean processExchange(final Endpoint endpoint, final Exchange exchange, final Exchange original, final AsyncCallback originalCallback, final RoutingSlipIterator iter) {	
processing exchangeid 

callback.done(true);	return;	}	try {	Exchange current = prepareExchangeForRoutingSlip(exchange, endpoint);	while (iter.hasNext(current)) {	if (isIgnoreInvalidEndpoints()) {	FailedToCreateProducerException e = current.getException(FailedToCreateProducerException.class);	if (e != null) {	if (log.isDebugEnabled()) {	
endpoint uri is invalid this exception will be ignored 

if (endpoint == null) {	continue;	}	} catch (Exception e) {	exchange.setException(e);	break;	}	boolean sync = processExchange(endpoint, current, original, callback, iter);	current = prepareExchangeForRoutingSlip(current, endpoint);	if (!sync) {	
processing exchangeid is continued being processed asynchronously 

} catch (Exception e) {	exchange.setException(e);	break;	}	boolean sync = processExchange(endpoint, current, original, callback, iter);	current = prepareExchangeForRoutingSlip(current, endpoint);	if (!sync) {	return;	}	}	
processing complete for exchangeid 

protected void doStart() throws Exception {	if (producerCache == null) {	if (cacheSize < 0) {	producerCache = new EmptyProducerCache(this, camelContext);	
routingslip is not using producercache 

protected void doStart() throws Exception {	if (producerCache == null) {	if (cacheSize < 0) {	producerCache = new EmptyProducerCache(this, camelContext);	} else if (cacheSize == 0) {	producerCache = new ProducerCache(this, camelContext);	
routingslip using producercache with default cache size 

========================= camel sample_4579 =========================

protected synchronized void doWrite(String event) throws IOException {	
writing event to splunk 

========================= camel sample_14478 =========================

if (qoSValue != null) {	qoS = MQTTConfiguration.getQoS(qoSValue.toString());	}	String topicName = configuration.getPublishTopicName();	Object topicValue = exchange.getIn().getHeader(MQTTConfiguration.MQTT_PUBLISH_TOPIC);	if (topicValue != null) {	topicName = topicValue.toString();	}	final String name = topicName;	try {	
publishing to 

}	String topicName = configuration.getPublishTopicName();	Object topicValue = exchange.getIn().getHeader(MQTTConfiguration.MQTT_PUBLISH_TOPIC);	if (topicValue != null) {	topicName = topicValue.toString();	}	final String name = topicName;	try {	mqttEndpoint.publish(name, body, qoS, retain, new Callback<Void>() {	public void onSuccess(Void aVoid) {	
onsuccess from 

if (topicValue != null) {	topicName = topicValue.toString();	}	final String name = topicName;	try {	mqttEndpoint.publish(name, body, qoS, retain, new Callback<Void>() {	public void onSuccess(Void aVoid) {	callback.done(false);	}	public void onFailure(Throwable throwable) {	
onfailure from 

callback.done(false);	}	});	} catch (Exception e) {	exchange.setException(e);	callback.done(true);	return true;	}	return false;	} else {	
no data to publish 

========================= camel sample_16853 =========================

private void start() throws IOException {	int port = 8080;	server = ServerBuilder.forPort(port).addService(new HelloCamelImpl()).build().start();	
server started i m listening on 

========================= camel sample_17741 =========================

public void handleResponse(Map<String, Object> ctx, Object[] res) {	try {	super.handleResponse(ctx, res);	} finally {	if (endpoint.getCookieHandler() != null) {	try {	Map<String, List<String>> cxfHeaders = CastUtils.cast((Map<?, ?>)cxfExchange.getInMessage().get(Message.PROTOCOL_HEADERS));	endpoint.getCookieHandler().storeCookies(camelExchange, endpoint.getRequestUri(camelExchange), cxfHeaders);	} catch (IOException e) {	
cannot store cookies 

Map<String, List<String>> cxfHeaders = CastUtils.cast((Map<?, ?>)cxfExchange.getInMessage().get(Message.PROTOCOL_HEADERS));	endpoint.getCookieHandler().storeCookies(camelExchange, endpoint.getRequestUri(camelExchange), cxfHeaders);	} catch (IOException e) {	}	}	if (!boi.getOperationInfo().isOneWay()) {	endpoint.getCxfBinding().populateExchangeFromCxfResponse(camelExchange, cxfExchange, ctx);	camelAsyncCallback.done(false);	}	if (LOG.isDebugEnabled()) {	
calling handleresponse 

}	} else {	camelExchange.setException(ex);	}	} finally {	if (endpoint.getCookieHandler() != null) {	try {	Map<String, List<String>> cxfHeaders = CastUtils.cast((Map<?, ?>)cxfExchange.getInMessage().get(Message.PROTOCOL_HEADERS));	endpoint.getCookieHandler().storeCookies(camelExchange, endpoint.getRequestUri(camelExchange), cxfHeaders);	} catch (IOException e) {	
cannot store cookies 

Map<String, List<String>> cxfHeaders = CastUtils.cast((Map<?, ?>)cxfExchange.getInMessage().get(Message.PROTOCOL_HEADERS));	endpoint.getCookieHandler().storeCookies(camelExchange, endpoint.getRequestUri(camelExchange), cxfHeaders);	} catch (IOException e) {	}	}	if (!boi.getOperationInfo().isOneWay()) {	endpoint.getCxfBinding().populateExchangeFromCxfResponse(camelExchange, cxfExchange, ctx);	camelAsyncCallback.done(false);	}	if (LOG.isDebugEnabled()) {	
calling handleexception 

========================= camel sample_7990 =========================

public String parseProperty(String key, String value, Properties properties) {	log.trace(format("Parsing property '%s=%s'", key, value));	if (value != null) {	initEncryptor();	Matcher matcher = PATTERN.matcher(value);	while (matcher.find()) {	
decrypting part s 

private synchronized void initEncryptor() {	if (encryptor == null) {	ObjectHelper.notEmpty("password", password);	StandardPBEStringEncryptor pbeStringEncryptor = new StandardPBEStringEncryptor();	pbeStringEncryptor.setPassword(password);	if (algorithm != null) {	pbeStringEncryptor.setAlgorithm(algorithm);	
initialized encryptor using s algorithm and provided password 

private synchronized void initEncryptor() {	if (encryptor == null) {	ObjectHelper.notEmpty("password", password);	StandardPBEStringEncryptor pbeStringEncryptor = new StandardPBEStringEncryptor();	pbeStringEncryptor.setPassword(password);	if (algorithm != null) {	pbeStringEncryptor.setAlgorithm(algorithm);	} else {	
initialized encryptor using default algorithm and provided password 

========================= camel sample_14614 =========================

public void onFailure(Exchange exchange) {	
callback onfailure 

public void onComplete(Exchange exchange) {	
callback oncomplete 

public void cleanup() {	
latch countdown count was 

public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {	String destinationName = messageSend.getDestination().getPhysicalName();	
received message for destination 

public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {	String destinationName = messageSend.getDestination().getPhysicalName();	if (destinationName.toLowerCase().contains("test") && i == 0) {	Thread.sleep(2000);	
waited seconds for destination 

========================= camel sample_7093 =========================

public void connect(WebsocketConsumer consumer) {	
connecting consumer 

public void disconnect(WebsocketConsumer consumer) {	
disconnecting consumer 

public DefaultWebsocket doWebSocketConnect(ServletUpgradeRequest request, String protocol) {	String protocolKey = protocol;	if (protocol == null || !socketFactory.containsKey(protocol)) {	
no factory found for the socket protocol returning default implementation 

========================= camel sample_17468 =========================

protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {	synchronized (endpoints) {	Endpoint endpoint = endpoints.get(uri);	if (endpoint == null) {	endpoint = new TradeExecutorEndpoint(uri, new TradeExecutor());	endpoints.put(uri, (TradeExecutorEndpoint) endpoint);	
created trade executor 

public Producer createProducer() throws Exception {	return new DefaultProducer(this) {	public void process(final Exchange exchange) throws Exception {	executor.execute(new Runnable() {	public void run() {	try {	tradeExecutor.execute(exchange.getIn().getMandatoryBody(Message.class));	} catch (Exception e) {	
error during trade execution 

========================= camel sample_10657 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<StreamComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.stream.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.stream.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_470 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KubernetesComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_535 =========================

protected void onExchange(Exchange exchange) throws Exception {	String path = getResourceUri();	ObjectHelper.notNull(path, "resourceUri");	String newResourceUri = exchange.getIn().getHeader(MvelConstants.MVEL_RESOURCE_URI, String.class);	if (newResourceUri != null) {	exchange.getIn().removeHeader(MvelConstants.MVEL_RESOURCE_URI);	
set to creating new endpoint to handle exchange 

MvelEndpoint newEndpoint = findOrCreateEndpoint(getEndpointUri(), newResourceUri);	newEndpoint.onExchange(exchange);	return;	}	CompiledTemplate compiled;	ParserContext mvelContext = ParserContext.create();	Map<String, Object> variableMap = ExchangeHelper.createVariableMap(exchange);	String content = exchange.getIn().getHeader(MvelConstants.MVEL_TEMPLATE, String.class);	if (content != null) {	if (log.isDebugEnabled()) {	
mvel content read from header for endpoint 

ParserContext mvelContext = ParserContext.create();	Map<String, Object> variableMap = ExchangeHelper.createVariableMap(exchange);	String content = exchange.getIn().getHeader(MvelConstants.MVEL_TEMPLATE, String.class);	if (content != null) {	if (log.isDebugEnabled()) {	}	exchange.getIn().removeHeader(MvelConstants.MVEL_TEMPLATE);	compiled = TemplateCompiler.compileTemplate(content, mvelContext);	} else {	if (log.isDebugEnabled()) {	
mvel content read from resource with resourceuri for endpoint 

if (log.isDebugEnabled()) {	}	Reader reader = getEncoding() != null ? new InputStreamReader(getResourceAsInputStream(), getEncoding()) : new InputStreamReader(getResourceAsInputStream());	String template = IOConverter.toString(reader);	if (!template.equals(this.template)) {	this.template = template;	this.compiled = TemplateCompiler.compileTemplate(template, mvelContext);	}	compiled = this.compiled;	}	
mvel is evaluating using mvel context 

public MvelEndpoint findOrCreateEndpoint(String uri, String newResourceUri) {	String newUri = uri.replace(getResourceUri(), newResourceUri);	
getting endpoint with uri 

========================= camel sample_8389 =========================

protected int poll() throws Exception {	Exchange exchange = super.getEndpoint().createExchange();	try {	
getting the blob content 

========================= camel sample_9961 =========================

getEndpointProperties(endpoint.getConfiguration(), properties);	final FacebookMethodsType method = findMethod(exchange, properties);	if (method == null) {	callback.done(true);	return true;	}	Runnable invocation = new Runnable() {	public void run() {	try {	if (LOG.isDebugEnabled()) {	
invoking method with 

if (processInBody(exchange, properties)) {	final Set<String> argNames = properties.keySet();	final List<FacebookMethodsType> filteredMethods = filterMethods(candidates, MatchType.SUPER_SET, argNames.toArray(new String[argNames.size()]));	if (filteredMethods.isEmpty()) {	final Set<String> missing = getMissingProperties(endpoint.getMethod(), endpoint.getNameStyle(), argNames);	throw new RuntimeCamelException(String.format("Missing properties for %s, need one or more from %s", endpoint.getMethod(), missing));	} else if (filteredMethods.size() == 1) {	method = filteredMethods.get(0);	} else {	method = FacebookMethodsTypeHelper.getHighestPriorityMethod(filteredMethods);	
calling highest priority method from methods 

private boolean processInBody(Exchange exchange, Map<String, Object> properties) {	final String inBodyProperty = endpoint.getInBody();	if (inBodyProperty != null) {	Object value = exchange.getIn().getBody();	try {	value = getEndpoint().getCamelContext().getTypeConverter().mandatoryConvertTo( FacebookEndpointConfiguration.class.getDeclaredField(inBodyProperty).getType(), exchange, value);	} catch (Exception e) {	exchange.setException(new RuntimeCamelException(String.format( "Error converting value %s to property %s: %s", value, inBodyProperty, e.getMessage()), e));	return false;	}	
property has message body value 

========================= camel sample_9598 =========================

public void testUndertow() throws Exception {	MockEndpoint mockEndpoint = getMockEndpoint("mock:myapp");	mockEndpoint.expectedHeaderReceived(Exchange.HTTP_METHOD, "POST");	
number of exchanges in mock myapp 

========================= camel sample_13094 =========================

private void processApexCall(final Exchange exchange, final AsyncCallback callback) throws SalesforceException {	final String apexUrl = getApexUrl(exchange);	String apexMethod = getParameter(APEX_METHOD, exchange, IGNORE_BODY, IS_OPTIONAL);	if (apexMethod == null) {	apexMethod = "GET";	
using http get method by default for apex rest call for 

}	try {	result.append(URLEncoder.encode(String.valueOf(value), "UTF-8").replaceAll("\\+", "%20"));	} catch (UnsupportedEncodingException e) {	throw new SalesforceException("Unexpected error: " + e.getMessage(), e);	}	}	if (start != 0) {	result.append(apexUrl.substring(start));	final String resolvedUrl = result.toString();	
resolved apex url to 

Map<String, Object> queryParams = new HashMap<String, Object>(endpoint.getConfiguration().getApexQueryParams());	for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {	if (entry.getKey().startsWith(APEX_QUERY_PARAM_PREFIX)) {	queryParams.put(entry.getKey().substring(APEX_QUERY_PARAM_PREFIX.length()), entry.getValue());	}	}	final Object body = exchange.getIn().getBody();	if (body instanceof Map) {	queryParams.putAll((Map<String, Object>) body);	}	
using apex query params 

========================= camel sample_14751 =========================

protected void doGetBuild(Exchange exchange, String operation) throws Exception {	Build build = null;	String buildName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_BUILD_NAME, String.class);	String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(buildName)) {	
get a specific build require specify a build name 

protected void doGetBuild(Exchange exchange, String operation) throws Exception {	Build build = null;	String buildName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_BUILD_NAME, String.class);	String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(buildName)) {	throw new IllegalArgumentException("Get a specific Build require specify a Build name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
get a specific build require specify a namespace name 

========================= camel sample_13283 =========================

protected Exchange doAdd(final CamelContext camelContext, final String key, final Exchange exchange, final boolean handleOptimisticLockingException) {	
adding key 

protected Exchange doAdd(final CamelContext camelContext, final String key, final Exchange exchange, final boolean handleOptimisticLockingException) {	try {	final Buffer keyBuffer = codec.marshallKey(key);	final Buffer exchangeBuffer = codec.marshallExchange(camelContext, exchange, allowSerializedHeaders);	Buffer rc = hawtDBFile.execute(new Work<Buffer>() {	public Buffer execute(Transaction tx) {	SortedIndex<Buffer, Buffer> index = hawtDBFile.getRepositoryIndex(tx, repositoryName, true);	Buffer buffer = index.put(keyBuffer, exchangeBuffer);	
added key index 

Exchange answer = null;	try {	final Buffer keyBuffer = codec.marshallKey(key);	Buffer rc = hawtDBFile.execute(new Work<Buffer>() {	public Buffer execute(Transaction tx) {	SortedIndex<Buffer, Buffer> index = hawtDBFile.getRepositoryIndex(tx, repositoryName, false);	if (index == null) {	return null;	}	Buffer buffer = index.get(keyBuffer);	
getting key index 

public String toString() {	return "Getting key [" + key + "]";	}	});	if (rc != null) {	answer = codec.unmarshallExchange(camelContext, rc);	}	} catch (IOException e) {	throw new RuntimeException("Error getting key " + key + " from repository " + repositoryName, e);	}	
getting key 

public void remove(final CamelContext camelContext, final String key, final Exchange exchange) {	
removing key 

public void remove(final CamelContext camelContext, final String key, final Exchange exchange) {	try {	final Buffer keyBuffer = codec.marshallKey(key);	final Buffer confirmKeyBuffer = codec.marshallKey(exchange.getExchangeId());	final Buffer exchangeBuffer = codec.marshallExchange(camelContext, exchange, allowSerializedHeaders);	hawtDBFile.execute(new Work<Buffer>() {	public Buffer execute(Transaction tx) {	SortedIndex<Buffer, Buffer> index = hawtDBFile.getRepositoryIndex(tx, repositoryName, true);	Buffer buffer = index.remove(keyBuffer);	
removed key index 

try {	final Buffer keyBuffer = codec.marshallKey(key);	final Buffer confirmKeyBuffer = codec.marshallKey(exchange.getExchangeId());	final Buffer exchangeBuffer = codec.marshallExchange(camelContext, exchange, allowSerializedHeaders);	hawtDBFile.execute(new Work<Buffer>() {	public Buffer execute(Transaction tx) {	SortedIndex<Buffer, Buffer> index = hawtDBFile.getRepositoryIndex(tx, repositoryName, true);	Buffer buffer = index.remove(keyBuffer);	SortedIndex<Buffer, Buffer> indexCompleted = hawtDBFile.getRepositoryIndex(tx, getRepositoryNameCompleted(), true);	indexCompleted.put(confirmKeyBuffer, exchangeBuffer);	
added confirm index 

public void confirm(final CamelContext camelContext, final String exchangeId) {	
confirming exchangeid 

public void confirm(final CamelContext camelContext, final String exchangeId) {	try {	final Buffer confirmKeyBuffer = codec.marshallKey(exchangeId);	hawtDBFile.execute(new Work<Buffer>() {	public Buffer execute(Transaction tx) {	SortedIndex<Buffer, Buffer> indexCompleted = hawtDBFile.getRepositoryIndex(tx, getRepositoryNameCompleted(), true);	Buffer buffer = indexCompleted.remove(confirmKeyBuffer);	
removed confirm index 

while (it.hasNext() && isRunAllowed()) {	Map.Entry<Buffer, Buffer> entry = it.next();	Buffer keyBuffer = entry.getKey();	String key;	try {	key  = codec.unmarshallKey(keyBuffer);	} catch (IOException e) {	throw new RuntimeException("Error unmarshalling key: " + keyBuffer, e);	}	if (key != null) {	
getkey 

while (it.hasNext() && isRunAllowed()) {	Map.Entry<Buffer, Buffer> entry = it.next();	Buffer keyBuffer = entry.getKey();	String exchangeId;	try {	exchangeId = codec.unmarshallKey(keyBuffer);	} catch (IOException e) {	throw new RuntimeException("Error unmarshalling confirm key: " + keyBuffer, e);	}	if (exchangeId != null) {	
scan exchangeid 

answer.add(exchangeId);	}	}	return null;	}	public String toString() {	return "Scan";	}	});	if (answer.size() == 0) {	
scanned and found no exchange to recover 

}	return null;	}	public String toString() {	return "Scan";	}	});	if (answer.size() == 0) {	} else {	if (LOG.isDebugEnabled()) {	
scanned and found exchange s to recover note some of them may already be in progress 

public String toString() {	return "Recovering exchangeId [" + exchangeId + "]";	}	});	if (rc != null) {	answer = codec.unmarshallExchange(camelContext, rc);	}	} catch (IOException e) {	throw new RuntimeException("Error recovering exchangeId " + exchangeId + " from repository " + repositoryName, e);	}	
recovering exchangeid 

private int size(final String repositoryName) {	int answer = hawtDBFile.execute(new Work<Integer>() {	public Integer execute(Transaction tx) {	SortedIndex<Buffer, Buffer> index = hawtDBFile.getRepositoryIndex(tx, repositoryName, false);	return index != null ? index.size() : 0;	}	public String toString() {	return "Size[" + repositoryName + "]";	}	});	
size of repository 

if (getPageSize() > 0) {	hawtDBFile.setPageSize(getPageSize());	}	}	ObjectHelper.notNull(hawtDBFile, "Either set a persistentFileName or a hawtDBFile");	ObjectHelper.notNull(repositoryName, "repositoryName");	ServiceHelper.startService(hawtDBFile);	int current = size(getRepositoryName());	int completed = size(getRepositoryNameCompleted());	if (current > 0) {	
on startup there are aggregate exchanges not completed in repository 

hawtDBFile.setPageSize(getPageSize());	}	}	ObjectHelper.notNull(hawtDBFile, "Either set a persistentFileName or a hawtDBFile");	ObjectHelper.notNull(repositoryName, "repositoryName");	ServiceHelper.startService(hawtDBFile);	int current = size(getRepositoryName());	int completed = size(getRepositoryNameCompleted());	if (current > 0) {	} else {	
on startup there are no existing aggregate exchanges not completed in repository 

}	ObjectHelper.notNull(hawtDBFile, "Either set a persistentFileName or a hawtDBFile");	ObjectHelper.notNull(repositoryName, "repositoryName");	ServiceHelper.startService(hawtDBFile);	int current = size(getRepositoryName());	int completed = size(getRepositoryNameCompleted());	if (current > 0) {	} else {	}	if (completed > 0) {	
on startup there are completed exchanges to be recovered in repository 

ObjectHelper.notNull(hawtDBFile, "Either set a persistentFileName or a hawtDBFile");	ObjectHelper.notNull(repositoryName, "repositoryName");	ServiceHelper.startService(hawtDBFile);	int current = size(getRepositoryName());	int completed = size(getRepositoryNameCompleted());	if (current > 0) {	} else {	}	if (completed > 0) {	} else {	
on startup there are no completed exchanges to be recovered in repository 

========================= camel sample_11744 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<MasterComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.zookeeper-master.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.zookeeper-master.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1215 =========================

public Exchange add(final CamelContext camelContext, final String key, final Exchange exchange) {	
adding an exchange with id for key in a thread safe manner 

public void remove(CamelContext camelContext, String key, Exchange exchange) {	
removing an exchange with id for key 

public void confirm(CamelContext camelContext, String exchangeId) {	
confirming an exchange with id 

public Set<String> scan(CamelContext camelContext) {	
scanning for exchanges to recover in context 

public Set<String> scan(CamelContext camelContext) {	Set<String> scanned = Collections.unmodifiableSet(getKeys());	
found keys for exchanges to recover in context 

public Exchange recover(CamelContext camelContext, String exchangeId) {	
recovering an exchange with id 

========================= camel sample_9625 =========================

public void process(Exchange exchange) throws Exception {	
entering processor 

public void process(Exchange exchange) throws Exception {	String name = exchange.getIn().getBody(String.class);	exchange.getOut().setBody("Hello " + name);	
leaving processor 

========================= camel sample_7791 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<MailComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mail.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mail.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_722 =========================

if (!routeContext.isRouteAdded()) {	boolean endpointInterceptor = false;	if (processor instanceof Channel) {	Channel channel = (Channel) processor;	Processor next = channel.getNextProcessor();	if (next instanceof InterceptEndpointProcessor) {	endpointInterceptor = true;	}	}	if (endpointInterceptor) {	
endpoint interceptor should not be added as an event driven consumer route 

boolean endpointInterceptor = false;	if (processor instanceof Channel) {	Channel channel = (Channel) processor;	Processor next = channel.getNextProcessor();	if (next instanceof InterceptEndpointProcessor) {	endpointInterceptor = true;	}	}	if (endpointInterceptor) {	} else {	
adding event driven processor 

protected Processor wrapChannel(RouteContext routeContext, Processor processor, ProcessorDefinition<?> child, Boolean inheritErrorHandler) throws Exception {	ModelChannel channel = createChannel(routeContext);	channel.setNextProcessor(processor);	addInterceptStrategies(routeContext, channel, routeContext.getCamelContext().getInterceptStrategies());	addInterceptStrategies(routeContext, channel, routeContext.getInterceptStrategies());	addInterceptStrategies(routeContext, channel, this.getInterceptStrategies());	ProcessorDefinition<?> defn = (ProcessorDefinition<?>) this;	channel.setChildDefinition(child);	channel.initChannel(defn, routeContext);	if (defn instanceof TryDefinition || defn instanceof CatchDefinition || defn instanceof FinallyDefinition) {	
is part of dotry docatch dofinally so no error handler is applied 

ModelChannel channel = createChannel(routeContext);	channel.setNextProcessor(processor);	addInterceptStrategies(routeContext, channel, routeContext.getCamelContext().getInterceptStrategies());	addInterceptStrategies(routeContext, channel, routeContext.getInterceptStrategies());	addInterceptStrategies(routeContext, channel, this.getInterceptStrategies());	ProcessorDefinition<?> defn = (ProcessorDefinition<?>) this;	channel.setChildDefinition(child);	channel.initChannel(defn, routeContext);	if (defn instanceof TryDefinition || defn instanceof CatchDefinition || defn instanceof FinallyDefinition) {	} else if (ProcessorDefinitionHelper.isParentOfType(TryDefinition.class, defn, true) || ProcessorDefinitionHelper.isParentOfType(CatchDefinition.class, defn, true) || ProcessorDefinitionHelper.isParentOfType(FinallyDefinition.class, defn, true)) {	
is part of dotry docatch dofinally so no error handler is applied 

channel.setNextProcessor(processor);	addInterceptStrategies(routeContext, channel, routeContext.getCamelContext().getInterceptStrategies());	addInterceptStrategies(routeContext, channel, routeContext.getInterceptStrategies());	addInterceptStrategies(routeContext, channel, this.getInterceptStrategies());	ProcessorDefinition<?> defn = (ProcessorDefinition<?>) this;	channel.setChildDefinition(child);	channel.initChannel(defn, routeContext);	if (defn instanceof TryDefinition || defn instanceof CatchDefinition || defn instanceof FinallyDefinition) {	} else if (ProcessorDefinitionHelper.isParentOfType(TryDefinition.class, defn, true) || ProcessorDefinitionHelper.isParentOfType(CatchDefinition.class, defn, true) || ProcessorDefinitionHelper.isParentOfType(FinallyDefinition.class, defn, true)) {	} else if (defn instanceof OnExceptionDefinition || ProcessorDefinitionHelper.isParentOfType(OnExceptionDefinition.class, defn, true)) {	
is part of onexception so no error handler is applied 

addInterceptStrategies(routeContext, channel, routeContext.getCamelContext().getInterceptStrategies());	addInterceptStrategies(routeContext, channel, routeContext.getInterceptStrategies());	addInterceptStrategies(routeContext, channel, this.getInterceptStrategies());	ProcessorDefinition<?> defn = (ProcessorDefinition<?>) this;	channel.setChildDefinition(child);	channel.initChannel(defn, routeContext);	if (defn instanceof TryDefinition || defn instanceof CatchDefinition || defn instanceof FinallyDefinition) {	} else if (ProcessorDefinitionHelper.isParentOfType(TryDefinition.class, defn, true) || ProcessorDefinitionHelper.isParentOfType(CatchDefinition.class, defn, true) || ProcessorDefinitionHelper.isParentOfType(FinallyDefinition.class, defn, true)) {	} else if (defn instanceof OnExceptionDefinition || ProcessorDefinitionHelper.isParentOfType(OnExceptionDefinition.class, defn, true)) {	} else if (defn instanceof HystrixDefinition || ProcessorDefinitionHelper.isParentOfType(HystrixDefinition.class, defn, true)) {	
is part of hystrixcircuitbreaker so no error handler is applied 

if (defn instanceof TryDefinition || defn instanceof CatchDefinition || defn instanceof FinallyDefinition) {	} else if (ProcessorDefinitionHelper.isParentOfType(TryDefinition.class, defn, true) || ProcessorDefinitionHelper.isParentOfType(CatchDefinition.class, defn, true) || ProcessorDefinitionHelper.isParentOfType(FinallyDefinition.class, defn, true)) {	} else if (defn instanceof OnExceptionDefinition || ProcessorDefinitionHelper.isParentOfType(OnExceptionDefinition.class, defn, true)) {	} else if (defn instanceof HystrixDefinition || ProcessorDefinitionHelper.isParentOfType(HystrixDefinition.class, defn, true)) {	} else if (defn instanceof MulticastDefinition) {	MulticastDefinition def = (MulticastDefinition) defn;	boolean isShareUnitOfWork = def.getShareUnitOfWork() != null && def.getShareUnitOfWork();	if (isShareUnitOfWork && child == null) {	wrapChannelInErrorHandler(channel, routeContext, inheritErrorHandler);	} else {	
is part of multicast which have special error handling so no error handler is applied 

MulticastDefinition def = (MulticastDefinition) defn;	boolean isShareUnitOfWork = def.getShareUnitOfWork() != null && def.getShareUnitOfWork();	if (isShareUnitOfWork && child == null) {	wrapChannelInErrorHandler(channel, routeContext, inheritErrorHandler);	} else {	}	} else {	wrapChannelInErrorHandler(channel, routeContext, inheritErrorHandler);	}	channel.postInitChannel(defn, routeContext);	
wrapped in channel 

private void wrapChannelInErrorHandler(Channel channel, RouteContext routeContext, Boolean inheritErrorHandler) throws Exception {	if (inheritErrorHandler == null || inheritErrorHandler) {	
is configured to inheriterrorhandler 

private void wrapChannelInErrorHandler(Channel channel, RouteContext routeContext, Boolean inheritErrorHandler) throws Exception {	if (inheritErrorHandler == null || inheritErrorHandler) {	Processor output = channel.getOutput();	Processor errorHandler = wrapInErrorHandler(routeContext, output);	channel.setErrorHandler(errorHandler);	} else {	
is configured to not inheriterrorhandler 

========================= camel sample_5256 =========================

protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {	String splitURI[] = ObjectHelper.splitOnCharacter(remaining, ":", 2);	if (splitURI[1] != null) {	String contextId = splitURI[0];	String localEndpoint = splitURI[1];	Component component = getCamelContext().getComponent(contextId);	if (component != null) {	
attempting to create local endpoint inside the component 

========================= camel sample_12168 =========================

public void process(Exchange exchange) throws Exception {	Message in = exchange.getIn();	Object message = in.getBody();	if (message == null) {	
ignoring a null message 

public void process(Exchange exchange) throws Exception {	Message in = exchange.getIn();	Object message = in.getBody();	if (message == null) {	return;	}	if (!(message instanceof String || message instanceof byte[] || message instanceof Reader || message instanceof InputStream)) {	if (LOG.isInfoEnabled()) {	
using string for unexpected message type 

if (!(message instanceof String || message instanceof byte[] || message instanceof Reader || message instanceof InputStream)) {	if (LOG.isInfoEnabled()) {	}	message = in.getBody(String.class);	}	if (message instanceof Reader) {	message = in.getBody(String.class);	} else if (message instanceof InputStream) {	message = in.getBody(byte[].class);	}	
sending to 

if (LOG.isInfoEnabled()) {	}	message = in.getBody(String.class);	}	if (message instanceof Reader) {	message = in.getBody(String.class);	} else if (message instanceof InputStream) {	message = in.getBody(byte[].class);	}	if (getEndpoint().isSendToAll()) {	
sending to all 

private void messageDistributor(final List<String> connectionKeyList, final Object message) {	if (connectionKeyList == null) {	throw new IllegalArgumentException("Failed to send message to multiple connections; connetion key list is not set.");	}	List<String> notValidConnectionKeys = new ArrayList<>();	for (final String connectionKey : connectionKeyList) {	
sending to connection key 

private void messageDistributor(final List<String> connectionKeyList, final Object message) {	if (connectionKeyList == null) {	throw new IllegalArgumentException("Failed to send message to multiple connections; connetion key list is not set.");	}	List<String> notValidConnectionKeys = new ArrayList<>();	for (final String connectionKey : connectionKeyList) {	sendMessage(getWebSocket(connectionKey, notValidConnectionKeys), message);	}	if (!notValidConnectionKeys.isEmpty()) {	
some connections have not received the message 

private void sendMessage(final WebSocket websocket, final Object message) {	if (websocket != null && message != null) {	executor.execute(new Runnable() {	public void run() {	try {	if (message instanceof String) {	websocket.write((String) message);	} else if (message instanceof byte[]) {	websocket.write((byte[]) message, 0, ((byte[]) message).length);	} else {	
unexpected message type 

executor.execute(new Runnable() {	public void run() {	try {	if (message instanceof String) {	websocket.write((String) message);	} else if (message instanceof byte[]) {	websocket.write((byte[]) message, 0, ((byte[]) message).length);	} else {	}	} catch (Exception e) {	
error when writing to websocket 

private WebSocket getWebSocket(final String connectionKey, final List<String> notValidConnectionKeys) {	WebSocket websocket;	if (connectionKey == null) {	throw new IllegalArgumentException("Failed to send message to single connection; connection key is not set.");	} else {	websocket = getEndpoint().getWebSocketStore().getWebSocket(connectionKey);	if (websocket == null) {	notValidConnectionKeys.add(connectionKey);	
failed to send message to single connection connetion key is not valid 

========================= camel sample_10010 =========================

public void testAll() throws Exception {	final List<AddOn> result = requestBody("direct: assertNotNull("all result", result);	
all 

========================= camel sample_17385 =========================

public void testConvertToXmlObject() throws Exception {	Exchange exchange = createExchangeWithBody("<hello>world!</hello>");	Message in = exchange.getIn();	XmlObject object = in.getBody(XmlObject.class);	assertNotNull("Should have created an XmlObject!", object);	
found 

========================= camel sample_14403 =========================

protected void doServiceAsync(AsyncContext context) {	final HttpServletRequest request = (HttpServletRequest) context.getRequest();	final HttpServletResponse response = (HttpServletResponse) context.getResponse();	try {	doService(request, response);	} catch (Exception e) {	
error processing request 

protected void doServiceAsync(AsyncContext context) {	final HttpServletRequest request = (HttpServletRequest) context.getRequest();	final HttpServletResponse response = (HttpServletResponse) context.getResponse();	try {	doService(request, response);	} catch (Exception e) {	try {	response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);	} catch (Exception e1) {	
cannot send reply to client 

protected void doService(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {	
service 

protected void doService(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {	HttpConsumer consumer = resolve(request);	if (consumer == null) {	boolean hasAnyMethod = METHODS.stream().anyMatch(m -> getServletResolveConsumerStrategy().isHttpMethodAllowed(request, m, getConsumers()));	if (hasAnyMethod) {	
no consumer to service request as method is not allowed 

protected void doService(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {	HttpConsumer consumer = resolve(request);	if (consumer == null) {	boolean hasAnyMethod = METHODS.stream().anyMatch(m -> getServletResolveConsumerStrategy().isHttpMethodAllowed(request, m, getConsumers()));	if (hasAnyMethod) {	response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);	return;	} else {	
no consumer to service request as resource is not found 

boolean hasAnyMethod = METHODS.stream().anyMatch(m -> getServletResolveConsumerStrategy().isHttpMethodAllowed(request, m, getConsumers()));	if (hasAnyMethod) {	response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);	return;	} else {	response.sendError(HttpServletResponse.SC_NOT_FOUND);	return;	}	}	if (consumer.isSuspended()) {	
consumer suspended cannot service request 

exchange.setIn(new HttpMessage(exchange, consumer.getEndpoint(), request, response));	String contextPath = consumer.getEndpoint().getPath();	exchange.getIn().setHeader("CamelServletContextPath", contextPath);	String httpPath = (String)exchange.getIn().getHeader(Exchange.HTTP_PATH);	if (contextPath != null && httpPath.startsWith(contextPath)) {	exchange.getIn().setHeader(Exchange.HTTP_PATH, httpPath.substring(contextPath.length()));	}	try {	consumer.createUoW(exchange);	} catch (Exception e) {	
error processing request 

if (contextPath != null && httpPath.startsWith(contextPath)) {	exchange.getIn().setHeader(Exchange.HTTP_PATH, httpPath.substring(contextPath.length()));	}	try {	consumer.createUoW(exchange);	} catch (Exception e) {	throw new ServletException(e);	}	try {	if (log.isTraceEnabled()) {	
processing request for exchangeid 

}	try {	if (log.isTraceEnabled()) {	}	consumer.getProcessor().process(exchange);	} catch (Exception e) {	exchange.setException(e);	}	try {	if (log.isTraceEnabled()) {	
writing response for exchangeid 

}	consumer.getProcessor().process(exchange);	} catch (Exception e) {	exchange.setException(e);	}	try {	if (log.isTraceEnabled()) {	}	Integer bs = consumer.getEndpoint().getResponseBufferSize();	if (bs != null) {	
using response buffer size 

}	try {	if (log.isTraceEnabled()) {	}	Integer bs = consumer.getEndpoint().getResponseBufferSize();	if (bs != null) {	response.setBufferSize(bs);	}	consumer.getBinding().writeResponse(exchange, response);	} catch (IOException e) {	
error processing request 

if (log.isTraceEnabled()) {	}	Integer bs = consumer.getEndpoint().getResponseBufferSize();	if (bs != null) {	response.setBufferSize(bs);	}	consumer.getBinding().writeResponse(exchange, response);	} catch (IOException e) {	throw e;	} catch (Exception e) {	
error processing request 

public void connect(HttpConsumer consumer) {	
connecting consumer 

public void disconnect(HttpConsumer consumer) {	
disconnecting consumer 

protected ClassLoader overrideTccl(final Exchange exchange) {	ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();	ClassLoader appCtxCl = exchange.getContext().getApplicationContextClassLoader();	if (oldClassLoader == null || appCtxCl == null) {	return null;	}	if (!oldClassLoader.equals(appCtxCl)) {	Thread.currentThread().setContextClassLoader(appCtxCl);	if (log.isTraceEnabled()) {	
overrode tccl for exchangeid to on thread 

protected void restoreTccl(final Exchange exchange, ClassLoader oldTccl) {	if (oldTccl == null) {	return;	}	Thread.currentThread().setContextClassLoader(oldTccl);	if (log.isTraceEnabled()) {	
restored tccl for exchangeid to on thread 

========================= camel sample_12884 =========================

try {	final Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();	final Error error = (Error) unmarshaller.unmarshal(responseContext.getEntityStream());	final Response.ResponseBuilder builder = Response.status(responseContext.getStatusInfo());	builder.entity(error);	for (Map.Entry<String, List<String>> header : responseContext.getHeaders().entrySet()) {	builder.header(header.getKey(), header.getValue());	}	throw new LinkedInException(error, builder.build());	} catch (JAXBException e) {	
unable to parse linkedin error 

========================= camel sample_8872 =========================

public O process(I i) throws Exception {	
processing item 

public O process(I i) throws Exception {	O result = (O) producerTemplate.requestBody(endpointUri, i);	
processed item 

========================= camel sample_12754 =========================

public DefaultCamelContext() {	boolean warmUp = "true".equalsIgnoreCase(System.getProperty("CamelWarmUpLRUCacheFactory", "true"));	if (warmUp) {	LRUCacheFactory.warmUp();	}	this.executorServiceManager = new DefaultExecutorServiceManager(this);	this.endpoints = new ProvisionalEndpointRegistry();	this.startupListeners.add(deferStartupListener);	if (WebSpherePackageScanClassResolver.isWebSphereClassLoader(this.getClass().getClassLoader())) {	
using websphere specific packagescanclassresolver 

private Component initComponent(String name, boolean autoCreateComponents) {	Component component = null;	if (autoCreateComponents) {	try {	if (log.isDebugEnabled()) {	
using componentresolver to resolve component with name 

public Component removeComponent(String componentName) {	Component oldComponent = components.remove(componentName);	if (oldComponent != null) {	try {	stopServices(oldComponent);	} catch (Exception e) {	
error stopping component this exception will be ignored 

if (oldEndpoint != null) {	answer.add(oldEndpoint);	stopServices(oldEndpoint);	} else {	for (Map.Entry<EndpointKey, Endpoint> entry : endpoints.entrySet()) {	oldEndpoint = entry.getValue();	if (EndpointHelper.matchEndpoint(this, oldEndpoint.getEndpointUri(), uri)) {	try {	stopServices(oldEndpoint);	} catch (Exception e) {	
error stopping endpoint this exception will be ignored 

public Endpoint getEndpoint(String uri) {	ObjectHelper.notEmpty(uri, "uri");	
getting endpoint with uri 

public Endpoint getEndpoint(String uri) {	ObjectHelper.notEmpty(uri, "uri");	try {	uri = resolvePropertyPlaceholders(uri);	} catch (Exception e) {	throw new ResolveEndpointFailedException(uri, e);	}	final String rawUri = uri;	uri = normalizeEndpointUri(uri);	
getting endpoint with raw uri normalized uri 

uri = normalizeEndpointUri(uri);	Endpoint answer;	String scheme = null;	EndpointKey key = getEndpointKeyPreNormalized(uri);	answer = endpoints.get(key);	if (answer == null) {	try {	String splitURI[] = ObjectHelper.splitOnCharacter(uri, ":", 2);	if (splitURI[1] != null) {	scheme = splitURI[0];	
endpoint uri is from component with name 

String scheme = null;	EndpointKey key = getEndpointKeyPreNormalized(uri);	answer = endpoints.get(key);	if (answer == null) {	try {	String splitURI[] = ObjectHelper.splitOnCharacter(uri, ":", 2);	if (splitURI[1] != null) {	scheme = splitURI[0];	Component component = getComponent(scheme);	if (component != null) {	
creating endpoint from uri using component 

if (splitURI[1] != null) {	scheme = splitURI[0];	Component component = getComponent(scheme);	if (component != null) {	if (component.useRawUri()) {	answer = component.createEndpoint(rawUri);	} else {	answer = component.createEndpoint(uri);	}	if (answer != null && log.isDebugEnabled()) {	
converted to endpoint by component 

answer = component.createEndpoint(rawUri);	} else {	answer = component.createEndpoint(uri);	}	if (answer != null && log.isDebugEnabled()) {	}	}	}	if (answer == null) {	answer = createEndpoint(uri);	
no component to create endpoint from uri fallback lookup in registry 

}	}	if (answer == null) {	answer = createEndpoint(uri);	}	if (answer == null && splitURI[1] == null) {	int pos = uri.indexOf('?');	String componentName = pos > 0 ? uri.substring(0, pos) : uri;	Component component = getComponent(componentName);	if (component != null) {	
creating endpoint from uri using component 

int pos = uri.indexOf('?');	String componentName = pos > 0 ? uri.substring(0, pos) : uri;	Component component = getComponent(componentName);	if (component != null) {	if (component.useRawUri()) {	answer = component.createEndpoint(rawUri);	} else {	answer = component.createEndpoint(uri);	}	if (answer != null && log.isDebugEnabled()) {	
converted to endpoint by component 

public void addRoutes(final RoutesBuilder builder) throws Exception {	
adding routes from builder 

for (Set<Endpoint> endpoints : endpointsInUse.values()) {	if (endpoints.contains(endpoint)) {	count++;	}	}	if (count <= 1) {	toRemove.add(endpoint);	}	}	for (Endpoint endpoint : toRemove) {	
removing which was only in use by route 

clazz = existing.getClass();	} else {	return null;	}	}	String packageName = clazz.getPackage().getName();	packageName = packageName.replace('.', '/');	String path = packageName + "/" + componentName + ".json";	ClassResolver resolver = getClassResolver();	InputStream inputStream = resolver.loadResourceAsStream(path);	
loading component json schema for using class resolver 

} catch (NoFactoryAvailableException e) {	}	if (clazz == null) {	return null;	}	String packageName = clazz.getPackage().getName();	packageName = packageName.replace('.', '/');	String path = packageName + "/" + dataFormatName + ".json";	ClassResolver resolver = getClassResolver();	InputStream inputStream = resolver.loadResourceAsStream(path);	
loading dataformat json schema for using class resolver 

} catch (NoFactoryAvailableException e) {	}	if (clazz == null) {	return null;	}	String packageName = clazz.getPackage().getName();	packageName = packageName.replace('.', '/');	String path = packageName + "/" + languageName + ".json";	ClassResolver resolver = getClassResolver();	InputStream inputStream = resolver.loadResourceAsStream(path);	
loading language json schema for using class resolver 

public String getEipParameterJsonSchema(String eipName) throws IOException {	String[] subPackages = new String[]{"", "/config", "/dataformat", "/language", "/loadbalancer", "/rest"};	for (String sub : subPackages) {	String path = CamelContextHelper.MODEL_DOCUMENTATION_PREFIX + sub + "/" + eipName + ".json";	ClassResolver resolver = getClassResolver();	InputStream inputStream = resolver.loadResourceAsStream(path);	if (inputStream != null) {	
loading eip json schema for using class resolver 

public String resolvePropertyPlaceholders(String text) throws Exception {	PropertiesComponent pc = getPropertiesComponent();	if (text != null && !text.startsWith("properties:")) {	if (pc == null && text.contains(PropertiesComponent.DEFAULT_PREFIX_TOKEN)) {	pc = (PropertiesComponent) CamelContextHelper.lookupPropertiesComponent(this, true);	}	if (pc != null && text.contains(pc.getPrefixToken())) {	String answer = pc.parseUri(text);	
resolved text 

protected void doSuspend() throws Exception {	EventHelper.notifyCamelContextSuspending(this);	
apache camel camelcontext is suspending 

getShutdownStrategy().suspend(this, orders);	for (RouteService service : suspendedRouteServices.values()) {	if (routeSupportsSuspension(service.getId())) {	service.suspend();	} else {	service.stop();	}	}	watch.stop();	if (log.isInfoEnabled()) {	
apache camel camelcontext is suspended in 

protected void doResume() throws Exception {	try {	EventHelper.notifyCamelContextResuming(this);	
apache camel camelcontext is resuming 

StopWatch watch = new StopWatch();	doStartOrResumeRoutes(suspendedRouteServices, false, true, true, false);	for (RouteService service : suspendedRouteServices.values()) {	if (routeSupportsSuspension(service.getId())) {	service.resume();	} else {	service.start();	}	}	if (log.isInfoEnabled()) {	
resumed routes 

StopWatch watch = new StopWatch();	doStartOrResumeRoutes(suspendedRouteServices, false, true, true, false);	for (RouteService service : suspendedRouteServices.values()) {	if (routeSupportsSuspension(service.getId())) {	service.resume();	} else {	service.start();	}	}	if (log.isInfoEnabled()) {	
apache camel camelcontext resumed in 

public void start() throws Exception {	try (MDCHelper mdcHelper = new MDCHelper()) {	vetoStated.set(false);	startDate = new Date();	stopWatch.restart();	
apache camel camelcontext is starting 

doStartOrResumeRoutes(routeServices, true, true, false, true);	}	try {	firstStartDone = true;	super.start();	} catch (VetoCamelContextStartException e) {	vetoStated.set(true);	if (e.isRethrowException()) {	throw e;	} else {	
camelcontext vetoed to not start due 

if (log.isInfoEnabled()) {	int started = 0;	for (Route route : getRoutes()) {	ServiceStatus status = getRouteStatus(route.getId());	if (status != null && status.isStarted()) {	started++;	}	}	final Collection<Route> controlledRoutes = getRouteController().getControlledRoutes();	if (controlledRoutes.isEmpty()) {	
total routes of which are started 

int started = 0;	for (Route route : getRoutes()) {	ServiceStatus status = getRouteStatus(route.getId());	if (status != null && status.isStarted()) {	started++;	}	}	final Collection<Route> controlledRoutes = getRouteController().getControlledRoutes();	if (controlledRoutes.isEmpty()) {	} else {	
total routes of which are started and are managed by routecontroller 

for (Route route : getRoutes()) {	ServiceStatus status = getRouteStatus(route.getId());	if (status != null && status.isStarted()) {	started++;	}	}	final Collection<Route> controlledRoutes = getRouteController().getControlledRoutes();	if (controlledRoutes.isEmpty()) {	} else {	}	
apache camel camelcontext started in 

private void doStartCamel() throws Exception {	if (globalOptions != null && !globalOptions.isEmpty()) {	for (Map.Entry<String, String> entry : globalOptions.entrySet()) {	String key = entry.getKey();	String value = entry.getValue();	if (value != null) {	String replaced = resolvePropertyPlaceholders(value);	if (!value.equals(replaced)) {	if (log.isDebugEnabled()) {	
camel property with key replaced value from 

}	}	}	if (classResolver instanceof CamelContextAware) {	((CamelContextAware) classResolver).setCamelContext(this);	}	if (log.isDebugEnabled()) {	log.debug("Using ClassResolver={}, PackageScanClassResolver={}, ApplicationContextClassLoader={}, RouteController={}", getClassResolver(), getPackageScanClassResolver(), getApplicationContextClassLoader(), getRouteController());	}	if (isStreamCaching()) {	
streamcaching is enabled on camelcontext 

}	if (classResolver instanceof CamelContextAware) {	((CamelContextAware) classResolver).setCamelContext(this);	}	if (log.isDebugEnabled()) {	log.debug("Using ClassResolver={}, PackageScanClassResolver={}, ApplicationContextClassLoader={}, RouteController={}", getClassResolver(), getPackageScanClassResolver(), getApplicationContextClassLoader(), getRouteController());	}	if (isStreamCaching()) {	}	if (isTracing()) {	
tracing is enabled on camelcontext 

((CamelContextAware) classResolver).setCamelContext(this);	}	if (log.isDebugEnabled()) {	log.debug("Using ClassResolver={}, PackageScanClassResolver={}, ApplicationContextClassLoader={}, RouteController={}", getClassResolver(), getPackageScanClassResolver(), getApplicationContextClassLoader(), getRouteController());	}	if (isStreamCaching()) {	}	if (isTracing()) {	}	if (isUseMDCLogging()) {	
mdc logging is enabled on camelcontext 

log.debug("Using ClassResolver={}, PackageScanClassResolver={}, ApplicationContextClassLoader={}, RouteController={}", getClassResolver(), getPackageScanClassResolver(), getApplicationContextClassLoader(), getRouteController());	}	if (isStreamCaching()) {	}	if (isTracing()) {	}	if (isUseMDCLogging()) {	}	if (isHandleFault()) {	if (HandleFault.getHandleFault(this) == null) {	
handlefault is enabled on camelcontext 

if (isTracing()) {	}	if (isUseMDCLogging()) {	}	if (isHandleFault()) {	if (HandleFault.getHandleFault(this) == null) {	addInterceptStrategy(new HandleFault());	}	}	if (getDelayer() != null && getDelayer() > 0) {	
delayer is enabled with ms on camelcontext 

if (isUseMDCLogging()) {	}	if (isHandleFault()) {	if (HandleFault.getHandleFault(this) == null) {	addInterceptStrategy(new HandleFault());	}	}	if (getDelayer() != null && getDelayer() > 0) {	}	if (getDebugger() != null) {	
debugger is enabled on camelcontext 

((CamelContextAware) managementStrategy).setCamelContext(this);	}	ServiceHelper.startService(managementStrategy);	ServiceHelper.startServices(lifecycleStrategies);	Iterator<LifecycleStrategy> it = lifecycleStrategies.iterator();	while (it.hasNext()) {	LifecycleStrategy strategy = it.next();	try {	strategy.onContextStart(this);	} catch (VetoCamelContextStartException e) {	
lifecycle strategy vetoed starting camelcontext due 

ServiceHelper.startService(managementStrategy);	ServiceHelper.startServices(lifecycleStrategies);	Iterator<LifecycleStrategy> it = lifecycleStrategies.iterator();	while (it.hasNext()) {	LifecycleStrategy strategy = it.next();	try {	strategy.onContextStart(this);	} catch (VetoCamelContextStartException e) {	throw e;	} catch (Exception e) {	
lifecycle strategy failed starting camelcontext due 

addService(producerServicePool, true, true);	addService(pollingConsumerServicePool, true, true);	addService(inflightRepository, true, true);	addService(asyncProcessorAwaitManager, true, true);	addService(shutdownStrategy, true, true);	addService(packageScanClassResolver, true, true);	addService(restRegistry, true, true);	addService(messageHistoryFactory, true, true);	addService(runtimeCamelCatalog, true, true);	if (reloadStrategy != null) {	
using reloadstrategy 

if (!streamCachingInUse) {	for (RouteDefinition route : routeDefinitions) {	Boolean routeCache = CamelContextHelper.parseBoolean(this, route.getStreamCache());	if (routeCache != null && routeCache) {	streamCachingInUse = true;	break;	}	}	}	if (isUseDataType()) {	
message datatype is enabled on camelcontext 

break;	}	}	}	if (isUseDataType()) {	}	if (streamCachingInUse) {	getStreamCachingStrategy().setEnabled(true);	addService(getStreamCachingStrategy(), true, true);	} else {	
streamcaching is not in use if using streams then its recommended to enable stream caching see more details at http 

}	}	}	if (isUseDataType()) {	}	if (streamCachingInUse) {	getStreamCachingStrategy().setEnabled(true);	addService(getStreamCachingStrategy(), true, true);	} else {	if (isAllowUseOriginalMessage()) {	
allowuseoriginalmessage enabled because useoriginalmessage is in use 

}	if (streamCachingInUse) {	getStreamCachingStrategy().setEnabled(true);	addService(getStreamCachingStrategy(), true, true);	} else {	if (isAllowUseOriginalMessage()) {	}	if (headersMapFactory instanceof DefaultHeadersMapFactory) {	headersMapFactory = new HeadersMapFactoryResolver().resolve(this);	}	
using headersmapfactory 

if (streamCachingInUse) {	getStreamCachingStrategy().setEnabled(true);	addService(getStreamCachingStrategy(), true, true);	} else {	if (isAllowUseOriginalMessage()) {	}	if (headersMapFactory instanceof DefaultHeadersMapFactory) {	headersMapFactory = new HeadersMapFactoryResolver().resolve(this);	}	if (!headersMapFactory.isCaseInsensitive()) {	
headersmapfactory is case sensitive which can cause problems for protocols such as http based which rely on case insensitive headers 

protected synchronized void doStop() throws Exception {	stopWatch.restart();	
apache camel camelcontext is shutting down 

protected synchronized void doStop() throws Exception {	stopWatch.restart();	EventHelper.notifyCamelContextStopping(this);	ServiceHelper.stopAndShutdownService(this.routeController);	try {	shutdownStrategy.shutdownForced(this, getRouteStartupOrder());	} catch (Throwable e) {	
error occurred while shutting down routes this exception will be ignored 

endpoints.clear();	shutdownServices(components.values());	components.clear();	shutdownServices(languages.values());	languages.clear();	try {	for (LifecycleStrategy strategy : lifecycleStrategies) {	strategy.onContextStop(this);	}	} catch (Throwable e) {	
error occurred while stopping lifecycle strategies this exception will be ignored 

for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {	shutdownServices(notifier);	}	shutdownServices(executorServiceManager);	shutdownServices(managementStrategy);	shutdownServices(managementMBeanAssembler);	shutdownServices(lifecycleStrategies);	forceStopLazyInitialization();	IntrospectionSupport.stop();	if (log.isInfoEnabled()) {	
apache camel camelcontext uptime 

for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {	shutdownServices(notifier);	}	shutdownServices(executorServiceManager);	shutdownServices(managementStrategy);	shutdownServices(managementMBeanAssembler);	shutdownServices(lifecycleStrategies);	forceStopLazyInitialization();	IntrospectionSupport.stop();	if (log.isInfoEnabled()) {	
apache camel camelcontext is shutdown in 

private void shutdownServices(Object service) {	try {	if (service instanceof Service) {	ServiceHelper.stopAndShutdownService(service);	} else if (service instanceof Collection) {	ServiceHelper.stopAndShutdownServices((Collection<?>)service);	}	} catch (Throwable e) {	
error occurred while shutting down service this exception will be ignored 

}	Endpoint existing = existingRoute.getEndpoint();	ServiceStatus status = getRouteStatus(existingRoute.getId());	if (status != null && (status.isStarted() || status.isStarting())) {	existingEndpoints.add(existing);	}	}	if (!doCheckMultipleConsumerSupportClash(endpoint, existingEndpoints)) {	throw new FailedToStartRouteException(routeService.getId(), "Multiple consumers for the same endpoint is not allowed: " + endpoint);	}	
route 

Endpoint existing = existingRoute.getEndpoint();	ServiceStatus status = getRouteStatus(existingRoute.getId());	if (status != null && (status.isStarted() || status.isStarting())) {	existingEndpoints.add(existing);	}	}	if (!doCheckMultipleConsumerSupportClash(endpoint, existingEndpoints)) {	throw new FailedToStartRouteException(routeService.getId(), "Multiple consumers for the same endpoint is not allowed: " + endpoint);	}	if (resumeOnly) {	
resuming consumer order on route 

ServiceStatus status = getRouteStatus(existingRoute.getId());	if (status != null && (status.isStarted() || status.isStarting())) {	existingEndpoints.add(existing);	}	}	if (!doCheckMultipleConsumerSupportClash(endpoint, existingEndpoints)) {	throw new FailedToStartRouteException(routeService.getId(), "Multiple consumers for the same endpoint is not allowed: " + endpoint);	}	if (resumeOnly) {	} else {	
starting consumer order on route 

}	}	if (!doCheckMultipleConsumerSupportClash(endpoint, existingEndpoints)) {	throw new FailedToStartRouteException(routeService.getId(), "Multiple consumers for the same endpoint is not allowed: " + endpoint);	}	if (resumeOnly) {	} else {	}	if (resumeOnly && route.supportsSuspension()) {	ServiceHelper.resumeService(consumer);	
route resumed and consuming from 

for (LifecycleStrategy strategy : lifecycleStrategies) {	strategy.onServiceAdd(this, consumer, route);	}	try {	startService(consumer);	route.getProperties().remove("route.start.exception");	} catch (Exception e) {	route.getProperties().put("route.start.exception", e);	throw e;	}	
route started and consuming from 

protected Registry createRegistry() {	JndiRegistry jndi = new JndiRegistry();	try {	jndi.getContext();	return jndi;	} catch (Throwable e) {	
cannot create javax naming initialcontext due will fallback and use simpleregistry instead this exception is ignored 

========================= camel sample_3947 =========================

context.addService(createClusterService(id, address));	context.addRoutePolicyFactory(ClusteredRoutePolicyFactory.forNamespace("my-ns"));	context.addRoutes(new RouteBuilder() {	public void configure() throws Exception {	from("timer:atomix?delay=1s&period=1s") .routeId("route-" + id) .log("From ${routeId}") .process(e -> contextLatch.countDown());	}	});	Thread.sleep(ThreadLocalRandom.current().nextInt(500));	context.start();	contextLatch.await();	
shutting down client node 

========================= camel sample_10293 =========================

public Exchange createExchange(Object feed, Object entry) {	Exchange exchange = createExchangeWithFeedHeader(feed, RssConstants.RSS_FEED);	SyndFeed newFeed;	try {	newFeed = (SyndFeed)((SyndFeed) feed).clone();	newFeed.setEntries(Arrays.asList(entry));	} catch (CloneNotSupportedException e) {	
could not create a new feed this exception will be ignored 

========================= camel sample_12304 =========================

if (absolute) {	base = new File("");	} else {	base = new File(".");	}	for (String part : parts) {	File subDir = new File(base, part);	if (!subDir.exists()) {	if (subDir.mkdir()) {	if (LOG.isTraceEnabled()) {	
setting chmod on directory 

public boolean buildDirectory(String directory, boolean absolute) throws GenericFileOperationFailedException {	ObjectHelper.notNull(endpoint, "endpoint");	if (endpoint.isAutoCreate() && !endpoint.getFile().exists()) {	
building starting directory 

if (ObjectHelper.isNotEmpty(afterRoot)) {	path = new File(endpoint.getFile(), afterRoot);	} else {	path = new File(endpoint.getFile(), directory);	}	}	synchronized (this) {	if (path.isDirectory() && path.exists()) {	return true;	} else {	
building directory 

public boolean storeFile(String fileName, Exchange exchange, long size) throws GenericFileOperationFailedException {	ObjectHelper.notNull(endpoint, "endpoint");	File file = new File(fileName);	if (file.exists()) {	if (endpoint.getFileExist() == GenericFileExist.Ignore) {	
an existing file already exists ignore and do not override it 

if (endpoint.getFileExist() == GenericFileExist.Ignore) {	return true;	} else if (endpoint.getFileExist() == GenericFileExist.Fail) {	throw new GenericFileOperationFailedException("File already exist: " + file + ". Cannot write new file.");	} else if (endpoint.getFileExist() == GenericFileExist.Move) {	doMoveExistingFile(fileName);	}	}	if (exchange.getIn().getBody() == null) {	if (endpoint.isAllowNullBody()) {	
writing empty file 

if (fileBased) {	File local = exchange.getIn().getHeader(Exchange.FILE_LOCAL_WORK_PATH, File.class);	if (local != null && local.exists()) {	boolean renamed = writeFileByLocalWorkPath(local, file);	if (renamed) {	keepLastModified(exchange, file);	if (ObjectHelper.isNotEmpty(endpoint.getChmod())) {	Set<PosixFilePermission> permissions = endpoint.getPermissions();	if (!permissions.isEmpty()) {	if (LOG.isTraceEnabled()) {	
setting chmod on file 

exchange.getIn().setHeader(Exchange.FILE_LOCAL_WORK_PATH, null);	return true;	}	} else if (source != null && source.exists()) {	writeFileByFile(source, file);	keepLastModified(exchange, file);	if (ObjectHelper.isNotEmpty(endpoint.getChmod())) {	Set<PosixFilePermission> permissions = endpoint.getPermissions();	if (!permissions.isEmpty()) {	if (LOG.isTraceEnabled()) {	
setting chmod on file 

writeFileByReaderWithCharset(in, file, charset);	} else {	InputStream in = exchange.getIn().getMandatoryBody(InputStream.class);	writeFileByStream(in, file);	}	keepLastModified(exchange, file);	if (ObjectHelper.isNotEmpty(endpoint.getChmod())) {	Set<PosixFilePermission> permissions = endpoint.getPermissions();	if (!permissions.isEmpty()) {	if (LOG.isTraceEnabled()) {	
setting chmod on file 

String to = endpoint.getMoveExisting().evaluate(dummy, String.class);	to = FileUtil.normalizePath(to);	if (ObjectHelper.isEmpty(to)) {	throw new GenericFileOperationFailedException("moveExisting evaluated as empty String, cannot move existing file: " + fileName);	}	File toFile = new File(to);	String directory = toFile.getParent();	boolean absolute = FileUtil.isAbsolute(toFile);	if (directory != null) {	if (!buildDirectory(directory, absolute)) {	
cannot build directory could be because of denied permissions 

}	File toFile = new File(to);	String directory = toFile.getParent();	boolean absolute = FileUtil.isAbsolute(toFile);	if (directory != null) {	if (!buildDirectory(directory, absolute)) {	}	}	if (existsFile(to)) {	if (endpoint.isEagerDeleteTargetFile()) {	
deleting existing file 

}	if (existsFile(to)) {	if (endpoint.isEagerDeleteTargetFile()) {	if (!deleteFile(to)) {	throw new GenericFileOperationFailedException("Cannot delete file: " + to);	}	} else {	throw new GenericFileOperationFailedException("Cannot moved existing file from: " + fileName + " to: " + to + " as there already exists a file: " + to);	}	}	
moving existing file to 

Long last;	Date date = exchange.getIn().getHeader(Exchange.FILE_LAST_MODIFIED, Date.class);	if (date != null) {	last = date.getTime();	} else {	last = exchange.getIn().getHeader(Exchange.FILE_LAST_MODIFIED, Long.class);	}	if (last != null) {	boolean result = file.setLastModified(last);	if (LOG.isTraceEnabled()) {	
keeping last modified timestamp on file with result 

private boolean writeFileByLocalWorkPath(File source, File file) throws IOException {	
using local work file being renamed from to 

private void writeFileByStream(InputStream in, File target) throws IOException {	try (SeekableByteChannel out = prepareOutputFileChannel(target)) {	
using inputstream to write file 

private void writeFileByReaderWithCharset(Reader in, File target, String charset) throws IOException {	boolean append = endpoint.getFileExist() == GenericFileExist.Append;	try (Writer out = Files.newBufferedWriter(target.toPath(), Charset.forName(charset), StandardOpenOption.WRITE, append ? StandardOpenOption.APPEND : StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.CREATE)) {	
using reader to write file with charset 

private void writeFileEmptyBody(File target) throws IOException {	if (!target.exists()) {	
creating new empty file 

private void writeFileEmptyBody(File target) throws IOException {	if (!target.exists()) {	FileUtil.createNewFile(target);	} else if (endpoint.getFileExist() == GenericFileExist.Override) {	
truncating existing file 

========================= camel sample_4781 =========================

return;	}	context.addRoutes(new RouteBuilder() {	public void configure() {	from("netty:tcp: .process(new Processor() {	public void process(Exchange exchange) throws Exception {	SSLSession session = exchange.getIn().getHeader(NettyConstants.NETTY_SSL_SESSION, SSLSession.class);	if (session != null) {	javax.security.cert.X509Certificate cert = session.getPeerCertificateChain()[0];	Principal principal = cert.getSubjectDN();	
client cert subjectdn 

========================= camel sample_6616 =========================

} else {	int avail = input.available();	if (avail > bufferSize) {	bufferSize = avail;	}	}	if (bufferSize > 262144) {	bufferSize = 262144;	}	if (LOG.isTraceEnabled()) {	
copying inputstream outputstream with buffer and flush on each write 

========================= camel sample_4294 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<FlinkComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.flink.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.flink.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1096 =========================

public void testAddAssignmentToTask() throws Exception {	com.box.sdk.BoxTask result = null;	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.taskId", testTask.getID());	headers.put("CamelBox.assignTo", getCurrentUser());	result = requestBodyAndHeaders("direct: assertNotNull("addAssignmentToTask result", result);	
addassignmenttotask 

com.box.sdk.BoxTask result = null;	try {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.fileId", testFile.getID());	headers.put("CamelBox.action", BoxTask.Action.REVIEW);	Date now = new Date();	Date dueAt = new Date(now.getTime() + TEN_MINUTES_IN_MILLIS);	headers.put("CamelBox.dueAt", dueAt);	headers.put("CamelBox.message", CAMEL_TEST_MESSAGE);	result = requestBodyAndHeaders("direct: assertNotNull("addFileTask result", result);	
addfiletask 

public void testGetFileTasks() throws Exception {	final java.util.List result = requestBody("direct: assertNotNull("getFileTasks result", result);	
getfiletasks 

public void testGetTaskAssignmentInfo() throws Exception {	BoxTaskAssignment.Info info = testTask.addAssignment(getCurrentUser());	com.box.sdk.BoxTaskAssignment.Info result = null;	try {	result = requestBody("direct: assertNotNull("getTaskAssignmentInfo result", result);	
gettaskassignmentinfo 

public void testGetTaskAssignments() throws Exception {	final java.util.List result = requestBody("direct: assertNotNull("getTaskAssignments result", result);	
gettaskassignments 

public void testGetTaskInfo() throws Exception {	final com.box.sdk.BoxTask.Info result = requestBody("direct: assertNotNull("getTaskInfo result", result);	
gettaskinfo 

public void testUpdateTaskInfo() throws Exception {	BoxTask.Info info = testTask.getInfo();	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.taskId", testTask.getID());	headers.put("CamelBox.info", info);	final com.box.sdk.BoxTask result = requestBodyAndHeaders("direct: assertNotNull("updateTaskInfo result", result);	
updatetaskinfo 

========================= camel sample_17413 =========================

public static void setupTestServer() throws Exception {	port = AvailablePortFinder.getNextAvailable(39913);	
starting zookeeper test infrastructure 

public static void setupTestServer() throws Exception {	port = AvailablePortFinder.getNextAvailable(39913);	server = new TestZookeeperServer(getServerPort(), clearServerData());	waitForServerUp("localhost:" + getServerPort(), 1000);	client = new TestZookeeperClient(getServerPort(), getTestClientSessionTimeout());	
started zookeeper test infrastructure on port 

public static void shutdownServer() throws Exception {	
stopping zookeeper test infrastructure 

public static void shutdownServer() throws Exception {	client.shutdown();	server.shutdown();	waitForServerDown("localhost:" + getServerPort(), 1000);	
stopped zookeeper test infrastructure 

public void create(String node, String data) throws Exception {	
creating node s with data s 

public void createPersistent(String node, String data) throws Exception {	
creating node s with data s 

public void create(String znode, String data, List<ACL> access, CreateMode mode) throws Exception {	delay(200);	String created = zk.create(znode, data != null ? data.getBytes() : null, access, mode);	if (log.isInfoEnabled()) {	
created znode named s 

public Stat setData(String node, String data, int version) throws Exception {	
testclient updating data of node s to s 

public void process(WatchedEvent event) {	if (event.getState() == KeeperState.SyncConnected) {	
testclient connected 

public void process(WatchedEvent event) {	if (event.getState() == KeeperState.SyncConnected) {	connected.countDown();	} else {	if (event.getState() == KeeperState.Disconnected) {	
testclient connected 

public void deleteAll(String node) throws Exception {	delay(200);	
deleting and it s immediate children 

public void delete(String node) throws Exception {	delay(200);	
deleting node 

public static boolean waitForServerUp(String hp, long timeout) {	long start = System.currentTimeMillis();	while (true) {	try {	hp = hp.split(",")[0];	String result = send4LetterWord(hp, "stat");	if (result.startsWith("Zookeeper version:")) {	return true;	}	} catch (IOException e) {	
server not up 

========================= camel sample_12611 =========================

}	} else {	try {	EtcdKeysResponse response = promise.get();	exchange = endpoint.createExchange();	exchange.getIn().setHeader(EtcdConstants.ETCD_NAMESPACE, getNamespace());	exchange.getIn().setHeader(EtcdConstants.ETCD_PATH, response.node.key);	exchange.getIn().setBody(response);	index.set(response.node.modifiedIndex + 1);	} catch (TimeoutException e) {	
timeout watching for 

========================= camel sample_12241 =========================

public Producer createProducer() throws Exception {	if (ObjectHelper.isEmpty(host)) {	throw new IllegalArgumentException("Hostname must be configured on either restConfiguration" + " or in the rest endpoint uri as a query parameter with name host, eg rest:" + method + ":" + path + "?host=someserver");	}	RestProducerFactory apiDocFactory = null;	RestProducerFactory factory = null;	if (apiDoc != null) {	
discovering camel swagger java on classpath for using api doc 

if (comp instanceof RestProducerFactory) {	if (found == null) {	found = (RestProducerFactory) comp;	foundName = name;	} else {	throw new IllegalArgumentException("Multiple RestProducerFactory found on classpath. Configure explicit which component to use");	}	}	}	if (found != null) {	
auto discovered as restproducerfactory 

} else {	throw new IllegalArgumentException("Multiple RestProducerFactory found on classpath. Configure explicit which component to use");	}	}	}	if (found != null) {	factory = found;	}	}	if (factory != null) {	
using restproducerfactory 

if (comp instanceof RestConsumerFactory) {	if (found == null) {	found = (RestConsumerFactory) comp;	foundName = name;	} else {	throw new IllegalArgumentException("Multiple RestConsumerFactory found on classpath. Configure explicit which component to use");	}	}	}	if (found != null) {	
auto discovered as restconsumerfactory 

========================= camel sample_4943 =========================

public void process(Exchange exchange) throws Exception {	Message in = exchange.getIn();	Comment comment = (Comment) in.getBody();	
got comment with id body 

========================= camel sample_12996 =========================

if (object == null) {	return null;	}	ByteArrayOutputStream baos = new ByteArrayOutputStream();	ObjectOutputStream oos = null;	try {	oos = new ObjectOutputStream(baos);	oos.writeObject(object);	result = baos.toByteArray();	} catch (IOException e) {	
error while serializing object null will be used 

public Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {	try {	return classLoader.loadClass(desc.getName());	} catch (Exception e) {	}	return super.resolveClass(desc);	}	};	result = (T) ois.readObject();	} catch (IOException e) {	
error while deserializing object null will be used 

try {	return classLoader.loadClass(desc.getName());	} catch (Exception e) {	}	return super.resolveClass(desc);	}	};	result = (T) ois.readObject();	} catch (IOException e) {	} catch (ClassNotFoundException e) {	
could not find class while deserializing object null will be used 

========================= camel sample_14004 =========================

host = "127.0.0.1";	}	if (port == -1) {	if (getType() == SnmpActionType.POLL) {	port = 161;	} else {	port = 162;	}	}	String address = String.format("%s:%s/%d", getProtocol(), host, port);	
using snmp address 

========================= camel sample_8825 =========================

public Product getProduct(@PathParam("productId")int productId) {	
invoking getproduct with id 

========================= camel sample_6092 =========================

public void initChannel(ProcessorDefinition<?> outputDefinition, RouteContext routeContext) throws Exception {	this.routeContext = routeContext;	this.definition = outputDefinition;	this.camelContext = routeContext.getCamelContext();	Processor target = nextProcessor;	Processor next;	if (target instanceof CamelContextAware) {	((CamelContextAware) target).setCamelContext(camelContext);	}	ProcessorDefinition<?> targetOutputDef = childDefinition != null ? childDefinition : outputDefinition;	
initialize channel for target 

for (InterceptStrategy strategy : interceptors) {	next = target == nextProcessor ? null : nextProcessor;	if (strategy instanceof Tracer) {	continue;	}	if (strategy instanceof StreamCaching) {	continue;	}	Processor wrapped = strategy.wrapProcessorInInterceptors(routeContext.getCamelContext(), targetOutputDef, target, next);	if (!(wrapped instanceof AsyncProcessor)) {	
interceptor at does not return an asyncprocessor instance this causes the asynchronous routing engine to not work as optimal as possible see more details at the interceptstrategy javadoc camel will use a bridge to adapt the interceptor to the asynchronous routing engine but its not the most optimal solution please consider changing your interceptor to comply 

========================= camel sample_4555 =========================

public void testSerialize() throws Exception {	Method method = getClass().getMethod("cheese", String.class, String.class);	BeanInvocation invocation = new BeanInvocation(method, new Object[] {"a", "b"});	ByteArrayOutputStream buffer = new ByteArrayOutputStream();	ObjectOutputStream out = new ObjectOutputStream(buffer);	out.writeObject(invocation);	out.close();	ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));	Object object = in.readObject();	BeanInvocation actual = assertIsInstanceOf(BeanInvocation.class, object);	
received 

BeanInvocation invocation = new BeanInvocation();	invocation.setArgs(new Object[] {"a", "b"});	invocation.setMethod(method);	ByteArrayOutputStream buffer = new ByteArrayOutputStream();	ObjectOutputStream out = new ObjectOutputStream(buffer);	out.writeObject(invocation);	out.close();	ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));	Object object = in.readObject();	BeanInvocation actual = assertIsInstanceOf(BeanInvocation.class, object);	
received 

public void cheese(String a, String b) {	
called with a b 

========================= camel sample_3290 =========================

public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {	if (!super.acquireExclusiveReadLock(operations, file, exchange)) {	return false;	}	File target = new File(file.getAbsoluteFilePath());	
waiting for exclusive read lock to file 

if (delta > timeout) {	CamelLogger.log(LOG, readLockLoggingLevel, "Cannot acquire read lock within " + timeout + " millis. Will skip the file: " + target);	return false;	}	}	try {	lock = timeout > 0 ? channel.tryLock() : channel.lock();	} catch (IllegalStateException ex) {	}	if (lock != null) {	
acquired exclusive read lock to file 

boolean interrupted = sleep();	if (interrupted) {	return false;	}	}	}	} catch (IOException e) {	if (timeout == 0) {	return false;	}	
cannot acquire read lock will try again 

private boolean sleep() {	
exclusive read lock not granted sleeping for millis 

private boolean sleep() {	try {	Thread.sleep(checkInterval);	return false;	} catch (InterruptedException e) {	
sleep interrupted while waiting for exclusive read lock so breaking out 

========================= camel sample_4806 =========================

TwitterFindComponent connector = new TwitterFindComponent();	connector.setCamelContext(camelContext);	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, connector, parameters, false);	connector.setOptions(parameters);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ConnectorCustomizer<TwitterFindComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.connector.customizer", "camel.connector.twitter-find.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.connector.customizer", "camel.connector.twitter-find.customizer");	if (useCustomizer) {	
configure connector with customizer 

TwitterFindComponent connector = new TwitterFindComponent( entry.getKey());	connector.setCamelContext(camelContext);	try {	IntrospectionSupport.getProperties(entry.getValue(), parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, connector, parameters, false);	connector.setOptions(parameters);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ConnectorCustomizer<TwitterFindComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.connector.customizer", "camel.connector.twitter-find." + entry.getKey() + ".customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.connector.customizer", "camel.connector.twitter-find." + entry.getKey() + ".customizer");	if (useCustomizer) {	
configure connector with customizer 

========================= camel sample_40 =========================

private synchronized MiloClientEndpoint createEndpoint(final String uri, final MiloClientConfiguration configuration, final Map<String, Object> parameters) throws Exception {	MiloClientConnection connection = this.cache.get(configuration.toCacheId());	if (connection == null) {	
cache miss creating new connection instance 

public synchronized void disposed(final MiloClientEndpoint endpoint) {	final MiloClientConnection connection = endpoint.getConnection();	this.connectionMap.remove(connection.getConnectionId(), endpoint);	if (!this.connectionMap.containsKey(connection.getConnectionId())) {	this.cache.remove(connection.getConnectionId());	try {	connection.close();	} catch (final Exception e) {	
failed to close connection 

========================= camel sample_17278 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KafkaComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kafka.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kafka.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_630 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ChronicleEngineComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.chronicle-engine.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.chronicle-engine.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1184 =========================

public void run() {	
received hang up stopping the main instance 

public void run() {	try {	mainInstance.stop();	} catch (Exception ex) {	
error during stopping the main instance 

beforeStart();	start();	try {	afterStart();	waitUntilCompleted();	internalBeforeStop();	beforeStop();	stop();	afterStop();	} catch (Exception e) {	
failed 

private void internalBeforeStop() {	try {	if (camelTemplate != null) {	ServiceHelper.stopService(camelTemplate);	camelTemplate = null;	}	} catch (Exception e) {	
error stopping cameltemplate due this exception is ignored 

protected void waitUntilCompleted() {	while (!completed.get()) {	try {	if (duration > 0) {	TimeUnit unit = getTimeUnit();	
waiting for 

protected void waitUntilCompleted() {	while (!completed.get()) {	try {	if (duration > 0) {	TimeUnit unit = getTimeUnit();	latch.await(duration, unit);	exitCode.compareAndSet(UNINITIALIZED_EXIT_CODE, durationHitExitCode);	completed.set(true);	} else if (durationIdle > 0) {	TimeUnit unit = getTimeUnit();	
waiting to be idle for 

TimeUnit unit = getTimeUnit();	latch.await(duration, unit);	exitCode.compareAndSet(UNINITIALIZED_EXIT_CODE, durationHitExitCode);	completed.set(true);	} else if (durationIdle > 0) {	TimeUnit unit = getTimeUnit();	exitCode.compareAndSet(UNINITIALIZED_EXIT_CODE, durationHitExitCode);	latch.await();	completed.set(true);	} else if (durationMaxMessages > 0) {	
waiting until messages has been processed 

public void run(String[] args) throws Exception {	parseArguments(args);	run();	
mainsupport exiting code 

}	if (fileWatchDirectory != null) {	ReloadStrategy reload = new FileWatcherReloadStrategy(fileWatchDirectory, fileWatchDirectoryRecursively);	camelContext.setReloadStrategy(reload);	camelContext.addService(reload);	Object managedObject = camelContext.getManagementStrategy().getManagementObjectStrategy().getManagedObjectForService(camelContext, reload);	if (managedObject == null) {	return;	}	if (camelContext.getManagementStrategy().isManaged(managedObject, null)) {	
the service is already managed 

Object managedObject = camelContext.getManagementStrategy().getManagementObjectStrategy().getManagedObjectForService(camelContext, reload);	if (managedObject == null) {	return;	}	if (camelContext.getManagementStrategy().isManaged(managedObject, null)) {	return;	}	try {	camelContext.getManagementStrategy().manageObject(managedObject);	} catch (Exception e) {	
could not register service as service mbean 

========================= camel sample_5597 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("direct:start") .to("activemq:topic:news?replyToType=Exclusive&replyTo=queue:back") .to("mock:result");	from("activemq:topic:news?disableReplyTo=true") .transform(body().prepend("Bye ")) .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String replyTo = exchange.getIn().getHeader("JMSReplyTo", String.class);	String cid = exchange.getIn().getHeader("JMSCorrelationID", String.class);	
replyto 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("direct:start") .to("activemq:topic:news?replyToType=Exclusive&replyTo=queue:back") .to("mock:result");	from("activemq:topic:news?disableReplyTo=true") .transform(body().prepend("Bye ")) .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String replyTo = exchange.getIn().getHeader("JMSReplyTo", String.class);	String cid = exchange.getIn().getHeader("JMSCorrelationID", String.class);	
correlationid 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("direct:start") .to("activemq:topic:news?replyToType=Exclusive&replyTo=queue:back") .to("mock:result");	from("activemq:topic:news?disableReplyTo=true") .transform(body().prepend("Bye ")) .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String replyTo = exchange.getIn().getHeader("JMSReplyTo", String.class);	String cid = exchange.getIn().getHeader("JMSCorrelationID", String.class);	if (replyTo != null && cid != null) {	Thread.sleep(1000);	
sending back reply message on 

========================= camel sample_7115 =========================

private ExecEndpoint createExecEndpoint(String uri) throws Exception {	
using exec endpoint uri 

========================= camel sample_12216 =========================

public Exchange add(final CamelContext camelContext, final String key, final Exchange exchange) {	
adding an exchange with id for key in a thread safe manner 

public void remove(CamelContext camelContext, String key, Exchange exchange) {	
removing an exchange with id for key 

public void confirm(CamelContext camelContext, String exchangeId) {	
confirming an exchange with id 

public Set<String> scan(CamelContext camelContext) {	
scanning for exchanges to recover in context 

public Set<String> scan(CamelContext camelContext) {	Set<String> scanned = Collections.unmodifiableSet(cache.keySet());	
found keys for exchanges to recover in context 

public Exchange recover(CamelContext camelContext, String exchangeId) {	
recovering an exchange with id 

========================= camel sample_13954 =========================

assertMockEndpointsSatisfied();	assertEquals(1, events.size());	ExchangeCompletedEvent event = (ExchangeCompletedEvent) events.get(0);	assertNotNull(event.getExchange());	assertNotNull(event.getExchange().getFromEndpoint());	assertEquals("direct: Date created = event.getExchange().getCreated();	assertNotNull(created);	Date now = new Date();	long elapsed = now.getTime() - created.getTime();	assertTrue("Should be > 400, was: " + elapsed, elapsed > 400);	
elapsed time in millis 

========================= camel sample_2747 =========================

public AbstractGitHubConsumer(GitHubEndpoint endpoint, Processor processor) throws Exception {	super(endpoint, processor);	this.endpoint = endpoint;	Registry registry = endpoint.getCamelContext().getRegistry();	Object service = registry.lookupByName(GitHubConstants.GITHUB_REPOSITORY_SERVICE);	if (service != null) {	
using repositoryservice found in registry 

========================= camel sample_14268 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("direct:start").to("restlet:http: from("restlet:http: .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String authorization = exchange.getIn().getHeader("Authorization", String.class);	
authorization header 

========================= camel sample_9234 =========================

private void analyzeServiceInterface(Class<?> serviceInterface) {	Method[] methods = serviceInterface.getMethods();	for (Method method : methods) {	MethodInfo info = analyzeMethod(method);	for (int i = 0; i < info.getIn().length; i++) {	TypeInfo ti = info.getIn()[i];	if (inTypeNameToQName.containsKey(ti.getTypeName())) {	if (ti.getTypeName() != null) {	if (!(ti.getTypeName().equals("javax.xml.ws.Holder")) && (!(inTypeNameToQName.get(ti.getTypeName()).equals(ti.getElName())))) {	
ambiguous qname mapping the type is already mapped to a qname in this context 

========================= camel sample_9664 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<FlatpackComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.flatpack.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.flatpack.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_763 =========================

protected void doStart() throws Exception {	
starting consumer for 

protected void doStop() throws Exception {	
stopping consumer for 

public void prepareShutdown(boolean suspendOnly, boolean forced) {	shutdownPending = true;	if (log.isDebugEnabled()) {	
preparing to shutdown waiting for threads to complete 

public void run() {	
kestrel poller is running 

} else {	target = endpoint.getQueue();	}	Exchanger exchanger = null;	while (isRunAllowed() && !shutdownPending) {	if (concurrent) {	try {	exchanger = exchangerQueue.take();	} catch (InterruptedException e) {	if (log.isDebugEnabled()) {	
interrupted are we stopping 

try {	exchanger = exchangerQueue.take();	} catch (InterruptedException e) {	if (log.isDebugEnabled()) {	}	continue;	}	}	Object value = null;	while (isRunAllowed() && !shutdownPending) {	
polling 

if (isRunAllowed() && !shutdownPending) {	if (endpoint.getConfiguration().getWaitTimeMs() > 0) {	} else {	try {	Thread.sleep(100);	} catch (InterruptedException ignored) {	}	}	}	}	
got object from 

} catch (InterruptedException ignored) {	}	}	}	}	if (concurrent) {	try {	exchanger.exchange(value);	} catch (InterruptedException e) {	if (log.isDebugEnabled()) {	
interrupted are we stopping 

getExceptionHandler().handleException("Error processing exchange", exchange, e);	} else {	getExceptionHandler().handleException(e);	}	}	} finally {	pendingExchangeCount.decrementAndGet();	}	}	}	
finished polling 

public void run() {	if (log.isTraceEnabled()) {	
is starting 

public void run() {	if (log.isTraceEnabled()) {	}	while (isRunAllowed() && !shutdownPending) {	try {	exchangerQueue.put(exchanger);	} catch (InterruptedException e) {	if (log.isDebugEnabled()) {	
interrupted are we stopping 

}	continue;	}	pendingExchangeCount.incrementAndGet();	try {	Object value;	try {	value = exchanger.exchange(this);	} catch (InterruptedException e) {	if (log.isDebugEnabled()) {	
interrupted are we stopping 

pendingExchangeCount.incrementAndGet();	try {	Object value;	try {	value = exchanger.exchange(this);	} catch (InterruptedException e) {	if (log.isDebugEnabled()) {	}	continue;	}	
got a value from the exchanger 

} else {	getExceptionHandler().handleException(e);	}	}	} finally {	pendingExchangeCount.decrementAndGet();	}	}	shutdownLatch.countDown();	if (log.isTraceEnabled()) {	
is finished 

========================= camel sample_8075 =========================

private void handleValueUpdate(final DataValue value) {	final Exchange exchange = getEndpoint().createExchange();	exchange.setIn(mapMessage(value));	try {	getAsyncProcessor().process(exchange);	} catch (final Exception e) {	
failed to process message 

========================= camel sample_17281 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<NettyHttpComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.netty-http.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.netty-http.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_626 =========================

public static void writeBody(IoSession session, Object body, Exchange exchange) throws CamelExchangeException {	WriteFuture future = session.write(body);	
waiting for write to complete for body using session 

========================= camel sample_7695 =========================

if (!headerFilterStrategy.applyFilterToCamelHeaders(name, value, exchange)) {	if ("subject".equalsIgnoreCase(name)) {	String subject = exchange.getContext().getTypeConverter().convertTo(String.class, value);	message.setSubject(subject);	} else if ("language".equalsIgnoreCase(name)) {	String language = exchange.getContext().getTypeConverter().convertTo(String.class, value);	message.setLanguage(language);	} else {	try {	JivePropertiesManager.addProperty(message, name, value);	
added property name value 

String subject = exchange.getContext().getTypeConverter().convertTo(String.class, value);	message.setSubject(subject);	} else if ("language".equalsIgnoreCase(name)) {	String language = exchange.getContext().getTypeConverter().convertTo(String.class, value);	message.setLanguage(language);	} else {	try {	JivePropertiesManager.addProperty(message, name, value);	} catch (IllegalArgumentException iae) {	if (LOG.isDebugEnabled()) {	
cannot add property to xmpp message due 

public void populateXmppStanza(Stanza stanza, Exchange exchange) {	Set<Map.Entry<String, Object>> entries = exchange.getIn().getHeaders().entrySet();	for (Map.Entry<String, Object> entry : entries) {	String name = entry.getKey();	Object value = entry.getValue();	if (!headerFilterStrategy.applyFilterToCamelHeaders(name, value, exchange)) {	try {	JivePropertiesManager.addProperty(stanza, name, value);	
added property name value 

public void populateXmppStanza(Stanza stanza, Exchange exchange) {	Set<Map.Entry<String, Object>> entries = exchange.getIn().getHeaders().entrySet();	for (Map.Entry<String, Object> entry : entries) {	String name = entry.getKey();	Object value = entry.getValue();	if (!headerFilterStrategy.applyFilterToCamelHeaders(name, value, exchange)) {	try {	JivePropertiesManager.addProperty(stanza, name, value);	} catch (IllegalArgumentException iae) {	
not adding property to xmpp message due to 

========================= camel sample_12596 =========================

PollingConsumer consumer;	Endpoint endpoint;	Object recipient = null;	try {	recipient = expression.evaluate(exchange, Object.class);	endpoint = resolveEndpoint(exchange, recipient);	consumer = consumerCache.acquirePollingConsumer(endpoint);	} catch (Throwable e) {	if (isIgnoreInvalidEndpoint()) {	if (LOG.isDebugEnabled()) {	
endpoint uri is invalid this exception will be ignored 

boolean bridgeErrorHandler = false;	if (delegate instanceof DefaultConsumer) {	ExceptionHandler handler = ((DefaultConsumer) delegate).getExceptionHandler();	if (handler instanceof BridgeExceptionHandlerToErrorHandler) {	bridgeErrorHandler = true;	}	}	Exchange resourceExchange;	try {	if (timeout < 0) {	
consumer receive 

ExceptionHandler handler = ((DefaultConsumer) delegate).getExceptionHandler();	if (handler instanceof BridgeExceptionHandlerToErrorHandler) {	bridgeErrorHandler = true;	}	}	Exchange resourceExchange;	try {	if (timeout < 0) {	resourceExchange = consumer.receive();	} else if (timeout == 0) {	
consumer receivenowait 

bridgeErrorHandler = true;	}	}	Exchange resourceExchange;	try {	if (timeout < 0) {	resourceExchange = consumer.receive();	} else if (timeout == 0) {	resourceExchange = consumer.receiveNoWait();	} else {	
consumer receive with timeout ms 

Exchange resourceExchange;	try {	if (timeout < 0) {	resourceExchange = consumer.receive();	} else if (timeout == 0) {	resourceExchange = consumer.receiveNoWait();	} else {	resourceExchange = consumer.receive(timeout);	}	if (resourceExchange == null) {	
consumer received no exchange 

try {	if (timeout < 0) {	resourceExchange = consumer.receive();	} else if (timeout == 0) {	resourceExchange = consumer.receiveNoWait();	} else {	resourceExchange = consumer.receive(timeout);	}	if (resourceExchange == null) {	} else {	
consumer received 

protected void doStart() throws Exception {	if (consumerCache == null) {	if (cacheSize < 0) {	consumerCache = new EmptyConsumerCache(this, camelContext);	
pollenrich is not using consumercache 

protected void doStart() throws Exception {	if (consumerCache == null) {	if (cacheSize < 0) {	consumerCache = new EmptyConsumerCache(this, camelContext);	} else if (cacheSize == 0) {	consumerCache = new ConsumerCache(this, camelContext);	
pollenrich using consumercache with default cache size 

========================= camel sample_4543 =========================

public void testAddNewRoute() throws Exception {	deleteDirectory("target/dummy");	createDirectory("target/dummy");	context.start();	assertEquals(0, context.getRoutes().size());	
copying file to target dummy 

from("direct:bar").routeId("bar").to("mock:foo");	}	});	context.start();	assertEquals(1, context.getRoutes().size());	getMockEndpoint("mock:bar").expectedMessageCount(0);	getMockEndpoint("mock:foo").expectedMessageCount(1);	template.sendBody("direct:bar", "Hello World");	assertMockEndpointsSatisfied();	resetMocks();	
copying file to target dummy 

context.getManagementStrategy().addEventNotifier(new EventNotifierSupport() {	public void notify(EventObject event) throws Exception {	latch.countDown();	}	public boolean isEnabled(EventObject event) {	return event instanceof RouteAddedEvent;	}	});	context.start();	assertEquals(0, context.getRoutes().size());	
copying file to target dummy 

}	});	context.start();	assertEquals(0, context.getRoutes().size());	FileUtil.copyFile(new File("src/test/resources/org/apache/camel/model/barRoute.xml"), new File("target/dummy/barRoute.xml"));	await().atMost(20, TimeUnit.SECONDS).untilAsserted(() -> assertEquals(1, context.getRoutes().size()));	getMockEndpoint("mock:bar").expectedMessageCount(1);	template.sendBody("direct:bar", "Hello World");	assertMockEndpointsSatisfied();	resetMocks();	
updating file in target dummy 

========================= camel sample_1311 =========================

public void testSocketReadOnClosedConnection() throws Exception {	final Thread acceptThread = new Thread() {	Logger log = LoggerFactory.getLogger("acceptThread");	public void run() {	boolean running = true;	try {	Socket echoSocket = serverSocket.accept();	
accepted connection 

echoSocket.setSoTimeout(2000);	while (echoSocket.isConnected() && !echoSocket.isClosed()) {	StringBuilder responseBuilder = new StringBuilder(500);	InputStream reader = echoSocket.getInputStream();	OutputStream writer = echoSocket.getOutputStream();	do {	int readByte = -1;	int available = -1;	try {	available = reader.available();	
inputstream available returned 

while (echoSocket.isConnected() && !echoSocket.isClosed()) {	StringBuilder responseBuilder = new StringBuilder(500);	InputStream reader = echoSocket.getInputStream();	OutputStream writer = echoSocket.getOutputStream();	do {	int readByte = -1;	int available = -1;	try {	available = reader.available();	readByte = reader.read();	
processing byte 

InputStream reader = echoSocket.getInputStream();	OutputStream writer = echoSocket.getOutputStream();	do {	int readByte = -1;	int available = -1;	try {	available = reader.available();	readByte = reader.read();	switch (readByte) {	case -1: if (echoSocket.isConnected() && !echoSocket.isClosed()) {	
available returned 

InputStream reader = echoSocket.getInputStream();	OutputStream writer = echoSocket.getOutputStream();	do {	int readByte = -1;	int available = -1;	try {	available = reader.available();	readByte = reader.read();	switch (readByte) {	case -1: if (echoSocket.isConnected() && !echoSocket.isClosed()) {	
socket claims to still be open but end of stream received closing echosocket 

int readByte = -1;	int available = -1;	try {	available = reader.available();	readByte = reader.read();	switch (readByte) {	case -1: if (echoSocket.isConnected() && !echoSocket.isClosed()) {	try {	echoSocket.close();	} catch (Exception ex) {	
exception encountered closing echosocket after end of stream received 

readByte = reader.read();	switch (readByte) {	case -1: if (echoSocket.isConnected() && !echoSocket.isClosed()) {	try {	echoSocket.close();	} catch (Exception ex) {	}	}	running = false;	break;	
complete message sending response 

running = false;	break;	byte[] response = responseBuilder.toString().getBytes();	responseBuilder.setLength(0);	writer.write(response, 0, response.length);	writer.write('\n');	break;	default: responseBuilder.append((char) readByte);	}	} catch (SocketTimeoutException timeoutEx) {	
timeout reading data available returned 

writer.write(response, 0, response.length);	writer.write('\n');	break;	default: responseBuilder.append((char) readByte);	}	} catch (SocketTimeoutException timeoutEx) {	}	} while (echoSocket.isConnected() && !echoSocket.isClosed());	}	} catch (IOException ioEx) {	
ioexception in run method 

}	} catch (SocketTimeoutException timeoutEx) {	}	} while (echoSocket.isConnected() && !echoSocket.isClosed());	}	} catch (IOException ioEx) {	} finally {	try {	serverSocket.close();	} catch (IOException ioEx) {	
exception encountered closing server socket 

}	} while (echoSocket.isConnected() && !echoSocket.isClosed());	}	} catch (IOException ioEx) {	} finally {	try {	serverSocket.close();	} catch (IOException ioEx) {	}	}	
finished processing connection 

} catch (IOException ioEx) {	}	}	}	};	acceptThread.start();	clientSocket = new Socket();	clientSocket.setSoTimeout(1000);	clientSocket.connect(serverSocket.getLocalSocketAddress(), 10000);	clientSocket.setTcpNoDelay(true);	
begining message send loop 

acceptThread.start();	clientSocket = new Socket();	clientSocket.setSoTimeout(1000);	clientSocket.connect(serverSocket.getLocalSocketAddress(), 10000);	clientSocket.setTcpNoDelay(true);	byte[] message = "Hello World".getBytes();	BufferedReader reader;	for (int i = 1; i <= messageCount; ++i) {	reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));	OutputStream writer = clientSocket.getOutputStream();	
sending payload 

clientSocket.setSoTimeout(1000);	clientSocket.connect(serverSocket.getLocalSocketAddress(), 10000);	clientSocket.setTcpNoDelay(true);	byte[] message = "Hello World".getBytes();	BufferedReader reader;	for (int i = 1; i <= messageCount; ++i) {	reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));	OutputStream writer = clientSocket.getOutputStream();	writer.write(message, 0, message.length);	writer.flush();	
sending terminator 

clientSocket.setTcpNoDelay(true);	byte[] message = "Hello World".getBytes();	BufferedReader reader;	for (int i = 1; i <= messageCount; ++i) {	reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));	OutputStream writer = clientSocket.getOutputStream();	writer.write(message, 0, message.length);	writer.flush();	writer.write('\n');	writer.flush();	
received response 

BufferedReader reader;	for (int i = 1; i <= messageCount; ++i) {	reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));	OutputStream writer = clientSocket.getOutputStream();	writer.write(message, 0, message.length);	writer.flush();	writer.write('\n');	writer.flush();	Thread.sleep(1000);	}	
message send loop complete closing connection 

reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));	OutputStream writer = clientSocket.getOutputStream();	writer.write(message, 0, message.length);	writer.flush();	writer.write('\n');	writer.flush();	Thread.sleep(1000);	}	clientSocket.getInputStream().close();	if (!clientSocket.isClosed()) {	
closing input stream didn t close socket 

writer.write(message, 0, message.length);	writer.flush();	writer.write('\n');	writer.flush();	Thread.sleep(1000);	}	clientSocket.getInputStream().close();	if (!clientSocket.isClosed()) {	clientSocket.close();	}	
sleeping 

public void testAvailableOnClosedConnection() throws Exception {	final Thread acceptThread = new Thread() {	Logger log = LoggerFactory.getLogger("acceptThread");	public void run() {	boolean running = true;	try {	Socket echoSocket = serverSocket.accept();	
accepted connection 

echoSocket.setSoTimeout(2000);	while (echoSocket.isConnected() && !echoSocket.isClosed()) {	StringBuilder responseBuilder = new StringBuilder(500);	InputStream reader = echoSocket.getInputStream();	OutputStream writer = echoSocket.getOutputStream();	do {	int readByte = -1;	int available = -1;	try {	available = reader.available();	
inputstream available returned 

while (echoSocket.isConnected() && !echoSocket.isClosed()) {	StringBuilder responseBuilder = new StringBuilder(500);	InputStream reader = echoSocket.getInputStream();	OutputStream writer = echoSocket.getOutputStream();	do {	int readByte = -1;	int available = -1;	try {	available = reader.available();	readByte = reader.read();	
processing byte 

InputStream reader = echoSocket.getInputStream();	OutputStream writer = echoSocket.getOutputStream();	do {	int readByte = -1;	int available = -1;	try {	available = reader.available();	readByte = reader.read();	switch (readByte) {	case -1: if (echoSocket.isConnected() && !echoSocket.isClosed()) {	
available returned 

InputStream reader = echoSocket.getInputStream();	OutputStream writer = echoSocket.getOutputStream();	do {	int readByte = -1;	int available = -1;	try {	available = reader.available();	readByte = reader.read();	switch (readByte) {	case -1: if (echoSocket.isConnected() && !echoSocket.isClosed()) {	
socket claims to still be open but end of stream received closing echosocket 

int readByte = -1;	int available = -1;	try {	available = reader.available();	readByte = reader.read();	switch (readByte) {	case -1: if (echoSocket.isConnected() && !echoSocket.isClosed()) {	try {	echoSocket.close();	} catch (Exception ex) {	
exception encountered closing echosocket after end of stream received 

readByte = reader.read();	switch (readByte) {	case -1: if (echoSocket.isConnected() && !echoSocket.isClosed()) {	try {	echoSocket.close();	} catch (Exception ex) {	}	}	running = false;	break;	
received escape closing connection 

case -1: if (echoSocket.isConnected() && !echoSocket.isClosed()) {	try {	echoSocket.close();	} catch (Exception ex) {	}	}	running = false;	break;	echoSocket.close();	break;	
complete message sending response 

echoSocket.close();	break;	byte[] response = responseBuilder.toString().getBytes();	responseBuilder.setLength(0);	writer.write(response, 0, response.length);	writer.write('\n');	break;	default: responseBuilder.append((char) readByte);	}	} catch (SocketTimeoutException timeoutEx) {	
timeout reading data available returned 

writer.write(response, 0, response.length);	writer.write('\n');	break;	default: responseBuilder.append((char) readByte);	}	} catch (SocketTimeoutException timeoutEx) {	}	} while (echoSocket.isConnected() && !echoSocket.isClosed());	}	} catch (IOException ioEx) {	
ioexception in run method 

}	} catch (SocketTimeoutException timeoutEx) {	}	} while (echoSocket.isConnected() && !echoSocket.isClosed());	}	} catch (IOException ioEx) {	} finally {	try {	serverSocket.close();	} catch (IOException ioEx) {	
exception encountered closing server socket 

}	} while (echoSocket.isConnected() && !echoSocket.isClosed());	}	} catch (IOException ioEx) {	} finally {	try {	serverSocket.close();	} catch (IOException ioEx) {	}	}	
finished processing connection 

} catch (IOException ioEx) {	}	}	}	};	acceptThread.start();	clientSocket = new Socket();	clientSocket.setSoTimeout(1000);	clientSocket.connect(serverSocket.getLocalSocketAddress(), 10000);	clientSocket.setTcpNoDelay(true);	
begining message send loop 

acceptThread.start();	clientSocket = new Socket();	clientSocket.setSoTimeout(1000);	clientSocket.connect(serverSocket.getLocalSocketAddress(), 10000);	clientSocket.setTcpNoDelay(true);	byte[] message = "Hello World".getBytes();	BufferedReader reader;	for (int i = 1; i <= messageCount; ++i) {	reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));	OutputStream writer = clientSocket.getOutputStream();	
sending payload 

clientSocket.setSoTimeout(1000);	clientSocket.connect(serverSocket.getLocalSocketAddress(), 10000);	clientSocket.setTcpNoDelay(true);	byte[] message = "Hello World".getBytes();	BufferedReader reader;	for (int i = 1; i <= messageCount; ++i) {	reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));	OutputStream writer = clientSocket.getOutputStream();	writer.write(message, 0, message.length);	writer.flush();	
sending terminator 

clientSocket.setTcpNoDelay(true);	byte[] message = "Hello World".getBytes();	BufferedReader reader;	for (int i = 1; i <= messageCount; ++i) {	reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));	OutputStream writer = clientSocket.getOutputStream();	writer.write(message, 0, message.length);	writer.flush();	writer.write('\n');	writer.flush();	
received response 

BufferedReader reader;	for (int i = 1; i <= messageCount; ++i) {	reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));	OutputStream writer = clientSocket.getOutputStream();	writer.write(message, 0, message.length);	writer.flush();	writer.write('\n');	writer.flush();	Thread.sleep(1000);	}	
message send loop complete closing connection 

BufferedReader reader;	for (int i = 1; i <= messageCount; ++i) {	reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));	OutputStream writer = clientSocket.getOutputStream();	writer.write(message, 0, message.length);	writer.flush();	writer.write('\n');	writer.flush();	Thread.sleep(1000);	}	
client socket available returned before close 

writer.flush();	writer.write('\n');	writer.flush();	Thread.sleep(1000);	}	byte[] buffer = new byte[0];	try {	clientSocket.getInputStream().read();	fail("read should have timed-out");	} catch (SocketTimeoutException timeoutEx) {	
client socket read timed out before close 

Thread.sleep(1000);	}	byte[] buffer = new byte[0];	try {	clientSocket.getInputStream().read();	fail("read should have timed-out");	} catch (SocketTimeoutException timeoutEx) {	}	clientSocket.getOutputStream().write(27);	Thread.sleep(1000);	
client socket available returned after close 

}	byte[] buffer = new byte[0];	try {	clientSocket.getInputStream().read();	fail("read should have timed-out");	} catch (SocketTimeoutException timeoutEx) {	}	clientSocket.getOutputStream().write(27);	Thread.sleep(1000);	buffer = new byte[0];	
client socket read returned after close 

try {	clientSocket.getInputStream().read();	fail("read should have timed-out");	} catch (SocketTimeoutException timeoutEx) {	}	clientSocket.getOutputStream().write(27);	Thread.sleep(1000);	buffer = new byte[0];	clientSocket.getInputStream().close();	if (!clientSocket.isClosed()) {	
closing input stream didn t close socket 

fail("read should have timed-out");	} catch (SocketTimeoutException timeoutEx) {	}	clientSocket.getOutputStream().write(27);	Thread.sleep(1000);	buffer = new byte[0];	clientSocket.getInputStream().close();	if (!clientSocket.isClosed()) {	clientSocket.close();	}	
sleeping 

========================= camel sample_13807 =========================

public void testHeaderPredicateFails() throws Exception {	MockEndpoint result = getMockEndpoint("mock:result");	result.message(0).header("sample.name").isEqualTo("shouldNotMatch");	template.sendBody("direct:start", "<sample><name>value</name></sample>");	try {	result.assertIsSatisfied();	fail("Should have failed this test!");	} catch (AssertionError e) {	
caught expected assertion failure 

========================= camel sample_3906 =========================

public void testRequestReplyWithConcurrent() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceivedInAnyOrder("Bye A", "Bye B", "Bye C", "Bye D", "Bye E");	
sending messages 

public void testRequestReplyWithConcurrent() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceivedInAnyOrder("Bye A", "Bye B", "Bye C", "Bye D", "Bye E");	template.sendBody("seda:start", "A");	template.sendBody("seda:start", "B");	template.sendBody("seda:start", "C");	template.sendBody("seda:start", "D");	template.sendBody("seda:start", "E");	
done sending messages 

========================= camel sample_7046 =========================

private void testPath(String pathSuffix) throws InterruptedException {	MockEndpoint mockEndpoint = getMockEndpoint("mock:" + pathSuffix);	mockEndpoint.expectedHeaderReceived(Exchange.HTTP_METHOD, "POST");	
number of exchanges in mock myapp 

========================= camel sample_13104 =========================

public MyListenerService() {	
instantiated service 

========================= camel sample_16306 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<RestSwaggerComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.rest-swagger.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.rest-swagger.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1192 =========================

public UnitTestResult executeTest(final ITestConfig config, String component) throws Exception {	
spring boot test configuration 

public UnitTestResult executeTest(final ITestConfig config, String component) throws Exception {	Pattern pattern = Pattern.compile(config.getUnitTestInclusionPattern());	
scaning the classpath for test classes 

Set<BeanDefinition> defs = scanner.findCandidateComponents(config.getUnitTestBasePackage());	List<String> testClasses = new LinkedList<>();	for (BeanDefinition bd : defs) {	testClasses.add(bd.getBeanClassName());	}	if (config.getUnitTestExclusionPattern() != null) {	Pattern exclusionPattern = Pattern.compile(config.getUnitTestExclusionPattern());	for (Iterator<String> it = testClasses.iterator(); it.hasNext();) {	String cn = it.next();	if (exclusionPattern.matcher(cn).matches()) {	
excluding test class 

if (exclusionPattern.matcher(cn).matches()) {	it.remove();	}	}	}	final List<Class<?>> classes = new ArrayList<>();	for (String cn : testClasses) {	try {	Class<?> clazz = Class.forName(cn);	if (isAdmissible(clazz)) {	
found admissible test class 

}	}	final List<Class<?>> classes = new ArrayList<>();	for (String cn : testClasses) {	try {	Class<?> clazz = Class.forName(cn);	if (isAdmissible(clazz)) {	classes.add(clazz);	}	} catch (Throwable t) {	
test class has thrown an exception during initialization 

}	}	final List<Class<?>> classes = new ArrayList<>();	for (String cn : testClasses) {	try {	Class<?> clazz = Class.forName(cn);	if (isAdmissible(clazz)) {	classes.add(clazz);	}	} catch (Throwable t) {	
exception for test cass is 

final List<Class<?>> classes = new ArrayList<>();	for (String cn : testClasses) {	try {	Class<?> clazz = Class.forName(cn);	if (isAdmissible(clazz)) {	classes.add(clazz);	}	} catch (Throwable t) {	}	}	
run junit tests on test classes 

} catch (Throwable t) {	}	}	JUnitCore runner = new JUnitCore();	runner.addListener(new RunListener() {	public void testStarted(Description description) throws Exception {	disableJmx(config.getJmxDisabledNames());	}	});	Result result = runner.run(classes.toArray(new Class[]{}));	
unit tests success test run failures ignored tests 

}	}	JUnitCore runner = new JUnitCore();	runner.addListener(new RunListener() {	public void testStarted(Description description) throws Exception {	disableJmx(config.getJmxDisabledNames());	}	});	Result result = runner.run(classes.toArray(new Class[]{}));	for (Failure f : result.getFailures()) {	
failed test description 

}	}	JUnitCore runner = new JUnitCore();	runner.addListener(new RunListener() {	public void testStarted(Description description) throws Exception {	disableJmx(config.getJmxDisabledNames());	}	});	Result result = runner.run(classes.toArray(new Class[]{}));	for (Failure f : result.getFailures()) {	
message 

}	JUnitCore runner = new JUnitCore();	runner.addListener(new RunListener() {	public void testStarted(Description description) throws Exception {	disableJmx(config.getJmxDisabledNames());	}	});	Result result = runner.run(classes.toArray(new Class[]{}));	for (Failure f : result.getFailures()) {	if (f.getException() != null) {	
exception thrown from test 

private void disableJmx(Set<String> disabledJmx) throws Exception {	
disabling jmx names 

private void disableJmx(Set<String> disabledJmx) throws Exception {	for (MBeanServer server : getMBeanServers()) {	for (String jmxName : disabledJmx) {	
disabling jmx query 

private void disableJmx(Set<String> disabledJmx) throws Exception {	for (MBeanServer server : getMBeanServers()) {	for (String jmxName : disabledJmx) {	ObjectName oName = new ObjectName(jmxName);	Set<ObjectName> names = new HashSet<>(server.queryNames(oName, null));	for (ObjectName name : names) {	
disabled jmx name 

========================= camel sample_5997 =========================

protected Endpoint createEndpoint(final String uri, final String remaining, final Map<String, Object> parameters) throws Exception {	
create endpoint uri remaining parameters 

protected abstract void applyDataModuleOptions(T2 options, Map<String, Object> parameters);	private T1 lookupConnection(final String fullUri, final Map<String, Object> parameters) throws Exception {	
parse connection 

protected abstract void applyDataModuleOptions(T2 options, Map<String, Object> parameters);	private T1 lookupConnection(final String fullUri, final Map<String, Object> parameters) throws Exception {	if (fullUri == null || fullUri.isEmpty()) {	throw new IllegalArgumentException("Invalid URI: " + fullUri);	}	final ConnectionId id = parseConnectionId(fullUri, parameters);	
parse connection fulluri 

protected abstract void applyDataModuleOptions(T2 options, Map<String, Object> parameters);	private T1 lookupConnection(final String fullUri, final Map<String, Object> parameters) throws Exception {	if (fullUri == null || fullUri.isEmpty()) {	throw new IllegalArgumentException("Invalid URI: " + fullUri);	}	final ConnectionId id = parseConnectionId(fullUri, parameters);	synchronized (this) {	
locating connection 

protected abstract void applyDataModuleOptions(T2 options, Map<String, Object> parameters);	private T1 lookupConnection(final String fullUri, final Map<String, Object> parameters) throws Exception {	if (fullUri == null || fullUri.isEmpty()) {	throw new IllegalArgumentException("Invalid URI: " + fullUri);	}	final ConnectionId id = parseConnectionId(fullUri, parameters);	synchronized (this) {	T1 connection = this.connections.get(id);	
result 

protected abstract void applyDataModuleOptions(T2 options, Map<String, Object> parameters);	private T1 lookupConnection(final String fullUri, final Map<String, Object> parameters) throws Exception {	if (fullUri == null || fullUri.isEmpty()) {	throw new IllegalArgumentException("Invalid URI: " + fullUri);	}	final ConnectionId id = parseConnectionId(fullUri, parameters);	synchronized (this) {	T1 connection = this.connections.get(id);	if (connection == null) {	final T2 options = parseOptions(id, parameters);	
creating new connection 

========================= camel sample_6712 =========================

public void testWSHttpCallEcho() throws Exception {	received.clear();	latch = new CountDownLatch(1);	AsyncHttpClient c = new DefaultAsyncHttpClient();	WebSocket websocket = c.prepareGet("ws: new WebSocketUpgradeHandler.Builder() .addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

assertEquals(1, received.size());	assertEquals("The bar has Beer", received.get(0));	websocket.close();	c.close();	received.clear();	latch = new CountDownLatch(1);	c = new DefaultAsyncHttpClient();	websocket = c.prepareGet("ws: new WebSocketUpgradeHandler.Builder() .addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

========================= camel sample_17452 =========================

public void testForwardingJmsMessageIgnoresHeadersMQDoesntLike() throws Exception {	MockEndpoint endpoint = getMockEndpoint("mock:result");	endpoint.expectedMessageCount(1);	Map<String, Object> headers = new HashMap<String, Object>();	headers.put("JMSXAppID", "ABC");	template.sendBodyAndHeaders("activemq:test.a", "Hello World!", headers);	endpoint.assertIsSatisfied();	Exchange exchange = endpoint.getReceivedExchanges().get(0);	Message in = exchange.getIn();	assertMessageHeader(in, "JMSXAppID", null);	
received message 

========================= camel sample_7103 =========================

private DirectVmConsumer awaitConsumer() throws InterruptedException {	DirectVmConsumer answer = null;	StopWatch watch = new StopWatch();	boolean done = false;	while (!done) {	Thread.sleep(500);	if (LOG.isDebugEnabled()) {	
waited for consumer to be ready 

========================= camel sample_4902 =========================

protected void doStop() throws Exception {	super.doStop();	
stopping kubernetes pods consumer 

========================= camel sample_13295 =========================

protected void doStop() throws Exception {	super.doStop();	if (resourceProxy != null) {	try {	WebClient.client(resourceProxy).close();	} catch (Exception e) {	
error closing linkedin rest proxy 

========================= camel sample_8864 =========================

private void safeCloseResultSet() {	try {	resultSet.close();	} catch (SQLException e) {	
error by closing result set 

private void safeCloseStatement() {	try {	statement.close();	} catch (SQLException e) {	
error by closing statement 

private void safeCloseConnection() {	try {	connection.close();	} catch (SQLException e) {	
error by closing connection 

========================= camel sample_14045 =========================

public void testDefaultTimeoutMapPurge() throws Exception {	DefaultTimeoutMap<String, Integer> map = new DefaultTimeoutMap<String, Integer>(executor, 100);	map.start();	assertTrue(map.currentTime() > 0);	assertEquals(0, map.size());	map.put("A", 123, 50);	assertEquals(1, map.size());	Thread.sleep(250);	if (map.size() > 0) {	
waiting extra due slow ci box 

public void testExecutor() throws Exception {	ScheduledExecutorService e = Executors.newScheduledThreadPool(2);	DefaultTimeoutMap<String, Integer> map = new DefaultTimeoutMap<String, Integer>(e, 50);	map.start();	assertEquals(50, map.getPurgePollTime());	map.put("A", 123, 100);	assertEquals(1, map.size());	Thread.sleep(250);	if (map.size() > 0) {	
waiting extra due slow ci box 

========================= camel sample_3681 =========================

protected void setUp() throws Exception {	utf = "ABC\u00e6".getBytes("utf-8");	deleteDirectory("target/charset");	createDirectory("target/charset/input");	
utf utf 

protected void setUp() throws Exception {	utf = "ABC\u00e6".getBytes("utf-8");	deleteDirectory("target/charset");	createDirectory("target/charset/input");	for (byte b : utf) {	
utf byte 

========================= camel sample_2993 =========================

final Producer producer;	final Endpoint endpoint;	Object recipient = null;	try {	recipient = expression.evaluate(exchange, Object.class);	endpoint = resolveEndpoint(exchange, recipient);	producer = producerCache.acquireProducer(endpoint);	} catch (Throwable e) {	if (isIgnoreInvalidEndpoint()) {	if (LOG.isDebugEnabled()) {	
endpoint uri is invalid this exception will be ignored 

}	exchange.setProperty(Exchange.TO_ENDPOINT, producer.getEndpoint().getEndpointUri());	try {	producerCache.releaseProducer(endpoint, producer);	} catch (Exception e) {	}	callback.done(false);	}	});	if (!sync) {	
processing exchangeid is continued being processed asynchronously 

try {	producerCache.releaseProducer(endpoint, producer);	} catch (Exception e) {	}	callback.done(false);	}	});	if (!sync) {	return false;	}	
processing exchangeid is continued being processed synchronously 

protected void doStart() throws Exception {	if (aggregationStrategy == null) {	aggregationStrategy = defaultAggregationStrategy();	}	if (aggregationStrategy instanceof CamelContextAware) {	((CamelContextAware) aggregationStrategy).setCamelContext(camelContext);	}	if (producerCache == null) {	if (cacheSize < 0) {	producerCache = new EmptyProducerCache(this, camelContext);	
enricher is not using producercache 

aggregationStrategy = defaultAggregationStrategy();	}	if (aggregationStrategy instanceof CamelContextAware) {	((CamelContextAware) aggregationStrategy).setCamelContext(camelContext);	}	if (producerCache == null) {	if (cacheSize < 0) {	producerCache = new EmptyProducerCache(this, camelContext);	} else if (cacheSize == 0) {	producerCache = new ProducerCache(this, camelContext);	
enricher using producercache with default cache size 

========================= camel sample_4514 =========================

protected RoutesBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	
caught error while performing task reason exception message stacktrace exception stacktrace 

public void process(Exchange exchange) throws Exception {	Exception ex = (Exception)exchange.getProperties().get(Exchange.EXCEPTION_CAUGHT);	
processing caught exception 

public void process(Exchange exchange) throws Exception {	Exception ex = (Exception)exchange.getProperties().get(Exchange.EXCEPTION_CAUGHT);	
attempting redelivery of handled exception with message 

========================= camel sample_8167 =========================

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyConcatFieldRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	
consumer 

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyConcatFieldRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	}	Assert.assertEquals("ftp:localhost:{{ftpPort}}/myapp?password=admin&username=admin", list.get(0).getElement());	list = CamelJavaParserHelper.parseCamelProducerUris(method, true, true);	for (ParserResult result : list) {	
producer 

========================= camel sample_221 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	getContext().setTracing(true);	from("direct:start").delay(10).to("mock:a"). process(new Processor() {	public void process(Exchange exchange) throws Exception {	
this is the processor being invoked between mock a and mock b 

========================= camel sample_3402 =========================

public void testWSHttpCall() throws Exception {	final List<String> received = new ArrayList<String>();	final CountDownLatch latch = new CountDownLatch(10);	AsyncHttpClient c = createAsyncHttpSSLClient();	WebSocket websocket = c.prepareGet("wss: new WebSocketUpgradeHandler.Builder() .addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

========================= camel sample_13153 =========================

public void initAnnotatedFields() {	for (Class<?> cl : models) {	List<Field> linkFields = new ArrayList<Field>();	if (LOG.isDebugEnabled()) {	
class retrieved 

public void initAnnotatedFields() {	for (Class<?> cl : models) {	List<Field> linkFields = new ArrayList<Field>();	if (LOG.isDebugEnabled()) {	}	for (Field field : cl.getDeclaredFields()) {	DataField dataField = field.getAnnotation(DataField.class);	if (dataField != null) {	if (LOG.isDebugEnabled()) {	
position defined in the class position field 

++numberMandatoryFields;	} else {	++numberOptionalFields;	}	dataFields.put(dataField.pos(), dataField);	annotatedFields.put(dataField.pos(), field);	}	Link linkField = field.getAnnotation(Link.class);	if (linkField != null) {	if (LOG.isDebugEnabled()) {	
class linked field 

if (LOG.isDebugEnabled()) {	}	linkFields.add(field);	}	}	if (!linkFields.isEmpty()) {	annotatedLinkFields.put(cl.getName(), linkFields);	}	totalFields = numberMandatoryFields + numberOptionalFields;	if (LOG.isDebugEnabled()) {	
number of optional fields 

if (LOG.isDebugEnabled()) {	}	linkFields.add(field);	}	}	if (!linkFields.isEmpty()) {	annotatedLinkFields.put(cl.getName(), linkFields);	}	totalFields = numberMandatoryFields + numberOptionalFields;	if (LOG.isDebugEnabled()) {	
number of mandatory fields 

if (LOG.isDebugEnabled()) {	}	linkFields.add(field);	}	}	if (!linkFields.isEmpty()) {	annotatedLinkFields.put(cl.getName(), linkFields);	}	totalFields = numberMandatoryFields + numberOptionalFields;	if (LOG.isDebugEnabled()) {	
total 

Object lengthObj =  lengthField.get(modelObj);	length = ((Integer)lengthObj).intValue();	}	if (length < 1 && delimiter == null && dataField.lengthPos() == 0) {	throw new IllegalArgumentException("Either length or delimiter must be specified for the field : " + dataField.toString());	}	if (offset - 1 <= -1) {	throw new IllegalArgumentException("Offset/Position of the field " + dataField.toString() + " cannot be negative");	}	if (dataField.pos() > offset) {	
skipping ahead chars 

}	if (dataField.required()) {	++counterMandatoryFields;	if (token.equals("")) {	throw new IllegalArgumentException("The mandatory field defined at the position " + pos + " is empty for the line: " + line);	}	}	field = annotatedFields.get(dataField.pos());	field.setAccessible(true);	if (LOG.isDebugEnabled()) {	
pos offset data field type 

m = ReflectionHelper.findMethod(clazz, methodName);	value = ObjectHelper.invokeMethod(m, value);	}	}	field.set(modelField, value);	++pos;	}	if (offset <= record.length() && !(record.substring(offset - 1, record.length())).trim().equals("") && !isIgnoreTrailingChars()) {	throw new IllegalArgumentException("Unexpected / unmapped characters found at the end of the fixed-length record at line : " + line);	}	
counter mandatory fields 

public String unbind(CamelContext camelContext, Map<String, Object> model) throws Exception {	StringBuilder buffer = new StringBuilder();	Map<Integer, List<String>> results = new HashMap<Integer, List<String>>();	for (Class<?> clazz : models) {	if (model.containsKey(clazz.getName())) {	Object obj = model.get(clazz.getName());	if (LOG.isDebugEnabled()) {	
model object class 

result = temp.toString();	} else if (result.length() > fieldLength) {	if (datafield.clip()) {	result = result.substring(0, fieldLength);	} else {	throw new IllegalArgumentException("Length for the " + field.getName() + " must not be larger than allowed, was: " + result.length() + ", allowed: " + fieldLength);	}	}	}	if (LOG.isDebugEnabled()) {	
value to be formatted position and its formatted value 

private void initFixedLengthRecordParameters() {	for (Class<?> cl : models) {	FixedLengthRecord record = cl.getAnnotation(FixedLengthRecord.class);	if (record != null) {	
fixed length record 

private void initFixedLengthRecordParameters() {	for (Class<?> cl : models) {	FixedLengthRecord record = cl.getAnnotation(FixedLengthRecord.class);	if (record != null) {	crlf = record.crlf();	
carriage return defined for the csv 

private void initFixedLengthRecordParameters() {	for (Class<?> cl : models) {	FixedLengthRecord record = cl.getAnnotation(FixedLengthRecord.class);	if (record != null) {	crlf = record.crlf();	eol = record.eol();	
eol end of line defined for the csv 

private void initFixedLengthRecordParameters() {	for (Class<?> cl : models) {	FixedLengthRecord record = cl.getAnnotation(FixedLengthRecord.class);	if (record != null) {	crlf = record.crlf();	eol = record.eol();	header =  record.header();	
header 

private void initFixedLengthRecordParameters() {	for (Class<?> cl : models) {	FixedLengthRecord record = cl.getAnnotation(FixedLengthRecord.class);	if (record != null) {	crlf = record.crlf();	eol = record.eol();	header =  record.header();	hasHeader = header != void.class;	
has header 

private void initFixedLengthRecordParameters() {	for (Class<?> cl : models) {	FixedLengthRecord record = cl.getAnnotation(FixedLengthRecord.class);	if (record != null) {	crlf = record.crlf();	eol = record.eol();	header =  record.header();	hasHeader = header != void.class;	skipHeader = record.skipHeader();	
skip header 

private void initFixedLengthRecordParameters() {	for (Class<?> cl : models) {	FixedLengthRecord record = cl.getAnnotation(FixedLengthRecord.class);	if (record != null) {	crlf = record.crlf();	eol = record.eol();	header =  record.header();	hasHeader = header != void.class;	skipHeader = record.skipHeader();	footer =  record.footer();	
footer 

for (Class<?> cl : models) {	FixedLengthRecord record = cl.getAnnotation(FixedLengthRecord.class);	if (record != null) {	crlf = record.crlf();	eol = record.eol();	header =  record.header();	hasHeader = header != void.class;	skipHeader = record.skipHeader();	footer =  record.footer();	hasFooter = record.footer() != void.class;	
has footer 

FixedLengthRecord record = cl.getAnnotation(FixedLengthRecord.class);	if (record != null) {	crlf = record.crlf();	eol = record.eol();	header =  record.header();	hasHeader = header != void.class;	skipHeader = record.skipHeader();	footer =  record.footer();	hasFooter = record.footer() != void.class;	skipFooter = record.skipFooter();	
skip footer 

if (record != null) {	crlf = record.crlf();	eol = record.eol();	header =  record.header();	hasHeader = header != void.class;	skipHeader = record.skipHeader();	footer =  record.footer();	hasFooter = record.footer() != void.class;	skipFooter = record.skipFooter();	isHeader = hasHeader ? cl.equals(header) : false;	
is header 

crlf = record.crlf();	eol = record.eol();	header =  record.header();	hasHeader = header != void.class;	skipHeader = record.skipHeader();	footer =  record.footer();	hasFooter = record.footer() != void.class;	skipFooter = record.skipFooter();	isHeader = hasHeader ? cl.equals(header) : false;	isFooter = hasFooter ? cl.equals(footer) : false;	
is footer 

eol = record.eol();	header =  record.header();	hasHeader = header != void.class;	skipHeader = record.skipHeader();	footer =  record.footer();	hasFooter = record.footer() != void.class;	skipFooter = record.skipFooter();	isHeader = hasHeader ? cl.equals(header) : false;	isFooter = hasFooter ? cl.equals(footer) : false;	paddingChar = record.paddingChar();	
padding char 

header =  record.header();	hasHeader = header != void.class;	skipHeader = record.skipHeader();	footer =  record.footer();	hasFooter = record.footer() != void.class;	skipFooter = record.skipFooter();	isHeader = hasHeader ? cl.equals(header) : false;	isFooter = hasFooter ? cl.equals(footer) : false;	paddingChar = record.paddingChar();	recordLength = record.length();	
length of the record 

hasHeader = header != void.class;	skipHeader = record.skipHeader();	footer =  record.footer();	hasFooter = record.footer() != void.class;	skipFooter = record.skipFooter();	isHeader = hasHeader ? cl.equals(header) : false;	isFooter = hasFooter ? cl.equals(footer) : false;	paddingChar = record.paddingChar();	recordLength = record.length();	ignoreTrailingChars = record.ignoreTrailingChars();	
ignore trailing chars 

skipHeader = record.skipHeader();	footer =  record.footer();	hasFooter = record.footer() != void.class;	skipFooter = record.skipFooter();	isHeader = hasHeader ? cl.equals(header) : false;	isFooter = hasFooter ? cl.equals(footer) : false;	paddingChar = record.paddingChar();	recordLength = record.length();	ignoreTrailingChars = record.ignoreTrailingChars();	ignoreMissingChars = record.ignoreMissingChars();	
enable ignore missing chars 

========================= camel sample_7441 =========================

public void testCreateFolder() throws Exception {	deleteTestFolder();	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.parentFolderId", "0");	headers.put("CamelBox.folderName", CAMEL_TEST_FOLDER);	testFolder = requestBodyAndHeaders("direct: assertNotNull("createFolder result", testFolder);	assertEquals("createFolder folder name", CAMEL_TEST_FOLDER, testFolder.getInfo().getName());	
createfolder 

public void testCreateFolderByPath() throws Exception {	deleteTestFolder();	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.parentFolderId", "0");	headers.put("CamelBox.path", new String[] {CAMEL_TEST_FOLDER});	testFolder = requestBodyAndHeaders("direct: assertNotNull("createFolder result", testFolder);	assertEquals("createFolder folder name", CAMEL_TEST_FOLDER, testFolder.getInfo().getName());	
createfolder 

public void testDeleteFolder() throws Exception {	requestBody("direct: BoxFolder rootFolder = BoxFolder.getRootFolder(getConnection());	Iterable<BoxItem.Info> it = rootFolder.search("^" + CAMEL_TEST_FOLDER + "$");	int searchResults = sizeOfIterable(it);	boolean exists = searchResults > 0 ? true : false;	assertEquals("deleteFolder exists", false, exists);	
deletefolder exists 

public void testCopyFolder() throws Exception {	com.box.sdk.BoxFolder result = null;	try {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.folderId", testFolder.getID());	headers.put("CamelBox.destinationFolderId", CAMEL_TEST_DESTINATION_FOLDER_ID);	headers.put("CamelBox.newName", CAMEL_TEST_COPY_FOLDER);	result = requestBodyAndHeaders("direct: assertNotNull("copyFolder result", result);	assertEquals("copyFolder folder name", CAMEL_TEST_COPY_FOLDER, result.getInfo().getName());	
copyfolder 

public void testCreateSharedLink() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.folderId", testFolder.getID());	headers.put("CamelBox.access", BoxSharedLink.Access.COLLABORATORS);	headers.put("CamelBox.unshareDate", null);	headers.put("CamelBox.permissions", new BoxSharedLink.Permissions());	final com.box.sdk.BoxSharedLink result = requestBodyAndHeaders("direct: headers);	assertNotNull("createFolderSharedLink result", result);	
createfoldersharedlink 

public void testGetFolder() throws Exception {	final com.box.sdk.BoxFolder result = requestBody("direct: assertNotNull("getFolder result", result);	assertEquals("getFolder folder id", testFolder.getID(), result.getID());	
getfolder 

public void testGetFolderInfo() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.folderId", testFolder.getID());	headers.put("CamelBox.fields", new String[] {"name"});	final com.box.sdk.BoxFolder.Info result = requestBodyAndHeaders("direct: assertNotNull("getFolderInfo result", result);	assertNotNull("getFolderInfo result.getName()", result.getName());	assertEquals("getFolderInfo info name", CAMEL_TEST_FOLDER, result.getName());	
getfolderinfo 

public void testGetFolderItems() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.folderId", CAMEL_TEST_ROOT_FOLDER_ID);	headers.put("CamelBox.offset", null);	headers.put("CamelBox.limit", null);	headers.put("CamelBox.fields", null);	final java.util.Collection result = requestBodyAndHeaders("direct: assertNotNull("getFolderItems result", result);	
getfolderitems 

public void testGetRootFolder() throws Exception {	final com.box.sdk.BoxFolder result = requestBody("direct: assertNotNull("getRootFolder result", result);	
getrootfolder 

public void testMoveFolder() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.folderId", testFolder.getID());	headers.put("CamelBox.destinationFolderId", CAMEL_TEST_DESTINATION_FOLDER_ID);	headers.put("CamelBox.newName", CAMEL_TEST_MOVE_FOLDER);	final com.box.sdk.BoxFolder result = requestBodyAndHeaders("direct: assertNotNull("moveFolder result", result);	assertEquals("moveFolder folder name", CAMEL_TEST_MOVE_FOLDER, result.getInfo().getName());	
movefolder 

public void testRenameFolder() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.folderId", testFolder.getID());	headers.put("CamelBox.newFolderName", CAMEL_TEST_RENAME_FOLDER);	final com.box.sdk.BoxFolder result = requestBodyAndHeaders("direct: assertNotNull("renameFolder result", result);	assertEquals("moveFolder folder name", CAMEL_TEST_RENAME_FOLDER, result.getInfo().getName());	
renamefolder 

public void testUpdateInfo() throws Exception {	final BoxFolder.Info testFolderInfo = testFolder.getInfo();	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.folderId", testFolder.getID());	testFolderInfo.setDescription(CAMEL_TEST_FOLDER_DESCRIPTION);	headers.put("CamelBox.info", testFolderInfo);	final com.box.sdk.BoxFolder result = requestBodyAndHeaders("direct: assertNotNull("updateInfo result", result);	assertEquals("update folder info description", CAMEL_TEST_FOLDER_DESCRIPTION, result.getInfo().getDescription());	
updateinfo 

========================= camel sample_17405 =========================

public void startThriftSecureClient() throws IOException, TTransportException {	if (transport == null) {	
connecting to the secured thrift server on port 

public void startThriftSecureClient() throws IOException, TTransportException {	if (transport == null) {	TSSLTransportFactory.TSSLTransportParameters sslParams = new TSSLTransportFactory.TSSLTransportParameters();	sslParams.setTrustStore(TRUST_STORE_PATH, SECURITY_STORE_PASSWORD);	transport = TSSLTransportFactory.getClientSocket("localhost", THRIFT_TEST_PORT, THRIFT_CLIENT_TIMEOUT, sslParams);	protocol = new TBinaryProtocol(transport);	thriftClient = new Calculator.Client(protocol);	
connected to the secured thrift server 

public void stopThriftClient() throws Exception {	if (transport != null) {	transport.close();	transport = null;	
connection to the thrift server closed 

public void testCalculateMethodInvocation() throws Exception {	
test calculate method invocation 

public void testEchoMethodInvocation() throws Exception {	
test echo method invocation 

========================= camel sample_13016 =========================

public void testCancel() throws Exception {	final com.braintreegateway.Result result = requestBody("direct: assertNotNull("cancel result", result);	
cancel 

public void testCreate() throws Exception {	final com.braintreegateway.Result result = requestBody("direct: assertNotNull("create result", result);	
create 

public void testDelete() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBraintree.customerId", null);	headers.put("CamelBraintree.id", null);	final com.braintreegateway.Result result = requestBodyAndHeaders("direct: assertNotNull("delete result", result);	
delete 

public void testFind() throws Exception {	final com.braintreegateway.Subscription result = requestBody("direct: assertNotNull("find result", result);	
find 

public void testRetryCharge() throws Exception {	final com.braintreegateway.Result result = requestBody("direct: assertNotNull("retryCharge result", result);	
retrycharge 

public void testRetryChargeWithAmount() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBraintree.subscriptionId", null);	headers.put("CamelBraintree.amount", null);	final com.braintreegateway.Result result = requestBodyAndHeaders("direct: assertNotNull("retryCharge result", result);	
retrycharge 

public void testSearch() throws Exception {	final com.braintreegateway.ResourceCollection result = requestBody("direct: assertNotNull("search result", result);	
search 

public void testUpdate() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBraintree.id", null);	headers.put("CamelBraintree.request", null);	final com.braintreegateway.Result result = requestBodyAndHeaders("direct: assertNotNull("update result", result);	
update 

========================= camel sample_17377 =========================

public void process(Exchange exchange) throws Exception {	String cacheKey = key.evaluate(exchange, String.class);	if (isValid(cacheManager, cacheName, cacheKey)) {	Ehcache cache = cacheManager.getCache(cacheName);	if (LOG.isDebugEnabled()) {	
replacing xpath value in message with value stored against key in cachename 

========================= camel sample_10518 =========================

if (endpoint.isPerformInvocation()) {	response = super.performInvocation(cxfExchange, serviceObject, method, paramArray);	}	paramArray = insertExchange(method, paramArray, cxfExchange);	OperationResourceInfo ori = cxfExchange.get(OperationResourceInfo.class);	if (ori.isSubResourceLocator()) {	return method.invoke(serviceObject, paramArray);	}	Continuation continuation;	if (!endpoint.isSynchronous() && (continuation = getContinuation(cxfExchange)) != null) {	
calling the camel async processors 

}	paramArray = insertExchange(method, paramArray, cxfExchange);	OperationResourceInfo ori = cxfExchange.get(OperationResourceInfo.class);	if (ori.isSubResourceLocator()) {	return method.invoke(serviceObject, paramArray);	}	Continuation continuation;	if (!endpoint.isSynchronous() && (continuation = getContinuation(cxfExchange)) != null) {	return asyncInvoke(cxfExchange, serviceObject, method, paramArray, continuation, response);	} else {	
calling the camel sync processors 

private Object asyncInvoke(Exchange cxfExchange, final Object serviceObject, Method method, Object[] paramArray, final Continuation continuation, Object response) throws Exception {	synchronized (continuation) {	if (continuation.isNew()) {	final org.apache.camel.Exchange camelExchange = prepareExchange(cxfExchange, method, paramArray, response);	cxfRsConsumer.createUoW(camelExchange);	
suspending continuation of exchangeid 

synchronized (continuation) {	if (continuation.isNew()) {	final org.apache.camel.Exchange camelExchange = prepareExchange(cxfExchange, method, paramArray, response);	cxfRsConsumer.createUoW(camelExchange);	continuation.suspend(endpoint.getContinuationTimeout());	cxfExchange.put(SUSPENED, Boolean.TRUE);	continuation.setObject(camelExchange);	cxfRsConsumer.getAsyncProcessor().process(camelExchange, new AsyncCallback() {	public void done(boolean doneSync) {	synchronized (continuation) {	
resuming continuation of exchangeid 

========================= camel sample_8029 =========================

public static void main(final String[] args) throws Exception {	File csvLogFile = new File(CSV_PATH);	if (csvLogFile.exists()) {	
removing log file 

public static void main(final String[] args) throws Exception {	File csvLogFile = new File(CSV_PATH);	if (csvLogFile.exists()) {	csvLogFile.delete();	}	
starting order camel route 

File csvLogFile = new File(CSV_PATH);	if (csvLogFile.exists()) {	csvLogFile.delete();	}	ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("META-INF/spring/camel-context.xml");	context.start();	CamelContext camelContext = context.getBean("order", CamelContext.class);	ProducerTemplate producer = camelContext.createProducerTemplate();	Thread.sleep(1000);	Order order = new Order() .setOrderId("Order-Java-0001") .setItemId("MILK") .setQuantity(3);	
sending to direct java 

csvLogFile.delete();	}	ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("META-INF/spring/camel-context.xml");	context.start();	CamelContext camelContext = context.getBean("order", CamelContext.class);	ProducerTemplate producer = camelContext.createProducerTemplate();	Thread.sleep(1000);	Order order = new Order() .setOrderId("Order-Java-0001") .setItemId("MILK") .setQuantity(3);	OrderResponse response = producer.requestBody("direct:java", order, OrderResponse.class);	Thread.sleep(1000);	
received 

csvLogFile.delete();	}	ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("META-INF/spring/camel-context.xml");	context.start();	CamelContext camelContext = context.getBean("order", CamelContext.class);	ProducerTemplate producer = camelContext.createProducerTemplate();	Thread.sleep(1000);	Order order = new Order() .setOrderId("Order-Java-0001") .setItemId("MILK") .setQuantity(3);	OrderResponse response = producer.requestBody("direct:java", order, OrderResponse.class);	Thread.sleep(1000);	
csv log now contains 

ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("META-INF/spring/camel-context.xml");	context.start();	CamelContext camelContext = context.getBean("order", CamelContext.class);	ProducerTemplate producer = camelContext.createProducerTemplate();	Thread.sleep(1000);	Order order = new Order() .setOrderId("Order-Java-0001") .setItemId("MILK") .setQuantity(3);	OrderResponse response = producer.requestBody("direct:java", order, OrderResponse.class);	Thread.sleep(1000);	Thread.sleep(1000);	String orderXml = "<order orderId=\"Order-XML-0001\" itemId=\"MIKAN\" quantity=\"365\"/>";	
sending to direct xml 

Thread.sleep(1000);	Order order = new Order() .setOrderId("Order-Java-0001") .setItemId("MILK") .setQuantity(3);	OrderResponse response = producer.requestBody("direct:java", order, OrderResponse.class);	Thread.sleep(1000);	Thread.sleep(1000);	String orderXml = "<order orderId=\"Order-XML-0001\" itemId=\"MIKAN\" quantity=\"365\"/>";	Exchange answerXml = producer.send("direct:xml", ex -> {	((DataTypeAware)ex.getIn()).setBody(orderXml, new DataType("xml:XMLOrder"));	});	Thread.sleep(1000);	
received 

Thread.sleep(1000);	Order order = new Order() .setOrderId("Order-Java-0001") .setItemId("MILK") .setQuantity(3);	OrderResponse response = producer.requestBody("direct:java", order, OrderResponse.class);	Thread.sleep(1000);	Thread.sleep(1000);	String orderXml = "<order orderId=\"Order-XML-0001\" itemId=\"MIKAN\" quantity=\"365\"/>";	Exchange answerXml = producer.send("direct:xml", ex -> {	((DataTypeAware)ex.getIn()).setBody(orderXml, new DataType("xml:XMLOrder"));	});	Thread.sleep(1000);	
csv log now contains 

OrderResponse response = producer.requestBody("direct:java", order, OrderResponse.class);	Thread.sleep(1000);	Thread.sleep(1000);	String orderXml = "<order orderId=\"Order-XML-0001\" itemId=\"MIKAN\" quantity=\"365\"/>";	Exchange answerXml = producer.send("direct:xml", ex -> {	((DataTypeAware)ex.getIn()).setBody(orderXml, new DataType("xml:XMLOrder"));	});	Thread.sleep(1000);	Thread.sleep(1000);	String orderJson = "{\"orderId\":\"Order-JSON-0001\", \"itemId\":\"MIZUYO-KAN\", \"quantity\":\"16350\"}";	
sending to direct json 

Exchange answerXml = producer.send("direct:xml", ex -> {	((DataTypeAware)ex.getIn()).setBody(orderXml, new DataType("xml:XMLOrder"));	});	Thread.sleep(1000);	Thread.sleep(1000);	String orderJson = "{\"orderId\":\"Order-JSON-0001\", \"itemId\":\"MIZUYO-KAN\", \"quantity\":\"16350\"}";	Exchange answerJson = producer.send("direct:json", ex -> {	((DataTypeAware)ex.getIn()).setBody(orderJson, new DataType("json"));	});	Thread.sleep(1000);	
received 

Exchange answerXml = producer.send("direct:xml", ex -> {	((DataTypeAware)ex.getIn()).setBody(orderXml, new DataType("xml:XMLOrder"));	});	Thread.sleep(1000);	Thread.sleep(1000);	String orderJson = "{\"orderId\":\"Order-JSON-0001\", \"itemId\":\"MIZUYO-KAN\", \"quantity\":\"16350\"}";	Exchange answerJson = producer.send("direct:json", ex -> {	((DataTypeAware)ex.getIn()).setBody(orderJson, new DataType("json"));	});	Thread.sleep(1000);	
csv log now contains 

========================= camel sample_17727 =========================

public void xxxtestTokenPairPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(5, TimeUnit.MINUTES);	
processed file with elements in 

public void xxxtestTokenPairPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(5, TimeUnit.MINUTES);	
processed tiny messages 

public void xxxtestTokenPairPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(5, TimeUnit.MINUTES);	
processed small messages 

public void xxxtestTokenPairPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(5, TimeUnit.MINUTES);	
processed medium messages 

public void xxxtestTokenPairPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(5, TimeUnit.MINUTES);	
processed large messages 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("file:target/data?initialDelay=0&delay=10&noop=true") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	
starting to process file 

from("file:target/data?initialDelay=0&delay=10&noop=true") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	watch.restart();	}	}) .split().tokenizeXML("order").streaming() .choice() .when().xpath("/order/amount < 10") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String xml = exchange.getIn().getBody(String.class);	assertTrue(xml, xml.contains("<amount>3</amount>"));	int num = tiny.incrementAndGet();	if (num % 100 == 0) {	
processed tiny messages 

if (num % 100 == 0) {	log.debug(xml);	}	}	}) .when().xpath("/order/amount < 50") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String xml = exchange.getIn().getBody(String.class);	assertTrue(xml, xml.contains("<amount>44</amount>"));	int num = small.incrementAndGet();	if (num % 100 == 0) {	
processed small messages 

if (num % 100 == 0) {	log.debug(xml);	}	}	}) .when().xpath("/order/amount < 100") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String xml = exchange.getIn().getBody(String.class);	assertTrue(xml, xml.contains("<amount>88</amount>"));	int num = med.incrementAndGet();	if (num % 100 == 0) {	
processed medium messages 

if (num % 100 == 0) {	log.debug(xml);	}	}	}) .otherwise() .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String xml = exchange.getIn().getBody(String.class);	assertTrue(xml, xml.contains("<amount>123</amount>"));	int num = large.incrementAndGet();	if (num % 100 == 0) {	
processed large messages 

========================= camel sample_3665 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() {	SchedulerComponent comp = context.getComponent("scheduler", SchedulerComponent.class);	comp.setConcurrentTasks(2);	from("scheduler: .process(new Processor() {	public void process(Exchange exchange) throws Exception {	if (sleep.compareAndSet(true, false)) {	
thread is sleeping 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() {	SchedulerComponent comp = context.getComponent("scheduler", SchedulerComponent.class);	comp.setConcurrentTasks(2);	from("scheduler: .process(new Processor() {	public void process(Exchange exchange) throws Exception {	if (sleep.compareAndSet(true, false)) {	Thread.sleep(1000);	
thread is done sleeping 

========================= camel sample_3370 =========================

protected void doGetNode(Exchange exchange, String operation) throws Exception {	Node node = null;	String pvName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NODE_NAME, String.class);	if (ObjectHelper.isEmpty(pvName)) {	
get a specific node require specify a node name 

========================= camel sample_13271 =========================

protected void doStart() throws Exception {	if (configuration.getClient() == null) {	configuration.createClient();	
producer dropbox client created 

protected void doStop() throws Exception {	if (configuration.getClient() == null) {	configuration.setClient(null);	
producer dropbox client deleted 

========================= camel sample_8496 =========================

protected void doStart() throws Exception {	if (sessionId.get() == null) {	client = configuration.createConsulClient(getCamelContext());	sessionClient = client.sessionClient();	keyValueClient = client.keyValueClient();	sessionId.set( sessionClient.createSession( ImmutableSession.builder() .name(getNamespace()) .ttl(configuration.getSessionTtl() + "s") .lockDelay(configuration.getSessionLockDelay() + "s") .build() ).getId() );	
acquired session with id 

protected void doStart() throws Exception {	if (sessionId.get() == null) {	client = configuration.createConsulClient(getCamelContext());	sessionClient = client.sessionClient();	keyValueClient = client.keyValueClient();	sessionId.set( sessionClient.createSession( ImmutableSession.builder() .name(getNamespace()) .ttl(configuration.getSessionTtl() + "s") .lockDelay(configuration.getSessionLockDelay() + "s") .build() ).getId() );	boolean lock = acquireLock();	
acquire lock on path with id result 

protected void doStop() throws Exception {	if (sessionId.get() != null) {	if (keyValueClient.releaseLock(this.path, sessionId.get())) {	
successfully released lock on path with id 

public void onComplete(ConsulResponse<com.google.common.base.Optional<Value>> consulResponse) {	if (isStarting() || isStarted()) {	com.google.common.base.Optional<Value> value = consulResponse.getResponse();	if (value.isPresent()) {	com.google.common.base.Optional<String> sid = value.get().getSession();	if (!sid.isPresent()) {	boolean lock = acquireLock();	
try to acquire lock on path with id result 

if (isStarting() || isStarted()) {	com.google.common.base.Optional<Value> value = consulResponse.getResponse();	if (value.isPresent()) {	com.google.common.base.Optional<String> sid = value.get().getSession();	if (!sid.isPresent()) {	boolean lock = acquireLock();	localMember.setMaster(lock);	} else {	boolean master = sid.get().equals(sessionId.get());	if (!master) {	
path is held by session local session is 

========================= camel sample_14367 =========================

return null;	}	try {	ASN1Primitive current = getNextEntry();	if (current != null) {	Message answer = new DefaultMessage(exchange.getContext());	answer.getHeaders().putAll(exchange.getIn().getHeaders());	answer.setBody(current.getEncoded());	return answer;	} else {	
close 

========================= camel sample_9454 =========================

private static boolean doNotifyEvent(EventNotifier notifier, EventObject event) {	boolean started = true;	if (notifier instanceof StatefulService) {	started = ((StatefulService) notifier).isStarted();	}	if (!started) {	
ignoring notifying event the eventnotifier has not been started yet 

private static boolean doNotifyEvent(EventNotifier notifier, EventObject event) {	boolean started = true;	if (notifier instanceof StatefulService) {	started = ((StatefulService) notifier).isStarted();	}	if (!started) {	return false;	}	if (!notifier.isEnabled(event)) {	
notifier is not enabled for the event 

}	if (!started) {	return false;	}	if (!notifier.isEnabled(event)) {	return false;	}	try {	notifier.notify(event);	} catch (Throwable e) {	
error notifying event this exception will be ignored 

========================= camel sample_4266 =========================

final Object body = undertowHttpBinding.toHttpRequest(request, camelExchange.getIn());	final TypeConverter tc = endpoint.getCamelContext().getTypeConverter();	final ByteBuffer bodyAsByte = tc.tryConvertTo(ByteBuffer.class, body);	if (body != null && bodyAsByte != null) {	requestHeaders.put(Headers.CONTENT_LENGTH, bodyAsByte.remaining());	}	for (final Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {	requestHeaders.putAll(HttpString.tryFromString(entry.getKey()), entry.getValue());	}	if (LOG.isDebugEnabled()) {	
executing http method 

final Xnio xnio = Xnio.getInstance();	worker = xnio.createWorker(options);	final SSLContext sslContext = getEndpoint().getSslContext();	if (sslContext != null) {	ssl = new UndertowXnioSsl(xnio, options, sslContext);	}	client = UndertowClient.getInstance();	if (endpoint.isWebSocket()) {	this.webSocketHandler = (CamelWebSocketHandler) endpoint.getComponent().registerEndpoint(endpoint.getHttpHandlerRegistrationInfo(), endpoint.getSslContext(), new CamelWebSocketHandler());	}	
created worker with options 

protected void doStop() throws Exception {	super.doStop();	if (endpoint.isWebSocket()) {	endpoint.getComponent().unregisterEndpoint(endpoint.getHttpHandlerRegistrationInfo(), endpoint.getSslContext());	}	if (worker != null && !worker.isShutdown()) {	
shutting down worker 

========================= camel sample_13158 =========================

public void onApplicationEvent(ContextRefreshedEvent event) {	ApplicationContext applicationContext = event.getApplicationContext();	if (this.applicationContext.equals(applicationContext)) {	CamelContext camelContext = event.getApplicationContext().getBean(CamelContext.class);	if (camelContext.getStatus().isStopped()) {	
post processing camelcontext bean 

public void onApplicationEvent(ContextRefreshedEvent event) {	ApplicationContext applicationContext = event.getApplicationContext();	if (this.applicationContext.equals(applicationContext)) {	CamelContext camelContext = event.getApplicationContext().getBean(CamelContext.class);	if (camelContext.getStatus().isStopped()) {	for (RoutesBuilder routesBuilder : configuration.routes()) {	boolean abs = Modifier.isAbstract(routesBuilder.getClass().getModifiers());	if (!abs) {	try {	
injecting following route into the camelcontext 

try {	camelContext.addRoutes(routesBuilder);	} catch (Exception e) {	throw new CamelSpringJavaconfigInitializationException(e);	}	}	}	try {	boolean skip = "true".equalsIgnoreCase(System.getProperty("skipStartingCamelContext"));	if (skip) {	
skipping starting camelcontext s as system property skipstartingcamelcontext is set to be true 

boolean skip = "true".equalsIgnoreCase(System.getProperty("skipStartingCamelContext"));	if (skip) {	} else {	camelContext.start();	}	} catch (Exception e) {	throw new CamelSpringJavaconfigInitializationException(e);	}	}	} else {	
ignore contextrefreshedevent 

========================= camel sample_10774 =========================

public void channelActive(ChannelHandlerContext ctx) throws Exception {	if (LOG.isTraceEnabled()) {	
channel open 

public void channelInactive(ChannelHandlerContext ctx) throws Exception {	if (LOG.isTraceEnabled()) {	
channel closed 

protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {	Object in = msg;	if (LOG.isDebugEnabled()) {	
channel received body 

private void sendResponse(Object message, ChannelHandlerContext ctx, Exchange exchange) throws Exception {	Object body = getResponseBody(exchange);	if (body == null) {	noReplyLogger.log("No payload to send as reply for exchange: " + exchange);	if (consumer.getConfiguration().isDisconnectOnNoReply()) {	if (LOG.isTraceEnabled()) {	
closing channel as no payload to send as reply at address 

========================= camel sample_10261 =========================

public boolean process(final Exchange exchange, final AsyncCallback callback) {	executor.submit(new Callable<Object>() {	public Object call() throws Exception {	
simulating a task which takes millis to reply 

public boolean process(final Exchange exchange, final AsyncCallback callback) {	executor.submit(new Callable<Object>() {	public Object call() throws Exception {	Thread.sleep(getEndpoint().getDelay());	int count = counter.incrementAndGet();	if (getEndpoint().getFailFirstAttempts() >= count) {	
simulating a failure at attempt 

public Object call() throws Exception {	Thread.sleep(getEndpoint().getDelay());	int count = counter.incrementAndGet();	if (getEndpoint().getFailFirstAttempts() >= count) {	exchange.setException(new CamelExchangeException("Simulated error at attempt " + count, exchange));	} else {	String reply = getEndpoint().getReply();	reply = getEndpoint().isAppend() ? exchange.getIn().getBody() + " " + reply : reply;	exchange.getOut().setBody(reply);	exchange.getOut().setHeaders(exchange.getIn().getHeaders());	
setting reply 

Thread.sleep(getEndpoint().getDelay());	int count = counter.incrementAndGet();	if (getEndpoint().getFailFirstAttempts() >= count) {	exchange.setException(new CamelExchangeException("Simulated error at attempt " + count, exchange));	} else {	String reply = getEndpoint().getReply();	reply = getEndpoint().isAppend() ? exchange.getIn().getBody() + " " + reply : reply;	exchange.getOut().setBody(reply);	exchange.getOut().setHeaders(exchange.getIn().getHeaders());	}	
callback done false 

} else {	String reply = getEndpoint().getReply();	reply = getEndpoint().isAppend() ? exchange.getIn().getBody() + " " + reply : reply;	exchange.getOut().setBody(reply);	exchange.getOut().setHeaders(exchange.getIn().getHeaders());	}	callback.done(false);	return null;	}	});	
task submitted now tell camel routing engine to that this exchange is being continued asynchronously 

========================= camel sample_1988 =========================

public void execute() {	DomainMetadataRequest request = new DomainMetadataRequest() .withDomainName(determineDomainName());	
sending request for exchange 

public void execute() {	DomainMetadataRequest request = new DomainMetadataRequest() .withDomainName(determineDomainName());	DomainMetadataResult result = this.sdbClient.domainMetadata(request);	
received result 

========================= camel sample_8750 =========================

public SecureRandom createSecureRandom() throws GeneralSecurityException {	
creating securerandom from securerandomparameters 

public SecureRandom createSecureRandom() throws GeneralSecurityException {	SecureRandom secureRandom;	if (this.getProvider() != null) {	secureRandom = SecureRandom.getInstance(this.parsePropertyValue(this.getAlgorithm()), this.parsePropertyValue(this.getProvider()));	} else {	secureRandom = SecureRandom.getInstance(this.parsePropertyValue(this.getAlgorithm()));	}	
securerandom is using provider and algorithm 

========================= camel sample_4289 =========================

private Repository getLocalRepository() throws IOException {	FileRepositoryBuilder builder = new FileRepositoryBuilder();	Repository repo = null;	try {	repo = builder.setGitDir(new File(endpoint.getLocalPath(), ".git")).readEnvironment() .findGitDir() .build();	} catch (IOException e) {	
there was an error cannot open repository 

========================= camel sample_9141 =========================

public void testFutureEcho() throws Exception {	Echo service = ProxyHelper.createProxy(context.getEndpoint("direct:echo"), Echo.class);	Future<String> future = service.asText(4);	
got future 

public void testFutureEcho() throws Exception {	Echo service = ProxyHelper.createProxy(context.getEndpoint("direct:echo"), Echo.class);	Future<String> future = service.asText(4);	
waiting for future to be done 

public void testFutureEchoCallTwoTimes() throws Exception {	Echo service = ProxyHelper.createProxy(context.getEndpoint("direct:echo"), Echo.class);	Future<String> future = service.asText(4);	
got future 

public void testFutureEchoCallTwoTimes() throws Exception {	Echo service = ProxyHelper.createProxy(context.getEndpoint("direct:echo"), Echo.class);	Future<String> future = service.asText(4);	
waiting for future to be done 

public void testFutureEchoCallTwoTimes() throws Exception {	Echo service = ProxyHelper.createProxy(context.getEndpoint("direct:echo"), Echo.class);	Future<String> future = service.asText(4);	assertEquals("Four", future.get(5, TimeUnit.SECONDS));	future = service.asText(5);	
got future 

public void testFutureEchoCallTwoTimes() throws Exception {	Echo service = ProxyHelper.createProxy(context.getEndpoint("direct:echo"), Echo.class);	Future<String> future = service.asText(4);	assertEquals("Four", future.get(5, TimeUnit.SECONDS));	future = service.asText(5);	
waiting for future to be done 

========================= camel sample_3262 =========================

public void testProxy() throws Exception {	send("http: StopWatch watch = new StopWatch();	
http log warn ms count watch taken 

========================= camel sample_6430 =========================

public static void main(String[] args) throws Exception {	
about to run splunk camel integration 

public static void main(String[] args) throws Exception {	CamelContext camelContext = new DefaultCamelContext();	camelContext.addRoutes(new SplunkPublishEventRouteBuilder());	ProducerTemplate eventProducer = camelContext.createProducerTemplate();	camelContext.start();	eventProducer.request("direct:start", new SplunkEventProcessor());	
successfully published event to splunk 

========================= camel sample_17770 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<JdbcComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jdbc.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jdbc.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_768 =========================

public String say() {	
invoking say method with message 

========================= camel sample_15608 =========================

answer.setTimeoutCheckerExecutorService(timeoutThreadPool);	answer.setShutdownTimeoutCheckerExecutorService(shutdownTimeoutThreadPool);	answer.setParallelProcessing(parallel);	if (getOptimisticLocking() != null) {	answer.setOptimisticLocking(getOptimisticLocking());	}	if (getCompletionPredicate() != null) {	Predicate predicate = getCompletionPredicate().createPredicate(routeContext);	answer.setCompletionPredicate(predicate);	} else if (strategy instanceof Predicate) {	
using aggregationstrategy as completion predicate 

========================= camel sample_5359 =========================

if (answer.contains(name) && port != null) {	answer = answer.replaceFirst(name, host + ":" + port);	}	if (answer.contains(name) && port == null) {	answer = answer.replaceFirst(name, host);	}	if (!answer.startsWith(scheme)) {	answer = scheme + ":" + answer;	}	}	
camel endpoint uri for calling service on server 

========================= camel sample_4118 =========================

public void process(Exchange exchange) throws Exception {	Message in = exchange.getIn();	
got event with body and action 

========================= camel sample_13226 =========================

String messageAsXml = MessageHelper.dumpAsXml(exchange.getIn(), true, 2, isBodyIncludeStreams(), isBodyIncludeFiles(), getBodyMaxChars());	long uid = debugCounter.incrementAndGet();	BacklogTracerEventMessage msg = new DefaultBacklogTracerEventMessage(uid, timestamp, routeId, toNode, exchangeId, messageAsXml);	suspendedBreakpointMessages.put(nodeId, msg);	final SuspendedExchange se = suspendedBreakpoints.get(nodeId);	if (se != null) {	logger.log("NodeBreakpoint at node " + toNode + " is waiting to continue for exchangeId: " + exchangeId);	try {	boolean hit = se.getLatch().await(fallbackTimeout, TimeUnit.SECONDS);	if (!hit) {	
nodebreakpoint at node timed out and is continued exchangeid 

String messageAsXml = MessageHelper.dumpAsXml(exchange.getIn(), true, 2, isBodyIncludeStreams(), isBodyIncludeFiles(), getBodyMaxChars());	long uid = debugCounter.incrementAndGet();	BacklogTracerEventMessage msg = new DefaultBacklogTracerEventMessage(uid, timestamp, routeId, toNode, exchangeId, messageAsXml);	suspendedBreakpointMessages.put(toNode, msg);	SuspendedExchange se = new SuspendedExchange(exchange, new CountDownLatch(1));	suspendedBreakpoints.put(toNode, se);	logger.log("StepBreakpoint at node " + toNode + " is waiting to continue for exchangeId: " + exchange.getExchangeId());	try {	boolean hit = se.getLatch().await(fallbackTimeout, TimeUnit.SECONDS);	if (!hit) {	
stepbreakpoint at node timed out and is continued exchangeid 

========================= camel sample_4548 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<XStreamDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.xstream.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.xstream.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_504 =========================

if (index != -1) {	path = uri.substring(index + 1);	index = path.indexOf('?');	if (index != -1) {	path = path.substring(0, index);	}	path = path.replaceAll(":", "");	try {	path = URLDecoder.decode(path, "UTF-8");	} catch (UnsupportedEncodingException e) {	
failed to decode url path ignoring exception 

========================= camel sample_8212 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<BonitaComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.bonita.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.bonita.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1199 =========================

if (!callback.await(API_TIMEOUT, TimeUnit.SECONDS)) {	throw new SalesforceException("API call timeout!", null);	}	final SalesforceException callbackException = callback.getException();	if (callbackException != null) {	throw callbackException;	}	QueryRecordsPushTopic records = OBJECT_MAPPER.readValue(callback.getResponse(), QueryRecordsPushTopic.class);	if (records.getTotalSize() == 1) {	PushTopic topic = records.getRecords().get(0);	
found existing topic 

topic.setDescription("Topic created by Camel Salesforce component");	topic.setNotifyForFields(config.getNotifyForFields());	if (preApi29) {	topic.setNotifyForOperations(config.getNotifyForOperations());	} else {	topic.setNotifyForOperationCreate(config.getNotifyForOperationCreate());	topic.setNotifyForOperationDelete(config.getNotifyForOperationDelete());	topic.setNotifyForOperationUndelete(config.getNotifyForOperationUndelete());	topic.setNotifyForOperationUpdate(config.getNotifyForOperationUpdate());	}	
creating topic 

private void updateTopic(String topicId) throws CamelException {	final String query = config.getSObjectQuery();	
updating topic with query 

========================= camel sample_14760 =========================

public void parseURI(URI uri, Map<String, Object> parameters, RouteboxComponent component) throws Exception {	String protocol = uri.getScheme();	if (!protocol.equalsIgnoreCase("routebox")) {	throw new IllegalArgumentException("Unrecognized protocol: " + protocol + " for uri: " + uri);	}	setUri(uri);	setAuthority(uri.getAuthority());	if (LOG.isTraceEnabled()) {	
authority 

innerContext = component.resolveAndRemoveReferenceParameter(parameters, "innerContext", CamelContext.class, new DefaultCamelContext());	}	} else {	innerContext = component.getCamelContext();	}	innerProducerTemplate = innerContext.createProducerTemplate();	setQueueSize(component.getAndRemoveParameter(parameters, "size", Integer.class, 0));	dispatchStrategy = component.resolveAndRemoveReferenceParameter(parameters, "dispatchStrategy", RouteboxDispatchStrategy.class, null);	dispatchMap = component.resolveAndRemoveReferenceParameter(parameters, "dispatchMap", HashMap.class, new HashMap<String, String>());	if (dispatchStrategy == null && dispatchMap == null) {	
no routebox dispatch map or strategy has been set routebox may not have more than one inner route 

========================= camel sample_14625 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<DockerComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.docker.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.docker.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_441 =========================

public String[] route(String body) {	
called with body 

========================= camel sample_2465 =========================

public void testCbr() throws Exception {	send("http: StopWatch watch = new StopWatch();	
http log warn ms count watch taken 

========================= camel sample_6426 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SjmsBatchComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.sjms-batch.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.sjms-batch.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1249 =========================

public void process(Exchange exchange) throws Exception {	Message in = exchange.getIn();	
got event with body and action 

========================= camel sample_13230 =========================

public static Predicate dropNonCoordinatorViews() {	return new Predicate() {	public boolean matches(Exchange exchange) {	Object body = exchange.getIn().getBody();	
filtering message 

public static Predicate dropNonCoordinatorViews() {	return new Predicate() {	public boolean matches(Exchange exchange) {	Object body = exchange.getIn().getBody();	if (body instanceof View) {	View view = (View) body;	Address coordinatorNodeAddress =  view.getMembers().get(COORDINATOR_NODE_INDEX);	Address channelAddress = exchange.getIn().getHeader(HEADER_JGROUPS_CHANNEL_ADDRESS, Address.class);	
comparing endpoint channel address against the coordinator node address 

public static Predicate dropNonCoordinatorViews() {	return new Predicate() {	public boolean matches(Exchange exchange) {	Object body = exchange.getIn().getBody();	if (body instanceof View) {	View view = (View) body;	Address coordinatorNodeAddress =  view.getMembers().get(COORDINATOR_NODE_INDEX);	Address channelAddress = exchange.getIn().getHeader(HEADER_JGROUPS_CHANNEL_ADDRESS, Address.class);	return channelAddress.equals(coordinatorNodeAddress);	}	
body is not an instance of org jgroups view skipping filter 

========================= camel sample_16931 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<MvelComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mvel.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mvel.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1025 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<RefComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ref.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ref.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_841 =========================

private void sendOutMessage(Exchange exchange) throws QFJException {	Message camelMessage = exchange.getOut();	quickfix.Message quickfixjMessage = camelMessage.getBody(quickfix.Message.class);	
sending fix message reply 

========================= camel sample_10670 =========================

}	if (System.getProperty(JmxSystemPropertyKeys.MANAGEMENT_NAME_PATTERN) != null) {	managementNamePattern = System.getProperty(JmxSystemPropertyKeys.MANAGEMENT_NAME_PATTERN);	values.put(JmxSystemPropertyKeys.MANAGEMENT_NAME_PATTERN, managementNamePattern);	}	if (System.getProperty(JmxSystemPropertyKeys.USE_HOST_IP_ADDRESS) != null) {	useHostIPAddress = Boolean.getBoolean(JmxSystemPropertyKeys.USE_HOST_IP_ADDRESS);	values.put(JmxSystemPropertyKeys.USE_HOST_IP_ADDRESS, useHostIPAddress);	}	if (!values.isEmpty()) {	
managementagent detected jvm system properties 

public void unregister(ObjectName name) throws JMException {	if (isRegistered(name)) {	ObjectName on = mbeansRegistered.remove(name);	server.unregisterMBean(on);	
unregistered mbean with objectname 

protected void doStart() throws Exception {	ObjectHelper.notNull(camelContext, "CamelContext");	if (server == null) {	finalizeSettings();	createMBeanServer();	}	assembler = camelContext.getManagementMBeanAssembler();	ServiceHelper.startService(assembler);	
starting jmx agent on server 

protected void doStop() throws Exception {	if (cs != null) {	try {	cs.stop();	
stopped jmx connector 

protected void doStop() throws Exception {	if (cs != null) {	try {	cs.stop();	} catch (IOException e) {	
error occurred during stopping jmxconnectorservice this exception will be ignored 

if (cs != null) {	try {	cs.stop();	} catch (IOException e) {	}	cs = null;	}	if (registry != null) {	try {	UnicastRemoteObject.unexportObject(registry, true);	
unexported jmx rmi registry 

try {	cs.stop();	} catch (IOException e) {	}	cs = null;	}	if (registry != null) {	try {	UnicastRemoteObject.unexportObject(registry, true);	} catch (NoSuchObjectException e) {	
error occurred while unexporting jmx rmi registry this exception will be ignored 

}	if (mbeansRegistered.isEmpty()) {	return;	}	ObjectName[] mBeans = mbeansRegistered.keySet().toArray(new ObjectName[mbeansRegistered.size()]);	int caught = 0;	for (ObjectName name : mBeans) {	try {	unregister(name);	} catch (Exception e) {	
exception unregistering mbean with name 

ObjectName[] mBeans = mbeansRegistered.keySet().toArray(new ObjectName[mbeansRegistered.size()]);	int caught = 0;	for (ObjectName name : mBeans) {	try {	unregister(name);	} catch (Exception e) {	caught++;	}	}	if (caught > 0) {	
a number of exceptions caught while unregistering mbeans during stop operation see info log for details 

private void registerMBeanWithServer(Object obj, ObjectName name, boolean forceRegistration) throws JMException {	boolean exists = isRegistered(name);	if (exists) {	if (forceRegistration) {	
forceregistration enabled unregistering existing mbean with objectname 

private void registerMBeanWithServer(Object obj, ObjectName name, boolean forceRegistration) throws JMException {	boolean exists = isRegistered(name);	if (exists) {	if (forceRegistration) {	server.unregisterMBean(name);	} else {	
mbean already registered with objectname 

private void registerMBeanWithServer(Object obj, ObjectName name, boolean forceRegistration) throws JMException {	boolean exists = isRegistered(name);	if (exists) {	if (forceRegistration) {	server.unregisterMBean(name);	} else {	}	}	ObjectInstance instance = null;	if (forceRegistration || !exists) {	
registering mbean with objectname 

server.unregisterMBean(name);	} else {	}	}	ObjectInstance instance = null;	if (forceRegistration || !exists) {	instance = server.registerMBean(obj, name);	}	if (instance != null) {	ObjectName registeredName = instance.getObjectName();	
registered mbean with objectname 

canAccessSystemProps = false;	}	if (canAccessSystemProps) {	try {	if (useHostIPAddress) {	hostName = InetAddress.getLocalHost().getHostAddress();	} else {	hostName = InetAddressUtil.getLocalHostName();	}	} catch (UnknownHostException uhe) {	
cannot determine localhost name or address using default 

}	} else {	hostName = DEFAULT_HOST;	}	server = findOrCreateMBeanServer();	try {	if (createConnector) {	createJmxConnector(hostName);	}	} catch (IOException ioe) {	
could not create and start jmx connector 

protected MBeanServer findOrCreateMBeanServer() {	if (usePlatformMBeanServer) {	return ManagementFactory.getPlatformMBeanServer();	}	List<MBeanServer> servers = MBeanServerFactory.findMBeanServer(null);	for (MBeanServer server : servers) {	
found mbeanserver with default domain 

protected void createJmxConnector(String host) throws IOException {	ObjectHelper.notEmpty(serviceUrlPath, "serviceUrlPath");	ObjectHelper.notNull(registryPort, "registryPort");	try {	registry = LocateRegistry.createRegistry(registryPort);	
created jmxconnector rmi registry on port 

final JMXServiceURL url;	if (connectorPort > 0) {	url = new JMXServiceURL("service:jmx:rmi: + ":" + registryPort + path);	} else {	url = new JMXServiceURL("service:jmx:rmi: }	cs = JMXConnectorServerFactory.newJMXConnectorServer(url, null, server);	String threadName = camelContext.getExecutorServiceManager().resolveThreadName("JMXConnector: " + url);	Thread thread = getCamelContext().getExecutorServiceManager().newThread(threadName, new Runnable() {	public void run() {	try {	
staring jmx connector thread to listen at 

if (connectorPort > 0) {	url = new JMXServiceURL("service:jmx:rmi: + ":" + registryPort + path);	} else {	url = new JMXServiceURL("service:jmx:rmi: }	cs = JMXConnectorServerFactory.newJMXConnectorServer(url, null, server);	String threadName = camelContext.getExecutorServiceManager().resolveThreadName("JMXConnector: " + url);	Thread thread = getCamelContext().getExecutorServiceManager().newThread(threadName, new Runnable() {	public void run() {	try {	cs.start();	
jmx connector thread started and listening at 

url = new JMXServiceURL("service:jmx:rmi: + ":" + registryPort + path);	} else {	url = new JMXServiceURL("service:jmx:rmi: }	cs = JMXConnectorServerFactory.newJMXConnectorServer(url, null, server);	String threadName = camelContext.getExecutorServiceManager().resolveThreadName("JMXConnector: " + url);	Thread thread = getCamelContext().getExecutorServiceManager().newThread(threadName, new Runnable() {	public void run() {	try {	cs.start();	} catch (IOException ioe) {	
could not start jmxconnector thread at jmx connector not in use 

========================= camel sample_4698 =========================

public static void startServer() throws Exception {	greeterImpl = new GreeterImpl();	String address = "http: endpoint = Endpoint.publish(address, greeterImpl);	
the ws endpoint is published 

========================= camel sample_6021 =========================

Integer dropletId = exchange.getIn().getHeader(DigitalOceanHeaders.DROPLET_ID, Integer.class);	String region = exchange.getIn().getHeader(DigitalOceanHeaders.REGION, String.class);	FloatingIP ip;	if (ObjectHelper.isNotEmpty(dropletId)) {	ip = getEndpoint().getDigitalOceanClient().createFloatingIP(dropletId);	} else if (ObjectHelper.isNotEmpty(region)) {	ip = getEndpoint().getDigitalOceanClient().createFloatingIP(region);	} else {	throw new IllegalArgumentException(DigitalOceanHeaders.DROPLET_ID + " or " + DigitalOceanHeaders.REGION + " must be specified");	}	
floatingip 

private void getFloatingIPs(Exchange exchange) throws Exception {	FloatingIPs ips = getEndpoint().getDigitalOceanClient().getAvailableFloatingIPs(configuration.getPage(), configuration.getPerPage());	
all floating ips page per page 

private void getFloatingIP(Exchange exchange) throws Exception {	String ipAddress = exchange.getIn().getHeader(DigitalOceanHeaders.FLOATING_IP_ADDRESS, String.class);	if (ObjectHelper.isEmpty(ipAddress)) {	throw new IllegalArgumentException(DigitalOceanHeaders.FLOATING_IP_ADDRESS + " must be specified");	}	FloatingIP ip = getEndpoint().getDigitalOceanClient().getFloatingIPInfo(ipAddress);	
floating ip 

private void deleteFloatingIP(Exchange exchange) throws Exception {	String ipAddress = exchange.getIn().getHeader(DigitalOceanHeaders.FLOATING_IP_ADDRESS, String.class);	if (ObjectHelper.isEmpty(ipAddress)) {	throw new IllegalArgumentException(DigitalOceanHeaders.FLOATING_IP_ADDRESS + " must be specified");	}	Delete delete = getEndpoint().getDigitalOceanClient().deleteFloatingIP(ipAddress);	
delete floating ip 

private void assignFloatingIPToDroplet(Exchange exchange) throws Exception {	Integer dropletId = exchange.getIn().getHeader(DigitalOceanHeaders.DROPLET_ID, Integer.class);	if (ObjectHelper.isEmpty(dropletId)) {	throw new IllegalArgumentException(DigitalOceanHeaders.DROPLET_ID + " must be specified");	}	String ipAddress = exchange.getIn().getHeader(DigitalOceanHeaders.FLOATING_IP_ADDRESS, String.class);	if (ObjectHelper.isEmpty(ipAddress)) {	throw new IllegalArgumentException(DigitalOceanHeaders.FLOATING_IP_ADDRESS + " must be specified");	}	Action action = getEndpoint().getDigitalOceanClient().assignFloatingIP(dropletId, ipAddress);	
assign floating ip to droplet 

private void unassignFloatingIP(Exchange exchange) throws Exception {	String ipAddress = exchange.getIn().getHeader(DigitalOceanHeaders.FLOATING_IP_ADDRESS, String.class);	if (ObjectHelper.isEmpty(ipAddress)) {	throw new IllegalArgumentException(DigitalOceanHeaders.FLOATING_IP_ADDRESS + " must be specified");	}	Action action = getEndpoint().getDigitalOceanClient().unassignFloatingIP(ipAddress);	
unassign floating ip 

private void getFloatingIPActions(Exchange exchange) throws Exception {	String ipAddress = exchange.getIn().getHeader(DigitalOceanHeaders.FLOATING_IP_ADDRESS, String.class);	if (ObjectHelper.isEmpty(ipAddress)) {	throw new IllegalArgumentException(DigitalOceanHeaders.FLOATING_IP_ADDRESS + " must be specified");	}	Actions actions = getEndpoint().getDigitalOceanClient().getAvailableFloatingIPActions(ipAddress, configuration.getPage(), configuration.getPerPage());	
actions for floatingip page per page 

========================= camel sample_8896 =========================

public void print(Doc doc, int copies, boolean sendToPrinter, String mimeType, String jobName) throws PrintException {	
print service 

public void print(Doc doc, int copies, boolean sendToPrinter, String mimeType, String jobName) throws PrintException {	
about to print copy s 

public void print(Doc doc, int copies, boolean sendToPrinter, String mimeType, String jobName) throws PrintException {	for (int i = 0; i < copies; i++) {	if (!sendToPrinter) {	
print flag is set to false this job will not be printed until this setting remains in effect please set the flag to true or remove the setting 

File file;	if (mimeType.equalsIgnoreCase("GIF") || mimeType.equalsIgnoreCase("RENDERABLE_IMAGE")) {	file = new File("./target/TestPrintJobNo" + i + "_" + UUID.randomUUID() + ".gif");	} else if (mimeType.equalsIgnoreCase("JPEG")) {	file = new File("./target/TestPrintJobNo" + i + "_" + UUID.randomUUID() + ".jpeg");	} else if (mimeType.equalsIgnoreCase("PDF")) {	file = new File("./target/TestPrintJobNo" + i + "_" + UUID.randomUUID() + ".pdf");	} else {	file = new File("./target/TestPrintJobNo" + i + "_" + UUID.randomUUID() + ".txt");	}	
writing print job to file 

try {	InputStream in = doc.getStreamForBytes();	FileOutputStream fos = new FileOutputStream(file);	IOHelper.copyAndCloseInput(in, fos);	IOHelper.close(fos);	} catch (Exception e) {	throw new PrintException("Error writing Document to the target file " + file.getAbsolutePath());	}	} else {	if (LOG.isDebugEnabled()) {	
issuing job to printer 

========================= camel sample_17224 =========================

public void consumerInjection(Method method, Object bean, String beanName) {	Consume consume = method.getAnnotation(Consume.class);	if (consume != null && matchContext(consume.context())) {	
creating a consumer for 

if (multipleConsumer || processor == null) {	processor = new SubscribeMethodProcessor(endpoint);	endpoint.getCamelContext().addService(processor, true);	processor.addMethod(bean, method, endpoint, predicate);	Consumer consumer = endpoint.createConsumer(processor);	startService(consumer, endpoint.getCamelContext(), bean, beanName);	} else {	processor.addMethod(bean, method, endpoint, predicate);	}	if (predicate != null) {	
subscribed method to consume from endpoint with predicate 

processor = new SubscribeMethodProcessor(endpoint);	endpoint.getCamelContext().addService(processor, true);	processor.addMethod(bean, method, endpoint, predicate);	Consumer consumer = endpoint.createConsumer(processor);	startService(consumer, endpoint.getCamelContext(), bean, beanName);	} else {	processor.addMethod(bean, method, endpoint, predicate);	}	if (predicate != null) {	} else {	
subscribed method to consume from endpoint 

protected void startService(Service service, CamelContext camelContext, Object bean, String beanName) throws Exception {	if (camelContext != null) {	camelContext.deferStartService(service, true);	} else {	ServiceHelper.startService(service);	}	boolean singleton = isSingleton(bean, beanName);	if (!singleton) {	
service is not singleton so you must remember to stop it manually 

========================= camel sample_4159 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KubernetesSecretsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-secrets.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-secrets.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_545 =========================

context.addService(service);	context.addRoutePolicyFactory(ClusteredRoutePolicyFactory.forNamespace("my-ns"));	context.addRoutes(new RouteBuilder() {	public void configure() throws Exception {	from("timer:atomix?delay=1s&period=1s") .routeId("route-" + address.port()) .log("From ${routeId}") .process(e -> contextLatch.countDown());	}	});	Thread.sleep(ThreadLocalRandom.current().nextInt(500));	context.start();	contextLatch.await();	
shutting down node 

========================= camel sample_10298 =========================

protected void doStart() throws Exception {	super.doStart();	transactionTemplate.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	try {	jdbcTemplate.execute(getTableExistsString());	
expected table for jdbcmessageidrepository exist 

protected void doStart() throws Exception {	super.doStart();	transactionTemplate.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	try {	jdbcTemplate.execute(getTableExistsString());	} catch (DataAccessException e) {	if (createTableIfNotExists) {	try {	
creating table for jdbcmessageidrepository because it doesn t exist 

protected void doStart() throws Exception {	super.doStart();	transactionTemplate.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	try {	jdbcTemplate.execute(getTableExistsString());	} catch (DataAccessException e) {	if (createTableIfNotExists) {	try {	jdbcTemplate.execute(getCreateString());	
table created with query 

super.doStart();	transactionTemplate.execute(new TransactionCallback<Boolean>() {	public Boolean doInTransaction(TransactionStatus status) {	try {	jdbcTemplate.execute(getTableExistsString());	} catch (DataAccessException e) {	if (createTableIfNotExists) {	try {	jdbcTemplate.execute(getCreateString());	} catch (DataAccessException dae) {	
can t create table for jdbcmessageidrepository with query because of this may be a permissions problem please create this table and try again 

========================= camel sample_9012 =========================

protected void initDozerBeanContainerAndMapper() throws Exception {	
configuring 

========================= camel sample_9442 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<XChangeComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.xchange.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.xchange.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1072 =========================

public InputStream getResourceAsInputStream() throws IOException {	InputStream is;	if (isContentCache()) {	synchronized (this) {	if (buffer == null) {	
reading resource into the content cache 

public InputStream getResourceAsInputStream() throws IOException {	InputStream is;	if (isContentCache()) {	synchronized (this) {	if (buffer == null) {	is = getResourceAsInputStreamWithoutCache();	buffer = IOConverter.toBytes(is);	IOHelper.close(is, resourceUri, log);	}	}	
using resource from the content cache 

public void clearContentCache() {	
clearing resource from the content cache 

========================= camel sample_4765 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<CwComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-cw.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-cw.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1137 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<WebsocketComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.websocket.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.websocket.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_953 =========================

public void execute() {	GetAttributesRequest request = new GetAttributesRequest() .withDomainName(determineDomainName()) .withItemName(determineItemName()) .withConsistentRead(determineConsistentRead()) .withAttributeNames(determineAttributeNames());	
sending request for exchange 

public void execute() {	GetAttributesRequest request = new GetAttributesRequest() .withDomainName(determineDomainName()) .withItemName(determineItemName()) .withConsistentRead(determineConsistentRead()) .withAttributeNames(determineAttributeNames());	GetAttributesResult result = this.sdbClient.getAttributes(request);	
received result 

========================= camel sample_8746 =========================

clientBuilder.setConnectionManagerShared(true);	}	if (!useSystemProperties) {	if (ObjectHelper.isNotEmpty(getCamelContext().getProperty("http.proxyHost")) && ObjectHelper.isNotEmpty(getCamelContext().getProperty("http.proxyPort"))) {	String host = getCamelContext().getProperty("http.proxyHost");	int port = Integer.parseInt(getCamelContext().getProperty("http.proxyPort"));	String scheme = getCamelContext().getProperty("http.proxyScheme");	if (scheme == null) {	scheme = HttpHelper.isSecureConnection(getEndpointUri()) ? "https" : "http";	}	
camelcontext properties http proxyhost http proxyport and http proxyscheme detected using http proxy host port scheme 

if (isAuthenticationPreemptive()) {	clientBuilder.addInterceptorFirst(new PreemptiveAuthInterceptor());	}	HttpClientConfigurer configurer = getHttpClientConfigurer();	if (configurer != null) {	configurer.configureHttpClient(clientBuilder);	}	if (isBridgeEndpoint()) {	clientBuilder.setDefaultCookieStore(new NoopCookieStore());	}	
setup the httpclientbuilder 

========================= camel sample_17048 =========================

} else {	useCdiMain = detectCDIOnClassPath();	}	boolean usingBlueprintMain;	if (useBlueprint != null) {	usingBlueprintMain = useBlueprint;	} else {	usingBlueprintMain = detectBlueprintOnClassPathOrBlueprintXMLFiles();	}	if (killAfter != -1) {	
warning killafter is now deprecated do you need it please comment on mexec 

}	if (!durationMaxMessages.equals("-1")) {	args.add("-dm");	args.add(durationMaxMessages);	}	if (arguments != null) {	args.addAll(Arrays.asList(arguments));	}	if (usingSpringJavaConfigureMain) {	mainClass = "org.apache.camel.spring.javaconfig.Main";	
using org apache camel spring javaconfig main to initiate a camelcontext 

args.add(durationMaxMessages);	}	if (arguments != null) {	args.addAll(Arrays.asList(arguments));	}	if (usingSpringJavaConfigureMain) {	mainClass = "org.apache.camel.spring.javaconfig.Main";	} else if (useCdiMain) {	mainClass = "org.apache.camel.cdi.Main";	extraPluginDependencyArtifactId = "camel-cdi";	
using to initiate a camelcontext 

mainClass = "org.apache.camel.test.blueprint.Main";	extraPluginDependencyArtifactId = "camel-test-blueprint";	if (configAdminPid != null) {	args.add("-pid");	args.add(configAdminPid);	}	if (configAdminFileName != null) {	args.add("-pf");	args.add(configAdminFileName);	}	
using org apache camel test blueprint main to initiate a camelcontext 

extraPluginDependencyArtifactId = "camel-test-blueprint";	if (configAdminPid != null) {	args.add("-pid");	args.add(configAdminPid);	}	if (configAdminFileName != null) {	args.add("-pf");	args.add(configAdminFileName);	}	} else if (mainClass != null) {	
using custom to initiate a camelcontext 

if (configAdminPid != null) {	args.add("-pid");	args.add(configAdminPid);	}	if (configAdminFileName != null) {	args.add("-pf");	args.add(configAdminFileName);	}	} else if (mainClass != null) {	} else {	
using org apache camel spring main to initiate a camelcontext 

msg.append(arguments[i]);	}	msg.append(")");	getLog().debug(msg);	}	IsolatedThreadGroup threadGroup = new IsolatedThreadGroup(mainClass /* name */);	final Thread bootstrapThread = new Thread(threadGroup, new Runnable() {	public void run() {	try {	beforeBootstrapCamel();	
starting camel 

IsolatedThreadGroup threadGroup = new IsolatedThreadGroup(mainClass /* name */);	final Thread bootstrapThread = new Thread(threadGroup, new Runnable() {	public void run() {	try {	beforeBootstrapCamel();	Method main = Thread.currentThread().getContextClassLoader() .loadClass(mainClass).getMethod("main", String[].class);	main.invoke(null, new Object[]{arguments});	afterBootstrapCamel();	} catch (Exception e) {	getLog().error("*************************************");	
error occurred while running main from 

getLog().error("*************************************");	Thread.currentThread().getThreadGroup().uncaughtException(Thread.currentThread(), e);	}	}	}, mainClass + ".main()");	bootstrapThread.setContextClassLoader(getClassLoader());	setSystemProperties();	bootstrapThread.start();	joinNonDaemonThreads(threadGroup);	if (keepAlive) {	
warning keepalive is now deprecated and obsolete do you need it please comment on mexec 

bootstrapThread.start();	joinNonDaemonThreads(threadGroup);	if (keepAlive) {	waitFor(0);	}	if (cleanupDaemonThreads) {	terminateThreads(threadGroup);	try {	threadGroup.destroy();	} catch (IllegalThreadStateException e) {	
couldn t destroy threadgroup 

}	boolean doLog = false;	synchronized (this) {	if (uncaughtException == null) {	uncaughtException = throwable;	} else {	doLog = true;	}	}	if (doLog) {	
an additional exception was thrown 

private void joinThread(Thread thread, long timeoutMsecs) {	try {	
joining on thread 

private void joinThread(Thread thread, long timeoutMsecs) {	try {	thread.join(timeoutMsecs);	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	
interrupted while joining against thread 

private void joinThread(Thread thread, long timeoutMsecs) {	try {	thread.join(timeoutMsecs);	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	}	if (thread.isAlive()) {	
thread was interrupted but is still alive after waiting at least msecs 

private void terminateThreads(ThreadGroup threadGroup) {	long startTime = System.currentTimeMillis();	Set<Thread> uncooperativeThreads = new HashSet<Thread>();	for (Collection<Thread> threads = getActiveThreads(threadGroup); !threads.isEmpty(); threads = getActiveThreads(threadGroup), threads .removeAll(uncooperativeThreads)) {	for (Thread thread : threads) {	
interrupting thread 

}	long timeout = daemonThreadJoinTimeout - (System.currentTimeMillis() - startTime);	if (timeout > 0) {	joinThread(thread, timeout);	}	if (!thread.isAlive()) {	continue;	}	uncooperativeThreads.add(thread);	if (stopUnresponsiveDaemonThreads) {	
thread will be thread stop ed 

if (timeout > 0) {	joinThread(thread, timeout);	}	if (!thread.isAlive()) {	continue;	}	uncooperativeThreads.add(thread);	if (stopUnresponsiveDaemonThreads) {	thread.stop();	} else {	
thread will linger despite being asked to die via interruption 

continue;	}	uncooperativeThreads.add(thread);	if (stopUnresponsiveDaemonThreads) {	thread.stop();	} else {	}	}	}	if (!uncooperativeThreads.isEmpty()) {	
note thread s did not finish despite being asked to via interruption this is not a problem with exec java it is a problem with the running code although not serious it should be remedied 

}	}	}	if (!uncooperativeThreads.isEmpty()) {	} else {	int activeCount = threadGroup.activeCount();	if (activeCount != 0) {	Thread[] threadsArray = new Thread[1];	threadGroup.enumerate(threadsArray);	if (getLog().isDebugEnabled()) {	
strange thread s still active in the group such as 

private boolean detectCDIOnClassPath() {	List<Dependency> deps = project.getCompileDependencies();	for (Dependency dep : deps) {	if ("org.apache.camel".equals(dep.getGroupId()) && "camel-cdi".equals(dep.getArtifactId())) {	
camel cdi detected on classpath 

private boolean detectBlueprintOnClassPathOrBlueprintXMLFiles() {	List<Dependency> deps = project.getCompileDependencies();	for (Dependency dep : deps) {	if ("org.apache.camel".equals(dep.getGroupId()) && "camel-blueprint".equals(dep.getArtifactId())) {	
camel blueprint detected on classpath 

List<Dependency> deps = project.getCompileDependencies();	for (Dependency dep : deps) {	if ("org.apache.camel".equals(dep.getGroupId()) && "camel-blueprint".equals(dep.getArtifactId())) {	}	}	List<Resource> resources = project.getResources();	for (Resource res : resources) {	File dir = new File(res.getDirectory());	File xml = new File(dir, "OSGI-INF/blueprint");	if (xml.exists() && xml.isDirectory()) {	
osgi blueprint xml files detected in directory 

private ClassLoader getClassLoader() throws MojoExecutionException {	Set<URL> classpathURLs = new LinkedHashSet<URL>();	this.addRelevantProjectDependenciesToClasspath(classpathURLs);	this.addExtraPluginDependenciesToClasspath(classpathURLs);	this.addRelevantPluginDependenciesToClasspath(classpathURLs);	if (logClasspath) {	
classpath 

private void addRelevantPluginDependenciesToClasspath(Set<URL> path) throws MojoExecutionException {	if (hasCommandlineArgs()) {	arguments = parseCommandlineArgs();	}	try {	Iterator<Artifact> iter = this.determineRelevantPluginDependencies().iterator();	while (iter.hasNext()) {	Artifact classPathElement = iter.next();	if (classPathElement.getArtifactId().equals("org.osgi.core")) {	if (getLog().isDebugEnabled()) {	
skipping org osgi core 

}	try {	Iterator<Artifact> iter = this.determineRelevantPluginDependencies().iterator();	while (iter.hasNext()) {	Artifact classPathElement = iter.next();	if (classPathElement.getArtifactId().equals("org.osgi.core")) {	if (getLog().isDebugEnabled()) {	}	continue;	}	
adding plugin dependency artifact to classpath 

private void addExtraPluginDependenciesToClasspath(Set<URL> path) throws MojoExecutionException {	if (extraPluginDependencyArtifactId == null && extendedPluginDependencyArtifactId == null) {	return;	}	try {	Set<Artifact> artifacts = new HashSet<Artifact>(this.pluginDependencies);	for (Artifact artifact : artifacts) {	if (artifact.getArtifactId().equals(extraPluginDependencyArtifactId) || artifact.getArtifactId().equals(extendedPluginDependencyArtifactId)) {	
adding extra plugin dependency artifact to classpath 

return;	}	try {	Set<Artifact> artifacts = new HashSet<Artifact>(this.pluginDependencies);	for (Artifact artifact : artifacts) {	if (artifact.getArtifactId().equals(extraPluginDependencyArtifactId) || artifact.getArtifactId().equals(extendedPluginDependencyArtifactId)) {	path.add(artifact.getFile().toURI().toURL());	Set<Artifact> deps = resolveExecutableDependencies(artifact, true);	if (deps != null) {	for (Artifact dep : deps) {	
adding extra plugin dependency artifact to classpath 

private void addRelevantProjectDependenciesToClasspath(Set<URL> path) throws MojoExecutionException {	if (this.includeProjectDependencies) {	try {	
project dependencies will be included 

private void addRelevantProjectDependenciesToClasspath(Set<URL> path) throws MojoExecutionException {	if (this.includeProjectDependencies) {	try {	URL mainClasses = new File(project.getBuild().getOutputDirectory()).toURI().toURL();	
adding to classpath 

private void addRelevantProjectDependenciesToClasspath(Set<URL> path) throws MojoExecutionException {	if (this.includeProjectDependencies) {	try {	URL mainClasses = new File(project.getBuild().getOutputDirectory()).toURI().toURL();	path.add(mainClasses);	Set<Artifact> dependencies = CastUtils.cast(project.getArtifacts());	dependencies.addAll(getAllNonTestScopedDependencies());	Iterator<Artifact> iter = dependencies.iterator();	while (iter.hasNext()) {	Artifact classPathElement = iter.next();	
adding project dependency artifact to classpath 

Artifact classPathElement = iter.next();	File file = classPathElement.getFile();	if (file != null) {	path.add(file.toURI().toURL());	}	}	} catch (MalformedURLException e) {	throw new MojoExecutionException("Error during setting up classpath", e);	}	} else {	
project dependencies will be excluded 

private Set<Artifact> determineRelevantPluginDependencies() throws MojoExecutionException {	Set<Artifact> relevantDependencies;	if (this.includePluginDependencies) {	if (this.executableDependency == null) {	
all plugin dependencies will be included 

private Set<Artifact> determineRelevantPluginDependencies() throws MojoExecutionException {	Set<Artifact> relevantDependencies;	if (this.includePluginDependencies) {	if (this.executableDependency == null) {	relevantDependencies = new HashSet<Artifact>(this.pluginDependencies);	} else {	
selected plugin dependencies will be included 

Set<Artifact> relevantDependencies;	if (this.includePluginDependencies) {	if (this.executableDependency == null) {	relevantDependencies = new HashSet<Artifact>(this.pluginDependencies);	} else {	Artifact executableArtifact = this.findExecutableArtifact();	Artifact executablePomArtifact = this.getExecutablePomArtifact(executableArtifact);	relevantDependencies = this.resolveExecutableDependencies(executablePomArtifact, false);	}	} else {	
only direct plugin dependencies will be included 

Set<Artifact> executableDependencies = null;	try {	MavenProject executableProject = this.projectBuilder.buildFromRepository(executablePomArtifact, this.remoteRepositories, this.localRepository);	List<Artifact> dependencies = CastUtils.cast(executableProject.getDependencies());	Set<Artifact> dependencyArtifacts = CastUtils.cast(MavenMetadataSource.createArtifacts(this.artifactFactory, dependencies, null, null, null));	dependencyArtifacts.add(executableProject.getArtifact());	ArtifactResolutionResult result = artifactResolver.resolveTransitively(dependencyArtifacts, executablePomArtifact, Collections.emptyMap(), this.localRepository, this.remoteRepositories, metadataSource, new ScopeArtifactFilter(Artifact.SCOPE_RUNTIME), Collections.emptyList());	executableDependencies = CastUtils.cast(result.getArtifacts());	} catch (Exception ex) {	if (ignoreFailures) {	
ignoring maven resolving dependencies failure 

private void waitFor(long millis) {	Object lock = new Object();	synchronized (lock) {	try {	lock.wait(millis);	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	
spuriously interrupted while waiting for ms 

========================= camel sample_67 =========================

public void process(Exchange exchange) throws Exception {	String eventName = getEventName(exchange);	String version = getVersion(exchange);	
scheduleactivity 

========================= camel sample_8802 =========================

public void testJavaTransformer() throws Exception {	MockEndpoint abcresult = getMockEndpoint("mock:abcresult");	abcresult.expectedMessageCount(1);	abcresult.whenAnyExchangeReceived(new Processor() {	public void process(Exchange exchange) throws Exception {	
asserting string xorderresponse convertion 

abcresult.expectedMessageCount(1);	abcresult.whenAnyExchangeReceived(new Processor() {	public void process(Exchange exchange) throws Exception {	assertEquals(XOrderResponse.class, exchange.getIn().getBody().getClass());	}	});	MockEndpoint xyzresult = getMockEndpoint("mock:xyzresult");	xyzresult.expectedMessageCount(1);	xyzresult.whenAnyExchangeReceived(new Processor() {	public void process(Exchange exchange) throws Exception {	
asserting string xorderresponse convertion is not yet performed 

public void testDataFormatTransformer() throws Exception {	MockEndpoint xyzresult = getMockEndpoint("mock:xyzresult");	xyzresult.expectedMessageCount(1);	xyzresult.whenAnyExchangeReceived(new Processor() {	public void process(Exchange exchange) throws Exception {	
asserting string xorderresponse convertion is not yet performed 

public void testEndpointTransformer() throws Exception {	MockEndpoint xyzresult = getMockEndpoint("mock:xyzresult");	xyzresult.expectedMessageCount(1);	xyzresult.whenAnyExchangeReceived(new Processor() {	public void process(Exchange exchange) throws Exception {	
asserting string xorderresponse convertion is not yet performed 

public void testCustomTransformer() throws Exception {	MockEndpoint xyzresult = getMockEndpoint("mock:xyzresult");	xyzresult.expectedMessageCount(1);	xyzresult.whenAnyExchangeReceived(new Processor() {	public void process(Exchange exchange) throws Exception {	
asserting string xorderresponse convertion is not yet performed 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	context.getTypeConverterRegistry().addTypeConverters(new MyTypeConverters());	from("direct:abc") .inputType(AOrder.class) .outputType(AOrderResponse.class) .process(new Processor() {	public void process(Exchange exchange) throws Exception {	
asserting input aorder convertion 

return new RouteBuilder() {	public void configure() throws Exception {	context.getTypeConverterRegistry().addTypeConverters(new MyTypeConverters());	from("direct:abc") .inputType(AOrder.class) .outputType(AOrderResponse.class) .process(new Processor() {	public void process(Exchange exchange) throws Exception {	assertEquals(AOrder.class, exchange.getIn().getBody().getClass());	}	}) .inOut("direct:xyz") .to("mock:abcresult");	from("direct:xyz") .inputType(XOrder.class) .outputType(XOrderResponse.class) .process(new Processor() {	public void process(Exchange exchange) throws Exception {	
asserting input xorder convertion 

public AOrder toAOrder(String order) {	
typeconverter string aorder 

public XOrder toXOrder(AOrder aorder) {	
typeconverter aorder xorder 

public XOrderResponse toXOrderResponse(String res) {	
typeconverter string xorderresponse 

public AOrderResponse toAOrderResponse(XOrderResponse xres) {	
typeconverter xorderresponse aorderresponse 

private DataFormat createDataFormat() {	return new DataFormat() {	public void marshal(Exchange exchange, Object graph, OutputStream stream) throws Exception {	assertEquals(graph.toString(), XOrderResponse.class, graph.getClass());	
dataformat xorderresponse json 

}	public Object unmarshal(Exchange exchange, InputStream stream) throws Exception {	BufferedReader reader = new BufferedReader(new InputStreamReader(stream));	String line = "";	String input = "";	while ((line = reader.readLine()) != null) {	input += line;	}	reader.close();	assertEquals("{name:XOrder}", input);	
dataformat json xorder 

public Producer createProducer() throws Exception {	return new DefaultAsyncProducer(this) {	public boolean process(Exchange exchange, AsyncCallback callback) {	Object input = exchange.getIn().getBody();	if (input instanceof XOrderResponse) {	
endpoint xorderresponse xml 

public Producer createProducer() throws Exception {	return new DefaultAsyncProducer(this) {	public boolean process(Exchange exchange, AsyncCallback callback) {	Object input = exchange.getIn().getBody();	if (input instanceof XOrderResponse) {	exchange.getIn().setBody("<XOrderResponse/>");	} else {	assertEquals("<XOrder/>", input);	
endpoint xml xorder 

public void transform(Message message, DataType from, DataType to) throws Exception {	assertEquals("name=XOrder", message.getBody());	
bean other xorder 

public void transform(Message message, DataType from, DataType to) throws Exception {	
bean xorderresponse other 

========================= camel sample_1320 =========================

private void createWriter(ProducerType producerType) {	switch (producerType) {	case TCP: {	
creating tcpdatawriter 

private void createWriter(ProducerType producerType) {	switch (producerType) {	case TCP: {	dataWriter = new TcpDataWriter(endpoint, buildSplunkArgs());	((TcpDataWriter)dataWriter).setPort(endpoint.getConfiguration().getTcpReceiverPort());	
tcpdatawriter created for endpoint 

private void createWriter(ProducerType producerType) {	switch (producerType) {	case TCP: {	dataWriter = new TcpDataWriter(endpoint, buildSplunkArgs());	((TcpDataWriter)dataWriter).setPort(endpoint.getConfiguration().getTcpReceiverPort());	break;	}	case SUBMIT: {	
creating submitdatawriter 

private void createWriter(ProducerType producerType) {	switch (producerType) {	case TCP: {	dataWriter = new TcpDataWriter(endpoint, buildSplunkArgs());	((TcpDataWriter)dataWriter).setPort(endpoint.getConfiguration().getTcpReceiverPort());	break;	}	case SUBMIT: {	dataWriter = new SubmitDataWriter(endpoint, buildSplunkArgs());	((SubmitDataWriter)dataWriter).setIndex(endpoint.getConfiguration().getIndex());	
submitdatawriter created for endpoint 

dataWriter = new TcpDataWriter(endpoint, buildSplunkArgs());	((TcpDataWriter)dataWriter).setPort(endpoint.getConfiguration().getTcpReceiverPort());	break;	}	case SUBMIT: {	dataWriter = new SubmitDataWriter(endpoint, buildSplunkArgs());	((SubmitDataWriter)dataWriter).setIndex(endpoint.getConfiguration().getIndex());	break;	}	case STREAM: {	
creating streamdatawriter 

break;	}	case SUBMIT: {	dataWriter = new SubmitDataWriter(endpoint, buildSplunkArgs());	((SubmitDataWriter)dataWriter).setIndex(endpoint.getConfiguration().getIndex());	break;	}	case STREAM: {	dataWriter = new StreamDataWriter(endpoint, buildSplunkArgs());	((StreamDataWriter)dataWriter).setIndex(endpoint.getConfiguration().getIndex());	
streamdatawriter created for endpoint 

========================= camel sample_14473 =========================

public void testFutureList() throws Exception {	Users service = ProxyHelper.createProxy(context.getEndpoint("direct:echo"), Users.class);	Future<List<String>> future = service.getUsers(true);	
got future 

public void testFutureList() throws Exception {	Users service = ProxyHelper.createProxy(context.getEndpoint("direct:echo"), Users.class);	Future<List<String>> future = service.getUsers(true);	assertFalse("Should not be done", future.isDone());	
waiting for future to be done 

public void testFutureListCallTwoTimes() throws Exception {	Users service = ProxyHelper.createProxy(context.getEndpoint("direct:echo"), Users.class);	Future<List<String>> future = service.getUsers(true);	
got future 

public void testFutureListCallTwoTimes() throws Exception {	Users service = ProxyHelper.createProxy(context.getEndpoint("direct:echo"), Users.class);	Future<List<String>> future = service.getUsers(true);	assertFalse("Should not be done", future.isDone());	
waiting for future to be done 

public void testFutureListCallTwoTimes() throws Exception {	Users service = ProxyHelper.createProxy(context.getEndpoint("direct:echo"), Users.class);	Future<List<String>> future = service.getUsers(true);	assertFalse("Should not be done", future.isDone());	List<String> users = future.get(2, TimeUnit.SECONDS);	assertEquals("Claus", users.get(0));	assertEquals("Jonathan", users.get(1));	future = service.getUsers(true);	
got future 

public void testFutureListCallTwoTimes() throws Exception {	Users service = ProxyHelper.createProxy(context.getEndpoint("direct:echo"), Users.class);	Future<List<String>> future = service.getUsers(true);	assertFalse("Should not be done", future.isDone());	List<String> users = future.get(2, TimeUnit.SECONDS);	assertEquals("Claus", users.get(0));	assertEquals("Jonathan", users.get(1));	future = service.getUsers(true);	assertFalse("Should not be done", future.isDone());	
waiting for future to be done 

========================= camel sample_3258 =========================

protected void checkWeatherContent(String weather) {	
the weather in format is 

========================= camel sample_11364 =========================

public static Field findConfigurationField(EndpointConfiguration config, String name) {	if (config != null && name != null) {	Class<?> clazz = config.getClass();	Field[] fields = clazz.getDeclaredFields();	Field found;	URIField anno;	for (final Field field : fields) {	anno = field.getAnnotation(URIField.class);	if (anno == null ? field.getName().equals(name) : anno.component().equals(name) || (anno.component().equals(EndpointConfiguration.URI_QUERY) && anno.parameter().equals(name))) {	found = field;	
found field as candidate for parameter 

========================= camel sample_4067 =========================

public void testLoadAndRecoverHawtDBAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(SIZE / 10);	mock.setResultWaitTime(50 * 1000);	
staring to send messages 

public void testLoadAndRecoverHawtDBAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(SIZE / 10);	mock.setResultWaitTime(50 * 1000);	for (int i = 0; i < SIZE; i++) {	final int value = 1;	char id = 'A';	Map<String, Object> headers = new HashMap<String, Object>();	headers.put("id", id);	headers.put("seq", i);	
sending with id 

mock.setResultWaitTime(50 * 1000);	for (int i = 0; i < SIZE; i++) {	final int value = 1;	char id = 'A';	Map<String, Object> headers = new HashMap<String, Object>();	headers.put("id", id);	headers.put("seq", i);	template.sendBodyAndHeaders("seda:start", value, headers);	Thread.sleep(5);	}	
sending all message done now waiting for aggregation to complete 

========================= camel sample_11734 =========================

result.whenAnyExchangeReceived(new Processor() {	public void process(Exchange exchange) throws Exception {	String msg = exchange.getIn().getBody(String.class);	exchange.setException(new ThrottlingException(msg));	}	});	sendMessage("Message One");	sendMessage("Message Two");	final ServiceSupport consumer = (ServiceSupport) context.getRoute("foo").getConsumer();	await().atMost(2, TimeUnit.SECONDS).until(consumer::isSuspended);	
sending message three 

sendMessage("Message Two");	final ServiceSupport consumer = (ServiceSupport) context.getRoute("foo").getConsumer();	await().atMost(2, TimeUnit.SECONDS).until(consumer::isSuspended);	sendMessage("Message Three");	assertMockEndpointsSatisfied();	result.reset();	result.expectedMessageCount(1);	bodies = Arrays.asList("Message Four");	result.expectedBodiesReceivedInAnyOrder(bodies);	await().atMost(2, TimeUnit.SECONDS).until(consumer::isStarted);	
sending message four 

protected void sendMessage(String bodyText) {	try {	template.sendBody(url, bodyText);	} catch (Exception e) {	
error sending 

========================= camel sample_2449 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<BrowseComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.browse.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.browse.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_882 =========================

public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent channelStateEvent) throws Exception {	if (LOG.isTraceEnabled()) {	
channel open 

public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent exceptionEvent) throws Exception {	if (LOG.isTraceEnabled()) {	
exception caught at channel 

public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent exceptionEvent) throws Exception {	if (LOG.isTraceEnabled()) {	}	if (exceptionHandled) {	return;	}	exceptionHandled = true;	Throwable cause = exceptionEvent.getCause();	if (LOG.isDebugEnabled()) {	
closing channel as an exception was thrown from netty 

public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {	if (LOG.isTraceEnabled()) {	
channel closed 

if (LOG.isTraceEnabled()) {	}	Exchange exchange = getExchange(ctx);	AsyncCallback callback = getAsyncCallback(ctx);	producer.removeState(ctx.getChannel());	producer.getAllChannels().remove(ctx.getChannel());	boolean doneUoW = exchange.getUnitOfWork() == null;	if (producer.getConfiguration().isSync() && !doneUoW && !messageReceived && !exceptionHandled) {	exceptionHandled = true;	if (LOG.isDebugEnabled()) {	
channel closed but no message received from address 

public void messageReceived(ChannelHandlerContext ctx, MessageEvent messageEvent) throws Exception {	messageReceived = true;	if (LOG.isTraceEnabled()) {	
message received 

public void messageReceived(ChannelHandlerContext ctx, MessageEvent messageEvent) throws Exception {	messageReceived = true;	if (LOG.isTraceEnabled()) {	}	ChannelHandler handler = ctx.getPipeline().get("timeout");	if (handler != null) {	
removing timeout channel as we received message 

}	if (close == null) {	close = exchange.getProperty(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);	}	boolean disconnect = producer.getConfiguration().isDisconnect();	if (close != null) {	disconnect = close;	}	if (disconnect) {	if (LOG.isTraceEnabled()) {	
closing channel when complete at address 

protected Message getResponseMessage(Exchange exchange, MessageEvent messageEvent) throws Exception {	Object body = messageEvent.getMessage();	if (LOG.isDebugEnabled()) {	
channel received body 

========================= camel sample_6689 =========================

public void foo(@Simple("${header.foo}") String bar) {	this.bar = bar;	
foo method called with 

public void foo(@Simple("${header.foo}") String bar) {	this.bar = bar;	
foo method called with 

========================= camel sample_3171 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<RedisComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.spring-redis.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.spring-redis.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_928 =========================

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MySimpleToDRoute.java"));	MethodSource<JavaClassSource> method = CamelJavaParserHelper.findConfigureMethod(clazz);	List<CamelEndpointDetails> details = new ArrayList<>();	RouteBuilderParser.parseRouteBuilderEndpoints(clazz, ".", "src/test/java/org/apache/camel/parser/java/MySimpleToDRoute.java", details);	LOG.info("{}", details);	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	
consumer 

MethodSource<JavaClassSource> method = CamelJavaParserHelper.findConfigureMethod(clazz);	List<CamelEndpointDetails> details = new ArrayList<>();	RouteBuilderParser.parseRouteBuilderEndpoints(clazz, ".", "src/test/java/org/apache/camel/parser/java/MySimpleToDRoute.java", details);	LOG.info("{}", details);	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	}	Assert.assertEquals("direct:start", list.get(0).getElement());	list = CamelJavaParserHelper.parseCamelProducerUris(method, true, true);	for (ParserResult result : list) {	
producer 

========================= camel sample_181 =========================

final ListTopicsResult response = snsClient.listTopics(nextToken);	nextToken = response.getNextToken();	for (final Topic topic : response.getTopics()) {	if (topic.getTopicArn().endsWith(arnSuffix)) {	configuration.setTopicArn(topic.getTopicArn());	break;	}	}	} while (nextToken != null);	} catch (final AmazonServiceException ase) {	
the list topics operation return the following error code 

break;	}	}	} while (nextToken != null);	} catch (final AmazonServiceException ase) {	throw ase;	}	}	if (configuration.getTopicArn() == null) {	CreateTopicRequest request = new CreateTopicRequest(configuration.getTopicName());	
creating topic with request 

}	} while (nextToken != null);	} catch (final AmazonServiceException ase) {	throw ase;	}	}	if (configuration.getTopicArn() == null) {	CreateTopicRequest request = new CreateTopicRequest(configuration.getTopicName());	CreateTopicResult result = snsClient.createTopic(request);	configuration.setTopicArn(result.getTopicArn());	
topic created with amazon resource name 

} catch (final AmazonServiceException ase) {	throw ase;	}	}	if (configuration.getTopicArn() == null) {	CreateTopicRequest request = new CreateTopicRequest(configuration.getTopicName());	CreateTopicResult result = snsClient.createTopic(request);	configuration.setTopicArn(result.getTopicArn());	}	if (ObjectHelper.isNotEmpty(configuration.getPolicy())) {	
updating topic with policy 

throw ase;	}	}	if (configuration.getTopicArn() == null) {	CreateTopicRequest request = new CreateTopicRequest(configuration.getTopicName());	CreateTopicResult result = snsClient.createTopic(request);	configuration.setTopicArn(result.getTopicArn());	}	if (ObjectHelper.isNotEmpty(configuration.getPolicy())) {	snsClient.setTopicAttributes(new SetTopicAttributesRequest(configuration.getTopicArn(), "Policy", configuration.getPolicy()));	
topic policy updated 

========================= camel sample_8697 =========================

public void testQuartz() throws Exception {	resultEndpoint = getMockEndpoint("mock:result");	resultEndpoint.expectedMessageCount(2);	resultEndpoint.message(0).header("triggerName").isEqualTo("myTimerName");	resultEndpoint.message(0).header("triggerGroup").isEqualTo("myGroup");	resultEndpoint.assertIsSatisfied();	List<Exchange> list = resultEndpoint.getReceivedExchanges();	for (Exchange exchange : list) {	Message in = exchange.getIn();	
received with headers 

========================= camel sample_17199 =========================

protected void doStart() throws Exception {	if (curator == null) {	ObjectHelper.notNull(getCamelContext(), "Camel Context");	ObjectHelper.notNull(configuration.getBasePath(), "ZooKeeper base path");	
starting zookeeper curator with namespace nodes 

protected void doStart() throws Exception {	if (curator == null) {	ObjectHelper.notNull(getCamelContext(), "Camel Context");	ObjectHelper.notNull(configuration.getBasePath(), "ZooKeeper base path");	curator = ZooKeeperCuratorHelper.createCurator(configuration);	curator.start();	}	if (serviceDiscovery == null) {	ObjectHelper.notNull(configuration.getBasePath(), "ZooKeeper base path");	
starting zookeeper servicediscoverybuilder with base path 

protected void doStop() throws Exception {	super.doStop();	if (serviceDiscovery != null) {	try {	serviceDiscovery.close();	} catch (Exception e) {	
error closing curator servicediscovery 

========================= camel sample_12661 =========================

public synchronized void onInit(Route route) {	super.onInit(route);	
route managed by setting route autostartup flag to false 

private synchronized void startManagedRoutes() {	if (!isLeader()) {	return;	}	try {	for (Route route : stoppeddRoutes) {	
starting route 

private synchronized void stopManagedRoutes() {	if (isLeader()) {	return;	}	try {	for (Route route : startedRoutes) {	
stopping route 

========================= camel sample_13973 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	String routeId = "mllp-receiver";	public void configure() {	
mllp log logginglevel info routeid to result 

public void configure() {	
mllp log logginglevel info routeid to result 

========================= camel sample_13836 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<HBaseComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hbase.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hbase.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_494 =========================

public static String getTextlineBody(Object body, Exchange exchange, TextLineDelimiter delimiter, boolean autoAppendDelimiter) throws NoTypeConversionAvailableException {	String s = exchange.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body);	if (autoAppendDelimiter) {	if (TextLineDelimiter.LINE.equals(delimiter)) {	if (!s.endsWith("\n")) {	
auto appending missing newline delimiter to body 

public static String getTextlineBody(Object body, Exchange exchange, TextLineDelimiter delimiter, boolean autoAppendDelimiter) throws NoTypeConversionAvailableException {	String s = exchange.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body);	if (autoAppendDelimiter) {	if (TextLineDelimiter.LINE.equals(delimiter)) {	if (!s.endsWith("\n")) {	s = s + "\n";	}	} else {	if (!s.endsWith("\u0000")) {	
auto appending missing null delimiter to body 

public static void close(Channel channel) {	if (channel != null) {	channel.close().addListener(new ChannelFutureListener() {	public void operationComplete(ChannelFuture future) {	
channel closed 

========================= camel sample_6666 =========================

incident.setDescription("my incident");	incident.setShortDescription("An incident");	incident.setSeverity(1);	incident.setImpact(1);	template().sendBodyAndHeaders( "direct:servicenow", incident, kvBuilder() .put(ServiceNowConstants.RESOURCE, "table") .put(ServiceNowConstants.ACTION, ServiceNowConstants.ACTION_CREATE) .put(ServiceNowParams.PARAM_TABLE_NAME, "incident") .build() );	mock.assertIsSatisfied();	incident = mock.getExchanges().get(0).getIn().getBody(Incident.class);	sysId = incident.getId();	number = incident.getNumber();	LOGGER.info("****************************************************");	
incident created 

mock.assertIsSatisfied();	incident = mock.getExchanges().get(0).getIn().getBody(Incident.class);	sysId = incident.getId();	number = incident.getNumber();	LOGGER.info("****************************************************");	LOGGER.info("  sysid  = {}", sysId);	LOGGER.info("  number = {}", number);	LOGGER.info("****************************************************");	}	{	
search the record 

mock.reset();	mock.expectedMessageCount(1);	template().sendBodyAndHeaders( "direct:servicenow", null, kvBuilder() .put(ServiceNowConstants.RESOURCE, "table") .put(ServiceNowConstants.ACTION, ServiceNowConstants.ACTION_RETRIEVE) .put(ServiceNowParams.PARAM_TABLE_NAME, "incident") .put(ServiceNowParams.SYSPARM_QUERY, "number=" + number) .build() );	mock.assertIsSatisfied();	List<Incident> incidents = mock.getExchanges().get(0).getIn().getBody(List.class);	assertEquals(1, incidents.size());	assertEquals(number, incidents.get(0).getNumber());	assertEquals(sysId, incidents.get(0).getId());	}	{	
update the record 

incident.setImpact(3);	template().sendBodyAndHeaders( "direct:servicenow", incident, kvBuilder() .put(ServiceNowConstants.RESOURCE, "table") .put(ServiceNowConstants.ACTION, ServiceNowConstants.ACTION_MODIFY) .put(ServiceNowParams.PARAM_TABLE_NAME, "incident") .put(ServiceNowParams.PARAM_SYS_ID, sysId) .build() );	mock.assertIsSatisfied();	incident = mock.getExchanges().get(0).getIn().getBody(Incident.class);	assertEquals(number, incident.getNumber());	assertEquals(2, incident.getSeverity());	assertEquals(3, incident.getImpact());	assertEquals("The incident", incident.getShortDescription());	}	{	
retrieve the record 

mock.assertIsSatisfied();	List<Incident> incidents = mock.getExchanges().get(0).getIn().getBody(List.class);	assertEquals(1, incidents.size());	assertEquals(number, incidents.get(0).getNumber());	assertEquals(sysId, incidents.get(0).getId());	assertEquals(2, incidents.get(0).getSeverity());	assertEquals(3, incidents.get(0).getImpact());	assertEquals("The incident", incidents.get(0).getShortDescription());	}	{	
search the record 

mock.expectedMessageCount(1);	template().sendBodyAndHeaders( "direct:servicenow", null, kvBuilder() .put(ServiceNowConstants.RESOURCE, "table") .put(ServiceNowConstants.ACTION, ServiceNowConstants.ACTION_RETRIEVE) .put(ServiceNowParams.PARAM_TABLE_NAME, "incident") .put(ServiceNowParams.PARAM_SYS_ID, sysId) .build() );	mock.assertIsSatisfied();	incident = mock.getExchanges().get(0).getIn().getBody(Incident.class);	assertEquals(2, incident.getSeverity());	assertEquals(3, incident.getImpact());	assertEquals("The incident", incident.getShortDescription());	assertEquals(number, incident.getNumber());	}	{	
delete the record 

assertEquals("The incident", incident.getShortDescription());	assertEquals(number, incident.getNumber());	}	{	mock.reset();	mock.expectedMessageCount(1);	template().sendBodyAndHeaders( "direct:servicenow", null, kvBuilder() .put(ServiceNowConstants.RESOURCE, "table") .put(ServiceNowConstants.ACTION, ServiceNowConstants.ACTION_DELETE) .put(ServiceNowParams.PARAM_TABLE_NAME, "incident") .put(ServiceNowParams.PARAM_SYS_ID, sysId) .build() );	mock.assertIsSatisfied();	}	{	
find the record should fail 

========================= camel sample_13565 =========================

protected void doStart() throws Exception {	if (Security.getProvider(BouncyCastleProvider.PROVIDER_NAME) == null) {	
adding bouncycastleprovider as security provider 

========================= camel sample_11558 =========================

public void handle(Request request, Response response) {	Method method = request.getMethod();	
methodrouter received request method 

public void handle(Request request, Response response) {	Method method = request.getMethod();	Restlet target = routes.get(method);	if (target == null || org.restlet.data.Method.OPTIONS.equals(method)) {	response.setAllowedMethods(routes.keySet());	}	if (target != null) {	target.handle(request, response);	} else {	
methodrouter method not allowed 

========================= camel sample_9317 =========================

public void testGetPost() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.post_id", null);	headers.put("CamelLinkedIn.count", null);	headers.put("CamelLinkedIn.start", null);	headers.put("CamelLinkedIn.fields", null);	final org.apache.camel.component.linkedin.api.model.Post result = requestBodyAndHeaders("direct: assertNotNull("getPost result", result);	
getpost 

public void testGetPostComments() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.post_id", null);	headers.put("CamelLinkedIn.count", null);	headers.put("CamelLinkedIn.start", null);	headers.put("CamelLinkedIn.fields", null);	final org.apache.camel.component.linkedin.api.model.Comments result = requestBodyAndHeaders("direct: assertNotNull("getPostComments result", result);	
getpostcomments 

========================= camel sample_8855 =========================

resultEndpoint.expectedBodiesReceived("msg1", "msg2", "msg3", "msg4", "msg5", "msg6");	sendBodyAndHeader(endpointUri, "msg4", "seqnum", 4L);	sendBodyAndHeader(endpointUri, "msg1", "seqnum", 1L);	sendBodyAndHeader(endpointUri, "msg3", "seqnum", 3L);	sendBodyAndHeader(endpointUri, "msg2", "seqnum", 2L);	sendBodyAndHeader(endpointUri, "msg6", "seqnum", 6L);	sendBodyAndHeader(endpointUri, "msg5", "seqnum", 5L);	resultEndpoint.assertIsSatisfied();	List<Exchange> list = resultEndpoint.getReceivedExchanges();	for (Exchange exchange : list) {	
received 

public void read(@Body String body) {	this.body = body;	
read method on with body 

public void execute() {	
started 

public void execute() {	
finished 

========================= camel sample_6148 =========================

public void act(final Client client, final Exchange exchange) throws NoSuchHeaderException {	final Message in = exchange.getIn();	final Long jobId = BeanstalkExchangeHelper.getJobID(exchange);	final long priority = BeanstalkExchangeHelper.getPriority(endpoint, in);	final int delay = BeanstalkExchangeHelper.getDelay(endpoint, in);	final boolean result = client.release(jobId, priority, delay);	if (!result && LOG.isWarnEnabled()) {	
failed to release job d priority d delay d 

public void act(final Client client, final Exchange exchange) throws NoSuchHeaderException {	final Message in = exchange.getIn();	final Long jobId = BeanstalkExchangeHelper.getJobID(exchange);	final long priority = BeanstalkExchangeHelper.getPriority(endpoint, in);	final int delay = BeanstalkExchangeHelper.getDelay(endpoint, in);	final boolean result = client.release(jobId, priority, delay);	if (!result && LOG.isWarnEnabled()) {	} else if (LOG.isDebugEnabled()) {	
job d released with priority d delay d seconds result is b 

========================= camel sample_8156 =========================

RouteBuilderParser.parseRouteBuilderEndpoints(clazz, ".", "src/test/java/org/apache/camel/parser/java/MyCdiRouteBuilder.java", details);	LOG.info("{}", details);	Assert.assertEquals("timer:foo?period=4999", details.get(0).getEndpointUri());	Assert.assertEquals("28", details.get(0).getLineNumber());	Assert.assertEquals("log:a", details.get(1).getEndpointUri());	Assert.assertEquals("32", details.get(1).getLineNumber());	Assert.assertEquals("netty4-http:http:someserver:80/hello", details.get(2).getEndpointUri());	Assert.assertEquals("36", details.get(2).getLineNumber());	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	
consumer 

Assert.assertEquals("log:a", details.get(1).getEndpointUri());	Assert.assertEquals("32", details.get(1).getLineNumber());	Assert.assertEquals("netty4-http:http:someserver:80/hello", details.get(2).getEndpointUri());	Assert.assertEquals("36", details.get(2).getLineNumber());	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true);	for (ParserResult result : list) {	}	Assert.assertEquals("timer:foo?period=4999", list.get(0).getElement());	list = CamelJavaParserHelper.parseCamelProducerUris(method, true, true);	for (ParserResult result : list) {	
producer 

========================= camel sample_210 =========================

protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {	CxfRsEndpoint answer;	Object value = parameters.remove("setDefaultBus");	if (value != null) {	
the option setdefaultbus is deprecated use name defaultbus instead 

========================= camel sample_8013 =========================

public void updateCorrelationId(String correlationId, String newCorrelationId, long requestTimeout) {	
updated provisional correlationid to expected correlationid 

protected void handleReplyMessage(String correlationID, AMQP.BasicProperties properties, byte[] message) {	ReplyHandler handler = correlation.get(correlationID);	if (handler == null && endpoint.isUseMessageIDAsCorrelationID()) {	handler = waitForProvisionCorrelationToBeUpdated(correlationID, message);	}	if (handler != null) {	correlation.remove(correlationID);	handler.onReply(correlationID, properties, message);	} else {	
reply received for unknown correlationid the message will be ignored 

protected Connection createListenerContainer() throws Exception {	
creating connection 

protected Connection createListenerContainer() throws Exception {	Connection conn = endpoint.connect(executorService);	
creating channel 

protected Connection createListenerContainer() throws Exception {	Connection conn = endpoint.connect(executorService);	Channel channel = conn.createChannel();	if (endpoint.isPrefetchEnabled()) {	channel.basicQos(endpoint.getPrefetchSize(), endpoint.getPrefetchCount(), endpoint.isPrefetchGlobal());	}	DeclareOk result = channel.queueDeclare();	
using temporary queue name 

========================= camel sample_14131 =========================

public void shutdown() throws Exception {	
stopping 

public void shutdown() throws Exception {	controlledContext.stop();	
stopped 

========================= camel sample_12636 =========================

public void testReplyToComment() throws Exception {	File testFile = uploadTestFile();	String fileId = testFile.getId();	Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelGoogleDrive.fileId", fileId);	com.google.api.services.drive.model.Comment comment = new com.google.api.services.drive.model.Comment();	comment.setContent("Camel rocks!");	headers.put("CamelGoogleDrive.content", comment);	requestBodyAndHeaders("direct: com.google.api.services.drive.model.CommentList result1 = requestBody("direct: assertNotNull(result1.get("items"));	
list 

headers = new HashMap<String, Object>();	headers.put("CamelGoogleDrive.fileId", fileId);	headers.put("CamelGoogleDrive.commentId", commentId);	com.google.api.services.drive.model.CommentReply reply = new com.google.api.services.drive.model.CommentReply();	reply.setContent("I know :-)");	headers.put("CamelGoogleDrive.content", reply);	requestBodyAndHeaders("direct: headers = new HashMap<String, Object>();	headers.put("CamelGoogleDrive.fileId", fileId);	headers.put("CamelGoogleDrive.commentId", commentId);	final com.google.api.services.drive.model.CommentReplyList result = requestBodyAndHeaders("direct: assertNotNull("list result", result);	
list 

========================= camel sample_15409 =========================

public void testWSHttpCall() throws Exception {	AsyncHttpClient c = createAsyncHttpSSLClient();	WebSocket websocket = c.prepareGet("wss: new WebSocketUpgradeHandler.Builder() .addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

========================= camel sample_17434 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<XMLSecurityDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.securexml.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.securexml.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_586 =========================

public void process(Exchange exchange) {	
firing cdi event with 

========================= camel sample_9878 =========================

protected void doStart() throws Exception {	super.doStart();	if (server == null) {	
starting the thrift server 

protected void doStop() throws Exception {	if (server != null) {	
terminating thrift server 

throw new IllegalArgumentException("Unknown host defined: " + configuration.getHost());	}	ThriftThreadPoolServer.Args args = new ThriftThreadPoolServer.Args(syncServerTransport);	args.processor((TProcessor)serverProcessor);	args.executorService(getEndpoint().getCamelContext().getExecutorServiceManager().newThreadPool(this, getEndpoint().getEndpointUri(), configuration.getPoolSize(), configuration.getMaxPoolSize()));	args.startThreadPool(getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, "start-" + getEndpoint().getEndpointUri()));	args.context(endpoint.getCamelContext());	server = new ThriftThreadPoolServer(args);	} else if (configuration.getCompressionType() == ThriftCompressionType.ZLIB && endpoint.isSynchronous()) {	if (ObjectHelper.isNotEmpty(configuration.getHost()) && ObjectHelper.isNotEmpty(configuration.getPort())) {	
building sync thrift server on 

ThriftThreadPoolServer.Args args = new ThriftThreadPoolServer.Args(syncServerTransport);	args.processor((TProcessor)serverProcessor);	args.executorService(getEndpoint().getCamelContext().getExecutorServiceManager().newThreadPool(this, getEndpoint().getEndpointUri(), configuration.getPoolSize(), configuration.getMaxPoolSize()));	args.startThreadPool(getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, "start-" + getEndpoint().getEndpointUri()));	args.context(endpoint.getCamelContext());	server = new ThriftThreadPoolServer(args);	} else if (configuration.getCompressionType() == ThriftCompressionType.ZLIB && endpoint.isSynchronous()) {	if (ObjectHelper.isNotEmpty(configuration.getHost()) && ObjectHelper.isNotEmpty(configuration.getPort())) {	syncServerTransport = new TServerSocket(new InetSocketAddress(configuration.getHost(), configuration.getPort()), configuration.getClientTimeout());	} else if (ObjectHelper.isEmpty(configuration.getHost()) && ObjectHelper.isNotEmpty(configuration.getPort())) {	
building sync thrift server on any address 

}	ThriftThreadPoolServer.Args args = new ThriftThreadPoolServer.Args(syncServerTransport);	args.processor((TProcessor)serverProcessor);	args.transportFactory(new TZlibTransport.Factory());	args.executorService(getEndpoint().getCamelContext().getExecutorServiceManager().newThreadPool(this, getEndpoint().getEndpointUri(), configuration.getPoolSize(), configuration.getMaxPoolSize()));	args.startThreadPool(getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, "start-" + getEndpoint().getEndpointUri()));	args.context(endpoint.getCamelContext());	server = new ThriftThreadPoolServer(args);	} else {	if (ObjectHelper.isNotEmpty(configuration.getHost()) && ObjectHelper.isNotEmpty(configuration.getPort())) {	
building thrift server on 

args.processor((TProcessor)serverProcessor);	args.transportFactory(new TZlibTransport.Factory());	args.executorService(getEndpoint().getCamelContext().getExecutorServiceManager().newThreadPool(this, getEndpoint().getEndpointUri(), configuration.getPoolSize(), configuration.getMaxPoolSize()));	args.startThreadPool(getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, "start-" + getEndpoint().getEndpointUri()));	args.context(endpoint.getCamelContext());	server = new ThriftThreadPoolServer(args);	} else {	if (ObjectHelper.isNotEmpty(configuration.getHost()) && ObjectHelper.isNotEmpty(configuration.getPort())) {	asyncServerTransport = new TNonblockingServerSocket(new InetSocketAddress(configuration.getHost(), configuration.getPort()), configuration.getClientTimeout());	} else if (ObjectHelper.isEmpty(configuration.getHost()) && ObjectHelper.isNotEmpty(configuration.getPort())) {	
building thrift server on any address 

private boolean doSend(Exchange exchange, AsyncCallback callback) {	if (isRunAllowed()) {	getAsyncProcessor().process(exchange, doneSync -> {	if (exchange.getException() != null) {	getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException());	}	callback.done(doneSync);	});	return false;	} else {	
consumer not ready to process exchanges the exchange will be discarded 

========================= camel sample_13027 =========================

public void testMustachePerformance() throws Exception {	int messageCount = 10000;	endSimpleMock.expectedMessageCount(messageCount);	StopWatch stopwatch = new StopWatch(true);	for (int i = 0; i < messageCount; i++) {	startSimpleProducerTemplate.sendBodyAndHeader("The Body", "someHeader", "Some Header");	}	assertMockEndpointsSatisfied();	
mustache performance ms for messages 

========================= camel sample_13498 =========================

public Processor createErrorHandler(RouteContext routeContext, Processor processor) throws Exception {	if (transactionTemplate == null) {	
no transactiontemplate configured on transactionerrorhandlerbuilder will try find it in the registry 

}	if (transactionTemplate == null) {	TransactedPolicy policy = routeContext.lookup(PROPAGATION_REQUIRED, TransactedPolicy.class);	if (policy instanceof SpringTransactionPolicy) {	transactionTemplate = ((SpringTransactionPolicy) policy).getTransactionTemplate();	}	}	if (transactionTemplate == null) {	Map<String, TransactionTemplate> mapTemplate = routeContext.lookupByType(TransactionTemplate.class);	if (mapTemplate == null || mapTemplate.isEmpty()) {	
no transactiontemplate found in registry 

if (policy instanceof SpringTransactionPolicy) {	transactionTemplate = ((SpringTransactionPolicy) policy).getTransactionTemplate();	}	}	if (transactionTemplate == null) {	Map<String, TransactionTemplate> mapTemplate = routeContext.lookupByType(TransactionTemplate.class);	if (mapTemplate == null || mapTemplate.isEmpty()) {	} else if (mapTemplate.size() == 1) {	transactionTemplate = mapTemplate.values().iterator().next();	} else {	
found transactiontemplate in registry cannot determine which one to use please configure a transactiontemplate on the transactionerrorhandlerbuilder 

Map<String, TransactionTemplate> mapTemplate = routeContext.lookupByType(TransactionTemplate.class);	if (mapTemplate == null || mapTemplate.isEmpty()) {	} else if (mapTemplate.size() == 1) {	transactionTemplate = mapTemplate.values().iterator().next();	} else {	}	}	if (transactionTemplate == null) {	Map<String, PlatformTransactionManager> mapManager = routeContext.lookupByType(PlatformTransactionManager.class);	if (mapManager == null || mapManager.isEmpty()) {	
no platformtransactionmanager found in registry 

transactionTemplate = mapTemplate.values().iterator().next();	} else {	}	}	if (transactionTemplate == null) {	Map<String, PlatformTransactionManager> mapManager = routeContext.lookupByType(PlatformTransactionManager.class);	if (mapManager == null || mapManager.isEmpty()) {	} else if (mapManager.size() == 1) {	transactionTemplate = new TransactionTemplate(mapManager.values().iterator().next());	} else {	
found platformtransactionmanager in registry cannot determine which one to use for transactiontemplate please configure a transactiontemplate on the transactionerrorhandlerbuilder 

}	if (transactionTemplate == null) {	Map<String, PlatformTransactionManager> mapManager = routeContext.lookupByType(PlatformTransactionManager.class);	if (mapManager == null || mapManager.isEmpty()) {	} else if (mapManager.size() == 1) {	transactionTemplate = new TransactionTemplate(mapManager.values().iterator().next());	} else {	}	}	if (transactionTemplate != null) {	
found transactiontemplate in registry to use 

========================= camel sample_16360 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<Mina2Component> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mina2.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mina2.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_990 =========================

protected void doStop() throws Exception {	
stopping consumer 

protected void doStart() throws Exception {	
starting consumer 

========================= camel sample_3960 =========================

private void doHttpPost(final String urlString, final String requestString) {	final HttpClient client = HttpClientBuilder.create().build();	final HttpPost post = new HttpPost(urlString);	post.setEntity(new StringEntity(requestString, Charset.forName("UTF-8")));	try {	final HttpResponse response = client.execute(post);	final int statusCode = response.getStatusLine().getStatusCode();	
response code 

throw new CMDirectException("CM Component and CM API show some kind of inconsistency. The component expects the status code to be 200 or 400. New api released? ");	}	final BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));	final StringBuffer result = new StringBuffer();	String line = null;	while ((line = rd.readLine()) != null) {	result.append(line);	}	line = result.toString();	if (!line.isEmpty()) {	
result of the request processing failed 

} else if (line.contains(CMConstants.ERROR_INSUFICIENT_BALANCE)) {	throw new InsufficientBalanceException();	} else if (line.contains(CMConstants.ERROR_UNROUTABLE_MESSAGE)) {	throw new UnroutableMessageException();	} else if (line.contains(CMConstants.ERROR_INVALID_PRODUCT_TOKEN)) {	throw new InvalidProductTokenException();	} else {	throw new CMResponseException("CHECK ME. I am not expecting this. ");	}	}	
result of the request processing successfully submited 

========================= camel sample_12773 =========================

private void addConsumerConfiguration(String remaining, Map<String, Object> parameters, SpringWebserviceConfiguration configuration) {	EndpointMappingType type = EndpointMappingType.getTypeFromUriPrefix(remaining);	if (type != null) {	
building spring web services consumer of type 

private void configureProducerConfiguration(String remaining, SpringWebserviceConfiguration configuration) throws URISyntaxException {	if (configuration.getEndpointMapping() == null && configuration.getEndpointDispatcher() == null) {	
building spring web services producer 

========================= camel sample_17121 =========================

public void testConnectionResourceRouter() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(100);	mock.expectsNoDuplicates(body());	StopWatch watch = new StopWatch();	for (int i = 0; i < 100; i++) {	template.sendBody("seda:start", "" + i);	}	assertMockEndpointsSatisfied(20, TimeUnit.SECONDS);	
took ms to process messages request reply over jms 

public void returnConnection(Connection connection) throws Exception {	
connection returned 

========================= camel sample_12323 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<GsonDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.json-gson.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.json-gson.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_656 =========================

public void processRequest(RequestEvent requestEvent) {	Request request = requestEvent.getRequest();	ServerTransaction serverTransactionId = requestEvent.getServerTransaction();	
request 

public void processRequest(RequestEvent requestEvent) {	Request request = requestEvent.getRequest();	ServerTransaction serverTransactionId = requestEvent.getServerTransaction();	
server transaction id 

public void processRequest(RequestEvent requestEvent) {	Request request = requestEvent.getRequest();	ServerTransaction serverTransactionId = requestEvent.getServerTransaction();	if (request.getMethod().equals(Request.SUBSCRIBE)) {	processSubscribe(requestEvent, serverTransactionId);	} else if (request.getMethod().equals(Request.PUBLISH)) {	processPublish(requestEvent, serverTransactionId);	} else {	
received expected request with method no further processing done 

if (sstate.getState().equalsIgnoreCase("terminated")) {	sstate.setReasonCode("deactivated");	}	} else {	sstate = sipPresenceAgent.getConfiguration().getHeaderFactory().createSubscriptionStateHeader(SubscriptionStateHeader.ACTIVE);	}	notifyRequest.addHeader(sstate);	notifyRequest.setHeader(eventHeader);	notifyRequest.setHeader(sipPresenceAgent.getConfiguration().getContactHeader());	notifyRequest.setContent(body, sipPresenceAgent.getConfiguration().getContentTypeHeader());	
sending the following notify request to subscriber 

private void processPublish(RequestEvent requestEvent, ServerTransaction serverTransactionId) {	try {	Request request = requestEvent.getRequest();	
sippresenceagentlistener received a publish request sending ok 

private void processPublish(RequestEvent requestEvent, ServerTransaction serverTransactionId) {	try {	Request request = requestEvent.getRequest();	
sippresenceagentlistener request 

private void processPublish(RequestEvent requestEvent, ServerTransaction serverTransactionId) {	try {	Request request = requestEvent.getRequest();	EventHeader eventHeader = (EventHeader) requestEvent.getRequest().getHeader(EventHeader.NAME);	Response response = sipPresenceAgent.getConfiguration().getMessageFactory().createResponse(202, request);	sipPresenceAgent.getProvider().sendResponse(response);	sendNotification(eventHeader, false, request.getContent());	} catch (Exception e) {	
exception thrown during publish notify processing in the sip presence agent listener 

public void processSubscribe(RequestEvent requestEvent, ServerTransaction serverTransaction) {	SipProvider sipProvider = (SipProvider) requestEvent.getSource();	Request request = requestEvent.getRequest();	try {	
sippresenceagentlistener received a subscribe request sending ok 

public void processSubscribe(RequestEvent requestEvent, ServerTransaction serverTransaction) {	SipProvider sipProvider = (SipProvider) requestEvent.getSource();	Request request = requestEvent.getRequest();	try {	
sippresenceagentlistener request 

public void processSubscribe(RequestEvent requestEvent, ServerTransaction serverTransaction) {	SipProvider sipProvider = (SipProvider) requestEvent.getSource();	Request request = requestEvent.getRequest();	try {	EventHeader eventHeader = (EventHeader) request.getHeader(EventHeader.NAME);	if (eventHeader == null) {	
cannot find event header dropping request 

ToHeader toHeader = (ToHeader) response.getHeader(ToHeader.NAME);	toHeader.setTag(toTag);	this.dialog = st.getDialog();	this.dialog.terminateOnBye(false);	} else {	response = sipPresenceAgent.getConfiguration().getMessageFactory().createResponse(200, request);	}	response.addHeader(sipPresenceAgent.getConfiguration().getContactHeader());	response.addHeader(sipPresenceAgent.getConfiguration().getExpiresHeader());	st.sendResponse(response);	
sippresenceagentlistener sent ok message 

ToHeader toHeader = (ToHeader) response.getHeader(ToHeader.NAME);	toHeader.setTag(toTag);	this.dialog = st.getDialog();	this.dialog.terminateOnBye(false);	} else {	response = sipPresenceAgent.getConfiguration().getMessageFactory().createResponse(200, request);	}	response.addHeader(sipPresenceAgent.getConfiguration().getContactHeader());	response.addHeader(sipPresenceAgent.getConfiguration().getExpiresHeader());	st.sendResponse(response);	
sippresenceagentlistener response 

this.dialog = st.getDialog();	this.dialog.terminateOnBye(false);	} else {	response = sipPresenceAgent.getConfiguration().getMessageFactory().createResponse(200, request);	}	response.addHeader(sipPresenceAgent.getConfiguration().getContactHeader());	response.addHeader(sipPresenceAgent.getConfiguration().getExpiresHeader());	st.sendResponse(response);	sendNotification(eventHeader, isInitial, request.getContent());	} catch (Throwable e) {	
exception thrown during notify processing in the sippresenceagentlistener 

public synchronized void processResponse(ResponseEvent responseReceivedEvent) {	Response response = responseReceivedEvent.getResponse();	Integer statusCode = response.getStatusCode();	if (SIP_MESSAGE_CODES.containsKey(statusCode)) {	
received from subscriber 

public void processTimeout(javax.sip.TimeoutEvent timeoutEvent) {	if (LOG.isWarnEnabled()) {	
timeoutevent received at sip subscription listener 

public void processIOException(IOExceptionEvent exceptionEvent) {	if (LOG.isWarnEnabled()) {	
ioexceptionevent received at sippresenceagentlistener 

public void processTransactionTerminated( TransactionTerminatedEvent transactionTerminatedEvent) {	if (LOG.isWarnEnabled()) {	
transactionterminatedevent received at sippresenceagentlistener 

========================= camel sample_8510 =========================

public void testSuspendResume() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceived("A");	template.sendBody("direct:foo", "A");	assertMockEndpointsSatisfied();	
Suspending 

assertMockEndpointsSatisfied();	resetMocks();	mock.expectedMessageCount(0);	context.suspendRoute("foo");	assertEquals("Suspended", context.getRouteStatus("foo").name());	try {	template.sendBody("direct:foo", "B");	fail("Should have thrown an exception");	} catch (Exception e) {	}	
Resuming 

========================= camel sample_1361 =========================

exchange.setException(e);	callback.done(true);	return true;	}	}	callback = new InternalCallback(states, exchange, callback);	Object synchronous = exchange.removeProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC);	if (exchange.isTransacted() || synchronous != null) {	if (LOG.isTraceEnabled()) {	if (exchange.isTransacted()) {	
transacted exchange must be routed synchronously for exchangeid 

callback.done(true);	return true;	}	}	callback = new InternalCallback(states, exchange, callback);	Object synchronous = exchange.removeProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC);	if (exchange.isTransacted() || synchronous != null) {	if (LOG.isTraceEnabled()) {	if (exchange.isTransacted()) {	} else {	
synchronous unitofwork exchange must be routed synchronously for exchangeid 

}	callback.done(true);	return true;	} else {	final UnitOfWork uow = exchange.getUnitOfWork();	AsyncCallback async = callback;	if (uow != null) {	async = uow.beforeProcess(processor, exchange, callback);	}	if (LOG.isTraceEnabled()) {	
processing exchange for exchangeid 

if (uow != null) {	async = uow.beforeProcess(processor, exchange, callback);	}	if (LOG.isTraceEnabled()) {	}	boolean sync = processor.process(exchange, async);	if (uow != null) {	uow.afterProcess(processor, exchange, callback, sync);	}	if (LOG.isTraceEnabled()) {	
exchange processed and is continued routed for exchangeid synchronously asynchronously 

protected boolean continueProcessing(Exchange exchange) {	Object stop = exchange.getProperty(Exchange.ROUTE_STOP);	if (stop != null) {	boolean doStop = exchange.getContext().getTypeConverter().convertTo(Boolean.class, stop);	if (doStop) {	
exchange is marked to stop routing 

public Object before(Exchange exchange) throws Exception {	for (RoutePolicy policy : routePolicies) {	try {	if (isRoutePolicyRunAllowed(policy)) {	policy.onExchangeBegin(route, exchange);	}	} catch (Exception e) {	
error occurred during onexchangebegin on routepolicy this exception will be ignored 

public void after(Exchange exchange, Object data) throws Exception {	if (isCamelStopping(exchange.getContext())) {	return;	}	for (RoutePolicy policy : routePolicies) {	try {	if (isRoutePolicyRunAllowed(policy)) {	policy.onExchangeDone(route, exchange);	}	} catch (Exception e) {	
error occurred during onexchangedone on routepolicy this exception will be ignored 

public Object before(Exchange exchange) throws Exception {	try {	
sleeping for millis 

public Object before(Exchange exchange) throws Exception {	try {	Thread.sleep(delay);	} catch (InterruptedException e) {	
sleep interrupted 

========================= camel sample_4533 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<JcrComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jcr.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jcr.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1224 =========================

public void transform(Message message, DataType from, DataType to) throws Exception {	Exchange exchange = message.getExchange();	CamelContext context = exchange.getContext();	if (from.isJavaType()) {	Object input = message.getBody();	Class<?> fromClass = context.getClassResolver().resolveClass(from.getName());	if (!fromClass.isAssignableFrom(input.getClass())) {	
converting to 

Exchange exchange = message.getExchange();	CamelContext context = exchange.getContext();	if (from.isJavaType()) {	Object input = message.getBody();	Class<?> fromClass = context.getClassResolver().resolveClass(from.getName());	if (!fromClass.isAssignableFrom(input.getClass())) {	input = context.getTypeConverter().mandatoryConvertTo(fromClass, input);	message.setBody(input);	}	}	
sending to transform processor 

}	DefaultExchange transformExchange = new DefaultExchange(exchange);	transformExchange.setIn(message);	transformExchange.setProperties(exchange.getProperties());	processor.process(transformExchange);	Message answer = transformExchange.hasOut() ? transformExchange.getOut() : transformExchange.getIn();	if (to.isJavaType()) {	Object answerBody = answer.getBody();	Class<?> toClass = context.getClassResolver().resolveClass(to.getName());	if (!toClass.isAssignableFrom(answerBody.getClass())) {	
converting to 

========================= camel sample_4026 =========================

protected void doGetService(Exchange exchange, String operation) throws Exception {	Service service = null;	String serviceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SERVICE_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(serviceName)) {	
get a specific service require specify a service name 

protected void doGetService(Exchange exchange, String operation) throws Exception {	Service service = null;	String serviceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SERVICE_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(serviceName)) {	throw new IllegalArgumentException( "Get a specific service require specify a service name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
get a specific service require specify a namespace name 

protected void doCreateService(Exchange exchange, String operation) throws Exception {	Service service = null;	String serviceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SERVICE_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	ServiceSpec serviceSpec = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SERVICE_SPEC, ServiceSpec.class);	if (ObjectHelper.isEmpty(serviceName)) {	
create a specific service require specify a service name 

protected void doCreateService(Exchange exchange, String operation) throws Exception {	Service service = null;	String serviceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SERVICE_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	ServiceSpec serviceSpec = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SERVICE_SPEC, ServiceSpec.class);	if (ObjectHelper.isEmpty(serviceName)) {	throw new IllegalArgumentException( "Create a specific service require specify a service name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
create a specific service require specify a namespace name 

String serviceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SERVICE_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	ServiceSpec serviceSpec = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SERVICE_SPEC, ServiceSpec.class);	if (ObjectHelper.isEmpty(serviceName)) {	throw new IllegalArgumentException( "Create a specific service require specify a service name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	throw new IllegalArgumentException( "Create a specific service require specify a namespace name");	}	if (ObjectHelper.isEmpty(serviceSpec)) {	
create a specific service require specify a service spec bean 

protected void doDeleteService(Exchange exchange, String operation) throws Exception {	String serviceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SERVICE_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(serviceName)) {	
delete a specific service require specify a service name 

protected void doDeleteService(Exchange exchange, String operation) throws Exception {	String serviceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_SERVICE_NAME, String.class);	String namespaceName = exchange.getIn().getHeader( KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);	if (ObjectHelper.isEmpty(serviceName)) {	throw new IllegalArgumentException( "Delete a specific service require specify a service name");	}	if (ObjectHelper.isEmpty(namespaceName)) {	
delete a specific service require specify a namespace name 

========================= camel sample_13318 =========================

protected void removeInterceptorWhichIsInThePhases(List<Interceptor<? extends Message>> interceptors, String[] phaseNames, Set<String> needToBeKept) {	for (Interceptor<? extends Message> i : interceptors) {	if (i instanceof PhaseInterceptor) {	PhaseInterceptor<? extends Message> p = (PhaseInterceptor<? extends Message>) i;	for (String phaseName : phaseNames) {	if (p.getPhase().equals(phaseName)) {	if (needToBeKept == null) {	
removing the interceptor 

protected void removeInterceptorWhichIsInThePhases(List<Interceptor<? extends Message>> interceptors, String[] phaseNames, Set<String> needToBeKept) {	for (Interceptor<? extends Message> i : interceptors) {	if (i instanceof PhaseInterceptor) {	PhaseInterceptor<? extends Message> p = (PhaseInterceptor<? extends Message>) i;	for (String phaseName : phaseNames) {	if (p.getPhase().equals(phaseName)) {	if (needToBeKept == null) {	interceptors.remove(p);	break;	} else if (!needToBeKept.contains(p.getClass().getName())) {	
removing the interceptor 

if (i instanceof PhaseInterceptor) {	PhaseInterceptor<? extends Message> p = (PhaseInterceptor<? extends Message>) i;	for (String phaseName : phaseNames) {	if (p.getPhase().equals(phaseName)) {	outside = true;	break;	}	}	if (!outside) {	if (needToBeKept == null) {	
removing the interceptor 

for (String phaseName : phaseNames) {	if (p.getPhase().equals(phaseName)) {	outside = true;	break;	}	}	if (!outside) {	if (needToBeKept == null) {	interceptors.remove(p);	} else if (!needToBeKept.contains(p.getClass().getName())) {	
removing the interceptor 

protected void removeInterceptors(List<Interceptor<? extends Message>> interceptors, Collection<Class<?>> toBeRemovedInterceptors) {	for (Interceptor<? extends Message> interceptor : interceptors) {	if (toBeRemovedInterceptors.contains(interceptor.getClass())) {	
removing the interceptor 

========================= camel sample_8005 =========================

public static void ensureRelativeFtpDirectory(Component ftpComponent, RemoteFileConfiguration configuration) {	if (FileUtil.hasLeadingSeparator(configuration.getDirectoryName())) {	String relativePath = FileUtil.stripLeadingSeparator(configuration.getDirectoryName());	
s doesn t support absolute paths will be converted to after camel absolute paths will be invalid 

========================= camel sample_15366 =========================

public Message toCamelMessage(FullHttpRequest request, Exchange exchange, NettyHttpConfiguration configuration) throws Exception {	
tocamelmessage 

public void populateCamelHeaders(FullHttpRequest request, Map<String, Object> headers, Exchange exchange, NettyHttpConfiguration configuration) throws Exception {	
populatecamelheaders 

String path = uri.getRawPath();	if (configuration.getPath() != null) {	String matchPath = path.toLowerCase(Locale.US);	String match = configuration.getPath() != null ? configuration.getPath().toLowerCase(Locale.US) : null;	if (match != null && matchPath.startsWith(match)) {	path = path.substring(configuration.getPath().length());	}	}	headers.put(Exchange.HTTP_PATH, path);	if (LOG.isTraceEnabled()) {	
http method 

String path = uri.getRawPath();	if (configuration.getPath() != null) {	String matchPath = path.toLowerCase(Locale.US);	String match = configuration.getPath() != null ? configuration.getPath().toLowerCase(Locale.US) : null;	if (match != null && matchPath.startsWith(match)) {	path = path.substring(configuration.getPath().length());	}	}	headers.put(Exchange.HTTP_PATH, path);	if (LOG.isTraceEnabled()) {	
http uri 

String value = request.headers().get(name);	if (value != null && value.trim().startsWith("Basic")) {	NettyHttpHelper.appendHeader(headers, NettyHttpConstants.HTTP_AUTHENTICATION, "Basic");	}	}	List<String> values = request.headers().getAll(name);	Iterator<?> it = ObjectHelper.createIterator(values, ",", true);	while (it.hasNext()) {	Object extracted = it.next();	Object decoded = shouldUrlDecodeHeader(configuration, name, extracted, "UTF-8");	
http header 

if (request.uri().contains("?")) {	String query = ObjectHelper.after(request.uri(), "?");	Map<String, Object> uriParameters = URISupport.parseQuery(query, false, true);	for (Map.Entry<String, Object> entry : uriParameters.entrySet()) {	String name = entry.getKey();	Object values = entry.getValue();	Iterator<?> it = ObjectHelper.createIterator(values, ",", true);	while (it.hasNext()) {	Object extracted = it.next();	Object decoded = shouldUrlDecodeHeader(configuration, name, extracted, "UTF-8");	
uri parameter 

public Message toCamelMessage(FullHttpResponse response, Exchange exchange, NettyHttpConfiguration configuration) throws Exception {	
tocamelmessage 

public void populateCamelHeaders(FullHttpResponse response, Map<String, Object> headers, Exchange exchange, NettyHttpConfiguration configuration) throws Exception {	
populatecamelheaders 

headers.put(Exchange.HTTP_RESPONSE_CODE, response.status().code());	headers.put(Exchange.HTTP_RESPONSE_TEXT, response.status().reasonPhrase());	for (String name : response.headers().names()) {	if (name.toLowerCase().equals("content-type")) {	name = Exchange.CONTENT_TYPE;	}	List<String> values = response.headers().getAll(name);	Iterator<?> it = ObjectHelper.createIterator(values);	while (it.hasNext()) {	Object extracted = it.next();	
http header 

public HttpResponse toNettyResponse(Message message, NettyHttpConfiguration configuration) throws Exception {	
tonettyresponse 

public HttpResponse toNettyResponse(Message message, NettyHttpConfiguration configuration) throws Exception {	if (message.getBody() instanceof HttpResponse) {	return (HttpResponse) message.getBody();	}	Object body = message.getBody();	Exception cause = message.getExchange().getException();	ByteBuf buffer;	boolean failed = message.getExchange().isFailed();	int defaultCode = failed ? 500 : 200;	int code = message.getHeader(Exchange.HTTP_RESPONSE_CODE, defaultCode, int.class);	
http status code 

}	}	HttpResponse response;	if (buffer != null) {	response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(code), buffer);	if (buffer.readerIndex() == buffer.writerIndex()) {	buffer.setIndex(0, buffer.writerIndex());	}	int len = buffer.readableBytes();	response.headers().set(HttpHeaderNames.CONTENT_LENGTH.toString(), len);	
content length 

String headerValue = tc.convertTo(String.class, it.next());	if (headerValue != null && headerFilterStrategy != null && !headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, message.getExchange())) {	LOG.trace("HTTP-Header: {}={}", key, headerValue);	response.headers().add(key, headerValue);	}	}	}	String contentType = MessageHelper.getContentType(message);	if (contentType != null) {	response.headers().set(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);	
content type 

if (configuration.isKeepAlive()) {	connection = HttpHeaderValues.KEEP_ALIVE.toString();	} else {	connection = HttpHeaderValues.CLOSE.toString();	}	}	response.headers().set(HttpHeaderNames.CONNECTION.toString(), connection);	if (connection.equalsIgnoreCase(HttpHeaderValues.CLOSE.toString())) {	message.setHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, true);	}	
connection 

public HttpRequest toNettyRequest(Message message, String uri, NettyHttpConfiguration configuration) throws Exception {	
tonettyrequest 

buffer = message.getBody(ByteBuf.class);	if (buffer == null) {	byte[] data = message.getMandatoryBody(byte[].class);	buffer = NettyConverter.toByteBuffer(data);	}	}	if (buffer != null) {	request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, uriForRequest, buffer);	int len = buffer.readableBytes();	request.headers().set(HttpHeaderNames.CONTENT_LENGTH.toString(), len);	
content length 

String headerValue = tc.convertTo(String.class, it.next());	if (headerValue != null && headerFilterStrategy != null && !headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, message.getExchange())) {	LOG.trace("HTTP-Header: {}={}", key, headerValue);	request.headers().add(key, headerValue);	}	}	}	String contentType = MessageHelper.getContentType(message);	if (contentType != null) {	request.headers().set(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);	
content type 

}	}	}	String contentType = MessageHelper.getContentType(message);	if (contentType != null) {	request.headers().set(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);	}	URI u = new URI(uri);	String hostHeader = u.getHost() + (u.getPort() == 80 ? "" : ":" + u.getPort());	request.headers().set(HttpHeaderNames.HOST.toString(), hostHeader);	
host 

request.headers().set(HttpHeaderNames.HOST.toString(), hostHeader);	String connection = message.getHeader(HttpHeaderNames.CONNECTION.toString(), String.class);	if (connection == null) {	if (configuration.isKeepAlive()) {	connection = HttpHeaderValues.KEEP_ALIVE.toString();	} else {	connection = HttpHeaderValues.CLOSE.toString();	}	}	request.headers().set(HttpHeaderNames.CONNECTION.toString(), connection);	
connection 

========================= camel sample_16663 =========================

protected void doStart() throws Exception {	super.doStart();	if (configuration.getNegotiationType() == ThriftNegotiationType.SSL) {	if (!endpoint.isSynchronous()) {	throw new IllegalArgumentException("The SSL negotiation type requires to set syncronous communication mode");	}	if (syncTransport == null) {	initializeSslTransport();	
getting synchronous secured client implementation 

if (!endpoint.isSynchronous()) {	throw new IllegalArgumentException("The SSL negotiation type requires to set syncronous communication mode");	}	if (syncTransport == null) {	initializeSslTransport();	thriftClient = ThriftUtils.constructClientInstance(endpoint.getServicePackage(), endpoint.getServiceName(), syncTransport, configuration.getExchangeProtocol(), configuration.getNegotiationType(), configuration.getCompressionType(), endpoint.getCamelContext());	}	} else if (endpoint.isSynchronous()) {	if (syncTransport == null) {	initializeSyncTransport();	
getting synchronous client implementation 

thriftClient = ThriftUtils.constructClientInstance(endpoint.getServicePackage(), endpoint.getServiceName(), syncTransport, configuration.getExchangeProtocol(), configuration.getNegotiationType(), configuration.getCompressionType(), endpoint.getCamelContext());	}	} else if (endpoint.isSynchronous()) {	if (syncTransport == null) {	initializeSyncTransport();	thriftClient = ThriftUtils.constructClientInstance(endpoint.getServicePackage(), endpoint.getServiceName(), syncTransport, configuration.getExchangeProtocol(), configuration.getNegotiationType(), configuration.getCompressionType(), endpoint.getCamelContext());	}	} else {	if (asyncTransport == null) {	initializeAsyncTransport();	
getting asynchronous client implementation 

protected void doStop() throws Exception {	if (syncTransport != null) {	
terminating synchronous transport the remote thrift server 

protected void doStop() throws Exception {	if (syncTransport != null) {	syncTransport.close();	syncTransport = null;	} else if (asyncTransport != null) {	
terminating asynchronous transport the remote thrift server 

protected void initializeSyncTransport() throws TTransportException {	if (!ObjectHelper.isEmpty(configuration.getHost()) && !ObjectHelper.isEmpty(configuration.getPort())) {	
creating transport to the remote thrift server 

protected void initializeAsyncTransport() throws IOException, TTransportException {	if (!ObjectHelper.isEmpty(configuration.getHost()) && !ObjectHelper.isEmpty(configuration.getPort())) {	
creating transport to the remote thrift server 

protected void initializeSslTransport() throws TTransportException {	if (!ObjectHelper.isEmpty(configuration.getHost()) && !ObjectHelper.isEmpty(configuration.getPort())) {	SSLContextParameters sslParameters = configuration.getSslParameters();	if (sslParameters == null) {	throw new IllegalArgumentException("SSL parameters must be initialized if negotiation type is set to " + configuration.getNegotiationType());	}	ObjectHelper.notNull(sslParameters.getSecureSocketProtocol(), "Security protocol");	ObjectHelper.notNull(sslParameters.getTrustManagers().getKeyStore().getResource(), "Trust store path");	ObjectHelper.notNull(sslParameters.getTrustManagers().getKeyStore().getPassword(), "Trust store password");	
creating secured transport to the remote thrift server 

========================= camel sample_13031 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<PgEventComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.pgevent.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.pgevent.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_969 =========================

public void testLoadAndRecoverLevelDBAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(SIZE / 10);	mock.setResultWaitTime(50 * 1000);	
staring to send messages 

public void testLoadAndRecoverLevelDBAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(SIZE / 10);	mock.setResultWaitTime(50 * 1000);	for (int i = 0; i < SIZE; i++) {	final int value = 1;	char id = 'A';	Map<String, Object> headers = new HashMap<String, Object>();	headers.put("id", id);	headers.put("seq", i);	
sending with id 

mock.setResultWaitTime(50 * 1000);	for (int i = 0; i < SIZE; i++) {	final int value = 1;	char id = 'A';	Map<String, Object> headers = new HashMap<String, Object>();	headers.put("id", id);	headers.put("seq", i);	template.sendBodyAndHeaders("seda:start", value, headers);	Thread.sleep(5);	}	
sending all message done now waiting for aggregation to complete 

========================= camel sample_13898 =========================

}	ConnectionFactory cf = resolveAndRemoveReferenceParameter(parameters, "connectionFactory", ConnectionFactory.class);	if (cf != null) {	endpoint.getConfiguration().setConnectionFactory(cf);	}	String cfUsername = getAndRemoveParameter(parameters, "username", String.class, getConfiguration().getUsername());	String cfPassword = getAndRemoveParameter(parameters, "password", String.class, getConfiguration().getPassword());	if (cfUsername != null && cfPassword != null) {	cf = endpoint.getConfiguration().getConnectionFactory();	ObjectHelper.notNull(cf, "ConnectionFactory");	
wrapping existing connectionfactory with usercredentialsconnectionfactoryadapter using username and password 

========================= camel sample_7173 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<RouteboxComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.routebox.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.routebox.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_590 =========================

public void testInvalidExpressionFailsWithMeaningfulException() throws Exception {	try {	GroovyLanguage.groovy("exchange.doesNotExist").evaluate(exchange);	fail("This test case should have thrown an exception!");	} catch (Exception e) {	
caught expected exception 

========================= camel sample_17137 =========================

public Producer createProducer() throws Exception {	
createproducer 

public Consumer createConsumer(Processor processor) throws Exception {	
createconsumer processor 

public Charset determineCharset(byte[] hl7Bytes, String msh18) {	Charset answer = MllpProtocolConstants.DEFAULT_CHARSET;	if (configuration.hasCharsetName()) {	String charsetName = configuration.getCharsetName();	if (Charset.isSupported(charsetName)) {	answer = Charset.forName(charsetName);	} else {	
unsupported character set configured for component using default character set 

if (configuration.hasCharsetName()) {	String charsetName = configuration.getCharsetName();	if (Charset.isSupported(charsetName)) {	answer = Charset.forName(charsetName);	} else {	}	} else if (msh18 != null && !msh18.isEmpty()) {	if (MllpProtocolConstants.MSH18_VALUES.containsKey(msh18)) {	answer = MllpProtocolConstants.MSH18_VALUES.get(msh18);	} else {	
unsupported character set specified for msh using default character set 

if (MllpProtocolConstants.MSH18_VALUES.containsKey(msh18)) {	answer = MllpProtocolConstants.MSH18_VALUES.get(msh18);	} else {	}	} else {	String foundMsh18 = findMsh18(hl7Bytes);	if (foundMsh18 != null && !foundMsh18.isEmpty()) {	if (MllpProtocolConstants.MSH18_VALUES.containsKey(foundMsh18)) {	answer = MllpProtocolConstants.MSH18_VALUES.get(foundMsh18);	} else {	
unsupported character set found in msh using default character set 

} else {	}	} else {	String foundMsh18 = findMsh18(hl7Bytes);	if (foundMsh18 != null && !foundMsh18.isEmpty()) {	if (MllpProtocolConstants.MSH18_VALUES.containsKey(foundMsh18)) {	answer = MllpProtocolConstants.MSH18_VALUES.get(foundMsh18);	} else {	}	} else {	
character set not specified and no character set found in msh using default character set 

public String createNewString(byte[] hl7Bytes, String msh18) {	if (hl7Bytes == null) {	return null;	} else if (hl7Bytes.length == 0) {	return "";	}	Charset charset = determineCharset(hl7Bytes, msh18);	
creating new string using charset 

========================= camel sample_13877 =========================

private static Object checkSerializableBody(String type, Exchange exchange, Object object) {	if (object == null) {	return null;	}	Serializable converted = exchange.getContext().getTypeConverter().convertTo(Serializable.class, exchange, object);	if (converted != null) {	return converted;	} else {	
exchange containing object of type cannot be serialized it will be excluded by the holder 

========================= camel sample_3976 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<CxfComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.cxf.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.cxf.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_986 =========================

public void testXPathPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(60, TimeUnit.SECONDS);	
processed file with elements in 

public void testXPathPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(60, TimeUnit.SECONDS);	
processed tiny messages 

public void testXPathPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(60, TimeUnit.SECONDS);	
processed small messages 

public void testXPathPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(60, TimeUnit.SECONDS);	
processed medium messages 

public void testXPathPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(60, TimeUnit.SECONDS);	
processed large messages 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("file:target/data?noop=true") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	
starting to process file 

from("file:target/data?noop=true") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	watch.restart();	}	}) .split().xpath("/orders/order").streaming() .choice() .when().xpath("/order/amount < 10") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String xml = exchange.getIn().getBody(String.class);	assertTrue(xml, xml.contains("<amount>3</amount>"));	int num = tiny.incrementAndGet();	if (num % 100 == 0) {	
processed tiny messages 

if (num % 100 == 0) {	log.debug(xml);	}	}	}) .when().xpath("/order/amount < 50") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String xml = exchange.getIn().getBody(String.class);	assertTrue(xml, xml.contains("<amount>44</amount>"));	int num = small.incrementAndGet();	if (num % 100 == 0) {	
processed small messages 

if (num % 100 == 0) {	log.debug(xml);	}	}	}) .when().xpath("/order/amount < 100") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String xml = exchange.getIn().getBody(String.class);	assertTrue(xml, xml.contains("<amount>88</amount>"));	int num = med.incrementAndGet();	if (num % 100 == 0) {	
processed medium messages 

if (num % 100 == 0) {	log.debug(xml);	}	}	}) .otherwise() .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String xml = exchange.getIn().getBody(String.class);	assertTrue(xml, xml.contains("<amount>123</amount>"));	int num = large.incrementAndGet();	if (num % 100 == 0) {	
processed large messages 

========================= camel sample_16726 =========================

private HdfsInfo setupHdfs(boolean onStartup) throws Exception {	if (onStartup) {	
connecting to hdfs file system may take a while if connection is not available 

private HdfsInfo setupHdfs(boolean onStartup) throws Exception {	if (onStartup) {	} else {	if (log.isDebugEnabled()) {	
connecting to hdfs file system may take a while if connection is not available 

private HdfsInfo setupHdfs(boolean onStartup) throws Exception {	if (onStartup) {	} else {	if (log.isDebugEnabled()) {	}	}	HdfsInfo answer = HdfsInfoFactory.newHdfsInfo(this.hdfsPath.toString());	if (onStartup) {	
connected to hdfs file system 

private HdfsInfo setupHdfs(boolean onStartup) throws Exception {	if (onStartup) {	} else {	if (log.isDebugEnabled()) {	}	}	HdfsInfo answer = HdfsInfoFactory.newHdfsInfo(this.hdfsPath.toString());	if (onStartup) {	} else {	if (log.isDebugEnabled()) {	
connected to hdfs file system 

Path pattern = info.getPath().suffix("/" + this.config.getPattern());	fileStatuses = info.getFileSystem().globStatus(pattern, new ExcludePathFilter());	}	for (FileStatus status : fileStatuses) {	if (normalFileIsDirectoryNoSuccessFile(status, info)) {	continue;	}	if (config.getOwner() != null) {	if (!config.getOwner().equals(status.getOwner())) {	if (log.isDebugEnabled()) {	
skipping file as not matching owner 

if (log.isDebugEnabled()) {	}	continue;	}	}	try {	this.rwlock.writeLock().lock();	this.istream = HdfsInputStream.createInputStream(status.getPath().toString(), this.config);	if (!this.istream.isOpened()) {	if (log.isDebugEnabled()) {	
skipping file because it doesn t exist anymore 

while (this.istream.next(key, value) >= 0) {	Exchange exchange = this.getEndpoint().createExchange();	Message message = new DefaultMessage(this.getEndpoint().getCamelContext());	String fileName = StringUtils.substringAfterLast(status.getPath().toString(), "/");	message.setHeader(Exchange.FILE_NAME, fileName);	if (key.value != null) {	message.setHeader(HdfsHeader.KEY.name(), key.value);	}	message.setBody(value.value);	exchange.setIn(message);	
processing file 

========================= camel sample_11149 =========================

protected void assertRowExist(String tableName, Map<String, String> row) throws Exception {	QueryRequest queryRequest = new QueryRequest();	String query = "SELECT * FROM " + DATASET_ID + "." + tableName + " WHERE " + row.entrySet().stream() .map(e -> e.getKey() + " = '" + e.getValue() + "'") .collect(Collectors.joining(" AND "));	
query 

protected void createBqTable(String tableId) throws Exception {	TableReference reference = new TableReference() .setTableId(tableId) .setDatasetId(DATASET_ID) .setProjectId(PROJECT_ID);	InputStream in = this.getClass().getResourceAsStream("/schema/simple-table.json");	TableSchema schema = readDefinition(in);	Table table = new Table() .setTableReference(reference) .setSchema(schema);	try {	getConnectionFactory().getDefaultClient().tables() .insert(PROJECT_ID, DATASET_ID, table) .execute();	} catch (GoogleJsonResponseException e) {	if (e.getDetails().getCode() == 409) {	
table already exist 

========================= camel sample_9356 =========================

protected void debugBefore(Exchange exchange, Processor processor, ProcessorDefinition<?> definition, String id, String shortName) {	
before with body 

========================= camel sample_11667 =========================

public void testPerformance() {	SimpleUuidGenerator uuidGenerator = new SimpleUuidGenerator();	StopWatch watch = new StopWatch();	
first id 

public void testPerformance() {	SimpleUuidGenerator uuidGenerator = new SimpleUuidGenerator();	StopWatch watch = new StopWatch();	for (int i = 0; i < 500000; i++) {	uuidGenerator.generateUuid();	}	
last id 

public void testPerformance() {	SimpleUuidGenerator uuidGenerator = new SimpleUuidGenerator();	StopWatch watch = new StopWatch();	for (int i = 0; i < 500000; i++) {	uuidGenerator.generateUuid();	}	
took 

========================= camel sample_1336 =========================

public void onFailure(Exchange exchange) {	Integer deadline = 0;	Object configuredDeadline = exchange.getIn().getHeader(GooglePubsubConstants.ACK_DEADLINE);	if (configuredDeadline != null && Integer.class.isInstance(configuredDeadline)) {	deadline = (Integer) configuredDeadline;	}	if (configuredDeadline != null && String.class.isInstance(configuredDeadline)) {	try {	deadline = Integer.valueOf((String) configuredDeadline);	} catch (Exception e) {	
unable to parse ack deadline header value 

if (configuredDeadline != null && Integer.class.isInstance(configuredDeadline)) {	deadline = (Integer) configuredDeadline;	}	if (configuredDeadline != null && String.class.isInstance(configuredDeadline)) {	try {	deadline = Integer.valueOf((String) configuredDeadline);	} catch (Exception e) {	}	}	if (deadline != 0) {	
exchange ack deadline 

========================= camel sample_17249 =========================

public EmbeddedServletContainerCustomizer containerCustomizer() {	return container -> {	try (ServerSocket socket = new ServerSocket(0)) {	
server port 

========================= camel sample_17619 =========================

public Language resolveLanguage(String name, CamelContext context) {	try {	Object bean = context.getRegistry().lookupByName(".camelBlueprint.languageResolver." + name);	if (bean instanceof LanguageResolver) {	
found language resolver in registry 

public Language resolveLanguage(String name, CamelContext context) {	try {	Object bean = context.getRegistry().lookupByName(".camelBlueprint.languageResolver." + name);	if (bean instanceof LanguageResolver) {	return ((LanguageResolver) bean).resolveLanguage(name, context);	}	} catch (Exception e) {	
ignored error looking up bean due 

========================= camel sample_8117 =========================

public boolean postProcessAfterInstantiation(final Object bean, final String beanName) throws BeansException {	ReflectionUtils.doWithFields(bean.getClass(), new ReflectionUtils.FieldCallback() {	public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {	MagicAnnotation annotation = field.getAnnotation(MagicAnnotation.class);	if (annotation != null && field.getType() == String.class) {	
found magicannotation on field of class 

========================= camel sample_15761 =========================

public void process(Exchange exchange) throws Exception {	ExecCommand execCommand = getBinding().readInput(exchange, endpoint);	ExecCommandExecutor executor = endpoint.getCommandExecutor();	if (executor == null) {	executor = new DefaultExecCommandExecutor();	}	
executing 

public void process(Exchange exchange) throws Exception {	ExecCommand execCommand = getBinding().readInput(exchange, endpoint);	ExecCommandExecutor executor = endpoint.getCommandExecutor();	if (executor == null) {	executor = new DefaultExecCommandExecutor();	}	ExecResult result = executor.execute(execCommand);	ObjectHelper.notNull(result, "The command executor must return a not-null result");	
the command had exit value 

public void process(Exchange exchange) throws Exception {	ExecCommand execCommand = getBinding().readInput(exchange, endpoint);	ExecCommandExecutor executor = endpoint.getCommandExecutor();	if (executor == null) {	executor = new DefaultExecCommandExecutor();	}	ExecResult result = executor.execute(execCommand);	ObjectHelper.notNull(result, "The command executor must return a not-null result");	if (result.getExitValue() != 0) {	
the command returned exit value 

========================= camel sample_12227 =========================

public static void osgiUpdate(DefaultCamelContext camelContext, BundleContext bundleContext) {	ObjectHelper.notNull(bundleContext, "BundleContext");	
using osgicamelcontextnamestrategy 

public static void osgiUpdate(DefaultCamelContext camelContext, BundleContext bundleContext) {	ObjectHelper.notNull(bundleContext, "BundleContext");	camelContext.setNameStrategy(new OsgiCamelContextNameStrategy(bundleContext));	
using osgimanagementnamestrategy 

public static void osgiUpdate(DefaultCamelContext camelContext, BundleContext bundleContext) {	ObjectHelper.notNull(bundleContext, "BundleContext");	camelContext.setNameStrategy(new OsgiCamelContextNameStrategy(bundleContext));	camelContext.setManagementNameStrategy(new OsgiManagementNameStrategy(camelContext, bundleContext));	
using osgiclassresolver 

public static void osgiUpdate(DefaultCamelContext camelContext, BundleContext bundleContext) {	ObjectHelper.notNull(bundleContext, "BundleContext");	camelContext.setNameStrategy(new OsgiCamelContextNameStrategy(bundleContext));	camelContext.setManagementNameStrategy(new OsgiManagementNameStrategy(camelContext, bundleContext));	camelContext.setClassResolver(new OsgiClassResolver(camelContext, bundleContext));	
using osgifactoryfinderresolver 

public static void osgiUpdate(DefaultCamelContext camelContext, BundleContext bundleContext) {	ObjectHelper.notNull(bundleContext, "BundleContext");	camelContext.setNameStrategy(new OsgiCamelContextNameStrategy(bundleContext));	camelContext.setManagementNameStrategy(new OsgiManagementNameStrategy(camelContext, bundleContext));	camelContext.setClassResolver(new OsgiClassResolver(camelContext, bundleContext));	camelContext.setFactoryFinderResolver(new OsgiFactoryFinderResolver(bundleContext));	
using osgipackagescanclassresolver 

public static void osgiUpdate(DefaultCamelContext camelContext, BundleContext bundleContext) {	ObjectHelper.notNull(bundleContext, "BundleContext");	camelContext.setNameStrategy(new OsgiCamelContextNameStrategy(bundleContext));	camelContext.setManagementNameStrategy(new OsgiManagementNameStrategy(camelContext, bundleContext));	camelContext.setClassResolver(new OsgiClassResolver(camelContext, bundleContext));	camelContext.setFactoryFinderResolver(new OsgiFactoryFinderResolver(bundleContext));	camelContext.setPackageScanClassResolver(new OsgiPackageScanClassResolver(bundleContext));	
using osgicomponentresolver 

public static void osgiUpdate(DefaultCamelContext camelContext, BundleContext bundleContext) {	ObjectHelper.notNull(bundleContext, "BundleContext");	camelContext.setNameStrategy(new OsgiCamelContextNameStrategy(bundleContext));	camelContext.setManagementNameStrategy(new OsgiManagementNameStrategy(camelContext, bundleContext));	camelContext.setClassResolver(new OsgiClassResolver(camelContext, bundleContext));	camelContext.setFactoryFinderResolver(new OsgiFactoryFinderResolver(bundleContext));	camelContext.setPackageScanClassResolver(new OsgiPackageScanClassResolver(bundleContext));	camelContext.setComponentResolver(new OsgiComponentResolver(bundleContext));	
using osgilanguageresolver 

public static void osgiUpdate(DefaultCamelContext camelContext, BundleContext bundleContext) {	ObjectHelper.notNull(bundleContext, "BundleContext");	camelContext.setNameStrategy(new OsgiCamelContextNameStrategy(bundleContext));	camelContext.setManagementNameStrategy(new OsgiManagementNameStrategy(camelContext, bundleContext));	camelContext.setClassResolver(new OsgiClassResolver(camelContext, bundleContext));	camelContext.setFactoryFinderResolver(new OsgiFactoryFinderResolver(bundleContext));	camelContext.setPackageScanClassResolver(new OsgiPackageScanClassResolver(bundleContext));	camelContext.setComponentResolver(new OsgiComponentResolver(bundleContext));	camelContext.setLanguageResolver(new OsgiLanguageResolver(bundleContext));	
using osgidataformatresolver 

public static Registry wrapRegistry(CamelContext camelContext, Registry registry, BundleContext bundleContext) {	ObjectHelper.notNull(bundleContext, "BundleContext");	
setting up osgi serviceregistry 

========================= camel sample_13089 =========================

public AS400 getConnection() {	AS400 system = null;	try {	if (LOG.isDebugEnabled()) {	
getting an object for from 

system = connectionPool.getSecureConnection(systemName, userID, password);	} else {	system = connectionPool.getConnection(systemName, userID, password);	}	if (ccsid != DEFAULT_SYSTEM_CCSID) {	system.setCcsid(ccsid);	}	try {	system.setGuiAvailable(guiAvailable);	} catch (PropertyVetoException e) {	
failed to disable as prompting in the environment running camel this exception will be ignored 

========================= camel sample_16771 =========================

public void configure() {	from("timer:period=20000") .setHeader("CamelFacebook.reading.limit", constant("10")) .process(new Processor() {	public void process(Exchange exchange) throws Exception {	if (lastTimestamp > 0) {	exchange.getIn().setHeader("CamelFacebook.reading.since", lastTimestamp);	}	}	}) .to("facebook: .process(new Processor() {	public void process(Exchange exchange) throws Exception {	ResponseList<Post> body = (ResponseList<Post>) exchange.getIn().getBody();	
number of posts received 

========================= camel sample_9585 =========================

policy.setRouteResumeRepeatInterval(3000);	from("direct:start") .routeId("test") .routePolicy(policy) .to("mock:success");	}	});	context.start();	ServiceHelper.suspendService(context.getRoute("test").getConsumer());	try {	template.sendBody("direct:start", "Ready or not, Here, I come");	fail("Should have thrown an exception");	} catch (CamelExecutionException e) {	
consumer successfully suspended 

policy.setRouteResumeRepeatInterval(3000);	from("direct:start") .routeId("test") .routePolicy(policy) .to("mock:success");	}	});	context.start();	Thread.sleep(1000);	try {	template.sendBody("direct:start", "Ready or not, Here, I come");	fail("Should have thrown an exception");	} catch (CamelExecutionException e) {	
consumer successfully suspended 

policy.setRouteResumeRepeatInterval(3000);	from("direct:start") .routeId("test") .routePolicy(policy) .to("mock:success");	}	});	context.start();	Thread.sleep(1000);	try {	template.sendBody("direct:start", "Ready or not, Here, I come");	fail("Should have thrown an exception");	} catch (CamelExecutionException e) {	
consumer successfully suspended 

========================= camel sample_17160 =========================

int completionTimeout = 1000;	int completionSize = 200;	fromF("sjms-batch:%s?completionTimeout=%s&completionSize=%s&consumerCount=%s&aggregationStrategy=#testStrategy", queueName, completionTimeout, completionSize, consumerCount) .routeId("batchConsumer").startupOrder(10).autoStartup(false) .split(body()) .to("mock:split");	}	});	context.start();	MockEndpoint mockBefore = getMockEndpoint("mock:before");	mockBefore.setExpectedMessageCount(messageCount);	MockEndpoint mockSplit = getMockEndpoint("mock:split");	mockSplit.setExpectedMessageCount(messageCount);	
sending messages 

int completionSize = 200;	fromF("sjms-batch:%s?completionTimeout=%s&completionSize=%s&consumerCount=%s&aggregationStrategy=#testStrategy", queueName, completionTimeout, completionSize, consumerCount) .routeId("batchConsumer").startupOrder(10).autoStartup(false) .split(body()) .to("mock:split");	}	});	context.start();	MockEndpoint mockBefore = getMockEndpoint("mock:before");	mockBefore.setExpectedMessageCount(messageCount);	MockEndpoint mockSplit = getMockEndpoint("mock:split");	mockSplit.setExpectedMessageCount(messageCount);	template.sendBody("direct:in", generateStrings(messageCount));	
send complete 

context.start();	MockEndpoint mockBefore = getMockEndpoint("mock:before");	mockBefore.setExpectedMessageCount(messageCount);	MockEndpoint mockSplit = getMockEndpoint("mock:split");	mockSplit.setExpectedMessageCount(messageCount);	template.sendBody("direct:in", generateStrings(messageCount));	StopWatch stopWatch = new StopWatch();	context.startRoute("batchConsumer");	assertMockEndpointsSatisfied();	long time = stopWatch.stop();	
processed messages in ms 

context.start();	MockEndpoint mockBefore = getMockEndpoint("mock:before");	mockBefore.setExpectedMessageCount(messageCount);	MockEndpoint mockSplit = getMockEndpoint("mock:split");	mockSplit.setExpectedMessageCount(messageCount);	template.sendBody("direct:in", generateStrings(messageCount));	StopWatch stopWatch = new StopWatch();	context.startRoute("batchConsumer");	assertMockEndpointsSatisfied();	long time = stopWatch.stop();	
average throughput msg s 

int completionTimeout = 1000;	int completionSize = 200;	fromF("sjms-batch:%s?completionTimeout=%s&completionSize=%s&consumerCount=%s&aggregationStrategy=#testStrategy&keepAliveDelay=300", queueName, completionTimeout, completionSize, consumerCount) .routeId("batchConsumer").startupOrder(10).autoStartup(false) .split(body()) .to("mock:split");	}	});	context.start();	MockEndpoint mockBefore = getMockEndpoint("mock:before");	mockBefore.setExpectedMessageCount(messageCount);	MockEndpoint mockSplit = getMockEndpoint("mock:split");	mockSplit.setExpectedMessageCount(messageCount);	
sending messages 

int completionSize = 200;	fromF("sjms-batch:%s?completionTimeout=%s&completionSize=%s&consumerCount=%s&aggregationStrategy=#testStrategy&keepAliveDelay=300", queueName, completionTimeout, completionSize, consumerCount) .routeId("batchConsumer").startupOrder(10).autoStartup(false) .split(body()) .to("mock:split");	}	});	context.start();	MockEndpoint mockBefore = getMockEndpoint("mock:before");	mockBefore.setExpectedMessageCount(messageCount);	MockEndpoint mockSplit = getMockEndpoint("mock:split");	mockSplit.setExpectedMessageCount(messageCount);	template.sendBody("direct:in", generateStrings(messageCount));	
send complete 

========================= camel sample_12362 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<GangliaComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ganglia.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ganglia.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_528 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	String routeId = "mllp-sender";	public void configure() {	
write error 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	String routeId = "mllp-sender";	public void configure() {	
receive error 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	String routeId = "mllp-sender";	public void configure() {	
sending message mllp log logginglevel info routeid acknowledgement to complete 

source.sendBody(Hl7TestMessageGenerator.generateMessage());	assertTrue("Should have completed two exchanges", done.matches(5, TimeUnit.SECONDS));	Thread.sleep((long) (IDLE_TIMEOUT * 1.1));	try {	mllpServer.checkClientConnections();	fail("Should receive and exception for the closed connection");	} catch (MllpJUnitResourceException expectedEx) {	}	source.sendBody(Hl7TestMessageGenerator.generateMessage());	assertMockEndpointsSatisfied(5, TimeUnit.SECONDS);	
Breakpoint 

========================= camel sample_13857 =========================

public RoutePolicy createRoutePolicy(CamelContext camelContext, String routeId, RouteDefinition route) {	if (filters.stream().allMatch(filter -> filter.test(camelContext, routeId, route))) {	if (ObjectHelper.isNotEmpty(route.getRoutePolicies())) {	if (route.getRoutePolicies().stream().anyMatch(ClusteredRoutePolicy.class::isInstance)) {	
route has a clusteredroutepolicy already set up 

return null;	}	}	try {	final ClusteredRouteConfiguration configuration = configurations.getOrDefault(routeId, defaultConfiguration);	final String namespace = ObjectHelper.supplyIfEmpty(configuration.getNamespace(), defaultConfiguration::getNamespace);	final Duration initialDelay = ObjectHelper.supplyIfEmpty(configuration.getInitialDelay(), defaultConfiguration::getInitialDelay);	ClusteredRoutePolicy policy = ClusteredRoutePolicy.forNamespace(clusterService, namespace);	policy.setCamelContext(getCamelContext());	policy.setInitialDelay(initialDelay);	
attaching route to namespace 

========================= camel sample_3956 =========================

protected void marshalInternal(InputStream is, OutputStream os, Exchange exchange) throws Exception {	
content encryption algorithm 

protected void marshalInternal(InputStream is, OutputStream os, Exchange exchange) throws Exception {	
parameter secretkeylength 

protected void marshalInternal(InputStream is, OutputStream os, Exchange exchange) throws Exception {	OutputStream encryptingStream = null;	try {	CMSEnvelopedDataStreamGenerator gen = new CMSEnvelopedDataStreamGenerator();	OriginatorInformationProvider originatorInformationProvider = conf.getOriginatorInformationProvider();	if (originatorInformationProvider != null) {	
originatorinformationprovider found 

protected void marshalInternal(InputStream is, OutputStream os, Exchange exchange) throws Exception {	OutputStream encryptingStream = null;	try {	CMSEnvelopedDataStreamGenerator gen = new CMSEnvelopedDataStreamGenerator();	OriginatorInformationProvider originatorInformationProvider = conf.getOriginatorInformationProvider();	if (originatorInformationProvider != null) {	OriginatorInformation originatorInformation = originatorInformationProvider.getOriginatorInformation(exchange);	if (originatorInformation != null) {	
originatorinformation found 

CMSEnvelopedDataStreamGenerator gen = new CMSEnvelopedDataStreamGenerator();	OriginatorInformationProvider originatorInformationProvider = conf.getOriginatorInformationProvider();	if (originatorInformationProvider != null) {	OriginatorInformation originatorInformation = originatorInformationProvider.getOriginatorInformation(exchange);	if (originatorInformation != null) {	gen.setOriginatorInfo(originatorInformation);	}	}	AttributesGeneratorProvider attributeGeneratorProvider = conf.getUnprotectedAttributesGeneratorProvider();	if (attributeGeneratorProvider != null) {	
attributegeneratorprovider found 

}	AttributesGeneratorProvider attributeGeneratorProvider = conf.getUnprotectedAttributesGeneratorProvider();	if (attributeGeneratorProvider != null) {	gen.setUnprotectedAttributeGenerator(attributeGeneratorProvider.getAttributesGenerator(exchange));	}	if (conf.getRecipient().isEmpty()) {	throw new CryptoCmsException("No recipient configured.");	}	for (RecipientInfo recipientInfo : conf.getRecipient()) {	TransRecipientInfo keyTransrecipientInfo = (TransRecipientInfo)recipientInfo;	
recipient info 

AttributesGeneratorProvider attributeGeneratorProvider = conf.getUnprotectedAttributesGeneratorProvider();	if (attributeGeneratorProvider != null) {	gen.setUnprotectedAttributeGenerator(attributeGeneratorProvider.getAttributesGenerator(exchange));	}	if (conf.getRecipient().isEmpty()) {	throw new CryptoCmsException("No recipient configured.");	}	for (RecipientInfo recipientInfo : conf.getRecipient()) {	TransRecipientInfo keyTransrecipientInfo = (TransRecipientInfo)recipientInfo;	X509Certificate encryptCert = keyTransrecipientInfo.getCertificate(exchange);	
encryption certificate for recipient with 

TransRecipientInfo keyTransrecipientInfo = (TransRecipientInfo)recipientInfo;	X509Certificate encryptCert = keyTransrecipientInfo.getCertificate(exchange);	AlgorithmIdentifier keyEncryptionAlgorithm = determineKeyEncryptionAlgorithmIdentifier(keyTransrecipientInfo.getKeyEncryptionAlgorithm(exchange), keyTransrecipientInfo);	JceKeyTransRecipientInfoGenerator keyTransRecipeintInfoGen = new JceKeyTransRecipientInfoGenerator(encryptCert, keyEncryptionAlgorithm);	keyTransRecipeintInfoGen.setProvider(BouncyCastleProvider.PROVIDER_NAME);	gen.addRecipientInfoGenerator(keyTransRecipeintInfoGen);	}	OutputEncryptor encryptor = new JceCMSContentEncryptorBuilder(conf.getAlgorithmID()).setProvider(BouncyCastleProvider.PROVIDER_NAME).build();	encryptingStream = gen.open(os, encryptor);	IOHelper.copy(is, encryptingStream);	
cms enveloped data creation successful 

========================= camel sample_11539 =========================

public void testStopStart() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceived("A");	template.sendBody("seda:foo", "A");	assertMockEndpointsSatisfied();	
Stopping 

resetMocks();	mock.expectedMessageCount(0);	context.stopRoute("foo");	assertEquals("Stopped", context.getRouteStatus("foo").name());	Route route = context.getRoute("foo");	if (route instanceof StatefulService) {	assertEquals("Stopped", ((StatefulService) route).getStatus().name());	}	template.sendBody("seda:foo", "B");	mock.assertIsSatisfied(1000);	
Starting 

========================= camel sample_1438 =========================

public void testWSHttpCallEcho() throws Exception {	{	final List<String> received = new ArrayList<String>();	final CountDownLatch latch = new CountDownLatch(1);	final AsyncHttpClient c = new DefaultAsyncHttpClient();	final WebSocket websocket = c.prepareGet("ws: new WebSocketUpgradeHandler.Builder() .addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

websocket.close();	c.close();	}	{	final List<String> received = new ArrayList<String>();	final CountDownLatch latch = new CountDownLatch(1);	final AsyncHttpClient c = new DefaultAsyncHttpClient();	final WebSocket websocket = c.prepareGet("ws: new WebSocketUpgradeHandler.Builder() .addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

========================= camel sample_13154 =========================

public void testConsume() throws Exception {	final MockEndpoint mockEndpoint = camelContext.getEndpoint("mock:results", MockEndpoint.class);	mockEndpoint.expectedBodiesReceived("b", "d");	Observable<Order> observable = reactiveCamel.toObservable("seda:orders", Order.class);	Observable<String> largeOrderIds = observable.filter(order -> order.getAmount() > 100.0).map(order -> order.getId());	largeOrderIds.take(2).subscribe(body -> {	
processing 

========================= camel sample_11169 =========================

public ModelMBean assemble(MBeanServer mBeanServer, Object obj, ObjectName name) throws JMException {	ModelMBeanInfo mbi = null;	if (obj instanceof ManagedInstance) {	Object custom = ((ManagedInstance) obj).getInstance();	if (custom != null && ObjectHelper.hasAnnotation(custom.getClass().getAnnotations(), ManagedResource.class)) {	
assembling mbeaninfo for from custom managedresource object 

ModelMBeanInfo mbi = null;	if (obj instanceof ManagedInstance) {	Object custom = ((ManagedInstance) obj).getInstance();	if (custom != null && ObjectHelper.hasAnnotation(custom.getClass().getAnnotations(), ManagedResource.class)) {	mbi = springAssembler.getMBeanInfo(custom, name.toString());	obj = custom;	}	}	if (mbi == null) {	if (ObjectHelper.hasAnnotation(obj.getClass().getAnnotations(), ManagedResource.class)) {	
assembling mbeaninfo for from managedresource object 

obj = custom;	}	}	if (mbi == null) {	if (ObjectHelper.hasAnnotation(obj.getClass().getAnnotations(), ManagedResource.class)) {	mbi = springAssembler.getMBeanInfo(obj, name.toString());	} else {	return super.assemble(mBeanServer, obj, name);	}	}	
assembled mbeaninfo 

========================= camel sample_16356 =========================

protected InputStream resolveResource(String resource) throws IOException {	InputStream is = null;	try {	
trying to open resource as a file 

protected InputStream resolveResource(String resource) throws IOException {	InputStream is = null;	try {	is = new FileInputStream(resource);	
opened resource as a file 

protected InputStream resolveResource(String resource) throws IOException {	InputStream is = null;	try {	is = new FileInputStream(resource);	} catch (FileNotFoundException e) {	
could not open resource as a file 

protected InputStream resolveResource(String resource) throws IOException {	InputStream is = null;	try {	is = new FileInputStream(resource);	} catch (FileNotFoundException e) {	}	if (is == null && this.context != null) {	
trying to open resource using the camelcontext classresolver 

protected InputStream resolveResource(String resource) throws IOException {	InputStream is = null;	try {	is = new FileInputStream(resource);	} catch (FileNotFoundException e) {	}	if (is == null && this.context != null) {	try {	is = context.getClassResolver().loadResourceAsStream(resource);	if (is == null) {	
could not to open resource using the camelcontext classresolver 

InputStream is = null;	try {	is = new FileInputStream(resource);	} catch (FileNotFoundException e) {	}	if (is == null && this.context != null) {	try {	is = context.getClassResolver().loadResourceAsStream(resource);	if (is == null) {	} else {	
opened resource using the camelcontext classresolver 

is = new FileInputStream(resource);	} catch (FileNotFoundException e) {	}	if (is == null && this.context != null) {	try {	is = context.getClassResolver().loadResourceAsStream(resource);	if (is == null) {	} else {	}	} catch (Throwable e) {	
could not open resource using the camelcontext classresolver 

if (is == null && this.context != null) {	try {	is = context.getClassResolver().loadResourceAsStream(resource);	if (is == null) {	} else {	}	} catch (Throwable e) {	}	}	if (is == null && Thread.currentThread().getContextClassLoader() != null) {	
trying to open resource as a class path resource with the tccl 

is = context.getClassResolver().loadResourceAsStream(resource);	if (is == null) {	} else {	}	} catch (Throwable e) {	}	}	if (is == null && Thread.currentThread().getContextClassLoader() != null) {	is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);	if (is == null) {	
could not open resource as a class path resource using the tccl 

if (is == null) {	} else {	}	} catch (Throwable e) {	}	}	if (is == null && Thread.currentThread().getContextClassLoader() != null) {	is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);	if (is == null) {	} else {	
opened resource as a class path resource with the tccl 

} catch (Throwable e) {	}	}	if (is == null && Thread.currentThread().getContextClassLoader() != null) {	is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);	if (is == null) {	} else {	}	}	if (is == null) {	
trying to open resource as a class path resource using the classloader 

}	if (is == null && Thread.currentThread().getContextClassLoader() != null) {	is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);	if (is == null) {	} else {	}	}	if (is == null) {	is = this.getClass().getResourceAsStream(resource);	if (is == null) {	
could not open resource as a class path resource using the classloader 

if (is == null && Thread.currentThread().getContextClassLoader() != null) {	is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);	if (is == null) {	} else {	}	}	if (is == null) {	is = this.getClass().getResourceAsStream(resource);	if (is == null) {	} else {	
opened resource as a class path resource with the classloader 

}	}	if (is == null) {	is = this.getClass().getResourceAsStream(resource);	if (is == null) {	} else {	}	}	if (is == null) {	try {	
trying to open resource as a url 

}	if (is == null) {	is = this.getClass().getResourceAsStream(resource);	if (is == null) {	} else {	}	}	if (is == null) {	try {	is = new URL(resource).openStream();	
opened resource as a url 

if (is == null) {	is = this.getClass().getResourceAsStream(resource);	if (is == null) {	} else {	}	}	if (is == null) {	try {	is = new URL(resource).openStream();	} catch (IOException e) {	
could not open resource as a url 

========================= camel sample_4285 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<AtomixQueueComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.atomix-queue.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.atomix-queue.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1087 =========================

public void run() throws TTransportException {	TTransport transport = new TSocket("localhost", THRIFT_SYNC_REQUEST_TEST_PORT);	transport.open();	TProtocol protocol = new TBinaryProtocol(new TFramedTransport(transport));	Calculator.Client client = (new Calculator.Client.Factory()).getClient(protocol);	int instanceId = createId();	int calculateResponse = 0;	try {	calculateResponse = client.calculate(1, new Work(instanceId, THRIFT_TEST_NUM1, Operation.MULTIPLY));	} catch (TException e) {	
Exception 

RunnableAssert ra = new RunnableAssert("testAsyncWithConcurrentThreads") {	public void run() throws TTransportException, IOException, InterruptedException {	final CountDownLatch latch = new CountDownLatch(1);	TNonblockingTransport transport = new TNonblockingSocket("localhost", THRIFT_ASYNC_REQUEST_TEST_PORT);	Calculator.AsyncClient client = (new Calculator.AsyncClient.Factory(new TAsyncClientManager(), new TBinaryProtocol.Factory())).getAsyncClient(transport);	int instanceId = createId();	CalculateAsyncMethodCallback calculateCallback = new CalculateAsyncMethodCallback(latch);	try {	client.calculate(1, new Work(instanceId, THRIFT_TEST_NUM1, Operation.MULTIPLY), calculateCallback);	} catch (TException e) {	
Exception 

public void onError(Exception exception) {	
Exception 

========================= camel sample_13011 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<SnakeYAMLDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.yaml-snakeyaml.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.yaml-snakeyaml.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_949 =========================

public void someMethod(String body, @Header("foo") String header, @ExchangeProperty("cheese") String cheese) throws ValidationException {	assertEquals("old", cheese);	if ("bar".equals(header)) {	
somemethod called with valid header and body 

========================= camel sample_2351 =========================

int pos = uri.indexOf(" if (pos != -1) {	String part = uri.substring(pos + 2);	if (part.startsWith("http:") || part.startsWith("https:")) {	throw new ResolveEndpointFailedException(uri, "The uri part is not configured correctly. You have duplicated the http(s) protocol.");	}	}	HttpClientConfigurer configurer = createHttpClientConfigurer(parameters, secure);	URI endpointUri = URISupport.createRemainingURI(uriHttpUriAddress, httpClientParameters);	String scheme = ObjectHelper.before(uri, ": endpointUri = URISupport.createRemainingURI( new URI(scheme, endpointUri.getUserInfo(), endpointUri.getHost(), endpointUri.getPort(), endpointUri.getPath(), endpointUri.getQuery(), endpointUri.getFragment()), httpClientParameters);	String endpointUriString = endpointUri.toString();	
creating endpoint uri 

if (localMaxTotalConnections > 0) {	answer.setMaxTotal(localMaxTotalConnections);	}	int localConnectionsPerRoute = connectionsPerRoute;	if (localConnectionsPerRoute == 0) {	localConnectionsPerRoute = getConnectionsPerRoute();	}	if (localConnectionsPerRoute > 0) {	answer.setDefaultMaxPerRoute(localConnectionsPerRoute);	}	
created clientconnectionmanager 

public void doStop() throws Exception {	if (clientConnectionManager != null) {	
shutting down clientconnectionmanager 

========================= camel sample_17052 =========================

public void testAsyncEndpointEventNotifier() throws Exception {	getMockEndpoint("mock:before").expectedBodiesReceived("Hello Camel");	getMockEndpoint("mock:result").expectedBodiesReceived("Bye Camel");	String reply = template.requestBody("direct:start", "Hello Camel", String.class);	assertEquals("Bye Camel", reply);	assertMockEndpointsSatisfied();	assertTrue("Should count down", latch.await(10, TimeUnit.SECONDS));	long delta = time.get();	
exchangeeventsent took ms 

========================= camel sample_1984 =========================

public static void startGrpcServer() throws Exception {	grpcServer = ServerBuilder.forPort(GRPC_TEST_PORT).addService(new PingPongImpl()).build().start();	
grpc server started on port 

public static void stopGrpcServer() throws IOException {	if (grpcServer != null) {	grpcServer.shutdown();	
grpc server stoped 

public void testPingSyncSyncMethodInvocation() throws Exception {	
grpc pingsyncsync method test start 

public void testPingSyncAsyncMethodInvocation() throws Exception {	
grpc pingsyncasync method test start 

public void testPingAsyncSyncMethodInvocation() throws Exception {	
grpc pingasyncsync method test start 

public void testPingAsyncAsyncMethodInvocation() throws Exception {	
grpc pingasyncasync method test start 

public StreamObserver<PingRequest> pingAsyncSync(StreamObserver<PongResponse> responseObserver) {	StreamObserver<PingRequest> requestObserver = new StreamObserver<PingRequest>() {	public void onNext(PingRequest request) {	PongResponse response = PongResponse.newBuilder().setPongName(request.getPingName() + GRPC_TEST_PONG_VALUE).setPongId(request.getPingId()).build();	responseObserver.onNext(response);	}	public void onError(Throwable t) {	
error in pingasyncsync 

public StreamObserver<PingRequest> pingAsyncAsync(StreamObserver<PongResponse> responseObserver) {	StreamObserver<PingRequest> requestObserver = new StreamObserver<PingRequest>() {	public void onNext(PingRequest request) {	PongResponse response = PongResponse.newBuilder().setPongName(request.getPingName() + GRPC_TEST_PONG_VALUE).setPongId(request.getPingId()).build();	responseObserver.onNext(response);	}	public void onError(Throwable t) {	
error in pingasyncasync 

========================= camel sample_7503 =========================

public XmppPrivateChatProducer(XmppEndpoint endpoint, String participant) {	super(endpoint);	this.endpoint = endpoint;	this.participant = participant;	StringHelper.notEmpty(participant, "participant");	
creating xmppprivatechatproducer to participant 

}	Message message = new Message();	try {	message.setTo(JidCreate.from(participant));	message.setThread(thread);	message.setType(Message.Type.normal);	ChatManager chatManager = ChatManager.getInstanceFor(connection);	Chat chat = getOrCreateChat(chatManager, participant, thread);	endpoint.getBinding().populateXmppMessage(message, exchange);	if (LOG.isDebugEnabled()) {	
sending xmpp message to from 

private synchronized void reconnect() throws InterruptedException, IOException, SmackException, XMPPException {	if (!connection.isConnected()) {	if (LOG.isDebugEnabled()) {	
reconnecting to 

protected void doStart() throws Exception {	if (connection == null) {	try {	connection = endpoint.createConnection();	} catch (SmackException e) {	if (endpoint.isTestConnectionOnStartup()) {	throw new RuntimeException("Could not establish connection to XMPP server: " + endpoint.getConnectionDescription(), e);	} else {	
could not connect to xmpp server producer will attempt lazy connection when needed 

========================= camel sample_12600 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<JacksonDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.json-jackson.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.json-jackson.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_1204 =========================

public Consumer createConsumer(Processor processor) throws Exception {	IgniteEvents events = createIgniteEvents();	IgniteEventsConsumer consumer = new IgniteEventsConsumer(this, processor, events);	configureConsumer(consumer);	
created ignite events consumer for event types 

private IgniteEvents createIgniteEvents() {	Ignite ignite = ignite();	IgniteEvents events;	if (clusterGroupExpression == null) {	
ignite events endpoint for event types using no cluster group 

private IgniteEvents createIgniteEvents() {	Ignite ignite = ignite();	IgniteEvents events;	if (clusterGroupExpression == null) {	events = ignite.events();	} else {	ClusterGroup group = clusterGroupExpression.getClusterGroup(ignite);	
ignite events endpoint for event types using cluster group 

========================= camel sample_11305 =========================

public void testInOut() throws Exception {	getMockEndpoint("mock:log").expectedBodiesReceived("Logging: Bye World");	String out = template.requestBody("direct:start", "Hello World", String.class);	assertEquals("Bye World", out);	
got reply 

========================= camel sample_3393 =========================

public void onEvent(Map<String, Object> heartbeat) {	String key = (String) heartbeat.get("name");	
event for details 

========================= camel sample_6938 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<FtpsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ftps.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ftps.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_733 =========================

private HdfsInfo setupHdfs(boolean onStartup) throws Exception {	if (onStartup) {	
connecting to hdfs file system may take a while if connection is not available 

private HdfsInfo setupHdfs(boolean onStartup) throws Exception {	if (onStartup) {	} else {	if (log.isDebugEnabled()) {	
connecting to hdfs file system may take a while if connection is not available 

private HdfsInfo setupHdfs(boolean onStartup) throws Exception {	if (onStartup) {	} else {	if (log.isDebugEnabled()) {	}	}	HdfsInfo answer = HdfsInfoFactory.newHdfsInfo(this.hdfsPath.toString());	if (onStartup) {	
connected to hdfs file system 

private HdfsInfo setupHdfs(boolean onStartup) throws Exception {	if (onStartup) {	} else {	if (log.isDebugEnabled()) {	}	}	HdfsInfo answer = HdfsInfoFactory.newHdfsInfo(this.hdfsPath.toString());	if (onStartup) {	} else {	if (log.isDebugEnabled()) {	
connected to hdfs file system 

Path pattern = info.getPath().suffix("/" + this.config.getPattern());	fileStatuses = info.getFileSystem().globStatus(pattern, new ExcludePathFilter());	}	for (FileStatus status : fileStatuses) {	if (normalFileIsDirectoryNoSuccessFile(status, info)) {	continue;	}	if (config.getOwner() != null) {	if (!config.getOwner().equals(status.getOwner())) {	if (log.isDebugEnabled()) {	
skipping file as not matching owner 

if (log.isDebugEnabled()) {	}	continue;	}	}	try {	this.rwlock.writeLock().lock();	this.istream = HdfsInputStream.createInputStream(status.getPath().toString(), this.config);	if (!this.istream.isOpened()) {	if (log.isDebugEnabled()) {	
skipping file because it doesn t exist anymore 

Exchange exchange = this.getEndpoint().createExchange();	Message message = new DefaultMessage(this.getEndpoint().getCamelContext());	String fileName = StringUtils.substringAfterLast(status.getPath().toString(), "/");	message.setHeader(Exchange.FILE_NAME, fileName);	message.setHeader(Exchange.FILE_PATH, status.getPath().toString());	if (key.value != null) {	message.setHeader(HdfsHeader.KEY.name(), key.value);	}	message.setBody(value.value);	exchange.setIn(message);	
processing file 

========================= camel sample_12179 =========================

protected void doStart() throws Exception {	super.doStart();	if (bundleContext == null) {	String descriptors = getDescriptors();	if (descriptors == null) {	throw new IllegalArgumentException("Descriptors must be provided, with the name of the blueprint XML file");	}	
starting blueprint xml file 

protected void doStop() throws Exception {	if (camelContext != null) {	camelContext.stop();	}	
stopping blueprint xml file 

========================= camel sample_10144 =========================

AbstractXmlApplicationContext db = new ClassPathXmlApplicationContext("org/apache/camel/routepolicy/quartz2/SpringQuartzClusteredAppDatabase.xml");	AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext("org/apache/camel/routepolicy/quartz2/SpringQuartzClusteredAppOne.xml");	AbstractXmlApplicationContext app2 = new ClassPathXmlApplicationContext("org/apache/camel/routepolicy/quartz2/SpringQuartzClusteredAppTwo.xml");	CamelContext camel = app.getBean("camelContext", CamelContext.class);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMessageCount(1);	mock.expectedBodiesReceived("clustering PINGS!");	Thread.sleep(5000);	app.getBean("template", ProducerTemplate.class).sendBody("direct:start", "clustering");	mock.assertIsSatisfied();	
the first app is going to crash now 

AbstractXmlApplicationContext app2 = new ClassPathXmlApplicationContext("org/apache/camel/routepolicy/quartz2/SpringQuartzClusteredAppTwo.xml");	CamelContext camel = app.getBean("camelContext", CamelContext.class);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMessageCount(1);	mock.expectedBodiesReceived("clustering PINGS!");	Thread.sleep(5000);	app.getBean("template", ProducerTemplate.class).sendBody("direct:start", "clustering");	mock.assertIsSatisfied();	app.getBean(Scheduler.class).shutdown();	IOHelper.close(app);	
crashed 

AbstractXmlApplicationContext app2 = new ClassPathXmlApplicationContext("org/apache/camel/routepolicy/quartz2/SpringQuartzClusteredAppTwo.xml");	CamelContext camel = app.getBean("camelContext", CamelContext.class);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMessageCount(1);	mock.expectedBodiesReceived("clustering PINGS!");	Thread.sleep(5000);	app.getBean("template", ProducerTemplate.class).sendBody("direct:start", "clustering");	mock.assertIsSatisfied();	app.getBean(Scheduler.class).shutdown();	IOHelper.close(app);	
crashed 

AbstractXmlApplicationContext app2 = new ClassPathXmlApplicationContext("org/apache/camel/routepolicy/quartz2/SpringQuartzClusteredAppTwo.xml");	CamelContext camel = app.getBean("camelContext", CamelContext.class);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMessageCount(1);	mock.expectedBodiesReceived("clustering PINGS!");	Thread.sleep(5000);	app.getBean("template", ProducerTemplate.class).sendBody("direct:start", "clustering");	mock.assertIsSatisfied();	app.getBean(Scheduler.class).shutdown();	IOHelper.close(app);	
crashed 

========================= camel sample_14941 =========================

public void act(final Client client, final Exchange exchange) throws NoSuchHeaderException {	final Message in = exchange.getIn();	final long priority = BeanstalkExchangeHelper.getPriority(endpoint, in);	final int delay = BeanstalkExchangeHelper.getDelay(endpoint, in);	final int timeToRun = BeanstalkExchangeHelper.getTimeToRun(endpoint, in);	final long jobId = client.put(priority, delay, timeToRun, in.getBody(byte[].class));	if (LOG.isDebugEnabled()) {	
created job d with priority d delay d seconds and time to run d 

========================= camel sample_8160 =========================

try {	if (camelContext != null && scriptResource != null) {	reader = createScriptReader(camelContext.getClassResolver(), scriptResource);	} else if (this.scriptText != null) {	reader = new StringReader(this.scriptText);	}	if (reader != null) {	if (compileScripte(camelContext) && scriptEngine instanceof Compilable) {	Compilable compilable = (Compilable) scriptEngine;	this.compiledScript = compilable.compile(reader);	
using compiled script 

ScriptEngineManager manager = new ScriptEngineManager(classLoader);	ScriptEngine engine = null;	String[] names = getScriptNames(language);	for (String name : names) {	try {	engine = manager.getEngineByName(name);	if (engine != null) {	break;	}	} catch (NoClassDefFoundError ex) {	
cannot load scriptengine for please ensure correct jars is provided on classpath stacktrace in debug logging 

ScriptEngineManager manager = new ScriptEngineManager(classLoader);	ScriptEngine engine = null;	String[] names = getScriptNames(language);	for (String name : names) {	try {	engine = manager.getEngineByName(name);	if (engine != null) {	break;	}	} catch (NoClassDefFoundError ex) {	
cannot load scriptengine for please ensure correct jars is provided on classpath 

private static ScriptEngine checkForOSGiEngine(String language) {	
no script engine found for using standard javax script auto registration checking osgi registry 

private static ScriptEngine checkForOSGiEngine(String language) {	try {	Class<?> c = Class.forName("org.apache.camel.script.osgi.Activator");	Method mth = c.getDeclaredMethod("getBundleContext");	Object ctx = mth.invoke(null);	
found osgi bundlecontext 

private static ScriptEngine checkForOSGiEngine(String language) {	try {	Class<?> c = Class.forName("org.apache.camel.script.osgi.Activator");	Method mth = c.getDeclaredMethod("getBundleContext");	Object ctx = mth.invoke(null);	if (ctx != null) {	Method resolveScriptEngine = c.getDeclaredMethod("resolveScriptEngine", String.class);	return (ScriptEngine)resolveScriptEngine.invoke(null, language);	}	} catch (Throwable t) {	
unable to detect osgi scriptengine for cannot be resolved 

protected Object evaluateScript(Exchange exchange) {	try {	if (reuseScriptEngine(exchange)) {	synchronized (this) {	
calling doevaluatescript without creating a new scriptengine 

protected Object evaluateScript(Exchange exchange) {	try {	if (reuseScriptEngine(exchange)) {	synchronized (this) {	return doEvaluateScript(exchange, scriptEngine);	}	} else {	
calling doevaluatescript with a new scriptengine 

if (reuseScriptEngine(exchange)) {	synchronized (this) {	return doEvaluateScript(exchange, scriptEngine);	}	} else {	ScriptEngine engine = scriptEngineFactory.getScriptEngine();	return doEvaluateScript(exchange, engine);	}	} catch (ScriptException e) {	if (LOG.isDebugEnabled()) {	
script evaluation failed 

protected Object doEvaluateScript(Exchange exchange, ScriptEngine scriptEngine) throws ScriptException, IOException {	ScriptContext context = populateBindings(scriptEngine, exchange, attributes);	addScriptEngineArguments(scriptEngine, exchange);	Object result = runScript(scriptEngine, exchange, context);	
the script evaluation result is 

protected Object runScript(ScriptEngine engine, Exchange exchange, ScriptContext context) throws ScriptException, IOException {	Object result = null;	if (compiledScript != null) {	
evaluate using compiled script for context on exchange 

protected Object runScript(ScriptEngine engine, Exchange exchange, ScriptContext context) throws ScriptException, IOException {	Object result = null;	if (compiledScript != null) {	result = compiledScript.eval(context);	} else {	if (scriptText != null) {	
evaluate script for context on exchange 

protected Object runScript(ScriptEngine engine, Exchange exchange, ScriptContext context) throws ScriptException, IOException {	Object result = null;	if (compiledScript != null) {	result = compiledScript.eval(context);	} else {	if (scriptText != null) {	result = engine.eval(scriptText, context);	} else if (scriptResource != null) {	Reader reader = createScriptReader(exchange.getContext().getClassResolver(), scriptResource);	try {	
evaluate script for context on exchange 

protected void addScriptEngineArguments(ScriptEngine engine, Exchange exchange) {	if (!exchange.getIn().hasHeaders()) {	return;	}	Map<Object, Object> args = exchange.getIn().getHeader(ARGUMENTS, Map.class);	if (args != null) {	for (Map.Entry<Object, Object> entry : args.entrySet()) {	String key = exchange.getContext().getTypeConverter().convertTo(String.class, entry.getKey());	Object value = entry.getValue();	if (!ObjectHelper.isEmpty(key) && value != null) {	
putting on scriptengine 

========================= camel sample_11240 =========================

return message;	}	for (LogListener listener : listeners) {	if (listener == null) {	continue;	}	try {	String output = listener.onLog(exchange, log, message);	message = output != null ? output : message;	} catch (Throwable t) {	
ignoring an exception thrown by 

========================= camel sample_4513 =========================

public void onFileSendToQueue(String body, @Header("CamelFileName") String name) {	
incoming file 

========================= camel sample_17843 =========================

protected String generateAcknowledgement(String hl7Message, String acknowledgementCode) {	final String defaulNackMessage = "MSH|^~\\&|||||||NACK||P|2.2" + MllpProtocolConstants.SEGMENT_DELIMITER + "MSA|AR|" + MllpProtocolConstants.SEGMENT_DELIMITER + MllpProtocolConstants.MESSAGE_TERMINATOR;	if (hl7Message == null) {	
invalid message for parsing operation please check your inputs 

throw new IllegalArgumentException("Acknowledgemnt Code must be AA, AE or AR: " + acknowledgementCode);	}	String messageControlId;	int endOfMshSegment = hl7Message.indexOf(MllpProtocolConstants.SEGMENT_DELIMITER);	if (-1 != endOfMshSegment) {	String mshSegment = hl7Message.substring(0, endOfMshSegment);	char fieldSeparator = mshSegment.charAt(3);	String fieldSeparatorPattern = Pattern.quote("" + fieldSeparator);	String[] mshFields = mshSegment.split(fieldSeparatorPattern);	if (mshFields.length == 0) {	
failed to split msh segment into fields 

ackBuilder.append(fieldSeparator);	--emptyFieldIndex;	}	}	ackBuilder.append(MllpProtocolConstants.SEGMENT_DELIMITER);	ackBuilder .append("MSA").append(fieldSeparator) .append(acknowledgementCode).append(fieldSeparator) .append(mshFields[9]).append(fieldSeparator) .append(MllpProtocolConstants.SEGMENT_DELIMITER);	ackBuilder.append(MllpProtocolConstants.MESSAGE_TERMINATOR);	return ackBuilder.toString();	}	} else {	
failed to find the end of the msh segment 

listenAddress = new InetSocketAddress(this.listenHost, this.listenPort);	} else {	listenAddress = new InetSocketAddress(this.listenPort);	}	long startTicks = System.currentTimeMillis();	while (!serverSocket.isBound()) {	try {	serverSocket.bind(listenAddress, backlog);	} catch (BindException bindEx) {	if (System.currentTimeMillis() < startTicks + bindTimeout) {	
unable to bind to retrying in milliseconds 

}	long startTicks = System.currentTimeMillis();	while (!serverSocket.isBound()) {	try {	serverSocket.bind(listenAddress, backlog);	} catch (BindException bindEx) {	if (System.currentTimeMillis() < startTicks + bindTimeout) {	try {	Thread.sleep(bindRetryDelay);	} catch (InterruptedException interruptedEx) {	
wait for bind retry was interrupted rethrowing bindexception 

Thread.sleep(bindRetryDelay);	} catch (InterruptedException interruptedEx) {	throw bindEx;	}	}	}	}	if (0 >= this.listenPort) {	this.listenPort = serverSocket.getLocalPort();	}	
opened tcp listener on port 

public void run() {	
accepting connections on port 

public void run() {	this.setName("MllpServerResource$AcceptSocketThread - " + serverSocket.getLocalSocketAddress().toString());	while (!isInterrupted() && serverSocket.isBound() && !serverSocket.isClosed()) {	Socket clientSocket = null;	try {	clientSocket = serverSocket.accept();	} catch (SocketTimeoutException timeoutEx) {	if (raiseExceptionOnAcceptTimeout) {	throw new MllpJUnitResourceTimeoutException("Timeout Accepting client connection", timeoutEx);	}	
timeout waiting for client connection 

this.setName("MllpServerResource$AcceptSocketThread - " + serverSocket.getLocalSocketAddress().toString());	while (!isInterrupted() && serverSocket.isBound() && !serverSocket.isClosed()) {	Socket clientSocket = null;	try {	clientSocket = serverSocket.accept();	} catch (SocketTimeoutException timeoutEx) {	if (raiseExceptionOnAcceptTimeout) {	throw new MllpJUnitResourceTimeoutException("Timeout Accepting client connection", timeoutEx);	}	} catch (SocketException socketEx) {	
socketexception encountered accepting client connection ignoring 

if (raiseExceptionOnAcceptTimeout) {	throw new MllpJUnitResourceTimeoutException("Timeout Accepting client connection", timeoutEx);	}	} catch (SocketException socketEx) {	if (null == clientSocket) {	continue;	} else if (!clientSocket.isClosed()) {	try {	clientSocket.setSoLinger(true, 0);	} catch (SocketException soLingerEx) {	
ignoring socketexception encountered when setting so linger in preparation of resetting client socket 

if (null == clientSocket) {	continue;	} else if (!clientSocket.isClosed()) {	try {	clientSocket.setSoLinger(true, 0);	} catch (SocketException soLingerEx) {	}	try {	clientSocket.close();	} catch (IOException ioEx) {	
ignoring ioexception encountered when resetting client socket 

try {	clientSocket.setKeepAlive(true);	clientSocket.setTcpNoDelay(false);	clientSocket.setSoLinger(false, -1);	clientSocket.setSoTimeout(5000);	ClientSocketThread clientSocketThread = new ClientSocketThread(clientSocket);	clientSocketThread.setDaemon(true);	clientSocketThread.start();	clientSocketThreads.add(clientSocketThread);	} catch (Exception unexpectedEx) {	
unexpected exception encountered configuring client socket 

clientSocket.setSoLinger(false, -1);	clientSocket.setSoTimeout(5000);	ClientSocketThread clientSocketThread = new ClientSocketThread(clientSocket);	clientSocketThread.setDaemon(true);	clientSocketThread.start();	clientSocketThreads.add(clientSocketThread);	} catch (Exception unexpectedEx) {	try {	clientSocket.close();	} catch (IOException ingoreEx) {	
exceptiong encountered closing client socket after attempting to accept connection 

clientSocketThreads.add(clientSocketThread);	} catch (Exception unexpectedEx) {	try {	clientSocket.close();	} catch (IOException ingoreEx) {	}	throw new MllpJUnitResourceException("Unexpected exception encountered configuring client socket", unexpectedEx);	}	}	}	
no longer accepting connections closing tcp listener on port 

}	throw new MllpJUnitResourceException("Unexpected exception encountered configuring client socket", unexpectedEx);	}	}	}	try {	serverSocket.close();	} catch (IOException e) {	e.printStackTrace();	}	
closed tcp listener on port 

public void interrupt() {	for (ClientSocketThread clientSocketThread : clientSocketThreads) {	clientSocketThread.interrupt();	}	if (serverSocket != null && serverSocket.isBound() && !serverSocket.isClosed()) {	try {	serverSocket.close();	} catch (Exception ex) {	
exception encountered closing server socket on interrupt 

public String getMessage(InputStream anInputStream) throws IOException {	try {	boolean waitingForStartOfBlock = true;	while (waitingForStartOfBlock) {	int potentialStartCharacter = anInputStream.read();	switch (potentialStartCharacter) {	case MllpProtocolConstants.END_OF_STREAM: return null;	case MllpProtocolConstants.START_OF_BLOCK: waitingForStartOfBlock = false;	break;	
start of block character has not been received out of band character received 

int potentialStartCharacter = anInputStream.read();	switch (potentialStartCharacter) {	case MllpProtocolConstants.END_OF_STREAM: return null;	case MllpProtocolConstants.START_OF_BLOCK: waitingForStartOfBlock = false;	break;	}	}	} catch (SocketException socketEx) {	if (clientSocket != null) {	if (clientSocket.isClosed()) {	
client socket closed while waiting for start of block 

switch (potentialStartCharacter) {	case MllpProtocolConstants.END_OF_STREAM: return null;	case MllpProtocolConstants.START_OF_BLOCK: waitingForStartOfBlock = false;	break;	}	}	} catch (SocketException socketEx) {	if (clientSocket != null) {	if (clientSocket.isClosed()) {	} else if (clientSocket.isConnected()) {	
socketexception encountered while waiting for start of block 

case MllpProtocolConstants.START_OF_BLOCK: waitingForStartOfBlock = false;	break;	}	}	} catch (SocketException socketEx) {	if (clientSocket != null) {	if (clientSocket.isClosed()) {	} else if (clientSocket.isConnected()) {	resetConnection();	} else {	
unable to read from socket stream when expected start of block resetting connection 

resetConnection();	}	}	return null;	}	boolean endOfMessage = false;	StringBuilder parsedMessage = new StringBuilder(anInputStream.available() + 10);	while (!endOfMessage) {	int characterReceived = anInputStream.read();	switch (characterReceived) {	
received start of block before end of data discarding data 

}	}	return null;	}	boolean endOfMessage = false;	StringBuilder parsedMessage = new StringBuilder(anInputStream.available() + 10);	while (!endOfMessage) {	int characterReceived = anInputStream.read();	switch (characterReceived) {	return null;	
received end of stream without end of data discarding data 

}	boolean endOfMessage = false;	StringBuilder parsedMessage = new StringBuilder(anInputStream.available() + 10);	while (!endOfMessage) {	int characterReceived = anInputStream.read();	switch (characterReceived) {	return null;	return null;	case MllpProtocolConstants.END_OF_BLOCK: characterReceived = anInputStream.read();	if (characterReceived != MllpProtocolConstants.END_OF_DATA) {	
received when expecting end of data after end of block discarding 

private void uncheckedSleep(long milliseconds) {	try {	Thread.sleep(milliseconds);	} catch (InterruptedException e) {	
sleep interrupted 

public void run() {	String localAddress = clientSocket.getLocalAddress().toString();	String remoteAddress = clientSocket.getRemoteSocketAddress().toString();	
handling connection 

public void run() {	String localAddress = clientSocket.getLocalAddress().toString();	String remoteAddress = clientSocket.getRemoteSocketAddress().toString();	try {	while (!isInterrupted() && null != clientSocket && clientSocket.isConnected() && !clientSocket.isClosed()) {	InputStream instream;	try {	instream = clientSocket.getInputStream();	} catch (IOException ioEx) {	if (clientSocket.isClosed()) {	
client socket was closed ignoring exception 

} else {	throw new MllpJUnitResourceException("Unexpected IOException encounted getting input stream", ioEx);	}	} catch (Exception unexpectedEx) {	throw new MllpJUnitResourceException("Unexpected exception encounted getting input stream", unexpectedEx);	}	String parsedHL7Message;	try {	parsedHL7Message = getMessage(instream);	} catch (SocketTimeoutException timeoutEx) {	
waiting for message from client 

}	String parsedHL7Message;	try {	parsedHL7Message = getMessage(instream);	} catch (SocketTimeoutException timeoutEx) {	continue;	}	if (null != parsedHL7Message && parsedHL7Message.length() > 0) {	++messageCounter;	if (closeSocketBeforeAcknowledgement(messageCounter)) {	
closing socket before sending acknowledgement 

}	if (null != parsedHL7Message && parsedHL7Message.length() > 0) {	++messageCounter;	if (closeSocketBeforeAcknowledgement(messageCounter)) {	clientSocket.shutdownInput();	clientSocket.shutdownOutput();	clientSocket.close();	break;	}	if (resetSocketBeforeAcknowledgement(messageCounter)) {	
resetting socket before sending acknowledgement 

if (closeSocketBeforeAcknowledgement(messageCounter)) {	clientSocket.shutdownInput();	clientSocket.shutdownOutput();	clientSocket.close();	break;	}	if (resetSocketBeforeAcknowledgement(messageCounter)) {	try {	clientSocket.setSoLinger(true, 0);	} catch (IOException ioEx) {	
ignoring ioexception encountered setting so linger when prepareing to reset socket 

}	} else {	acknowledgmentMessage = acknowledgementString;	}	BufferedOutputStream outstream = new BufferedOutputStream(clientSocket.getOutputStream());	if (sendOutOfBandData(messageCounter)) {	byte[] outOfBandDataBytes = "Out Of Band Hl7TestMessageGenerator".getBytes();	outstream.write(outOfBandDataBytes, 0, outOfBandDataBytes.length);	}	if (excludeStartOfBlock(messageCounter)) {	
not sending start of block 

}	if (excludeStartOfBlock(messageCounter)) {	} else {	outstream.write(MllpProtocolConstants.START_OF_BLOCK);	if (delayBeforeStartOfBlock > 0) {	uncheckedSleep(delayBeforeStartOfBlock);	uncheckedFlush(outstream);	}	}	if (excludeAcknowledgement(messageCounter)) {	
not sending acknowledgement body 

if (delayBeforeStartOfBlock > 0) {	uncheckedSleep(delayBeforeStartOfBlock);	uncheckedFlush(outstream);	}	}	if (excludeAcknowledgement(messageCounter)) {	} else {	if (delayBeforeAcknowledgement > 0) {	uncheckedSleep(delayBeforeAcknowledgement);	}	
buffering acknowledgement t 

uncheckedFlush(outstream);	} else {	outstream.write(ackBytes, 0, ackBytes.length);	}	if (delayAfterAcknowledgement > 0) {	uncheckedFlush(outstream);	uncheckedSleep(delayAfterAcknowledgement);	}	}	if (excludeEndOfBlock(messageCounter)) {	
not sending end of block 

}	if (excludeEndOfBlock(messageCounter)) {	} else {	outstream.write(MllpProtocolConstants.END_OF_BLOCK);	if (delayAfterEndOfBlock > 0) {	uncheckedFlush(outstream);	uncheckedSleep(delayAfterEndOfBlock);	}	}	if (excludeEndOfData(messageCounter)) {	
not sending end of data 

outstream.write(MllpProtocolConstants.END_OF_BLOCK);	if (delayAfterEndOfBlock > 0) {	uncheckedFlush(outstream);	uncheckedSleep(delayAfterEndOfBlock);	}	}	if (excludeEndOfData(messageCounter)) {	} else {	outstream.write(MllpProtocolConstants.END_OF_DATA);	}	
writing acknowledgement t 

uncheckedFlush(outstream);	uncheckedSleep(delayAfterEndOfBlock);	}	}	if (excludeEndOfData(messageCounter)) {	} else {	outstream.write(MllpProtocolConstants.END_OF_DATA);	}	uncheckedFlush(outstream);	if (closeSocketAfterAcknowledgement(messageCounter)) {	
closing client 

if (clientSocket != null) {	try {	clientSocket.close();	} catch (IOException e) {	String errorMessage = "Error while attempting to close to client Socket";	log.error(errorMessage, e);	throw new MllpJUnitResourceException(errorMessage, e);	}	}	}	
client connection finished 

private void uncheckedFlush(OutputStream outputStream) {	try {	outputStream.flush();	} catch (IOException e) {	
ignoring exception caught while flushing output stream 

public void interrupt() {	if (clientSocket != null && clientSocket.isConnected() && !clientSocket.isClosed()) {	try {	clientSocket.close();	} catch (Exception ex) {	
exception encountered closing client socket on interrput 

========================= camel sample_13800 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<Olingo4Component> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.olingo4.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.olingo4.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_508 =========================

public OperationResult<List<String>> getResult() {	try {	Stat statistics = new Stat();	List<String> children = connection.getChildren(node, true, statistics);	if (LOG.isDebugEnabled()) {	if (LOG.isTraceEnabled()) {	
received children from s path with statistics s 

public OperationResult<List<String>> getResult() {	try {	Stat statistics = new Stat();	List<String> children = connection.getChildren(node, true, statistics);	if (LOG.isDebugEnabled()) {	if (LOG.isTraceEnabled()) {	} else {	
received children from s path 

========================= camel sample_12657 =========================

public void process(Exchange exchange) throws Exception {	
some 

public String slip(String body, @ExchangeProperties Map<String, Object> properties) {	
slip EXIT 

public String slip(String body, @ExchangeProperties Map<String, Object> properties) {	if (properties.get("EXIT") != null && properties.get("EXIT").equals("PLEASE")) {	
exiting after iterations 

========================= camel sample_3844 =========================

if (Character.isDigit(ch)) {	buffer.append(ch);	}	}	value = buffer.toString();	}	if (ObjectHelper.isNotEmpty(value)) {	double number = Double.parseDouble(value);	return number >= minimumVersion;	} else {	
could not determine version of package 

}	if (ObjectHelper.isNotEmpty(value)) {	double number = Double.parseDouble(value);	return number >= minimumVersion;	} else {	}	}	}	} catch (Exception e) {	if (LOG.isDebugEnabled()) {	
could not determine version of package 

========================= camel sample_4378 =========================

throw new IllegalArgumentException(String.format("SObject Class not found for %s", sObjectName));	}	} else {	final String className = endpoint.getConfiguration().getSObjectClass();	if (className != null) {	sObjectClass = endpoint.getComponent().getCamelContext().getClassResolver().resolveClass(className);	if (sObjectClass == null) {	throw new IllegalArgumentException(String.format("SObject Class not found %s", className));	}	} else {	
property sobjectname or sobjectclass not set messages will be of type java lang map 

public void processMessage(ClientSessionChannel channel, Message message) {	final Exchange exchange = endpoint.createExchange();	org.apache.camel.Message in = exchange.getIn();	setHeaders(in, message);	Map<String, Object> data = message.getDataAsMap();	final Map<String, Object> event = (Map<String, Object>) data.get(EVENT_PROPERTY);	final Object eventType = event.get(TYPE_PROPERTY);	Object createdDate = event.get(CREATED_DATE_PROPERTY);	Object replayId = event.get(REPLAY_ID_PROPERTY);	if (log.isDebugEnabled()) {	
received event s on channel s created on s 

if (log.isDebugEnabled()) {	}	in.setHeader("CamelSalesforceEventType", eventType);	in.setHeader("CamelSalesforceCreatedDate", createdDate);	if (replayId != null) {	in.setHeader("CamelSalesforceReplayId", replayId);	}	final Map<String, Object> sObject = (Map<String, Object>) data.get(SOBJECT_PROPERTY);	try {	final String sObjectString = objectMapper.writeValueAsString(sObject);	
received sobject 

in.setBody(objectMapper.readValue( new StringReader(sObjectString), sObjectClass));	}	} catch (IOException e) {	final String msg = String.format("Error parsing message [%s] from Topic %s: %s", message, topicName, e.getMessage());	handleException(msg, new SalesforceException(msg, e));	}	try {	getAsyncProcessor().process(exchange, new AsyncCallback() {	public void done(boolean doneSync) {	if (log.isTraceEnabled()) {	
done processing event synchronously asynchronously 

========================= camel sample_14783 =========================

protected ClientConnectionMultiplexor createConnection(final ConnectionId id, final ClientOptions options) {	
create new connection id 

========================= camel sample_6715 =========================

protected void doStartInnerContext() throws Exception {	CamelContext context = endpoint.getConfig().getInnerContext();	List<RouteBuilder> routeBuildersList = endpoint.getConfig().getRouteBuilders();	if (!(routeBuildersList.isEmpty())) {	for (RouteBuilder routeBuilder : routeBuildersList) {	if (log.isDebugEnabled()) {	
adding routebuilder to 

========================= camel sample_14629 =========================

protected void doStart() throws Exception {	
starting hystrixmetricspoller with delay and queue size 

protected void doStop() throws Exception {	if (poller != null) {	
shutting down hystrixmetricspoller 

public void handleJsonMetric(String json) {	
handlejsonmetric 

public void handleJsonMetric(String json) {	int drain = queue.size() - queueSize + 1;	if (drain > 0) {	
draining queue to make room 

========================= camel sample_11352 =========================

private <T> T execute(ChannelCallback<T> callback) throws Exception {	Channel channel;	try {	channel = channelPool.borrowObject();	} catch (IllegalStateException e) {	checkConnectionAndChannelPool();	channel = channelPool.borrowObject();	}	if (!channel.isOpen()) {	
got a closed channel from the pool invalidating and borrowing a new one from the pool 

private synchronized void openConnectionAndChannelPool() throws Exception {	
creating connection 

private synchronized void openConnectionAndChannelPool() throws Exception {	this.conn = getEndpoint().connect(executorService);	
created connection 

private synchronized void openConnectionAndChannelPool() throws Exception {	this.conn = getEndpoint().connect(executorService);	
creating channel pool 

private synchronized void checkConnectionAndChannelPool() throws Exception {	if (this.conn == null || !this.conn.isOpen()) {	
reconnecting to rabbitmq 

protected void doStart() throws Exception {	this.executorService = getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, "CamelRabbitMQProducer[" + getEndpoint().getQueue() + "]");	try {	openConnectionAndChannelPool();	} catch (IOException e) {	
failed to create connection it will attempt to connect again when publishing a message 

private synchronized void closeConnectionAndChannel() throws IOException {	if (channelPool != null) {	try {	channelPool.close();	channelPool = null;	} catch (Exception e) {	throw new IOException("Error closing channelPool", e);	}	}	if (conn != null) {	
closing connection with timeout ms 

if (exchangeName == null || getEndpoint().isBridgeEndpoint()) {	exchangeName = getEndpoint().getExchangeName();	}	String key = in.getHeader(RabbitMQConstants.ROUTING_KEY, String.class);	if (key == null || getEndpoint().isBridgeEndpoint()) {	key = getEndpoint().getRoutingKey() == null ? "" : getEndpoint().getRoutingKey();	}	if (ObjectHelper.isEmpty(key) && ObjectHelper.isEmpty(exchangeName)) {	throw new IllegalArgumentException("ExchangeName and RoutingKey is not provided in the endpoint: " + getEndpoint());	}	
registering reply for 

protected void initReplyManager() {	if (!started.get()) {	synchronized (this) {	if (started.get()) {	return;	}	
starting reply manager 

}	if (getEndpoint().getReplyToType() != null) {	if (getEndpoint().getReplyTo() != null && getEndpoint().getReplyToType().equals(ReplyToType.Temporary.name())) {	throw new IllegalArgumentException("ReplyToType " + ReplyToType.Temporary + " is not supported when replyTo " + getEndpoint().getReplyTo() + " is also configured.");	}	}	if (getEndpoint().getReplyTo() != null) {	throw new IllegalArgumentException("Specifying replyTo " + getEndpoint().getReplyTo() + " is currently not supported.");	} else {	replyManager = createReplyManager();	
using rabbitmqreplymanager to process replies from temporary queue 

protected ReplyManager createReplyManager() throws Exception {	ReplyManager replyManager = new TemporaryQueueReplyManager(getEndpoint().getCamelContext());	replyManager.setEndpoint(getEndpoint());	String name = "RabbitMQReplyManagerTimeoutChecker[" + getEndpoint().getExchangeName() + "]";	ScheduledExecutorService replyManagerExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadScheduledExecutor(name, name);	replyManager.setScheduledExecutorService(replyManagerExecutorService);	
starting reply manager service 

========================= camel sample_14150 =========================

public void prepare(Message message) throws IOException {	
camelconduit send message 

public void close() {	
camelconduit closed 

public void close() {	try {	producer.stop();	} catch (Exception e) {	
camelconduit producer stop with the exception 

========================= camel sample_6579 =========================

public void testJettyAsyncTimeout() throws Exception {	getMockEndpoint("mock:result").expectedBodiesReceived("Bye World");	StopWatch watch = new StopWatch();	try {	template.requestBody("http: fail("Should have thrown an exception");	} catch (CamelExecutionException e) {	
timeout hit and client got reply with failure status code 

========================= camel sample_10955 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<JIRAComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jira.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jira.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1183 =========================

private Object doAppend(Exchange exchange) throws IOException {	
got operation going to append text to provided pdf 

private String doExtractText(Exchange exchange) throws IOException {	
got operation going to extract text from provided pdf 

private OutputStream doCreate(Exchange exchange) throws IOException {	
got operation going to create and write provided string to pdf document 

========================= camel sample_14280 =========================

private String send(Verb verb, String params) throws Exception {	String url = apiUrl + ((params != null) ? params : "");	OAuthRequest request = new OAuthRequest(verb, url);	request.addQuerystringParameter(OAuthConstants.ACCESS_TOKEN, apiAccessToken);	StringBuilder sb = new StringBuilder();	sb.append("Bearer ");	sb.append(apiAccessToken);	request.addHeader("Authorization",  sb.toString());	if (LOG.isDebugEnabled()) {	
yammer request url 

========================= camel sample_13545 =========================

public static boolean process(final AsyncProcessor processor, final Exchange exchange, final AsyncCallback callback) {	boolean sync;	if (exchange.isTransacted()) {	
transacted exchange must be routed synchronously for exchangeid 

AsyncCallback async = callback;	if (uow != null) {	async = uow.beforeProcess(processor, exchange, callback);	}	sync = processor.process(exchange, async);	if (uow != null) {	uow.afterProcess(processor, exchange, callback, sync);	}	}	if (LOG.isTraceEnabled()) {	
exchange processed and is continued routed for exchangeid synchronously asynchronously 

========================= camel sample_4381 =========================

public void doesNotAddCamelHeaders() {	Map<String, Object> pointInMapFormat = new HashMap<>();	pointInMapFormat.put(InfluxDbConstants.MEASUREMENT_NAME, "testCPU");	double value = 99.999999d;	pointInMapFormat.put("busy", value);	Point p = CamelInfluxDbConverters.fromMapToPoint(pointInMapFormat);	assertNotNull(p);	String line = p.lineProtocol();	assertNotNull(line);	
doesnotaddcamelheaders generated 

public void canAddDouble() {	Map<String, Object> pointInMapFormat = new HashMap<>();	pointInMapFormat.put(InfluxDbConstants.MEASUREMENT_NAME, "testCPU");	double value = 99.999999d;	pointInMapFormat.put("busy", value);	Point p = CamelInfluxDbConverters.fromMapToPoint(pointInMapFormat);	assertNotNull(p);	String line = p.lineProtocol();	assertNotNull(line);	
doublecommand generated 

public void canAddInt() {	Map<String, Object> pointInMapFormat = new HashMap<>();	pointInMapFormat.put(InfluxDbConstants.MEASUREMENT_NAME, "testCPU");	int value = 99999999;	pointInMapFormat.put("busy", value);	Point p = CamelInfluxDbConverters.fromMapToPoint(pointInMapFormat);	assertNotNull(p);	String line = p.lineProtocol();	assertNotNull(line);	
int command generated 

public void canAddByte() {	Map<String, Object> pointInMapFormat = new HashMap<>();	pointInMapFormat.put(InfluxDbConstants.MEASUREMENT_NAME, "testCPU");	byte value = Byte.MAX_VALUE;	pointInMapFormat.put("busy", value);	Point p = CamelInfluxDbConverters.fromMapToPoint(pointInMapFormat);	assertNotNull(p);	String line = p.lineProtocol();	assertNotNull(line);	
byte command generated 

========================= camel sample_11128 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<LdapComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ldap.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ldap.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1029 =========================

public synchronized Handle register() throws Exception {	final HandleImplementation handle = new HandleImplementation();	final boolean needStart = this.handles.isEmpty();	this.handles.add(handle);	if (needStart) {	
calling performstart 

private synchronized void unregister(final HandleImplementation handle) throws Exception {	if (!this.handles.remove(handle)) {	return;	}	if (this.handles.isEmpty()) {	
calling performstop 

public synchronized void dispose() {	
Disposing 

public synchronized void dispose() {	if (this.handles.isEmpty()) {	
disposing not started 

public synchronized void dispose() {	if (this.handles.isEmpty()) {	return;	}	
disposing calling performstop 

========================= camel sample_6703 =========================

public void configure(ApplicationContext applicationContext, SpringCamelContext camelContext) {	CamelConfigurationProperties config = applicationContext.getBean(CamelConfigurationProperties.class);	if (config != null) {	try {	
merging xml based camelcontext with spring boot configuration properties 

========================= camel sample_13400 =========================

getMockEndpoint("mock:result").expectedMessageCount(2);	String out = template.requestBody("direct:start", null, String.class);	String out2 = template.requestBody("direct:start", null, String.class);	assertEquals("9091", out);	assertEquals("9090", out2);	assertMockEndpointsSatisfied();	context.stopRoute("9090");	servers.removeServer("localhost", 9090);	String out3 = template.requestBody("direct:start", null, String.class);	assertEquals("9091", out3);	
sleeping to all the server list updated to run 

String out = template.requestBody("direct:start", null, String.class);	String out2 = template.requestBody("direct:start", null, String.class);	assertEquals("9091", out);	assertEquals("9090", out2);	assertMockEndpointsSatisfied();	context.stopRoute("9090");	servers.removeServer("localhost", 9090);	String out3 = template.requestBody("direct:start", null, String.class);	assertEquals("9091", out3);	Thread.sleep(1000);	
calling the service now 

========================= camel sample_13050 =========================

public void testConvertStringToAndFromByteArray() throws Exception {	byte[] array = converter.convertTo(byte[].class, "foo");	assertNotNull(array);	
found array of size 

public void testConvertStringToAndFromCharArray() throws Exception {	char[] array = converter.convertTo(char[].class, "foo");	assertNotNull(array);	
found array of size 

list.add(5);	list.add(6);	Integer[] integerArray = converter.convertTo(Integer[].class, list);	assertEquals("Integer[] length", 2, integerArray.length);	int[] intArray = converter.convertTo(int[].class, list);	assertEquals("int[] length", 2, intArray.length);	long[] longArray = converter.convertTo(long[].class, intArray);	assertEquals("long[] length", 2, longArray.length);	List<?> resultList = converter.convertTo(List.class, intArray);	assertEquals("List size", 2, resultList.size());	
from primitive type array we ve created the list 

========================= camel sample_1496 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	
direct start mock local mock exhausted seda foo 

========================= camel sample_3852 =========================

public void activate() {	
cameldestination activate 

public void activate() {	ObjectHelper.notNull(camelContext, "CamelContext", this);	try {	
establishing camel connection 

public void deactivate() {	try {	ServiceHelper.stopService(consumer);	} catch (Exception e) {	
error stopping consumer 

public void shutdown() {	
cameldestination shutdown 

protected void incoming(org.apache.camel.Exchange camelExchange) {	
server received request 

Exception exception = outMessage.getContent(Exception.class);	if (checkException && exception != null) {	camelExchange.setException(exception);	}	OutputStream outputStream = outMessage.getContent(OutputStream.class);	if (outputStream instanceof CachedOutputStream) {	camelExchange.getOut().setBody(((CachedOutputStream)outputStream).getInputStream());	} else {	camelExchange.getOut().setBody(outputStream);	}	
send the response message 

========================= camel sample_6580 =========================

private void openConnection() throws IOException, TimeoutException {	
creating connection 

private void openConnection() throws IOException, TimeoutException {	this.conn = getEndpoint().connect(executor);	
created connection 

protected synchronized Connection getConnection() throws IOException, TimeoutException {	if (this.conn == null) {	openConnection();	return this.conn;	} else if (this.conn.isOpen() || (!this.conn.isOpen() && isAutomaticRecoveryEnabled())) {	return this.conn;	} else {	
the existing connection is closed 

private void startConsumers() {	try {	for (RabbitConsumer consumer : this.consumers) {	consumer.start();	}	} catch (Exception e) {	
connection failed will start background thread to retry 

private void closeConnectionAndChannel() throws IOException, TimeoutException {	if (startConsumerCallable != null) {	startConsumerCallable.stop();	}	for (RabbitConsumer consumer : this.consumers) {	try {	consumer.stop();	} catch (TimeoutException e) {	
timeout occurred while stopping consumer this exception is ignored 

startConsumerCallable.stop();	}	for (RabbitConsumer consumer : this.consumers) {	try {	consumer.stop();	} catch (TimeoutException e) {	}	}	this.consumers.clear();	if (conn != null) {	
closing connection with timeout ms 

protected void doStart() throws Exception {	executor = endpoint.createExecutor();	
using executor 

public Void call() throws Exception {	boolean connectionFailed = true;	while (running.get() && connectionFailed) {	try {	for (RabbitConsumer consumer : consumers) {	consumer.reconnect();	}	connectionFailed = false;	} catch (Exception e) {	
connection failed will retry in ms 

========================= camel sample_14146 =========================

public static void traceMBeans(String domain) throws Exception {	MBeanServer mbsc =  ManagementFactory.getPlatformMBeanServer();	String d = getDomainName(domain);	Set<ObjectName> s = mbsc.queryNames(new ObjectName(d + ":*"), null);	if (s.size() > 0) {	
objectnames registered in domain 

========================= camel sample_2890 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	errorHandler(deadLetterChannel("mock:global") .maximumRedeliveries(2) .redeliveryDelay(500));	
direct start mock exhausted seda foo 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	errorHandler(deadLetterChannel("mock:global") .maximumRedeliveries(2) .redeliveryDelay(500));	
direct mock seda 

========================= camel sample_3782 =========================

public void notify(EventObject event) throws Exception {	if (event instanceof ExchangeSendingEvent) {	
sending 

========================= camel sample_1615 =========================

Iterator<Processor> processors = next().iterator();	Object lastHandled = exchange.getProperty(Exchange.EXCEPTION_HANDLED);	exchange.setProperty(Exchange.EXCEPTION_HANDLED, null);	while (continueRouting(processors, exchange)) {	exchange.setProperty(Exchange.TRY_ROUTE_BLOCK, true);	ExchangeHelper.prepareOutToIn(exchange);	Processor processor = processors.next();	AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);	boolean sync = process(exchange, callback, processors, async, lastHandled);	if (!sync) {	
processing exchangeid is continued being processed asynchronously 

exchange.setProperty(Exchange.EXCEPTION_HANDLED, null);	while (continueRouting(processors, exchange)) {	exchange.setProperty(Exchange.TRY_ROUTE_BLOCK, true);	ExchangeHelper.prepareOutToIn(exchange);	Processor processor = processors.next();	AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);	boolean sync = process(exchange, callback, processors, async, lastHandled);	if (!sync) {	return false;	}	
processing exchangeid is continued being processed synchronously 

Processor processor = processors.next();	AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);	boolean sync = process(exchange, callback, processors, async, lastHandled);	if (!sync) {	return false;	}	}	ExchangeHelper.prepareOutToIn(exchange);	exchange.removeProperty(Exchange.TRY_ROUTE_BLOCK);	exchange.setProperty(Exchange.EXCEPTION_HANDLED, lastHandled);	
processing complete for exchangeid 

protected boolean process(final Exchange exchange, final AsyncCallback callback, final Iterator<Processor> processors, final AsyncProcessor processor, final Object lastHandled) {	
processing exchangeid 

public void done(boolean doneSync) {	if (doneSync) {	return;	}	while (continueRouting(processors, exchange)) {	exchange.setProperty(Exchange.TRY_ROUTE_BLOCK, true);	ExchangeHelper.prepareOutToIn(exchange);	AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());	doneSync = process(exchange, callback, processors, processor, lastHandled);	if (!doneSync) {	
processing exchangeid is continued being processed asynchronously 

ExchangeHelper.prepareOutToIn(exchange);	AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());	doneSync = process(exchange, callback, processors, processor, lastHandled);	if (!doneSync) {	return;	}	}	ExchangeHelper.prepareOutToIn(exchange);	exchange.removeProperty(Exchange.TRY_ROUTE_BLOCK);	exchange.setProperty(Exchange.EXCEPTION_HANDLED, lastHandled);	
processing complete for exchangeid 

protected boolean continueRouting(Iterator<Processor> it, Exchange exchange) {	Object stop = exchange.getProperty(Exchange.ROUTE_STOP);	if (stop != null) {	boolean doStop = exchange.getContext().getTypeConverter().convertTo(Boolean.class, stop);	if (doStop) {	
exchange is marked to stop routing 

========================= camel sample_4417 =========================

optParam = new OptionalParameter.OctetString(key, (byte[]) value);	} else if (value instanceof String) {	optParam = new OptionalParameter.COctetString(key, (String) value);	} else if (value instanceof Byte) {	optParam = new OptionalParameter.Byte(key, (Byte) value);	} else if (value instanceof Integer) {	optParam = new OptionalParameter.Int(key, (Integer) value);	} else if (value instanceof Short) {	optParam = new OptionalParameter.Short(key, (Short) value);	} else {	
couldn t determine optional parameter for value type skip this one 

optParam = new OptionalParameter.Byte(key, (Byte) value);	} else if (value instanceof Integer) {	optParam = new OptionalParameter.Int(key, (Integer) value);	} else if (value instanceof Short) {	optParam = new OptionalParameter.Short(key, (Short) value);	} else {	continue;	}	optParams.add(optParam);	} catch (Exception e) {	
couldn t determine optional parameter for key and value skip this one 

optParam = (OptionalParameter) type.getConstructor(byte.class).newInstance(byteValue);	} else if (ancestorClasses.contains(OptionalParameter.Int.class)) {	Integer intValue = (value == null) ? 0 : Integer.valueOf(value);	optParam = (OptionalParameter) type.getConstructor(int.class).newInstance(intValue);	} else if (ancestorClasses.contains(OptionalParameter.Short.class)) {	Short shortValue = (value == null) ? 0 : Short.valueOf(value);	optParam = (OptionalParameter) type.getConstructor(short.class).newInstance(shortValue);	}	optParams.add(optParam);	} catch (Exception e) {	
couldn t determine optional parameter for key and value skip this one 

========================= camel sample_16897 =========================

}	if (delegatedConsumer != null) {	return;	}	delegatedConsumer = delegatedEndpoint.createConsumer(processor);	if (delegatedConsumer instanceof StartupListener) {	getEndpoint().getCamelContext().addStartupListener((StartupListener) delegatedConsumer);	}	ServiceHelper.startService(delegatedEndpoint);	ServiceHelper.startService(delegatedConsumer);	
leadership taken consumer started 

private synchronized void onLeadershipLost() throws Exception {	ServiceHelper.stopAndShutdownServices(delegatedConsumer);	ServiceHelper.stopAndShutdownServices(delegatedEndpoint);	delegatedConsumer = null;	
leadership lost consumer stopped 

========================= camel sample_14453 =========================

context.setName("context-" + id);	context.addService(createClusterService(id, address));	context.addRoutes(new RouteBuilder() {	public void configure() throws Exception {	from("timer:atomix?delay=1s&period=1s") .routeId("route-" + id) .routePolicy(ClusteredRoutePolicy.forNamespace("my-ns")) .log("From ${routeId}") .process(e -> contextLatch.countDown());	}	});	Thread.sleep(ThreadLocalRandom.current().nextInt(500));	context.start();	contextLatch.await();	
shutting down client node 

========================= camel sample_10294 =========================

public static void main(String[] args) throws Exception {	
about to run google pubsub camel integration 

GooglePubsubComponent googlePubsub = PubsubUtil.createComponent();	camelContext.addComponent("google-pubsub", googlePubsub);	from("direct:googlePubsubStart").routeId("DirectToGooglePubsub") .to("google-pubsub:{{pubsub.projectId}}:{{pubsub.topic}}").log("${headers}");	from("stream:in") .to("direct:googlePubsubStart");	}	});	ProducerTemplate producerTemplate = camelContext.createProducerTemplate();	camelContext.start();	Map<String, Object> headers = new HashMap<>();	producerTemplate.sendBodyAndHeaders("direct:googlePubsubStart", testPubsubMessage, headers);	
successfully published message to pubsub 

========================= camel sample_17551 =========================

public I read() throws Exception {	
reading new item 

public I read() throws Exception {	I item = (I) consumerTemplate.receiveBody(endpointUri);	
read item 

========================= camel sample_12753 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("direct:foo").routeId("foo").log("Got ${body}").to("mock:foo");	
direct bar bar also got body mock bar 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("direct:foo").routeId("foo").log("Got ${body}").to("mock:foo");	
direct baz baz cool me got body mock baz 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("direct:foo").routeId("foo").log("Got ${body}").to("mock:foo");	
direct wombat wombat cool mymarker me got body mock wombat 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("direct:foo").routeId("foo").log("Got ${body}").to("mock:foo");	
direct nolog nolog should not log body mock bar 

========================= camel sample_2202 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KubernetesBuildsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-builds.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-builds.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_549 =========================

public void testPutAndGetNotFound() {	LevelDBAggregationRepository repo = new LevelDBAggregationRepository();	repo.setLevelDBFile(levelDBFile);	repo.setRepositoryName("repo1");	Exchange exchange = new DefaultExchange(context);	exchange.getIn().setBody("Hello World");	
created 

LevelDBAggregationRepository repo = new LevelDBAggregationRepository();	repo.setLevelDBFile(levelDBFile);	repo.setRepositoryName("repo1");	Exchange exchange = new DefaultExchange(context);	exchange.getIn().setBody("Hello World");	repo.add(context, exchange.getExchangeId(), exchange);	Exchange out = repo.get(context, exchange.getExchangeId());	assertNotNull("Should find exchange", out);	Exchange exchange2 = new DefaultExchange(context);	exchange2.getIn().setBody("Bye World");	
created 

========================= camel sample_13904 =========================

public void testSearchFolder() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelBox.folderId", "0");	headers.put("CamelBox.query", CAMEL_TEST_FILE_NAME);	final java.util.Collection result = requestBodyAndHeaders("direct: assertNotNull("searchFolder result", result);	assertEquals("searchFolder file found", 1, result.size());	
searchfolder 

========================= camel sample_17414 =========================

private String findCamelConnectorJSonSchema(Class<?> componentClass) {	
finding camel connector json in classpath for connector 

try {	urls = componentClass.getClassLoader().getResources("camel-connector.json");	} catch (IOException e) {	throw new IllegalArgumentException("Cannot open camel-connector.json in classpath for connector " + componentName);	}	while (urls.hasMoreElements()) {	try (InputStream is = urls.nextElement().openStream()) {	String json = IOHelper.loadText(is);	JsonObject output = (JsonObject) Jsoner.deserialize(json);	String javaType = output.getString("javaType");	
found camel connector json in classpath with javatype 

========================= camel sample_6 =========================

public org.apache.thrift.async.AsyncMethodCallback<Void> getResultHandler(final org.apache.thrift.server.AbstractNonblockingServer.AsyncFrameBuffer fb, final int seqid) {	final org.apache.thrift.AsyncProcessFunction fcall = this;	return new org.apache.thrift.async.AsyncMethodCallback<Void>() {	public void onComplete(Void o) {	ping_result result = new ping_result();	try {	fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);	} catch (org.apache.thrift.transport.TTransportException e) {	
ttransportexception writing to internal frame buffer 

public org.apache.thrift.async.AsyncMethodCallback<Void> getResultHandler(final org.apache.thrift.server.AbstractNonblockingServer.AsyncFrameBuffer fb, final int seqid) {	final org.apache.thrift.AsyncProcessFunction fcall = this;	return new org.apache.thrift.async.AsyncMethodCallback<Void>() {	public void onComplete(Void o) {	ping_result result = new ping_result();	try {	fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);	} catch (org.apache.thrift.transport.TTransportException e) {	fb.close();	} catch (java.lang.Exception e) {	
exception writing to internal frame buffer 

fb.close();	} catch (java.lang.Exception e) {	onError(e);	}	}	public void onError(java.lang.Exception e) {	byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;	org.apache.thrift.TSerializable msg;	ping_result result = new ping_result();	if (e instanceof org.apache.thrift.transport.TTransportException) {	
ttransportexception inside handler 

}	}	public void onError(java.lang.Exception e) {	byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;	org.apache.thrift.TSerializable msg;	ping_result result = new ping_result();	if (e instanceof org.apache.thrift.transport.TTransportException) {	fb.close();	return;	} else if (e instanceof org.apache.thrift.TApplicationException) {	
tapplicationexception inside handler 

byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;	org.apache.thrift.TSerializable msg;	ping_result result = new ping_result();	if (e instanceof org.apache.thrift.transport.TTransportException) {	fb.close();	return;	} else if (e instanceof org.apache.thrift.TApplicationException) {	msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;	msg = (org.apache.thrift.TApplicationException)e;	} else {	
exception inside handler 

} else if (e instanceof org.apache.thrift.TApplicationException) {	msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;	msg = (org.apache.thrift.TApplicationException)e;	} else {	msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;	msg = new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());	}	try {	fcall.sendResponse(fb,msg,msgType,seqid);	} catch (java.lang.Exception ex) {	
exception writing to internal frame buffer 

public org.apache.thrift.async.AsyncMethodCallback<java.lang.Integer> getResultHandler(final org.apache.thrift.server.AbstractNonblockingServer.AsyncFrameBuffer fb, final int seqid) {	final org.apache.thrift.AsyncProcessFunction fcall = this;	return new org.apache.thrift.async.AsyncMethodCallback<java.lang.Integer>() {	public void onComplete(java.lang.Integer o) {	add_result result = new add_result();	result.success = o;	result.setSuccessIsSet(true);	try {	fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);	} catch (org.apache.thrift.transport.TTransportException e) {	
ttransportexception writing to internal frame buffer 

return new org.apache.thrift.async.AsyncMethodCallback<java.lang.Integer>() {	public void onComplete(java.lang.Integer o) {	add_result result = new add_result();	result.success = o;	result.setSuccessIsSet(true);	try {	fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);	} catch (org.apache.thrift.transport.TTransportException e) {	fb.close();	} catch (java.lang.Exception e) {	
exception writing to internal frame buffer 

fb.close();	} catch (java.lang.Exception e) {	onError(e);	}	}	public void onError(java.lang.Exception e) {	byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;	org.apache.thrift.TSerializable msg;	add_result result = new add_result();	if (e instanceof org.apache.thrift.transport.TTransportException) {	
ttransportexception inside handler 

}	}	public void onError(java.lang.Exception e) {	byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;	org.apache.thrift.TSerializable msg;	add_result result = new add_result();	if (e instanceof org.apache.thrift.transport.TTransportException) {	fb.close();	return;	} else if (e instanceof org.apache.thrift.TApplicationException) {	
tapplicationexception inside handler 

byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;	org.apache.thrift.TSerializable msg;	add_result result = new add_result();	if (e instanceof org.apache.thrift.transport.TTransportException) {	fb.close();	return;	} else if (e instanceof org.apache.thrift.TApplicationException) {	msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;	msg = (org.apache.thrift.TApplicationException)e;	} else {	
exception inside handler 

} else if (e instanceof org.apache.thrift.TApplicationException) {	msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;	msg = (org.apache.thrift.TApplicationException)e;	} else {	msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;	msg = new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());	}	try {	fcall.sendResponse(fb,msg,msgType,seqid);	} catch (java.lang.Exception ex) {	
exception writing to internal frame buffer 

public org.apache.thrift.async.AsyncMethodCallback<java.lang.Integer> getResultHandler(final org.apache.thrift.server.AbstractNonblockingServer.AsyncFrameBuffer fb, final int seqid) {	final org.apache.thrift.AsyncProcessFunction fcall = this;	return new org.apache.thrift.async.AsyncMethodCallback<java.lang.Integer>() {	public void onComplete(java.lang.Integer o) {	calculate_result result = new calculate_result();	result.success = o;	result.setSuccessIsSet(true);	try {	fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);	} catch (org.apache.thrift.transport.TTransportException e) {	
ttransportexception writing to internal frame buffer 

return new org.apache.thrift.async.AsyncMethodCallback<java.lang.Integer>() {	public void onComplete(java.lang.Integer o) {	calculate_result result = new calculate_result();	result.success = o;	result.setSuccessIsSet(true);	try {	fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);	} catch (org.apache.thrift.transport.TTransportException e) {	fb.close();	} catch (java.lang.Exception e) {	
exception writing to internal frame buffer 

}	public void onError(java.lang.Exception e) {	byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;	org.apache.thrift.TSerializable msg;	calculate_result result = new calculate_result();	if (e instanceof InvalidOperation) {	result.ouch = (InvalidOperation) e;	result.setOuchIsSet(true);	msg = result;	} else if (e instanceof org.apache.thrift.transport.TTransportException) {	
ttransportexception inside handler 

org.apache.thrift.TSerializable msg;	calculate_result result = new calculate_result();	if (e instanceof InvalidOperation) {	result.ouch = (InvalidOperation) e;	result.setOuchIsSet(true);	msg = result;	} else if (e instanceof org.apache.thrift.transport.TTransportException) {	fb.close();	return;	} else if (e instanceof org.apache.thrift.TApplicationException) {	
tapplicationexception inside handler 

result.ouch = (InvalidOperation) e;	result.setOuchIsSet(true);	msg = result;	} else if (e instanceof org.apache.thrift.transport.TTransportException) {	fb.close();	return;	} else if (e instanceof org.apache.thrift.TApplicationException) {	msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;	msg = (org.apache.thrift.TApplicationException)e;	} else {	
exception inside handler 

} else if (e instanceof org.apache.thrift.TApplicationException) {	msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;	msg = (org.apache.thrift.TApplicationException)e;	} else {	msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;	msg = new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());	}	try {	fcall.sendResponse(fb,msg,msgType,seqid);	} catch (java.lang.Exception ex) {	
exception writing to internal frame buffer 

public org.apache.thrift.async.AsyncMethodCallback<Void> getResultHandler(final org.apache.thrift.server.AbstractNonblockingServer.AsyncFrameBuffer fb, final int seqid) {	final org.apache.thrift.AsyncProcessFunction fcall = this;	return new org.apache.thrift.async.AsyncMethodCallback<Void>() {	public void onComplete(Void o) {	}	public void onError(java.lang.Exception e) {	if (e instanceof org.apache.thrift.transport.TTransportException) {	
ttransportexception inside handler 

public org.apache.thrift.async.AsyncMethodCallback<Void> getResultHandler(final org.apache.thrift.server.AbstractNonblockingServer.AsyncFrameBuffer fb, final int seqid) {	final org.apache.thrift.AsyncProcessFunction fcall = this;	return new org.apache.thrift.async.AsyncMethodCallback<Void>() {	public void onComplete(Void o) {	}	public void onError(java.lang.Exception e) {	if (e instanceof org.apache.thrift.transport.TTransportException) {	fb.close();	} else {	
exception inside oneway handler 

public org.apache.thrift.async.AsyncMethodCallback<Work> getResultHandler(final org.apache.thrift.server.AbstractNonblockingServer.AsyncFrameBuffer fb, final int seqid) {	final org.apache.thrift.AsyncProcessFunction fcall = this;	return new org.apache.thrift.async.AsyncMethodCallback<Work>() {	public void onComplete(Work o) {	echo_result result = new echo_result();	result.success = o;	try {	fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);	} catch (org.apache.thrift.transport.TTransportException e) {	
ttransportexception writing to internal frame buffer 

final org.apache.thrift.AsyncProcessFunction fcall = this;	return new org.apache.thrift.async.AsyncMethodCallback<Work>() {	public void onComplete(Work o) {	echo_result result = new echo_result();	result.success = o;	try {	fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);	} catch (org.apache.thrift.transport.TTransportException e) {	fb.close();	} catch (java.lang.Exception e) {	
exception writing to internal frame buffer 

fb.close();	} catch (java.lang.Exception e) {	onError(e);	}	}	public void onError(java.lang.Exception e) {	byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;	org.apache.thrift.TSerializable msg;	echo_result result = new echo_result();	if (e instanceof org.apache.thrift.transport.TTransportException) {	
ttransportexception inside handler 

}	}	public void onError(java.lang.Exception e) {	byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;	org.apache.thrift.TSerializable msg;	echo_result result = new echo_result();	if (e instanceof org.apache.thrift.transport.TTransportException) {	fb.close();	return;	} else if (e instanceof org.apache.thrift.TApplicationException) {	
tapplicationexception inside handler 

byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;	org.apache.thrift.TSerializable msg;	echo_result result = new echo_result();	if (e instanceof org.apache.thrift.transport.TTransportException) {	fb.close();	return;	} else if (e instanceof org.apache.thrift.TApplicationException) {	msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;	msg = (org.apache.thrift.TApplicationException)e;	} else {	
exception inside handler 

} else if (e instanceof org.apache.thrift.TApplicationException) {	msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;	msg = (org.apache.thrift.TApplicationException)e;	} else {	msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;	msg = new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());	}	try {	fcall.sendResponse(fb,msg,msgType,seqid);	} catch (java.lang.Exception ex) {	
exception writing to internal frame buffer 

public org.apache.thrift.async.AsyncMethodCallback<java.lang.Integer> getResultHandler(final org.apache.thrift.server.AbstractNonblockingServer.AsyncFrameBuffer fb, final int seqid) {	final org.apache.thrift.AsyncProcessFunction fcall = this;	return new org.apache.thrift.async.AsyncMethodCallback<java.lang.Integer>() {	public void onComplete(java.lang.Integer o) {	alltypes_result result = new alltypes_result();	result.success = o;	result.setSuccessIsSet(true);	try {	fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);	} catch (org.apache.thrift.transport.TTransportException e) {	
ttransportexception writing to internal frame buffer 

return new org.apache.thrift.async.AsyncMethodCallback<java.lang.Integer>() {	public void onComplete(java.lang.Integer o) {	alltypes_result result = new alltypes_result();	result.success = o;	result.setSuccessIsSet(true);	try {	fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);	} catch (org.apache.thrift.transport.TTransportException e) {	fb.close();	} catch (java.lang.Exception e) {	
exception writing to internal frame buffer 

fb.close();	} catch (java.lang.Exception e) {	onError(e);	}	}	public void onError(java.lang.Exception e) {	byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;	org.apache.thrift.TSerializable msg;	alltypes_result result = new alltypes_result();	if (e instanceof org.apache.thrift.transport.TTransportException) {	
ttransportexception inside handler 

}	}	public void onError(java.lang.Exception e) {	byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;	org.apache.thrift.TSerializable msg;	alltypes_result result = new alltypes_result();	if (e instanceof org.apache.thrift.transport.TTransportException) {	fb.close();	return;	} else if (e instanceof org.apache.thrift.TApplicationException) {	
tapplicationexception inside handler 

byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;	org.apache.thrift.TSerializable msg;	alltypes_result result = new alltypes_result();	if (e instanceof org.apache.thrift.transport.TTransportException) {	fb.close();	return;	} else if (e instanceof org.apache.thrift.TApplicationException) {	msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;	msg = (org.apache.thrift.TApplicationException)e;	} else {	
exception inside handler 

} else if (e instanceof org.apache.thrift.TApplicationException) {	msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;	msg = (org.apache.thrift.TApplicationException)e;	} else {	msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;	msg = new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());	}	try {	fcall.sendResponse(fb,msg,msgType,seqid);	} catch (java.lang.Exception ex) {	
exception writing to internal frame buffer 

========================= camel sample_13007 =========================

protected List<Status> doDirect() throws TwitterException {	
dodirect getretweetsofme 

========================= camel sample_14238 =========================

Class<?> c = Class.forName("org.bouncycastle.jce.provider.BouncyCastleProvider");	cons = c.getConstructor(new Class[] {});	Provider provider = (java.security.Provider)cons.newInstance();	Security.insertProviderAt(provider, 2);	}	if (isJavaVendor("IBM")) {	canTest = false;	}	} catch (Exception e) {	System.err.println("Cannot test due " + e.getMessage());	
cannot test due 

public void setUp() throws Exception {	disableJMX();	try {	super.setUp();	} catch (Exception e) {	System.err.println("Cannot test due " + e.getMessage());	
cannot test due 

========================= camel sample_6754 =========================

public void onCompleted() {	if (producer != null) {	try {	ServiceHelper.stopService(producer);	} catch (Exception e) {	
error stopping producer due this exception is ignored 

========================= camel sample_11190 =========================

try {	if (!doneSync) {	NettyHttpMessage nettyMessage = exchange.hasOut() ? exchange.getOut(NettyHttpMessage.class) : exchange.getIn(NettyHttpMessage.class);	if (nettyMessage != null) {	final FullHttpResponse response = nettyMessage.getHttpResponse();	if (response != null) {	response.content().retain();	exchange.addOnCompletion(new SynchronizationAdapter() {	public void onDone(Exchange exchange) {	if (response.refCnt() > 0) {	
releasing netty httpresonse bytebuf 

response.content().retain();	exchange.addOnCompletion(new SynchronizationAdapter() {	public void onDone(Exchange exchange) {	if (response.refCnt() > 0) {	ReferenceCountUtil.release(response);	}	}	});	String actualUrl = exchange.getIn().getHeader(Exchange.HTTP_URL, String.class);	int code = response.status() != null ? response.status().code() : -1;	
http responsecode 

========================= camel sample_16655 =========================

protected void configureSSLContext(SSLContext context) throws GeneralSecurityException {	
configuring client side sslcontext parameters on sslcontext 

protected void configureSSLContext(SSLContext context) throws GeneralSecurityException {	if (this.getSessionTimeout() != null) {	
configuring client side sslcontext session timeout on sslcontext to 

protected void configureSSLContext(SSLContext context) throws GeneralSecurityException {	if (this.getSessionTimeout() != null) {	this.configureSessionContext(context.getClientSessionContext(), this.getSessionTimeout());	}	
configured client side sslcontext parameters on sslcontext 

========================= camel sample_4293 =========================

public void process(final Exchange exchange) {	for (int i = 1; i <= retryCount; i++) {	if (i > 1) {	
retrying attempt 

Thread.sleep(retrySleep);	} catch (InterruptedException e) {	}	}	try {	transactionTemplate.execute(new TransactionCallback<T>() {	public T doInTransaction(TransactionStatus status) {	try {	Object key = getCorrelationKey(exchange);	T entity = loadEntity(exchange, key);	
correlation key with entity 

T entity = loadEntity(exchange, key);	processEntity(exchange, entity);	return entity;	} catch (Exception e) {	onError(status, e);	return null;	}	}	});	if (i > 1) {	
attempt worked 

} catch (Exception e) {	onError(status, e);	return null;	}	}	});	if (i > 1) {	}	return;	} catch (Exception e) {	
failed to complete transaction this exception is ignored 

protected void onError(TransactionStatus status, Exception e) throws RuntimeCamelException {	status.setRollbackOnly();	
caught 

========================= camel sample_12495 =========================

public void testTemporaryDestinationTypes() throws Exception {	JmsEndpoint endpoint = getMandatoryEndpoint("activemq:test.queue", JmsEndpoint.class);	JmsConfiguration configuration = endpoint.getConfiguration();	JmsProviderMetadata providerMetadata = configuration.getProviderMetadata();	assertNotNull("provider", providerMetadata);	Class<? extends TemporaryQueue> queueType = endpoint.getTemporaryQueueType();	Class<? extends TemporaryTopic> topicType = endpoint.getTemporaryTopicType();	
found queue type 

public void testTemporaryDestinationTypes() throws Exception {	JmsEndpoint endpoint = getMandatoryEndpoint("activemq:test.queue", JmsEndpoint.class);	JmsConfiguration configuration = endpoint.getConfiguration();	JmsProviderMetadata providerMetadata = configuration.getProviderMetadata();	assertNotNull("provider", providerMetadata);	Class<? extends TemporaryQueue> queueType = endpoint.getTemporaryQueueType();	Class<? extends TemporaryTopic> topicType = endpoint.getTemporaryTopicType();	
found topic type 

========================= camel sample_6884 =========================

public void testCacheBasedXPathElementReplacer() throws Exception {	
beginning test testcachebasedxpathelementreplacer 

in.setBody(book1);	} else if (key.equalsIgnoreCase("book2")) {	in.setBody(book2);	} else {	in.setBody(xmlFragment);	}	}	});	}	resultEndpoint.assertIsSatisfied();	
completed test testcachebasedxpathelementreplacer 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() {	from("cache: .process(new CacheBasedXPathReplacer("cache: .process(new CacheBasedXPathReplacer("cache: .to("direct:next");	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	String key = (String)exchange.getIn().getHeader(CacheConstants.CACHE_KEY);	Object body = exchange.getIn().getBody();	String data = exchange.getContext().getTypeConverter().convertTo(String.class, body);	if (log.isDebugEnabled()) {	
payload replacement results 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() {	from("cache: .process(new CacheBasedXPathReplacer("cache: .process(new CacheBasedXPathReplacer("cache: .to("direct:next");	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	String key = (String)exchange.getIn().getHeader(CacheConstants.CACHE_KEY);	Object body = exchange.getIn().getBody();	String data = exchange.getContext().getTypeConverter().convertTo(String.class, body);	if (log.isDebugEnabled()) {	
the following payload was replaced from cache 

from("cache: .process(new CacheBasedXPathReplacer("cache: .process(new CacheBasedXPathReplacer("cache: .to("direct:next");	from("direct:next").process(new Processor() {	public void process(Exchange exchange) throws Exception {	String key = (String)exchange.getIn().getHeader(CacheConstants.CACHE_KEY);	Object body = exchange.getIn().getBody();	String data = exchange.getContext().getTypeConverter().convertTo(String.class, body);	if (log.isDebugEnabled()) {	log.debug("key = {}", key);	log.debug("Before Value = {}", xmlFragment);	log.debug("After value = {}", data);	
end 

========================= camel sample_10502 =========================

public void start() {	if (getFile() == null) {	throw new IllegalArgumentException("A file must be configured");	}	if (LOG.isDebugEnabled()) {	
starting hawtdb using file 

throw new IllegalArgumentException("A file must be configured");	}	if (LOG.isDebugEnabled()) {	}	open();	pageFile = getTxPageFile();	execute(new Work<Boolean>() {	public Boolean execute(Transaction tx) {	if (!tx.allocator().isAllocated(0)) {	ROOT_INDEXES_FACTORY.create(tx);	
aggregation repository data store created using file 

if (LOG.isDebugEnabled()) {	}	open();	pageFile = getTxPageFile();	execute(new Work<Boolean>() {	public Boolean execute(Transaction tx) {	if (!tx.allocator().isAllocated(0)) {	ROOT_INDEXES_FACTORY.create(tx);	} else {	SortedIndex<String, Integer> indexes = ROOT_INDEXES_FACTORY.open(tx);	
aggregation repository data store loaded using file containing repositories 

public void stop() {	File file = getFile();	
stopping hawtdb using file 

public void stop() {	File file = getFile();	try {	close();	} catch (IOException e) {	
error closing hawtdb file this exception will be ignored 

public <T> T execute(Work<T> work, boolean rollbackOnOptimisticUpdateException) {	
executing work start 

public <T> T execute(Work<T> work, boolean rollbackOnOptimisticUpdateException) {	Transaction tx = pageFile.tx();	T answer = doExecute(work, tx, pageFile, rollbackOnOptimisticUpdateException);	
executing work done 

public SortedIndex<Buffer, Buffer> getRepositoryIndex(Transaction tx, String name, boolean create) {	SortedIndex<Buffer, Buffer> answer = null;	SortedIndex<String, Integer> indexes = ROOT_INDEXES_FACTORY.open(tx);	Integer location = indexes.get(name);	if (create && location == null) {	SortedIndex<Buffer, Buffer> created = INDEX_FACTORY.create(tx);	int page = created.getIndexLocation();	indexes.put(name, page);	
created new repository index with name at location 

public SortedIndex<Buffer, Buffer> getRepositoryIndex(Transaction tx, String name, boolean create) {	SortedIndex<Buffer, Buffer> answer = null;	SortedIndex<String, Integer> indexes = ROOT_INDEXES_FACTORY.open(tx);	Integer location = indexes.get(name);	if (create && location == null) {	SortedIndex<Buffer, Buffer> created = INDEX_FACTORY.create(tx);	int page = created.getIndexLocation();	indexes.put(name, page);	answer = created;	} else if (location != null) {	
repository index with name at location 

SortedIndex<String, Integer> indexes = ROOT_INDEXES_FACTORY.open(tx);	Integer location = indexes.get(name);	if (create && location == null) {	SortedIndex<Buffer, Buffer> created = INDEX_FACTORY.create(tx);	int page = created.getIndexLocation();	indexes.put(name, page);	answer = created;	} else if (location != null) {	answer = INDEX_FACTORY.open(tx, location);	}	
repository index with name 

private static <T> T doExecute(Work<T> work, Transaction tx, TxPageFile page, boolean handleOptimisticLockingException) {	T answer = null;	boolean done = false;	int attempt = 0;	while (!done) {	try {	if (attempt > 0) {	
attempt to execute work 

private static <T> T doExecute(Work<T> work, Transaction tx, TxPageFile page, boolean handleOptimisticLockingException) {	T answer = null;	boolean done = false;	int attempt = 0;	while (!done) {	try {	if (attempt > 0) {	}	attempt++;	answer = work.execute(tx);	
tx is read only for executed work 

try {	if (attempt > 0) {	}	attempt++;	answer = work.execute(tx);	tx.commit();	page.flush();	done = true;	} catch (OptimisticUpdateException e) {	if (handleOptimisticLockingException) {	
optimisticupdateexception occurred at attempt executing work will do rollback and retry 

page.flush();	done = true;	} catch (OptimisticUpdateException e) {	if (handleOptimisticLockingException) {	tx.rollback();	} else {	tx.rollback();	throw e;	}	} catch (RuntimeException e) {	
error executing work will do rollback 

========================= camel sample_11743 =========================

return false;	}	boolean filtered = false;	for (int i = offset; i < offset + length; i++) {	if (isFiltered(content[i])) {	filtered = true;	content[i] = REPLACEMENT_CHAR;	}	}	if (filtered) {	
identified and replaced non xml chars 

========================= camel sample_13791 =========================

PrintService[] services = PrintServiceLookup.lookupPrintServices(null, null);	String name;	if (config.getHostname().equalsIgnoreCase("localhost")) {	name = config.getPrintername();	} else {	name = config.getHostname() + "/" + config.getPrintername();	if (config.getPrinterPrefix() != null) {	name = config.getPrinterPrefix() + name;	}	}	
using printer name 

private int findPrinter(PrintService[] services, String printer) {	int position = -1;	printer = printer.toLowerCase(Locale.US);	printer = printer.replace('\\', '/');	for (int i = 0; i < services.length; i++) {	String printerName = services[i].getName();	
printer service printer name 

========================= camel sample_17228 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<PGPDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.pgp.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.pgp.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_660 =========================

try {	properties.load(getClass().getResourceAsStream(TEST_OPTIONS_PROPERTIES));	} catch (Exception e) {	throw new IOException(String.format("%s could not be loaded: %s", TEST_OPTIONS_PROPERTIES, e.getMessage()), e);	}	Map<String, Object> options = new HashMap<>();	for (Map.Entry<Object, Object> entry : properties.entrySet()) {	options.put(entry.getKey().toString(), entry.getValue());	}	AuthenticationType configurationType = getAuthenticationType();	
test using s configuration profile 

========================= camel sample_17382 =========================

public Message toCamelMessage(HttpRequest request, Exchange exchange, NettyHttpConfiguration configuration) throws Exception {	
tocamelmessage 

public void populateCamelHeaders(HttpRequest request, Map<String, Object> headers, Exchange exchange, NettyHttpConfiguration configuration) throws Exception {	
populatecamelheaders 

String path = uri.getRawPath();	if (configuration.getPath() != null) {	String matchPath = path.toLowerCase(Locale.US);	String match = configuration.getPath() != null ? configuration.getPath().toLowerCase(Locale.US) : null;	if (match != null && matchPath.startsWith(match)) {	path = path.substring(configuration.getPath().length());	}	}	headers.put(Exchange.HTTP_PATH, path);	if (LOG.isTraceEnabled()) {	
http method 

String path = uri.getRawPath();	if (configuration.getPath() != null) {	String matchPath = path.toLowerCase(Locale.US);	String match = configuration.getPath() != null ? configuration.getPath().toLowerCase(Locale.US) : null;	if (match != null && matchPath.startsWith(match)) {	path = path.substring(configuration.getPath().length());	}	}	headers.put(Exchange.HTTP_PATH, path);	if (LOG.isTraceEnabled()) {	
http uri 

String value = request.headers().get(name);	if (value != null && value.trim().startsWith("Basic")) {	NettyHttpHelper.appendHeader(headers, NettyHttpConstants.HTTP_AUTHENTICATION, "Basic");	}	}	List<String> values = request.headers().getAll(name);	Iterator<?> it = ObjectHelper.createIterator(values);	while (it.hasNext()) {	Object extracted = it.next();	Object decoded = shouldUrlDecodeHeader(configuration, name, extracted, "UTF-8");	
http header 

if (request.getUri().contains("?")) {	String query = ObjectHelper.after(request.getUri(), "?");	Map<String, Object> uriParameters = URISupport.parseQuery(query, false, true);	for (Map.Entry<String, Object> entry : uriParameters.entrySet()) {	String name = entry.getKey();	Object values = entry.getValue();	Iterator<?> it = ObjectHelper.createIterator(values);	while (it.hasNext()) {	Object extracted = it.next();	Object decoded = shouldUrlDecodeHeader(configuration, name, extracted, "UTF-8");	
uri parameter 

public Message toCamelMessage(HttpResponse response, Exchange exchange, NettyHttpConfiguration configuration) throws Exception {	
tocamelmessage 

public void populateCamelHeaders(HttpResponse response, Map<String, Object> headers, Exchange exchange, NettyHttpConfiguration configuration) throws Exception {	
populatecamelheaders 

headers.put(Exchange.HTTP_RESPONSE_CODE, response.getStatus().getCode());	headers.put(Exchange.HTTP_RESPONSE_TEXT, response.getStatus().getReasonPhrase());	for (String name : response.headers().names()) {	if (name.toLowerCase().equals("content-type")) {	name = Exchange.CONTENT_TYPE;	}	List<String> values = response.headers().getAll(name);	Iterator<?> it = ObjectHelper.createIterator(values);	while (it.hasNext()) {	Object extracted = it.next();	
http header 

public HttpResponse toNettyResponse(Message message, NettyHttpConfiguration configuration) throws Exception {	
tonettyresponse 

public HttpResponse toNettyResponse(Message message, NettyHttpConfiguration configuration) throws Exception {	if (message.getBody() instanceof HttpResponse) {	return (HttpResponse) message.getBody();	}	boolean failed = message.getExchange().isFailed();	int defaultCode = failed ? 500 : 200;	int code = message.getHeader(Exchange.HTTP_RESPONSE_CODE, defaultCode, int.class);	HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(code));	
http status code 

}	}	}	if (buffer != null) {	response.setContent(buffer);	if (buffer.readerIndex() == buffer.writerIndex()) {	buffer.setIndex(0, buffer.writerIndex());	}	int len = buffer.readableBytes();	response.headers().set(HttpHeaders.Names.CONTENT_LENGTH, len);	
content length 

response.setContent(buffer);	if (buffer.readerIndex() == buffer.writerIndex()) {	buffer.setIndex(0, buffer.writerIndex());	}	int len = buffer.readableBytes();	response.headers().set(HttpHeaders.Names.CONTENT_LENGTH, len);	}	String contentType = MessageHelper.getContentType(message);	if (contentType != null) {	response.headers().set(HttpHeaders.Names.CONTENT_TYPE, contentType);	
content type 

if (configuration.isKeepAlive()) {	connection = HttpHeaders.Values.KEEP_ALIVE;	} else {	connection = HttpHeaders.Values.CLOSE;	}	}	response.headers().set(HttpHeaders.Names.CONNECTION, connection);	if (connection.equalsIgnoreCase(HttpHeaders.Values.CLOSE)) {	message.setHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, true);	}	
connection 

public HttpRequest toNettyRequest(Message message, String uri, NettyHttpConfiguration configuration) throws Exception {	
tonettyrequest 

buffer = message.getBody(ChannelBuffer.class);	if (buffer == null) {	byte[] data = message.getMandatoryBody(byte[].class);	buffer = ChannelBuffers.copiedBuffer(data);	}	}	if (buffer != null) {	request.setContent(buffer);	int len = buffer.readableBytes();	request.headers().set(HttpHeaders.Names.CONTENT_LENGTH, len);	
content length 

request.headers().set(HttpHeaders.Names.CONTENT_LENGTH, len);	} else {	throw new NoTypeConversionAvailableException(body, ChannelBuffer.class);	}	}	HttpMethod method = NettyHttpHelper.createMethod(message, body != null);	request.setMethod(method);	String contentType = MessageHelper.getContentType(message);	if (contentType != null) {	request.headers().set(HttpHeaders.Names.CONTENT_TYPE, contentType);	
content type 

}	HttpMethod method = NettyHttpHelper.createMethod(message, body != null);	request.setMethod(method);	String contentType = MessageHelper.getContentType(message);	if (contentType != null) {	request.headers().set(HttpHeaders.Names.CONTENT_TYPE, contentType);	}	URI u = new URI(uri);	String hostHeader = u.getHost() + (u.getPort() == 80 ? "" : ":" + u.getPort());	request.headers().set(HttpHeaders.Names.HOST, hostHeader);	
host 

request.headers().set(HttpHeaders.Names.HOST, hostHeader);	String connection = message.getHeader(HttpHeaders.Names.CONNECTION, String.class);	if (connection == null) {	if (configuration.isKeepAlive()) {	connection = HttpHeaders.Values.KEEP_ALIVE;	} else {	connection = HttpHeaders.Values.CLOSE;	}	}	request.headers().set(HttpHeaders.Names.CONNECTION, connection);	
connection 

========================= camel sample_8361 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<JsonPathLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.jsonpath.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.jsonpath.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_477 =========================

private void removeJobInScheduler() throws Exception {	Scheduler scheduler = getComponent().getScheduler();	if (scheduler == null) {	return;	}	if (deleteJob) {	boolean isClustered = scheduler.getMetaData().isJobStoreClustered();	if (!scheduler.isShutdown() && !isClustered) {	
deleting job 

private Trigger createTrigger(JobDetail jobDetail) throws Exception {	Trigger result;	Date startTime = new Date();	if (getComponent().getScheduler().isStarted()) {	startTime = new Date(System.currentTimeMillis() + triggerStartDelay);	}	if (cron != null) {	
creating crontrigger 

} else {	if (ObjectHelper.isNotEmpty(customCalendar)) {	result = TriggerBuilder.newTrigger() .withIdentity(triggerKey) .startAt(startTime) .withSchedule(cronSchedule(cron) .withMisfireHandlingInstructionFireAndProceed()) .modifiedByCalendar(QuartzConstants.QUARTZ_CAMEL_CUSTOM_CALENDAR) .build();	} else {	result = TriggerBuilder.newTrigger() .withIdentity(triggerKey) .startAt(startTime) .withSchedule(cronSchedule(cron) .withMisfireHandlingInstructionFireAndProceed()) .build();	}	}	jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_TYPE, "cron");	jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_CRON_EXPRESSION, cron);	} else {	
creating simpletrigger 

}	if (fireNow) {	triggerBuilder = triggerBuilder.startNow();	}	result = triggerBuilder.build();	jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_TYPE, "simple");	jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_SIMPLE_REPEAT_COUNTER, repeat);	jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_SIMPLE_REPEAT_INTERVAL, interval);	}	if (triggerParameters != null && triggerParameters.size() > 0) {	
setting user extra triggerparameters 

private JobDetail createJobDetail() throws Exception {	String name = triggerKey.getName();	String group = triggerKey.getGroup();	Class<? extends Job> jobClass = stateful ? StatefulCamelJob.class : CamelJob.class;	
creating new 

Class<? extends Job> jobClass = stateful ? StatefulCamelJob.class : CamelJob.class;	JobBuilder builder = JobBuilder.newJob(jobClass) .withIdentity(name, group);	if (durableJob) {	builder = builder.storeDurably();	}	if (recoverableJob) {	builder = builder.requestRecovery();	}	JobDetail result = builder.build();	if (jobParameters != null && jobParameters.size() > 0) {	
setting user extra jobparameters 

public void pauseTrigger() throws Exception {	Scheduler scheduler = getComponent().getScheduler();	boolean isClustered = scheduler.getMetaData().isJobStoreClustered();	if (jobPaused.get() || isClustered) {	return;	}	jobPaused.set(true);	if (!scheduler.isShutdown()) {	
pausing trigger 

public void resumeTrigger() throws Exception {	if (!jobPaused.get()) {	return;	}	jobPaused.set(false);	Scheduler scheduler = getComponent().getScheduler();	if (scheduler != null) {	
resuming trigger 

========================= camel sample_15002 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<EC2Component> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-ec2.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-ec2.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1140 =========================

public void notify(EventObject eventObject) throws Exception {	String message = eventObject.toString();	Level level = determineLevel(eventObject);	MessagePayload payload = new MessagePayload(getHostName(), level, getServiceName(), message);	if (log.isInfoEnabled()) {	
sending notification to nagios 

public void notify(EventObject eventObject) throws Exception {	String message = eventObject.toString();	Level level = determineLevel(eventObject);	MessagePayload payload = new MessagePayload(getHostName(), level, getServiceName(), message);	if (log.isInfoEnabled()) {	}	sender.send(payload);	
sending notification done 

protected void doStart() throws Exception {	if (nagiosSettings == null) {	nagiosSettings = configuration.getNagiosSettings();	}	if (sender == null) {	sender = new NagiosPassiveCheckSender(nagiosSettings);	}	
using 

========================= camel sample_9120 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<TimerComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.timer.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.timer.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_861 =========================

public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {	if (cause instanceof IOException) {	
io exception client connection closed 

public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {	if (cause instanceof IOException) {	} else {	
caught an exception while reading closing channel 

========================= camel sample_7581 =========================

public void testPerformance() throws Exception {	StopWatch watch = new StopWatch();	MockEndpoint endpoint = getMockEndpoint(uri);	endpoint.expectedMessageCount((int) dataSet.getSize());	endpoint.expectedHeaderReceived("foo", 123);	MockEndpoint.assertIsSatisfied(context, 30, TimeUnit.SECONDS);	
routeperformancetest sent took ms 

========================= camel sample_2500 =========================

public void contextInitialized(ServletContextEvent sce) {	
camelcontextservletlistener initializing 

registry = createRegistry();	camelContext = new ServletCamelContext(registry, sce.getServletContext());	} catch (Exception e) {	throw new RuntimeException("Error creating CamelContext.", e);	}	Map<String, Object> map = extractInitParameters(sce);	String test = (String) map.remove("test");	if (test != null && "true".equalsIgnoreCase(test)) {	this.test = true;	}	
in test mode 

camelContextLifecycle = camelContext.getInjector().newInstance(clazz);	} catch (ClassNotFoundException e) {	throw new RuntimeException("Error creating CamelContextLifecycle class with name " + lifecycle, e);	}	}	try {	if (camelContextLifecycle != null) {	camelContextLifecycle.beforeAddRoutes(camelContext, registry);	}	} catch (Exception e) {	
error before adding routes to camelcontext 

try {	camelContext.addRouteDefinition((RouteDefinition) route);	} catch (Exception e) {	throw new RuntimeException("Error adding route(s) " + route, e);	}	} else {	throw new IllegalArgumentException("Unsupported route: " + route);	}	}	if (!map.isEmpty()) {	
there are servletcontext init parameters unknown to camel maybe they are used by other frameworks 

throw new IllegalArgumentException("Unsupported route: " + route);	}	}	if (!map.isEmpty()) {	}	try {	if (camelContextLifecycle != null) {	camelContextLifecycle.afterAddRoutes(camelContext, registry);	}	} catch (Exception e) {	
error after adding routes to camelcontext 

}	try {	if (camelContextLifecycle != null) {	camelContextLifecycle.beforeStart(camelContext, registry);	}	camelContext.start();	if (camelContextLifecycle != null) {	camelContextLifecycle.afterStart(camelContext, registry);	}	} catch (Exception e) {	
error starting camelcontext 

if (camelContextLifecycle != null) {	camelContextLifecycle.afterStart(camelContext, registry);	}	} catch (Exception e) {	throw new RuntimeException("Error starting CamelContext.", e);	}	if (this.test) {	instance = camelContext;	}	sce.getServletContext().setAttribute(CAMEL_CONTEXT_KEY, camelContext);	
camelcontextservletlistener initialized 

public void contextDestroyed(ServletContextEvent sce) {	
camelcontextservletlistener destroying 

if (camelContext != null) {	try {	if (camelContextLifecycle != null) {	camelContextLifecycle.beforeStop(camelContext, registry);	}	camelContext.stop();	if (camelContextLifecycle != null) {	camelContextLifecycle.afterStop(camelContext, registry);	}	} catch (Exception e) {	
error stopping camelcontext this exception will be ignored 

if (camelContextLifecycle != null) {	camelContextLifecycle.afterStop(camelContext, registry);	}	} catch (Exception e) {	}	}	camelContext = null;	registry = null;	instance = null;	sce.getServletContext().removeAttribute(CAMEL_CONTEXT_KEY);	
camelcontextservletlistener destroyed 

Map<String, Object> map = new LinkedHashMap<String, Object>();	Enumeration<?> names = sce.getServletContext().getInitParameterNames();	while (names.hasMoreElements()) {	String name = (String) names.nextElement();	String value = sce.getServletContext().getInitParameter(name);	if (ObjectHelper.isNotEmpty(value)) {	Object target = value;	if (value.startsWith("#")) {	value = value.substring(1);	target = lookupRegistryByName(value);	
resolved the servlet context s initialization parameter to 

private void initJmx(ServletCamelContext camelContext, Map<String, Object> parameters) throws Exception {	Map<String, Object> properties = IntrospectionSupport.extractProperties(parameters, "jmx.");	if (properties != null && !properties.isEmpty()) {	String disabled = (String) properties.remove("disabled");	boolean disableJmx = CamelContextHelper.parseBoolean(camelContext, disabled != null ? disabled : "false");	if (disableJmx) {	
jmxagent disabled 

private void initJmx(ServletCamelContext camelContext, Map<String, Object> parameters) throws Exception {	Map<String, Object> properties = IntrospectionSupport.extractProperties(parameters, "jmx.");	if (properties != null && !properties.isEmpty()) {	String disabled = (String) properties.remove("disabled");	boolean disableJmx = CamelContextHelper.parseBoolean(camelContext, disabled != null ? disabled : "false");	if (disableJmx) {	camelContext.getLifecycleStrategies().clear();	camelContext.setManagementStrategy(new DefaultManagementStrategy());	} else {	
jmxagent enabled 

========================= camel sample_12114 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	context.addComponent("async", new MyAsyncComponent());	errorHandler(defaultErrorHandler().maximumRedeliveries(5).redeliveryDelay(100).asyncDelayedRedelivery());	from("seda:start") .to("log:before") .to("mock:before") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	
processing at attempt 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	context.addComponent("async", new MyAsyncComponent());	errorHandler(defaultErrorHandler().maximumRedeliveries(5).redeliveryDelay(100).asyncDelayedRedelivery());	from("seda:start") .to("log:before") .to("mock:before") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String body = exchange.getIn().getBody(String.class);	if (body.contains("World")) {	if (++attempt <= 2) {	
processing failed will thrown an exception 

errorHandler(defaultErrorHandler().maximumRedeliveries(5).redeliveryDelay(100).asyncDelayedRedelivery());	from("seda:start") .to("log:before") .to("mock:before") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String body = exchange.getIn().getBody(String.class);	if (body.contains("World")) {	if (++attempt <= 2) {	throw new IllegalArgumentException("Damn");	}	}	exchange.getIn().setBody("Hello " + body);	
processing at attempt complete 

========================= camel sample_2015 =========================

public static void handleDisableJmx(ConfigurableApplicationContext context, Class<?> testClass) {	CamelSpringTestHelper.setOriginalJmxDisabledValue(System.getProperty(JmxSystemPropertyKeys.DISABLED));	if (testClass.isAnnotationPresent(DisableJmx.class)) {	if (testClass.getAnnotation(DisableJmx.class).value()) {	
disabling camel jmx globally as disablejmx annotation was found and disablejmx is set to true 

public static void handleDisableJmx(ConfigurableApplicationContext context, Class<?> testClass) {	CamelSpringTestHelper.setOriginalJmxDisabledValue(System.getProperty(JmxSystemPropertyKeys.DISABLED));	if (testClass.isAnnotationPresent(DisableJmx.class)) {	if (testClass.getAnnotation(DisableJmx.class).value()) {	System.setProperty(JmxSystemPropertyKeys.DISABLED, "true");	} else {	
enabling camel jmx as disablejmx annotation was found and disablejmx is set to false 

public static void handleDisableJmx(ConfigurableApplicationContext context, Class<?> testClass) {	CamelSpringTestHelper.setOriginalJmxDisabledValue(System.getProperty(JmxSystemPropertyKeys.DISABLED));	if (testClass.isAnnotationPresent(DisableJmx.class)) {	if (testClass.getAnnotation(DisableJmx.class).value()) {	System.setProperty(JmxSystemPropertyKeys.DISABLED, "true");	} else {	System.clearProperty(JmxSystemPropertyKeys.DISABLED);	}	} else {	
disabling camel jmx globally for tests by default use the disablejmx annotation to override the default setting 

public static void handleRouteCoverage(ConfigurableApplicationContext context, Class<?> testClass, Function testMethod) throws Exception {	if (testClass.isAnnotationPresent(EnableRouteCoverage.class)) {	System.setProperty(CamelTestSupport.ROUTE_COVERAGE_ENABLED, "true");	CamelSpringTestHelper.doToSpringCamelContexts(context, new CamelSpringTestHelper.DoToSpringCamelContextsStrategy() {	public void execute(String contextName, SpringCamelContext camelContext) throws Exception {	
enabling routecoverage 

}	if (breakpoints.size() != 0) {	CamelSpringTestHelper.doToSpringCamelContexts(context, new CamelSpringTestHelper.DoToSpringCamelContextsStrategy() {	public void execute(String contextName, SpringCamelContext camelContext) throws Exception {	Debugger debugger = camelContext.getDebugger();	if (debugger == null) {	debugger = new DefaultDebugger();	camelContext.setDebugger(debugger);	}	for (Breakpoint breakpoint : breakpoints) {	
adding breakpoint to camelcontext with name 

final TimeUnit shutdownTimeUnit;	if (testClass.isAnnotationPresent(ShutdownTimeout.class)) {	shutdownTimeout = testClass.getAnnotation(ShutdownTimeout.class).value();	shutdownTimeUnit = testClass.getAnnotation(ShutdownTimeout.class).timeUnit();	} else {	shutdownTimeout = 10;	shutdownTimeUnit = TimeUnit.SECONDS;	}	CamelSpringTestHelper.doToSpringCamelContexts(context, new CamelSpringTestHelper.DoToSpringCamelContextsStrategy() {	public void execute(String contextName, SpringCamelContext camelContext) throws Exception {	
setting shutdown timeout to on camelcontext with name 

public static void handleMockEndpoints(ConfigurableApplicationContext context, Class<?> testClass) throws Exception {	if (testClass.isAnnotationPresent(MockEndpoints.class)) {	final String mockEndpoints = testClass.getAnnotation(MockEndpoints.class).value();	CamelSpringTestHelper.doToSpringCamelContexts(context, new CamelSpringTestHelper.DoToSpringCamelContextsStrategy() {	public void execute(String contextName, SpringCamelContext camelContext) throws Exception {	
enabling auto mocking of endpoints matching pattern on camelcontext with name 

public static void handleMockEndpointsAndSkip(ConfigurableApplicationContext context, Class<?> testClass) throws Exception {	if (testClass.isAnnotationPresent(MockEndpointsAndSkip.class)) {	final String mockEndpoints = testClass.getAnnotation(MockEndpointsAndSkip.class).value();	CamelSpringTestHelper.doToSpringCamelContexts(context, new CamelSpringTestHelper.DoToSpringCamelContextsStrategy() {	public void execute(String contextName, SpringCamelContext camelContext) throws Exception {	String mockEndpointsValue = camelContext.resolvePropertyPlaceholders(mockEndpoints);	
enabling auto mocking and skipping of endpoints matching pattern on camelcontext with name 

}	if (properties.size() != 0) {	CamelSpringTestHelper.doToSpringCamelContexts(context, new CamelSpringTestHelper.DoToSpringCamelContextsStrategy() {	public void execute(String contextName, SpringCamelContext camelContext) throws Exception {	PropertiesComponent pc = camelContext.getComponent("properties", PropertiesComponent.class);	Properties extra = new Properties();	for (Properties prop : properties) {	extra.putAll(prop);	}	if (!extra.isEmpty()) {	
using properties to override any existing properties on the propertiescomponent on camelcontext with name 

public static void handleCamelContextStartup(ConfigurableApplicationContext context, Class<?> testClass) throws Exception {	boolean skip = "true".equalsIgnoreCase(System.getProperty("skipStartingCamelContext"));	if (skip) {	
skipping starting camelcontext s as system property skipstartingcamelcontext is set to be true 

public static void handleCamelContextStartup(ConfigurableApplicationContext context, Class<?> testClass) throws Exception {	boolean skip = "true".equalsIgnoreCase(System.getProperty("skipStartingCamelContext"));	if (skip) {	} else if (testClass.isAnnotationPresent(UseAdviceWith.class)) {	if (testClass.getAnnotation(UseAdviceWith.class).value()) {	
skipping starting camelcontext s as useadvicewith annotation was found and isuseadvicewith is set to true 

public static void handleCamelContextStartup(ConfigurableApplicationContext context, Class<?> testClass) throws Exception {	boolean skip = "true".equalsIgnoreCase(System.getProperty("skipStartingCamelContext"));	if (skip) {	} else if (testClass.isAnnotationPresent(UseAdviceWith.class)) {	if (testClass.getAnnotation(UseAdviceWith.class).value()) {	skip = true;	} else {	
starting camelcontext s as useadvicewith annotation was found but isuseadvicewith is set to false 

if (testClass.getAnnotation(UseAdviceWith.class).value()) {	skip = true;	} else {	skip = false;	}	}	if (!skip) {	CamelSpringTestHelper.doToSpringCamelContexts(context, new CamelSpringTestHelper.DoToSpringCamelContextsStrategy() {	public void execute(String contextName, SpringCamelContext camelContext) throws Exception {	if (!camelContext.isStarted()) {	
starting camelcontext with name 

} else {	skip = false;	}	}	if (!skip) {	CamelSpringTestHelper.doToSpringCamelContexts(context, new CamelSpringTestHelper.DoToSpringCamelContextsStrategy() {	public void execute(String contextName, SpringCamelContext camelContext) throws Exception {	if (!camelContext.isStarted()) {	camelContext.start();	} else {	
camelcontext with name already started 

========================= camel sample_10579 =========================

protected void createConnection() {	if (connection != null) {	connection.disconnect(null);	}	connection = configuration.callbackConnection();	connection.listener(new Listener() {	public void onConnected() {	connected = true;	
mqtt connection connected to 

protected void createConnection() {	if (connection != null) {	connection.disconnect(null);	}	connection = configuration.callbackConnection();	connection.listener(new Listener() {	public void onConnected() {	connected = true;	}	public void onDisconnected() {	
mqtt connection disconnected from 

for (MQTTConsumer consumer : consumers) {	consumer.processExchange(exchange);	}	}	if (ack != null) {	ack.run();	}	}	public void onFailure(Throwable value) {	connected = false;	
connection to failure due forcing a disconnect to re connect on next attempt 

if (ack != null) {	ack.run();	}	}	public void onFailure(Throwable value) {	connected = false;	connection.disconnect(new Callback<Void>() {	public void onSuccess(Void value) {	}	public void onFailure(Throwable e) {	
failed to disconnect from this exception is ignored 

public void onSuccess(Void value) {	
connected to 

public void onSuccess(Void value) {	Topic[] topics = createSubscribeTopics();	if (topics != null && topics.length > 0) {	connection.subscribe(topics, new Callback<byte[]>() {	public void onSuccess(byte[] value) {	promise.onSuccess(value);	connected = true;	}	public void onFailure(Throwable value) {	
failed to subscribe 

public void onFailure(Throwable value) {	
failed to connect to due 

public void run() {	
publishing to 

========================= camel sample_16854 =========================

public static String getEffectiveAddress(Exchange exchange, String defaultAddress) {	String retval = exchange.getIn().getHeader(Exchange.DESTINATION_OVERRIDE_URL, String.class);	if (retval == null) {	retval = defaultAddress;	} else {	
client address is overridden by header to value 

========================= camel sample_8048 =========================

public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {	try {	if (config != null && config.getUseGlobalSslContextParameters() != null && config.getUseGlobalSslContextParameters()) {	SSLContextParameters globalSSLParams = context.getSSLContextParameters();	if (globalSSLParams != null) {	ProtocolSocketFactory factory = new SSLContextParametersSecureProtocolSocketFactory(globalSSLParams, context);	Protocol.registerProtocol("https", new Protocol( "https", factory, 443));	}	}	} catch (NoUniqueBeanDefinitionException e) {	
multiple instance of sslcontextparameters found skipping configuration 

try {	if (config != null && config.getUseGlobalSslContextParameters() != null && config.getUseGlobalSslContextParameters()) {	SSLContextParameters globalSSLParams = context.getSSLContextParameters();	if (globalSSLParams != null) {	ProtocolSocketFactory factory = new SSLContextParametersSecureProtocolSocketFactory(globalSSLParams, context);	Protocol.registerProtocol("https", new Protocol( "https", factory, 443));	}	}	} catch (NoUniqueBeanDefinitionException e) {	} catch (NoSuchBeanDefinitionException e) {	
no instance of sslcontextparameters found 

if (config != null && config.getUseGlobalSslContextParameters() != null && config.getUseGlobalSslContextParameters()) {	SSLContextParameters globalSSLParams = context.getSSLContextParameters();	if (globalSSLParams != null) {	ProtocolSocketFactory factory = new SSLContextParametersSecureProtocolSocketFactory(globalSSLParams, context);	Protocol.registerProtocol("https", new Protocol( "https", factory, 443));	}	}	} catch (NoUniqueBeanDefinitionException e) {	} catch (NoSuchBeanDefinitionException e) {	} catch (BeansException e) {	
cannot create sslcontextparameters 

========================= camel sample_1269 =========================

public void run() {	BaseQueue<?> queue = endpoint.getHazelcastInstance().getQueue(endpoint.getConfiguration().getQueueName());	while (queue != null && isRunAllowed()) {	final Exchange exchange = this.getEndpoint().createExchange();	TransactionContext transactionCtx = null;	try {	if (endpoint.getConfiguration().isTransacted()) {	transactionCtx = endpoint.getHazelcastInstance().newTransactionContext();	if (transactionCtx != null) {	
begin transaction 

public void done(boolean asyncDone) {	}	});	if (exchange.getException() != null) {	if (transactionCtx != null) {	transactionCtx.rollbackTransaction();	}	getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException());	}	} catch (Exception e) {	
hzlq exception caught 

}	});	if (exchange.getException() != null) {	if (transactionCtx != null) {	transactionCtx.rollbackTransaction();	}	getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException());	}	} catch (Exception e) {	if (transactionCtx != null) {	
rollback transaction 

}	getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException());	}	} catch (Exception e) {	if (transactionCtx != null) {	transactionCtx.rollbackTransaction();	}	}	}	if (exchange.getException() == null && transactionCtx != null) {	
commit transaction 

if (transactionCtx != null) {	transactionCtx.rollbackTransaction();	}	}	}	if (exchange.getException() == null && transactionCtx != null) {	transactionCtx.commitTransaction();	}	} catch (InterruptedException e) {	if (LOG.isDebugEnabled()) {	
hzlq consumer interrupted 

}	if (exchange.getException() == null && transactionCtx != null) {	transactionCtx.commitTransaction();	}	} catch (InterruptedException e) {	if (LOG.isDebugEnabled()) {	}	continue;	} catch (Throwable e) {	if (transactionCtx != null) {	
rollback transaction 

========================= camel sample_9527 =========================

public List<Exchange> pollConsume() throws TwitterException {	String keywords = this.keywords;	Query query;	if (keywords != null && keywords.trim().length() > 0) {	query = new Query(keywords);	
searching twitter with keywords 

public List<Exchange> pollConsume() throws TwitterException {	String keywords = this.keywords;	Query query;	if (keywords != null && keywords.trim().length() > 0) {	query = new Query(keywords);	} else {	query = new Query();	
searching twitter without keywords 

public List<Exchange> directConsume() throws TwitterException {	String keywords = this.keywords;	if (keywords == null || keywords.trim().length() == 0) {	return Collections.emptyList();	}	Query query = new Query(keywords);	
searching twitter with keywords 

}	if (ObjectHelper.isNotEmpty(endpoint.getProperties().getCount())) {	query.setCount(endpoint.getProperties().getCount());	}	if (ObjectHelper.isNotEmpty(endpoint.getProperties().getNumberOfPages())) {	numberOfPages = endpoint.getProperties().getNumberOfPages();	}	if (ObjectHelper.isNotEmpty(endpoint.getProperties().getLatitude()) && ObjectHelper.isNotEmpty(endpoint.getProperties().getLongitude()) && ObjectHelper.isNotEmpty(endpoint.getProperties().getRadius())) {	GeoLocation location = new GeoLocation(endpoint.getProperties().getLatitude(), endpoint.getProperties().getLongitude());	query.setGeoCode(location, endpoint.getProperties().getRadius(), Unit.valueOf(endpoint.getProperties().getDistanceMetric()));	
searching with additional geolocation parameters 

if (ObjectHelper.isNotEmpty(endpoint.getProperties().getCount())) {	query.setCount(endpoint.getProperties().getCount());	}	if (ObjectHelper.isNotEmpty(endpoint.getProperties().getNumberOfPages())) {	numberOfPages = endpoint.getProperties().getNumberOfPages();	}	if (ObjectHelper.isNotEmpty(endpoint.getProperties().getLatitude()) && ObjectHelper.isNotEmpty(endpoint.getProperties().getLongitude()) && ObjectHelper.isNotEmpty(endpoint.getProperties().getRadius())) {	GeoLocation location = new GeoLocation(endpoint.getProperties().getLatitude(), endpoint.getProperties().getLongitude());	query.setGeoCode(location, endpoint.getProperties().getRadius(), Unit.valueOf(endpoint.getProperties().getDistanceMetric()));	}	
searching with pages 

========================= camel sample_14214 =========================

final Set<String> argNames = new HashSet<>(endpoint.getEndpointPropertyNames());	propertyNamesInterceptor.interceptPropertyNames(argNames);	List<ApiMethod> filteredMethods = endpoint.methodHelper.filterMethods( endpoint.getCandidates(), ApiMethodHelper.MatchType.SUPER_SET, argNames);	if (filteredMethods.isEmpty()) {	ApiMethodHelper<? extends ApiMethod> methodHelper = endpoint.getMethodHelper();	throw new IllegalArgumentException( String.format("Missing properties for %s/%s, need one or more from %s", endpoint.getApiName().getName(), endpoint.getMethodName(), methodHelper.getMissingProperties(endpoint.getMethodName(), argNames)));	} else if (filteredMethods.size() == 1) {	result = filteredMethods.get(0);	} else {	result = ApiMethodHelper.getHighestPriorityMethod(filteredMethods);	
using highest priority operation s from operations s for endpoint s 

========================= camel sample_4315 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<BindyCsvDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.bindy-csv.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.bindy-csv.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_973 =========================

count++;	model = factory.factory();	List<String> result = Arrays.asList(line.split(separator));	if (result.size() == 0 || result.isEmpty()) {	throw new java.lang.IllegalArgumentException("No records have been defined in the KVP");	}	if (result.size() > 0) {	factory.bind(getCamelContext(), result, model, count, lists);	factory.link(model);	models.add(model);	
graph of objects created 

========================= camel sample_7493 =========================

result.expectedMessageCount(1);	template.sendBody("direct:start", "Hello World");	result.assertIsSatisfied();	MBeanServer mbeanServer = getMBeanServer();	ObjectName on = ObjectName.getInstance("org.apache.camel:context=camel-1,type=services,*");	Set<ObjectName> names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	ObjectName onP = ObjectName.getInstance("org.apache.camel:context=camel-1,type=producers,*");	Set<ObjectName> namesP = mbeanServer.queryNames(onP, null);	assertEquals(1, namesP.size());	
adding route 

}	});	MockEndpoint bar = getMockEndpoint("mock:bar");	bar.expectedMessageCount(1);	template.sendBody("direct:bar", "Hello World");	bar.assertIsSatisfied();	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	namesP = mbeanServer.queryNames(onP, null);	assertEquals(2, namesP.size());	
removing route 

assertEquals(services, names.size());	namesP = mbeanServer.queryNames(onP, null);	assertEquals(2, namesP.size());	context.stopRoute("bar");	boolean removed = context.removeRoute("bar");	assertTrue(removed);	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	namesP = mbeanServer.queryNames(onP, null);	assertEquals(1, namesP.size());	
shutting down 

result.expectedMessageCount(1);	template.sendBody("direct:start", "Hello World");	result.assertIsSatisfied();	MBeanServer mbeanServer = getMBeanServer();	ObjectName on = ObjectName.getInstance("org.apache.camel:context=camel-1,type=services,*");	Set<ObjectName> names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	ObjectName onP = ObjectName.getInstance("org.apache.camel:context=camel-1,type=producers,*");	Set<ObjectName> namesP = mbeanServer.queryNames(onP, null);	assertEquals(1, namesP.size());	
adding route 

}	});	MockEndpoint bar = getMockEndpoint("mock:bar");	bar.expectedMessageCount(1);	template.sendBodyAndHeader("direct:bar", "Hello World", "bar", "mock:bar");	bar.assertIsSatisfied();	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	namesP = mbeanServer.queryNames(onP, null);	assertEquals(1, namesP.size());	
removing route 

assertEquals(services, names.size());	namesP = mbeanServer.queryNames(onP, null);	assertEquals(1, namesP.size());	context.stopRoute("bar");	boolean removed = context.removeRoute("bar");	assertTrue(removed);	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	namesP = mbeanServer.queryNames(onP, null);	assertEquals(1, namesP.size());	
shutting down 

result.expectedMessageCount(1);	template.sendBody("direct:start", "Hello World");	result.assertIsSatisfied();	MBeanServer mbeanServer = getMBeanServer();	ObjectName on = ObjectName.getInstance("org.apache.camel:context=camel-1,type=services,*");	Set<ObjectName> names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	ObjectName onP = ObjectName.getInstance("org.apache.camel:context=camel-1,type=producers,*");	Set<ObjectName> namesP = mbeanServer.queryNames(onP, null);	assertEquals(1, namesP.size());	
adding route 

}	});	MockEndpoint bar = getMockEndpoint("mock:bar");	bar.expectedMessageCount(1);	template.sendBodyAndHeader("direct:bar", "Hello World", "bar", "mock:bar");	bar.assertIsSatisfied();	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	namesP = mbeanServer.queryNames(onP, null);	assertEquals(1, namesP.size());	
removing route 

assertEquals(services, names.size());	namesP = mbeanServer.queryNames(onP, null);	assertEquals(1, namesP.size());	context.stopRoute("bar");	boolean removed = context.removeRoute("bar");	assertTrue(removed);	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	namesP = mbeanServer.queryNames(onP, null);	assertEquals(1, namesP.size());	
shutting down 

public void testRouteAddRemoteRouteWithRecipientListAndRouteScopedOnException() throws Exception {	MockEndpoint result = getMockEndpoint("mock:result");	result.expectedMessageCount(1);	template.sendBody("direct:start", "Hello World");	result.assertIsSatisfied();	MBeanServer mbeanServer = getMBeanServer();	ObjectName on = ObjectName.getInstance("org.apache.camel:context=camel-1,type=services,*");	Set<ObjectName> names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	
adding route 

});	getMockEndpoint("mock:bar").expectedMessageCount(1);	getMockEndpoint("mock:error").expectedMessageCount(1);	Map<String, Object> headers = new HashMap<String, Object>();	headers.put("error", "mock:error");	headers.put("bar", "mock:bar");	template.sendBodyAndHeaders("direct:bar", "Hello World", headers);	assertMockEndpointsSatisfied();	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	
stopping route 

getMockEndpoint("mock:bar").expectedMessageCount(1);	getMockEndpoint("mock:error").expectedMessageCount(1);	Map<String, Object> headers = new HashMap<String, Object>();	headers.put("error", "mock:error");	headers.put("bar", "mock:bar");	template.sendBodyAndHeaders("direct:bar", "Hello World", headers);	assertMockEndpointsSatisfied();	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	context.stopRoute("bar");	
removing route 

headers.put("bar", "mock:bar");	template.sendBodyAndHeaders("direct:bar", "Hello World", headers);	assertMockEndpointsSatisfied();	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	context.stopRoute("bar");	boolean removed = context.removeRoute("bar");	assertTrue(removed);	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	
shutting down 

public void testRouteAddRemoteRouteWithRecipientListAndContextScopedOnException() throws Exception {	MockEndpoint result = getMockEndpoint("mock:result");	result.expectedMessageCount(1);	template.sendBody("direct:start", "Hello World");	result.assertIsSatisfied();	MBeanServer mbeanServer = getMBeanServer();	ObjectName on = ObjectName.getInstance("org.apache.camel:context=camel-1,type=services,*");	Set<ObjectName> names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	
adding route 

});	getMockEndpoint("mock:bar").expectedMessageCount(1);	getMockEndpoint("mock:error").expectedMessageCount(1);	Map<String, Object> headers = new HashMap<String, Object>();	headers.put("error", "mock:error");	headers.put("bar", "mock:bar");	template.sendBodyAndHeaders("direct:bar", "Hello World", headers);	assertMockEndpointsSatisfied();	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	
stopping route 

getMockEndpoint("mock:bar").expectedMessageCount(1);	getMockEndpoint("mock:error").expectedMessageCount(1);	Map<String, Object> headers = new HashMap<String, Object>();	headers.put("error", "mock:error");	headers.put("bar", "mock:bar");	template.sendBodyAndHeaders("direct:bar", "Hello World", headers);	assertMockEndpointsSatisfied();	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	context.stopRoute("bar");	
removing route 

headers.put("bar", "mock:bar");	template.sendBodyAndHeaders("direct:bar", "Hello World", headers);	assertMockEndpointsSatisfied();	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	context.stopRoute("bar");	boolean removed = context.removeRoute("bar");	assertTrue(removed);	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	
shutting down 

public void testRouteAddRemoteRouteWithRecipientListAndRouteScopedOnCompletion() throws Exception {	MockEndpoint result = getMockEndpoint("mock:result");	result.expectedMessageCount(1);	template.sendBody("direct:start", "Hello World");	result.assertIsSatisfied();	MBeanServer mbeanServer = getMBeanServer();	ObjectName on = ObjectName.getInstance("org.apache.camel:context=camel-1,type=services,*");	Set<ObjectName> names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	
adding route 

});	getMockEndpoint("mock:bar").expectedMessageCount(1);	getMockEndpoint("mock:done").expectedMessageCount(1);	Map<String, Object> headers = new HashMap<String, Object>();	headers.put("done", "mock:done");	headers.put("bar", "mock:bar");	template.sendBodyAndHeaders("direct:bar", "Hello World", headers);	assertMockEndpointsSatisfied();	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	
stopping route 

getMockEndpoint("mock:bar").expectedMessageCount(1);	getMockEndpoint("mock:done").expectedMessageCount(1);	Map<String, Object> headers = new HashMap<String, Object>();	headers.put("done", "mock:done");	headers.put("bar", "mock:bar");	template.sendBodyAndHeaders("direct:bar", "Hello World", headers);	assertMockEndpointsSatisfied();	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	context.stopRoute("bar");	
removing route 

headers.put("bar", "mock:bar");	template.sendBodyAndHeaders("direct:bar", "Hello World", headers);	assertMockEndpointsSatisfied();	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	context.stopRoute("bar");	boolean removed = context.removeRoute("bar");	assertTrue(removed);	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	
shutting down 

public void testRouteAddRemoteRouteWithRecipientListAndContextScopedOnCompletion() throws Exception {	MockEndpoint result = getMockEndpoint("mock:result");	result.expectedMessageCount(1);	template.sendBody("direct:start", "Hello World");	result.assertIsSatisfied();	MBeanServer mbeanServer = getMBeanServer();	ObjectName on = ObjectName.getInstance("org.apache.camel:context=camel-1,type=services,*");	Set<ObjectName> names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	
adding route 

});	getMockEndpoint("mock:bar").expectedMessageCount(1);	getMockEndpoint("mock:done").expectedMessageCount(1);	Map<String, Object> headers = new HashMap<String, Object>();	headers.put("done", "mock:done");	headers.put("bar", "mock:bar");	template.sendBodyAndHeaders("direct:bar", "Hello World", headers);	assertMockEndpointsSatisfied();	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	
stopping route 

getMockEndpoint("mock:bar").expectedMessageCount(1);	getMockEndpoint("mock:done").expectedMessageCount(1);	Map<String, Object> headers = new HashMap<String, Object>();	headers.put("done", "mock:done");	headers.put("bar", "mock:bar");	template.sendBodyAndHeaders("direct:bar", "Hello World", headers);	assertMockEndpointsSatisfied();	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	context.stopRoute("bar");	
removing route 

headers.put("bar", "mock:bar");	template.sendBodyAndHeaders("direct:bar", "Hello World", headers);	assertMockEndpointsSatisfied();	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	context.stopRoute("bar");	boolean removed = context.removeRoute("bar");	assertTrue(removed);	names = mbeanServer.queryNames(on, null);	assertEquals(services, names.size());	
shutting down 

========================= camel sample_2691 =========================

public Object extractBodyFromJms(Exchange exchange, Message message) {	try {	if (endpoint != null && endpoint.getMessageConverter() != null) {	if (LOG.isTraceEnabled()) {	
extracting body using a custom messageconverter from jms message 

public Object extractBodyFromJms(Exchange exchange, Message message) {	try {	if (endpoint != null && endpoint.getMessageConverter() != null) {	if (LOG.isTraceEnabled()) {	}	return endpoint.getMessageConverter().fromMessage(message);	}	if (endpoint != null && !endpoint.getConfiguration().isMapJmsMessage()) {	
option map jms message is false so using jms message as body 

try {	if (endpoint != null && endpoint.getMessageConverter() != null) {	if (LOG.isTraceEnabled()) {	}	return endpoint.getMessageConverter().fromMessage(message);	}	if (endpoint != null && !endpoint.getConfiguration().isMapJmsMessage()) {	return message;	}	if (message instanceof ObjectMessage) {	
extracting body as a objectmessage from jms message 

ObjectMessage objectMessage = (ObjectMessage)message;	Object payload = objectMessage.getObject();	if (payload instanceof DefaultExchangeHolder) {	DefaultExchangeHolder holder = (DefaultExchangeHolder) payload;	DefaultExchangeHolder.unmarshal(exchange, holder);	return exchange.getIn().getBody();	} else {	return objectMessage.getObject();	}	} else if (message instanceof TextMessage) {	
extracting body as a textmessage from jms message 

DefaultExchangeHolder holder = (DefaultExchangeHolder) payload;	DefaultExchangeHolder.unmarshal(exchange, holder);	return exchange.getIn().getBody();	} else {	return objectMessage.getObject();	}	} else if (message instanceof TextMessage) {	TextMessage textMessage = (TextMessage)message;	return textMessage.getText();	} else if (message instanceof MapMessage) {	
extracting body as a mapmessage from jms message 

return exchange.getIn().getBody();	} else {	return objectMessage.getObject();	}	} else if (message instanceof TextMessage) {	TextMessage textMessage = (TextMessage)message;	return textMessage.getText();	} else if (message instanceof MapMessage) {	return createMapFromMapMessage((MapMessage)message);	} else if (message instanceof BytesMessage) {	
extracting body as a bytesmessage from jms message 

return objectMessage.getObject();	}	} else if (message instanceof TextMessage) {	TextMessage textMessage = (TextMessage)message;	return textMessage.getText();	} else if (message instanceof MapMessage) {	return createMapFromMapMessage((MapMessage)message);	} else if (message instanceof BytesMessage) {	return createByteArrayFromBytesMessage(exchange, (BytesMessage)message);	} else if (message instanceof StreamMessage) {	
extracting body as a streammessage from jms message 

protected Object createByteArrayFromBytesMessage(Exchange exchange, BytesMessage message) throws JMSException {	Long size = getSafeLongProperty(message, "_AMQ_LARGE_SIZE");	if (size != null && size > 0) {	
optimised for artemis reading from bytesmessage in streaming mode directly into cachedoutputstream payload 

return cos.getInputStream();	} catch (IOException e) {	JMSException cause = new MessageFormatException(e.getMessage());	cause.initCause(e);	throw cause;	} finally {	IOHelper.close(cos);	}	}	if (message.getBodyLength() > Integer.MAX_VALUE) {	
length of bytesmessage is too long 

answer = answer instanceof ObjectMessage ? answer : null;	} else if (type == Stream) {	answer = answer instanceof StreamMessage ? answer : null;	}	}	}	}	}	if (answer == null) {	if (cause != null) {	
will create jmsmessage with caused exception 

JmsMessageHelper.setJMSReplyTo(jmsMessage, replyTo);	} else if (headerName.equals("JMSType")) {	jmsMessage.setJMSType(ExchangeHelper.convertToType(exchange, String.class, headerValue));	} else if (headerName.equals("JMSPriority")) {	jmsMessage.setJMSPriority(ExchangeHelper.convertToType(exchange, Integer.class, headerValue));	} else if (headerName.equals("JMSDeliveryMode")) {	JmsMessageHelper.setJMSDeliveryMode(exchange, jmsMessage, headerValue);	} else if (headerName.equals("JMSExpiration")) {	jmsMessage.setJMSExpiration(ExchangeHelper.convertToType(exchange, Long.class, headerValue));	} else {	
ignoring jms header with value 

jmsMessage.setJMSExpiration(ExchangeHelper.convertToType(exchange, Long.class, headerValue));	} else {	}	} else if (shouldOutputHeader(in, headerName, headerValue, exchange)) {	Object value = getValidJMSHeaderValue(headerName, headerValue);	if (value == null && endpoint.getConfiguration().getAllowAdditionalHeaders() != null) {	Iterator it = ObjectHelper.createIterator(endpoint.getConfiguration().getAllowAdditionalHeaders());	while (it.hasNext()) {	String pattern = (String) it.next();	if (EndpointHelper.matchPattern(headerName, pattern)) {	
header allowed as additional header despite not being valid according to the jms specification 

if (EndpointHelper.matchPattern(headerName, pattern)) {	value = headerValue;	break;	}	}	}	if (value != null) {	String key = jmsKeyFormatStrategy.encodeKey(headerName);	JmsMessageHelper.setProperty(jmsMessage, key, value);	} else if (LOG.isDebugEnabled()) {	
ignoring non primitive header of class with value 

protected Message createJmsMessage(Exception cause, Session session) throws JMSException {	
using jmsmessagetype 

JmsMessageType type;	if (endpoint != null && endpoint.isTransferExchange()) {	LOG.trace("Option transferExchange=true so we use JmsMessageType: Object");	Serializable holder = DefaultExchangeHolder.marshal(exchange, true, endpoint.isAllowSerializedHeaders());	Message answer = session.createObjectMessage(holder);	answer.setJMSDeliveryMode(Message.DEFAULT_DELIVERY_MODE);	return answer;	}	if (endpoint != null && endpoint.getMessageConverter() != null) {	if (LOG.isTraceEnabled()) {	
creating jmsmessage using a custom messageconverter with body 

type = context.getTypeConverter().convertTo(JmsMessageType.class, headers.get(JmsConstants.JMS_MESSAGE_TYPE));	} else if (endpoint != null && endpoint.getConfiguration().getJmsMessageType() != null) {	type = endpoint.getConfiguration().getJmsMessageType();	} else {	type = getJMSMessageTypeForBody(exchange, body, headers, session, context);	}	if (type != null) {	if (body == null && (endpoint != null && !endpoint.getConfiguration().isAllowNullBody())) {	throw new JMSException("Cannot send message as message body is null, and option allowNullBody is false.");	}	
using jmsmessagetype 

throw new JMSException("Cannot send message as message body is null, and option allowNullBody is false.");	}	Message answer = createJmsMessageForType(exchange, body, headers, session, context, type);	answer.setJMSDeliveryMode(Message.DEFAULT_DELIVERY_MODE);	return answer;	}	if (body == null && (endpoint != null && !endpoint.getConfiguration().isAllowNullBody())) {	throw new JMSException("Cannot send message as message body is null, and option allowNullBody is false.");	}	if (body != null && LOG.isWarnEnabled()) {	
cannot determine specific jmsmessage type to use from body class will use generic jmsmessage body class if you want to send a pojo then your class might need to implement java io serializable or you can force a specific type by setting the jmsmessagetype option on the jms endpoint 

String payload = context.getTypeConverter().convertTo(String.class, exchange, body);	message.setText(payload);	}	return message;	}	case Bytes: {	BytesMessage message = session.createBytesMessage();	if (body != null) {	try {	if (isVendor(session, "Artemis")) {	
optimised for artemis streaming payload in bytesmessage 

}	return message;	}	case Bytes: {	BytesMessage message = session.createBytesMessage();	if (body != null) {	try {	if (isVendor(session, "Artemis")) {	InputStream is = context.getTypeConverter().mandatoryConvertTo(InputStream.class, exchange, body);	message.setObjectProperty("JMS_AMQ_InputStream", is);	
optimised for artemis finished streaming payload in bytesmessage 

}	}	return message;	}	case Stream: {	StreamMessage message = session.createStreamMessage();	if (body != null) {	long size = 0;	try {	InputStream is = context.getTypeConverter().mandatoryConvertTo(InputStream.class, exchange, body);	
writing payload in streammessage 

try {	InputStream is = context.getTypeConverter().mandatoryConvertTo(InputStream.class, exchange, body);	byte[] buffer = new byte[FileUtil.BUFFER_SIZE];	int len = 0;	int count = 0;	while (len >= 0) {	count++;	len = is.read(buffer);	if (len >= 0) {	size += len;	
writing payload chunk as bytes in streammessage 

int len = 0;	int count = 0;	while (len >= 0) {	count++;	len = is.read(buffer);	if (len >= 0) {	size += len;	message.writeBytes(buffer, 0, len);	}	}	
finished writing payload size as bytes in streammessage 

========================= camel sample_7169 =========================

public void testUploadFileToFolder() throws Exception {	File folder = uploadTestFolder();	File file = uploadTestFile();	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelGoogleDrive.folderId", folder.getId());	com.google.api.services.drive.model.ChildReference child = new com.google.api.services.drive.model.ChildReference();	child.setId(file.getId());	headers.put("CamelGoogleDrive.content", child);	requestBodyAndHeaders("direct: final com.google.api.services.drive.model.ChildList result = requestBody("direct: assertNotNull("insert result", result);	
insert 

========================= camel sample_15405 =========================

if (exchange.getProperty(Exchange.ASYNC_WAIT) != null) {	wait = exchange.getProperty(Exchange.ASYNC_WAIT, WaitForTaskToComplete.class);	}	if (wait == WaitForTaskToComplete.Always || (wait == WaitForTaskToComplete.IfReplyExpected && ExchangeHelper.isOutCapable(exchange))) {	final Exchange copy = prepareCopy(exchange, false);	final CountDownLatch latch = new CountDownLatch(1);	copy.addOnCompletion(new SynchronizationAdapter() {	public void onDone(final Exchange response) {	if (latch.getCount() == 0) {	if (log.isTraceEnabled()) {	
timeout occurred so response will be ignored 

if (wait == WaitForTaskToComplete.Always || (wait == WaitForTaskToComplete.IfReplyExpected && ExchangeHelper.isOutCapable(exchange))) {	final Exchange copy = prepareCopy(exchange, false);	final CountDownLatch latch = new CountDownLatch(1);	copy.addOnCompletion(new SynchronizationAdapter() {	public void onDone(final Exchange response) {	if (latch.getCount() == 0) {	if (log.isTraceEnabled()) {	}	} else {	if (log.isTraceEnabled()) {	
with response 

public boolean allowHandover() {	return false;	}	public String toString() {	return "onDone at endpoint: " + endpoint;	}	});	doPublish(copy);	if (timeout > 0) {	if (log.isTraceEnabled()) {	
waiting for task to complete using timeout ms at 

done = latch.await(timeout, TimeUnit.MILLISECONDS);	} catch (InterruptedException e) {	}	if (!done) {	exchange.setProperty(DisruptorEndpoint.DISRUPTOR_IGNORE_EXCHANGE, true);	exchange.setException(new ExchangeTimedOutException(exchange, timeout));	latch.countDown();	}	} else {	if (log.isTraceEnabled()) {	
waiting for task to complete blocking at 

private void doPublish(Exchange exchange) {	
publishing exchange to disruptor ringbuffer 

========================= camel sample_10742 =========================

public void process(Exchange exchange) throws Exception {	
crafting standard response in stockquoteresponseprocessor 

========================= camel sample_17087 =========================

public void process(Exchange exchange) throws Exception {	List<MetricDatum> metricData = getMetricData(exchange);	PutMetricDataRequest request = new PutMetricDataRequest() .withMetricData(metricData) .withNamespace(determineNameSpace(exchange));	
sending request from exchange 

========================= camel sample_8789 =========================

AtomicReference<Throwable> thrown = new AtomicReference<>(null);	callback = ReactiveStreamsHelper.attachCallback(data, (exchange, error) -> {	thrown.compareAndSet(null, error);	if (counter.decrementAndGet() == 0) {	originalCallback.processed(exchange, thrown.get());	}	});	}	if (subs.size() > 0) {	if (LOG.isDebugEnabled()) {	
exchange published to subscriptions for the stream 

========================= camel sample_11503 =========================

}	SplitStrategy idleStrategy = null;	for (SplitStrategy strategy : config.getSplitStrategies()) {	if (strategy.type == SplitStrategyType.IDLE) {	idleStrategy = strategy;	break;	}	}	if (idleStrategy != null) {	scheduler = getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "HdfsIdleCheck");	
creating idlecheck task scheduled to run every millis 

private synchronized HdfsOutputStream setupHdfs(boolean onStartup) throws Exception {	if (ostream != null) {	return ostream;	}	StringBuilder actualPath = new StringBuilder(hdfsPath);	if (config.getSplitStrategies().size() > 0) {	actualPath = newFileName();	}	if (onStartup) {	
connecting to hdfs file system may take a while if connection is not available 

if (ostream != null) {	return ostream;	}	StringBuilder actualPath = new StringBuilder(hdfsPath);	if (config.getSplitStrategies().size() > 0) {	actualPath = newFileName();	}	if (onStartup) {	} else {	if (log.isDebugEnabled()) {	
connecting to hdfs file system may take a while if connection is not available 

if (config.getSplitStrategies().size() > 0) {	actualPath = newFileName();	}	if (onStartup) {	} else {	if (log.isDebugEnabled()) {	}	}	HdfsOutputStream answer = HdfsOutputStream.createOutputStream(actualPath.toString(), config);	if (onStartup) {	
connected to hdfs file system 

}	if (onStartup) {	} else {	if (log.isDebugEnabled()) {	}	}	HdfsOutputStream answer = HdfsOutputStream.createOutputStream(actualPath.toString(), config);	if (onStartup) {	} else {	if (log.isDebugEnabled()) {	
connected to hdfs file system 

public void run() {	if (ostream == null) {	return;	}	
idlecheck running 

public void run() {	if (ostream == null) {	return;	}	if (System.currentTimeMillis() - ostream.getLastAccess() > strategy.value && !idle.get() && !ostream.isBusy().get()) {	idle.set(true);	try {	
closing stream as idle 

========================= camel sample_11153 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<TerserLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.terser.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.terser.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_1052 =========================

properties.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_CACHE, isLoaderCache() ? "true" : "false");	properties.setProperty(RuntimeConstants.RESOURCE_LOADER, "file, class");	properties.setProperty("class.resource.loader.description", "Camel Velocity Classpath Resource Loader");	properties.setProperty("class.resource.loader.class", CamelVelocityClasspathResourceLoader.class.getName());	final Logger velocityLogger = LoggerFactory.getLogger("org.apache.camel.maven.Velocity");	properties.setProperty(RuntimeConstants.RUNTIME_LOG_NAME, velocityLogger.getName());	if (ObjectHelper.isNotEmpty(getPropertiesFile())) {	InputStream reader = ResourceHelper.resolveMandatoryResourceAsInputStream(getCamelContext(), getPropertiesFile());	try {	properties.load(reader);	
loaded the velocity configuration file 

final Logger velocityLogger = LoggerFactory.getLogger("org.apache.camel.maven.Velocity");	properties.setProperty(RuntimeConstants.RUNTIME_LOG_NAME, velocityLogger.getName());	if (ObjectHelper.isNotEmpty(getPropertiesFile())) {	InputStream reader = ResourceHelper.resolveMandatoryResourceAsInputStream(getCamelContext(), getPropertiesFile());	try {	properties.load(reader);	} finally {	IOHelper.close(reader, getPropertiesFile(), log);	}	}	
initializing velocityengine with properties 

public VelocityEndpoint findOrCreateEndpoint(String uri, String newResourceUri) {	String newUri = uri.replace(getResourceUri(), newResourceUri);	
getting endpoint with uri 

protected void onExchange(Exchange exchange) throws Exception {	String path = getResourceUri();	ObjectHelper.notNull(path, "resourceUri");	String newResourceUri = exchange.getIn().getHeader(VelocityConstants.VELOCITY_RESOURCE_URI, String.class);	if (newResourceUri != null) {	exchange.getIn().removeHeader(VelocityConstants.VELOCITY_RESOURCE_URI);	
set to creating new endpoint to handle exchange 

exchange.getIn().removeHeader(VelocityConstants.VELOCITY_RESOURCE_URI);	VelocityEndpoint newEndpoint = findOrCreateEndpoint(getEndpointUri(), newResourceUri);	newEndpoint.onExchange(exchange);	return;	}	Reader reader;	String content = exchange.getIn().getHeader(VelocityConstants.VELOCITY_TEMPLATE, String.class);	if (content != null) {	reader = new StringReader(content);	if (log.isDebugEnabled()) {	
velocity content read from header for endpoint 

}	Reader reader;	String content = exchange.getIn().getHeader(VelocityConstants.VELOCITY_TEMPLATE, String.class);	if (content != null) {	reader = new StringReader(content);	if (log.isDebugEnabled()) {	}	exchange.getIn().removeHeader(VelocityConstants.VELOCITY_TEMPLATE);	} else {	if (log.isDebugEnabled()) {	
velocity content read from resource with resourceuri for endpoint 

Context velocityContext = exchange.getIn().getHeader(VelocityConstants.VELOCITY_CONTEXT, Context.class);	if (velocityContext == null) {	Map<String, Object> variableMap = ExchangeHelper.createVariableMap(exchange);	Map<String, Object> supplementalMap = exchange.getIn().getHeader(VelocityConstants.VELOCITY_SUPPLEMENTAL_CONTEXT, Map.class);	if (supplementalMap != null) {	variableMap.putAll(supplementalMap);	}	velocityContext = new VelocityContext(variableMap);	}	VelocityEngine engine = getVelocityEngine();	
velocity is evaluating using velocity context 

========================= camel sample_13494 =========================

if (exchange.getException(exception) != null) {	answer = true;	break;	}	}	}	if (answer) {	statistics.onHandledFailure(exchange.getException());	}	}	
should failover for exchangeid 

public boolean isRunAllowed() {	boolean forceShutdown = camelContext.getShutdownStrategy().forceShutdown(this);	if (forceShutdown) {	
run not allowed as shutdownstrategy is forcing shutting down 

if (idx == -1) {	idx = 0;	}	index.set(idx);	} else if (isRoundRobin()) {	if (counter.incrementAndGet() >= processors.size()) {	counter.set(0);	}	index.set(counter.get());	}	
failover starting with endpoint index 

}	index.set(idx);	} else if (isRoundRobin()) {	if (counter.incrementAndGet() >= processors.size()) {	counter.set(0);	}	index.set(counter.get());	}	while (first || shouldFailOver(copy)) {	if (!isRunAllowed()) {	
run not allowed will reject executing exchange 

if (!isRunAllowed()) {	if (exchange.getException() == null) {	exchange.setException(new RejectedExecutionException());	}	callback.done(true);	return true;	}	if (!first) {	attempts.incrementAndGet();	if (maximumFailoverAttempts > -1 && attempts.get() > maximumFailoverAttempts) {	
breaking out of failover after failover attempts 

if (maximumFailoverAttempts > -1 && attempts.get() > maximumFailoverAttempts) {	break;	}	index.incrementAndGet();	counter.incrementAndGet();	} else {	first = false;	}	if (index.get() >= processors.size()) {	if (isRoundRobin()) {	
failover is round robin enabled and therefore starting from the first endpoint 

index.incrementAndGet();	counter.incrementAndGet();	} else {	first = false;	}	if (index.get() >= processors.size()) {	if (isRoundRobin()) {	index.set(0);	counter.set(0);	} else {	
breaking out of failover as we reached the end of endpoints to use for failover 

index.set(0);	counter.set(0);	} else {	break;	}	}	copy = prepareExchangeForFailover(exchange);	Processor processor = processors.get(index.get());	boolean sync = processExchange(processor, exchange, copy, attempts, index, callback, processors);	if (!sync) {	
processing exchangeid is continued being processed asynchronously 

} else {	break;	}	}	copy = prepareExchangeForFailover(exchange);	Processor processor = processors.get(index.get());	boolean sync = processExchange(processor, exchange, copy, attempts, index, callback, processors);	if (!sync) {	return false;	}	
processing exchangeid is continued being processed synchronously 

Processor processor = processors.get(index.get());	boolean sync = processExchange(processor, exchange, copy, attempts, index, callback, processors);	if (!sync) {	return false;	}	}	lastGoodIndex.set(index.get());	if (copy != null) {	ExchangeHelper.copyResults(exchange, copy);	}	
failover complete for exchangeid 

private boolean processExchange(Processor processor, Exchange exchange, Exchange copy, AtomicInteger attempts, AtomicInteger index, AsyncCallback callback, List<Processor> processors) {	if (processor == null) {	throw new IllegalStateException("No processors could be chosen to process " + copy);	}	
processing failover at attempt for 

public void done(boolean doneSync) {	if (doneSync) {	return;	}	while (shouldFailOver(copy)) {	if (!isRunAllowed()) {	
run not allowed will reject executing exchange 

}	while (shouldFailOver(copy)) {	if (!isRunAllowed()) {	if (exchange.getException() == null) {	exchange.setException(new RejectedExecutionException());	}	callback.done(false);	}	attempts.incrementAndGet();	if (maximumFailoverAttempts > -1 && attempts.get() > maximumFailoverAttempts) {	
breaking out of failover after failover attempts 

callback.done(false);	}	attempts.incrementAndGet();	if (maximumFailoverAttempts > -1 && attempts.get() > maximumFailoverAttempts) {	break;	}	index.incrementAndGet();	counter.incrementAndGet();	if (index.get() >= processors.size()) {	if (isRoundRobin()) {	
failover is round robin enabled and therefore starting from the first endpoint 

if (maximumFailoverAttempts > -1 && attempts.get() > maximumFailoverAttempts) {	break;	}	index.incrementAndGet();	counter.incrementAndGet();	if (index.get() >= processors.size()) {	if (isRoundRobin()) {	index.set(0);	counter.set(0);	} else {	
breaking out of failover as we reached the end of endpoints to use for failover 

index.set(0);	counter.set(0);	} else {	break;	}	}	copy = prepareExchangeForFailover(exchange);	Processor processor = processors.get(index.get());	doneSync = processExchange(processor, exchange, copy, attempts, index, callback, processors);	if (!doneSync) {	
processing exchangeid is continued being processed asynchronously 

Processor processor = processors.get(index.get());	doneSync = processExchange(processor, exchange, copy, attempts, index, callback, processors);	if (!doneSync) {	return;	}	}	lastGoodIndex.set(index.get());	if (copy != null) {	ExchangeHelper.copyResults(exchange, copy);	}	
failover complete for exchangeid 

========================= camel sample_4483 =========================

protected void commitOffset(StateRepository<String, String> offsetRepository, TopicPartition partition, long partitionLastOffset) {	if (partitionLastOffset != -1) {	if (offsetRepository != null) {	offsetRepository.setState(serializeOffsetKey(partition), serializeOffsetValue(partitionLastOffset));	} else {	
commitsync from topic with offset 

========================= camel sample_16415 =========================

public Boolean executeTest(ITestConfig config, String language) throws Exception {	
getting camel language 

public Boolean executeTest(ITestConfig config, String language) throws Exception {	Language lan = context.resolveLanguage(language);	assertNotNull("Cannot get language with name: " + language, lan);	
found camel language instance with classname 

========================= camel sample_6001 =========================

protected int poll() throws Exception {	shutdownRunningTask = null;	pendingExchanges = 0;	if (entityManager == null) {	if (getEndpoint().isSharedEntityManager()) {	this.entityManager = SharedEntityManagerCreator.createSharedEntityManager(entityManagerFactory);	} else {	this.entityManager = entityManagerFactory.createEntityManager();	}	
recreated entitymanager on 

Object messagePolled = null;	try {	messagePolled = transactionTemplate.execute(new TransactionCallback<Object>() {	public Object doInTransaction(TransactionStatus status) {	if (getEndpoint().isJoinTransaction()) {	entityManager.joinTransaction();	}	Queue<DataHolder> answer = new LinkedList<DataHolder>();	Query query = getQueryFactory().createQuery(entityManager);	configureParameters(query);	
created query 

try {	messagePolled = transactionTemplate.execute(new TransactionCallback<Object>() {	public Object doInTransaction(TransactionStatus status) {	if (getEndpoint().isJoinTransaction()) {	entityManager.joinTransaction();	}	Queue<DataHolder> answer = new LinkedList<DataHolder>();	Query query = getQueryFactory().createQuery(entityManager);	configureParameters(query);	List<?> results = query.getResultList();	
got result list from query 

messagePolled = processBatch(CastUtils.cast(answer));	} catch (Exception e) {	if (e instanceof PersistenceException) {	cause = (PersistenceException) e;	} else {	cause = new PersistenceException(e);	}	}	if (cause != null) {	if (!isTransacted()) {	
error processing last message due will commit all previous successful processed message and ignore this last failure 

} else {	cause = new PersistenceException(e);	}	}	if (cause != null) {	if (!isTransacted()) {	} else {	throw cause;	}	}	
flushing entitymanager 

} else {	throw cause;	}	}	entityManager.flush();	entityManager.clear();	return messagePolled;	}	});	} catch (Exception e) {	
disposing entitymanager on due to coming transaction rollback 

public int processBatch(Queue<Object> exchanges) throws Exception {	int total = exchanges.size();	if (maxMessagesPerPoll > 0 && total > maxMessagesPerPoll) {	
limiting to maximum messages to poll as there were messages in this poll 

DataHolder holder = ObjectHelper.cast(DataHolder.class, exchanges.poll());	EntityManager entityManager = holder.manager;	Exchange exchange = holder.exchange;	Object result = holder.result;	exchange.setProperty(Exchange.BATCH_INDEX, index);	exchange.setProperty(Exchange.BATCH_SIZE, total);	exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);	pendingExchanges = total - index - 1;	if (lockEntity(result, entityManager)) {	createPreDeleteHandler().deleteObject(entityManager, result, exchange);	
processing exchange 

protected boolean lockEntity(Object entity, EntityManager entityManager) {	if (!getEndpoint().isConsumeLockEntity()) {	return true;	}	try {	
acquiring exclusive lock on entity 

}	try {	if (isSkipLockedEntity()) {	entityManager.lock(entity, lockModeType, NOWAIT);	} else {	entityManager.lock(entity, lockModeType);	}	return true;	} catch (Exception e) {	if (LOG.isDebugEnabled()) {	
failed to achieve lock on entity reason 

protected void doStart() throws Exception {	if (getEndpoint().isSharedEntityManager()) {	this.entityManager = SharedEntityManagerCreator.createSharedEntityManager(entityManagerFactory);	} else {	this.entityManager = entityManagerFactory.createEntityManager();	}	
created entitymanager on 

protected void doShutdown() throws Exception {	if (entityManager != null) {	this.entityManager.close();	
closed entitymanager on 

========================= camel sample_14097 =========================

public void testInvocation() throws Exception {	LoanBrokerWS loanBroker = Client.getProxy(url);	String result = loanBroker.getLoanQuote("SSN", 1000.54, 10);	
result 

========================= camel sample_17711 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<HazelcastQueueComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-queue.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-queue.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_709 =========================

protected RoutesBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	
creating new test route 

public void test() throws Exception {	resultEndpoint.setMinimumExpectedMessageCount(1);	resultEndpoint.assertIsSatisfied();	String body = resultEndpoint.getExchanges().get(0).getIn().getBody(String.class);	
received usernames 

========================= camel sample_12143 =========================

public void testList() throws Exception {	File testFile = uploadTestFile();	String fileId = testFile.getId();	final com.google.api.services.drive.model.PermissionList result = requestBody("direct: assertNotNull("list result", result);	
list 

========================= camel sample_15413 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<JohnzonDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.json-johnzon.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.json-johnzon.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_436 =========================

final Policy policy = transactedDefinition.resolvePolicy(routeContext);	if (policy != null) {	if (!(policy instanceof JtaTransactionPolicy)) {	throw new RuntimeCamelException("The configured policy '" + policyRef + "' is of type '" + policyRef.getClass().getName() + "' but an instance of '" + JtaTransactionPolicy.class.getName() + "' is required!");	}	transactionPolicy = (JtaTransactionPolicy) policy;	}	}	}	if (transactionPolicy == null) {	
no transaction policy configured on transactionerrorhandlerbuilder will try find it in the registry 

transactionPolicy = (JtaTransactionPolicy) policy;	}	}	if (transactionPolicy == null) {	TransactedPolicy policy = routeContext.lookup(PROPAGATION_REQUIRED, TransactedPolicy.class);	if (policy instanceof JtaTransactionPolicy) {	transactionPolicy = (JtaTransactionPolicy) policy;	}	}	if (transactionPolicy != null) {	
found transactionpolicy in registry to use 

========================= camel sample_9862 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SparkComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.spark.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.spark.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_965 =========================

public static boolean renameFile(File from, File to, boolean copyAndDeleteOnRenameFail) throws IOException {	if (!from.exists()) {	return false;	}	boolean renamed = false;	int count = 0;	while (!renamed && count < 3) {	if (LOG.isDebugEnabled() && count > 0) {	
retrying attempt to rename file from to 

renamed = from.renameTo(to);	if (!renamed && count > 0) {	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	}	count++;	}	if (!renamed && copyAndDeleteOnRenameFail) {	
cannot rename file from to will now use a copy delete approach instead 

Thread.sleep(1000);	} catch (InterruptedException e) {	}	}	count++;	}	if (!renamed && copyAndDeleteOnRenameFail) {	renamed = renameFileUsingCopy(from, to);	}	if (LOG.isDebugEnabled() && count > 0) {	
tried to rename file to with result 

public static boolean renameFileUsingCopy(File from, File to) throws IOException {	if (!from.exists()) {	return false;	}	
rename file to using copy delete strategy 

public static boolean deleteFile(File file) {	if (!file.exists()) {	return false;	}	boolean deleted = false;	int count = 0;	while (!deleted && count < 3) {	
retrying attempt to delete file 

deleted = file.delete();	if (!deleted && count > 0) {	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	}	count++;	}	if (LOG.isDebugEnabled() && count > 0) {	
tried to delete file with result 

========================= camel sample_4303 =========================

public Output get(Input input) throws Exception {	XmlSignatureProperties.Output result = new Output();	if (!isAddSignedSignatureProperties() && !isAddSignedDataObjectPropeties()) {	
xades signature properties are empty therefore no xades element will be added to the signature 

Document doc;	if (Node.DOCUMENT_NODE == parent.getNodeType()) {	doc = (Document) parent;	} else {	doc = parent.getOwnerDocument();	}	Element qualifyingProperties = createElement("QualifyingProperties", doc, input);	setIdAttributeFromHeader(XmlSignatureConstants.HEADER_XADES_QUALIFYING_PROPERTIES_ID, qualifyingProperties, input);	String signatureId = input.getSignatureId();	if (signatureId == null || signatureId.isEmpty()) {	
no signature id configured therefore a value is generated 

protected void addSignedSignatureProperties(Document doc, Element signedProperties, Input input) throws Exception {	if (isAddSignedSignatureProperties()) {	
adding signed signature properties 

protected void addSignatureProductionPlace(Document doc, Element signedSignatureProperties, Input input) {	if (!isAddSignatureProductionPlace()) {	return;	}	Element signatureProductionPlace = createElement("SignatureProductionPlace", doc, input);	signedSignatureProperties.appendChild(signatureProductionPlace);	if (getSignatureProductionPlaceCity() != null && !getSignatureProductionPlaceCity().isEmpty()) {	
adding production city 

return;	}	Element signatureProductionPlace = createElement("SignatureProductionPlace", doc, input);	signedSignatureProperties.appendChild(signatureProductionPlace);	if (getSignatureProductionPlaceCity() != null && !getSignatureProductionPlaceCity().isEmpty()) {	Element city = createElement("City", doc, input);	signatureProductionPlace.appendChild(city);	city.setTextContent(getSignatureProductionPlaceCity());	}	if (getSignatureProductionPlaceStateOrProvince() != null && !getSignatureProductionPlaceStateOrProvince().isEmpty()) {	
adding production state or province 

Element city = createElement("City", doc, input);	signatureProductionPlace.appendChild(city);	city.setTextContent(getSignatureProductionPlaceCity());	}	if (getSignatureProductionPlaceStateOrProvince() != null && !getSignatureProductionPlaceStateOrProvince().isEmpty()) {	Element stateOrProvince = createElement("StateOrProvince", doc, input);	signatureProductionPlace.appendChild(stateOrProvince);	stateOrProvince.setTextContent(getSignatureProductionPlaceStateOrProvince());	}	if (getSignatureProductionPlacePostalCode() != null && !getSignatureProductionPlacePostalCode().isEmpty()) {	
adding production postal code 

Element stateOrProvince = createElement("StateOrProvince", doc, input);	signatureProductionPlace.appendChild(stateOrProvince);	stateOrProvince.setTextContent(getSignatureProductionPlaceStateOrProvince());	}	if (getSignatureProductionPlacePostalCode() != null && !getSignatureProductionPlacePostalCode().isEmpty()) {	Element postalCode = createElement("PostalCode", doc, input);	signatureProductionPlace.appendChild(postalCode);	postalCode.setTextContent(getSignatureProductionPlacePostalCode());	}	if (getSignatureProductionPlaceCountryName() != null && !getSignatureProductionPlaceCountryName().isEmpty()) {	
adding production country name 

protected void addSignerRole(Document doc, Element signedSignatureProperties, Input input) throws XmlSignatureException, SAXException, IOException, ParserConfigurationException {	if (!isAddSignerRole()) {	return;	}	Element signerRole = createElement("SignerRole", doc, input);	signedSignatureProperties.appendChild(signerRole);	List<String> claimedRoles = getSignerClaimedRoles();	if (!claimedRoles.isEmpty()) {	
adding claimed roles 

Element claimedRolesEl = createElement("ClaimedRoles", doc, input);	signerRole.appendChild(claimedRolesEl);	String errorMessage = "The XAdES confguration is invalid. The list of the claimed roles contains the invalid entry '%s'." + " An entry must either be a text or an XML fragment with the root element '%s' with the namespace '%s'.";	for (String claimedRole : claimedRoles) {	Element claimedRoleEl = createChildFromXmlFragmentOrText(doc, input, "ClaimedRole", errorMessage, claimedRole);	claimedRolesEl.appendChild(claimedRoleEl);	}	}	List<XAdESEncapsulatedPKIData> certifiedRoles = getSignerCertifiedRoles();	if (!certifiedRoles.isEmpty()) {	
adding certified roles 

protected void addSignaturePolicyIdentifier(Document doc, Element signedProperties, Input input) throws XmlSignatureException, SAXException, IOException, ParserConfigurationException {	if (!isAddSignaturePolicy()) {	return;	}	Element signaturePolicyIdentifier = createElement("SignaturePolicyIdentifier", doc, input);	signedProperties.appendChild(signaturePolicyIdentifier);	if (SIG_POLICY_IMPLIED.equals(getSignaturePolicy())) {	
adding implied signature policy 

protected void addSignaturePolicyIdentifier(Document doc, Element signedProperties, Input input) throws XmlSignatureException, SAXException, IOException, ParserConfigurationException {	if (!isAddSignaturePolicy()) {	return;	}	Element signaturePolicyIdentifier = createElement("SignaturePolicyIdentifier", doc, input);	signedProperties.appendChild(signaturePolicyIdentifier);	if (SIG_POLICY_IMPLIED.equals(getSignaturePolicy())) {	Element implied = createElement("SignaturePolicyImplied", doc, input);	signaturePolicyIdentifier.appendChild(implied);	} else if (SIG_POLICY_EXPLICIT_ID.equals(getSignaturePolicy())) {	
adding signatue policy id 

protected void addSigningCertificate(Document doc, Element signedProperties, Input input) throws Exception {	if (getSigningCertificate() == null && (getSigningCertificateChain() == null || getSigningCertificateChain().length == 0)) {	return;	}	Element signedCertificate = createElement("SigningCertificate", doc, input);	signedProperties.appendChild(signedCertificate);	if (getSigningCertificate() != null) {	
adding signing certificate 

}	Element signedCertificate = createElement("SigningCertificate", doc, input);	signedProperties.appendChild(signedCertificate);	if (getSigningCertificate() != null) {	X509Certificate cert = getSigningCertificate();	addCertificate(cert, signedCertificate, doc, 0, input);	} else if (getSigningCertificateChain() != null && getSigningCertificateChain().length > 0) {	Certificate[] certs = getSigningCertificateChain();	int index = 0;	for (Certificate cert : certs) {	
adding chain certtificate 

protected void addSigningTime(Document doc, Element signedProperties, Input input) {	if (isAddSigningTime()) {	
adding signing time 

========================= camel sample_6781 =========================

protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {	HttpRequest request = (HttpRequest) msg;	
message received 

protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {	HttpRequest request = (HttpRequest) msg;	if (consumer.isSuspended()) {	
consumer suspended cannot service request 

boolean inRole = true;	if (principal != null) {	subject = authenticate(security.getSecurityAuthenticator(), security.getLoginDeniedLoggingLevel(), principal);	if (subject != null) {	String userRoles = security.getSecurityAuthenticator().getUserRoles(subject);	inRole = matchesRoles(roles, userRoles);	}	}	if (principal == null || subject == null || !inRole) {	if (principal == null) {	
http basic auth required for resource 

if (principal != null) {	subject = authenticate(security.getSecurityAuthenticator(), security.getLoginDeniedLoggingLevel(), principal);	if (subject != null) {	String userRoles = security.getSecurityAuthenticator().getUserRoles(subject);	inRole = matchesRoles(roles, userRoles);	}	}	if (principal == null || subject == null || !inRole) {	if (principal == null) {	} else if (subject == null) {	
http basic auth not authorized for username 

subject = authenticate(security.getSecurityAuthenticator(), security.getLoginDeniedLoggingLevel(), principal);	if (subject != null) {	String userRoles = security.getSecurityAuthenticator().getUserRoles(subject);	inRole = matchesRoles(roles, userRoles);	}	}	if (principal == null || subject == null || !inRole) {	if (principal == null) {	} else if (subject == null) {	} else {	
http basic auth not in role for username 

} else {	}	HttpResponse response = new DefaultHttpResponse(HTTP_1_1, UNAUTHORIZED);	response.headers().set("WWW-Authenticate", "Basic realm=\"" + security.getRealm() + "\"");	response.headers().set(Exchange.CONTENT_TYPE, "text/plain");	response.headers().set(Exchange.CONTENT_LENGTH, 0);	ctx.writeAndFlush(response);	ctx.channel().close();	return;	} else {	
http basic auth authorized for username 

if (constraint != null) {	if ("Basic".equalsIgnoreCase(constraint.trim())) {	String decoded = ObjectHelper.after(auth, " ");	ByteBuf buf = NettyConverter.toByteBuffer(decoded.getBytes());	ByteBuf out = Base64.decode(buf);	try {	String userAndPw = out.toString(Charset.defaultCharset());	String username = ObjectHelper.before(userAndPw, ":");	String password = ObjectHelper.after(userAndPw, ":");	HttpPrincipal principal = new HttpPrincipal(username, password);	
extracted basic auth principal from http header 

public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {	if (consumer.isRunAllowed()) {	if (cause instanceof ClosedChannelException) {	
channel already closed ignoring this exception 

public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {	if (consumer.isRunAllowed()) {	if (cause instanceof ClosedChannelException) {	} else {	
closing channel as an exception was thrown from netty 

========================= camel sample_16680 =========================

protected void onFullBinaryMessage(final WebSocketChannel channel, BufferedBinaryMessage message) throws IOException {	
onfullbinarymessage 

for (ByteBuffer buffer : buffers) {	int increment = buffer.remaining();	buffer.get(bytes, offset, increment);	offset += increment;	}	synchronized (consumerLock) {	if (consumer != null) {	final Object outMsg = consumer.getEndpoint().isUseStreaming() ? new ByteArrayInputStream(bytes) : bytes;	consumer.sendMessage(connectionKey, outMsg);	} else {	
no consumer to handle message received 

protected void onFullTextMessage(WebSocketChannel channel, BufferedTextMessage message) {	final String text = message.getData();	
onfulltextmessage 

final String text = message.getData();	final String connectionKey = (String) channel.getAttribute(UndertowConstants.CONNECTION_KEY);	if (connectionKey == null) {	throw new RuntimeCamelException(UndertowConstants.CONNECTION_KEY + " attribute not found on " + WebSocketChannel.class.getSimpleName() + " " + channel);	}	synchronized (consumerLock) {	if (consumer != null) {	final Object outMsg = consumer.getEndpoint().isUseStreaming() ? new StringReader(text) : text;	consumer.sendMessage(connectionKey, outMsg);	} else {	
no consumer to handle message received 

public void onConnect(WebSocketHttpExchange exchange, WebSocketChannel channel) {	
onconnect 

========================= camel sample_13178 =========================

public void testVertxMessages() throws Exception {	resultEndpoint = context.getEndpoint(resultUri, MockEndpoint.class);	resultEndpoint.expectedBodiesReceivedInAnyOrder(body1, body2);	template.sendBody(startUri, body1);	template.sendBody(startUri, body2);	resultEndpoint.assertIsSatisfied();	List<Exchange> list = resultEndpoint.getReceivedExchanges();	for (Exchange exchange : list) {	
received exchange headers 

========================= camel sample_11515 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	
direct foo foo got body mock foo 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	
direct bar bar org apache camel customlogger also got body mock bar 

========================= camel sample_2668 =========================

public RouteBuilder route() {	return new RouteBuilder() {	public void configure() throws Exception {	Assert.hasLength(uri);	
cm component is an uri based component cm uri 

========================= camel sample_12769 =========================

protected void assertChildTo(String message, ProcessorDefinition<?> route, String uri) {	ProcessorDefinition<?> processor = assertOneElement(route.getOutputs());	ToDefinition value = assertIsInstanceOf(ToDefinition.class, processor);	String text = message + "To URI";	
testing is equal to for processor 

protected void assertTo(String message, ProcessorDefinition<?> processor, String uri) {	ToDefinition value = assertIsInstanceOf(ToDefinition.class, processor);	String text = message + "To URI";	
testing is equal to for processor 

========================= camel sample_3700 =========================

public void testRouteAddSecondRoute() throws Exception {	if (isPlatform("aix")) {	return;	}	MBeanServer mbeanServer = getMBeanServer();	ObjectName route1 = ObjectName.getInstance("org.apache.camel:context=camel-1,type=routes,name=\"foo\"");	String state = (String) mbeanServer.getAttribute(route1, "State");	assertEquals("Should be started", ServiceStatus.Started.name(), state);	
adding route 

}	MBeanServer mbeanServer = getMBeanServer();	ObjectName route1 = ObjectName.getInstance("org.apache.camel:context=camel-1,type=routes,name=\"foo\"");	String state = (String) mbeanServer.getAttribute(route1, "State");	assertEquals("Should be started", ServiceStatus.Started.name(), state);	context.addRoutes(new RouteBuilder() {	public void configure() throws Exception {	from("direct:bar").routeId("bar").to("mock:bar");	}	});	
adding route done 

========================= camel sample_2812 =========================

public void onMessage(String body) {	
received 

========================= camel sample_6152 =========================

public synchronized boolean connect(RemoteFileConfiguration configuration) throws GenericFileOperationFailedException {	if (isConnected()) {	return true;	}	boolean connected = false;	int attempt = 0;	while (!connected) {	try {	if (LOG.isTraceEnabled() && attempt > 0) {	
reconnect attempt connecting to 

return true;	}	boolean connected = false;	int attempt = 0;	while (!connected) {	try {	if (LOG.isTraceEnabled() && attempt > 0) {	}	if (channel == null || !channel.isConnected()) {	if (session == null || !session.isConnected()) {	
session isn t connected trying to recreate and connect 

boolean connected = false;	int attempt = 0;	while (!connected) {	try {	if (LOG.isTraceEnabled() && attempt > 0) {	}	if (channel == null || !channel.isConnected()) {	if (session == null || !session.isConnected()) {	session = createSession(configuration);	if (endpoint.getConfiguration().getConnectTimeout() > 0) {	
connecting use connecttimeout 

while (!connected) {	try {	if (LOG.isTraceEnabled() && attempt > 0) {	}	if (channel == null || !channel.isConnected()) {	if (session == null || !session.isConnected()) {	session = createSession(configuration);	if (endpoint.getConfiguration().getConnectTimeout() > 0) {	session.connect(endpoint.getConfiguration().getConnectTimeout());	} else {	
connecting 

}	if (channel == null || !channel.isConnected()) {	if (session == null || !session.isConnected()) {	session = createSession(configuration);	if (endpoint.getConfiguration().getConnectTimeout() > 0) {	session.connect(endpoint.getConfiguration().getConnectTimeout());	} else {	session.connect();	}	}	
channel isn t connected trying to recreate and connect 

if (session == null || !session.isConnected()) {	session = createSession(configuration);	if (endpoint.getConfiguration().getConnectTimeout() > 0) {	session.connect(endpoint.getConfiguration().getConnectTimeout());	} else {	session.connect();	}	}	channel = (ChannelSftp) session.openChannel("sftp");	if (endpoint.getConfiguration().getConnectTimeout() > 0) {	
connecting use connecttimeout 

if (endpoint.getConfiguration().getConnectTimeout() > 0) {	session.connect(endpoint.getConfiguration().getConnectTimeout());	} else {	session.connect();	}	}	channel = (ChannelSftp) session.openChannel("sftp");	if (endpoint.getConfiguration().getConnectTimeout() > 0) {	channel.connect(endpoint.getConfiguration().getConnectTimeout());	} else {	
connecting 

} else {	session.connect();	}	}	channel = (ChannelSftp) session.openChannel("sftp");	if (endpoint.getConfiguration().getConnectTimeout() > 0) {	channel.connect(endpoint.getConfiguration().getConnectTimeout());	} else {	channel.connect();	}	
connected to 

} else {	channel.connect();	}	}	connected = true;	} catch (Exception e) {	if (Thread.currentThread().isInterrupted()) {	throw new GenericFileOperationFailedException("Interrupted during connecting", new InterruptedException("Interrupted during connecting"));	}	GenericFileOperationFailedException failed = new GenericFileOperationFailedException("Cannot connect to " + configuration.remoteServerInformation(), e);	
cannot connect due 

private void tryConfigureBulkRequests() throws JSchException {	Integer bulkRequests = endpoint.getConfiguration().getBulkRequests();	if (bulkRequests != null) {	
configuring channel to use up to bulk request s 

protected Session createSession(final RemoteFileConfiguration configuration) throws JSchException {	final JSch jsch = new JSch();	JSch.setLogger(new JSchLogger(endpoint.getConfiguration().getJschLoggingLevel()));	SftpConfiguration sftpConfig = (SftpConfiguration) configuration;	if (isNotEmpty(sftpConfig.getCiphers())) {	
using ciphers 

final JSch jsch = new JSch();	JSch.setLogger(new JSchLogger(endpoint.getConfiguration().getJschLoggingLevel()));	SftpConfiguration sftpConfig = (SftpConfiguration) configuration;	if (isNotEmpty(sftpConfig.getCiphers())) {	Hashtable<String, String> ciphers = new Hashtable<String, String>();	ciphers.put("cipher.s2c", sftpConfig.getCiphers());	ciphers.put("cipher.c2s", sftpConfig.getCiphers());	JSch.setConfig(ciphers);	}	if (isNotEmpty(sftpConfig.getPrivateKeyFile())) {	
using private keyfile 

JSch.setConfig(ciphers);	}	if (isNotEmpty(sftpConfig.getPrivateKeyFile())) {	if (isNotEmpty(sftpConfig.getPrivateKeyPassphrase())) {	jsch.addIdentity(sftpConfig.getPrivateKeyFile(), sftpConfig.getPrivateKeyPassphrase());	} else {	jsch.addIdentity(sftpConfig.getPrivateKeyFile());	}	}	if (sftpConfig.getPrivateKey() != null) {	
using private key information from byte array 

if (isNotEmpty(sftpConfig.getPrivateKeyPassphrase())) {	try {	passphrase = sftpConfig.getPrivateKeyPassphrase().getBytes("UTF-8");	} catch (UnsupportedEncodingException e) {	throw new JSchException("Cannot transform passphrase to byte[]", e);	}	}	jsch.addIdentity("ID", sftpConfig.getPrivateKey(), null, passphrase);	}	if (sftpConfig.getPrivateKeyUri() != null) {	
using private key uri 

try {	InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(endpoint.getCamelContext(), sftpConfig.getPrivateKeyUri());	ByteArrayOutputStream bos = new ByteArrayOutputStream();	IOHelper.copyAndCloseInput(is, bos);	jsch.addIdentity("ID", bos.toByteArray(), null, passphrase);	} catch (IOException e) {	throw new JSchException("Cannot read resource: " + sftpConfig.getPrivateKeyUri(), e);	}	}	if (sftpConfig.getKeyPair() != null) {	
using private key information from key pair 

}	}	if (sftpConfig.getKeyPair() != null) {	KeyPair keyPair = sftpConfig.getKeyPair();	if (keyPair.getPrivate() != null && keyPair.getPublic() != null) {	if (keyPair.getPrivate() instanceof RSAPrivateKey && keyPair.getPublic() instanceof RSAPublicKey) {	jsch.addIdentity(new RSAKeyPairIdentity("ID", keyPair), null);	} else if (keyPair.getPrivate() instanceof DSAPrivateKey && keyPair.getPublic() instanceof DSAPublicKey) {	jsch.addIdentity(new DSAKeyPairIdentity("ID", keyPair), null);	} else {	
only rsa and dsa key pairs are supported 

if (sftpConfig.getKeyPair() != null) {	KeyPair keyPair = sftpConfig.getKeyPair();	if (keyPair.getPrivate() != null && keyPair.getPublic() != null) {	if (keyPair.getPrivate() instanceof RSAPrivateKey && keyPair.getPublic() instanceof RSAPublicKey) {	jsch.addIdentity(new RSAKeyPairIdentity("ID", keyPair), null);	} else if (keyPair.getPrivate() instanceof DSAPrivateKey && keyPair.getPublic() instanceof DSAPublicKey) {	jsch.addIdentity(new DSAKeyPairIdentity("ID", keyPair), null);	} else {	}	} else {	
privatekey and publickey in the keypair must be filled 

if (keyPair.getPrivate() instanceof RSAPrivateKey && keyPair.getPublic() instanceof RSAPublicKey) {	jsch.addIdentity(new RSAKeyPairIdentity("ID", keyPair), null);	} else if (keyPair.getPrivate() instanceof DSAPrivateKey && keyPair.getPublic() instanceof DSAPublicKey) {	jsch.addIdentity(new DSAKeyPairIdentity("ID", keyPair), null);	} else {	}	} else {	}	}	if (isNotEmpty(sftpConfig.getKnownHostsFile())) {	
using knownhosts file 

jsch.addIdentity(new DSAKeyPairIdentity("ID", keyPair), null);	} else {	}	} else {	}	}	if (isNotEmpty(sftpConfig.getKnownHostsFile())) {	jsch.setKnownHosts(sftpConfig.getKnownHostsFile());	}	if (isNotEmpty(sftpConfig.getKnownHostsUri())) {	
using known hosts uri 

}	if (isNotEmpty(sftpConfig.getKnownHostsUri())) {	try {	InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(endpoint.getCamelContext(), sftpConfig.getKnownHostsUri());	jsch.setKnownHosts(is);	} catch (IOException e) {	throw new JSchException("Cannot read resource: " + sftpConfig.getKnownHostsUri(), e);	}	}	if (sftpConfig.getKnownHosts() != null) {	
using known hosts information from byte array 

} catch (IOException e) {	throw new JSchException("Cannot read resource: " + sftpConfig.getKnownHostsUri(), e);	}	}	if (sftpConfig.getKnownHosts() != null) {	jsch.setKnownHosts(new ByteArrayInputStream(sftpConfig.getKnownHosts()));	}	String knownHostsFile = sftpConfig.getKnownHostsFile();	if (knownHostsFile == null && sftpConfig.isUseUserKnownHostsFile()) {	knownHostsFile = System.getProperty("user.home") + "/.ssh/known_hosts";	
known host file not configured using user known host file 

}	}	if (sftpConfig.getKnownHosts() != null) {	jsch.setKnownHosts(new ByteArrayInputStream(sftpConfig.getKnownHosts()));	}	String knownHostsFile = sftpConfig.getKnownHostsFile();	if (knownHostsFile == null && sftpConfig.isUseUserKnownHostsFile()) {	knownHostsFile = System.getProperty("user.home") + "/.ssh/known_hosts";	}	if (ObjectHelper.isNotEmpty(knownHostsFile)) {	
using known hosts information from file 

}	String knownHostsFile = sftpConfig.getKnownHostsFile();	if (knownHostsFile == null && sftpConfig.isUseUserKnownHostsFile()) {	knownHostsFile = System.getProperty("user.home") + "/.ssh/known_hosts";	}	if (ObjectHelper.isNotEmpty(knownHostsFile)) {	jsch.setKnownHosts(knownHostsFile);	}	final Session session = jsch.getSession(configuration.getUsername(), configuration.getHost(), configuration.getPort());	if (isNotEmpty(sftpConfig.getStrictHostKeyChecking())) {	
using strickhostkeychecking 

if (ObjectHelper.isNotEmpty(knownHostsFile)) {	jsch.setKnownHosts(knownHostsFile);	}	final Session session = jsch.getSession(configuration.getUsername(), configuration.getHost(), configuration.getPort());	if (isNotEmpty(sftpConfig.getStrictHostKeyChecking())) {	session.setConfig("StrictHostKeyChecking", sftpConfig.getStrictHostKeyChecking());	}	session.setServerAliveInterval(sftpConfig.getServerAliveInterval());	session.setServerAliveCountMax(sftpConfig.getServerAliveCountMax());	if (sftpConfig.getCompression() > 0) {	
using compression 

session.setConfig("StrictHostKeyChecking", sftpConfig.getStrictHostKeyChecking());	}	session.setServerAliveInterval(sftpConfig.getServerAliveInterval());	session.setServerAliveCountMax(sftpConfig.getServerAliveCountMax());	if (sftpConfig.getCompression() > 0) {	session.setConfig("compression.s2c", "zlib@openssh.com,zlib,none");	session.setConfig("compression.c2s", "zlib@openssh.com,zlib,none");	session.setConfig("compression_level", Integer.toString(sftpConfig.getCompression()));	}	if (sftpConfig.getPreferredAuthentications() != null) {	
using preferredauthentications 

public String getPassword() {	return configuration.getPassword();	}	public boolean promptPassword(String s) {	return true;	}	public boolean promptPassphrase(String s) {	return true;	}	public boolean promptYesNo(String s) {	
server asks for confirmation yes no camel will answer no 

public boolean promptPassword(String s) {	return true;	}	public boolean promptPassphrase(String s) {	return true;	}	public boolean promptYesNo(String s) {	return false;	}	public void showMessage(String s) {	
message received from server 

public synchronized boolean deleteFile(String name) throws GenericFileOperationFailedException {	
deleting file 

public synchronized boolean deleteFile(String name) throws GenericFileOperationFailedException {	try {	reconnectIfNecessary();	channel.rm(name);	return true;	} catch (SftpException e) {	
cannot delete file 

public synchronized boolean renameFile(String from, String to) throws GenericFileOperationFailedException {	
renaming file to 

public synchronized boolean renameFile(String from, String to) throws GenericFileOperationFailedException {	try {	reconnectIfNecessary();	to = FileUtil.compactPath(to, '/');	channel.rename(from, to);	return true;	} catch (SftpException e) {	
cannot rename file from to 

public synchronized boolean buildDirectory(String directory, boolean absolute) throws GenericFileOperationFailedException {	directory = endpoint.getConfiguration().normalizePath(directory);	
builddirectory 

directory = endpoint.getConfiguration().normalizePath(directory);	boolean success = false;	String originalDirectory = getCurrentDirectory();	try {	try {	channel.cd(directory);	success = true;	} catch (SftpException e) {	}	if (!success) {	
trying to build remote directory 

for (String dir : dirs) {	if (first) {	first = false;	} else {	sb.append('/');	}	sb.append(dir);	String directory = endpoint.getConfiguration().normalizePath(sb.toString());	if (!(directory.equals("/") || directory.equals("\\"))) {	try {	
trying to build remote directory by chunk 

public synchronized String getCurrentDirectory() throws GenericFileOperationFailedException {	
getcurrentdirectory 

public synchronized String getCurrentDirectory() throws GenericFileOperationFailedException {	try {	String answer = channel.pwd();	
current dir 

public synchronized void changeCurrentDirectory(String path) throws GenericFileOperationFailedException {	
changecurrentdirectory 

public synchronized void changeCurrentDirectory(String path) throws GenericFileOperationFailedException {	if (ObjectHelper.isEmpty(path)) {	return;	}	String before = path;	char separatorChar = '/';	path = FileUtil.compactPath(path, separatorChar);	if (LOG.isTraceEnabled()) {	
compacted path using separator 

private void doChangeDirectory(String path) {	if (path == null || ".".equals(path) || ObjectHelper.isEmpty(path)) {	return;	}	
changing directory 

public synchronized void changeToParentDirectory() throws GenericFileOperationFailedException {	
changetoparentdirectory 

public synchronized List<SftpRemoteFile> listFiles(String path) throws GenericFileOperationFailedException {	
listfiles 

public synchronized boolean retrieveFile(String name, Exchange exchange, long size) throws GenericFileOperationFailedException {	
retrievefile 

if (endpoint.getConfiguration().isStepwise()) {	currentDir = getCurrentDirectory();	String path = FileUtil.onlyPath(name);	if (path != null) {	changeCurrentDirectory(path);	}	remoteName = FileUtil.stripPath(name);	}	channel.get(remoteName, os);	} catch (SftpException e) {	
error occurred during retrieving file to local directory deleting local work file 

if (path != null) {	changeCurrentDirectory(path);	}	remoteName = FileUtil.stripPath(name);	}	channel.get(remoteName, os);	} catch (SftpException e) {	IOHelper.close(os, "retrieve: " + name, LOG);	boolean deleted = FileUtil.deleteFile(temp);	if (!deleted) {	
error occurred during retrieving file to local directory cannot delete local work file 

boolean deleted = FileUtil.deleteFile(temp);	if (!deleted) {	}	throw new GenericFileOperationFailedException("Cannot retrieve file: " + name, e);	} finally {	IOHelper.close(os, "retrieve: " + name, LOG);	if (currentDir != null) {	changeCurrentDirectory(currentDir);	}	}	
retrieve file to local work file result true 

boolean deleted = FileUtil.deleteFile(temp);	if (!deleted) {	}	throw new GenericFileOperationFailedException("Cannot retrieve file: " + name, e);	} finally {	IOHelper.close(os, "retrieve: " + name, LOG);	if (currentDir != null) {	changeCurrentDirectory(currentDir);	}	}	
renaming local in progress file from to 

public synchronized boolean storeFile(String name, Exchange exchange, long size) throws GenericFileOperationFailedException {	name = endpoint.getConfiguration().normalizePath(name);	
storefile 

private boolean doStoreFile(String name, String targetName, Exchange exchange) throws GenericFileOperationFailedException {	
dostorefile 

private boolean doStoreFile(String name, String targetName, Exchange exchange) throws GenericFileOperationFailedException {	if (endpoint.getFileExist() == GenericFileExist.Ignore || endpoint.getFileExist() == GenericFileExist.Fail || endpoint.getFileExist() == GenericFileExist.Move) {	boolean existFile = existsFile(targetName);	if (existFile && endpoint.getFileExist() == GenericFileExist.Ignore) {	
an existing file already exists ignore and do not override it 

return true;	} else if (existFile && endpoint.getFileExist() == GenericFileExist.Fail) {	throw new GenericFileOperationFailedException("File already exist: " + name + ". Cannot write new file.");	} else if (existFile && endpoint.getFileExist() == GenericFileExist.Move) {	doMoveExistingFile(name, targetName);	}	}	InputStream is = null;	if (exchange.getIn().getBody() == null) {	if (endpoint.isAllowNullBody()) {	
writing empty file 

is = new ByteArrayInputStream(new byte[]{});	} else {	throw new GenericFileOperationFailedException("Cannot write null body to file: " + name);	}	}	try {	if (is == null) {	String charset = endpoint.getCharset();	if (charset != null) {	is = new ByteArrayInputStream(exchange.getIn().getMandatoryBody(String.class).getBytes(charset));	
using inputstream with charset 

try {	if (is == null) {	String charset = endpoint.getCharset();	if (charset != null) {	is = new ByteArrayInputStream(exchange.getIn().getMandatoryBody(String.class).getBytes(charset));	} else {	is = exchange.getIn().getMandatoryBody(InputStream.class);	}	}	final StopWatch watch = new StopWatch();	
about to store file using stream 

if (is == null) {	String charset = endpoint.getCharset();	if (charset != null) {	is = new ByteArrayInputStream(exchange.getIn().getMandatoryBody(String.class).getBytes(charset));	} else {	is = exchange.getIn().getMandatoryBody(InputStream.class);	}	}	final StopWatch watch = new StopWatch();	if (endpoint.getFileExist() == GenericFileExist.Append) {	
client appendfile 

if (charset != null) {	is = new ByteArrayInputStream(exchange.getIn().getMandatoryBody(String.class).getBytes(charset));	} else {	is = exchange.getIn().getMandatoryBody(InputStream.class);	}	}	final StopWatch watch = new StopWatch();	if (endpoint.getFileExist() == GenericFileExist.Append) {	channel.put(is, targetName, ChannelSftp.APPEND);	} else {	
client storefile 

}	}	final StopWatch watch = new StopWatch();	if (endpoint.getFileExist() == GenericFileExist.Append) {	channel.put(is, targetName, ChannelSftp.APPEND);	} else {	channel.put(is, targetName);	}	if (LOG.isDebugEnabled()) {	long time = watch.taken();	
took millis to store file and ftp client returned true 

channel.put(is, targetName, ChannelSftp.APPEND);	} else {	channel.put(is, targetName);	}	if (LOG.isDebugEnabled()) {	long time = watch.taken();	}	String mode = endpoint.getConfiguration().getChmod();	if (ObjectHelper.isNotEmpty(mode)) {	int permissions = Integer.parseInt(mode, 8);	
setting chmod on file 

to = endpoint.getConfiguration().normalizePath(to);	if (ObjectHelper.isEmpty(to)) {	throw new GenericFileOperationFailedException("moveExisting evaluated as empty String, cannot move existing file: " + name);	}	String dir = FileUtil.onlyPath(to);	if (dir != null) {	buildDirectory(dir, false);	}	if (existsFile(to)) {	if (endpoint.isEagerDeleteTargetFile()) {	
deleting existing file 

if (dir != null) {	buildDirectory(dir, false);	}	if (existsFile(to)) {	if (endpoint.isEagerDeleteTargetFile()) {	deleteFile(to);	} else {	throw new GenericFileOperationFailedException("Cannot moved existing file from: " + name + " to: " + to + " as there already exists a file: " + to);	}	}	
moving existing file to 

public synchronized boolean existsFile(String name) throws GenericFileOperationFailedException {	
existsfile 

}	String onlyName = FileUtil.stripPath(name);	try {	Vector files = channel.ls(directory);	if (files == null) {	return false;	}	for (Object file : files) {	ChannelSftp.LsEntry entry = (ChannelSftp.LsEntry) file;	String existing = entry.getFilename();	
existing file target file 

protected boolean fastExistsFile(String name) throws GenericFileOperationFailedException {	
fastexistsfile 

public synchronized boolean sendNoop() throws GenericFileOperationFailedException {	if (isConnected()) {	try {	session.sendKeepAliveMsg();	return true;	} catch (Exception e) {	
sftp session was closed ignoring this exception 

========================= camel sample_15385 =========================

StringWriter buffer = new StringWriter();	Map<String, Object> variableMap = exchange.getIn().getHeader(StringTemplateConstants.STRINGTEMPLATE_VARIABLE_MAP, Map.class);	if (variableMap == null) {	variableMap = ExchangeHelper.createVariableMap(exchange);	}	String text = exchange.getContext().getTypeConverter().mandatoryConvertTo(String.class, getResourceAsInputStream());	ST template = new ST(text, delimiterStart, delimiterStop);	for (Map.Entry<String, Object> entry : variableMap.entrySet()) {	template.add(entry.getKey(), entry.getValue());	}	
stringtemplate is writing using attributes 

========================= camel sample_12440 =========================

public void onDisconnected() {	
server ondisconnected 

public void onRegistered() {	
server onregistered 

========================= camel sample_12155 =========================

public void init(final ServletConfig config) throws ServletException {	super.init(config);	Map<String, Object> parameters = new HashMap<String, Object>();	Enumeration en = config.getInitParameterNames();	while (en.hasMoreElements()) {	String name = (String) en.nextElement();	Object value = config.getInitParameter(name);	parameters.put(name, value);	}	if (parameters.get("cors") != null) {	
use restswaggercorsfilter when uisng this servlet to enable cors 

boolean match = false;	if (name != null) {	match = true;	if (apiContextIdPattern != null) {	if ("#name#".equals(apiContextIdPattern)) {	match = true;	} else {	match = EndpointHelper.matchPattern(name, apiContextIdPattern);	}	if (LOG.isDebugEnabled()) {	
match contextid with pattern 

}	}	}	if (!match) {	adapter.noContent();	} else {	support.renderResourceListing(adapter, swaggerConfig, name, route, json, yaml, classResolver, null);	}	}	} catch (Exception e) {	
error rendering swagger api due 

========================= camel sample_17357 =========================

protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {	LoggingLevel level = getLoggingLevel(parameters);	Logger providedLogger = getLogger(parameters);	if (providedLogger == null) {	Map<String, Logger> availableLoggers = getCamelContext().getRegistry().findByTypeWithName(Logger.class);	if (availableLoggers.size() == 1) {	providedLogger = availableLoggers.values().iterator().next();	
using custom logger 

protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {	LoggingLevel level = getLoggingLevel(parameters);	Logger providedLogger = getLogger(parameters);	if (providedLogger == null) {	Map<String, Logger> availableLoggers = getCamelContext().getRegistry().findByTypeWithName(Logger.class);	if (availableLoggers.size() == 1) {	providedLogger = availableLoggers.values().iterator().next();	} else if (availableLoggers.size() > 1) {	
more than one instance found in the registry falling back to creating logger from uri 

========================= camel sample_4929 =========================

public Object populateCxfRsResponseFromExchange(Exchange camelExchange, org.apache.cxf.message.Exchange cxfExchange) throws Exception {	if (camelExchange.isFailed() && camelExchange.getException() != null) {	throw camelExchange.getException();	}	org.apache.camel.Message response;	if (camelExchange.getPattern().isOutCapable()) {	if (camelExchange.hasOut()) {	response = camelExchange.getOut();	
get the response from the out message 

public Object populateCxfRsResponseFromExchange(Exchange camelExchange, org.apache.cxf.message.Exchange cxfExchange) throws Exception {	if (camelExchange.isFailed() && camelExchange.getException() != null) {	throw camelExchange.getException();	}	org.apache.camel.Message response;	if (camelExchange.getPattern().isOutCapable()) {	if (camelExchange.hasOut()) {	response = camelExchange.getOut();	} else {	response = camelExchange.getIn();	
get the response from the in message as a fallback 

}	org.apache.camel.Message response;	if (camelExchange.getPattern().isOutCapable()) {	if (camelExchange.hasOut()) {	response = camelExchange.getOut();	} else {	response = camelExchange.getIn();	}	} else {	response = camelExchange.getIn();	
get the response from the in message 

========================= camel sample_8009 =========================

public HttpClient createHttpClient() {	ObjectHelper.notNull(clientParams, "clientParams");	ObjectHelper.notNull(httpConnectionManager, "httpConnectionManager");	HttpClient answer = new HttpClient(getClientParams());	if (ObjectHelper.isNotEmpty(getCamelContext().getProperty("http.proxyHost")) && ObjectHelper.isNotEmpty(getCamelContext().getProperty("http.proxyPort"))) {	String host = getCamelContext().getProperty("http.proxyHost");	int port = Integer.parseInt(getCamelContext().getProperty("http.proxyPort"));	
camelcontext properties http proxyhost and http proxyport detected using http proxy host port 

public HttpClient createHttpClient() {	ObjectHelper.notNull(clientParams, "clientParams");	ObjectHelper.notNull(httpConnectionManager, "httpConnectionManager");	HttpClient answer = new HttpClient(getClientParams());	if (ObjectHelper.isNotEmpty(getCamelContext().getProperty("http.proxyHost")) && ObjectHelper.isNotEmpty(getCamelContext().getProperty("http.proxyPort"))) {	String host = getCamelContext().getProperty("http.proxyHost");	int port = Integer.parseInt(getCamelContext().getProperty("http.proxyPort"));	answer.getHostConfiguration().setProxy(host, port);	}	if (getProxyHost() != null) {	
using proxy 

if (getAuthMethodPriority() != null) {	List<String> authPrefs = new ArrayList<String>();	Iterator<?> it = getCamelContext().getTypeConverter().convertTo(Iterator.class, getAuthMethodPriority());	int i = 1;	while (it.hasNext()) {	Object value = it.next();	AuthMethod auth = getCamelContext().getTypeConverter().convertTo(AuthMethod.class, value);	if (auth == null) {	throw new IllegalArgumentException("Unknown authMethod: " + value + " in authMethodPriority: " + getAuthMethodPriority());	}	
using authschemepriority 

========================= camel sample_12856 =========================

private void processExchangeForUser(String user, Exchange exchange) throws Exception {	String urlPath = String.format(getMostRecentMessageUrl(), user);	
polling hipchat api for new messages at UTC 

private void processApiResponse(Exchange exchange, CloseableHttpResponse response) throws Exception {	try {	Map<String, Object> jsonMap = MAPPER.readValue(response.getEntity().getContent(), MAP_TYPE);	
hipchat response json 

private void processApiResponse(Exchange exchange, CloseableHttpResponse response) throws Exception {	try {	Map<String, Object> jsonMap = MAPPER.readValue(response.getEntity().getContent(), MAP_TYPE);	if (jsonMap != null && jsonMap.size() > 0) {	List<Map<String, Object>> items = (List<Map<String, Object>>) jsonMap.get(HipchatApiConstants.API_ITEMS);	if (items != null && items.size() > 0) {	try {	Map<String, Object> item = items.get(0);	String date = (String) item.get(HipchatApiConstants.API_DATE);	String message = (String) item.get(HipchatApiConstants.API_MESSAGE);	
setting exchange body header 

========================= camel sample_11329 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<CinderComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.openstack-cinder.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.openstack-cinder.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1228 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<BeanLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.bean.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.bean.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_898 =========================

if (ObjectHelper.isNotEmpty(endpoint.getUsername()) && ObjectHelper.isNotEmpty(endpoint.getPassword())) {	UsernamePasswordCredentialsProvider credentials = new UsernamePasswordCredentialsProvider(endpoint.getUsername(), endpoint.getPassword());	result = Git.cloneRepository().setCredentialsProvider(credentials).setURI(endpoint.getRemotePath()).setDirectory(new File(endpoint.getLocalPath(), "")).call();	} else {	result = Git.cloneRepository().setURI(endpoint.getRemotePath()).setDirectory(new File(endpoint.getLocalPath(), "")).call();	}	} else {	throw new IllegalArgumentException("The local repository directory already exists");	}	} catch (Exception e) {	
there was an error in git operation 

protected void doInit(Exchange exchange, String operation) throws Exception {	Git result = null;	if (ObjectHelper.isEmpty(endpoint.getLocalPath())) {	throw new IllegalArgumentException("Local path must specified to execute " + operation);	}	try {	result = Git.init().setDirectory(new File(endpoint.getLocalPath(), "")).setBare(false).call();	} catch (Exception e) {	
there was an error in git operation 

fileName = exchange.getIn().getHeader(GitConstants.GIT_FILE_NAME, String.class);	} else {	throw new IllegalArgumentException("File name must be specified to execute " + operation);	}	try {	if (ObjectHelper.isNotEmpty(endpoint.getBranchName())) {	git.checkout().setCreateBranch(false).setName(endpoint.getBranchName()).call();	}	git.add().addFilepattern(fileName).call();	} catch (Exception e) {	
there was an error in git operation 

fileName = exchange.getIn().getHeader(GitConstants.GIT_FILE_NAME, String.class);	} else {	throw new IllegalArgumentException("File name must be specified to execute " + operation);	}	try {	if (ObjectHelper.isNotEmpty(endpoint.getBranchName())) {	git.checkout().setCreateBranch(false).setName(endpoint.getBranchName()).call();	}	git.rm().addFilepattern(fileName).call();	} catch (Exception e) {	
there was an error in git operation 

try {	if (ObjectHelper.isNotEmpty(endpoint.getBranchName())) {	git.checkout().setCreateBranch(false).setName(endpoint.getBranchName()).call();	}	if (ObjectHelper.isNotEmpty(username) && ObjectHelper.isNotEmpty(email)) {	git.commit().setAllowEmpty(allowEmpty).setCommitter(username, email).setMessage(commitMessage).call();	} else {	git.commit().setAllowEmpty(allowEmpty).setMessage(commitMessage).call();	}	} catch (Exception e) {	
there was an error in git operation 

try {	if (ObjectHelper.isNotEmpty(endpoint.getBranchName())) {	git.checkout().setCreateBranch(false).setName(endpoint.getBranchName()).call();	}	if (ObjectHelper.isNotEmpty(username) && ObjectHelper.isNotEmpty(email)) {	git.commit().setAllowEmpty(allowEmpty).setAll(true).setCommitter(username, email).setMessage(commitMessage).call();	} else {	git.commit().setAllowEmpty(allowEmpty).setAll(true).setMessage(commitMessage).call();	}	} catch (Exception e) {	
there was an error in git operation 

protected void doCreateBranch(Exchange exchange, String operation) throws Exception {	if (ObjectHelper.isEmpty(endpoint.getBranchName())) {	throw new IllegalArgumentException("Branch Name must be specified to execute " + operation);	}	try {	git.branchCreate().setName(endpoint.getBranchName()).call();	} catch (Exception e) {	
there was an error in git operation 

protected void doDeleteBranch(Exchange exchange, String operation) throws Exception {	if (ObjectHelper.isEmpty(endpoint.getBranchName())) {	throw new IllegalArgumentException("Branch Name must be specified to execute " + operation);	}	try {	git.branchDelete().setBranchNames(endpoint.getBranchName()).call();	} catch (Exception e) {	
there was an error in git operation 

protected void doStatus(Exchange exchange, String operation) throws Exception {	Status status = null;	try {	if (ObjectHelper.isNotEmpty(endpoint.getBranchName())) {	git.checkout().setCreateBranch(false).setName(endpoint.getBranchName()).call();	}	status = git.status().call();	} catch (Exception e) {	
there was an error in git operation 

if (ObjectHelper.isNotEmpty(endpoint.getBranchName())) {	git.checkout().setCreateBranch(false).setName(endpoint.getBranchName()).call();	}	if (ObjectHelper.isNotEmpty(endpoint.getUsername()) && ObjectHelper.isNotEmpty(endpoint.getPassword())) {	UsernamePasswordCredentialsProvider credentials = new UsernamePasswordCredentialsProvider(endpoint.getUsername(), endpoint.getPassword());	result = git.push().setCredentialsProvider(credentials).setRemote(endpoint.getRemoteName()).call();	} else {	result = git.push().setRemote(endpoint.getRemoteName()).call();	}	} catch (Exception e) {	
there was an error in git operation 

if (ObjectHelper.isNotEmpty(endpoint.getBranchName())) {	git.checkout().setCreateBranch(false).setName(endpoint.getBranchName()).call();	}	if (ObjectHelper.isNotEmpty(endpoint.getUsername()) && ObjectHelper.isNotEmpty(endpoint.getPassword())) {	UsernamePasswordCredentialsProvider credentials = new UsernamePasswordCredentialsProvider(endpoint.getUsername(), endpoint.getPassword());	result = git.pull().setCredentialsProvider(credentials).setRemote(endpoint.getRemoteName()).call();	} else {	result = git.pull().setRemote(endpoint.getRemoteName()).call();	}	} catch (Exception e) {	
there was an error in git operation 

protected void doCreateTag(Exchange exchange, String operation) throws Exception {	if (ObjectHelper.isEmpty(endpoint.getTagName())) {	throw new IllegalArgumentException("Tag Name must be specified to execute " + operation);	}	try {	git.tag().setName(endpoint.getTagName()).call();	} catch (Exception e) {	
there was an error in git operation 

protected void doDeleteTag(Exchange exchange, String operation) throws Exception {	if (ObjectHelper.isEmpty(endpoint.getTagName())) {	throw new IllegalArgumentException("Tag Name must be specified to execute " + operation);	}	try {	git.tagDelete().setTags(endpoint.getTagName()).call();	} catch (Exception e) {	
there was an error in git operation 

protected void doShowBranches(Exchange exchange, String operation) throws Exception {	List<Ref> result = null;	try {	result = git.branchList().setListMode(ListMode.ALL).call();	} catch (Exception e) {	
there was an error in git operation 

}	RevWalk walk = new RevWalk(repo);	ObjectId id = repo.resolve(commitId);	RevCommit commit = walk.parseCommit(id);	walk.dispose();	if (ObjectHelper.isNotEmpty(endpoint.getBranchName())) {	git.checkout().setCreateBranch(false).setName(endpoint.getBranchName()).call();	}	result = git.cherryPick().include(commit).call();	} catch (Exception e) {	
there was an error in git operation 

if (ObjectHelper.isEmpty(endpoint.getRemotePath())) {	throw new IllegalArgumentException("Remote Path must be specified to execute " + operation);	}	RemoteConfig result = null;	try {	RemoteAddCommand remoteAddCommand = git.remoteAdd();	remoteAddCommand.setUri(new URIish(endpoint.getRemotePath()));	remoteAddCommand.setName(endpoint.getRemoteName());	result = remoteAddCommand.call();	} catch (Exception e) {	
there was an error in git operation 

protected void doRemoteList(Exchange exchange, String operation) throws Exception {	List<RemoteConfig> result = null;	try {	result = git.remoteList().call();	} catch (Exception e) {	
there was an error in git operation 

private Repository getLocalRepository() throws IOException {	FileRepositoryBuilder builder = new FileRepositoryBuilder();	Repository repo = null;	try {	repo = builder.setGitDir(new File(endpoint.getLocalPath(), ".git")).readEnvironment() .findGitDir() .build();	} catch (IOException e) {	
there was an error cannot open repository 

========================= camel sample_9136 =========================

public synchronized RepositoryCommit addRepositoryCommit() {	User author = new User();	author.setEmail("someguy@gmail.com");	author.setHtmlUrl("http: author.setLogin("someguy");	RepositoryCommit rc = new RepositoryCommit();	rc.setAuthor(author);	rc.setSha(fakeSha.incrementAndGet() + "");	
in mockcommitservice added commit with sha 

public synchronized List<RepositoryCommit> getCommits(IRepositoryIdProvider repository, String sha, String path) throws IOException {	
returning list of size 

========================= camel sample_14255 =========================

public void validateConfiguration() {	for (ChannelHandler encoder : encoders) {	if (encoder instanceof ChannelHandlerFactory) {	continue;	}	if (ObjectHelper.getAnnotation(encoder, ChannelHandler.Sharable.class) != null) {	continue;	}	
the encoder is not shareable or an channelhandlerfactory instance the encoder cannot safely be used 

continue;	}	}	for (ChannelHandler decoder : decoders) {	if (decoder instanceof ChannelHandlerFactory) {	continue;	}	if (ObjectHelper.getAnnotation(decoder, ChannelHandler.Sharable.class) != null) {	continue;	}	
the decoder is not shareable or an channelhandlerfactory instance the decoder cannot safely be used 

continue;	}	if (ObjectHelper.getAnnotation(decoder, ChannelHandler.Sharable.class) != null) {	continue;	}	}	if (sslHandler != null) {	boolean factory = sslHandler instanceof ChannelHandlerFactory;	boolean shareable = ObjectHelper.getAnnotation(sslHandler, ChannelHandler.Sharable.class) != null;	if (!factory && !shareable) {	
the sslhandler is not shareable or an channelhandlerfactory instance the sslhandler cannot safely be used 

}	if (encoders.isEmpty() && decoders.isEmpty()) {	if (isAllowDefaultCodec()) {	if (isTextline()) {	Charset charset = getEncoding() != null ? Charset.forName(getEncoding()) : CharsetUtil.UTF_8;	encoders.add(ChannelHandlerFactories.newStringEncoder(charset));	ChannelBuffer[] delimiters = delimiter == TextLineDelimiter.LINE ? Delimiters.lineDelimiter() : Delimiters.nulDelimiter();	decoders.add(ChannelHandlerFactories.newDelimiterBasedFrameDecoder(decoderMaxLineLength, delimiters));	decoders.add(ChannelHandlerFactories.newStringDecoder(charset));	if (LOG.isDebugEnabled()) {	
using textline encoders and decoders with charset delimiter and decodermaxlinelength 

Charset charset = getEncoding() != null ? Charset.forName(getEncoding()) : CharsetUtil.UTF_8;	encoders.add(ChannelHandlerFactories.newStringEncoder(charset));	ChannelBuffer[] delimiters = delimiter == TextLineDelimiter.LINE ? Delimiters.lineDelimiter() : Delimiters.nulDelimiter();	decoders.add(ChannelHandlerFactories.newDelimiterBasedFrameDecoder(decoderMaxLineLength, delimiters));	decoders.add(ChannelHandlerFactories.newStringDecoder(charset));	if (LOG.isDebugEnabled()) {	}	} else {	encoders.add(ChannelHandlerFactories.newObjectEncoder());	decoders.add(ChannelHandlerFactories.newObjectDecoder());	
using object encoders and decoders 

ChannelBuffer[] delimiters = delimiter == TextLineDelimiter.LINE ? Delimiters.lineDelimiter() : Delimiters.nulDelimiter();	decoders.add(ChannelHandlerFactories.newDelimiterBasedFrameDecoder(decoderMaxLineLength, delimiters));	decoders.add(ChannelHandlerFactories.newStringDecoder(charset));	if (LOG.isDebugEnabled()) {	}	} else {	encoders.add(ChannelHandlerFactories.newObjectEncoder());	decoders.add(ChannelHandlerFactories.newObjectDecoder());	}	} else {	
no encoders and decoders will be used 

decoders.add(ChannelHandlerFactories.newStringDecoder(charset));	if (LOG.isDebugEnabled()) {	}	} else {	encoders.add(ChannelHandlerFactories.newObjectEncoder());	decoders.add(ChannelHandlerFactories.newObjectDecoder());	}	} else {	}	} else {	
using configured encoders and or decoders 

========================= camel sample_6693 =========================

public static InputStream resolveResourceAsInputStream(ClassResolver classResolver, String uri) throws IOException {	if (uri.startsWith("file:")) {	uri = ObjectHelper.after(uri, "file:");	uri = tryDecodeUri(uri);	
loading resource from file system 

public static InputStream resolveResourceAsInputStream(ClassResolver classResolver, String uri) throws IOException {	if (uri.startsWith("file:")) {	uri = ObjectHelper.after(uri, "file:");	uri = tryDecodeUri(uri);	return new FileInputStream(uri);	} else if (uri.startsWith("http:")) {	URL url = new URL(uri);	
loading resource from http 

} catch (IOException e) {	if (con instanceof HttpURLConnection) {	((HttpURLConnection) con).disconnect();	}	throw e;	}	} else if (uri.startsWith("classpath:")) {	uri = ObjectHelper.after(uri, "classpath:");	uri = tryDecodeUri(uri);	} else if (uri.contains(":")) {	
loading resource with urlhandler for protocol 

}	} else if (uri.startsWith("classpath:")) {	uri = ObjectHelper.after(uri, "classpath:");	uri = tryDecodeUri(uri);	} else if (uri.contains(":")) {	URL url = new URL(uri);	URLConnection con = url.openConnection();	return con.getInputStream();	}	String resolvedName = resolveUriPath(uri);	
loading resource from classpath 

public static URL resolveResourceAsUrl(ClassResolver classResolver, String uri) throws MalformedURLException {	if (uri.startsWith("file:")) {	String name = ObjectHelper.after(uri, "file:");	uri = tryDecodeUri(uri);	
loading resource from file system 

public static URL resolveResourceAsUrl(ClassResolver classResolver, String uri) throws MalformedURLException {	if (uri.startsWith("file:")) {	String name = ObjectHelper.after(uri, "file:");	uri = tryDecodeUri(uri);	File file = new File(name);	if (!file.exists()) {	return null;	}	return new URL(uri);	} else if (uri.startsWith("http:")) {	
loading resource from http 

if (!file.exists()) {	return null;	}	return new URL(uri);	} else if (uri.startsWith("http:")) {	return new URL(uri);	} else if (uri.startsWith("classpath:")) {	uri = ObjectHelper.after(uri, "classpath:");	uri = tryDecodeUri(uri);	} else if (uri.contains(":")) {	
loading resource with urlhandler for protocol 

return new URL(uri);	} else if (uri.startsWith("http:")) {	return new URL(uri);	} else if (uri.startsWith("classpath:")) {	uri = ObjectHelper.after(uri, "classpath:");	uri = tryDecodeUri(uri);	} else if (uri.contains(":")) {	return new URL(uri);	}	String resolvedName = resolveUriPath(uri);	
loading resource from classpath 

private static String tryDecodeUri(String uri) {	try {	uri = URLDecoder.decode(uri, "UTF-8");	} catch (Exception e) {	
error url decoding uri using utf encoding this exception is ignored 

========================= camel sample_4354 =========================

int nummsg = 1000;	MockEndpoint resultEndpoint = context.getEndpoint("mock:mymock", MockEndpoint.class);	resultEndpoint.expectedMessageCount(nummsg);	long start = System.currentTimeMillis();	producer.start();	for (int i = 0; i < nummsg; ++i) {	producer.process(exchange);	}	resultEndpoint.assertIsSatisfied();	long stop = System.currentTimeMillis();	
took milliseconds 

========================= camel sample_15014 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<JpaComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jpa.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.jpa.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_461 =========================

public void testRestartAppChangeCronExpression() throws Exception {	app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz/SpringQuartzPersistentStoreRestartAppChangeCronExpressionTest1.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	String cronExpression = ((CronTrigger) getTrigger(camel, "quartzRoute")).getCronExpression();	app.stop();	
restarting 

public void testRestartAppChangeCronExpression() throws Exception {	app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz/SpringQuartzPersistentStoreRestartAppChangeCronExpressionTest1.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	String cronExpression = ((CronTrigger) getTrigger(camel, "quartzRoute")).getCronExpression();	app.stop();	
restarting 

public void testRestartAppChangeCronExpression() throws Exception {	app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz/SpringQuartzPersistentStoreRestartAppChangeCronExpressionTest1.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	String cronExpression = ((CronTrigger) getTrigger(camel, "quartzRoute")).getCronExpression();	app.stop();	
restarting 

public void testRestartAppChangeTriggerOptions() throws Exception {	AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz/SpringQuartzPersistentStoreRestartAppChangeOptionsTest1.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	SimpleTrigger trigger = (SimpleTrigger) getTrigger(camel, "quartzRoute");	long repeatInterval = trigger.getRepeatInterval();	app.stop();	
restarting 

public void testRestartAppChangeTriggerOptions() throws Exception {	AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz/SpringQuartzPersistentStoreRestartAppChangeOptionsTest1.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	SimpleTrigger trigger = (SimpleTrigger) getTrigger(camel, "quartzRoute");	long repeatInterval = trigger.getRepeatInterval();	app.stop();	
restarting 

public void testRestartAppChangeTriggerOptions() throws Exception {	AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz/SpringQuartzPersistentStoreRestartAppChangeOptionsTest1.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	SimpleTrigger trigger = (SimpleTrigger) getTrigger(camel, "quartzRoute");	long repeatInterval = trigger.getRepeatInterval();	app.stop();	
restarting 

public void testRestartAppChangeTriggerType() throws Exception {	app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz/SpringQuartzPersistentStoreRestartAppChangeCronExpressionTest1.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	assertTrue(getTrigger(camel, "quartzRoute") instanceof CronTrigger);	app.stop();	
restarting 

public void testRestartAppChangeTriggerType() throws Exception {	app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz/SpringQuartzPersistentStoreRestartAppChangeCronExpressionTest1.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	assertTrue(getTrigger(camel, "quartzRoute") instanceof CronTrigger);	app.stop();	
restarting 

public void testRestartAppChangeTriggerType() throws Exception {	app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz/SpringQuartzPersistentStoreRestartAppChangeCronExpressionTest1.xml");	app.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	assertNotNull(camel);	assertTrue(getTrigger(camel, "quartzRoute") instanceof CronTrigger);	app.stop();	
restarting 

========================= camel sample_17183 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<HessianDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.hessian.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.hessian.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_524 =========================

public Processor wrapProcessorInInterceptors(CamelContext camelContext, ProcessorDefinition<?> processorDefinition, Processor target, Processor nextTarget) throws Exception {	String defName = processorDefinition.getShortName();	return new DelegateAsyncProcessor((Exchange exchange) -> {	
creating new subsegment for eip 

public Processor wrapProcessorInInterceptors(CamelContext camelContext, ProcessorDefinition<?> processorDefinition, Processor target, Processor nextTarget) throws Exception {	String defName = processorDefinition.getShortName();	return new DelegateAsyncProcessor((Exchange exchange) -> {	Subsegment subsegment = AWSXRay.beginSubsegment(sanitizeName(defName));	try {	
processing eip 

public Processor wrapProcessorInInterceptors(CamelContext camelContext, ProcessorDefinition<?> processorDefinition, Processor target, Processor nextTarget) throws Exception {	String defName = processorDefinition.getShortName();	return new DelegateAsyncProcessor((Exchange exchange) -> {	Subsegment subsegment = AWSXRay.beginSubsegment(sanitizeName(defName));	try {	target.process(exchange);	} catch (Exception ex) {	
handling exception thrown by invoked eip 

public Processor wrapProcessorInInterceptors(CamelContext camelContext, ProcessorDefinition<?> processorDefinition, Processor target, Processor nextTarget) throws Exception {	String defName = processorDefinition.getShortName();	return new DelegateAsyncProcessor((Exchange exchange) -> {	Subsegment subsegment = AWSXRay.beginSubsegment(sanitizeName(defName));	try {	target.process(exchange);	} catch (Exception ex) {	subsegment.addException(ex);	throw ex;	} finally {	
closing down subsegment for 

========================= camel sample_8232 =========================

public boolean rollback(Consumer consumer, Endpoint endpoint, int retryCounter, Exception e) throws Exception {	if (e.getCause() instanceof FacebookException) {	FacebookException facebookException = (FacebookException) e.getCause();	if (facebookException.getErrorCode() == 11 || facebookException.getErrorCode() == 12 || facebookException.getErrorCode() == 1) {	context().stopRoute(route.getId());	String method = ((FacebookEndpoint) route.getEndpoint()).getMethod();	MockEndpoint mock = getMockEndpoint("mock:consumeQueryResult" + method);	mock.expectedMinimumMessageCount(0);	MockEndpoint mock2 = getMockEndpoint("mock:consumeResult" + method);	mock2.expectedMinimumMessageCount(0);	
ignoring failed facebook deprecated api call 

========================= camel sample_9589 =========================

public void process(Exchange exchange) throws Exception {	MqttClient client = getEndpoint().getClient();	String topic = exchange.getIn().getHeader(PahoConstants.CAMEL_PAHO_OVERRIDE_TOPIC, getEndpoint().getTopic(), String.class);	int qos = exchange.getIn().getHeader(PahoConstants.CAMEL_PAHO_MSG_QOS, getEndpoint().getQos(), Integer.class);	boolean retained = exchange.getIn().getHeader(PahoConstants.CAMEL_PAHO_MSG_RETAINED, getEndpoint().isRetained(), Boolean.class);	byte[] payload = exchange.getIn().getBody(byte[].class);	MqttMessage message = new MqttMessage(payload);	message.setQos(qos);	message.setRetained(retained);	
publishing to topic qos retrained 

========================= camel sample_9073 =========================

public SmppConsumer(SmppEndpoint endpoint, SmppConfiguration config, Processor processor) {	super(endpoint, processor);	this.configuration = config;	this.internalSessionStateListener = new SessionStateListener() {	public void onStateChange(SessionState newState, SessionState oldState, Session source) {	if (configuration.getSessionStateListener() != null) {	configuration.getSessionStateListener().onStateChange(newState, oldState, source);	}	if (newState.equals(SessionState.CLOSED)) {	
lost connection to trying to reconnect 

protected void doStart() throws Exception {	
connecting to 

protected void doStart() throws Exception {	super.doStart();	session = createSession();	
connected to 

protected void doStop() throws Exception {	
disconnecting from 

protected void doStop() throws Exception {	super.doStop();	closeSession();	
disconnected from 

private void reconnect(final long initialReconnectDelay) {	if (reconnectLock.tryLock()) {	try {	Runnable r = new Runnable() {	public void run() {	boolean reconnected = false;	
schedule reconnect after millis 

public void run() {	boolean reconnected = false;	try {	Thread.sleep(initialReconnectDelay);	} catch (InterruptedException e) {	}	int attempt = 0;	while (!(isStopping() || isStopped()) && (session == null || session.getSessionState().equals(SessionState.CLOSED)) && attempt < configuration.getMaxReconnect()) {	try {	attempt++;	
trying to reconnect to attempt 

Thread.sleep(initialReconnectDelay);	} catch (InterruptedException e) {	}	int attempt = 0;	while (!(isStopping() || isStopped()) && (session == null || session.getSessionState().equals(SessionState.CLOSED)) && attempt < configuration.getMaxReconnect()) {	try {	attempt++;	session = createSession();	reconnected = true;	} catch (IOException e) {	
failed to reconnect to 

reconnected = true;	} catch (IOException e) {	closeSession();	try {	Thread.sleep(configuration.getReconnectDelay());	} catch (InterruptedException ee) {	}	}	}	if (reconnected) {	
reconnected to 

========================= camel sample_16907 =========================

protected void doStart() throws Exception {	super.doStart();	
starting google pubsub consumer for 

protected void doStop() throws Exception {	super.doStop();	
stopping google pubsub consumer for 

public void run() {	if (localLog.isDebugEnabled()) {	
subscribing to 

public void run() {	if (localLog.isDebugEnabled()) {	}	while (isRunAllowed() && !isSuspendingOrSuspended()) {	try {	PullRequest pullRequest = new PullRequest().setMaxMessages(endpoint.getMaxMessagesPerPoll());	PullResponse pullResponse;	try {	if (localLog.isTraceEnabled()) {	
polling 

while (isRunAllowed() && !isSuspendingOrSuspended()) {	try {	PullRequest pullRequest = new PullRequest().setMaxMessages(endpoint.getMaxMessagesPerPoll());	PullResponse pullResponse;	try {	if (localLog.isTraceEnabled()) {	}	pullResponse = GooglePubsubConsumer.this.pubsub .projects() .subscriptions() .pull(subscriptionFullName, pullRequest) .execute();	} catch (SocketTimeoutException ste) {	if (localLog.isTraceEnabled()) {	
socket timeout 

continue;	}	if (null == pullResponse.getReceivedMessages()) {	continue;	}	List<ReceivedMessage> receivedMessages = pullResponse.getReceivedMessages();	for (ReceivedMessage receivedMessage : receivedMessages) {	PubsubMessage pubsubMessage = receivedMessage.getMessage();	byte[] body = pubsubMessage.decodeData();	if (localLog.isTraceEnabled()) {	
received message id 

if (endpoint.getAckMode() != GooglePubsubConstants.AckMode.NONE) {	exchange.addOnCompletion(GooglePubsubConsumer.this.ackStrategy);	}	try {	processor.process(exchange);	} catch (Throwable e) {	exchange.setException(e);	}	}	} catch (Exception e) {	
failure getting messages from pubsub 

========================= camel sample_17245 =========================

public void prepareTestInstance(TestContext testContext) throws Exception {	
runwith camelspringbootrunner class preparing 

public void beforeTestMethod(TestContext testContext) throws Exception {	
runwith camelspringbootrunner class before 

public void beforeTestMethod(TestContext testContext) throws Exception {	Class<?> testClass = testContext.getTestClass();	String testName = testContext.getTestMethod().getName();	ConfigurableApplicationContext context = (ConfigurableApplicationContext) testContext.getApplicationContext();	System.clearProperty("skipStartingCamelContext");	CamelAnnotationsHandler.handleRouteCoverage(context, testClass, s -> testName);	
initialized camelspringbootrunner now ready to start camelcontext 

========================= camel sample_10580 =========================

public void testSendReceiveTraps() throws Exception {	PDU trap = new PDU();	trap.setType(PDU.TRAP);	OID oid = new OID("1.2.3.4.5");	trap.add(new VariableBinding(SnmpConstants.snmpTrapOID, oid));	trap.add(new VariableBinding(SnmpConstants.sysUpTime, new TimeTicks(5000)));	trap.add(new VariableBinding(SnmpConstants.sysDescr, new OctetString("System Description")));	Variable var = new OctetString("some string");	trap.add(new VariableBinding(oid, var));	
sending pdu 

Thread.sleep(1000);	}	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(1);	mock.assertIsSatisfied();	List<Exchange> exchanges = mock.getExchanges();	SnmpMessage msg = (SnmpMessage) exchanges.get(0).getIn();	PDU receivedTrap = msg.getSnmpMessage();	Assert.assertEquals(trap, receivedTrap);	if (LOG.isInfoEnabled()) {	
received snmp trap 

========================= camel sample_8818 =========================

public String prepareQuery(String query, boolean allowNamedParameters) throws SQLException {	String answer;	if (allowNamedParameters && hasNamedParameters(query)) {	answer = query.replaceAll("\\:\\?\\w+", "\\?");	} else {	answer = query;	}	
prepared query 

public void populateStatement(PreparedStatement ps, Iterator<?> iterator, int expectedParams) throws SQLException {	int argNumber = 1;	if (expectedParams > 0) {	while (iterator != null && iterator.hasNext() && argNumber <= expectedParams) {	Object value = iterator.next();	
setting parameter with value 

========================= camel sample_14039 =========================

protected byte[] readSchemaResource() throws IOException {	
reading schema resource 

========================= camel sample_4568 =========================

public void process(Exchange exchange) {	
called with exchange 

========================= camel sample_3757 =========================

public boolean rollback(Consumer consumer, Endpoint endpoint, int retryCounter, Exception cause) throws Exception {	Integer times = state.get(consumer);	if (times == null) {	times = 1;	} else {	times += 1;	}	
rollback occurred after times when consuming 

protected void onSuspend(Consumer consumer, Endpoint endpoint) throws Exception {	
suspending consumer after attempts to consume from you have to manually resume the consumer 

========================= camel sample_4092 =========================

applicationContext = createApplicationContext();	threadAppContext.set(applicationContext);	}	} else {	applicationContext = createApplicationContext();	}	assertNotNull(applicationContext, "Should have created a valid spring context");	SpringCamelContext.setNoStart(false);	}	} else {	
skipping starting camelcontext as system property skipstartingcamelcontext is set to be true 

========================= camel sample_11684 =========================

public ModelMBeanInfo getMBeanInfo(Object defaultManagedBean, Object customManagedBean, String objectName) throws JMException {	if (defaultManagedBean != null && Proxy.isProxyClass(defaultManagedBean.getClass())) {	
skip creating modelmbeaninfo due proxy class 

extractMbeanAttributes(customManagedBean, attributes, mBeanAttributes, mBeanOperations);	extractMbeanOperations(customManagedBean, operations, mBeanOperations);	extractMbeanNotifications(customManagedBean, mBeanNotifications);	}	String name = getName(customManagedBean != null ? customManagedBean : defaultManagedBean, objectName);	String description = getDescription(customManagedBean != null ? customManagedBean : defaultManagedBean, objectName);	ModelMBeanAttributeInfo[] arrayAttributes = mBeanAttributes.toArray(new ModelMBeanAttributeInfo[mBeanAttributes.size()]);	ModelMBeanOperationInfo[] arrayOperations = mBeanOperations.toArray(new ModelMBeanOperationInfo[mBeanOperations.size()]);	ModelMBeanNotificationInfo[] arrayNotifications = mBeanNotifications.toArray(new ModelMBeanNotificationInfo[mBeanNotifications.size()]);	ModelMBeanInfo info = new ModelMBeanInfoSupport(name, description, arrayAttributes, null, arrayOperations, arrayNotifications);	
created modelmbeaninfo 

private void doExtractAttributesAndOperations(Class<?> managedClass, Map<String, ManagedAttributeInfo> attributes, Set<ManagedOperationInfo> operations) {	doDoExtractAttributesAndOperations(managedClass, attributes, operations);	if (managedClass.getSuperclass() != null) {	Class<?> clazz = managedClass.getSuperclass();	if (!clazz.getName().startsWith("java")) {	
extracting attributes and operations from sub class 

Class<?> clazz = managedClass.getSuperclass();	if (!clazz.getName().startsWith("java")) {	doExtractAttributesAndOperations(clazz, attributes, operations);	}	}	if (managedClass.getInterfaces() != null) {	for (Class<?> clazz : managedClass.getInterfaces()) {	if (clazz.getName().startsWith("java")) {	continue;	}	
extracting attributes and operations from implemented interface 

private void doDoExtractAttributesAndOperations(Class<?> managedClass, Map<String, ManagedAttributeInfo> attributes, Set<ManagedOperationInfo> operations) {	
extracting attributes and operations from class 

private void doDoExtractAttributesAndOperations(Class<?> managedClass, Map<String, ManagedAttributeInfo> attributes, Set<ManagedOperationInfo> operations) {	IntrospectionSupport.ClassInfo cache = IntrospectionSupport.cacheClass(managedClass);	for (IntrospectionSupport.MethodInfo cacheInfo : cache.methods) {	if (cacheInfo.method.getDeclaringClass() != managedClass) {	continue;	}	
extracting attributes and operations from method 

mbeanOperation.setDescriptor(opDesc);	mBeanOperations.add(mbeanOperation);	}	if (info.getSetter() != null) {	desc.setField("setMethod", info.getSetter().getName());	ModelMBeanOperationInfo mbeanOperation = new ModelMBeanOperationInfo(info.getKey(), info.getSetter());	mBeanOperations.add(mbeanOperation);	}	mbeanAttribute.setDescriptor(desc);	mBeanAttributes.add(mbeanAttribute);	
assembled attribute 

private void extractMbeanOperations(Object managedBean, Set<ManagedOperationInfo> operations, Set<ModelMBeanOperationInfo> mBeanOperations) {	for (ManagedOperationInfo info : operations) {	ModelMBeanOperationInfo mbean = new ModelMBeanOperationInfo(info.getDescription(), info.getOperation());	Descriptor opDesc = mbean.getDescriptor();	opDesc.setField("mask", info.isMask() ? "true" : "false");	mbean.setDescriptor(opDesc);	mBeanOperations.add(mbean);	
assembled operation 

private void extractMbeanNotifications(Object managedBean, Set<ModelMBeanNotificationInfo> mBeanNotifications) {	ManagedNotifications notifications = managedBean.getClass().getAnnotation(ManagedNotifications.class);	if (notifications != null) {	for (ManagedNotification notification : notifications.value()) {	ModelMBeanNotificationInfo info = new ModelMBeanNotificationInfo(notification.notificationTypes(), notification.name(), notification.description());	mBeanNotifications.add(info);	
assembled notification 

========================= camel sample_4587 =========================

private void testIteration(int i) throws Exception {	MockEndpoint me = context.getEndpoint("mock:result", MockEndpoint.class);	me.reset();	me.expectedMessageCount(4);	
run 

template.sendBody("direct:start", "4");	template.sendBody("direct:start", "1");	template.sendBody("direct:start", "3");	template.sendBody("direct:start", "2");	assertMockEndpointsSatisfied();	String a = me.getExchanges().get(0).getIn().getBody(String.class);	String b = me.getExchanges().get(1).getIn().getBody(String.class);	String c = me.getExchanges().get(2).getIn().getBody(String.class);	String d = me.getExchanges().get(3).getIn().getBody(String.class);	String line = a + b + c + d;	
order 

========================= camel sample_1785 =========================

public void onNewArtifacts(Set<NexusArtifactDto> newArtifacts) {	for (NexusArtifactDto dto : newArtifacts) {	try {	
processing new artifact 

public void onNewArtifacts(Set<NexusArtifactDto> newArtifacts) {	for (NexusArtifactDto dto : newArtifacts) {	try {	String url = createArtifactURL(dto);	URL jarUrl = new URL(url);	addCustomCamelConnectorFromArtifact(dto, jarUrl);	} catch (Throwable e) {	
error downloading connector jar this exception is ignored 

protected void addConnector(NexusArtifactDto dto, String name, String scheme, String javaType, String description, String labels, String connectorJson, String connectorSchemaJson, String componentSchemaJson) {	String groupId = dto.getGroupId();	String artifactId = dto.getArtifactId();	String version = dto.getVersion();	camelConnectorCatalog.addConnector(groupId, artifactId, version, name, scheme, javaType, description, labels, connectorJson, connectorSchemaJson, componentSchemaJson);	
added connector 

String description = tree.get("description").textValue();	Iterator<JsonNode> it = tree.withArray("labels").iterator();	CollectionStringBuffer csb = new CollectionStringBuffer(",");	while (it.hasNext()) {	String text = it.next().textValue();	csb.append(text);	}	addConnector(dto, name, scheme, javaType, description, csb.toString(), json[0], json[1], json[2]);	}	} catch (IOException e) {	
error scanning jar for custom camel components 

private String[] loadConnectorJSonSchema(ClassLoader classLoader) {	String[] answer = new String[3];	String path = "camel-connector.json";	try {	InputStream is = classLoader.getResourceAsStream(path);	if (is != null) {	answer[0] = loadText(is);	}	} catch (Throwable e) {	
error loading file 

} catch (Throwable e) {	return null;	}	path = "camel-connector-schema.json";	try {	InputStream is = classLoader.getResourceAsStream(path);	if (is != null) {	answer[1] = loadText(is);	}	} catch (Throwable e) {	
error loading file 

} catch (Throwable e) {	return null;	}	path = "camel-component-schema.json";	try {	InputStream is = classLoader.getResourceAsStream(path);	if (is != null) {	answer[2] = loadText(is);	}	} catch (Throwable e) {	
error loading file 

========================= camel sample_318 =========================

public void startListenerContainer() {	
starting listener container on destination 

public void startListenerContainer() {	listenerContainer.start();	
started listener container on destination 

protected void testConnectionOnStartup() throws FailedToCreateConsumerException {	try {	
testing jms connection on startup for destination 

protected void testConnectionOnStartup() throws FailedToCreateConsumerException {	try {	Connection con = listenerContainer.getConnectionFactory().createConnection();	JmsUtils.closeConnection(con);	
successfully tested jms connection on startup for destination 

if (listenerContainer == null) {	createMessageListenerContainer();	}	getEndpoint().onListenerContainerStarting(listenerContainer);	if (getEndpoint().getConfiguration().isAsyncStartListener()) {	getEndpoint().getAsyncStartStopExecutorService().submit(new Runnable() {	public void run() {	try {	prepareAndStartListenerContainer();	} catch (Throwable e) {	
error starting listener container on destination this exception will be ignored 

protected void doStop() throws Exception {	if (listenerContainer != null) {	if (getEndpoint().getConfiguration().isAsyncStopListener()) {	getEndpoint().getAsyncStartStopExecutorService().submit(new Runnable() {	public void run() {	try {	stopAndDestroyListenerContainer();	} catch (Throwable e) {	
error stopping listener container on destination this exception will be ignored 

protected void doResume() throws Exception {	if (!initialized) {	doStart();	} else {	if (listenerContainer != null) {	startListenerContainer();	} else {	
the listenercontainer is not instantiated probably there was a timeout during the suspend operation please restart your consumer route 

========================= camel sample_7201 =========================

public void process(Exchange exchange) throws Exception {	
processing exchange in camel 

public void process(Exchange exchange) throws Exception {	BindingOperationInfo boi = (BindingOperationInfo)exchange.getProperty(BindingOperationInfo.class.getName());	if (boi != null) {	
boi isunwrapped 

public void process(Exchange exchange) throws Exception {	BindingOperationInfo boi = (BindingOperationInfo)exchange.getProperty(BindingOperationInfo.class.getName());	if (boi != null) {	}	MessageContentsList msgList = (MessageContentsList)exchange.getIn().getBody();	Holder<String> personId = (Holder<String>)msgList.get(0);	Holder<String> ssn = (Holder<String>)msgList.get(1);	Holder<String> name = (Holder<String>)msgList.get(2);	if (personId.value == null || personId.value.length() == 0) {	
person id so throwing exception 

if (personId.value == null || personId.value.length() == 0) {	org.apache.camel.wsdl_first.types.UnknownPersonFault personFault = new org.apache.camel.wsdl_first.types.UnknownPersonFault();	personFault.setPersonId("");	org.apache.camel.wsdl_first.UnknownPersonFault fault = new org.apache.camel.wsdl_first.UnknownPersonFault("Get the null value of person name", personFault);	exchange.getOut().setFault(true);	exchange.getOut().setBody(fault);	return;	}	name.value = "Bonjour";	ssn.value = "123";	
setting bonjour as the response 

========================= camel sample_7715 =========================

protected void debugBefore(Exchange exchange, Processor processor, ProcessorDefinition<?> definition, String id, String shortName) {	
before with body 

========================= camel sample_6807 =========================

private Charset getCharsetForMessage(Message message) {	if (message.getHeaders().containsKey(SmppConstants.ENCODING)) {	String encoding = message.getHeader(SmppConstants.ENCODING, String.class);	if (Charset.isSupported(encoding)) {	return Charset.forName(encoding);	} else {	
unsupported encoding requested in header 

========================= camel sample_16906 =========================

public ApplicationContext loadContext(MergedContextConfiguration mergedConfig) throws Exception {	Class<?> testClass = getTestClass();	if (logger.isDebugEnabled()) {	
loading applicationcontext for merged context configuration 

========================= camel sample_10581 =========================

public boolean unregister(String messageName) {	if (!StringUtils.isEmpty(messageName)) {	if (consumerRegistry.remove(messageName) == null) {	
consumer with message name was already unregistered 

========================= camel sample_13657 =========================

List<RouteStartupOrder> routesOrdered = new ArrayList<RouteStartupOrder>(routes);	routesOrdered.sort(new Comparator<RouteStartupOrder>() {	public int compare(RouteStartupOrder o1, RouteStartupOrder o2) {	return o1.getStartupOrder() - o2.getStartupOrder();	}	});	if (shutdownRoutesInReverseOrder) {	Collections.reverse(routesOrdered);	}	if (suspendOnly) {	
starting to graceful suspend routes timeout 

routesOrdered.sort(new Comparator<RouteStartupOrder>() {	public int compare(RouteStartupOrder o1, RouteStartupOrder o2) {	return o1.getStartupOrder() - o2.getStartupOrder();	}	});	if (shutdownRoutesInReverseOrder) {	Collections.reverse(routesOrdered);	}	if (suspendOnly) {	} else {	
starting to graceful shutdown routes timeout 

currentShutdownTaskFuture = getExecutorService().submit(new ShutdownTask(context, routesOrdered, timeout, timeUnit, suspendOnly, abortAfterTimeout, timeoutOccurred, isLogInflightExchangesOnTimeout()));	try {	currentShutdownTaskFuture.get(timeout, timeUnit);	} catch (ExecutionException e) {	throw ObjectHelper.wrapRuntimeCamelException(e.getCause());	} catch (Exception e) {	timeoutOccurred.set(true);	currentShutdownTaskFuture.cancel(true);	this.forceShutdown = forceShutdown;	if (!forceShutdown && abortAfterTimeout) {	
timeout occurred during graceful shutdown aborting the shutdown now notice some resources may still be running as graceful shutdown did not complete successfully 

throw ObjectHelper.wrapRuntimeCamelException(e.getCause());	} catch (Exception e) {	timeoutOccurred.set(true);	currentShutdownTaskFuture.cancel(true);	this.forceShutdown = forceShutdown;	if (!forceShutdown && abortAfterTimeout) {	logInflightExchanges(context, routes, isLogInflightExchangesOnTimeout());	return false;	} else {	if (forceShutdown || shutdownNowOnTimeout) {	
timeout occurred during graceful shutdown forcing the routes to be shutdown now notice some resources may still be running as graceful shutdown did not complete successfully 

} else {	if (forceShutdown || shutdownNowOnTimeout) {	logInflightExchanges(context, routes, isLogInflightExchangesOnTimeout());	shutdownRoutesNow(routesOrdered);	for (RouteStartupOrder order : routes) {	for (Service service : order.getServices()) {	prepareShutdown(service, false, true, true, isSuppressLoggingOnTimeout());	}	}	} else {	
timeout occurred during graceful shutdown will ignore shutting down the remainder routes notice some resources may still be running as graceful shutdown did not complete successfully 

}	}	} else {	logInflightExchanges(context, routes, isLogInflightExchangesOnTimeout());	}	}	} finally {	currentShutdownTaskFuture = null;	}	long seconds = TimeUnit.SECONDS.convert(watch.taken(), TimeUnit.MILLISECONDS);	
graceful shutdown of routes completed in seconds 

protected void shutdownRoutesNow(List<RouteStartupOrder> routes) {	for (RouteStartupOrder order : routes) {	ShutdownRunningTask current = order.getRoute().getRouteContext().getShutdownRunningTask();	if (current != ShutdownRunningTask.CompleteCurrentTaskOnly) {	
changing shutdownrunningtask from to on route to shutdown faster 

protected static void shutdownNow(Consumer consumer) {	
shutting down 

protected static void shutdownNow(Consumer consumer) {	try {	ServiceHelper.stopService(consumer);	} catch (Throwable e) {	
error occurred while shutting down route this exception will be ignored 

protected static void shutdownNow(Consumer consumer) {	try {	ServiceHelper.stopService(consumer);	} catch (Throwable e) {	EventHelper.notifyServiceStopFailure(consumer.getEndpoint().getCamelContext(), consumer, e);	}	
shutdown complete for 

protected static void suspendNow(Consumer consumer) {	
suspending 

protected static void suspendNow(Consumer consumer) {	try {	ServiceHelper.suspendService(consumer);	} catch (Throwable e) {	
error occurred while suspending route this exception will be ignored 

protected static void suspendNow(Consumer consumer) {	try {	ServiceHelper.suspendService(consumer);	} catch (Throwable e) {	EventHelper.notifyServiceStopFailure(consumer.getEndpoint().getCamelContext(), consumer, e);	}	
suspend complete for 

public void run() {	
there are routes to suspend shutdown 

public void run() {	List<ShutdownDeferredConsumer> deferredConsumers = new ArrayList<ShutdownDeferredConsumer>();	for (RouteStartupOrder order : routes) {	ShutdownRoute shutdownRoute = order.getRoute().getRouteContext().getShutdownRoute();	ShutdownRunningTask shutdownRunningTask = order.getRoute().getRouteContext().getShutdownRunningTask();	if (LOG.isTraceEnabled()) {	
with options suspending route shutting down route 

if (consumer instanceof ShutdownAware) {	shutdown = !((ShutdownAware) consumer).deferShutdown(shutdownRunningTask);	}	if (shutdown && consumer instanceof Suspendable) {	suspend = true;	}	}	if (suspend) {	suspendNow(consumer);	deferredConsumers.add(new ShutdownDeferredConsumer(order.getRoute(), consumer));	
route suspended and shutdown deferred was consuming from 

}	if (shutdown && consumer instanceof Suspendable) {	suspend = true;	}	}	if (suspend) {	suspendNow(consumer);	deferredConsumers.add(new ShutdownDeferredConsumer(order.getRoute(), consumer));	} else if (shutdown) {	shutdownNow(consumer);	
route shutdown complete was consuming from 

suspend = true;	}	}	if (suspend) {	suspendNow(consumer);	deferredConsumers.add(new ShutdownDeferredConsumer(order.getRoute(), consumer));	} else if (shutdown) {	shutdownNow(consumer);	} else {	deferredConsumers.add(new ShutdownDeferredConsumer(order.getRoute(), consumer));	
route shutdown deferred suspension deferred 

while (!done && !timeoutOccurred.get()) {	int size = 0;	final Map<String, Integer> routeInflight = new LinkedHashMap<String, Integer>();	for (RouteStartupOrder order : routes) {	int inflight = context.getInflightRepository().size(order.getRoute().getId());	inflight += getPendingInflightExchanges(order);	if (inflight > 0) {	String routeId = order.getRoute().getId();	routeInflight.put(routeId, inflight);	size += inflight;	
inflight and pending exchanges for route 

String row = String.format("%s = %s", entry.getKey(), entry.getValue());	csb.append(row);	}	String msg = "Waiting as there are still " + size + " inflight and pending exchanges to complete, timeout in " + (TimeUnit.SECONDS.convert(timeout, timeUnit) - (loopCount++ * loopDelaySeconds)) + " seconds.";	msg += " Inflights per route: [" + csb.toString() + "]";	LOG.info(msg);	logInflightExchanges(context, routes, logInflightExchangesOnTimeout);	Thread.sleep(loopDelaySeconds * 1000);	} catch (InterruptedException e) {	if (abortAfterTimeout) {	
interrupted while waiting during graceful shutdown will abort 

}	String msg = "Waiting as there are still " + size + " inflight and pending exchanges to complete, timeout in " + (TimeUnit.SECONDS.convert(timeout, timeUnit) - (loopCount++ * loopDelaySeconds)) + " seconds.";	msg += " Inflights per route: [" + csb.toString() + "]";	LOG.info(msg);	logInflightExchanges(context, routes, logInflightExchangesOnTimeout);	Thread.sleep(loopDelaySeconds * 1000);	} catch (InterruptedException e) {	if (abortAfterTimeout) {	return;	} else {	
interrupted while waiting during graceful shutdown will force shutdown now 

break;	}	}	} else {	done = true;	}	}	for (ShutdownDeferredConsumer deferred : deferredConsumers) {	Consumer consumer = deferred.getConsumer();	if (consumer instanceof ShutdownAware) {	
route preparing to shutdown 

} else {	done = true;	}	}	for (ShutdownDeferredConsumer deferred : deferredConsumers) {	Consumer consumer = deferred.getConsumer();	if (consumer instanceof ShutdownAware) {	boolean forced = context.getShutdownStrategy().forceShutdown(consumer);	boolean suppress = context.getShutdownStrategy().isSuppressLoggingOnTimeout();	prepareShutdown(consumer, suspendOnly, forced, false, suppress);	
route preparing to shutdown complete 

if (consumer instanceof ShutdownAware) {	boolean forced = context.getShutdownStrategy().forceShutdown(consumer);	boolean suppress = context.getShutdownStrategy().isSuppressLoggingOnTimeout();	prepareShutdown(consumer, suspendOnly, forced, false, suppress);	}	}	for (ShutdownDeferredConsumer deferred : deferredConsumers) {	Consumer consumer = deferred.getConsumer();	if (suspendOnly) {	suspendNow(consumer);	
route suspend complete was consuming from 

boolean suppress = context.getShutdownStrategy().isSuppressLoggingOnTimeout();	prepareShutdown(consumer, suspendOnly, forced, false, suppress);	}	}	for (ShutdownDeferredConsumer deferred : deferredConsumers) {	Consumer consumer = deferred.getConsumer();	if (suspendOnly) {	suspendNow(consumer);	} else {	shutdownNow(consumer);	
route shutdown complete was consuming from 

========================= camel sample_4093 =========================

container.disableJMX();	container.addRoutes(builder);	container.start();	Endpoint endpoint = container.getEndpoint("direct:a");	Exchange exchange = endpoint.createExchange();	if (header != null) {	exchange.getIn().setHeader("foo", header);	}	Producer producer = endpoint.createProducer();	producer.process(exchange);	
invocation order 

========================= camel sample_3756 =========================

public void handleNotification(Notification notification, Object handback) {	
get the notification 

========================= camel sample_2844 =========================

public static void assertInMessageBodyEquals(Exchange exchange, Object expected) throws InvalidPayloadException {	assertNotNull(exchange, "Should have a response exchange!");	Object actual;	if (expected == null) {	actual = exchange.getIn().getMandatoryBody();	assertEquals(actual, expected, "in body of: " + exchange);	} else {	actual = exchange.getIn().getMandatoryBody(expected.getClass());	}	assertEquals(actual, expected, "in body of: " + exchange);	
received response with in 

public static void assertOutMessageBodyEquals(Exchange exchange, Object expected) throws InvalidPayloadException {	assertNotNull(exchange, "Should have a response exchange!");	Object actual;	if (expected == null) {	actual = exchange.getOut().getMandatoryBody();	assertEquals(actual, expected, "output body of: " + exchange);	} else {	actual = exchange.getOut().getMandatoryBody(expected.getClass());	}	assertEquals(actual, expected, "output body of: " + exchange);	
received response with out 

public static Object assertExpression(Expression expression, Exchange exchange, Object expected) {	Object value;	if (expected != null) {	value = expression.evaluate(exchange, expected.getClass());	} else {	value = expression.evaluate(exchange, Object.class);	}	
evaluated expression on exchange result 

public static void assertPredicateDoesNotMatch(Predicate predicate, Exchange exchange) {	try {	PredicateAssertHelper.assertMatches(predicate, "Predicate should match: ", exchange);	} catch (AssertionError e) {	
caught expected assertion error 

public static boolean assertPredicate(final Predicate predicate, Exchange exchange, boolean expected) {	if (expected) {	PredicateAssertHelper.assertMatches(predicate, "Predicate failed: ", exchange);	}	boolean value = predicate.matches(exchange);	
evaluated predicate on exchange result 

return;	}	if (file.isDirectory()) {	File[] files = file.listFiles();	for (File child : files) {	recursivelyDeleteDirectory(child);	}	}	boolean success = file.delete();	if (!success) {	
deletion of file failed 

========================= camel sample_11685 =========================

public Exchange add(CamelContext camelContext, String key, Exchange oldExchange, Exchange newExchange) throws OptimisticLockingException {	if (!optimistic) {	throw new UnsupportedOperationException();	}	
adding an exchange with id for key in an optimistic manner 

DefaultExchangeHolder oldHolder = cache.getAndPut(key, newHolder);	if (oldHolder != null) {	Exchange exchange = unmarshallExchange(camelContext, oldHolder);	LOG.error("Optimistic locking failed for exchange with key {}: IMap#putIfAbsend returned Exchange with ID {}, while it's expected no exchanges to be returned", key, exchange != null ? exchange.getExchangeId() : "<null>");	throw new OptimisticLockingException();	}	} else {	DefaultExchangeHolder oldHolder = DefaultExchangeHolder.marshal(oldExchange, true, allowSerializedHeaders);	DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(newExchange, true, allowSerializedHeaders);	if (!cache.replace(key, oldHolder, newHolder)) {	
optimistic locking failed for exchange with key imap replace returned no exchanges while it s expected to replace one 

LOG.error("Optimistic locking failed for exchange with key {}: IMap#putIfAbsend returned Exchange with ID {}, while it's expected no exchanges to be returned", key, exchange != null ? exchange.getExchangeId() : "<null>");	throw new OptimisticLockingException();	}	} else {	DefaultExchangeHolder oldHolder = DefaultExchangeHolder.marshal(oldExchange, true, allowSerializedHeaders);	DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(newExchange, true, allowSerializedHeaders);	if (!cache.replace(key, oldHolder, newHolder)) {	throw new OptimisticLockingException();	}	}	
added an exchange with id for key in optimistic manner 

public Exchange add(CamelContext camelContext, String key, Exchange exchange) {	if (optimistic) {	throw new UnsupportedOperationException();	}	
adding an exchange with id for key in a thread safe manner 

public void remove(CamelContext camelContext, String key, Exchange exchange) {	DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);	if (optimistic) {	
removing an exchange with id for key in an optimistic manner 

public void remove(CamelContext camelContext, String key, Exchange exchange) {	DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);	if (optimistic) {	if (!cache.remove(key, holder)) {	
optimistic locking failed for exchange with key imap remove removed no exchanges while it s expected to remove one 

public void remove(CamelContext camelContext, String key, Exchange exchange) {	DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);	if (optimistic) {	if (!cache.remove(key, holder)) {	throw new OptimisticLockingException();	}	
removed an exchange with id for key in an optimistic manner 

public void confirm(CamelContext camelContext, String exchangeId) {	
confirming an exchange with id 

========================= camel sample_12553 =========================

public void connect(SocketAddress endpoint, int timeout) throws IOException {	
connecting socket 

public synchronized void close() throws IOException {	
disconnecting socket 

========================= camel sample_15296 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ApnsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.apns.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.apns.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_749 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<TelegramComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.telegram.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.telegram.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1157 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<XmppComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.xmpp.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.xmpp.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_933 =========================

final Processor exceptionThrower = new Processor() {	public void process(Exchange exchange) throws Exception {	exchange.getIn().setBody("<exception/>");	throw new IllegalArgumentException("Exception thrown intentionally.");	}	};	return new RouteBuilder() {	public void configure() {	errorHandler(deadLetterChannel("mock:error").redeliveryDelay(0).maximumRedeliveries(3));	if (getName().endsWith("WithLongHandler")) {	
using long exception handler 

exchange.getIn().setBody("<exception/>");	throw new IllegalArgumentException("Exception thrown intentionally.");	}	};	return new RouteBuilder() {	public void configure() {	errorHandler(deadLetterChannel("mock:error").redeliveryDelay(0).maximumRedeliveries(3));	if (getName().endsWith("WithLongHandler")) {	onException(IllegalArgumentException.class).setBody(constant("<not-handled/>")). to("mock:exception");	} else if (getName().endsWith("WithHandler")) {	
using exception handler 

========================= camel sample_3869 =========================

protected void doService(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {	
service 

}	if (epContinuationTimeout != null) {	continuationTimeout = epContinuationTimeout;	} else {	continuationTimeout = jettyEndpoint.getComponent().getContinuationTimeout();	}	}	if (useContinuation) {	log.trace("Start request with continuation timeout of {}", continuationTimeout != null ? continuationTimeout : "jetty default");	} else {	
usage of continuation is disabled either by component or endpoint configuration fallback to normal servlet processing instead 

if (continuation.isInitial() && continuationTimeout != null) {	continuation.setTimeout(continuationTimeout);	}	if (consumer.isSuspended() && continuation.isInitial()) {	response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);	return;	}	if (continuation.isExpired()) {	String id = (String) continuation.getAttribute(EXCHANGE_ATTRIBUTE_ID);	expiredExchanges.put(id, id);	
continuation expired of exchangeid 

}	if (consumer.getEndpoint().isDisableStreamCache()) {	exchange.setProperty(Exchange.DISABLE_HTTP_STREAM_CACHE, Boolean.TRUE);	}	HttpHelper.setCharsetFromContentType(request.getContentType(), exchange);	exchange.setIn(new HttpMessage(exchange, consumer.getEndpoint(), request, response));	String contextPath = consumer.getEndpoint().getPath();	exchange.getIn().setHeader("CamelServletContextPath", contextPath);	updateHttpPath(exchange, contextPath);	if (log.isTraceEnabled()) {	
suspending continuation of exchangeid 

exchange.setIn(new HttpMessage(exchange, consumer.getEndpoint(), request, response));	String contextPath = consumer.getEndpoint().getPath();	exchange.getIn().setHeader("CamelServletContextPath", contextPath);	updateHttpPath(exchange, contextPath);	if (log.isTraceEnabled()) {	}	continuation.setAttribute(EXCHANGE_ATTRIBUTE_ID, exchange.getExchangeId());	try {	consumer.createUoW(exchange);	} catch (Exception e) {	
error processing request 

}	continuation.setAttribute(EXCHANGE_ATTRIBUTE_ID, exchange.getExchangeId());	try {	consumer.createUoW(exchange);	} catch (Exception e) {	throw new ServletException(e);	}	continuation.suspend();	ClassLoader oldTccl = overrideTccl(exchange);	if (log.isTraceEnabled()) {	
processing request for exchangeid 

}	continuation.suspend();	ClassLoader oldTccl = overrideTccl(exchange);	if (log.isTraceEnabled()) {	}	consumer.getAsyncProcessor().process(exchange, new AsyncCallback() {	public void done(boolean doneSync) {	boolean expired = expiredExchanges.remove(exchange.getExchangeId()) != null;	if (!expired) {	if (log.isTraceEnabled()) {	
resuming continuation of exchangeid 

}	consumer.getAsyncProcessor().process(exchange, new AsyncCallback() {	public void done(boolean doneSync) {	boolean expired = expiredExchanges.remove(exchange.getExchangeId()) != null;	if (!expired) {	if (log.isTraceEnabled()) {	}	continuation.setAttribute(EXCHANGE_ATTRIBUTE_NAME, exchange);	continuation.resume();	} else {	
cannot resume expired continuation of exchangeid 

}	}	});	if (oldTccl != null) {	restoreTccl(exchange, oldTccl);	}	return;	}	try {	if (log.isTraceEnabled()) {	
resumed continuation and writing response for exchangeid 

if (oldTccl != null) {	restoreTccl(exchange, oldTccl);	}	return;	}	try {	if (log.isTraceEnabled()) {	}	Integer bs = consumer.getEndpoint().getResponseBufferSize();	if (bs != null) {	
using response buffer size 

}	try {	if (log.isTraceEnabled()) {	}	Integer bs = consumer.getEndpoint().getResponseBufferSize();	if (bs != null) {	response.setBufferSize(bs);	}	consumer.getBinding().writeResponse(result, response);	} catch (IOException e) {	
error processing request 

if (log.isTraceEnabled()) {	}	Integer bs = consumer.getEndpoint().getResponseBufferSize();	if (bs != null) {	response.setBufferSize(bs);	}	consumer.getBinding().writeResponse(result, response);	} catch (IOException e) {	throw e;	} catch (Exception e) {	
error processing request 

========================= camel sample_17497 =========================

public void testGuice() throws Exception {	Injector injector = Guice.createInjector(new MyModule());	MyConfigurableRoute2 instance = injector.getInstance(Key.get(MyConfigurableRoute2.class, Names.named("foo")));	assertNotNull("should have found a key for 'foo'", instance);	
found instance 

public void testGuice() throws Exception {	Injector injector = Guice.createInjector(new MyModule());	MyConfigurableRoute2 instance = injector.getInstance(Key.get(MyConfigurableRoute2.class, Names.named("foo")));	assertNotNull("should have found a key for 'foo'", instance);	Collection<RouteBuilder> list = Injectors.getInstancesOf(injector, RouteBuilder.class);	
routebuilder list 

public void testGuice() throws Exception {	Injector injector = Guice.createInjector(new MyModule());	MyConfigurableRoute2 instance = injector.getInstance(Key.get(MyConfigurableRoute2.class, Names.named("foo")));	assertNotNull("should have found a key for 'foo'", instance);	Collection<RouteBuilder> list = Injectors.getInstancesOf(injector, RouteBuilder.class);	assertEquals("route builder list: " + list, 1, list.size());	list = Injectors.getInstancesOf(injector, Matchers.subclassesOf(RouteBuilder.class));	
routebuilder list 

========================= camel sample_8399 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SolrComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.solr.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.solr.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_525 =========================

protected void doStart() throws Exception {	ObjectHelper.notNull(camelContext, "CamelContext", this);	camelContext.getManagementStrategy().addEventNotifier(eventNotifier);	if (!camelContext.getRoutePolicyFactories().contains(this)) {	camelContext.addRoutePolicyFactory(this);	}	if (null == tracingStrategy) {	
no tracing strategy available defaulting to no op strategy 

protected void doStart() throws Exception {	ObjectHelper.notNull(camelContext, "CamelContext", this);	camelContext.getManagementStrategy().addEventNotifier(eventNotifier);	if (!camelContext.getRoutePolicyFactories().contains(this)) {	camelContext.addRoutePolicyFactory(this);	}	if (null == tracingStrategy) {	tracingStrategy = new NoopTracingStrategy();	}	camelContext.addInterceptStrategy(tracingStrategy);	
starting xray tracer 

protected void doStop() throws Exception {	camelContext.getManagementStrategy().removeEventNotifier(eventNotifier);	ServiceHelper.stopAndShutdownService(eventNotifier);	camelContext.getRoutePolicyFactories().remove(this);	
xray tracer stopped 

public void init(CamelContext camelContext) {	if (!camelContext.hasService(this)) {	try {	
initializing xray tracer 

private boolean isExcluded(String routeId) {	if (!excludePatterns.isEmpty()) {	for (String pattern : excludePatterns) {	if (pattern.equals(routeId)) {	
ignoring route with id 

public void notify(EventObject event) throws Exception {	if (event instanceof ExchangeSendingEvent) {	ExchangeSendingEvent ese = (ExchangeSendingEvent) event;	
target routeid 

public void notify(EventObject event) throws Exception {	if (event instanceof ExchangeSendingEvent) {	ExchangeSendingEvent ese = (ExchangeSendingEvent) event;	if (Thread.currentThread().getName().contains("Multicast")) {	Segment segment = (Segment) ese.getExchange().getProperty(CURRENT_SEGMENT);	
copying over segment from exchange received from to exchange processing 

if (!sd.newSegment()) {	return;	}	if (AWSXRay.getCurrentSegmentOptional().isPresent()) {	String name = sd.getOperationName(ese.getExchange(), ese.getEndpoint());	if (sd.getComponent() != null) {	name = sd.getComponent() + ":" + name;	}	Subsegment subsegment = AWSXRay.beginSubsegment(sanitizeName(name));	sd.pre(subsegment, ese.getExchange(), ese.getEndpoint());	
creating new subsegment with id and name 

return;	}	if (AWSXRay.getCurrentSegmentOptional().isPresent()) {	String name = sd.getOperationName(ese.getExchange(), ese.getEndpoint());	if (sd.getComponent() != null) {	name = sd.getComponent() + ":" + name;	}	Subsegment subsegment = AWSXRay.beginSubsegment(sanitizeName(name));	sd.pre(subsegment, ese.getExchange(), ese.getEndpoint());	} else {	
ignoring creation of xray subsegment as no segment exists in the current thread 

String name = sd.getOperationName(ese.getExchange(), ese.getEndpoint());	if (sd.getComponent() != null) {	name = sd.getComponent() + ":" + name;	}	Subsegment subsegment = AWSXRay.beginSubsegment(sanitizeName(name));	sd.pre(subsegment, ese.getExchange(), ese.getEndpoint());	} else {	}	} else if (event instanceof ExchangeSentEvent) {	ExchangeSentEvent ese = (ExchangeSentEvent) event;	
target routeid 

sd.pre(subsegment, ese.getExchange(), ese.getEndpoint());	} else {	}	} else if (event instanceof ExchangeSentEvent) {	ExchangeSentEvent ese = (ExchangeSentEvent) event;	SegmentDecorator sd = getSegmentDecorator(ese.getEndpoint());	if (AWSXRay.getCurrentSubsegmentOptional().isPresent()) {	Subsegment subsegment = AWSXRay.getCurrentSubsegment();	sd.post(subsegment, ese.getExchange(), ese.getEndpoint());	subsegment.close();	
closing down subsegment with id and name 

}	} else if (event instanceof ExchangeSentEvent) {	ExchangeSentEvent ese = (ExchangeSentEvent) event;	SegmentDecorator sd = getSegmentDecorator(ese.getEndpoint());	if (AWSXRay.getCurrentSubsegmentOptional().isPresent()) {	Subsegment subsegment = AWSXRay.getCurrentSubsegment();	sd.post(subsegment, ese.getExchange(), ese.getEndpoint());	subsegment.close();	}	} else {	
received event from source 

traceID = TraceID.fromString(exchange.getIn().getHeader(XRAY_TRACE_ID, String.class));	} else {	traceID = new TraceID();	exchange.getIn().setHeader(XRAY_TRACE_ID, traceID.toString());	}	SegmentDecorator sd = getSegmentDecorator(route.getEndpoint());	if (!AWSXRay.getCurrentSegmentOptional().isPresent()) {	Segment segment = AWSXRay.beginSegment(sanitizeName(route.getId()));	segment.setTraceId(traceID);	sd.pre(segment, exchange, route.getEndpoint());	
created new xray segment with name 

}	SegmentDecorator sd = getSegmentDecorator(route.getEndpoint());	if (!AWSXRay.getCurrentSegmentOptional().isPresent()) {	Segment segment = AWSXRay.beginSegment(sanitizeName(route.getId()));	segment.setTraceId(traceID);	sd.pre(segment, exchange, route.getEndpoint());	exchange.setProperty(CURRENT_SEGMENT, segment);	} else {	Subsegment subsegment = AWSXRay.beginSubsegment(route.getId());	sd.pre(subsegment, exchange, route.getEndpoint());	
created new xray subsegment with name 

public void onExchangeDone(Route route, Exchange exchange) {	if (isExcluded(route.getId())) {	return;	}	LOG.trace("=> RoutePolicy-Done: Route: {} - RouteId: {}", routeId, route.getId());	SegmentDecorator sd = getSegmentDecorator(route.getEndpoint());	if (AWSXRay.getCurrentSubsegmentOptional().isPresent()) {	Subsegment subsegment = AWSXRay.getCurrentSubsegment();	sd.post(subsegment, exchange, route.getEndpoint());	subsegment.close();	
closing down subsegment with name 

LOG.trace("=> RoutePolicy-Done: Route: {} - RouteId: {}", routeId, route.getId());	SegmentDecorator sd = getSegmentDecorator(route.getEndpoint());	if (AWSXRay.getCurrentSubsegmentOptional().isPresent()) {	Subsegment subsegment = AWSXRay.getCurrentSubsegment();	sd.post(subsegment, exchange, route.getEndpoint());	subsegment.close();	} else if (AWSXRay.getCurrentSegmentOptional().isPresent()) {	Segment segment = AWSXRay.getCurrentSegment();	sd.post(segment, exchange, route.getEndpoint());	segment.close();	
closing down segment with name 

========================= camel sample_8233 =========================

if (conf.isVerifySignaturesOfAllSigners(exchange)) {	throw new CryptoCmsNoCertificateForSignerInfoException("KCS7/CMS signature verification failed. The public key for the signer information with" + signerInformationToString(signer) + " cannot be found in the configured certificates: " + certsToString(allowedVerifyCerts));	} else {	continue;	}	}	Iterator<X509CertificateHolder> certIt = certCollection.iterator();	X509CertificateHolder cert = certIt.next();	try {	if (signer.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(BouncyCastleProvider.PROVIDER_NAME).build(cert))) {	
verification successful 

========================= camel sample_11543 =========================

protected MqttConnectOptions resolveMqttConnectOptions() {	if (connectOptions != null) {	return connectOptions;	}	Set<MqttConnectOptions> connectOptions = getCamelContext().getRegistry().findByType(MqttConnectOptions.class);	if (connectOptions.size() == 1) {	
single mqttconnectoptions instance found in the registry it will be used by the endpoint 

protected MqttConnectOptions resolveMqttConnectOptions() {	if (connectOptions != null) {	return connectOptions;	}	Set<MqttConnectOptions> connectOptions = getCamelContext().getRegistry().findByType(MqttConnectOptions.class);	if (connectOptions.size() == 1) {	return connectOptions.iterator().next();	} else if (connectOptions.size() > 1) {	
found instances of the mqttconnectoptions in the registry none of these will be used by the endpoint please use connectoptions endpoint option to select one 

========================= camel sample_9072 =========================

ServiceReference<?> sr = bundleContext.getServiceReference(name);	if (sr == null) {	String filterExpression = "(" + Constants.SERVICE_PID + "=" + name + ")";	try {	ServiceReference<?>[] refs = bundleContext.getServiceReferences((String)null, filterExpression);	if (refs != null && refs.length > 0) {	sr = refs[0];	}	} catch (InvalidSyntaxException ex) {	if (LOG.isDebugEnabled()) {	
invalid osgi service reference filter skipped lookup by service pid filter expression 

========================= camel sample_13084 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<PropertiesComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.properties.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.properties.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_876 =========================

public void run() {	
continue routing exchange 

public void reject() {	exchange.setException(new RejectedExecutionException());	
rejected routing exchange 

public boolean process(Exchange exchange, AsyncCallback callback) {	if (shutdown.get()) {	throw new IllegalStateException("ThreadsProcessor is not running.");	}	if (exchange.isTransacted()) {	
transacted exchange must be routed synchronously for exchangeid 

public boolean process(Exchange exchange, AsyncCallback callback) {	if (shutdown.get()) {	throw new IllegalStateException("ThreadsProcessor is not running.");	}	if (exchange.isTransacted()) {	callback.done(true);	return true;	}	try {	ProcessCall call = new ProcessCall(exchange, callback, false);	
submitting task 

========================= camel sample_4494 =========================

public static KubernetesClient getKubernetesClient(KubernetesConfiguration configuration) {	if (configuration.getKubernetesClient() != null) {	return configuration.getKubernetesClient();	} else if (configuration.getMasterUrl() != null) {	return createKubernetesClient(configuration);	} else {	
creating default kubernetes client without applying configuration 

private static KubernetesClient createKubernetesClient(KubernetesConfiguration configuration) {	
create kubernetes client with the following configuration 

========================= camel sample_13250 =========================

private void handleNickInUse() {	IRCConnection connection = component.getIRCConnection(configuration);	String nick = connection.getNick() + "-";	if (nick.endsWith("----")) {	
unable to set nick disconnecting 

private void handleNickInUse() {	IRCConnection connection = component.getIRCConnection(configuration);	String nick = connection.getNick() + "-";	if (nick.endsWith("----")) {	} else {	
unable to set nick retrying with 

public void joinChannel(IrcChannel channel) {	if (channel == null) {	return;	}	IRCConnection connection = component.getIRCConnection(configuration);	String chn = channel.getName();	String key = channel.getKey();	if (ObjectHelper.isNotEmpty(key)) {	if (LOG.isDebugEnabled()) {	
joining using with secret key 

}	IRCConnection connection = component.getIRCConnection(configuration);	String chn = channel.getName();	String key = channel.getKey();	if (ObjectHelper.isNotEmpty(key)) {	if (LOG.isDebugEnabled()) {	}	connection.doJoin(chn, key);	} else {	if (LOG.isDebugEnabled()) {	
joining using 

========================= camel sample_12154 =========================

return new RouteBuilder() {	public void configure() throws Exception {	context.addComponent("async", new MyAsyncComponent());	errorHandler(defaultErrorHandler().maximumRedeliveries(5).redeliveryDelay(100).asyncDelayedRedelivery());	from("seda:start") .to("log:before") .to("mock:before") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	beforeThreadName = Thread.currentThread().getName();	}	}) .to("async:camel") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	
processing at attempt 

errorHandler(defaultErrorHandler().maximumRedeliveries(5).redeliveryDelay(100).asyncDelayedRedelivery());	from("seda:start") .to("log:before") .to("mock:before") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	beforeThreadName = Thread.currentThread().getName();	}	}) .to("async:camel") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String body = exchange.getIn().getBody(String.class);	if (body.contains("Camel")) {	if (++attempt <= 2) {	
processing failed will thrown an exception 

}	}) .to("async:camel") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String body = exchange.getIn().getBody(String.class);	if (body.contains("Camel")) {	if (++attempt <= 2) {	throw new IllegalArgumentException("Damn");	}	}	exchange.getIn().setBody("Hello " + body);	
processing at attempt complete 

========================= camel sample_2055 =========================

public void configure() {	
adding route from to 

========================= camel sample_6446 =========================

String s = entry.getValue().size() > 1 ? entry.getValue().toString() : entry.getValue().get(0);	method.addRequestHeader(key, s);	}	}	}	if (getEndpoint().isConnectionClose()) {	method.addRequestHeader("Connection", "close");	}	try {	if (LOG.isDebugEnabled()) {	
executing http method 

}	}	}	if (getEndpoint().isConnectionClose()) {	method.addRequestHeader("Connection", "close");	}	try {	if (LOG.isDebugEnabled()) {	}	int responseCode = executeMethod(method);	
http responsecode 

url = url.substring(0, url.indexOf('?'));	}	RequestEntity requestEntity = createRequestEntity(exchange);	String methodName = HttpHelper.createMethod(exchange, getEndpoint(), requestEntity != null).name();	HttpMethods methodsToUse = HttpMethods.valueOf(methodName);	HttpMethod method = methodsToUse.createMethod(url);	if (queryString != null) {	queryString = UnsafeUriCharactersEncoder.encode(queryString);	method.setQueryString(queryString);	}	
using url with method 

String methodName = HttpHelper.createMethod(exchange, getEndpoint(), requestEntity != null).name();	HttpMethods methodsToUse = HttpMethods.valueOf(methodName);	HttpMethod method = methodsToUse.createMethod(url);	if (queryString != null) {	queryString = UnsafeUriCharactersEncoder.encode(queryString);	method.setQueryString(queryString);	}	if (methodsToUse.isEntityEnclosing()) {	((EntityEnclosingMethod) method).setRequestEntity(requestEntity);	if (requestEntity != null && requestEntity.getContentType() == null) {	
no content type provided for url with exchange 

========================= camel sample_12857 =========================

protected void doStart() throws Exception {	super.doStart();	launchContinuousQuery();	
started ignite cache continuous query consumer for cache with query  

ContinuousQuery<Object, Object> continuousQuery = new ContinuousQuery<>();	if (endpoint.getQuery() != null) {	continuousQuery.setInitialQuery(endpoint.getQuery());	}	if (endpoint.getRemoteFilter() != null) {	continuousQuery.setRemoteFilter(endpoint.getRemoteFilter());	}	continuousQuery.setLocalListener(new CacheEntryUpdatedListener<Object, Object>() {	public void onUpdated(Iterable<CacheEntryEvent<? extends Object, ? extends Object>> events) throws CacheEntryListenerException {	if (LOG.isTraceEnabled()) {	
processing continuous query event s  

protected void doStop() throws Exception {	super.doStop();	cursor.close();	
stopped ignite cache continuous query consumer for cache with query  

========================= camel sample_11282 =========================

private MessagePublisherClient() { }	public static void main(String[] args) throws Exception {	
about to run kafka camel integration 

headers.put(KafkaConstants.KEY, "2");	headers.put(KafkaConstants.TOPIC, "TestLog");	producerTemplate.sendBodyAndHeaders("direct:kafkaStartNoTopic", testKafkaMessage, headers);	testKafkaMessage = "PART 0 :  " + testKafkaMessage;	Map<String, Object> newHeader = new HashMap<String, Object>();	newHeader.put(KafkaConstants.KEY, "AB");	producerTemplate.sendBodyAndHeaders("direct:kafkaStartWithPartitioner", testKafkaMessage, newHeader);	testKafkaMessage = "PART 1 :  " + testKafkaMessage;	newHeader.put(KafkaConstants.KEY, "ABC");	producerTemplate.sendBodyAndHeaders("direct:kafkaStartWithPartitioner", testKafkaMessage, newHeader);	
successfully published event to kafka 

========================= camel sample_17585 =========================

private void listBrokers(AmazonMQ mqClient, Exchange exchange) {	ListBrokersRequest request = new ListBrokersRequest();	if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(MQConstants.MAX_RESULTS))) {	int maxResults = exchange.getIn().getHeader(MQConstants.MAX_RESULTS, Integer.class);	request.withMaxResults(maxResults);	}	ListBrokersResult result;	try {	result = mqClient.listBrokers(request);	} catch (AmazonServiceException ase) {	
list brokers command returned the error code 

throw new IllegalArgumentException("Broker Name must be specified");	}	if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(MQConstants.BROKER_DEPLOYMENT_MODE))) {	deploymentMode = exchange.getIn().getHeader(MQConstants.BROKER_DEPLOYMENT_MODE, String.class);	request.withDeploymentMode(deploymentMode);	}	CreateBrokerResult result;	try {	result = mqClient.createBroker(request);	} catch (AmazonServiceException ase) {	
create broker command returned the error code 

if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(MQConstants.BROKER_ID))) {	brokerId = exchange.getIn().getHeader(MQConstants.BROKER_ID, String.class);	request.withBrokerId(brokerId);	} else {	throw new IllegalArgumentException("Broker Name must be specified");	}	DeleteBrokerResult result;	try {	result = mqClient.deleteBroker(request);	} catch (AmazonServiceException ase) {	
delete broker command returned the error code 

========================= camel sample_8771 =========================

protected Endpoint createEndpoint(final String uri, final String remaining, final Map<String, Object> parameters) throws Exception {	final CMConfiguration config = new CMConfiguration();	setProperties(config, parameters);	
validating uri based configuration 

========================= camel sample_12787 =========================

protected Endpoint doCreateEndpoint(TwitterConfiguration properties, String uri, String remaining, Map<String, Object> parameters) throws Exception {	String[] tokens = remaining.split("/");	
the scheme syntax twitter has been deprecated use twitter instead 

========================= camel sample_14203 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<StAXComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.stax.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.stax.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1100 =========================

public int commit(DefaultSqlEndpoint defaultSqlEndpoint, Exchange exchange, Object data, NamedParameterJdbcTemplate jdbcTemplate, SqlParameterSource parameterSource, String query) throws Exception {	final SqlParameterSource param = new ElsqlSqlMapSource(exchange, data);	final String sql = elSql.getSql(query, new SpringSqlParams(param));	
commit using sql 

public int commit(DefaultSqlEndpoint defaultSqlEndpoint, Exchange exchange, Object data, NamedParameterJdbcTemplate jdbcTemplate, SqlParameterSource parameterSource, String query) throws Exception {	final SqlParameterSource param = new ElsqlSqlMapSource(exchange, data);	final String sql = elSql.getSql(query, new SpringSqlParams(param));	return jdbcTemplate.execute(sql, param, new PreparedStatementCallback<Integer>() {	public Integer doInPreparedStatement(PreparedStatement ps) throws SQLException, DataAccessException {	ps.execute();	int updateCount = ps.getUpdateCount();	if (LOG.isTraceEnabled()) {	
update count 

public int commitBatchComplete(DefaultSqlEndpoint endpoint, NamedParameterJdbcTemplate namedJdbcTemplate, SqlParameterSource parameterSource, String query) throws Exception {	final SqlParameterSource param = new EmptySqlParameterSource();	final String sql = elSql.getSql(query, new SpringSqlParams(param));	
commitbatchcomplete using sql 

public int commitBatchComplete(DefaultSqlEndpoint endpoint, NamedParameterJdbcTemplate namedJdbcTemplate, SqlParameterSource parameterSource, String query) throws Exception {	final SqlParameterSource param = new EmptySqlParameterSource();	final String sql = elSql.getSql(query, new SpringSqlParams(param));	return namedJdbcTemplate.execute(sql, param, new PreparedStatementCallback<Integer>() {	public Integer doInPreparedStatement(PreparedStatement ps) throws SQLException, DataAccessException {	ps.execute();	int updateCount = ps.getUpdateCount();	if (LOG.isTraceEnabled()) {	
update count 

========================= camel sample_13196 =========================

public boolean canTest() {	if (System.getProperty("java.vendor").contains("IBM")) {	return false;	}	try {	javax.security.auth.login.Configuration.getConfiguration();	} catch (Exception e) {	
cannot run test due security exception 

========================= camel sample_11144 =========================

protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {	HttpRequest request = (HttpRequest) msg;	
message received 

public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {	Attribute<HttpServerChannelHandler> attr = ctx.channel().attr(SERVER_HANDLER_KEY);	HttpServerChannelHandler handler = attr.get();	if (handler != null) {	handler.exceptionCaught(ctx, cause);	} else {	if (cause instanceof ClosedChannelException) {	
channel already closed ignoring this exception 

public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {	Attribute<HttpServerChannelHandler> attr = ctx.channel().attr(SERVER_HANDLER_KEY);	HttpServerChannelHandler handler = attr.get();	if (handler != null) {	handler.exceptionCaught(ctx, cause);	} else {	if (cause instanceof ClosedChannelException) {	return;	} else {	
httpserverchannelhandler is not found as attachment to handle exception send back to the client 

========================= camel sample_16681 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<CacheComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.cache.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.cache.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_821 =========================

public void testUriIssue() throws Exception {	String uri = "rss:http: PollingConsumer consumer = context.getEndpoint(uri).createPollingConsumer();	consumer.start();	Exchange exchange = consumer.receive();	
receive 

========================= camel sample_12292 =========================

protected boolean runningAllowed() {	boolean quickStop = false;	if (isAllowQuickStop() && !endpoint.isAcceptMessagesWhileStopping()) {	quickStop = endpoint.getCamelContext().getStatus().isStopping();	}	if (quickStop) {	
runningallowed false due camelcontext is stopping and endpoint configured to not accept messages while stopping 

protected boolean runningAllowed() {	boolean quickStop = false;	if (isAllowQuickStop() && !endpoint.isAcceptMessagesWhileStopping()) {	quickStop = endpoint.getCamelContext().getStatus().isStopping();	}	if (quickStop) {	return false;	} else {	boolean answer = endpoint.isRunning();	
runningallowed 

public void stop() throws JmsException {	if (logger.isDebugEnabled()) {	
stopping listenercontainer with cachelevel and sharedconnectionenabled 

public void destroy() {	if (logger.isDebugEnabled()) {	
destroying listenercontainer with cachelevel and sharedconnectionenabled 

protected void stopSharedConnection() {	if (logger.isDebugEnabled()) {	if (sharedConnectionEnabled()) {	
stopping shared connection on listenercontainer 

========================= camel sample_7191 =========================

private void verifyTheRecivedEmail(String expectString) throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.assertIsSatisfied();	Exchange out = mock.assertExchangeReceived(0);	ByteArrayOutputStream baos = new ByteArrayOutputStream(((MailMessage)out.getIn()).getMessage().getSize());	((MailMessage)out.getIn()).getMessage().writeTo(baos);	String dumpedMessage = baos.toString();	assertTrue("There should have the " + expectString, dumpedMessage.indexOf(expectString) > 0);	
multipart alternative 

========================= camel sample_11847 =========================

public void execute() throws MojoExecutionException, MojoFailureException {	if (!isStarterAllowed()) {	
spring boot starter starter not allowed for module skipping 

public void execute() throws MojoExecutionException, MojoFailureException {	if (!isStarterAllowed()) {	return;	}	try {	File starterDir = starterDir();	
spring boot starter starter dir for the component is 

String stdName = (comps[0] + ":" + comps[1]).replace("-starter", "");	if (stdName.equals(project.getGroupId() + ":" + project.getArtifactId())) {	inGlobal = true;	break;	}	}	if (!inGlobal) {	deps.addAll(globalProps);	}	if (deps.size() > 0) {	
the following dependencies will be added to the starter 

DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();	Document originalPom = builder.parse(project.getFile());	XPath xpath = XPathFactory.newInstance().newXPath();	Node repositories = (Node) xpath.compile("/project/repositories").evaluate(originalPom, XPathConstants.NODE);	if (repositories != null) {	pom.getDocumentElement().appendChild(pom.createComment(GENERATED_SECTION_START));	pom.getDocumentElement().appendChild(pom.importNode(repositories, true));	pom.getDocumentElement().appendChild(pom.createComment(GENERATED_SECTION_END));	}	} else {	
cannot access the project pom file to retrieve repositories 

loggingImpl.add("org.slf4j:slf4j-jcl");	loggingImpl.add("org.slf4j:slf4j-jdk14");	loggingImpl.add("org.slf4j:slf4j-log4j12");	loggingImpl.add("org.slf4j:slf4j-log4j13");	loggingImpl.add("org.slf4j:slf4j-nop");	loggingImpl.add("org.slf4j:slf4j-simple");	Set<String> configExclusions = new HashSet<>();	Properties properties = new Properties();	properties.load(getClass().getResourceAsStream("/spring-boot-fix-dependencies.properties"));	String artExcl = properties.getProperty("exclude_" + project.getArtifactId());	
configured exclusions 

loggingImpl.add("org.slf4j:slf4j-log4j12");	loggingImpl.add("org.slf4j:slf4j-log4j13");	loggingImpl.add("org.slf4j:slf4j-nop");	loggingImpl.add("org.slf4j:slf4j-simple");	Set<String> configExclusions = new HashSet<>();	Properties properties = new Properties();	properties.load(getClass().getResourceAsStream("/spring-boot-fix-dependencies.properties"));	String artExcl = properties.getProperty("exclude_" + project.getArtifactId());	if (artExcl != null && artExcl.trim().length() > 0) {	for (String dep : artExcl.split(",")) {	
adding configured exclusion 

if (artExcl != null && artExcl.trim().length() > 0) {	for (String dep : artExcl.split(",")) {	configExclusions.add(dep);	}	}	Set<String> libsToRemove = new TreeSet<>();	libsToRemove.addAll(loggingImpl);	libsToRemove.addAll(configExclusions);	libsToRemove = filterIncludedArtifacts(libsToRemove);	if (libsToRemove.size() > 0) {	
spring boot starter the following dependencies will be removed from the starter 

node.accept(visitor);	List<DependencyNode> nodes = visitor.getNodes();	for (DependencyNode dependencyNode : nodes) {	Artifact artifact = dependencyNode.getArtifact();	if (getLog().isDebugEnabled()) {	getLog().debug("Found dependency node: " + artifact.getGroupId() + ":" + artifact.getArtifactId() + ":" + artifact.getVersion() + " - scope=" + artifact.getScope());	}	if (!Artifact.SCOPE_TEST.equals(artifact.getScope()) && !Artifact.SCOPE_PROVIDED.equals(artifact.getScope())) {	String canonicalName = artifact.getGroupId() + ":" + artifact.getArtifactId();	if (artifacts.contains(canonicalName)) {	
marked for exclusion 

try (InputStream in = new FileInputStream(pomFile)) {	String content = IOUtils.toString(in, "UTF-8");	boolean editablePom = content.contains(GENERATED_SECTION_START_COMMENT);	if (editablePom) {	content = removeGeneratedSections(content, 10);	DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();	Document pom;	try (InputStream contentIn = new ByteArrayInputStream(content.getBytes("UTF-8"))) {	pom = builder.parse(contentIn);	}	
reusing the existing pom xml for the starter 

DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();	Document pom;	try (InputStream contentIn = new ByteArrayInputStream(content.getBytes("UTF-8"))) {	pom = builder.parse(contentIn);	}	return pom;	}	}	}	} catch (Exception e) {	
cannot use the existing pom xml file 

private Document createBasePomFromScratch() throws Exception {	
creating a new pom xml for the starter from scratch 

private boolean isStarterAllowed() {	for (String ignored : IGNORE_MODULES) {	if (ignored.equals(project.getArtifactId())) {	
component inside ignore list 

private boolean isStarterAllowed() {	for (String ignored : IGNORE_MODULES) {	if (ignored.equals(project.getArtifactId())) {	return false;	}	}	if (IGNORE_TEST_MODULES && (project.getArtifactId().startsWith("camel-test") || project.getArtifactId().startsWith("camel-testng"))) {	
test components are ignored 

private boolean isStarterAllowed() {	for (String ignored : IGNORE_MODULES) {	if (ignored.equals(project.getArtifactId())) {	return false;	}	}	if (IGNORE_TEST_MODULES && (project.getArtifactId().startsWith("camel-test") || project.getArtifactId().startsWith("camel-testng"))) {	return false;	}	if (project.getPackaging() != null && !project.getPackaging().equals("jar")) {	
ignored for wrong packaging 

}	if (project.getPackaging() != null && !project.getPackaging().equals("jar")) {	return false;	}	if (baseDir.getName().equals("camel-core")) {	return true;	}	if (baseDir.getParentFile().getName().equals("components") || baseDir.getName().endsWith("-component")) {	return true;	}	
component directory mismatch 

}	content = content.replaceFirst("-->", "-->\n").replaceFirst("\\?><!--", "\\?>\n<!--");	writeIfChanged(content, destination);	}	private void writeIfChanged(String content, File file) throws IOException {	boolean write = true;	if (file.exists()) {	try (FileReader fr = new FileReader(file)) {	String oldContent = IOUtils.toString(fr);	if (!content.equals(oldContent)) {	
writing new file 

writeIfChanged(content, destination);	}	private void writeIfChanged(String content, File file) throws IOException {	boolean write = true;	if (file.exists()) {	try (FileReader fr = new FileReader(file)) {	String oldContent = IOUtils.toString(fr);	if (!content.equals(oldContent)) {	fr.close();	} else {	
file has been left unchanged 

========================= camel sample_122 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<FacebookComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.facebook.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.facebook.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_572 =========================

private Message getNextElement() {	if (tarInputStream == null) {	return null;	}	try {	TarArchiveEntry current = getNextEntry();	if (current != null) {	
reading tarentry 

answer.getHeaders().putAll(exchange.getIn().getHeaders());	answer.setHeader(TARFILE_ENTRY_NAME_HEADER, current.getName());	answer.setHeader(Exchange.FILE_NAME, current.getName());	if (current.getSize() > 0) {	answer.setBody(new TarElementInputStreamWrapper(tarInputStream));	} else {	answer.setBody(new ByteArrayInputStream(new byte[0]));	}	return answer;	} else {	
closed tarinputstream 

========================= camel sample_12457 =========================

protected void doStart() throws Exception {	boolean startScheduler = isStartScheduler();	setStartScheduler(false);	try {	super.doStart();	if (endpoint.isAutoCreate()) {	
auto creating directory 

protected void doStart() throws Exception {	boolean startScheduler = isStartScheduler();	setStartScheduler(false);	try {	super.doStart();	if (endpoint.isAutoCreate()) {	try {	connectIfNecessary();	operations.buildDirectory(endpoint.getConfiguration().getDirectory(), true);	} catch (GenericFileOperationFailedException e) {	
error auto creating directory due this exception is ignored 

protected boolean doPollDirectory(String absolutePath, String dirName, List<GenericFile<SftpRemoteFile>> fileList, int depth) {	
dopolldirectory from absolutepath dirname 

protected boolean doPollDirectory(String absolutePath, String dirName, List<GenericFile<SftpRemoteFile>> fileList, int depth) {	depth++;	dirName = FileUtil.stripTrailingSeparator(dirName);	String dir;	if (isStepwise()) {	dir = ObjectHelper.isNotEmpty(dirName) ? dirName : absolutePath;	operations.changeCurrentDirectory(dir);	} else {	dir = absolutePath;	}	
polling directory 

}	} else {	fileExpressionResult = evaluateFileExpression();	if (fileExpressionResult != null) {	SftpRemoteFile file = new SftpRemoteFileSingle(fileExpressionResult);	files = new ArrayList<SftpRemoteFile>(1);	files.add(file);	}	}	if (files == null || files.isEmpty()) {	
no files found in directory 

fileExpressionResult = evaluateFileExpression();	if (fileExpressionResult != null) {	SftpRemoteFile file = new SftpRemoteFileSingle(fileExpressionResult);	files = new ArrayList<SftpRemoteFile>(1);	files.add(file);	}	}	if (files == null || files.isEmpty()) {	return true;	} else {	
found in directory 

protected boolean isMatched(GenericFile<SftpRemoteFile> file, String doneFileName, List<SftpRemoteFile> files) {	String onlyName = FileUtil.stripPath(doneFileName);	for (SftpRemoteFile f : files) {	if (f.getFilename().equals(onlyName)) {	return true;	}	}	
done file does not exist 

========================= camel sample_15392 =========================

public void testExpressionArray() throws Exception {	Exchange exchange = new DefaultExchange(context);	exchange.getIn().setBody(new File("src/test/resources/books.json"));	Language lan = context.resolveLanguage("jsonpath");	Expression exp = lan.createExpression("$.store.book[*].author");	List<?> authors = exp.evaluate(exchange, List.class);	
authors 

========================= camel sample_16947 =========================

getMockEndpoint("mock:deadLetter").expectedMessageCount(1);	getMockEndpoint("mock:deadLetter").setResultWaitTime(25000);	template.sendBody("seda:foo", "Hello World");	getMockEndpoint("mock:foo").assertIsSatisfied();	StopWatch watch = new StopWatch();	Thread.sleep(500);	log.info("==== stopping route foo ====");	context.stopRoute("foo");	long taken = watch.taken();	getMockEndpoint("mock:deadLetter").assertIsSatisfied();	
onredelivery processor counter 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	
mock deadletter 

========================= camel sample_2106 =========================

public void testSendingAndReceivingMessages() throws Exception {	
sending messages 

public void testSendingAndReceivingMessages() throws Exception {	sendLoop(getMessageCount());	
sending messages completed now will assert on their content as well as the order of their receipt 

========================= camel sample_6145 =========================

}	final Exchange original = exchange;	Exchange target = exchange;	if (predicate == null) {	exchange.setProperty(Exchange.LOOP_SIZE, count);	}	while ((predicate != null && doWhile.get()) || (index.get() < count.get())) {	target = prepareExchange(exchange, index.get(), original);	boolean sync = process(target, callback, index, count, doWhile, original);	if (!sync) {	
processing exchangeid is continued being processed asynchronously 

Exchange target = exchange;	if (predicate == null) {	exchange.setProperty(Exchange.LOOP_SIZE, count);	}	while ((predicate != null && doWhile.get()) || (index.get() < count.get())) {	target = prepareExchange(exchange, index.get(), original);	boolean sync = process(target, callback, index, count, doWhile, original);	if (!sync) {	return false;	}	
processing exchangeid is continued being processed synchronously 

target = prepareExchange(exchange, index.get(), original);	boolean sync = process(target, callback, index, count, doWhile, original);	if (!sync) {	return false;	}	if (!continueProcessing(target, "so breaking out of loop", LOG)) {	break;	}	}	ExchangeHelper.copyResults(exchange, target);	
processing complete for exchangeid 

protected boolean process(final Exchange exchange, final AsyncCallback callback, final AtomicInteger index, final AtomicInteger count, final AtomicBoolean doWhile, final Exchange original) {	
loopprocessor iteration 

return;	}	Exchange target = exchange;	while ((predicate != null && doWhile.get()) || (index.get() < count.get())) {	if (!continueProcessing(target, "so breaking out of loop", LOG)) {	break;	}	target = prepareExchange(exchange, index.get(), original);	boolean sync = process(target, callback, index, count, doWhile, original);	if (!sync) {	
processing exchangeid is continued being processed asynchronously 

if (!continueProcessing(target, "so breaking out of loop", LOG)) {	break;	}	target = prepareExchange(exchange, index.get(), original);	boolean sync = process(target, callback, index, count, doWhile, original);	if (!sync) {	return;	}	}	ExchangeHelper.copyResults(exchange, target);	
processing complete for exchangeid 

========================= camel sample_4528 =========================

String topic = endpoint.getConfiguration().getTopic();	if (!endpoint.getConfiguration().isBridgeEndpoint()) {	String headerTopic = exchange.getIn().getHeader(KafkaConstants.TOPIC, String.class);	boolean allowHeader = true;	if (headerTopic != null && endpoint.getConfiguration().isCircularTopicDetection()) {	Endpoint from = exchange.getFromEndpoint();	if (from instanceof KafkaEndpoint) {	String fromTopic = ((KafkaEndpoint) from).getConfiguration().getTopic();	allowHeader = !headerTopic.equals(fromTopic);	if (!allowHeader) {	
circular topic detected from message header cannot send to same topic as the message comes from will use endpoint configured topic 

if (endpoint.getConfiguration().isRecordMetadata()) {	if (exchange.hasOut()) {	exchange.getOut().setHeader(KafkaConstants.KAFKA_RECORDMETA, recordMetadatas);	} else {	exchange.getIn().setHeader(KafkaConstants.KAFKA_RECORDMETA, recordMetadatas);	}	}	while (c.hasNext()) {	ProducerRecord rec = c.next();	if (log.isDebugEnabled()) {	
sending message to topic partition key 

public boolean process(Exchange exchange, AsyncCallback callback) {	try {	Iterator<ProducerRecord> c = createRecorder(exchange);	KafkaProducerCallBack cb = new KafkaProducerCallBack(exchange, callback);	while (c.hasNext()) {	cb.increment();	ProducerRecord rec = c.next();	if (log.isDebugEnabled()) {	
sending message to topic partition key 

public void onCompletion(RecordMetadata recordMetadata, Exception e) {	if (e != null) {	exchange.setException(e);	}	recordMetadatas.add(recordMetadata);	if (count.decrementAndGet() == 0) {	workerPool.submit(new Runnable() {	public void run() {	
all messages sent continue routing 

========================= camel sample_16414 =========================

public void testIrcPrivateMessages() throws Exception {	resultEndpoint = context.getEndpoint("mock:result", MockEndpoint.class);	resultEndpoint.expectedBodiesReceived(expectedBody1, expectedBody2);	resultEndpoint.assertIsSatisfied();	List<Exchange> list = resultEndpoint.getReceivedExchanges();	for (Exchange exchange : list) {	
received exchange headers 

========================= camel sample_12142 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<S3Component> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-s3.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-s3.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1116 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<BindyFixedLengthDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.bindy-fixed.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.bindy-fixed.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_972 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<XmlBeansDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.xmlbeans.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.xmlbeans.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_421 =========================

protected void doStart() throws Exception {	if (isSingleton()) {	
starting producer 

protected void doStart() throws Exception {	if (isSingleton()) {	} else {	
starting producer 

protected void doStop() throws Exception {	if (isSingleton()) {	
stopping producer 

protected void doStop() throws Exception {	if (isSingleton()) {	} else {	
stopping producer 

========================= camel sample_3982 =========================

public void testCopy() throws Exception {	File testFile = uploadTestFile();	String fromFileId = testFile.getId();	File toFile = new File();	toFile.setTitle(UPLOAD_FILE.getName() + "_copy");	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelGoogleDrive.fileId", fromFileId);	headers.put("CamelGoogleDrive.content", toFile);	final File result = requestBodyAndHeaders("direct: assertNotNull("copy result", result);	assertEquals(toFile.getTitle(), result.getTitle());	
copy 

public void testGet() throws Exception {	File testFile = uploadTestFile();	String fileId = testFile.getId();	final File result = requestBody("direct: assertNotNull("get result", result);	
get 

public void testInsert() throws Exception {	File file = new File();	file.setTitle(UPLOAD_FILE.getName());	File result = requestBody("direct: assertNotNull("insert result", result);	
insert 

public void testInsert1() throws Exception {	File result = uploadTestFile();	assertNotNull("insert result", result);	
insert 

public void testPatch() throws Exception {	File file = uploadTestFile();	file.setTitle(UPLOAD_FILE.getName() + "PATCHED");	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelGoogleDrive.fileId", file.getId());	headers.put("CamelGoogleDrive.fields", "title");	headers.put("CamelGoogleDrive.content", file);	File result = requestBodyAndHeaders("direct: assertNotNull("patch result", result);	assertEquals(UPLOAD_FILE.getName() + "PATCHED", result.getTitle());	
patch 

public void testUpdate() throws Exception {	File theTestFile = uploadTestFile();	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelGoogleDrive.fileId", theTestFile.getId());	headers.put("CamelGoogleDrive.content", theTestFile);	File result = requestBodyAndHeaders("direct: assertNotNull("update result", result);	
update 

File testFile = uploadTestFile();	String fileId = testFile.getId();	final File file = requestBody("direct: file.setTitle("camel.png");	java.io.File fileContent = new java.io.File(TEST_UPLOAD_IMG);	FileContent mediaContent = new FileContent(null, fileContent);	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelGoogleDrive.fileId", fileId);	headers.put("CamelGoogleDrive.content", file);	headers.put("CamelGoogleDrive.mediaContent", mediaContent);	File result = requestBodyAndHeaders("direct: assertNotNull("update result", result);	
update 

public void testWatch() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelGoogleDrive.fileId", null);	headers.put("CamelGoogleDrive.contentChannel", null);	final com.google.api.services.drive.Drive.Files.Watch result = requestBodyAndHeaders("direct: assertNotNull("watch result", result);	
watch 

========================= camel sample_15404 =========================

public void testWSHttpCall() throws Exception {	AsyncHttpClient c = new DefaultAsyncHttpClient();	WebSocket websocket = c.prepareGet("ws: new WebSocketUpgradeHandler.Builder() .addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

public void testWSBytesHttpCall() throws Exception {	AsyncHttpClient c = new DefaultAsyncHttpClient();	WebSocket websocket = c.prepareGet("ws: new WebSocketUpgradeHandler.Builder() .addWebSocketListener(new DefaultWebSocketListener() {	public void onMessage(byte[] message) {	received.add(message);	
received 

========================= camel sample_17439 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KubernetesDeploymentsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-deployments.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kubernetes-deployments.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_564 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<HL7DataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.hl7.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.hl7.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_1053 =========================

public void testUsingJavaExtensions() throws Exception {	Object instance = null;	try {	instance = Class.forName("org.apache.xalan.extensions.XPathFunctionResolverImpl").newInstance();	} catch (Throwable e) {	
could not find xalan on the classpath so ignoring this test case 

========================= camel sample_3740 =========================

public void execute(Exchange exchange) throws SmppException {	CancelSm cancelSm = createCancelSm(exchange);	if (log.isDebugEnabled()) {	
canceling a short message for exchange id and message id 

public void execute(Exchange exchange) throws SmppException {	CancelSm cancelSm = createCancelSm(exchange);	if (log.isDebugEnabled()) {	}	try {	session.cancelShortMessage( cancelSm.getServiceType(), cancelSm.getMessageId(), TypeOfNumber.valueOf(cancelSm.getSourceAddrTon()), NumberingPlanIndicator.valueOf(cancelSm.getSourceAddrNpi()), cancelSm.getSourceAddr(), TypeOfNumber.valueOf(cancelSm.getDestAddrTon()), NumberingPlanIndicator.valueOf(cancelSm.getDestAddrNpi()), cancelSm.getDestinationAddress());	} catch (Exception e) {	throw new SmppException(e);	}	if (log.isDebugEnabled()) {	
cancel a short message for exchange id and message id 

========================= camel sample_16910 =========================

public void onFailure(Exchange exchange) {	try {	if (commitStrategy.rollback(exchange)) {	
processing failure of exchange id 

public void onFailure(Exchange exchange) {	try {	if (commitStrategy.rollback(exchange)) {	if (session != null && session.getTransacted()) {	session.rollback();	}	}	} catch (Exception e) {	
failed to rollback the session 

public void onComplete(Exchange exchange) {	try {	if (commitStrategy.commit(exchange)) {	
processing completion of exchange id 

public void onComplete(Exchange exchange) {	try {	if (commitStrategy.commit(exchange)) {	if (session != null && session.getTransacted()) {	session.commit();	}	}	} catch (Exception e) {	
failed to commit the session 

========================= camel sample_12400 =========================

Gauge<?> gauge = endpoint.getRegistry().getGauges().get(endpoint.getMetricsName());	if (gauge instanceof CamelMetricsGauge) {	CamelMetricsGauge camelMetricsGauge = (CamelMetricsGauge)gauge;	if (endpoint.getSubject() != null) {	camelMetricsGauge.setValue(endpoint.getSubject());	}	} else {	if (endpoint.getSubject() != null) {	endpoint.getRegistry().register(endpoint.getMetricsName(), new CamelMetricsGauge(endpoint.getSubject()));	} else {	
no subject found for gauge ignoring 

Object subject = exchange.getIn().getHeader(HEADER_GAUGE_SUBJECT, Object.class);	if (subject != null) {	camelMetricsGauge.setValue(subject);	}	} else {	Object subject = exchange.getIn().getHeader(HEADER_GAUGE_SUBJECT, Object.class);	Object finalSubject = subject != null ? subject : endpoint.getSubject();	if (finalSubject != null) {	registry.register(metricsName, new CamelMetricsGauge(finalSubject));	} else {	
no subject found for gauge ignoring 

========================= camel sample_13704 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<HttpComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.http.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.http.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1268 =========================

final CountDownLatch logonLatch = new CountDownLatch(2);	final CountDownLatch receivedMessageLatch = new CountDownLatch(1);	RouteBuilder routes = new RouteBuilder() {	public void configure() throws Exception {	from("quickfix:examples/inprocess.cfg"). filter(header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.SessionLogon)). bean(new CountDownLatchDecrementer("logon", logonLatch));	from("quickfix:examples/inprocess.cfg"). filter(PredicateBuilder.or( header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.AdminMessageReceived), header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.AppMessageReceived))). bean(new QuickfixjMessageJsonPrinter());	from("quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:MARKET->TRADER"). filter(header(QuickfixjEndpoint.MESSAGE_TYPE_KEY).isEqualTo(MsgType.EMAIL)). bean(new CountDownLatchDecrementer("message", receivedMessageLatch));	}	};	context.addRoutes(routes);	
starting camel context 

}	String marketUri = "quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:TRADER->MARKET";	Producer producer = context.getEndpoint(marketUri).createProducer();	Email email = TestSupport.createEmailMessage("Example");	Exchange exchange = producer.createExchange(ExchangePattern.InOnly);	exchange.getIn().setBody(email);	producer.process(exchange);	if (!receivedMessageLatch.await(5L, TimeUnit.SECONDS)) {	throw new IllegalStateException("Message did not reach market");	}	
message received shutting down camel context 

String marketUri = "quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:TRADER->MARKET";	Producer producer = context.getEndpoint(marketUri).createProducer();	Email email = TestSupport.createEmailMessage("Example");	Exchange exchange = producer.createExchange(ExchangePattern.InOnly);	exchange.getIn().setBody(email);	producer.process(exchange);	if (!receivedMessageLatch.await(5L, TimeUnit.SECONDS)) {	throw new IllegalStateException("Message did not reach market");	}	context.stop();	
example complete 

========================= camel sample_10651 =========================

public void setJmsMessage(Message jmsMessage) {	if (jmsMessage != null) {	try {	setMessageId(jmsMessage.getJMSMessageID());	} catch (JMSException e) {	
unable to retrieve jmsmessageid from jms message 

protected String createMessageId() {	if (jmsMessage == null) {	
no javax jms message set so generating a new message id 

========================= camel sample_12396 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	
mock exception 

========================= camel sample_10201 =========================

prop.setProperty(StdSchedulerFactory.PROP_SCHED_INTERRUPT_JOBS_ON_SHUTDOWN, "true");	}	if (enableJmx && !prop.containsKey("org.quartz.scheduler.jmx.export")) {	prop.put("org.quartz.scheduler.jmx.export", "true");	LOG.info("Setting org.quartz.scheduler.jmx.export=true to ensure QuartzScheduler(s) will be enlisted in JMX.");	}	answer = new StdSchedulerFactory(prop);	}	if (LOG.isDebugEnabled()) {	String name = prop.getProperty(StdSchedulerFactory.PROP_SCHED_INSTANCE_NAME);	
creating schedulerfactory with properties 

private Properties loadProperties() throws SchedulerException {	Properties answer = getProperties();	if (answer == null && getPropertiesFile() != null) {	
loading quartz properties file from 

protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {	Integer startDelayedSeconds = getAndRemoveParameter(parameters, "startDelayedSeconds", Integer.class);	if (startDelayedSeconds != null) {	if (this.startDelayedSeconds != 0 && !(this.startDelayedSeconds == startDelayedSeconds)) {	
a quartz job is already configured with a different startdelayedseconds configuration all quartz jobs must share the same startdelayedseconds configuration cannot apply the startdelayedseconds configuration 

private void createAndInitScheduler() throws SchedulerException {	
create and initializing scheduler 

protected void doStop() throws Exception {	super.doStop();	if (scheduler != null) {	if (isInterruptJobsOnShutdown()) {	
shutting down scheduler will interrupts jobs to shutdown quicker 

protected void doStop() throws Exception {	super.doStop();	if (scheduler != null) {	if (isInterruptJobsOnShutdown()) {	scheduler.shutdown(false);	scheduler = null;	} else {	AtomicInteger number = (AtomicInteger) scheduler.getContext().get(QuartzConstants.QUARTZ_CAMEL_JOBS_COUNT);	if (number != null && number.get() > 0) {	
cannot shutdown scheduler as there are still jobs registered 

protected void doStop() throws Exception {	super.doStop();	if (scheduler != null) {	if (isInterruptJobsOnShutdown()) {	scheduler.shutdown(false);	scheduler = null;	} else {	AtomicInteger number = (AtomicInteger) scheduler.getContext().get(QuartzConstants.QUARTZ_CAMEL_JOBS_COUNT);	if (number != null && number.get() > 0) {	} else {	
shutting down scheduler will wait for all jobs to complete first 

public void onCamelContextStarted(CamelContext context, boolean alreadyStarted) throws Exception {	if (scheduler == null) {	createAndInitScheduler();	} else {	storeCamelContextInQuartzContext();	}	if (!autoStartScheduler) {	
not starting scheduler because autostartscheduler is set to false 

public void onCamelContextStarted(CamelContext context, boolean alreadyStarted) throws Exception {	if (scheduler == null) {	createAndInitScheduler();	} else {	storeCamelContextInQuartzContext();	}	if (!autoStartScheduler) {	} else {	if (startDelayedSeconds > 0) {	if (scheduler.isStarted()) {	
the scheduler has already started cannot apply the startdelayedseconds configuration 

if (!autoStartScheduler) {	} else {	if (startDelayedSeconds > 0) {	if (scheduler.isStarted()) {	} else {	LOG.info("Starting scheduler with startDelayedSeconds={}", startDelayedSeconds);	scheduler.startDelayed(startDelayedSeconds);	}	} else {	if (scheduler.isStarted()) {	
the scheduler has already been started 

} else {	if (startDelayedSeconds > 0) {	if (scheduler.isStarted()) {	} else {	LOG.info("Starting scheduler with startDelayedSeconds={}", startDelayedSeconds);	scheduler.startDelayed(startDelayedSeconds);	}	} else {	if (scheduler.isStarted()) {	} else {	
starting scheduler 

========================= camel sample_15003 =========================

public static String getSystemProperty(String name, String defaultValue) {	try {	return System.getProperty(name, defaultValue);	} catch (Exception e) {	if (LOG.isDebugEnabled()) {	
caught security exception accessing system property will use default value 

clazz = doLoadClass(name, Thread.currentThread().getContextClassLoader());	}	if (clazz == null) {	clazz = doLoadClass(name, loader);	}	if (clazz == null) {	clazz = doLoadClass(name, ObjectHelper.class.getClassLoader());	}	if (clazz == null) {	if (needToWarn) {	
cannot find class 

}	if (clazz == null) {	clazz = doLoadClass(name, loader);	}	if (clazz == null) {	clazz = doLoadClass(name, ObjectHelper.class.getClassLoader());	}	if (clazz == null) {	if (needToWarn) {	} else {	
cannot find class 

private static Class<?> doLoadClass(String name, ClassLoader loader) {	ObjectHelper.notEmpty(name, "name");	if (loader == null) {	return null;	}	try {	
loading class using classloader 

private static Class<?> doLoadClass(String name, ClassLoader loader) {	ObjectHelper.notEmpty(name, "name");	if (loader == null) {	return null;	}	try {	return loader.loadClass(name);	} catch (ClassNotFoundException e) {	if (LOG.isTraceEnabled()) {	
cannot load class using classloader 

========================= camel sample_4343 =========================

private synchronized void stopConsumer(Route route) {	try {	if (!suspendedRoutes.contains(route)) {	
stopping consumer for 

private synchronized void startAllStoppedConsumers() {	try {	for (Route route : suspendedRoutes) {	
starting consumer for 

========================= camel sample_9571 =========================

public <T> T convertTo(Class<T> type, Exchange exchange, Object value) throws TypeConversionException {	CamelContext context = exchange != null ? exchange.getContext() : null;	ClassLoader appcl = context != null ? context.getApplicationContextClassLoader() : null;	T result;	ClassLoader tccl = Thread.currentThread().getContextClassLoader();	try {	if (appcl != null && appcl != tccl) {	
switching tccl to 

Class<?> sourceType = value.getClass();	ClassMappingMetadata metadata = getClassMappingMetadata(sourceType, type);	if (metadata != null) {	mapId = metadata.getMapId();	}	}	result = mapper.map(value, type, mapId);	} finally {	if (appcl != null && appcl != tccl) {	Thread.currentThread().setContextClassLoader(tccl);	
restored tccl to 

========================= camel sample_9434 =========================

int actualExchanges = exchangeCounter.decrementAndGet();	if (actualExchanges == 0) {	try {	closeFileInputStreams();	if (outputStream != null) {	outputStream.close();	}	try {	cleanUpTempFile();	} catch (Exception e) {	
error deleting temporary cache file this exception will be ignored 

try {	closeFileInputStreams();	if (outputStream != null) {	outputStream.close();	}	try {	cleanUpTempFile();	} catch (Exception e) {	}	} catch (Exception e) {	
error closing streams this exception will be ignored 

========================= camel sample_4206 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<RssDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.rss.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.rss.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_499 =========================

protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {	in.markReaderIndex();	boolean frameDecoded = false;	try {	if (!in.isReadable(FRAME_HEADER_LENGTH)) {	return;	}	int frameVersion = in.readUnsignedByte();	sessionHandler.versionRead(frameVersion);	int frameType = in.readUnsignedByte();	
received a lumberjack frame of type 

case TYPE_DATA: frameDecoded = handleDataFrame(in, out);	break;	case TYPE_WINDOW: frameDecoded = handleWindowFrame(in);	break;	case TYPE_COMPRESS: frameDecoded = handleCompressedFrame(ctx, in, out);	break;	default: throw new RuntimeException("Unsupported frame type=" + frameType);	}	} finally {	if (!frameDecoded) {	
not enough data to decode a complete frame retry when more data is available reader index was 

========================= camel sample_7580 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<MimeMultipartDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.mime-multipart.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.mime-multipart.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_724 =========================

public void test() throws Exception {	String result = template.requestBody("direct:out", "hello", String.class);	Assert.assertEquals("hello", result);	
sleeping for seconds and no netty exception should occur 

========================= camel sample_10153 =========================

protected int poll() throws Exception {	CurrencyPair pair = getEndpoint().getConfiguration().getCurrencyPair();	
going to execute ticker query for 

========================= camel sample_8462 =========================

private String getPropertyValue(String key, String input) {	if (propertiesComponent != null) {	for (PropertiesFunction function : propertiesComponent.getFunctions().values()) {	String token = function.getName() + ":";	if (key.startsWith(token)) {	String remainder = key.substring(token.length());	
property with key is applied by function 

if (propertiesComponent != null) {	for (PropertiesFunction function : propertiesComponent.getFunctions().values()) {	String token = function.getName() + ":";	if (key.startsWith(token)) {	String remainder = key.substring(token.length());	String value = function.apply(remainder);	if (value == null) {	throw new IllegalArgumentException("Property with key [" + key + "] using function [" + function.getName() + "]" + " returned null value which is not allowed, from input: " + input);	} else {	if (log.isDebugEnabled()) {	
property with key applied by function 

}	String defaultValue = null;	if (defaultFallbackEnabled && key.contains(GET_OR_ELSE_TOKEN)) {	defaultValue = ObjectHelper.after(key, GET_OR_ELSE_TOKEN);	key = ObjectHelper.before(key, GET_OR_ELSE_TOKEN);	}	String augmentedKey = getAugmentedKey(key);	boolean shouldFallback = fallbackToUnaugmentedProperty && !key.equals(augmentedKey);	String value = doGetPropertyValue(augmentedKey);	if (value == null && shouldFallback) {	
property with key not found attempting with unaugmented key 

defaultValue = ObjectHelper.after(key, GET_OR_ELSE_TOKEN);	key = ObjectHelper.before(key, GET_OR_ELSE_TOKEN);	}	String augmentedKey = getAugmentedKey(key);	boolean shouldFallback = fallbackToUnaugmentedProperty && !key.equals(augmentedKey);	String value = doGetPropertyValue(augmentedKey);	if (value == null && shouldFallback) {	value = doGetPropertyValue(key);	}	if (value == null && defaultValue != null) {	
property with key not found using default value 

private String getAugmentedKey(String key) {	String augmentedKey = key;	if (propertyPrefix != null) {	
augmenting property key with prefix 

private String getAugmentedKey(String key) {	String augmentedKey = key;	if (propertyPrefix != null) {	augmentedKey = propertyPrefix + augmentedKey;	}	if (propertySuffix != null) {	
augmenting property key with suffix 

private String doGetPropertyValue(String key) {	if (ObjectHelper.isEmpty(key)) {	return parseProperty(key, null, properties);	}	String value = null;	int mode = propertiesComponent != null ? propertiesComponent.getSystemPropertiesMode() : PropertiesComponent.SYSTEM_PROPERTIES_MODE_OVERRIDE;	if (mode == PropertiesComponent.SYSTEM_PROPERTIES_MODE_OVERRIDE) {	value = System.getProperty(key);	if (value != null) {	
found a jvm system property with value to be used 

String value = null;	int mode = propertiesComponent != null ? propertiesComponent.getSystemPropertiesMode() : PropertiesComponent.SYSTEM_PROPERTIES_MODE_OVERRIDE;	if (mode == PropertiesComponent.SYSTEM_PROPERTIES_MODE_OVERRIDE) {	value = System.getProperty(key);	if (value != null) {	}	}	if (value == null && properties != null) {	value = properties.getProperty(key);	if (value != null) {	
found property with value to be used 

}	}	if (value == null && properties != null) {	value = properties.getProperty(key);	if (value != null) {	}	}	if (value == null && mode == PropertiesComponent.SYSTEM_PROPERTIES_MODE_FALLBACK) {	value = System.getProperty(key);	if (value != null) {	
found a jvm system property with value to be used 

========================= camel sample_4912 =========================

public void onContextStop(CamelContext context) {	
camelcontext has been shutdown triggering shutdown of the jvm 

========================= camel sample_5600 =========================

protected AggregationStrategyMethodInfo createMethodInfo() {	Class<?>[] parameterTypes = method.getParameterTypes();	int size = parameterTypes.length;	if (LOG.isTraceEnabled()) {	
creating methodinfo for class method having parameters 

========================= camel sample_4441 =========================

public Olingo2SampleServer(int port, String resourcePath) {	this.port = port;	server = new org.eclipse.jetty.server.Server(port);	WebAppContext webappcontext = new WebAppContext();	String contextPath = null;	try {	contextPath = Olingo2SampleServer.class.getResource(resourcePath).toURI().getPath();	} catch (URISyntaxException e) {	
unable to read the resource at 

public void start() throws Exception {	server.start();	
olingo sample server started at port 

static void generateSampleData(String serviceUrl) throws IOException {	try {	Class<?> clz = Class.forName("org.apache.olingo.sample.annotation.util.AnnotationSampleDataGenerator");	Method m = clz.getMethod("generateData", String.class);	m.invoke(null, serviceUrl);	} catch (Throwable t) {	
unable to load the required sample class 

========================= camel sample_14540 =========================

public PollingConsumer createPollingConsumer() throws Exception {	if (LOG.isDebugEnabled()) {	
creating eventdrivenpollingconsumer with queuesize blockwhenfull blocktimeout 

========================= camel sample_4011 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<GrpcComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.grpc.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.grpc.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1213 =========================

public void readRequest(HttpServletRequest request, HttpMessage message) {	
readrequest 

String rawPath = getRawPath(request);	headers.put(Exchange.HTTP_METHOD, request.getMethod());	headers.put(Exchange.HTTP_QUERY, request.getQueryString());	headers.put(Exchange.HTTP_URL, request.getRequestURL().toString());	headers.put(Exchange.HTTP_URI, request.getRequestURI());	headers.put(Exchange.HTTP_PATH, rawPath);	if (!headers.containsKey(Exchange.CONTENT_TYPE)) {	headers.put(Exchange.CONTENT_TYPE, request.getContentType());	}	if (LOG.isTraceEnabled()) {	
http method 

String rawPath = getRawPath(request);	headers.put(Exchange.HTTP_METHOD, request.getMethod());	headers.put(Exchange.HTTP_QUERY, request.getQueryString());	headers.put(Exchange.HTTP_URL, request.getRequestURL().toString());	headers.put(Exchange.HTTP_URI, request.getRequestURI());	headers.put(Exchange.HTTP_PATH, rawPath);	if (!headers.containsKey(Exchange.CONTENT_TYPE)) {	headers.put(Exchange.CONTENT_TYPE, request.getContentType());	}	if (LOG.isTraceEnabled()) {	
http query 

String rawPath = getRawPath(request);	headers.put(Exchange.HTTP_METHOD, request.getMethod());	headers.put(Exchange.HTTP_QUERY, request.getQueryString());	headers.put(Exchange.HTTP_URL, request.getRequestURL().toString());	headers.put(Exchange.HTTP_URI, request.getRequestURI());	headers.put(Exchange.HTTP_PATH, rawPath);	if (!headers.containsKey(Exchange.CONTENT_TYPE)) {	headers.put(Exchange.CONTENT_TYPE, request.getContentType());	}	if (LOG.isTraceEnabled()) {	
http url 

String rawPath = getRawPath(request);	headers.put(Exchange.HTTP_METHOD, request.getMethod());	headers.put(Exchange.HTTP_QUERY, request.getQueryString());	headers.put(Exchange.HTTP_URL, request.getRequestURL().toString());	headers.put(Exchange.HTTP_URI, request.getRequestURI());	headers.put(Exchange.HTTP_PATH, rawPath);	if (!headers.containsKey(Exchange.CONTENT_TYPE)) {	headers.put(Exchange.CONTENT_TYPE, request.getContentType());	}	if (LOG.isTraceEnabled()) {	
http uri 

String rawPath = getRawPath(request);	headers.put(Exchange.HTTP_METHOD, request.getMethod());	headers.put(Exchange.HTTP_QUERY, request.getQueryString());	headers.put(Exchange.HTTP_URL, request.getRequestURL().toString());	headers.put(Exchange.HTTP_URI, request.getRequestURI());	headers.put(Exchange.HTTP_PATH, rawPath);	if (!headers.containsKey(Exchange.CONTENT_TYPE)) {	headers.put(Exchange.CONTENT_TYPE, request.getContentType());	}	if (LOG.isTraceEnabled()) {	
http path 

String rawPath = getRawPath(request);	headers.put(Exchange.HTTP_METHOD, request.getMethod());	headers.put(Exchange.HTTP_QUERY, request.getQueryString());	headers.put(Exchange.HTTP_URL, request.getRequestURL().toString());	headers.put(Exchange.HTTP_URI, request.getRequestURI());	headers.put(Exchange.HTTP_PATH, rawPath);	if (!headers.containsKey(Exchange.CONTENT_TYPE)) {	headers.put(Exchange.CONTENT_TYPE, request.getContentType());	}	if (LOG.isTraceEnabled()) {	
http content type 

protected void readHeaders(HttpServletRequest request, HttpMessage message) {	
readheaders 

protected void readBody(HttpServletRequest request, HttpMessage message) {	
readbody 

protected void readFormUrlEncodedBody(HttpServletRequest request, HttpMessage message) throws UnsupportedEncodingException {	
readformurlencodedbody 

protected void readFormUrlEncodedBody(HttpServletRequest request, HttpMessage message) throws UnsupportedEncodingException {	if (mapHttpMessageBody && mapHttpMessageHeaders) {	
http method with content type 

if (is != null) {	ServletOutputStream os = response.getOutputStream();	if (!checkChunked(message, exchange)) {	CachedOutputStream stream = new CachedOutputStream(exchange);	try {	int len = copyStream(is, stream, response.getBufferSize());	response.setContentLength(len);	OutputStream current = stream.getCurrentStream();	if (current instanceof ByteArrayOutputStream) {	if (LOG.isDebugEnabled()) {	
streaming direct response in non chunked mode with content length 

int len = copyStream(is, stream, response.getBufferSize());	response.setContentLength(len);	OutputStream current = stream.getCurrentStream();	if (current instanceof ByteArrayOutputStream) {	if (LOG.isDebugEnabled()) {	}	ByteArrayOutputStream bos = (ByteArrayOutputStream) current;	bos.writeTo(os);	} else {	if (LOG.isDebugEnabled()) {	
streaming response in non chunked mode with content length and buffer size 

} else {	if (LOG.isDebugEnabled()) {	}	copyStream(stream.getInputStream(), os, len);	}	} finally {	IOHelper.close(is, os);	}	} else {	if (LOG.isDebugEnabled()) {	
streaming response in chunked mode with buffer size 

copyStream(is, os, response.getBufferSize());	}	} else {	String data = message.getBody(String.class);	if (data != null) {	String charset = IOHelper.getCharsetName(exchange, true);	final int dataByteLength = data.getBytes(charset).length;	response.setCharacterEncoding(charset);	response.setContentLength(dataByteLength);	if (LOG.isDebugEnabled()) {	
writing response in non chunked mode as plain text with content length and buffer size 

byte[] bytes;	try {	bytes = message.getMandatoryBody(byte[].class);	} catch (InvalidPayloadException e) {	throw ObjectHelper.wrapRuntimeCamelException(e);	}	byte[] data = GZIPHelper.compressGZIP(bytes);	ServletOutputStream os = response.getOutputStream();	try {	if (LOG.isDebugEnabled()) {	
streaming response as gzip in non chunked mode with content length and buffer size 

public Object parseBody(HttpMessage httpMessage) throws IOException {	HttpServletRequest request = httpMessage.getRequest();	int len = request.getContentLength();	
httpservletrequest content length 

========================= camel sample_12882 =========================

protected RouteContainer assertParseAsJaxb(String uri) throws JAXBException {	Object value = parseUri(uri);	RouteContainer context = assertIsInstanceOf(RouteContainer.class, value);	
found 

protected RestContainer assertParseRestAsJaxb(String uri) throws JAXBException {	Object value = parseUri(uri);	RestContainer context = assertIsInstanceOf(RestContainer.class, value);	
found 

========================= camel sample_3691 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<CryptoDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.crypto.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.crypto.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_661 =========================

protected void before() throws Throwable {	
starting up mock aws daemon 

protected void after() {	
shutting down mock aws daemon 

protected void after() {	socketListener.close();	executorService.shutdown();	try {	if (!executorService.awaitTermination(10, TimeUnit.SECONDS)) {	executorService.shutdownNow();	if (!executorService.awaitTermination(10, TimeUnit.SECONDS)) {	
could not terminate udp server 

public void run() {	try {	
starting udp socket listening on port 

public void run() {	try {	serverSocket = new DatagramSocket(2000);	StringBuilder sb = new StringBuilder();	while (!done) {	byte[] receiveData = new byte[2048];	DatagramPacket receivedPacket = new DatagramPacket(receiveData, receiveData.length);	serverSocket.receive(receivedPacket);	
receiving udp data 

byte[] receiveData = new byte[2048];	DatagramPacket receivedPacket = new DatagramPacket(receiveData, receiveData.length);	serverSocket.receive(receivedPacket);	sb.append(new String(receivedPacket.getData()));	String locSegment = null;	try {	String raw = sb.toString().trim();	String[] segments = raw.split("\\n");	for (String segment : segments) {	locSegment = segment;	
processing received segment 

serverSocket.receive(receivedPacket);	sb.append(new String(receivedPacket.getData()));	String locSegment = null;	try {	String raw = sb.toString().trim();	String[] segments = raw.split("\\n");	for (String segment : segments) {	locSegment = segment;	if (!"".equals(segment)) {	if (!segment.endsWith("}") || StringUtils.countMatches(segment, "{") != StringUtils.countMatches(segment, "}") || StringUtils.countMatches(segment, "[") != StringUtils.countMatches(segment, "]")) {	
skipping incomplete content 

try {	String raw = sb.toString().trim();	String[] segments = raw.split("\\n");	for (String segment : segments) {	locSegment = segment;	if (!"".equals(segment)) {	if (!segment.endsWith("}") || StringUtils.countMatches(segment, "{") != StringUtils.countMatches(segment, "}") || StringUtils.countMatches(segment, "[") != StringUtils.countMatches(segment, "]")) {	continue;	}	if (segment.contains("format") && segment.contains("version")) {	
skipping format and version json 

String raw = sb.toString().trim();	String[] segments = raw.split("\\n");	for (String segment : segments) {	locSegment = segment;	if (!"".equals(segment)) {	if (!segment.endsWith("}") || StringUtils.countMatches(segment, "{") != StringUtils.countMatches(segment, "}") || StringUtils.countMatches(segment, "[") != StringUtils.countMatches(segment, "]")) {	continue;	}	if (segment.contains("format") && segment.contains("version")) {	} else {	
converting segment to a java object 

String raw = sb.toString().trim();	String[] segments = raw.split("\\n");	for (String segment : segments) {	locSegment = segment;	if (!"".equals(segment)) {	if (!segment.endsWith("}") || StringUtils.countMatches(segment, "{") != StringUtils.countMatches(segment, "}") || StringUtils.countMatches(segment, "[") != StringUtils.countMatches(segment, "]")) {	continue;	}	if (segment.contains("format") && segment.contains("version")) {	} else {	
original json content 

}	testTrace.withSegment(convertData(json));	receivedTraces.put(traceId, testTrace);	}	sb.delete(0, segment.length());	if (sb.length() > 1 && sb.charAt(0) == '\n') {	sb.deleteCharAt(0);	}	}	}	
item received json content raw 

testTrace.withSegment(convertData(json));	receivedTraces.put(traceId, testTrace);	}	sb.delete(0, segment.length());	if (sb.length() > 1 && sb.charAt(0) == '\n') {	sb.deleteCharAt(0);	}	}	}	} catch (Exception jsonEx) {	
could not convert segment to a java object 

sb.delete(0, segment.length());	if (sb.length() > 1 && sb.charAt(0) == '\n') {	sb.deleteCharAt(0);	}	}	}	} catch (Exception jsonEx) {	}	}	} catch (SocketException sex) {	
udp socket closed 

if (sb.length() > 1 && sb.charAt(0) == '\n') {	sb.deleteCharAt(0);	}	}	}	} catch (Exception jsonEx) {	}	}	} catch (SocketException sex) {	} catch (Exception ex) {	
udp socket failed due to 

private void close() {	done = true;	if (null != serverSocket) {	
shutting down udp socket 

========================= camel sample_8177 =========================

public void run() {	try {	runMethodWithoutCatchingExceptions();	} catch (NoSuchMethodException e) {	
class does not have a main method 

public void run() {	try {	runMethodWithoutCatchingExceptions();	} catch (NoSuchMethodException e) {	} catch (IllegalAccessException e) {	
failed to run reason 

public void run() {	try {	runMethodWithoutCatchingExceptions();	} catch (NoSuchMethodException e) {	} catch (IllegalAccessException e) {	} catch (InvocationTargetException e) {	Throwable throwable = e.getTargetException();	
failed to run reason 

========================= camel sample_16341 =========================

public void write(List<? extends I> items) throws Exception {	for (I item : items) {	
writing item 

public void write(List<? extends I> items) throws Exception {	for (I item : items) {	producerTemplate.sendBody(endpointUri, item);	
wrote item 

========================= camel sample_12752 =========================

protected RouteBuilder createRouteBuilder() {	mllpClient.setMllpHost("localhost");	mllpClient.setMllpPort(AvailablePortFinder.getNextAvailable());	return new RouteBuilder() {	int connectTimeout = 500;	int responseTimeout = 5000;	public void configure() throws Exception {	String routeId = "mllp-test-receiver-route";	
test route complete 

protected RouteBuilder createRouteBuilder() {	mllpClient.setMllpHost("localhost");	mllpClient.setMllpPort(AvailablePortFinder.getNextAvailable());	return new RouteBuilder() {	int connectTimeout = 500;	int responseTimeout = 5000;	public void configure() throws Exception {	String routeId = "mllp-test-receiver-route";	
test route failed 

protected RouteBuilder createRouteBuilder() {	mllpClient.setMllpHost("localhost");	mllpClient.setMllpPort(AvailablePortFinder.getNextAvailable());	return new RouteBuilder() {	int connectTimeout = 500;	int responseTimeout = 5000;	public void configure() throws Exception {	String routeId = "mllp-test-receiver-route";	
mllp mllpclient getmllphost mllpclient getmllpport connecttimeout responsetimeout routeid routeid log logginglevel info routeid message to target routeid consumer log logginglevel info routeid message to result 

========================= camel sample_13840 =========================

models.add(model);	}	}	Collections.sort(models, new EipComparator());	long deprecated = models.stream() .filter(EipModel::isDeprecated) .count();	File file = new File(readmeCoreDir, "readme-eip.adoc");	boolean exists = file.exists();	String changed = templateEips(models, deprecated);	boolean updated = updateEips(file, changed);	if (updated) {	
updated readme eip adoc file 

}	}	Collections.sort(models, new EipComparator());	long deprecated = models.stream() .filter(EipModel::isDeprecated) .count();	File file = new File(readmeCoreDir, "readme-eip.adoc");	boolean exists = file.exists();	String changed = templateEips(models, deprecated);	boolean updated = updateEips(file, changed);	if (updated) {	} else if (exists) {	
no changes to readme eip adoc file 

}	Collections.sort(models, new EipComparator());	long deprecated = models.stream() .filter(EipModel::isDeprecated) .count();	File file = new File(readmeCoreDir, "readme-eip.adoc");	boolean exists = file.exists();	String changed = templateEips(models, deprecated);	boolean updated = updateEips(file, changed);	if (updated) {	} else if (exists) {	} else {	
no readme eip adoc file 

File file;	if (coreOnly) {	file = new File(readmeCoreDir, "readme.adoc");	} else {	file = new File(readmeComponentsDir, "readme.adoc");	}	boolean exists = file.exists();	String changed = templateComponents(components, count, deprecated);	boolean updated = updateComponents(file, changed);	if (updated) {	
updated readme adoc file 

if (coreOnly) {	file = new File(readmeCoreDir, "readme.adoc");	} else {	file = new File(readmeComponentsDir, "readme.adoc");	}	boolean exists = file.exists();	String changed = templateComponents(components, count, deprecated);	boolean updated = updateComponents(file, changed);	if (updated) {	} else if (exists) {	
no changes to readme adoc file 

file = new File(readmeCoreDir, "readme.adoc");	} else {	file = new File(readmeComponentsDir, "readme.adoc");	}	boolean exists = file.exists();	String changed = templateComponents(components, count, deprecated);	boolean updated = updateComponents(file, changed);	if (updated) {	} else if (exists) {	} else {	
no readme adoc file 

others.add(model);	}	Collections.sort(others, new OtherComparator());	int count = others.stream() .map(OtherModel::getArtifactId) .collect(toSet()).size();	long deprecated = others.stream() .filter(o -> "true".equals(o.getDeprecated())) .count();	File file = new File(readmeComponentsDir, "readme.adoc");	boolean exists = file.exists();	String changed = templateOthers(others, count, deprecated);	boolean updated = updateOthers(file, changed);	if (updated) {	
updated readme adoc file 

}	Collections.sort(others, new OtherComparator());	int count = others.stream() .map(OtherModel::getArtifactId) .collect(toSet()).size();	long deprecated = others.stream() .filter(o -> "true".equals(o.getDeprecated())) .count();	File file = new File(readmeComponentsDir, "readme.adoc");	boolean exists = file.exists();	String changed = templateOthers(others, count, deprecated);	boolean updated = updateOthers(file, changed);	if (updated) {	} else if (exists) {	
no changes to readme adoc file 

Collections.sort(others, new OtherComparator());	int count = others.stream() .map(OtherModel::getArtifactId) .collect(toSet()).size();	long deprecated = others.stream() .filter(o -> "true".equals(o.getDeprecated())) .count();	File file = new File(readmeComponentsDir, "readme.adoc");	boolean exists = file.exists();	String changed = templateOthers(others, count, deprecated);	boolean updated = updateOthers(file, changed);	if (updated) {	} else if (exists) {	} else {	
no readme adoc file 

File file;	if (coreOnly) {	file = new File(readmeCoreDir, "readme.adoc");	} else {	file = new File(readmeComponentsDir, "readme.adoc");	}	boolean exists = file.exists();	String changed = templateDataFormats(dataFormats, count, deprecated);	boolean updated = updateDataFormats(file, changed);	if (updated) {	
updated readme adoc file 

if (coreOnly) {	file = new File(readmeCoreDir, "readme.adoc");	} else {	file = new File(readmeComponentsDir, "readme.adoc");	}	boolean exists = file.exists();	String changed = templateDataFormats(dataFormats, count, deprecated);	boolean updated = updateDataFormats(file, changed);	if (updated) {	} else if (exists) {	
no changes to readme adoc file 

file = new File(readmeCoreDir, "readme.adoc");	} else {	file = new File(readmeComponentsDir, "readme.adoc");	}	boolean exists = file.exists();	String changed = templateDataFormats(dataFormats, count, deprecated);	boolean updated = updateDataFormats(file, changed);	if (updated) {	} else if (exists) {	} else {	
no readme adoc file 

File file;	if (coreOnly) {	file = new File(readmeCoreDir, "readme.adoc");	} else {	file = new File(readmeComponentsDir, "readme.adoc");	}	boolean exists = file.exists();	String changed = templateLanguages(languages, count, deprecated);	boolean updated = updateLanguages(file, changed);	if (updated) {	
updated readme adoc file 

if (coreOnly) {	file = new File(readmeCoreDir, "readme.adoc");	} else {	file = new File(readmeComponentsDir, "readme.adoc");	}	boolean exists = file.exists();	String changed = templateLanguages(languages, count, deprecated);	boolean updated = updateLanguages(file, changed);	if (updated) {	} else if (exists) {	
no changes to readme adoc file 

file = new File(readmeCoreDir, "readme.adoc");	} else {	file = new File(readmeComponentsDir, "readme.adoc");	}	boolean exists = file.exists();	String changed = templateLanguages(languages, count, deprecated);	boolean updated = updateLanguages(file, changed);	if (updated) {	} else if (exists) {	} else {	
no readme adoc file 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
cannot find markers in file 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
add the following markers 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
t getlog warn 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
cannot find markers in file 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
add the following markers 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
t getlog warn 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
cannot find markers in file 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
add the following markers 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
t getlog warn 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
cannot find markers in file 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
add the following markers 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
t getlog warn 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
cannot find markers in file 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
add the following markers 

String existing = StringHelper.between(text, " if (existing != null) {	existing = existing.trim();	changed = changed.trim();	if (existing.equals(changed)) {	return false;	} else {	String before = StringHelper.before(text, " String after = StringHelper.after(text, " text = before + " writeText(file, text);	return true;	}	} else {	
t getlog warn 

========================= camel sample_118 =========================

SyndFeed oldFeed = oldExchange.getIn().getBody(SyndFeed.class);	SyndFeed newFeed = newExchange.getIn().getBody(SyndFeed.class);	if (oldFeed != null && newFeed != null) {	List<SyndEntryImpl> oldEntries = CastUtils.cast(oldFeed.getEntries());	List<SyndEntryImpl> newEntries = CastUtils.cast(newFeed.getEntries());	List<SyndEntryImpl> mergedList = new ArrayList<SyndEntryImpl>(oldEntries.size() + newEntries.size());	mergedList.addAll(oldEntries);	mergedList.addAll(newEntries);	oldFeed.setEntries(mergedList);	} else {	
could not merge exchanges one body was null 

========================= camel sample_12302 =========================

} finally {	deleteTestFile();	}	MockEndpoint mockEndpoint = getMockEndpoint("mock:boxEvents");	mockEndpoint.expectedMinimumMessageCount(2);	mockEndpoint.setResultWaitTime(TimeUnit.MILLISECONDS.convert(30, TimeUnit.SECONDS));	mockEndpoint.assertIsSatisfied();	final List<Exchange> exchanges = mockEndpoint.getExchanges();	assertNotNull("poll result", exchanges);	assertFalse("poll result", exchanges.isEmpty());	
poll result 

========================= camel sample_17415 =========================

exchange.setException(e);	logTransactionRollback(redelivered, ids, e, false);	} finally {	exchange.getUnitOfWork().endTransactedBy(transactionKey);	}	Boolean onlyLast = (Boolean) exchange.removeProperty(Exchange.ROLLBACK_ONLY_LAST);	if (onlyLast != null && onlyLast) {	if (log.isDebugEnabled()) {	Exception cause = exchange.getException();	if (cause != null) {	
transaction rollback redelivered for due exchange was marked for rollbackonlylast and caught 

logTransactionRollback(redelivered, ids, e, false);	} finally {	exchange.getUnitOfWork().endTransactedBy(transactionKey);	}	Boolean onlyLast = (Boolean) exchange.removeProperty(Exchange.ROLLBACK_ONLY_LAST);	if (onlyLast != null && onlyLast) {	if (log.isDebugEnabled()) {	Exception cause = exchange.getException();	if (cause != null) {	} else {	
transaction rollback redelivered for due exchange was marked for rollbackonlylast 

public void run() throws Throwable {	Throwable rce;	processByErrorHandler(exchange);	if (exchange.getException() != null || exchange.isRollbackOnly()) {	if (exchange.getException() != null) {	rce = exchange.getException();	} else {	rce = new TransactionRolledbackException();	}	if (log.isTraceEnabled()) {	
throwing runtime exception to force transaction to rollback on 

public void prepareShutdown(boolean suspendOnly, boolean forced) {	
prepare shutdown on error handler 

========================= camel sample_9859 =========================

protected List<Status> doDirect() throws TwitterException {	
dodirect getmentionstimeline 

========================= camel sample_14239 =========================

public void process(Exchange exchange) throws Exception {	if (endpoint.getConsumer() == null) {	if (endpoint.isFailIfNoConsumers()) {	throw new DirectConsumerNotAvailableException("No consumers available on endpoint: " + endpoint, exchange);	} else {	
message ignored no consumers available on endpoint 

public boolean process(Exchange exchange, AsyncCallback callback) {	if (endpoint.getConsumer() == null) {	if (endpoint.isFailIfNoConsumers()) {	exchange.setException(new DirectConsumerNotAvailableException("No consumers available on endpoint: " + endpoint, exchange));	} else {	
message ignored no consumers available on endpoint 

========================= camel sample_4768 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<AtomixMessagingComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.atomix-messaging.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.atomix-messaging.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1090 =========================

public void marshal(Exchange exchange, Object graph, OutputStream stream) throws Exception {	ObjectHelper.notNull(graph, "The object to marshal must be provided");	List<Map<String, Object>> data = (List<Map<String, Object>>) graph;	if (data.isEmpty()) {	
no data to marshal as the list is empty 

========================= camel sample_14669 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<AMQPComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.amqp.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.amqp.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1244 =========================

return;	}	try {	doHandleDelivery(consumerTag, envelope, properties, body);	} finally {	if (!consumer.getEndpoint().isAutoAck()) {	lock.release();	}	}	} catch (InterruptedException e) {	
thread interrupted 

public void doHandleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {	Exchange exchange = consumer.getEndpoint().createRabbitExchange(envelope, properties, body);	consumer.getEndpoint().getMessageConverter().mergeAmqpProperties(exchange, properties);	boolean sendReply = properties.getReplyTo() != null;	if (sendReply && !exchange.getPattern().isOutCapable()) {	
in an inout capable route 

}	if (tag != null && isChannelOpen()) {	channel.basicCancel(tag);	}	try {	lock.acquire();	if (isChannelOpen()) {	channel.close();	}	} catch (TimeoutException e) {	
timeout occured 

channel.basicCancel(tag);	}	try {	lock.acquire();	if (isChannelOpen()) {	channel.close();	}	} catch (TimeoutException e) {	throw e;	} catch (InterruptedException e1) {	
thread interrupted 

public void handleCancelOk(String consumerTag) {	
received cancelok signal on the rabbitmq channel 

public void handleCancel(String consumerTag) throws IOException {	
received cancel signal on the rabbitmq channel 

public void handleShutdownSignal(String consumerTag, ShutdownSignalException sig) {	
received shutdown signal on the rabbitmq channel 

public void handleShutdownSignal(String consumerTag, ShutdownSignalException sig) {	if (!sig.isInitiatedByApplication()) {	boolean connected = false;	while (!connected && !stopping) {	try {	reconnect();	connected = true;	} catch (IOException | TimeoutException e) {	
unable to obtain a rabbitmq channel will try again 

public void handleRecoverOk(String consumerTag) {	
received recover ok signal on the rabbitmq channel 

public void reconnect() throws IOException, TimeoutException {	if (isChannelOpen()) {	return;	} else if (channel != null && !channel.isOpen() && isAutomaticRecoveryEnabled()) {	throw new IOException("Waiting for channel to re-open.");	} else if (channel == null || !isAutomaticRecoveryEnabled()) {	
attempting to open a new rabbitmq channel 

private Channel openChannel(Connection conn) throws IOException {	
creating channel 

private Channel openChannel(Connection conn) throws IOException {	Channel channel = conn.createChannel();	
created channel 

========================= camel sample_14147 =========================

public CuratorFramework getObject() throws Exception {	
connecting to zookeeper on 

public CuratorFramework getObject() throws Exception {	CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder() .connectString(connectString) .retryPolicy(new ExponentialBackoffRetry(5, 10)) .connectionTimeoutMs(getTimeout());	this.curator = builder.build();	
starting curator 

========================= camel sample_9674 =========================

} else if (org.jsmpp.bean.OptionalParameter.Byte.class.isInstance(optPara)) {	optParams.put(valueOfTag.toString(), Byte.valueOf(((org.jsmpp.bean.OptionalParameter.Byte) optPara).getValue()));	} else if (org.jsmpp.bean.OptionalParameter.Short.class.isInstance(optPara)) {	optParams.put(valueOfTag.toString(), Short.valueOf(((org.jsmpp.bean.OptionalParameter.Short) optPara).getValue()));	} else if (org.jsmpp.bean.OptionalParameter.Int.class.isInstance(optPara)) {	optParams.put(valueOfTag.toString(), Integer.valueOf(((org.jsmpp.bean.OptionalParameter.Int) optPara).getValue()));	} else if (Null.class.isInstance(optPara)) {	optParams.put(valueOfTag.toString(), null);	}	} else {	
skipping optional parameter with tag because it was not recogized 

} else if (org.jsmpp.bean.OptionalParameter.Short.class.isInstance(optPara)) {	optParams.put(valueOfTag.toString(), Short.valueOf(((org.jsmpp.bean.OptionalParameter.Short) optPara).getValue()));	} else if (org.jsmpp.bean.OptionalParameter.Int.class.isInstance(optPara)) {	optParams.put(valueOfTag.toString(), Integer.valueOf(((org.jsmpp.bean.OptionalParameter.Int) optPara).getValue()));	} else if (Null.class.isInstance(optPara)) {	optParams.put(valueOfTag.toString(), null);	}	} else {	}	} catch (IllegalArgumentException e) {	
skipping optional parameter with tag due 

========================= camel sample_16896 =========================

PetStoreComponent connector = new PetStoreComponent();	connector.setCamelContext(camelContext);	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, connector, parameters, false);	connector.setOptions(parameters);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ConnectorCustomizer<PetStoreComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.connector.customizer", "camel.connector.petstore.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.connector.customizer", "camel.connector.petstore.customizer");	if (useCustomizer) {	
configure connector with customizer 

PetStoreComponent connector = new PetStoreComponent(entry.getKey());	connector.setCamelContext(camelContext);	try {	IntrospectionSupport.getProperties(entry.getValue(), parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, connector, parameters, false);	connector.setOptions(parameters);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ConnectorCustomizer<PetStoreComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.connector.customizer", "camel.connector.petstore." + entry.getKey() + ".customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.connector.customizer", "camel.connector.petstore." + entry.getKey() + ".customizer");	if (useCustomizer) {	
configure connector with customizer 

========================= camel sample_46 =========================

LineDelimiter delimiter = getLineDelimiterParameter(configuration.getTextlineDelimiter());	TextLineCodecFactory codecFactory = new TextLineCodecFactory(charset, delimiter);	if (configuration.getEncoderMaxLineLength() > 0) {	codecFactory.setEncoderMaxLineLength(configuration.getEncoderMaxLineLength());	}	if (configuration.getDecoderMaxLineLength() > 0) {	codecFactory.setDecoderMaxLineLength(configuration.getDecoderMaxLineLength());	}	addCodecFactory(config, codecFactory);	if (LOG.isDebugEnabled()) {	
using textlinecodecfactory using encoding line delimiter 

LineDelimiter delimiter = getLineDelimiterParameter(configuration.getTextlineDelimiter());	TextLineCodecFactory codecFactory = new TextLineCodecFactory(charset, delimiter);	if (configuration.getEncoderMaxLineLength() > 0) {	codecFactory.setEncoderMaxLineLength(configuration.getEncoderMaxLineLength());	}	if (configuration.getDecoderMaxLineLength() > 0) {	codecFactory.setDecoderMaxLineLength(configuration.getDecoderMaxLineLength());	}	addCodecFactory(config, codecFactory);	if (LOG.isDebugEnabled()) {	
encoder maximum line length decoder maximum line length 

}	if (configuration.getDecoderMaxLineLength() > 0) {	codecFactory.setDecoderMaxLineLength(configuration.getDecoderMaxLineLength());	}	addCodecFactory(config, codecFactory);	if (LOG.isDebugEnabled()) {	}	} else {	ObjectSerializationCodecFactory codecFactory = new ObjectSerializationCodecFactory();	addCodecFactory(config, codecFactory);	
using objectserializationcodecfactory 

protected void configureDataGramCodecFactory(final String type, final IoServiceConfig config, final MinaConfiguration configuration) {	ProtocolCodecFactory codecFactory = configuration.getCodec();	if (codecFactory == null) {	codecFactory = new MinaUdpProtocolCodecFactory(getCamelContext());	if (LOG.isDebugEnabled()) {	
using codecfactory 

private static Charset getEncodingParameter(String type, MinaConfiguration configuration) {	String encoding = configuration.getEncoding();	if (encoding == null) {	encoding = Charset.defaultCharset().name();	configuration.setEncoding(encoding);	
no encoding parameter using default charset 

========================= camel sample_7685 =========================

type = findComponent(name, context);	if (type == null) {	return null;	}	} catch (NoFactoryAvailableException e) {	return null;	} catch (Exception e) {	throw new IllegalArgumentException("Invalid URI, no Component registered for scheme: " + name, e);	}	if (getLog().isDebugEnabled()) {	
found component via type via 

========================= camel sample_4103 =========================

public void testAmbiguousMethodCallFails() throws Exception {	try {	Object value = template.requestBody("bean:myBean", body);	fail("We should have failed to invoke an ambiguous method but instead got: " + value);	} catch (Exception e) {	
caught expected failure 

========================= camel sample_15490 =========================

public static String evaluate(final String xpath, final String xml) {	JAXPXPathEngine xpathEngine = new JAXPXPathEngine();	xpathEngine.setNamespaceContext(Collections.singletonMap("svrl", Constants.HTTP_PURL_OCLC_ORG_DSDL_SVRL));	try {	return xpathEngine.evaluate(xpath, Input.fromString(xml).build());	} catch (Exception e) {	
failed to apply xpath on xml 

========================= camel sample_11980 =========================

private String sendAndReceiveUdpMessages(String input) throws Exception {	DatagramSocket socket = new DatagramSocket();	InetAddress address = InetAddress.getByName("127.0.0.1");	byte[] data = input.getBytes();	DatagramPacket packet = new DatagramPacket(data, data.length, address, getPort());	
sending data 

private String sendAndReceiveUdpMessages(String input) throws Exception {	DatagramSocket socket = new DatagramSocket();	InetAddress address = InetAddress.getByName("127.0.0.1");	byte[] data = input.getBytes();	DatagramPacket packet = new DatagramPacket(data, data.length, address, getPort());	socket.send(packet);	Thread.sleep(1000);	byte[] buf = new byte[128];	DatagramPacket receive = new DatagramPacket(buf, buf.length, address, getPort());	
receiveing data 

========================= camel sample_11579 =========================

public InfluxDB influxDbBean() throws UnknownHostException {	if (LOG.isDebugEnabled()) {	
creating new instance of a mocked influx db connection 

========================= camel sample_11129 =========================

public void onApplicationEvent(ContextRefreshedEvent event) {	CamelContext camelContext = applicationContext.getBean(CamelContext.class);	if (camelContext.getStatus().isStopped()) {	
post processing camelcontext bean 

if (!abs) {	String name = routesBuilder.getClass().getName();	name = name.replace('.', '/');	String exclude = configurationProperties.getJavaRoutesExcludePattern();	String include = configurationProperties.getJavaRoutesIncludePattern();	boolean match = !"false".equals(include);	if (match && ObjectHelper.isNotEmpty(exclude)) {	String[] parts = exclude.split(",");	for (String part : parts) {	match = !matcher.match(part, name);	
java routesbuilder exclude filter 

match = !matcher.match(part, name);	if (!match) {	break;	}	}	}	if (match && ObjectHelper.isNotEmpty(include)) {	String[] parts = include.split(",");	for (String part : parts) {	match = matcher.match(part, name);	
java routesbuilder include filter 

}	if (match && ObjectHelper.isNotEmpty(include)) {	String[] parts = include.split(",");	for (String part : parts) {	match = matcher.match(part, name);	if (match) {	break;	}	}	}	
java routesbuilder accepted by include exclude filter 

String[] parts = include.split(",");	for (String part : parts) {	match = matcher.match(part, name);	if (match) {	break;	}	}	}	if (match) {	try {	
injecting following route into the camelcontext 

try {	boolean scan = !configurationProperties.getXmlRoutes().equals("false");	if (scan) {	loadXmlRoutes(applicationContext, camelContext, configurationProperties.getXmlRoutes());	}	boolean scanRests = !configurationProperties.getXmlRests().equals("false");	if (scanRests) {	loadXmlRests(applicationContext, camelContext, configurationProperties.getXmlRests());	}	for (CamelContextConfiguration camelContextConfiguration : camelContextConfigurations) {	
camelcontextconfiguration found invoking beforeapplicationstart 

if (scanRests) {	loadXmlRests(applicationContext, camelContext, configurationProperties.getXmlRests());	}	for (CamelContextConfiguration camelContextConfiguration : camelContextConfigurations) {	camelContextConfiguration.beforeApplicationStart(camelContext);	}	if (configurationProperties.isMainRunController()) {	CamelMainRunController controller = new CamelMainRunController(applicationContext, camelContext);	if (configurationProperties.getDurationMaxMessages() > 0 || configurationProperties.getDurationMaxIdleSeconds() > 0) {	if (configurationProperties.getDurationMaxMessages() > 0) {	
camelspringboot will terminate after processing messages 

}	for (CamelContextConfiguration camelContextConfiguration : camelContextConfigurations) {	camelContextConfiguration.beforeApplicationStart(camelContext);	}	if (configurationProperties.isMainRunController()) {	CamelMainRunController controller = new CamelMainRunController(applicationContext, camelContext);	if (configurationProperties.getDurationMaxMessages() > 0 || configurationProperties.getDurationMaxIdleSeconds() > 0) {	if (configurationProperties.getDurationMaxMessages() > 0) {	}	if (configurationProperties.getDurationMaxIdleSeconds() > 0) {	
camelspringboot will terminate after being idle for more seconds 

if (configurationProperties.getDurationMaxMessages() > 0 || configurationProperties.getDurationMaxIdleSeconds() > 0) {	if (configurationProperties.getDurationMaxMessages() > 0) {	}	if (configurationProperties.getDurationMaxIdleSeconds() > 0) {	}	EventNotifier notifier = new MainDurationEventNotifier(camelContext, configurationProperties.getDurationMaxMessages(), configurationProperties.getDurationMaxIdleSeconds(), controller.getCompleted(), controller.getLatch(), true);	ServiceHelper.startService(notifier);	camelContext.getManagementStrategy().addEventNotifier(notifier);	}	if (configurationProperties.getDurationMaxSeconds() > 0) {	
camelspringboot will terminate after seconds 

EventNotifier notifier = new MainDurationEventNotifier(camelContext, configurationProperties.getDurationMaxMessages(), configurationProperties.getDurationMaxIdleSeconds(), controller.getCompleted(), controller.getLatch(), true);	ServiceHelper.startService(notifier);	camelContext.getManagementStrategy().addEventNotifier(notifier);	}	if (configurationProperties.getDurationMaxSeconds() > 0) {	terminateMainControllerAfter(camelContext, configurationProperties.getDurationMaxSeconds(), controller.getCompleted(), controller.getLatch());	}	camelContext.addStartupListener(new StartupListener() {	public void onCamelContextStarted(CamelContext context, boolean alreadyStarted) throws Exception {	if (!alreadyStarted) {	
starting camelmainruncontroller to ensure the main thread keeps running 

public void onCamelContextStarted(CamelContext context, boolean alreadyStarted) throws Exception {	if (!alreadyStarted) {	controller.start();	}	}	});	} else {	if (applicationContext instanceof ConfigurableApplicationContext) {	ConfigurableApplicationContext cac = (ConfigurableApplicationContext) applicationContext;	if (configurationProperties.getDurationMaxSeconds() > 0) {	
camelspringboot will terminate after seconds 

}	});	} else {	if (applicationContext instanceof ConfigurableApplicationContext) {	ConfigurableApplicationContext cac = (ConfigurableApplicationContext) applicationContext;	if (configurationProperties.getDurationMaxSeconds() > 0) {	terminateApplicationContext(cac, camelContext, configurationProperties.getDurationMaxSeconds());	}	if (configurationProperties.getDurationMaxMessages() > 0 || configurationProperties.getDurationMaxIdleSeconds() > 0) {	if (configurationProperties.getDurationMaxMessages() > 0) {	
camelspringboot will terminate after processing messages 

} else {	if (applicationContext instanceof ConfigurableApplicationContext) {	ConfigurableApplicationContext cac = (ConfigurableApplicationContext) applicationContext;	if (configurationProperties.getDurationMaxSeconds() > 0) {	terminateApplicationContext(cac, camelContext, configurationProperties.getDurationMaxSeconds());	}	if (configurationProperties.getDurationMaxMessages() > 0 || configurationProperties.getDurationMaxIdleSeconds() > 0) {	if (configurationProperties.getDurationMaxMessages() > 0) {	}	if (configurationProperties.getDurationMaxIdleSeconds() > 0) {	
camelspringboot will terminate after being idle for more seconds 

ServiceHelper.startService(notifier);	camelContext.getManagementStrategy().addEventNotifier(notifier);	terminateApplicationContext(cac, camelContext, latch);	}	}	}	if (!camelContextConfigurations.isEmpty()) {	camelContext.getManagementStrategy().addEventNotifier(new EventNotifierSupport() {	public void notify(EventObject eventObject) throws Exception {	for (CamelContextConfiguration camelContextConfiguration : camelContextConfigurations) {	
camelcontextconfiguration found invoking afterapplicationstart 

}	}	}	if (!camelContextConfigurations.isEmpty()) {	camelContext.getManagementStrategy().addEventNotifier(new EventNotifierSupport() {	public void notify(EventObject eventObject) throws Exception {	for (CamelContextConfiguration camelContextConfiguration : camelContextConfigurations) {	try {	camelContextConfiguration.afterApplicationStart(camelContext);	} catch (Exception e) {	
error during calling afterapplicationstart due this exception is ignored 

}	public boolean isEnabled(EventObject eventObject) {	return eventObject instanceof CamelContextStartedEvent;	}	});	}	} catch (Exception e) {	throw new CamelSpringBootInitializationException(e);	}	} else {	
camel already started not adding routes 

private void loadXmlRoutes(ApplicationContext applicationContext, CamelContext camelContext, String directory) throws Exception {	
loading additional camel xml routes from 

private void loadXmlRoutes(ApplicationContext applicationContext, CamelContext camelContext, String directory) throws Exception {	try {	Resource[] xmlRoutes = applicationContext.getResources(directory);	for (Resource xmlRoute : xmlRoutes) {	
found xml route 

private void loadXmlRoutes(ApplicationContext applicationContext, CamelContext camelContext, String directory) throws Exception {	try {	Resource[] xmlRoutes = applicationContext.getResources(directory);	for (Resource xmlRoute : xmlRoutes) {	RoutesDefinition xmlDefinition = camelContext.loadRoutesDefinition(xmlRoute.getInputStream());	camelContext.addRouteDefinitions(xmlDefinition.getRoutes());	}	} catch (FileNotFoundException e) {	
no xml routes found in skipping xml routes detection 

private void loadXmlRests(ApplicationContext applicationContext, CamelContext camelContext, String directory) {	
loading additional camel xml rests from 

final Resource[] xmlRests = applicationContext.getResources(directory);	for (final Resource xmlRest : xmlRests) {	final RestsDefinition xmlDefinitions = camelContext.loadRestsDefinition(xmlRest.getInputStream());	camelContext.addRestDefinitions(xmlDefinitions.getRests());	for (final RestDefinition xmlDefinition : xmlDefinitions.getRests()) {	final List<RouteDefinition> routeDefinitions = xmlDefinition.asRouteDefinition(camelContext);	camelContext.addRouteDefinitions(routeDefinitions);	}	}	} catch (FileNotFoundException e) {	
no xml rests found in skipping xml rests detection 

private void terminateMainControllerAfter(final CamelContext camelContext, int seconds, final AtomicBoolean completed, final CountDownLatch latch) {	ScheduledExecutorService executorService = camelContext.getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "CamelSpringBootTerminateTask");	Runnable task = () -> {	
camelspringboot triggering shutdown of the jvm 

private void terminateMainControllerAfter(final CamelContext camelContext, int seconds, final AtomicBoolean completed, final CountDownLatch latch) {	ScheduledExecutorService executorService = camelContext.getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "CamelSpringBootTerminateTask");	Runnable task = () -> {	try {	camelContext.stop();	} catch (Throwable e) {	
error during stopping camelcontext 

private void terminateApplicationContext(final ConfigurableApplicationContext applicationContext, final CamelContext camelContext, int seconds) {	ScheduledExecutorService executorService = camelContext.getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "CamelSpringBootTerminateTask");	Runnable task = () -> {	
camelspringboot triggering shutdown of the jvm 

private void terminateApplicationContext(final ConfigurableApplicationContext applicationContext, final CamelContext camelContext, final CountDownLatch latch) {	ExecutorService executorService = camelContext.getExecutorServiceManager().newSingleThreadExecutor(this, "CamelSpringBootTerminateTask");	Runnable task = () -> {	try {	latch.await();	
camelspringboot triggering shutdown of the jvm 

========================= camel sample_13401 =========================

protected String mask(String opName, String value) {	String answer = URISupport.sanitizeUri(value);	if (LOG.isTraceEnabled()) {	
masking jmx operation value 

========================= camel sample_4695 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<ConstantLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.constant.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.constant.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_909 =========================

public void testWSHttpCallEcho() throws Exception {	received.clear();	latch = new CountDownLatch(2);	DefaultAsyncHttpClient c = new DefaultAsyncHttpClient();	WebSocket websocket = c.prepareGet("ws: new WebSocketUpgradeHandler.Builder() .addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

========================= camel sample_17442 =========================

public void process(Exchange exchange) throws Exception {	if (connection == null) {	connection = this.zkm.getConnection();	}	ProductionContext context = new ProductionContext(connection, exchange);	String operation = exchange.getIn().getHeader(ZooKeeperMessage.ZOOKEEPER_OPERATION, String.class);	boolean isDelete = ZK_OPERATION_DELETE.equals(operation);	if (ExchangeHelper.isOutCapable(exchange)) {	if (isDelete) {	if (log.isDebugEnabled()) {	
deleting znode s waiting for confirmation 

if (isDelete) {	if (log.isDebugEnabled()) {	}	OperationResult result = synchronouslyDelete(context);	if (configuration.isListChildren()) {	result = listChildren(context);	}	updateExchangeWithResult(context, result);	} else {	if (log.isDebugEnabled()) {	
storing data to znode s waiting for confirmation 

protected void doStart() throws Exception {	connection = zkm.getConnection();	if (log.isTraceEnabled()) {	
starting zookeeper producer of s 

protected void doStop() throws Exception {	super.doStop();	if (log.isTraceEnabled()) {	
shutting down zookeeper producer of s 

private void asynchronouslyDeleteNode(ZooKeeper connection, ProductionContext context) {	if (log.isDebugEnabled()) {	
deleting node s not waiting for confirmation 

private void asynchronouslySetDataOnNode(ZooKeeper connection, ProductionContext context) {	if (log.isDebugEnabled()) {	
storing data to node s not waiting for confirmation 

public void processResult(int rc, String node, Object ctx, Stat statistics) {	if (Code.NONODE.equals(Code.get(rc))) {	if (configuration.isCreate()) {	
node s did not exist creating it 

public void processResult(int rc, String node, Object ctx, Stat statistics) {	if (Code.NONODE.equals(Code.get(rc))) {	if (configuration.isCreate()) {	ProductionContext context = (ProductionContext)ctx;	OperationResult<String> result = null;	try {	result = createNode(context);	} catch (Exception e) {	
error trying to create node s 

public void processResult(int rc, String node, Object ctx, Stat statistics) {	if (Code.NONODE.equals(Code.get(rc))) {	if (configuration.isCreate()) {	ProductionContext context = (ProductionContext)ctx;	OperationResult<String> result = null;	try {	result = createNode(context);	} catch (Exception e) {	}	if (result == null || !result.isOk()) {	
error creating node s 

public void processResult(int rc, String path, Object ctx) {	if (log.isDebugEnabled()) {	if (log.isTraceEnabled()) {	
removed data node s 

public void processResult(int rc, String path, Object ctx) {	if (log.isDebugEnabled()) {	if (log.isTraceEnabled()) {	} else {	
removed data node s 

private OperationResult synchronouslySetData(ProductionContext ctx) throws Exception {	SetDataOperation setData = new SetDataOperation(ctx.connection, ctx.node, ctx.payload);	setData.setVersion(ctx.version);	OperationResult result = setData.get();	if (!result.isOk() && configuration.isCreate() && result.failedDueTo(Code.NONODE)) {	
node s did not exist creating it 

private OperationResult synchronouslyDelete(ProductionContext ctx) throws Exception {	DeleteOperation setData = new DeleteOperation(ctx.connection, ctx.node);	setData.setVersion(ctx.version);	OperationResult result = setData.get();	if (!result.isOk() && configuration.isCreate() && result.failedDueTo(Code.NONODE)) {	
node s did not exist creating it 

========================= camel sample_12640 =========================

boolean shutdownThreadPool = ProcessorDefinitionHelper.willCreateNewThreadPool(routeContext, this, true);	ExecutorService threadPool = ProcessorDefinitionHelper.getConfiguredExecutorService(routeContext, name, this, false);	ThreadPoolRejectedPolicy policy = resolveRejectedPolicy(routeContext);	if (policy == null) {	if (callerRunsWhenRejected == null || callerRunsWhenRejected) {	policy = ThreadPoolRejectedPolicy.CallerRuns;	} else {	policy = ThreadPoolRejectedPolicy.Abort;	}	}	
using threadpoolrejectedpolicy 

========================= camel sample_5211 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<FlatpackDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.flatpack.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.flatpack.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_765 =========================

return false;	}	if (!relayHeaders) {	return true;	}	if (relayAllMessageHeaders) {	return false;	}	MessageHeaderFilter messageHeaderfilter = getMessageHeaderFilter(exchange);	if (messageHeaderfilter == null) {	
no cxf binding namespace can be resolved message headers are intact 

}	MessageHeaderFilter messageHeaderfilter = getMessageHeaderFilter(exchange);	if (messageHeaderfilter == null) {	return false;	}	LOG.trace("messageHeaderfilter = {}", messageHeaderfilter);	try {	messageHeaderfilter.filter(direction, (List<Header>)value);	} catch (Throwable t) {	if (LOG.isDebugEnabled()) {	
failed to cast value to header list due to 

========================= camel sample_6597 =========================

protected void debugBefore(Exchange exchange, org.apache.camel.Processor processor, ProcessorDefinition<?> definition, String id, String label) {	
before with body 

protected void debugAfter(Exchange exchange, org.apache.camel.Processor processor, ProcessorDefinition<?> definition, String id, String label, long timeTaken) {	
after with body 

========================= camel sample_10057 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<SpelLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.spel.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.spel.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_620 =========================

public boolean acquireExclusiveReadLock(GenericFileOperations<T> operations, GenericFile<T> file, Exchange exchange) throws Exception {	
waiting for exclusive read lock to file 

try {	exclusive = operations.renameFile(file.getAbsoluteFilePath(), newFile.getAbsoluteFilePath());	} catch (GenericFileOperationFailedException ex) {	if (ex.getCause() instanceof FileNotFoundException) {	exclusive = false;	} else {	throw ex;	}	}	if (exclusive) {	
acquired exclusive read lock to file 

private boolean sleep() {	
exclusive read lock not granted sleeping for millis 

private boolean sleep() {	try {	Thread.sleep(checkInterval);	return false;	} catch (InterruptedException e) {	
sleep interrupted while waiting for exclusive read lock so breaking out 

========================= camel sample_4816 =========================

public String[] route(@XPath("/person/city/text()") String city) {	if (city.equals("London")) {	
person is from emea region 

public String[] route(@XPath("/person/city/text()") String city) {	if (city.equals("London")) {	return new String[] {"file:target/messages/emea/hr_pickup", "file:target/messages/emea/finance_pickup"};	} else {	
person is from amer region 

========================= camel sample_17842 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ExecComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.exec.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.exec.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1194 =========================

public void close() {	try {	if (null != inputStream) {	clientSocket.close();	}	} catch (IOException e) {	
exception encountered closing connection to 

public void reset() {	try {	clientSocket.setSoLinger(true, 0);	} catch (SocketException socketEx) {	
exception encountered setting set so linger to force a tcp reset 

public void reset() {	try {	clientSocket.setSoLinger(true, 0);	} catch (SocketException socketEx) {	}	try {	if (null != inputStream) {	clientSocket.close();	}	} catch (IOException e) {	
exception encountered resetting connection to 

public void sendData(String data, boolean disconnectAfterSend) {	byte[] payloadBytes = data.getBytes();	try {	outputStream.write(payloadBytes, 0, payloadBytes.length);	} catch (IOException e) {	
unable to send raw string 

public void sendData(String data, boolean disconnectAfterSend) {	byte[] payloadBytes = data.getBytes();	try {	outputStream.write(payloadBytes, 0, payloadBytes.length);	} catch (IOException e) {	throw new MllpJUnitResourceException("Unable to send raw string", e);	}	if (disconnectAfterSend) {	
closing tcp connection 

throw new MllpJUnitResourceException("Cannot send message - client is not connected");	}	if (null == outputStream) {	throw new MllpJUnitResourceException("Cannot send message - output stream is null");	}	byte[] payloadBytes = hl7Message.getBytes();	try {	if (sendStartOfBlock) {	outputStream.write(START_OF_BLOCK);	} else {	
not sending start of block 

byte[] payloadBytes = hl7Message.getBytes();	try {	if (sendStartOfBlock) {	outputStream.write(START_OF_BLOCK);	} else {	}	outputStream.write(payloadBytes, 0, payloadBytes.length);	if (sendEndOfBlock) {	outputStream.write(END_OF_BLOCK);	} else {	
not sending end of block 

} else {	}	outputStream.write(payloadBytes, 0, payloadBytes.length);	if (sendEndOfBlock) {	outputStream.write(END_OF_BLOCK);	} else {	}	if (sendEndOfData) {	outputStream.write(END_OF_DATA);	} else {	
not sending end of data 

if (sendEndOfBlock) {	outputStream.write(END_OF_BLOCK);	} else {	}	if (sendEndOfData) {	outputStream.write(END_OF_DATA);	} else {	}	outputStream.flush();	} catch (IOException e) {	
unable to send message 

}	if (sendEndOfData) {	outputStream.write(END_OF_DATA);	} else {	}	outputStream.flush();	} catch (IOException e) {	throw new MllpJUnitResourceException("Unable to send HL7 message", e);	}	if (disconnectAfterSend) {	
closing tcp connection 

throw new MllpJUnitResourceException("Cannot send message - client is not connected");	}	if (null == outputStream) {	throw new MllpJUnitResourceException("Cannot send message - output stream is null");	}	byte[] payloadBytes = hl7Message.getBytes();	try {	if (sendStartOfBlock) {	outputStream.write(START_OF_BLOCK);	} else {	
not sending start of block 

}	for (int i = 0; i < payloadBytes.length; ++i) {	outputStream.write(payloadBytes[i]);	if (flushByte == payloadBytes[i]) {	outputStream.flush();	}	}	if (sendEndOfBlock) {	outputStream.write(END_OF_BLOCK);	} else {	
not sending end of block 

outputStream.flush();	}	}	if (sendEndOfBlock) {	outputStream.write(END_OF_BLOCK);	} else {	}	if (sendEndOfData) {	outputStream.write(END_OF_DATA);	} else {	
not sending end of data 

if (sendEndOfBlock) {	outputStream.write(END_OF_BLOCK);	} else {	}	if (sendEndOfData) {	outputStream.write(END_OF_DATA);	} else {	}	outputStream.flush();	} catch (IOException e) {	
unable to send message 

}	if (sendEndOfData) {	outputStream.write(END_OF_DATA);	} else {	}	outputStream.flush();	} catch (IOException e) {	throw new MllpJUnitResourceException("Unable to send HL7 message", e);	}	if (disconnectAfterSend) {	
closing tcp connection 

if (null == outputStream) {	throw new MllpJUnitResourceException("Cannot receive acknowledgement - output stream is null");	}	clientSocket.setSoTimeout(timout);	StringBuilder acknowledgement = new StringBuilder();	try {	int firstByte = inputStream.read();	if (START_OF_BLOCK != firstByte) {	if (isConnected()) {	if (END_OF_STREAM == firstByte) {	
end of stream reached while waiting for start of block closing socket 

clientSocket.setSoTimeout(timout);	StringBuilder acknowledgement = new StringBuilder();	try {	int firstByte = inputStream.read();	if (START_OF_BLOCK != firstByte) {	if (isConnected()) {	if (END_OF_STREAM == firstByte) {	try {	clientSocket.close();	} catch (Exception ex) {	
exception encountered closing socket after receiving end of stream while waiting for start of block 

int firstByte = inputStream.read();	if (START_OF_BLOCK != firstByte) {	if (isConnected()) {	if (END_OF_STREAM == firstByte) {	try {	clientSocket.close();	} catch (Exception ex) {	}	return "";	} else {	
acknowledgement did not start with start of block 

case END_OF_BLOCK: if (END_OF_DATA != inputStream.read()) {	throw new MllpJUnitResourceCorruptFrameException("END_OF_BLOCK was not followed by END_OF_DATA");	}	readingMessage = false;	break;	default: acknowledgement.append((char) nextByte);	}	}	} catch (SocketTimeoutException timeoutEx) {	if (0 < acknowledgement.length()) {	
timeout waiting for acknowledgement 

throw new MllpJUnitResourceCorruptFrameException("END_OF_BLOCK was not followed by END_OF_DATA");	}	readingMessage = false;	break;	default: acknowledgement.append((char) nextByte);	}	}	} catch (SocketTimeoutException timeoutEx) {	if (0 < acknowledgement.length()) {	} else {	
timeout while reading acknowledgement 

break;	default: acknowledgement.append((char) nextByte);	}	}	} catch (SocketTimeoutException timeoutEx) {	if (0 < acknowledgement.length()) {	} else {	}	throw new MllpJUnitResourceTimeoutException("Timeout while reading acknowledgement", timeoutEx);	} catch (IOException e) {	
unable to read acknowledgement 

public String receiveData(int timeout) throws SocketException, SocketTimeoutException {	clientSocket.setSoTimeout(timeout);	StringBuilder availableInput = new StringBuilder();	try {	do {	availableInput.append((char) inputStream.read());	} while (0 < inputStream.available());	} catch (SocketTimeoutException timeoutEx) {	
timeout while receiving available input 

public String receiveData(int timeout) throws SocketException, SocketTimeoutException {	clientSocket.setSoTimeout(timeout);	StringBuilder availableInput = new StringBuilder();	try {	do {	availableInput.append((char) inputStream.read());	} while (0 < inputStream.available());	} catch (SocketTimeoutException timeoutEx) {	throw new MllpJUnitResourceTimeoutException("Timeout while receiving available input", timeoutEx);	} catch (IOException e) {	
exception encountered eating available input 

public String eatData(int timeout) throws SocketException {	clientSocket.setSoTimeout(timeout);	StringBuilder availableInput = new StringBuilder();	try {	while (0 < inputStream.available()) {	availableInput.append((char) inputStream.read());	}	} catch (IOException e) {	
exception encountered eating available input 

========================= camel sample_13801 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<MiloServerComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.milo-server.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.milo-server.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_509 =========================

public void process(WatchedEvent event) {	this.event = event;	EventType received = event.getType();	if (LOG.isDebugEnabled()) {	
recieved event of type s for node s 

}	}	if (LOG.isTraceEnabled() && waitForAnyWatchedType.getCount() > 0) {	StringBuilder b = new StringBuilder();	for (EventType type : awaitedTypes) {	b.append(type).append(", ");	}	if (b.length() > 0) {	b.setLength(b.length() - 2);	}	
recieved event of type s did not match any watched types s 

========================= camel sample_12656 =========================

public void testWSHttpCall() throws Exception {	AsyncHttpClient c = new DefaultAsyncHttpClient();	WebSocket websocket = c.prepareGet("ws: new WebSocketUpgradeHandler.Builder() .addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

========================= camel sample_17454 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("direct:start") .recipientList().header("whereTo") .to("mock:result");	from("activemq:topic:news?disableReplyTo=true") .transform(body().prepend("Bye ")) .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String replyTo = exchange.getIn().getHeader("JMSReplyTo", String.class);	String cid = exchange.getIn().getHeader("JMSCorrelationID", String.class);	
replyto 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("direct:start") .recipientList().header("whereTo") .to("mock:result");	from("activemq:topic:news?disableReplyTo=true") .transform(body().prepend("Bye ")) .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String replyTo = exchange.getIn().getHeader("JMSReplyTo", String.class);	String cid = exchange.getIn().getHeader("JMSCorrelationID", String.class);	
correlationid 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("direct:start") .recipientList().header("whereTo") .to("mock:result");	from("activemq:topic:news?disableReplyTo=true") .transform(body().prepend("Bye ")) .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String replyTo = exchange.getIn().getHeader("JMSReplyTo", String.class);	String cid = exchange.getIn().getHeader("JMSCorrelationID", String.class);	if (replyTo != null && cid != null) {	Thread.sleep(1000);	
sending back reply message on 

========================= camel sample_7105 =========================

public static void doneUow(UnitOfWork uow, Exchange exchange) {	try {	if (uow != null) {	uow.done(exchange);	}	} catch (Throwable e) {	
exception occurred during done unitofwork for exchange this exception will be ignored 

if (uow != null) {	uow.done(exchange);	}	} catch (Throwable e) {	}	try {	if (uow != null) {	uow.stop();	}	} catch (Throwable e) {	
exception occurred during stopping unitofwork for exchange this exception will be ignored 

========================= camel sample_4379 =========================

protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {	OperationName operationName = null;	String topicName = null;	String apexUrl = null;	try {	
creating endpoint for 

loginConfig.setInstanceUrl(instanceUrl);	loginConfig.setClientId(clientId);	loginConfig.setClientSecret(clientSecret);	loginConfig.setKeystore(keystore);	loginConfig.setLazyLogin(lazyLogin);	loginConfig.setLoginUrl(loginUrl);	loginConfig.setPassword(password);	loginConfig.setRefreshToken(refreshToken);	loginConfig.setType(authenticationType);	loginConfig.setUserName(userName);	
created login configuration 

loginConfig.setClientId(clientId);	loginConfig.setClientSecret(clientSecret);	loginConfig.setKeystore(keystore);	loginConfig.setLazyLogin(lazyLogin);	loginConfig.setLoginUrl(loginUrl);	loginConfig.setPassword(password);	loginConfig.setRefreshToken(refreshToken);	loginConfig.setType(authenticationType);	loginConfig.setUserName(userName);	} else {	
using shared login configuration 

if (session == null) {	session = new SalesforceSession(getCamelContext(), httpClient, httpClient.getTimeout(), loginConfig);	}	httpClient.setSession(session);	httpClient.start();	if (!loginConfig.isLazyLogin()) {	ServiceHelper.startService(session);	}	if (packages != null && packages.length > 0) {	classMap = parsePackages();	
found generated classes in packages 

========================= camel sample_14782 =========================

Object out = transactionTemplate.execute(new TransactionCallback<Object>() {	public Object doInTransaction(TransactionStatus status) {	if (getEndpoint().isJoinTransaction()) {	entityManager.joinTransaction();	}	Query query = getQueryFactory().createQuery(entityManager);	configureParameters(query);	if (getEndpoint().isConsumeLockEntity()) {	query.setLockMode(getLockModeType());	}	
created query 

query.setLockMode(getLockModeType());	}	Object answer;	try {	List<?> results = query.getResultList();	if (results != null && results.size() == 1) {	answer = results.get(0);	} else {	answer = results;	}	
flushing entitymanager 

try {	List<?> results = query.getResultList();	if (results != null && results.size() == 1) {	answer = results.get(0);	} else {	answer = results;	}	entityManager.flush();	entityManager.clear();	} catch (PersistenceException e) {	
disposing entitymanager on due to coming transaction rollback 

========================= camel sample_14106 =========================

public void testSendMessages() throws Exception {	long start = System.currentTimeMillis();	for (int i = 0; i < size; i++) {	template.sendBody(url, "Message " + i);	}	assertEquals(size, processor.getCounter());	long delta = System.currentTimeMillis() - start;	
routeperformancecounttest sent took ms 

========================= camel sample_2429 =========================

public void testAddingDataToCache() throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). to("cache: }	});	context.start();	
beginning cacheproducer add test 

public void testAddingDataToCacheWithNonStringCacheKey() throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). setHeader(CacheConstants.CACHE_KEY, constant(10L)). to("cache: }	});	context.start();	NotifyBuilder notify = new NotifyBuilder(context).whenExactlyDone(1).create();	
beginning cacheproducer add test 

public void testAddingDataElementEternal() throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). setHeader(CacheConstants.CACHE_ELEMENT_EXPIRY_ETERNAL, constant(Boolean.TRUE)). to("cache: }	});	context.start();	
beginning cacheproducer add test 

public void testAddingDataElementIdle() throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). setHeader(CacheConstants.CACHE_ELEMENT_EXPIRY_IDLE, constant(24)). to("cache: }	});	context.start();	
beginning cacheproducer add test 

public void testAddingDataElementTimeToLive() throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). setHeader(CacheConstants.CACHE_ELEMENT_EXPIRY_TTL, constant(42)). to("cache: }	});	context.start();	
beginning cacheproducer add test 

public void testAddingDataToCacheDoesFailOnEmptyBody() throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	onException(CacheException.class). handled(true). to("log:LOGGER"). to("mock:CacheProducerTest.cacheException");	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). to("cache: }	});	resultEndpoint.expectedMessageCount(0);	cacheExceptionEndpoint.expectedMessageCount(1);	context.start();	
beginning cacheproducer add does fail on empty body test 

public void testAddingSerializableDataToCache() throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). to("cache: }	});	context.start();	
beginning cacheproducer add test 

public void testUpdatingDataInCache() throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_UPDATE)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). to("cache: }	});	context.start();	
beginning cacheproducer update test 

public void testUpdatingDataInCacheDoesFailOnEmptyBody() throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	onException(CacheException.class). handled(true). to("log:LOGGER"). to("mock:CacheProducerTest.cacheException");	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_UPDATE)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). to("cache: }	});	cacheExceptionEndpoint.expectedMessageCount(1);	context.start();	
beginning cacheproducer update does fail on empty body test 

public void testDeletingDataFromCache() throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_DELETE)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). to("cache: }	});	context.start();	
beginning cacheproducer delete test 

public void testDeletingDataFromCacheDoesNotFailOnEmptyBody() throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	onException(CacheException.class). handled(true). to("log:LOGGER"). to("mock:CacheProducerTest.cacheException");	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_DELETE)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). to("cache: }	});	cacheExceptionEndpoint.expectedMessageCount(0);	context.start();	
beginning cacheproducer delete does not fail on empty body test 

public void testDeletingAllDataFromCache() throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_DELETEALL)). to("cache: }	});	context.start();	
beginning cacheproducer delete all elements test 

public void testDeletingAllDataFromCacheDoesNotFailOnEmptyBody() throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	onException(CacheException.class). handled(true). to("log:LOGGER"). to("mock:CacheProducerTest.cacheException");	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_DELETEALL)). to("cache: }	});	cacheExceptionEndpoint.expectedMessageCount(0);	context.start();	
beginning cacheproducer delete all elements does not fail on empty body test 

public void testUnknownOperation() throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	onException(CacheException.class). handled(true). to("log:LOGGER"). to("mock:CacheProducerTest.cacheException");	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant("UNKNOWN")). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). to("cache: to("mock:CacheProducerTest.result");	}	});	resultEndpoint.expectedMessageCount(0);	cacheExceptionEndpoint.expectedMessageCount(1);	context.start();	
beginning cacheproducer query an elements test 

public void configure() {	onException(CacheException.class). handled(true). choice().when(exceptionMessage().isEqualTo(CacheConstants.CACHE_OPERATION + " UNKNOWN is not supported.")). to("log:LOGGER"). to("mock:CacheProducerTest.cacheException").end();	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant("UNKNOWN")). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). to("cache: to("mock:CacheProducerTest.result");	}	};	context.setTracing(true);	context.addRoutes(builder);	resultEndpoint.expectedMessageCount(0);	cacheExceptionEndpoint.expectedMessageCount(1);	context.start();	
beginning cacheproducer query an elements does fail on empty body test 

public void testQueringNonExistingDataFromCache() throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	onException(CacheException.class). handled(true). to("log:LOGGER"). to("mock:CacheProducerTest.cacheException");	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_DELETEALL)). to("cache: setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_GET)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). to("cache: choice().when(header(CacheConstants.CACHE_ELEMENT_WAS_FOUND).isNotNull()). to("mock:CacheProducerTest.result").end();	}	});	resultEndpoint.expectedMessageCount(0);	cacheExceptionEndpoint.expectedMessageCount(0);	context.start();	
beginning cacheproducer query an elements test 

public void testQueringNonExistingDataFromCacheDoesNotFailOnEmptyBody() throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	onException(CacheException.class). handled(true). to("log:LOGGER"). to("mock:CacheProducerTest.cacheException");	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_DELETEALL)). to("cache: setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_GET)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). to("cache: choice().when(header(CacheConstants.CACHE_ELEMENT_WAS_FOUND).isNotNull()). to("mock:CacheProducerTest.result").end();	}	});	resultEndpoint.expectedMessageCount(0);	cacheExceptionEndpoint.expectedMessageCount(0);	context.start();	
beginning cacheproducer query an elements does not fail on empty body test 

public void configure() {	onException(CacheException.class). handled(true). to("log:LOGGER"). to("mock:CacheProducerTest.cacheException");	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). to("cache: setBody(constant("Don't care. This body will be overridden.")). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_GET)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). to("cache: choice().when(header(CacheConstants.CACHE_ELEMENT_WAS_FOUND).isNotNull()). to("mock:CacheProducerTest.result").end();	}	});	resultEndpoint.expectedMessageCount(1);	cacheExceptionEndpoint.expectedMessageCount(0);	String body = new String(getFileAsByteArray(FILEPATH_UPDATEDTEST_TXT), "UTF-8");	resultEndpoint.expectedBodiesReceived(body);	context.start();	
beginning cacheproducer query an elements test 

context.addRoutes(new RouteBuilder() {	public void configure() {	onException(CacheException.class). handled(true). to("log:LOGGER"). to("mock:CacheProducerTest.cacheException");	from("direct:a"). to("cache: setBody(constant("Don't care. This body will be overridden.")). to("cache: choice().when(header(CacheConstants.CACHE_ELEMENT_WAS_FOUND).isNotNull()). to("mock:CacheProducerTest.result").end();	}	});	resultEndpoint.expectedMessageCount(1);	cacheExceptionEndpoint.expectedMessageCount(0);	resultEndpoint.expectedBodiesReceived(POETRY);	context.start();	
beginning cacheproducer query an elements test 

context.addRoutes(new RouteBuilder() {	public void configure() {	onException(CacheException.class). handled(true). to("log:LOGGER"). to("mock:CacheProducerTest.cacheException");	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). to("cache: setBody(constant("Don't care. This body will be overridden.")). setHeader(CacheConstants.CACHE_KEY, constant("foo")). to("cache: choice().when(header(CacheConstants.CACHE_ELEMENT_WAS_FOUND).isNotNull()). to("mock:CacheProducerTest.result").end();	}	});	resultEndpoint.expectedMessageCount(1);	cacheExceptionEndpoint.expectedMessageCount(0);	resultEndpoint.expectedBodiesReceived(POETRY);	context.start();	
beginning cacheproducer query an elements test 

context.addRoutes(new RouteBuilder() {	public void configure() {	onException(CacheException.class). handled(true). to("log:LOGGER"). to("mock:CacheProducerTest.cacheException");	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). setHeader(CacheConstants.CACHE_KEY, constant("foo")). to("cache: setBody(constant("Don't care. This body will be overridden.")). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_GET)). setHeader(CacheConstants.CACHE_KEY, constant("foo")). to("cache: choice().when(header(CacheConstants.CACHE_ELEMENT_WAS_FOUND).isNotNull()). to("mock:CacheProducerTest.result").end();	}	});	resultEndpoint.expectedMessageCount(1);	cacheExceptionEndpoint.expectedMessageCount(0);	resultEndpoint.expectedBodiesReceived(POETRY);	context.start();	
beginning cacheproducer query an elements test 

context.addRoutes(new RouteBuilder() {	public void configure() {	onException(CacheException.class). handled(true). to("log:LOGGER"). to("mock:CacheProducerTest.cacheException");	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). setBody(constant("Test body")). to("cache: setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_URL_CHECK)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). to("cache: choice().when(header(CacheConstants.CACHE_ELEMENT_WAS_FOUND).isNotNull()). to("mock:CacheProducerTest.result").end();	}	});	resultEndpoint.expectedMessageCount(1);	cacheExceptionEndpoint.expectedMessageCount(0);	resultEndpoint.expectedBodiesReceived("Test body");	context.start();	
beginning cacheproducer check an element exists test 

public void testCheckDataFromCacheNegativeTest() throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	onException(CacheException.class). handled(true). to("log:LOGGER"). to("mock:CacheProducerTest.cacheException");	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). setBody(constant("Test body")). to("cache: setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_URL_CHECK)). setHeader(CacheConstants.CACHE_KEY, constant("foo")). to("cache: choice().when(header(CacheConstants.CACHE_ELEMENT_WAS_FOUND).isNotNull()). to("mock:CacheProducerTest.result").end();	}	});	resultEndpoint.expectedMessageCount(0);	cacheExceptionEndpoint.expectedMessageCount(0);	context.start();	
beginning cacheproducer check an element does not exist test 

public void testCheckExpiredDataFromCache() throws Exception {	context.addRoutes(new RouteBuilder() {	public void configure() {	onException(CacheException.class). handled(true). to("log:LOGGER"). to("mock:CacheProducerTest.cacheException");	from("direct:a"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). setBody(constant("Test body")). to("cache: from("direct:b"). setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_URL_CHECK)). setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")). to("cache: choice().when(header(CacheConstants.CACHE_ELEMENT_WAS_FOUND).isNull()). to("mock:CacheProducerTest.result").end();	}	});	resultEndpoint.expectedMessageCount(1);	cacheExceptionEndpoint.expectedMessageCount(0);	context.start();	
beginning cacheproducer check an element does not exist after expiry test 

========================= camel sample_10515 =========================

public String echo(String text) {	
call for echo with 

public void ping() {	invocationCount++;	
call for oneway ping 

========================= camel sample_7781 =========================

protected void doStart() throws Exception {	super.doStart();	
starting couchdb consumer 

protected void doStop() throws Exception {	super.doStop();	
stopping couchdb consumer 

========================= camel sample_12482 =========================

idx2 = i;	}	}	if (idx1 >= 0 && idx2 >= 0 && idx1 > idx2) {	bundleDescriptors.add(idx2, bundleDescriptors.remove(idx1));	}	bundles.addAll(bundleDescriptors);	if (LOG.isDebugEnabled()) {	for (int i = 0; i < bundles.size(); i++) {	BundleDescriptor desc = bundles.get(i);	
bundle 

public static void disposeBundleContext(BundleContext bundleContext) throws BundleException {	try {	if (bundleContext != null) {	List<Bundle> bundles = new ArrayList<Bundle>();	bundles.addAll(Arrays.asList(bundleContext.getBundles()));	Collections.reverse(bundles);	for (Bundle bundle : bundles) {	
stopping bundle 

List<Bundle> bundles = new ArrayList<Bundle>();	bundles.addAll(Arrays.asList(bundleContext.getBundles()));	Collections.reverse(bundles);	for (Bundle bundle : bundles) {	bundle.stop();	}	}	} catch (Exception e) {	IllegalStateException ise = ObjectHelper.getException(IllegalStateException.class, e);	if (ise != null) {	
error during disposing bundlecontext this exception will be ignored 

bundles.addAll(Arrays.asList(bundleContext.getBundles()));	Collections.reverse(bundles);	for (Bundle bundle : bundles) {	bundle.stop();	}	}	} catch (Exception e) {	IllegalStateException ise = ObjectHelper.getException(IllegalStateException.class, e);	if (ise != null) {	} else {	
error during disposing bundlecontext this exception will be ignored 

}	}	} catch (Exception e) {	IllegalStateException ise = ObjectHelper.getException(IllegalStateException.class, e);	if (ise != null) {	} else {	}	} finally {	String tempDir = System.clearProperty("org.osgi.framework.storage");	if (tempDir != null) {	
deleting work directory 

public static void setPersistentFileForConfigAdmin(BundleContext bundleContext, String pid, String fileName, final Dictionary props, String symbolicName, Set<Long> bpEvents, boolean expectReload) throws IOException, InterruptedException {	if (pid != null) {	if (fileName == null) {	throw new IllegalArgumentException("The persistent file should not be null");	} else {	File load = new File(fileName);	
loading properties from osgi config admin file 

throw new IllegalArgumentException("The persistent file should not be null");	} else {	File load = new File(fileName);	org.apache.felix.utils.properties.Properties cfg = new org.apache.felix.utils.properties.Properties(load);	for (Object key : cfg.keySet()) {	props.put(key, cfg.get(key));	}	ConfigurationAdmin configAdmin = CamelBlueprintHelper .getOsgiService(bundleContext, ConfigurationAdmin.class);	if (configAdmin != null) {	final Configuration config = configAdmin.getConfiguration(pid, null);	
updating configadmin by overriding properties 

}	} else {	flt = "(" + Constants.OBJECTCLASS + "=" + type.getName() + ")";	}	Filter osgiFilter = FrameworkUtil.createFilter(flt);	tracker = new ServiceTracker<T, T>(bundleContext, osgiFilter, null);	tracker.open(true);	Object svc = tracker.waitForService(timeout);	if (svc == null) {	Dictionary<?, ?> dic = bundleContext.getBundle().getHeaders();	
test bundle headers 

} else {	flt = "(" + Constants.OBJECTCLASS + "=" + type.getName() + ")";	}	Filter osgiFilter = FrameworkUtil.createFilter(flt);	tracker = new ServiceTracker<T, T>(bundleContext, osgiFilter, null);	tracker.open(true);	Object svc = tracker.waitForService(timeout);	if (svc == null) {	Dictionary<?, ?> dic = bundleContext.getBundle().getHeaders();	for (ServiceReference ref : asCollection(bundleContext.getAllServiceReferences(null, null))) {	
servicereference bundle symbolicname 

}	Filter osgiFilter = FrameworkUtil.createFilter(flt);	tracker = new ServiceTracker<T, T>(bundleContext, osgiFilter, null);	tracker.open(true);	Object svc = tracker.waitForService(timeout);	if (svc == null) {	Dictionary<?, ?> dic = bundleContext.getBundle().getHeaders();	for (ServiceReference ref : asCollection(bundleContext.getAllServiceReferences(null, null))) {	}	for (ServiceReference ref : asCollection(bundleContext.getAllServiceReferences(null, flt))) {	
filtered servicereference bundle symbolicname 

protected static TinyBundle createTestBundle(String name, String version, String descriptors) throws IOException {	TinyBundle bundle = TinyBundles.newBundle();	for (URL url : getBlueprintDescriptors(descriptors)) {	
using blueprint xml file 

protected static Collection<URL> getBlueprintDescriptors(String descriptors) throws FileNotFoundException, MalformedURLException {	List<URL> answer = new ArrayList<URL>();	if (descriptors != null) {	Iterator<Object> it = ObjectHelper.createIterator(descriptors);	while (it.hasNext()) {	String s = (String) it.next();	
resource descriptor 

Enumeration<URL> urls = ObjectHelper.loadResourcesAsURL(packageName);	while (urls.hasMoreElements()) {	URL url = urls.nextElement();	File dir = new File(url.getFile());	if (dir.isDirectory()) {	File[] files = dir.listFiles();	if (files != null) {	for (File file : files) {	if (file.isFile() && file.exists() && file.getName().endsWith(".xml")) {	String name = packageName + file.getName();	
resolving resource 

URL xmlUrl = ObjectHelper.loadResourceAsURL(name);	if (xmlUrl != null) {	answer.add(xmlUrl);	}	}	}	}	}	}	} else {	
resolving resource 

========================= camel sample_10145 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SftpComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.sftp.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.sftp.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_732 =========================

public void act(final Client client, final Exchange exchange) throws NoSuchHeaderException, InvalidPayloadException {	final Integer jobs = exchange.getIn().getMandatoryBody(Integer.class);	final int result = client.kick(jobs);	if (LOG.isDebugEnabled()) {	
kick d jobs kicked d actually 

========================= camel sample_8161 =========================

public void onOpen(WebSocket websocket) {	
ws opened 

public void onClose(WebSocket websocket) {	
ws closed 

public void onError(Throwable t) {	
ws error 

public void onMessage(byte[] message) {	received.add(message);	
ws received bytes 

public void onMessage(String message) {	received.add(message);	
ws received 

========================= camel sample_10000 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<HazelcastAtomicnumberComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-atomicvalue.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-atomicvalue.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_677 =========================

public void run() {	for (int j = 0; j < inner; j++) {	Document dom = context.getTypeConverter().convertTo(Document.class, "<hello>World</hello>");	assertNotNull(dom);	}	latch.countDown();	}	});	}	assertTrue("Should all work", latch.await(2, TimeUnit.MINUTES));	
took 

========================= camel sample_1340 =========================

public void testXPathSTaXPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(60, TimeUnit.SECONDS);	
processed file with elements in 

public void testXPathSTaXPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(60, TimeUnit.SECONDS);	
processed tiny messages 

public void testXPathSTaXPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(60, TimeUnit.SECONDS);	
processed small messages 

public void testXPathSTaXPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(60, TimeUnit.SECONDS);	
processed medium messages 

public void testXPathSTaXPerformanceRoute() throws Exception {	NotifyBuilder notify = new NotifyBuilder(context).whenDone(size).create();	boolean matches = notify.matches(60, TimeUnit.SECONDS);	
processed large messages 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("file:target/data?noop=true") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	
starting to process file 

from("file:target/data?noop=true") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	watch.restart();	}	}) .split(stax(Order.class)).streaming() .choice() .when().xpath("/order/amount < 10") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String xml = exchange.getIn().getBody(String.class);	assertTrue(xml, xml.contains("<amount>3</amount>"));	int num = tiny.incrementAndGet();	if (num % 100 == 0) {	
processed tiny messages 

if (num % 100 == 0) {	log.debug(xml);	}	}	}) .when().xpath("/order/amount < 50") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String xml = exchange.getIn().getBody(String.class);	assertTrue(xml, xml.contains("<amount>44</amount>"));	int num = small.incrementAndGet();	if (num % 100 == 0) {	
processed small messages 

if (num % 100 == 0) {	log.debug(xml);	}	}	}) .when().xpath("/order/amount < 100") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String xml = exchange.getIn().getBody(String.class);	assertTrue(xml, xml.contains("<amount>88</amount>"));	int num = med.incrementAndGet();	if (num % 100 == 0) {	
processed medium messages 

if (num % 100 == 0) {	log.debug(xml);	}	}	}) .otherwise() .process(new Processor() {	public void process(Exchange exchange) throws Exception {	String xml = exchange.getIn().getBody(String.class);	assertTrue(xml, xml.contains("<amount>123</amount>"));	int num = large.incrementAndGet();	if (num % 100 == 0) {	
processed large messages 

========================= camel sample_9320 =========================

public void onInit(Route route) {	super.onInit(route);	
route managed by setting route autostartup flag to false 

private synchronized void setLeader(boolean isLeader) {	if (isLeader && leader.compareAndSet(false, isLeader)) {	
leadership taken 

private synchronized void setLeader(boolean isLeader) {	if (isLeader && leader.compareAndSet(false, isLeader)) {	startManagedRoutes();	} else if (!isLeader && leader.getAndSet(isLeader)) {	
leadership lost 

private void doStartManagedRoutes() {	if (!isRunAllowed()) {	return;	}	try {	for (Route route : stoppedRoutes) {	ServiceStatus status = route.getRouteContext().getRoute().getStatus(getCamelContext());	if (status.isStartable()) {	
starting route 

private void doStopManagedRoutes() {	if (!isRunAllowed()) {	return;	}	try {	for (Route route : startedRoutes) {	ServiceStatus status = route.getRouteContext().getRoute().getStatus(getCamelContext());	if (status.isStoppable()) {	
stopping route 

private void onCamelContextStarted() {	if (contextStarted.compareAndSet(false, true)) {	if (initialDelay.toMillis() > 0) {	
policy will be effective in 

========================= camel sample_3957 =========================

protected RouteBuilder createRouteBuilder() {	return new RouteBuilder() {	public void configure() {	from("direct:start"). marshal().json(JsonLibrary.XStream, PurchaseOrder.class). process(new Processor() {	public void process(Exchange exchange) throws Exception {	
marshalled 

========================= camel sample_10283 =========================

public void testUsingCustomExceptionHandlerAndOneRedelivery() throws Exception {	a.expectedMessageCount(1);	sendBody("direct:start", "a");	MockEndpoint.assertIsSatisfied(a, b);	List<Exchange> list = a.getReceivedExchanges();	assertTrue("List should not be empty!", !list.isEmpty());	Exchange exchange = list.get(0);	Message in = exchange.getIn();	
found message with headers 

public void testUsingCustomExceptionHandlerWithNoRedeliveries() throws Exception {	b.expectedMessageCount(1);	sendBody("direct:start", "b");	MockEndpoint.assertIsSatisfied(a, b);	List<Exchange> list = b.getReceivedExchanges();	assertTrue("List should not be empty!", !list.isEmpty());	Exchange exchange = list.get(0);	Message in = exchange.getIn();	
found message with headers 

========================= camel sample_2645 =========================

private String sendAndReceiveUdpMessages(String input) throws Exception {	DatagramSocket socket = new DatagramSocket();	InetAddress address = InetAddress.getByName("127.0.0.1");	byte[] data = (input + "\n").getBytes();	DatagramPacket packet = new DatagramPacket(data, data.length, address, getPort());	
sending data 

private String sendAndReceiveUdpMessages(String input) throws Exception {	DatagramSocket socket = new DatagramSocket();	InetAddress address = InetAddress.getByName("127.0.0.1");	byte[] data = (input + "\n").getBytes();	DatagramPacket packet = new DatagramPacket(data, data.length, address, getPort());	socket.send(packet);	Thread.sleep(1000);	byte[] buf = new byte[128];	DatagramPacket receive = new DatagramPacket(buf, buf.length, address, getPort());	
receiving data 

protected RouteBuilder createRouteBuilder() {	return new RouteBuilder() {	public void configure() {	from("netty:udp: public void process(Exchange exchange) throws Exception {	String s = exchange.getIn().getBody(String.class);	
server got 

========================= camel sample_6606 =========================

ExecutorService executorService = this.executor;	if (executorService != null && this.isRunAllowed()) {	executorService.execute(() -> this.getAsyncProcessor().process(exchange, doneSync -> {	if (exchange.getException() != null) {	getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException());	}	callback.done(doneSync);	}));	return false;	} else {	
consumer not ready to process exchanges the exchange will be discarded 

========================= camel sample_11492 =========================

public KeyManager[] createKeyManagers() throws GeneralSecurityException, IOException {	
creating keymanager from keymanagersparameters 

String kmfAlgorithm = this.parsePropertyValue(this.getAlgorithm());	if (kmfAlgorithm == null) {	kmfAlgorithm = KeyManagerFactory.getDefaultAlgorithm();	}	KeyManagerFactory kmf;	if (this.getProvider() == null) {	kmf = KeyManagerFactory.getInstance(kmfAlgorithm);	} else {	kmf = KeyManagerFactory.getInstance(kmfAlgorithm, this.parsePropertyValue(this.getProvider()));	}	
keymanagerfactory initialized from is using provider and algorithm 

} else {	kmf = KeyManagerFactory.getInstance(kmfAlgorithm, this.parsePropertyValue(this.getProvider()));	}	char[] kmfPassword = null;	if (this.getKeyPassword() != null) {	kmfPassword = this.parsePropertyValue(this.getKeyPassword()).toCharArray();	}	KeyStore ks = this.getKeyStore() == null ? null : this.getKeyStore().createKeyStore();	kmf.init(ks, kmfPassword);	keyManagers = kmf.getKeyManagers();	
keymanager initialized from keymanagerfactory 

========================= camel sample_4284 =========================

public FilePropertySource(String name, ApplicationContext applicationContext, String directory) {	super(name);	StringHelper.notEmpty(directory, "directory");	Properties loaded = new Properties();	try {	Resource[] files = applicationContext.getResources(directory);	for (Resource file : files) {	if (file.exists()) {	try (FileInputStream fis = new FileInputStream(file.getFile())) {	
loading properties from file 

loaded.putAll(extra);	}	} catch (IOException e) {	}	}	}	} catch (IOException e) {	}	if (loaded.isEmpty()) {	properties = null;	
no properties found while loading from 

} catch (IOException e) {	}	}	}	} catch (IOException e) {	}	if (loaded.isEmpty()) {	properties = null;	} else {	properties = loaded;	
loaded properties from 

public Object getProperty(String name) {	Object answer = properties != null ? properties.getProperty(name) : null;	
getproperty 

========================= camel sample_13440 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	context.setUseMDCLogging(true);	from("direct:a").routeId("route-a") .onCompletion() .process(new Processor() {	public void process(Exchange exchange) throws Exception {	assertEquals("route-a", MDC.get("camel.routeId"));	assertEquals(exchange.getExchangeId(), MDC.get("camel.exchangeId"));	assertEquals(exchange.getIn().getMessageId(), MDC.get("camel.messageId"));	assertEquals("1", MDC.get("custom.id"));	
from oncompletion after route a 

assertEquals(exchange.getIn().getMessageId(), MDC.get("camel.messageId"));	assertEquals("1", MDC.get("custom.id"));	}	}) .end() .to("log:foo") .to("direct:b");	from("direct:b").routeId("route-b") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	assertEquals("route-b", MDC.get("camel.routeId"));	assertEquals(exchange.getExchangeId(), MDC.get("camel.exchangeId"));	assertEquals(exchange.getIn().getMessageId(), MDC.get("camel.messageId"));	MDC.put("custom.id", "1");	
from processor in route b 

========================= camel sample_2350 =========================

} else if (exchange.getIn().getHeader(Exchange.CONTENT_TYPE) != null) {	contentType = exchange.getIn().getHeader(Exchange.CONTENT_TYPE, String.class);	}	if (contentType != null && contentType.contains(";")) {	contentType = MailUtils.padContentType(contentType);	}	if (contentType != null) {	String charset = determineCharSet(configuration, exchange);	contentType = MailUtils.replaceCharSet(contentType, charset);	}	
determined content type 

try {	supported = Charset.isSupported(charset);	} catch (IllegalCharsetNameException e) {	supported = false;	}	if (supported) {	return charset;	} else if (!configuration.isIgnoreUnsupportedCharset()) {	return charset;	} else if (configuration.isIgnoreUnsupportedCharset()) {	
charset is not supported and cannot be used as charset in content type header 

protected String populateContentOnMimeMessage(MimeMessage part, MailConfiguration configuration, Exchange exchange) throws MessagingException, IOException {	String contentType = determineContentType(configuration, exchange);	
using content type for mimemessage 

protected String populateContentOnBodyPart(BodyPart part, MailConfiguration configuration, Exchange exchange) throws MessagingException, IOException {	String contentType = determineContentType(configuration, exchange);	if (contentType != null) {	
using content type for bodypart 

public Object extractBodyFromMail(Exchange exchange, MailMessage mailMessage) {	Message message = mailMessage.getMessage();	try {	if (((MailEndpoint) exchange.getFromEndpoint()).getConfiguration().isMapMailMessage()) {	return message.getContent();	}	return message;	} catch (Exception e) {	UnsupportedEncodingException uee = ObjectHelper.getException(UnsupportedEncodingException.class, e);	if (uee != null) {	
unsupported encoding detected 

return message.getContent();	}	return message;	} catch (Exception e) {	UnsupportedEncodingException uee = ObjectHelper.getException(UnsupportedEncodingException.class, e);	if (uee != null) {	try {	String contentType = message.getContentType();	String type = ObjectHelper.before(contentType, "charset=");	if (type != null) {	
trying to extract mail message again with fixed content type 

public void extractAttachmentsFromMail(Message message, Map<String, Attachment> map) throws MessagingException, IOException {	
extracting attachments start 

public void extractAttachmentsFromMail(Message message, Map<String, Attachment> map) throws MessagingException, IOException {	Object content = message.getContent();	if (content instanceof Multipart) {	extractAttachmentsFromMultipart((Multipart) content, map);	} else if (content != null) {	
no attachments to extract as content is not multipart 

public void extractAttachmentsFromMail(Message message, Map<String, Attachment> map) throws MessagingException, IOException {	Object content = message.getContent();	if (content instanceof Multipart) {	extractAttachmentsFromMultipart((Multipart) content, map);	} else if (content != null) {	}	
extracting attachments done 

protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map) throws MessagingException, IOException {	for (int i = 0; i < mp.getCount(); i++) {	Part part = mp.getBodyPart(i);	
part 

protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map) throws MessagingException, IOException {	for (int i = 0; i < mp.getCount(); i++) {	Part part = mp.getBodyPart(i);	if (part.isMimeType("multipart/*")) {	
part is mimetype multipart 

protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map) throws MessagingException, IOException {	for (int i = 0; i < mp.getCount(); i++) {	Part part = mp.getBodyPart(i);	if (part.isMimeType("multipart/*")) {	extractAttachmentsFromMultipart((Multipart) part.getContent(), map);	} else {	String disposition = part.getDisposition();	String fileName = part.getFileName();	if (LOG.isTraceEnabled()) {	
part disposition 

protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map) throws MessagingException, IOException {	for (int i = 0; i < mp.getCount(); i++) {	Part part = mp.getBodyPart(i);	if (part.isMimeType("multipart/*")) {	extractAttachmentsFromMultipart((Multipart) part.getContent(), map);	} else {	String disposition = part.getDisposition();	String fileName = part.getFileName();	if (LOG.isTraceEnabled()) {	
part description 

protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map) throws MessagingException, IOException {	for (int i = 0; i < mp.getCount(); i++) {	Part part = mp.getBodyPart(i);	if (part.isMimeType("multipart/*")) {	extractAttachmentsFromMultipart((Multipart) part.getContent(), map);	} else {	String disposition = part.getDisposition();	String fileName = part.getFileName();	if (LOG.isTraceEnabled()) {	
part contenttype 

protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map) throws MessagingException, IOException {	for (int i = 0; i < mp.getCount(); i++) {	Part part = mp.getBodyPart(i);	if (part.isMimeType("multipart/*")) {	extractAttachmentsFromMultipart((Multipart) part.getContent(), map);	} else {	String disposition = part.getDisposition();	String fileName = part.getFileName();	if (LOG.isTraceEnabled()) {	
part filename 

protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map) throws MessagingException, IOException {	for (int i = 0; i < mp.getCount(); i++) {	Part part = mp.getBodyPart(i);	if (part.isMimeType("multipart/*")) {	extractAttachmentsFromMultipart((Multipart) part.getContent(), map);	} else {	String disposition = part.getDisposition();	String fileName = part.getFileName();	if (LOG.isTraceEnabled()) {	
part size 

protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map) throws MessagingException, IOException {	for (int i = 0; i < mp.getCount(); i++) {	Part part = mp.getBodyPart(i);	if (part.isMimeType("multipart/*")) {	extractAttachmentsFromMultipart((Multipart) part.getContent(), map);	} else {	String disposition = part.getDisposition();	String fileName = part.getFileName();	if (LOG.isTraceEnabled()) {	
part linecount 

for (int i = 0; i < mp.getCount(); i++) {	Part part = mp.getBodyPart(i);	if (part.isMimeType("multipart/*")) {	extractAttachmentsFromMultipart((Multipart) part.getContent(), map);	} else {	String disposition = part.getDisposition();	String fileName = part.getFileName();	if (LOG.isTraceEnabled()) {	}	if (validDisposition(disposition, fileName) || fileName != null) {	
mail contains file attachment 

if (validDisposition(disposition, fileName) || fileName != null) {	if (!map.containsKey(fileName)) {	DefaultAttachment camelAttachment = new DefaultAttachment(part.getDataHandler());	Enumeration<Header> headers = part.getAllHeaders();	while (headers.hasMoreElements()) {	Header header = headers.nextElement();	camelAttachment.addHeader(header.getName(), header.getValue());	}	map.put(fileName, camelAttachment);	} else {	
cannot extract duplicate file attachment 

protected void addAttachmentsToMultipart(MimeMultipart multipart, String partDisposition, AttachmentsContentTransferEncodingResolver encodingResolver, Exchange exchange) throws MessagingException {	
adding attachments start 

protected void addAttachmentsToMultipart(MimeMultipart multipart, String partDisposition, AttachmentsContentTransferEncodingResolver encodingResolver, Exchange exchange) throws MessagingException {	int i = 0;	for (Map.Entry<String, Attachment> entry : exchange.getIn().getAttachmentObjects().entrySet()) {	String attachmentFilename = entry.getKey();	Attachment attachment = entry.getValue();	if (LOG.isTraceEnabled()) {	
attachment disposition 

protected void addAttachmentsToMultipart(MimeMultipart multipart, String partDisposition, AttachmentsContentTransferEncodingResolver encodingResolver, Exchange exchange) throws MessagingException {	int i = 0;	for (Map.Entry<String, Attachment> entry : exchange.getIn().getAttachmentObjects().entrySet()) {	String attachmentFilename = entry.getKey();	Attachment attachment = entry.getValue();	if (LOG.isTraceEnabled()) {	
attachment datahandler 

protected void addAttachmentsToMultipart(MimeMultipart multipart, String partDisposition, AttachmentsContentTransferEncodingResolver encodingResolver, Exchange exchange) throws MessagingException {	int i = 0;	for (Map.Entry<String, Attachment> entry : exchange.getIn().getAttachmentObjects().entrySet()) {	String attachmentFilename = entry.getKey();	Attachment attachment = entry.getValue();	if (LOG.isTraceEnabled()) {	
attachment filename 

for (String value : values) {	messageBodyPart.setHeader(headerName, value);	}	}	if (attachmentFilename.toLowerCase().startsWith("cid:")) {	messageBodyPart.addHeader("Content-ID", "<" + attachmentFilename.substring(4) + ">");	messageBodyPart.setFileName(attachmentFilename.substring(4));	} else {	messageBodyPart.setFileName(attachmentFilename);	}	
attachment contenttype 

}	}	if (attachmentFilename.toLowerCase().startsWith("cid:")) {	messageBodyPart.addHeader("Content-ID", "<" + attachmentFilename.substring(4) + ">");	messageBodyPart.setFileName(attachmentFilename.substring(4));	} else {	messageBodyPart.setFileName(attachmentFilename);	}	if (contentTypeResolver != null) {	String contentType = contentTypeResolver.resolveContentType(attachmentFilename);	
attachment using content type resolver resolved content type as 

messageBodyPart.addHeader("Content-ID", "<" + attachmentFilename.substring(4) + ">");	messageBodyPart.setFileName(attachmentFilename.substring(4));	} else {	messageBodyPart.setFileName(attachmentFilename);	}	if (contentTypeResolver != null) {	String contentType = contentTypeResolver.resolveContentType(attachmentFilename);	if (contentType != null) {	String value = contentType + "; name=" + attachmentFilename;	messageBodyPart.setHeader("Content-Type", value);	
attachment contenttype 

String contentType = contentTypeResolver.resolveContentType(attachmentFilename);	if (contentType != null) {	String value = contentType + "; name=" + attachmentFilename;	messageBodyPart.setHeader("Content-Type", value);	}	}	resolveContentTransferEncoding(encodingResolver, i, messageBodyPart);	messageBodyPart.setDisposition(partDisposition);	multipart.addBodyPart(messageBodyPart);	} else {	
shouldaddattachment false 

String value = contentType + "; name=" + attachmentFilename;	messageBodyPart.setHeader("Content-Type", value);	}	}	resolveContentTransferEncoding(encodingResolver, i, messageBodyPart);	messageBodyPart.setDisposition(partDisposition);	multipart.addBodyPart(messageBodyPart);	} else {	}	} else {	
cannot add attachment as datahandler is null 

}	resolveContentTransferEncoding(encodingResolver, i, messageBodyPart);	messageBodyPart.setDisposition(partDisposition);	multipart.addBodyPart(messageBodyPart);	} else {	}	} else {	}	i++;	}	
adding attachments done 

protected void resolveContentTransferEncoding(AttachmentsContentTransferEncodingResolver resolver, int i, BodyPart messageBodyPart) throws MessagingException {	if (resolver != null) {	String contentTransferEncoding = resolver.resolveContentTransferEncoding(messageBodyPart);	
attachment using content transfer encoding resolver resolved content transfer encoding as 

========================= camel sample_11884 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from("direct:start") .log("Start ${body}") .split(body().tokenize("@"), new UseLatestAggregationStrategy()).parallelProcessing().streaming() .process(new Processor() {	public void process(Exchange exchange) throws Exception {	int num = exchange.getIn().getBody(int.class);	final long sleep = num * delay;	
sleep for ms 

========================= camel sample_3812 =========================

public static void startGrpcServer() throws Exception {	grpcServerWithTLS = NettyServerBuilder.forPort(GRPC_TLS_TEST_PORT) .sslContext(GrpcSslContexts.forServer(new File("src/test/resources/certs/server.pem"), new File("src/test/resources/certs/server.key")) .trustManager(new File("src/test/resources/certs/ca.pem")) .clientAuth(ClientAuth.REQUIRE) .sslProvider(SslProvider.OPENSSL) .build()) .addService(new PingPongImpl()).build().start();	grpcServerWithJWT = NettyServerBuilder.forPort(GRPC_JWT_TEST_PORT) .addService(new PingPongImpl()) .intercept(new JwtServerInterceptor(JwtAlgorithm.HMAC256, GRPC_JWT_CORRECT_SECRET, null, null)) .build() .start();	
grpc server with tls started on port 

public static void startGrpcServer() throws Exception {	grpcServerWithTLS = NettyServerBuilder.forPort(GRPC_TLS_TEST_PORT) .sslContext(GrpcSslContexts.forServer(new File("src/test/resources/certs/server.pem"), new File("src/test/resources/certs/server.key")) .trustManager(new File("src/test/resources/certs/ca.pem")) .clientAuth(ClientAuth.REQUIRE) .sslProvider(SslProvider.OPENSSL) .build()) .addService(new PingPongImpl()).build().start();	grpcServerWithJWT = NettyServerBuilder.forPort(GRPC_JWT_TEST_PORT) .addService(new PingPongImpl()) .intercept(new JwtServerInterceptor(JwtAlgorithm.HMAC256, GRPC_JWT_CORRECT_SECRET, null, null)) .build() .start();	
grpc server with the jwt auth started on port 

public static void stopGrpcServer() throws IOException {	if (grpcServerWithTLS != null) {	grpcServerWithTLS.shutdown();	
grpc server with tls stoped 

public static void stopGrpcServer() throws IOException {	if (grpcServerWithTLS != null) {	grpcServerWithTLS.shutdown();	}	if (grpcServerWithJWT != null) {	grpcServerWithJWT.shutdown();	
grpc server with jwt stoped 

public void testWithEnableTLS() throws Exception {	
grpc pingsyncsync method test start with tls enable 

public void testWithCorrectJWT() throws Exception {	
grpc pingsyncsync method test start with correct jwt authentication 

public void testWithIncorrectJWT() throws Exception {	
grpc pingsyncsync method test start with incorrect jwt authentication 

========================= camel sample_7502 =========================

public void process(Exchange exchange) throws Exception {	try {	if (connection == null) {	connection = endpoint.createConnection();	}	if (!connection.isConnected()) {	if (LOG.isDebugEnabled()) {	
reconnecting to 

========================= camel sample_12601 =========================

public void testHammerJms() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(size);	for (int i = 0; i < size; i++) {	template.sendBody("direct:start", message);	
send 

========================= camel sample_7125 =========================

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyRouteTest.java"));	MethodSource<JavaClassSource> method = CamelJavaParserHelper.findConfigureMethod(clazz);	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, false);	for (ParserResult result : list) {	
consumer 

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyRouteTest.java"));	MethodSource<JavaClassSource> method = CamelJavaParserHelper.findConfigureMethod(clazz);	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, false);	for (ParserResult result : list) {	}	Assert.assertEquals("direct:foo", list.get(0).getElement());	list = CamelJavaParserHelper.parseCamelProducerUris(method, true, false);	for (ParserResult result : list) {	
producer 

========================= camel sample_196 =========================

public PullRequestCommentProducer(GitHubEndpoint endpoint) throws Exception {	super(endpoint);	Registry registry = endpoint.getCamelContext().getRegistry();	Object service = registry.lookupByName(GitHubConstants.GITHUB_PULL_REQUEST_SERVICE);	if (service != null) {	
using pullrequestservice found in registry 

========================= camel sample_14258 =========================

protected void assertMethodPattern(BeanInfo info, String methodName, ExchangePattern expectedPattern) throws NoSuchMethodException {	Class<?> type = info.getType();	Method method = type.getMethod(methodName);	assertNotNull("Could not find method: " + methodName, method);	MethodInfo methodInfo = info.getMethodInfo(method);	assertNotNull("Could not find methodInfo for: " + method, methodInfo);	ExchangePattern actualPattern = methodInfo.getPattern();	assertEquals("Pattern for: " + method, expectedPattern, actualPattern);	
method has pattern 

========================= camel sample_3166 =========================

private static Calendar parseRfc3164Date(ByteBuffer byteBuffer) {	char charFound;	char[] month = new char[3];	for (int i = 0; i < 3; i++) {	month[i] = (char) (byteBuffer.get() & 0xff);	}	charFound = (char) byteBuffer.get();	if (charFound != ' ') {	
invalid syslog message missing a mandatory space after month 

========================= camel sample_6734 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<XPathLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.xpath.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.xpath.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_895 =========================

protected Language getLanguage(String name, CamelContext context) {	
finding language 

protected LanguageResolver getLanguageResolver(String name, CamelContext context) {	
finding languageresolver 

========================= camel sample_13088 =========================

protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> properties) throws Exception {	AS400ConnectionPool connectionPool;	if (properties.containsKey(CONNECTION_POOL)) {	
instance specified in the uri will look it up 

protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> properties) throws Exception {	AS400ConnectionPool connectionPool;	if (properties.containsKey(CONNECTION_POOL)) {	String poolId = properties.remove(CONNECTION_POOL).toString();	connectionPool = EndpointHelper.resolveReferenceParameter(getCamelContext(), poolId, AS400ConnectionPool.class, true);	} else {	
no instance specified in the uri one will be provided 

public synchronized AS400ConnectionPool getConnectionPool() {	if (connectionPool == null) {	
instantiating the default connection pool 

protected void doShutdown() throws Exception {	super.doShutdown();	if (connectionPool != null) {	
shutting down the default connection pool 

========================= camel sample_16770 =========================

protected void doSuspend() throws Exception {	if (channel != null) {	
serverbootstrap disconnecting from 

serverBootstrap.setOption("reuseAddress", configuration.isReuseAddress());	serverBootstrap.setOption("connectTimeoutMillis", configuration.getConnectTimeout());	if (configuration.getBacklog() > 0) {	serverBootstrap.setOption("backlog", configuration.getBacklog());	}	if (configuration.getOptions() != null) {	for (Map.Entry<String, Object> entry : configuration.getOptions().entrySet()) {	serverBootstrap.setOption(entry.getKey(), entry.getValue());	}	}	
created serverbootstrap with options 

serverBootstrap.setOption("connectTimeoutMillis", configuration.getConnectTimeout());	if (configuration.getBacklog() > 0) {	serverBootstrap.setOption("backlog", configuration.getBacklog());	}	if (configuration.getOptions() != null) {	for (Map.Entry<String, Object> entry : configuration.getOptions().entrySet()) {	serverBootstrap.setOption(entry.getKey(), entry.getValue());	}	}	serverBootstrap.setPipelineFactory(pipelineFactory);	
serverbootstrap connecting to 

protected Channel openChannel(ChannelFuture channelFuture) throws Exception {	if (LOG.isTraceEnabled()) {	
waiting for operation to complete for millis 

}	if (!channelFuture.isDone() || !channelFuture.isSuccess()) {	ConnectException cause = new ConnectException("Cannot connect to " + configuration.getAddress());	if (channelFuture.getCause() != null) {	cause.initCause(channelFuture.getCause());	}	throw cause;	}	Channel answer = channelFuture.getChannel();	if (LOG.isDebugEnabled()) {	
creating connector to address 

protected void stopServerBootstrap() {	
serverbootstrap disconnecting from 

========================= camel sample_6671 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<TidyMarkupDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.tidymarkup.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.tidymarkup.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_483 =========================

public void configure() throws Exception {	String routeId = "mllp-test-receiver-route";	onCompletion() .to("mock: .toF("log:%s?level=INFO&showAll=true", routeId) .log(LoggingLevel.INFO, routeId, "Test route complete");	
mllp mllpclient getmllphost mllpclient getmllpport connecttimeout responsetimeout routeid routeid log logginglevel info routeid message to result 

========================= camel sample_13821 =========================

public Exchange add(final CamelContext camelContext, final String key, final Exchange exchange) {	
adding an exchange with id for key in a thread safe manner 

public void remove(CamelContext camelContext, String key, Exchange exchange) {	
removing an exchange with id for key 

public void confirm(CamelContext camelContext, String exchangeId) {	
confirming an exchange with id 

public Set<String> scan(CamelContext camelContext) {	
scanning for exchanges to recover in context 

public Set<String> scan(CamelContext camelContext) {	Set<String> scanned = Collections.unmodifiableSet(getKeys());	
found keys for exchanges to recover in context 

public Exchange recover(CamelContext camelContext, String exchangeId) {	
recovering an exchange with id 

========================= camel sample_12733 =========================

private boolean convertIfRequired(Message message, DataType type) throws Exception {	if (type != null && type.isJavaType() && type.getName() != null) {	CamelContext context = message.getExchange().getContext();	Class<?> typeJava = getClazz(type.getName(), context);	if (!typeJava.isAssignableFrom(message.getBody().getClass())) {	
converting to 

========================= camel sample_4565 =========================

public void groupEvent(Group group, GroupEvent event) {	switch (event) {	case CONNECTED: break;	case CHANGED: if (singleton.isConnected()) {	if (singleton.isMaster()) {	if (LOG.isDebugEnabled()) {	
master standby endpoint is master for in 

public void groupEvent(Group group, GroupEvent event) {	switch (event) {	case CONNECTED: break;	case CHANGED: if (singleton.isConnected()) {	if (singleton.isMaster()) {	if (LOG.isDebugEnabled()) {	}	onLockOwned();	} else {	if (LOG.isDebugEnabled()) {	
master standby endpoint is standby for in 

if (LOG.isDebugEnabled()) {	}	onLockOwned();	} else {	if (LOG.isDebugEnabled()) {	}	}	}	break;	case DISCONNECTED: try {	
disconnecting as master stopping consumer 

onLockOwned();	} else {	if (LOG.isDebugEnabled()) {	}	}	}	break;	case DISCONNECTED: try {	onDisconnected();	} catch (Exception e) {	
failed to stop master consumer for this exception is ignored 

========================= camel sample_9707 =========================

public void process(Exchange exchange) throws Exception {	List<Exchange> entryList = prepareExchangeList(exchange);	if (entryList == null || entryList.size() == 0) {	
the incoming message is either null or empty triggered by an aggregation timeout 

public void process(Exchange exchange) throws Exception {	List<Exchange> entryList = prepareExchangeList(exchange);	if (entryList == null || entryList.size() == 0) {	return;	}	if (logger.isDebugEnabled()) {	
uploader thread id api call completed 

========================= camel sample_17248 =========================

try {	String fqn = file.getPath();	String baseDir = ".";	JavaType out = Roaster.parse(file);	if (out instanceof JavaClassSource) {	JavaClassSource clazz = (JavaClassSource) out;	List<CamelNodeDetails> result = RouteBuilderParser.parseRouteBuilderTree(clazz, baseDir, fqn, true);	routeTrees.addAll(result);	}	} catch (Exception e) {	
error parsing java file code due 

for (File file : xmlFiles) {	if (matchFile(file)) {	try {	String fqn = file.getPath();	String baseDir = ".";	InputStream is = new FileInputStream(file);	List<CamelNodeDetails> result = XmlRouteParser.parseXmlRouteTree(is, baseDir, fqn);	routeTrees.addAll(result);	is.close();	} catch (Exception e) {	
error parsing xml file code due 

String fqn = file.getPath();	String baseDir = ".";	InputStream is = new FileInputStream(file);	List<CamelNodeDetails> result = XmlRouteParser.parseXmlRouteTree(is, baseDir, fqn);	routeTrees.addAll(result);	is.close();	} catch (Exception e) {	}	}	}	
discovered routes 

InputStream is = new FileInputStream(file);	List<CamelNodeDetails> result = XmlRouteParser.parseXmlRouteTree(is, baseDir, fqn);	routeTrees.addAll(result);	is.close();	} catch (Exception e) {	}	}	}	long anonymous = routeTrees.stream().filter(t -> t.getRouteId() == null).count();	if (!anonymousRoutes && anonymous > 0) {	
discovered anonymous routes add route ids to these routes for route coverage support 

}	final AtomicInteger notCovered = new AtomicInteger();	List<CamelNodeDetails> routeIdTrees = routeTrees.stream().filter(t -> t.getRouteId() != null).collect(Collectors.toList());	List<CamelNodeDetails> anonymousRouteTrees = routeTrees.stream().filter(t -> t.getRouteId() == null).collect(Collectors.toList());	for (CamelNodeDetails t : routeIdTrees) {	String routeId = t.getRouteId();	String fileName = stripRootPath(asRelativeFile(t.getFileName()));	try {	List<CoverageData> coverageData = RouteCoverageHelper.parseDumpRouteCoverageByRouteId("target/camel-route-coverage", routeId);	if (coverageData.isEmpty()) {	
no route coverage data found for route make sure to enable route coverage in your unit tests and assign unique route ids to your routes also remember to run unit tests first 

List<CamelNodeDetails> anonymousRouteTrees = routeTrees.stream().filter(t -> t.getRouteId() == null).collect(Collectors.toList());	for (CamelNodeDetails t : routeIdTrees) {	String routeId = t.getRouteId();	String fileName = stripRootPath(asRelativeFile(t.getFileName()));	try {	List<CoverageData> coverageData = RouteCoverageHelper.parseDumpRouteCoverageByRouteId("target/camel-route-coverage", routeId);	if (coverageData.isEmpty()) {	} else {	List<RouteCoverageNode> coverage = gatherRouteCoverageSummary(Collections.singletonList(t), coverageData);	String out = templateCoverageData(fileName, routeId, coverage, notCovered);	
route coverage summary 

getLog().info("");	}	} catch (Exception e) {	throw new MojoExecutionException("Error during gathering route coverage data for route: " + routeId, e);	}	}	if (anonymousRoutes && !anonymousRouteTrees.isEmpty()) {	try {	Map<String, List<CoverageData>> datas = RouteCoverageHelper.parseDumpRouteCoverageByClassAndTestMethod("target/camel-route-coverage");	if (datas.isEmpty()) {	
no route coverage data found make sure to enable route coverage in your unit tests also remember to run unit tests first 

String key = entry.getKey();	String dataClassName = key.substring(0, key.indexOf('-'));	if (dataClassName.equals(className)) {	List<RouteCoverageNode> result = gatherRouteCoverageSummary(t.getValue(), entry.getValue());	mergeCoverageData(coverage, result);	}	}	if (!coverage.isEmpty()) {	String fileName = stripRootPath(asRelativeFile(t.getValue().get(0).getFileName()));	String out = templateCoverageData(fileName, null, coverage, notCovered);	
route coverage summary 

========================= camel sample_70 =========================

public void appendBuilders(List<RoutesBuilder> list) throws IllegalAccessException, InstantiationException {	Set<Class<?>> classes = resolver.findImplementations(RoutesBuilder.class, packages);	for (Class<?> aClass : classes) {	
found routebuilder class 

public void appendBuilders(List<RoutesBuilder> list) throws IllegalAccessException, InstantiationException {	Set<Class<?>> classes = resolver.findImplementations(RoutesBuilder.class, packages);	for (Class<?> aClass : classes) {	if (shouldIgnoreBean(aClass)) {	
ignoring routebuilder class 

public void appendBuilders(List<RoutesBuilder> list) throws IllegalAccessException, InstantiationException {	Set<Class<?>> classes = resolver.findImplementations(RoutesBuilder.class, packages);	for (Class<?> aClass : classes) {	if (shouldIgnoreBean(aClass)) {	continue;	}	if (!isValidClass(aClass)) {	
ignoring invalid routebuilder class 

public void appendBuilders(List<RoutesBuilder> list) throws IllegalAccessException, InstantiationException {	Set<Class<?>> classes = resolver.findImplementations(RoutesBuilder.class, packages);	for (Class<?> aClass : classes) {	if (shouldIgnoreBean(aClass)) {	continue;	}	if (!isValidClass(aClass)) {	continue;	}	RoutesBuilder builder = instantiateBuilder(aClass);	
adding instantiated routebuilder 

========================= camel sample_8116 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<BeanValidatorComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.bean-validator.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.bean-validator.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_745 =========================

public void onNewArtifacts(Set<NexusArtifactDto> newArtifacts) {	for (NexusArtifactDto dto : newArtifacts) {	try {	
processing new artifact 

public void onNewArtifacts(Set<NexusArtifactDto> newArtifacts) {	for (NexusArtifactDto dto : newArtifacts) {	try {	String url = createArtifactURL(dto);	URL jarUrl = new URL(url);	addCustomCamelComponentsFromArtifact(dto, jarUrl);	} catch (Throwable e) {	
error downloading component jar this exception is ignored 

if (javaType != null) {	String json = loadComponentJSonSchema(log, classLoader, scheme);	if (json != null) {	addComponent(dto, getCamelCatalog(), scheme, javaType, json);	}	}	}	}	}	} catch (IOException e) {	
error scanning jar for custom camel components 

========================= camel sample_315 =========================

public void testLoadTestHawtDBAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(10);	mock.setResultWaitTime(50 * 1000);	ExecutorService executor = Executors.newFixedThreadPool(10);	
staring to send messages 

MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(10);	mock.setResultWaitTime(50 * 1000);	ExecutorService executor = Executors.newFixedThreadPool(10);	for (int i = 0; i < SIZE; i++) {	final int value = 1;	final int key = i % 10;	executor.submit(new Callable<Object>() {	public Object call() throws Exception {	char id = KEYS[key];	
sending with id 

final int key = i % 10;	executor.submit(new Callable<Object>() {	public Object call() throws Exception {	char id = KEYS[key];	template.sendBodyAndHeader("direct:start", value, "id", "" + id);	Thread.sleep(3);	return null;	}	});	}	
sending all message done now waiting for aggregation to complete 

========================= camel sample_11723 =========================

public void remove(Table table, byte[] row) {	Delete delete = new Delete(row);	try {	table.delete(delete);	} catch (IOException e) {	
failed to delete row from table this exception will be ignored 

========================= camel sample_14521 =========================

public String doOrder(Order order) {	
processing order 

========================= camel sample_7871 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<AtmosComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.atmos.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.atmos.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_968 =========================

public void onEvent(BoxEvent event) {	try {	
processed event for 

public void onEvent(BoxEvent event) {	try {	} catch (Exception e) {	
received exception consuming event 

========================= camel sample_17423 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<DozerComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.dozer.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.dozer.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_591 =========================

public void doCheese() {	
docheese called 

========================= camel sample_10759 =========================

public void validate(Message message, DataType type) throws ValidationException {	Exchange exchange = message.getExchange();	
sending to validate processor 

========================= camel sample_3977 =========================

protected void onEventBusEvent(final Message event) {	
onevent 

protected void onEventBusEvent(final Message event) {	final boolean reply = event.replyAddress() != null;	final Exchange exchange = endpoint.createExchange(reply ? ExchangePattern.InOut : ExchangePattern.InOnly);	exchange.getIn().setBody(event.body());	try {	getAsyncProcessor().process(exchange, new AsyncCallback() {	public void done(boolean doneSync) {	if (reply) {	Object body = getVertxBody(exchange);	if (body != null) {	
sending reply to with body 

protected void doStart() throws Exception {	if (LOG.isDebugEnabled()) {	
registering eventbus handler on address 

protected void doStop() throws Exception {	if (LOG.isDebugEnabled()) {	
unregistering eventbus handler on address 

protected void doStop() throws Exception {	if (LOG.isDebugEnabled()) {	}	try {	if (messageConsumer != null && messageConsumer.isRegistered()) {	messageConsumer.unregister();	messageConsumer = null;	}	} catch (IllegalStateException e) {	
eventbus already stopped on address 

========================= camel sample_11518 =========================

public void create() throws Exception {	
creating database tables 

if (connection == null) {	EmbeddedDriver driver = new EmbeddedDriver();	connection = driver.connect(url + ";create=true", null);	}	String sql = "create table ORDERS (\n" + "  ORD_ID integer primary key,\n" + "  ITEM varchar(10),\n" + "  ITEM_COUNT varchar(5),\n" + "  ITEM_DESC varchar(30),\n" + "  ORD_DELETED boolean\n" + ")";	try {	execute("drop table orders");	} catch (Throwable e) {	}	execute(sql);	
database tables created 

public void drop() throws Exception {	
dropping database tables 

public void drop() throws Exception {	try {	execute("drop table orders");	} catch (Throwable e) {	}	connection.close();	
database tables dropped 

========================= camel sample_17835 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<CxfRsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.cxfrs.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.cxfrs.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_987 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<QuickfixjComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.quickfix.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.quickfix.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1049 =========================

public void configure() {	errorHandler(deadLetterChannel("mock:error") .maximumRedeliveries(3) .redeliveryDelay(0L) .onRedelivery(new Processor() {	public void process(Exchange exchange) throws Exception {	final Message in = exchange.getIn();	final int count = in.getHeader(Exchange.REDELIVERY_COUNTER, Integer.class);	final int maxCount = in.getHeader(Exchange.REDELIVERY_MAX_COUNTER, Integer.class);	log.info("Redelivery count = {}", count);	if (count >= (maxCount - 1)) {	if (sshd != null) {	sshd.start();	
restarting sshd 

========================= camel sample_10020 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<JaxbDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.jaxb.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.jaxb.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_657 =========================

StringBuilder sb = new StringBuilder();	for (char ch : hostName.toCharArray()) {	if (ch < 127) {	sb.append(ch);	} else {	changed = true;	}	}	if (changed) {	String newHost = sb.toString();	
sanitized hostname from to 

========================= camel sample_4162 =========================

protected void doStart() throws Exception {	if (producerCache == null) {	if (cacheSize < 0) {	producerCache = new EmptyProducerCache(this, camelContext);	
recipientlist is not using producercache 

protected void doStart() throws Exception {	if (producerCache == null) {	if (cacheSize < 0) {	producerCache = new EmptyProducerCache(this, camelContext);	} else if (cacheSize == 0) {	producerCache = new ProducerCache(this, camelContext);	
recipientlist using producercache with default cache size 

========================= camel sample_4532 =========================

private Connection openConnection() throws IOException, TimeoutException {	if (!isConnectionOpened()) {	
open connection 

private Channel openChannel() throws IOException, TimeoutException {	if (!isChannelOpened()) {	
open channel 

public void closeConnection() throws TimeoutException {	if (isChannelOpened()) {	try {	
close channel 

public void closeConnection() throws TimeoutException {	if (isChannelOpened()) {	try {	channel.close();	} catch (IOException e) {	}	}	if (isConnectionOpened()) {	try {	
close connection 

========================= camel sample_14126 =========================

public void read(String body, @Simple("${header.foo}") String foo) {	this.foo = foo;	this.body = body;	
read method called on 

========================= camel sample_3218 =========================

public void transform(Message message, DataType from, DataType to) throws Exception {	Exchange exchange = message.getExchange();	CamelContext context = exchange.getContext();	if ((to == null || to.isJavaType()) && (from.equals(getFrom()) || from.getModel().equals(getModel()))) {	DataFormat dataFormat = getDataFormat(exchange);	
unmarshaling with 

public void transform(Message message, DataType from, DataType to) throws Exception {	Exchange exchange = message.getExchange();	CamelContext context = exchange.getContext();	if ((to == null || to.isJavaType()) && (from.equals(getFrom()) || from.getModel().equals(getModel()))) {	DataFormat dataFormat = getDataFormat(exchange);	Object answer = dataFormat.unmarshal(exchange, message.getBody(InputStream.class));	if (to != null && to.getName() != null) {	Class<?> toClass = context.getClassResolver().resolveClass(to.getName());	if (!toClass.isAssignableFrom(answer.getClass())) {	
converting to 

if (!toClass.isAssignableFrom(answer.getClass())) {	answer = context.getTypeConverter().mandatoryConvertTo(toClass, answer);	}	}	message.setBody(answer);	} else if ((from == null || from.isJavaType()) && (to.equals(getTo()) || to.getModel().equals(getModel()))) {	Object input = message.getBody();	if (from != null && from.getName() != null) {	Class<?> fromClass = context.getClassResolver().resolveClass(from.getName());	if (!fromClass.isAssignableFrom(input.getClass())) {	
converting to 

} else if ((from == null || from.isJavaType()) && (to.equals(getTo()) || to.getModel().equals(getModel()))) {	Object input = message.getBody();	if (from != null && from.getName() != null) {	Class<?> fromClass = context.getClassResolver().resolveClass(from.getName());	if (!fromClass.isAssignableFrom(input.getClass())) {	input = context.getTypeConverter().mandatoryConvertTo(fromClass, input);	}	}	OutputStreamBuilder osb = OutputStreamBuilder.withExchange(exchange);	DataFormat dataFormat = getDataFormat(exchange);	
marshaling with 

========================= camel sample_4027 =========================

public void testApi() throws Exception {	Exchange exchange = template.request("http: assertThat(exchange.getOut().getHeader(HTTP_RESPONSE_CODE, Integer.class), is(200));	String body = exchange.getOut().getBody(String.class);	
received body 

========================= camel sample_9245 =========================

public void initialize(Client client, Bus bus) {	client.getEndpoint().put("org.apache.cxf.binding.soap.addNamespaceContext", "true");	removeFaultInInterceptorFromClient(client);	removeInterceptor(client.getEndpoint().getInInterceptors(), HolderInInterceptor.class);	removeInterceptor(client.getEndpoint().getOutInterceptors(), HolderOutInterceptor.class);	removeInterceptor(client.getEndpoint().getBinding().getInInterceptors(), SoapHeaderInterceptor.class);	client.getEndpoint().getBinding().getInInterceptors().add(new ConfigureDocLitWrapperInterceptor(true));	resetPartTypes(client.getEndpoint().getBinding());	
initialized cxf client in payload mode with allow streaming 

public void initialize(Server server, Bus bus) {	server.getEndpoint().put("org.apache.cxf.binding.soap.addNamespaceContext", "true");	server.getEndpoint().getBinding().getInInterceptors().add(new ConfigureDocLitWrapperInterceptor(true));	if (server.getEndpoint().getBinding() instanceof SoapBinding) {	server.getEndpoint().getBinding().getOutInterceptors().add(new SetSoapVersionInterceptor());	}	removeInterceptor(server.getEndpoint().getInInterceptors(), HolderInInterceptor.class);	removeInterceptor(server.getEndpoint().getOutInterceptors(), HolderOutInterceptor.class);	removeInterceptor(server.getEndpoint().getBinding().getInInterceptors(), SoapHeaderInterceptor.class);	resetPartTypes(server.getEndpoint().getBinding());	
initialized cxf server in payload mode with allow streaming 

========================= camel sample_8004 =========================

public void notifyElementEvicted(Ehcache cache, Element element) {	
element is being evicted from cache 

public void notifyElementExpired(Ehcache cache, Element element) {	
element has expired in cache 

public void notifyElementPut(Ehcache cache, Element element) throws CacheException {	
element has just been added put in cache 

public void notifyElementRemoved(Ehcache cache, Element element) throws CacheException {	
element has just been removed from cache 

public void notifyElementUpdated(Ehcache cache, Element element) throws CacheException {	
element has just been updated in cache 

public void notifyRemoveAll(Ehcache cache) {	
cache is being emptied and all elements removed 

private void dispatchExchange(Ehcache cache, Element element, String operation) {	Exchange exchange;	
consumer dispatching the exchange containing the element in cache 

========================= camel sample_10535 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<HazelcastSetComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-set.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-set.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_712 =========================

private CuratorFramework getOrCreateCurator() throws Exception {	if (curator == null) {	curator = configuration.getCuratorFramework();	if (curator == null) {	managedInstance = true;	
starting zookeeper curator with namespace nodes 

========================= camel sample_12637 =========================

public void testStaticResource() throws Exception {	AsyncHttpClient c = new DefaultAsyncHttpClient();	WebSocket websocket = c.prepareGet("ws: new WebSocketUpgradeHandler.Builder() .addWebSocketListener(new WebSocketTextListener() {	public void onMessage(String message) {	received.add(message);	
received 

========================= camel sample_17435 =========================

public void testGet() throws Exception {	final com.google.api.services.drive.model.About result = requestBody("direct: assertNotNull("get result", result);	
get 

========================= camel sample_15408 =========================

try {	getProcessor().process(camelExchange);	} catch (Exception e) {	getExceptionHandler().handleException(e);	} finally {	doneUoW(camelExchange);	}	Object body = getResponseBody(httpExchange, camelExchange);	TypeConverter tc = getEndpoint().getCamelContext().getTypeConverter();	if (body == null) {	
no payload to send as reply for exchange 

========================= camel sample_13163 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<DigitalOceanComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.digitalocean.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.digitalocean.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_991 =========================

public void testJaxrsRelayRoute() throws Exception {	final Main main = new Main();	try {	main.setApplicationContextUri("org/apache/camel/component/cxf/jaxrs/CxfRsSpringRelay.xml");	main.start();	Thread t = new Thread(new Runnable() {	public void run() {	try {	JAXRSClientFactory.create("http: .upload(CamelRouteBuilder.class.getResourceAsStream(SAMPLE_CONTENT_PATH), SAMPLE_NAME);	} catch (Exception e) {	
error uploading to http 

========================= camel sample_7922 =========================

public void testGetCompanies() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.email_domain", "linkedin.com");	final org.apache.camel.component.linkedin.api.model.Companies result = requestBodyAndHeaders("direct: assertNotNull("getCompanies result", result);	
getcompanies 

public void testGetCompanyById() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.company_id", TEST_COMPANY_ID);	headers.put("CamelLinkedIn.fields", null);	final org.apache.camel.component.linkedin.api.model.Company result = requestBodyAndHeaders("direct: assertNotNull("getCompanyById result", result);	
getcompanybyid 

public void testGetCompanyByName() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.universal_name", "linkedin");	headers.put("CamelLinkedIn.fields", null);	final org.apache.camel.component.linkedin.api.model.Company result = requestBodyAndHeaders("direct: assertNotNull("getCompanyByName result", result);	
getcompanybyname 

public void testGetCompanyUpdateComments() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.company_id", 0L);	headers.put("CamelLinkedIn.update_key", null);	headers.put("CamelLinkedIn.fields", null);	headers.put("CamelLinkedIn.secure_urls", null);	final org.apache.camel.component.linkedin.api.model.UpdateComments result = requestBodyAndHeaders("direct: assertNotNull("getCompanyUpdateComments result", result);	
getcompanyupdatecomments 

public void testGetCompanyUpdateLikes() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.company_id", 0L);	headers.put("CamelLinkedIn.update_key", null);	headers.put("CamelLinkedIn.fields", null);	headers.put("CamelLinkedIn.secure_urls", null);	final org.apache.camel.component.linkedin.api.model.Likes result = requestBodyAndHeaders("direct: assertNotNull("getCompanyUpdateLikes result", result);	
getcompanyupdatelikes 

public void testGetCompanyUpdates() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.company_id", TEST_COMPANY_ID);	headers.put("CamelLinkedIn.event_type", EventType.STATUS_UPDATE);	headers.put("CamelLinkedIn.start", null);	headers.put("CamelLinkedIn.count", null);	final org.apache.camel.component.linkedin.api.model.Updates result = requestBodyAndHeaders("direct: assertNotNull("getCompanyUpdates result", result);	
getcompanyupdates 

public void testGetHistoricalFollowStatistics() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.company_id", 0L);	headers.put("CamelLinkedIn.start_timestamp", null);	headers.put("CamelLinkedIn.end_timestamp", null);	headers.put("CamelLinkedIn.time_granularity", null);	final org.apache.camel.component.linkedin.api.model.HistoricalFollowStatistics result = requestBodyAndHeaders("direct: assertNotNull("getHistoricalFollowStatistics result", result);	
gethistoricalfollowstatistics 

public void testGetHistoricalStatusUpdateStatistics() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.company_id", TEST_COMPANY_ID);	headers.put("CamelLinkedIn.start_timestamp", null);	headers.put("CamelLinkedIn.end_timestamp", null);	headers.put("CamelLinkedIn.time_granularity", null);	headers.put("CamelLinkedIn.statistics_update_key", null);	final org.apache.camel.component.linkedin.api.model.HistoricalStatusUpdateStatistics result = requestBodyAndHeaders("direct: assertNotNull("getHistoricalStatusUpdateStatistics result", result);	
gethistoricalstatusupdatestatistics 

public void testGetNumberOfFollowers() throws Exception {	final Map<String, Object> headers = new HashMap<String, Object>();	headers.put("CamelLinkedIn.company_id", TEST_COMPANY_ID);	headers.put("CamelLinkedIn.geos", null);	headers.put("CamelLinkedIn.companySizes", null);	headers.put("CamelLinkedIn.jobFunc", null);	headers.put("CamelLinkedIn.industries", null);	headers.put("CamelLinkedIn.seniorities", null);	final org.apache.camel.component.linkedin.api.model.NumFollowers result = requestBodyAndHeaders("direct: assertNotNull("getNumberOfFollowers result", result);	
getnumberoffollowers 

public void testGetStatistics() throws Exception {	final org.apache.camel.component.linkedin.api.model.CompanyStatistics result = requestBody("direct: assertNotNull("getStatistics result", result);	
getstatistics 

public void testIsShareEnabled() throws Exception {	final org.apache.camel.component.linkedin.api.model.IsCompanyShareEnabled result = requestBody("direct: assertNotNull("isShareEnabled result", result);	
isshareenabled 

public void testIsViewerShareEnabled() throws Exception {	final org.apache.camel.component.linkedin.api.model.IsCompanyShareEnabled result = requestBody("direct: assertNotNull("isViewerShareEnabled result", result);	
isviewershareenabled 

========================= camel sample_8854 =========================

protected abstract Trigger createTrigger(Action action, Route route) throws Exception;	protected void onJobExecute(Action action, Route route) throws Exception {	
scheduled event notification received performing action on route 

if (action == Action.START) {	if (routeStatus == ServiceStatus.Stopped) {	startRoute(route);	} else if (ServiceHelper.isSuspended(route.getConsumer())) {	resumeOrStartConsumer(route.getConsumer());	}	} else if (action == Action.STOP) {	if ((routeStatus == ServiceStatus.Started) || (routeStatus == ServiceStatus.Suspended)) {	stopRoute(route, getRouteStopGracePeriod(), getTimeUnit());	} else {	
route is not in a started suspended state and cannot be stopped the current route state is 

}	} else if (action == Action.STOP) {	if ((routeStatus == ServiceStatus.Started) || (routeStatus == ServiceStatus.Suspended)) {	stopRoute(route, getRouteStopGracePeriod(), getTimeUnit());	} else {	}	} else if (action == Action.SUSPEND) {	if (routeStatus == ServiceStatus.Started) {	suspendOrStopConsumer(route.getConsumer());	} else {	
route is not in a started state and cannot be suspended the current route state is 

} else if (action == Action.SUSPEND) {	if (routeStatus == ServiceStatus.Started) {	suspendOrStopConsumer(route.getConsumer());	} else {	}	} else if (action == Action.RESUME) {	if (routeStatus == ServiceStatus.Started) {	if (ServiceHelper.isSuspended(route.getConsumer())) {	resumeOrStartConsumer(route.getConsumer());	} else {	
the consumer is not suspended and cannot be resumed 

suspendOrStopConsumer(route.getConsumer());	} else {	}	} else if (action == Action.RESUME) {	if (routeStatus == ServiceStatus.Started) {	if (ServiceHelper.isSuspended(route.getConsumer())) {	resumeOrStartConsumer(route.getConsumer());	} else {	}	} else {	
route is not in a started state and cannot be resumed the current route state is 

public void scheduleRoute(Action action, Route route) throws Exception {	JobDetail jobDetail = createJobDetail(action, route);	Trigger trigger = createTrigger(action, route);	updateScheduledRouteDetails(action, jobDetail, trigger, route);	loadCallbackDataIntoSchedulerContext(jobDetail, action, route);	boolean isClustered = route.getRouteContext().getCamelContext().getComponent("quartz", QuartzComponent.class).isClustered();	if (isClustered) {	JobDetail existingJobDetail = getScheduler().getJobDetail(jobDetail.getName(), jobDetail.getGroup());	if (jobDetail.equals(existingJobDetail)) {	if (LOG.isInfoEnabled()) {	
skipping to schedule the job for action on route as the job already existing inside the cluster 

if (isClustered) {	JobDetail existingJobDetail = getScheduler().getJobDetail(jobDetail.getName(), jobDetail.getGroup());	if (jobDetail.equals(existingJobDetail)) {	if (LOG.isInfoEnabled()) {	}	return;	}	}	getScheduler().scheduleJob(jobDetail, trigger);	if (LOG.isInfoEnabled()) {	
scheduled trigger for action on route 

public void pauseRouteTrigger(Action action, String routeId) throws SchedulerException {	String triggerName = retrieveTriggerName(action, routeId);	String triggerGroup = retrieveTriggerGroup(action, routeId);	getScheduler().pauseTrigger(triggerName, triggerGroup);	
scheduled trigger is paused 

public void resumeRouteTrigger(Action action, String routeId) throws SchedulerException {	String triggerName = retrieveTriggerName(action, routeId);	String triggerGroup = retrieveTriggerGroup(action, routeId);	getScheduler().resumeTrigger(triggerName, triggerGroup);	
scheduled trigger is resumed 

public void deleteRouteJob(Action action, ScheduledRouteDetails scheduledRouteDetails) throws SchedulerException {	String jobDetailName = retrieveJobDetailName(action, scheduledRouteDetails);	String jobDetailGroup = retrieveJobDetailGroup(action, scheduledRouteDetails);	if (!getScheduler().isShutdown()) {	getScheduler().deleteJob(jobDetailName, jobDetailGroup);	}	
scheduled job is deleted 

========================= camel sample_17209 =========================

public void act(final Client client, final Exchange exchange) throws NoSuchHeaderException {	final Long jobId = BeanstalkExchangeHelper.getJobID(exchange);	final boolean result = client.delete(jobId);	if (!result && LOG.isWarnEnabled()) {	
failed to delete job d 

public void act(final Client client, final Exchange exchange) throws NoSuchHeaderException {	final Long jobId = BeanstalkExchangeHelper.getJobID(exchange);	final boolean result = client.delete(jobId);	if (!result && LOG.isWarnEnabled()) {	} else if (LOG.isDebugEnabled()) {	
job d deleted result is b 

========================= camel sample_8157 =========================

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyNewLineConstRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, false);	for (ParserResult result : list) {	
consumer 

public void parse() throws Exception {	JavaClassSource clazz = (JavaClassSource) Roaster.parse(new File("src/test/java/org/apache/camel/parser/java/MyNewLineConstRouteBuilder.java"));	MethodSource<JavaClassSource> method = clazz.getMethod("configure");	List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, false);	for (ParserResult result : list) {	}	Assert.assertEquals("timer:foo", list.get(0).getElement());	list = CamelJavaParserHelper.parseCamelProducerUris(method, true, false);	for (ParserResult result : list) {	
producer 

========================= camel sample_211 =========================

protected int sendTimerExchange() {	final Exchange exchange = getEndpoint().createExchange();	exchange.setProperty(Exchange.TIMER_NAME, getEndpoint().getName());	Date now = new Date();	exchange.setProperty(Exchange.TIMER_FIRED_TIME, now);	if (log.isTraceEnabled()) {	
timer is firing 

========================= camel sample_4877 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<HazelcastInstanceComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-instance.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.hazelcast-instance.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_704 =========================

System.arraycopy(intAsByteArray, 0, result, index, 4);	index += 4;	System.arraycopy(sshRsa, 0, result, index, sshRsa.length);	index += sshRsa.length;	intAsByteArray = ByteBuffer.allocate(4).putInt(signature.length).array();	System.arraycopy(intAsByteArray, 0, result, index, 4);	index += 4;	System.arraycopy(signature, 0, result, index, signature.length);	return result;	} catch (NoSuchAlgorithmException e) {	
cannot sign 

index += 4;	System.arraycopy(sshRsa, 0, result, index, sshRsa.length);	index += sshRsa.length;	intAsByteArray = ByteBuffer.allocate(4).putInt(signature.length).array();	System.arraycopy(intAsByteArray, 0, result, index, 4);	index += 4;	System.arraycopy(signature, 0, result, index, signature.length);	return result;	} catch (NoSuchAlgorithmException e) {	} catch (InvalidKeyException e) {	
cannot sign 

System.arraycopy(sshRsa, 0, result, index, sshRsa.length);	index += sshRsa.length;	intAsByteArray = ByteBuffer.allocate(4).putInt(signature.length).array();	System.arraycopy(intAsByteArray, 0, result, index, 4);	index += 4;	System.arraycopy(signature, 0, result, index, signature.length);	return result;	} catch (NoSuchAlgorithmException e) {	} catch (InvalidKeyException e) {	} catch (SignatureException e) {	
cannot sign 

========================= camel sample_15371 =========================

answer = ExchangeHelper.createCorrelatedCopy(exchange, false);	if (answer.hasOut()) {	answer.setIn(answer.getOut());	answer.setOut(null);	}	answer.setPattern(ExchangePattern.InOnly);	} else {	answer = exchange;	}	if (useOriginalBody) {	
using the original in message instead of current 

if (onFailureOnly) {	return;	}	if (onWhen != null && !onWhen.matches(exchange)) {	return;	}	final Exchange copy = prepareExchange(exchange);	if (executorService != null) {	executorService.submit(new Callable<Exchange>() {	public Exchange call() throws Exception {	
processing oncomplete 

}	final Exchange copy = prepareExchange(exchange);	if (executorService != null) {	executorService.submit(new Callable<Exchange>() {	public Exchange call() throws Exception {	doProcess(processor, copy);	return copy;	}	});	} else {	
processing oncomplete 

final boolean originalFault = copy.hasOut() ? copy.getOut().isFault() : copy.getIn().isFault();	copy.setException(null);	if (copy.hasOut()) {	copy.getOut().setFault(false);	} else {	copy.getIn().setFault(false);	}	if (executorService != null) {	executorService.submit(new Callable<Exchange>() {	public Exchange call() throws Exception {	
processing onfailure 

}	if (executorService != null) {	executorService.submit(new Callable<Exchange>() {	public Exchange call() throws Exception {	doProcess(processor, copy);	copy.setException(original);	return null;	}	});	} else {	
processing onfailure 

if (!exchange.isFailed() && onFailureOnly) {	return;	}	if (onWhen != null && !onWhen.matches(exchange)) {	return;	}	final Exchange copy = prepareExchange(exchange);	if (executorService != null) {	executorService.submit(new Callable<Exchange>() {	public Exchange call() throws Exception {	
processing onafterroute 

}	final Exchange copy = prepareExchange(exchange);	if (executorService != null) {	executorService.submit(new Callable<Exchange>() {	public Exchange call() throws Exception {	doProcess(processor, copy);	return copy;	}	});	} else {	
processing onafterroute 

========================= camel sample_4461 =========================

public void testSuspendResume() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceived("A");	template.sendBody("seda:foo", "A");	assertMockEndpointsSatisfied();	
Suspending 

context.suspendRoute("foo");	await().atMost(1, TimeUnit.SECONDS).until(() -> {	return context.getEndpoint("seda:bar", SedaEndpoint.class).getQueue().size() == 0;	});	template.sendBody("seda:foo", "B");	template.sendBody("direct:bar", "C");	mockBar.assertIsSatisfied();	mock.assertIsSatisfied(1000);	assertEquals("Suspended", context.getRouteStatus("foo").name());	assertEquals("Started", context.getRouteStatus("bar").name());	
Resuming 

========================= camel sample_1399 =========================

list.add(payloadToSend);	if (i % 100 == 0) {	noOfBlocks++;	System.out.println("sending blok " + noOfBlocks);	template.sendBody(sedaEndpoint, list.toArray(new String[0]));	list.clear();	}	}	MockEndpoint mockEndpoint = getMockEndpoint("mock:iron");	while (mockEndpoint.getReceivedCounter() != noOfBlocks) {	
waiting for queue to fill up current size is 

list.clear();	}	}	MockEndpoint mockEndpoint = getMockEndpoint("mock:iron");	while (mockEndpoint.getReceivedCounter() != noOfBlocks) {	Thread.sleep(1000);	}	long delta = System.currentTimeMillis() - start;	int seconds = (int)delta / 1000;	int msgPrSec = NO_OF_MESSAGES / seconds;	
ironmqperformancetest took seconds to produce messages which is messages pr second 

public void testConcurrentConsumers() throws Exception {	long start = System.currentTimeMillis();	context.startRoute("iron");	MockEndpoint endpoint = getMockEndpoint("mock:result");	endpoint.expectedMessageCount(NO_OF_MESSAGES);	assertMockEndpointsSatisfied(4, TimeUnit.MINUTES);	long delta = System.currentTimeMillis() - start;	int seconds = (int)delta / 1000;	int msgPrSec = NO_OF_MESSAGES / seconds;	
ironmqperformancetest took seconds to consume messages which is messages pr second 

========================= camel sample_14560 =========================

protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {	HipchatEndpoint endpoint = getHipchatEndpoint(uri);	setProperties(endpoint.getConfiguration(), parameters);	if (endpoint.getConfiguration().getAuthToken() == null) {	throw new HipchatException("OAuth 2 auth token must be specified");	}	parseUri(remaining, endpoint);	
using hipchat api url 

========================= camel sample_11332 =========================

final ZonedDateTime now = ZonedDateTime.now();	final boolean enabled = ObjectHelper.supplyIfEmpty(conf.isEnabled(), HealthCheckConfiguration::defaultValueEnabled);	final Duration interval = ObjectHelper.supplyIfEmpty(conf.getInterval(), HealthCheckConfiguration::defaultValueInterval);	final Integer threshold = ObjectHelper.supplyIfEmpty(conf.getFailureThreshold(), HealthCheckConfiguration::defaultValueFailureThreshold);	int invocationCount = (Integer)meta.getOrDefault(INVOCATION_COUNT, 0);	int failureCount = (Integer)meta.getOrDefault(FAILURE_COUNT, 0);	String invocationTime = now.format(DateTimeFormatter.ISO_ZONED_DATE_TIME);	boolean call = true;	meta.put(INVOCATION_ATTEMPT_TIME, invocationTime);	if (!enabled) {	
health check won t be invoked as not enabled 

return builder.unknown().build();	}	if (lastResult != null && lastInvocation != null && !interval.isZero()) {	Duration elapsed = Duration.between(lastInvocation, now);	if (elapsed.compareTo(interval) < 0) {	LOGGER.debug("health-check {}/{} won't be invoked as interval ({}) is not yet expired (last-invocation={})", getGroup(), getId(), elapsed, lastInvocation);	call = false;	}	}	if (call) {	
invoke health check 

if (elapsed.compareTo(interval) < 0) {	LOGGER.debug("health-check {}/{} won't be invoked as interval ({}) is not yet expired (last-invocation={})", getGroup(), getId(), elapsed, lastInvocation);	call = false;	}	}	if (call) {	doCall(builder, options);	ObjectHelper.notNull(builder.state(), "Response State");	if (builder.state() == State.DOWN) {	if (failureCount++ < threshold) {	
health check has status down but failure count is less than configured threshold 

========================= camel sample_4031 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<NeutronComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.openstack-neutron.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.openstack-neutron.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1233 =========================

public static List<FacebookMethodsType> getCandidateMethods(String name, String... argNames) {	final List<FacebookMethodsType> methods = METHOD_MAP.get(name);	if (methods == null) {	
no matching method for method 

public static List<FacebookMethodsType> getCandidateMethods(String name, String... argNames) {	final List<FacebookMethodsType> methods = METHOD_MAP.get(name);	if (methods == null) {	return Collections.emptyList();	}	int nArgs = argNames != null ? argNames.length : 0;	if (nArgs == 0) {	
found methods for method 

final List<FacebookMethodsType> methods = METHOD_MAP.get(name);	if (methods == null) {	return Collections.emptyList();	}	int nArgs = argNames != null ? argNames.length : 0;	if (nArgs == 0) {	return Collections.unmodifiableList(methods);	} else {	final List<FacebookMethodsType> filteredSet = filterMethods(methods, MatchType.SUBSET, argNames);	if (LOG.isDebugEnabled()) {	
found filtered methods for 

public static Object invokeMethod(Facebook facebook, FacebookMethodsType method, Map<String, Object> properties) throws RuntimeCamelException {	
invoking with arguments 

========================= camel sample_9603 =========================

static void afterPropertiesSet(ApplicationContext applicationContext, CamelContext camelContext) throws Exception {	Tracer tracer = getSingleBeanOfType(applicationContext, Tracer.class);	if (tracer != null) {	TraceFormatter formatter = getSingleBeanOfType(applicationContext, TraceFormatter.class);	if (formatter != null) {	tracer.setFormatter(formatter);	}	
using custom tracer 

Tracer tracer = getSingleBeanOfType(applicationContext, Tracer.class);	if (tracer != null) {	TraceFormatter formatter = getSingleBeanOfType(applicationContext, TraceFormatter.class);	if (formatter != null) {	tracer.setFormatter(formatter);	}	camelContext.addInterceptStrategy(tracer);	}	BacklogTracer backlogTracer = getSingleBeanOfType(applicationContext, BacklogTracer.class);	if (backlogTracer != null) {	
using custom backlogtracer 

tracer.setFormatter(formatter);	}	camelContext.addInterceptStrategy(tracer);	}	BacklogTracer backlogTracer = getSingleBeanOfType(applicationContext, BacklogTracer.class);	if (backlogTracer != null) {	camelContext.addInterceptStrategy(backlogTracer);	}	HandleFault handleFault = getSingleBeanOfType(applicationContext, HandleFault.class);	if (handleFault != null) {	
using custom handlefault 

BacklogTracer backlogTracer = getSingleBeanOfType(applicationContext, BacklogTracer.class);	if (backlogTracer != null) {	camelContext.addInterceptStrategy(backlogTracer);	}	HandleFault handleFault = getSingleBeanOfType(applicationContext, HandleFault.class);	if (handleFault != null) {	camelContext.addInterceptStrategy(handleFault);	}	InflightRepository inflightRepository = getSingleBeanOfType(applicationContext, InflightRepository.class);	if (inflightRepository != null) {	
using custom inflightrepository 

HandleFault handleFault = getSingleBeanOfType(applicationContext, HandleFault.class);	if (handleFault != null) {	camelContext.addInterceptStrategy(handleFault);	}	InflightRepository inflightRepository = getSingleBeanOfType(applicationContext, InflightRepository.class);	if (inflightRepository != null) {	camelContext.setInflightRepository(inflightRepository);	}	AsyncProcessorAwaitManager asyncProcessorAwaitManager = getSingleBeanOfType(applicationContext, AsyncProcessorAwaitManager.class);	if (asyncProcessorAwaitManager != null) {	
using custom asyncprocessorawaitmanager 

InflightRepository inflightRepository = getSingleBeanOfType(applicationContext, InflightRepository.class);	if (inflightRepository != null) {	camelContext.setInflightRepository(inflightRepository);	}	AsyncProcessorAwaitManager asyncProcessorAwaitManager = getSingleBeanOfType(applicationContext, AsyncProcessorAwaitManager.class);	if (asyncProcessorAwaitManager != null) {	camelContext.setAsyncProcessorAwaitManager(asyncProcessorAwaitManager);	}	ManagementStrategy managementStrategy = getSingleBeanOfType(applicationContext, ManagementStrategy.class);	if (managementStrategy != null) {	
using custom managementstrategy 

AsyncProcessorAwaitManager asyncProcessorAwaitManager = getSingleBeanOfType(applicationContext, AsyncProcessorAwaitManager.class);	if (asyncProcessorAwaitManager != null) {	camelContext.setAsyncProcessorAwaitManager(asyncProcessorAwaitManager);	}	ManagementStrategy managementStrategy = getSingleBeanOfType(applicationContext, ManagementStrategy.class);	if (managementStrategy != null) {	camelContext.setManagementStrategy(managementStrategy);	}	ManagementNamingStrategy managementNamingStrategy = getSingleBeanOfType(applicationContext, ManagementNamingStrategy.class);	if (managementNamingStrategy != null) {	
using custom managementnamingstrategy 

ManagementStrategy managementStrategy = getSingleBeanOfType(applicationContext, ManagementStrategy.class);	if (managementStrategy != null) {	camelContext.setManagementStrategy(managementStrategy);	}	ManagementNamingStrategy managementNamingStrategy = getSingleBeanOfType(applicationContext, ManagementNamingStrategy.class);	if (managementNamingStrategy != null) {	camelContext.getManagementStrategy().setManagementNamingStrategy(managementNamingStrategy);	}	EventFactory eventFactory = getSingleBeanOfType(applicationContext, EventFactory.class);	if (eventFactory != null) {	
using custom eventfactory 

ManagementNamingStrategy managementNamingStrategy = getSingleBeanOfType(applicationContext, ManagementNamingStrategy.class);	if (managementNamingStrategy != null) {	camelContext.getManagementStrategy().setManagementNamingStrategy(managementNamingStrategy);	}	EventFactory eventFactory = getSingleBeanOfType(applicationContext, EventFactory.class);	if (eventFactory != null) {	camelContext.getManagementStrategy().setEventFactory(eventFactory);	}	UnitOfWorkFactory unitOfWorkFactory = getSingleBeanOfType(applicationContext, UnitOfWorkFactory.class);	if (unitOfWorkFactory != null) {	
using custom unitofworkfactory 

EventFactory eventFactory = getSingleBeanOfType(applicationContext, EventFactory.class);	if (eventFactory != null) {	camelContext.getManagementStrategy().setEventFactory(eventFactory);	}	UnitOfWorkFactory unitOfWorkFactory = getSingleBeanOfType(applicationContext, UnitOfWorkFactory.class);	if (unitOfWorkFactory != null) {	camelContext.setUnitOfWorkFactory(unitOfWorkFactory);	}	RuntimeEndpointRegistry runtimeEndpointRegistry = getSingleBeanOfType(applicationContext, RuntimeEndpointRegistry.class);	if (runtimeEndpointRegistry != null) {	
using custom runtimeendpointregistry 

camelContext.setUnitOfWorkFactory(unitOfWorkFactory);	}	RuntimeEndpointRegistry runtimeEndpointRegistry = getSingleBeanOfType(applicationContext, RuntimeEndpointRegistry.class);	if (runtimeEndpointRegistry != null) {	camelContext.setRuntimeEndpointRegistry(runtimeEndpointRegistry);	}	Map<String, TypeConverters> typeConverters = applicationContext.getBeansOfType(TypeConverters.class);	if (typeConverters != null && !typeConverters.isEmpty()) {	for (Map.Entry<String, TypeConverters> entry : typeConverters.entrySet()) {	TypeConverters converter = entry.getValue();	
adding custom typeconverters with id and implementation 

for (Map.Entry<String, TypeConverters> entry : typeConverters.entrySet()) {	TypeConverters converter = entry.getValue();	camelContext.getTypeConverterRegistry().addTypeConverters(converter);	}	}	Map<String, EventNotifier> eventNotifiers = applicationContext.getBeansOfType(EventNotifier.class);	if (eventNotifiers != null && !eventNotifiers.isEmpty()) {	for (Map.Entry<String, EventNotifier> entry : eventNotifiers.entrySet()) {	EventNotifier notifier = entry.getValue();	if (!camelContext.getManagementStrategy().getEventNotifiers().contains(notifier)) {	
using custom eventnotifier with id and implementation 

EventNotifier notifier = entry.getValue();	if (!camelContext.getManagementStrategy().getEventNotifiers().contains(notifier)) {	camelContext.getManagementStrategy().addEventNotifier(notifier);	}	}	}	Map<String, EndpointStrategy> endpointStrategies = applicationContext.getBeansOfType(EndpointStrategy.class);	if (endpointStrategies != null && !endpointStrategies.isEmpty()) {	for (Map.Entry<String, EndpointStrategy> entry : endpointStrategies.entrySet()) {	EndpointStrategy strategy = entry.getValue();	
using custom endpointstrategy with id and implementation 

}	Map<String, EndpointStrategy> endpointStrategies = applicationContext.getBeansOfType(EndpointStrategy.class);	if (endpointStrategies != null && !endpointStrategies.isEmpty()) {	for (Map.Entry<String, EndpointStrategy> entry : endpointStrategies.entrySet()) {	EndpointStrategy strategy = entry.getValue();	camelContext.addRegisterEndpointCallback(strategy);	}	}	ShutdownStrategy shutdownStrategy = getSingleBeanOfType(applicationContext, ShutdownStrategy.class);	if (shutdownStrategy != null) {	
using custom shutdownstrategy 

}	ShutdownStrategy shutdownStrategy = getSingleBeanOfType(applicationContext, ShutdownStrategy.class);	if (shutdownStrategy != null) {	camelContext.setShutdownStrategy(shutdownStrategy);	}	Map<String, InterceptStrategy> interceptStrategies = applicationContext.getBeansOfType(InterceptStrategy.class);	if (interceptStrategies != null && !interceptStrategies.isEmpty()) {	for (Map.Entry<String, InterceptStrategy> entry : interceptStrategies.entrySet()) {	InterceptStrategy strategy = entry.getValue();	if (!camelContext.getInterceptStrategies().contains(strategy)) {	
using custom interceptstrategy with id and implementation 

if (!camelContext.getInterceptStrategies().contains(strategy)) {	camelContext.addInterceptStrategy(strategy);	}	}	}	Map<String, LifecycleStrategy> lifecycleStrategies = applicationContext.getBeansOfType(LifecycleStrategy.class);	if (lifecycleStrategies != null && !lifecycleStrategies.isEmpty()) {	for (Map.Entry<String, LifecycleStrategy> entry : lifecycleStrategies.entrySet()) {	LifecycleStrategy strategy = entry.getValue();	if (!camelContext.getLifecycleStrategies().contains(strategy)) {	
using custom lifecyclestrategy with id and implementation 

LifecycleStrategy strategy = entry.getValue();	if (!camelContext.getLifecycleStrategies().contains(strategy)) {	camelContext.addLifecycleStrategy(strategy);	}	}	}	Map<String, CamelClusterService> clusterServices = applicationContext.getBeansOfType(CamelClusterService.class);	if (clusterServices != null && !clusterServices.isEmpty()) {	for (Map.Entry<String, CamelClusterService> entry : clusterServices.entrySet()) {	CamelClusterService service = entry.getValue();	
using camelclusterservice with id and implementation 

if (clusterServices != null && !clusterServices.isEmpty()) {	for (Map.Entry<String, CamelClusterService> entry : clusterServices.entrySet()) {	CamelClusterService service = entry.getValue();	camelContext.addService(service);	}	}	Map<String, RoutePolicyFactory> routePolicyFactories = applicationContext.getBeansOfType(RoutePolicyFactory.class);	if (routePolicyFactories != null && !routePolicyFactories.isEmpty()) {	for (Map.Entry<String, RoutePolicyFactory> entry : routePolicyFactories.entrySet()) {	RoutePolicyFactory factory = entry.getValue();	
using custom routepolicyfactory with id and implementation 

camelContext.addRoutePolicyFactory(factory);	}	}	GlobalSSLContextParametersSupplier sslContextParametersSupplier = getSingleBeanOfType(applicationContext, GlobalSSLContextParametersSupplier.class);	if (sslContextParametersSupplier != null) {	camelContext.setSSLContextParameters(sslContextParametersSupplier.get());	}	HealthCheckRegistry healthCheckRegistry = getSingleBeanOfType(applicationContext, HealthCheckRegistry.class);	if (healthCheckRegistry != null) {	healthCheckRegistry.setCamelContext(camelContext);	
using healthcheckregistry 

healthCheckRegistry.setCamelContext(camelContext);	}	Map<String, HealthCheckRepository> repositories = applicationContext.getBeansOfType(HealthCheckRepository.class);	if (ObjectHelper.isNotEmpty(repositories)) {	for (HealthCheckRepository repository: repositories.values()) {	healthCheckRegistry.addRepository(repository);	}	}	HealthCheckService healthCheckService = getSingleBeanOfType(applicationContext, HealthCheckService.class);	if (healthCheckService != null) {	
using healthcheckservice 

for (HealthCheckRepository repository: repositories.values()) {	healthCheckRegistry.addRepository(repository);	}	}	HealthCheckService healthCheckService = getSingleBeanOfType(applicationContext, HealthCheckService.class);	if (healthCheckService != null) {	camelContext.addService(healthCheckService);	}	RouteController routeController = getSingleBeanOfType(applicationContext, RouteController.class);	if (routeController != null) {	
using routecontroller 

private static void initThreadPoolProfiles(ApplicationContext applicationContext, CamelContext camelContext) {	Set<String> defaultIds = new HashSet<String>();	Map<String, ThreadPoolProfile> profiles = applicationContext.getBeansOfType(ThreadPoolProfile.class);	if (profiles != null && !profiles.isEmpty()) {	for (Map.Entry<String, ThreadPoolProfile> entry : profiles.entrySet()) {	ThreadPoolProfile profile = entry.getValue();	if (profile.isDefaultProfile()) {	
using custom default threadpoolprofile with id and implementation 

========================= camel sample_13421 =========================

public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {	if (LOG.isTraceEnabled()) {	
channel open 

public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {	if (LOG.isTraceEnabled()) {	
channel closed 

public void messageReceived(final ChannelHandlerContext ctx, final MessageEvent messageEvent) throws Exception {	Object in = messageEvent.getMessage();	if (LOG.isDebugEnabled()) {	
channel received body 

private void sendResponse(MessageEvent messageEvent, Exchange exchange) throws Exception {	Object body = getResponseBody(exchange);	if (body == null) {	noReplyLogger.log("No payload to send as reply for exchange: " + exchange);	if (consumer.getConfiguration().isDisconnectOnNoReply()) {	if (LOG.isTraceEnabled()) {	
closing channel as no payload to send as reply at address 

========================= camel sample_6688 =========================

public void testSplitAndAggregateInOut() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedBodiesReceived(expectedBody);	Object out = template.requestBody("direct:start", "A@B@C");	assertEquals(expectedBody, out);	
response to caller 

public String handleOrder(String line) {	
handleorder 

public String buildCombinedResponse(String line) {	
buildcombinedresponse 

public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {	if (oldExchange == null) {	return newExchange;	}	String orders = oldExchange.getIn().getBody(String.class);	String newLine = newExchange.getIn().getBody(String.class);	
aggregate old orders 

public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {	if (oldExchange == null) {	return newExchange;	}	String orders = oldExchange.getIn().getBody(String.class);	String newLine = newExchange.getIn().getBody(String.class);	
aggregate new order 

========================= camel sample_2331 =========================

AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz/SpringQuartzConsumerClusteredAppOne.xml");	app.start();	AbstractXmlApplicationContext app2 = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz/SpringQuartzConsumerClusteredAppTwo.xml");	app2.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMinimumMessageCount(3);	mock.expectedMessagesMatches(new ClusteringPredicate(true));	Thread.sleep(5000);	mock.assertIsSatisfied();	
the first app is going to crash now 

app.start();	AbstractXmlApplicationContext app2 = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz/SpringQuartzConsumerClusteredAppTwo.xml");	app2.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMinimumMessageCount(3);	mock.expectedMessagesMatches(new ClusteringPredicate(true));	Thread.sleep(5000);	mock.assertIsSatisfied();	IOHelper.close(app);	
crashed 

app.start();	AbstractXmlApplicationContext app2 = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz/SpringQuartzConsumerClusteredAppTwo.xml");	app2.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMinimumMessageCount(3);	mock.expectedMessagesMatches(new ClusteringPredicate(true));	Thread.sleep(5000);	mock.assertIsSatisfied();	IOHelper.close(app);	
crashed 

app.start();	AbstractXmlApplicationContext app2 = new ClassPathXmlApplicationContext("org/apache/camel/component/quartz/SpringQuartzConsumerClusteredAppTwo.xml");	app2.start();	CamelContext camel = app.getBean("camelContext", CamelContext.class);	MockEndpoint mock = camel.getEndpoint("mock:result", MockEndpoint.class);	mock.expectedMinimumMessageCount(3);	mock.expectedMessagesMatches(new ClusteringPredicate(true));	Thread.sleep(5000);	mock.assertIsSatisfied();	IOHelper.close(app);	
crashed 

========================= camel sample_17198 =========================

DefaultZookeeperConnectionStrategy(ZooKeeperEndpoint endpoint) {	this.configuration = endpoint.getConfiguration();	
creating connection to zookeeper 

public void shutdown() {	
shutting down connection to zookeeper 

========================= camel sample_12660 =========================

public void process(Exchange exchange) throws Exception {	PublishRequest request = new PublishRequest();	request.setTopicArn(getConfiguration().getTopicArn());	request.setSubject(determineSubject(exchange));	request.setMessageStructure(determineMessageStructure(exchange));	request.setMessage(exchange.getIn().getBody(String.class));	request.setMessageAttributes(this.translateAttributes(exchange.getIn().getHeaders(), exchange));	
sending request from exchange 

public void process(Exchange exchange) throws Exception {	PublishRequest request = new PublishRequest();	request.setTopicArn(getConfiguration().getTopicArn());	request.setSubject(determineSubject(exchange));	request.setMessageStructure(determineMessageStructure(exchange));	request.setMessage(exchange.getIn().getBody(String.class));	request.setMessageAttributes(this.translateAttributes(exchange.getIn().getHeaders(), exchange));	PublishResult result = getEndpoint().getSNSClient().publish(request);	
received result 

========================= camel sample_8696 =========================

public void onRemoval(Object key, Object value, RemovalCause cause) {	
key s was removed s n 

========================= camel sample_12725 =========================

StaxUtils.copy(reader, cos);	li.set(new StreamSourceCache(cos.newStreamCache()));	continue;	} catch (Exception e) {	StreamResult sr = new StreamResult(cos);	try {	xml.toResult(source, sr);	li.set(new StreamSourceCache(cos.newStreamCache()));	continue;	} catch (Exception e2) {	
error during parsing xmlstreamreader from staxsource staxsource will fallback to using dom mode this exception is ignored 

========================= camel sample_7975 =========================

private void configureGlobalSettings(Mapper mapper) {	GlobalSettings settings;	try {	
attempting to retrieve globalsettings from 

Field field = mapper.getClass().getDeclaredField("globalSettings");	field.setAccessible(true);	settings = (GlobalSettings)field.get(mapper);	} catch (Exception e) {	throw new IllegalStateException("Cannot retrieve Dozer GlobalSettings due " + e.getMessage(), e);	}	if (settings == null) {	throw new IllegalStateException("Cannot retrieve Dozer GlobalSettings due null reflection response");	}	try {	
configuring globalsettings to use camel classloader 

if (settings == null) {	throw new IllegalStateException("Cannot retrieve Dozer GlobalSettings due null reflection response");	}	try {	Field field = settings.getClass().getDeclaredField("classLoaderBeanName");	ReflectionHelper.setField(field, settings, DozerThreadContextClassLoader.class.getName());	} catch (Exception e) {	throw new IllegalStateException("Cannot configure Dozer GlobalSettings to use DozerThreadContextClassLoader as classloader due " + e.getMessage(), e);	}	try {	
configuring globalsettings to enable el 

ClassLoader tccl = Thread.currentThread().getContextClassLoader();	try {	ClassLoader appcl = camelContext.getApplicationContextClassLoader();	ClassLoader auxcl = appcl != null ? appcl : DozerEndpoint.class.getClassLoader();	Thread.currentThread().setContextClassLoader(auxcl);	try {	Class<?> clazz = auxcl.loadClass("com.sun.el.ExpressionFactoryImpl");	ExpressionFactory factory = (ExpressionFactory)clazz.newInstance();	System.setProperty("javax.el.ExpressionFactory", factory.getClass().getName());	} catch (ClassNotFoundException | InstantiationException | IllegalAccessException ex) {	
cannot load glasfish expression engine using default 

private BeanContainer resolveBeanContainer(Mapper mapper) {	
attempting to retrieve beancontainer from 

========================= camel sample_9438 =========================

public void start() {	if (Boolean.TRUE.equals(NO_START.get())) {	
ignoring start as no start is false 

public void start() {	if (Boolean.TRUE.equals(NO_START.get())) {	return;	}	if (!isStarted() && !isStarting()) {	try {	StopWatch watch = new StopWatch();	super.start();	
start took millis 

return;	}	if (!isStarted() && !isStarting()) {	try {	StopWatch watch = new StopWatch();	super.start();	} catch (Exception e) {	throw wrapRuntimeCamelException(e);	}	} else {	
ignoring start as camel is already started 

public void stop() {	if (!isStopping() && !isStopped()) {	try {	super.stop();	} catch (Exception e) {	throw wrapRuntimeCamelException(e);	}	} else {	
ignoring stop as camel is already stopped 

public void onApplicationEvent(ApplicationEvent event) {	
onapplicationevent 

public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {	this.applicationContext = applicationContext;	ClassLoader cl;	if (applicationContext != null && applicationContext.getClassLoader() != null) {	cl = applicationContext.getClassLoader();	} else {	
cannot find the class loader from application context using the thread context class loader instead 

public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {	this.applicationContext = applicationContext;	ClassLoader cl;	if (applicationContext != null && applicationContext.getClassLoader() != null) {	cl = applicationContext.getClassLoader();	} else {	cl = Thread.currentThread().getContextClassLoader();	}	
set the application context classloader to 

protected Injector createInjector() {	if (applicationContext instanceof ConfigurableApplicationContext) {	return new SpringInjector((ConfigurableApplicationContext)applicationContext);	} else {	
cannot use springinjector as applicationcontext is not a configurableapplicationcontext as its 

========================= camel sample_16336 =========================

protected void runCamel(ClassLoader newLoader) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, MojoExecutionException {	
running camel in 

protected void runCamel(ClassLoader newLoader) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, MojoExecutionException {	Class<?> type = newLoader.loadClass(mainClass);	Method method = type.getMethod("main", String[].class);	String[] arguments = createArguments();	
starting the camel main with arguments 

public ClassLoader createClassLoader(ClassLoader parent) throws MalformedURLException {	
using classpath 

public ClassLoader createClassLoader(ClassLoader parent) throws MalformedURLException {	int size = classpathElements.size();	URL[] urls = new URL[size];	for (int i = 0; i < size; i++) {	String name = (String) classpathElements.get(i);	File file = new File(name);	urls[i] = file.toURI().toURL();	
url 

========================= camel sample_66 =========================

public void testPostStatusUpdateRequestResponse() throws Exception {	Date now = new Date();	String tweet = "UserProducerInOnlyTest: This is a tweet posted on " + now.toString();	
tweet 

========================= camel sample_14188 =========================

public synchronized boolean reset(Exception e) {	boolean answer = false;	if ((e instanceof RuntimeException && ((RuntimeException)e).getCause() instanceof ConnectException) || ((e instanceof SocketException) || (e instanceof SSLException))) {	
got exception from splunk service will be reset 

========================= camel sample_14472 =========================

Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, dataformat, parameters, false);	} catch (Exception e) {	throw new RuntimeCamelException(e);	}	if (ObjectHelper.isNotEmpty(customizers)) {	for (DataFormatCustomizer<UniVocityTsvDataFormat> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.univocity-tsv.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext .getEnvironment(), "camel.dataformat.customizer", "camel.dataformat.univocity-tsv.customizer");	if (useCustomizer) {	
configure dataformat with customizer 

========================= camel sample_1264 =========================

if (applicationContext == null) {	applicationContext = doCreateApplicationContext();	threadAppContext.set(applicationContext);	}	} else {	applicationContext = doCreateApplicationContext();	}	SpringCamelContext.setNoStart(false);	}	} else {	
skipping starting camelcontext as system property skipstartingcamelcontext is set to be true 

private AbstractApplicationContext doCreateApplicationContext() {	AbstractApplicationContext context = createApplicationContext();	assertNotNull("Should have created a valid Spring application context", context);	String[] profiles = activeProfiles();	if (profiles != null && profiles.length > 0) {	if (context.isActive()) {	throw new IllegalStateException("Cannot active profiles: " + Arrays.asList(profiles) + " on active Spring application context: " + context + ". The code in your createApplicationContext() method should be adjusted to create the application context with refresh = false as parameter");	}	
spring activating profiles 

========================= camel sample_10574 =========================

File rootDir2 = new File(camelCoreXmlDir, pathToCoreXmlModelDir);	Map<String, File> jsonFiles2 = PackageHelper.findJsonFiles(rootDir2);	File rootDir3 = new File(camelSpringDir, pathToSpringModelDir);	Map<String, File> jsonFiles3 = PackageHelper.findJsonFiles(rootDir3);	jsonFiles.putAll(jsonFiles2);	jsonFiles.putAll(jsonFiles3);	NodeList elementsAndTypes = domFinder.findElementsAndTypes();	documentationEnricher.enrichTopLevelElementsDocumentation(elementsAndTypes, jsonFiles);	Map<String, String> typeToNameMap = buildTypeToNameMap(elementsAndTypes);	Set<String> injectedTypes = new LinkedHashSet<String>();	
found models to use when enriching the xsd schema 

jsonFiles.putAll(jsonFiles2);	jsonFiles.putAll(jsonFiles3);	NodeList elementsAndTypes = domFinder.findElementsAndTypes();	documentationEnricher.enrichTopLevelElementsDocumentation(elementsAndTypes, jsonFiles);	Map<String, String> typeToNameMap = buildTypeToNameMap(elementsAndTypes);	Set<String> injectedTypes = new LinkedHashSet<String>();	for (Map.Entry<String, String> entry : typeToNameMap.entrySet()) {	String elementType = entry.getKey();	String elementName = entry.getValue();	if (jsonFileExistsForElement(jsonFiles, elementName)) {	
enriching 

private Map<String, String> buildTypeToNameMap(NodeList elementsAndTypes) {	Map<String, String> typeToNameMap = new LinkedHashMap<String, String>();	for (int i = 0; i < elementsAndTypes.getLength(); i++) {	Element item = (Element) elementsAndTypes.item(i);	String name = item.getAttribute(Constants.NAME_ATTRIBUTE_NAME);	String type = item.getAttribute(Constants.TYPE_ATTRIBUTE_NAME);	if (name != null && type != null) {	type = truncateTypeNamespace(type);	if (getLog().isDebugEnabled()) {	
putting attributes type s name s 

========================= camel sample_89 =========================

private void writeSlowFile() throws Exception {	
writing slow file 

private void writeSlowFile() throws Exception {	createDirectory(FTP_ROOT_DIR + "/changed");	FileOutputStream fos = new FileOutputStream(FTP_ROOT_DIR + "/changed/slowfile.dat", true);	for (int i = 0; i < 20; i++) {	fos.write(("Line " + i + LS).getBytes());	
writing line 

private void writeSlowFile() throws Exception {	createDirectory(FTP_ROOT_DIR + "/changed");	FileOutputStream fos = new FileOutputStream(FTP_ROOT_DIR + "/changed/slowfile.dat", true);	for (int i = 0; i < 20; i++) {	fos.write(("Line " + i + LS).getBytes());	Thread.sleep(200);	}	fos.flush();	fos.close();	
writing slow file done 

========================= camel sample_15326 =========================

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	context.addComponent("async", new MyAsyncComponent());	from("direct:start").routeId("myRoute") .to("mock:before") .to("async:bye:camel").id("myAsync") .to("mock:after") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	int size = context.getAsyncProcessorAwaitManager().size();	
async inflight 

return new RouteBuilder() {	public void configure() throws Exception {	context.addComponent("async", new MyAsyncComponent());	from("direct:start").routeId("myRoute") .to("mock:before") .to("async:bye:camel").id("myAsync") .to("mock:after") .process(new Processor() {	public void process(Exchange exchange) throws Exception {	int size = context.getAsyncProcessorAwaitManager().size();	assertEquals(1, size);	Collection<AsyncProcessorAwaitManager.AwaitThread> threads = context.getAsyncProcessorAwaitManager().browse();	AsyncProcessorAwaitManager.AwaitThread thread = threads.iterator().next();	long wait = thread.getWaitDuration();	
thread has waited for msec 

========================= camel sample_2018 =========================

}	RestoreAction restoreAction = CURRENT_RESTORE_ACTION.get();	if (restoreAction == null) {	return;	}	restoreAction.actions.add(new Runnable() {	public void run() {	try {	IntrospectionSupport.setProperties(context, null, target, properties);	} catch (Exception e) {	
could not restore definition properties 

public static void resolvePropertyPlaceholders(CamelContext camelContext, Object definition) throws Exception {	
resolving property placeholders for 

s = s + suffixToken;	}	value = s;	}	properties.put(local, value);	}	}	}	Map<String, Object> changedProperties = new HashMap<String, Object>();	if (!properties.isEmpty()) {	
there are properties on 

if (value instanceof String) {	String text = (String) value;	text = camelContext.resolvePropertyPlaceholders(text);	if (text != value) {	boolean changed = IntrospectionSupport.setProperty(camelContext.getTypeConverter(), definition, name, text);	if (!changed) {	throw new IllegalArgumentException("No setter to set property: " + name + " to: " + text + " on: " + definition);	}	changedProperties.put(name, value);	if (LOG.isDebugEnabled()) {	
changed property from to 

public static void resolveKnownConstantFields(Object definition) throws Exception {	
resolving known fields for 

public static void resolveKnownConstantFields(Object definition) throws Exception {	Map<String, Object> properties = new HashMap<String, Object>();	IntrospectionSupport.getProperties(definition, properties, null);	Map<String, Object> changedProperties = new HashMap<String, Object>();	if (!properties.isEmpty()) {	
there are properties on 

Object value = entry.getValue();	if (value instanceof String) {	String text = (String) value;	if (text.startsWith("Exchange.")) {	String field = ObjectHelper.after(text, "Exchange.");	String constant = ObjectHelper.lookupConstantFieldValue(Exchange.class, field);	if (constant != null) {	IntrospectionSupport.setProperty(definition, name, constant);	changedProperties.put(name, value);	if (LOG.isDebugEnabled()) {	
changed property from to 

========================= camel sample_5227 =========================

public void doCheese() {	
docheese called 

========================= camel sample_10763 =========================

public void xxxtestLongShutdownOfThreadPool() throws Exception {	final CountDownLatch latch = new CountDownLatch(1);	ExecutorService pool = context.getExecutorServiceManager().newSingleThreadExecutor(this, "Cool");	pool.execute(new Runnable() {	public void run() {	
starting thread 

public void xxxtestLongShutdownOfThreadPool() throws Exception {	final CountDownLatch latch = new CountDownLatch(1);	ExecutorService pool = context.getExecutorServiceManager().newSingleThreadExecutor(this, "Cool");	pool.execute(new Runnable() {	public void run() {	try {	latch.await(42, TimeUnit.SECONDS);	} catch (InterruptedException e) {	}	
existing thread 

========================= camel sample_1423 =========================

throw new IllegalArgumentException( "Header specifying expected returning columns isn't an instance of String[] or int[] but " + expectedGeneratedColumns.getClass());	}	}	}	};	SqlOutputType outputType = getEndpoint().getOutputType();	if (outputType == SqlOutputType.StreamList) {	processStreamList(exchange, statementCreator, sql, preparedQuery);	return;	}	
jdbctemplate execute 

protected void processStreamList(Exchange exchange, PreparedStatementCreator statementCreator, String sql, String preparedQuery) throws Exception {	
processstreamlist 

========================= camel sample_9013 =========================

private int pollWithQuery(CMISConsumer cmisConsumer) throws Exception {	int count = 0;	int pageNumber = 0;	boolean finished = false;	ItemIterable<QueryResult> itemIterable = executeQuery(query);	while (!finished) {	ItemIterable<QueryResult> currentPage = itemIterable.skipTo(count).getPage();	
processing page 

public List<Map<String, Object>> retrieveResult(Boolean retrieveContent, Integer readSize, ItemIterable<QueryResult> itemIterable) {	List<Map<String, Object>> result = new ArrayList<Map<String, Object>>();	boolean queryForContent = retrieveContent != null ? retrieveContent : readContent;	int documentsToRead = readSize != null ? readSize : readCount;	int count = 0;	int pageNumber = 0;	boolean finished = false;	while (!finished) {	ItemIterable<QueryResult> currentPage = itemIterable.skipTo(count).getPage();	
processing page 

========================= camel sample_9156 =========================

protected void sendText(final String fragment, CamelContext context) throws Exception {	ProducerTemplate template = context.createProducerTemplate();	template.start();	template.send("direct:start", new Processor() {	public void process(Exchange exchange) throws Exception {	exchange.setProperty(Exchange.CHARSET_NAME, "UTF-8");	Message in = exchange.getIn();	in.setBody(fragment);	
xmlfragment 

========================= camel sample_6759 =========================

private Status updateStatus(StatusUpdate status) throws Exception {	Status response = endpoint.getProperties().getTwitter().updateStatus(status);	
updated status 

private Status updateStatus(StatusUpdate status) throws Exception {	Status response = endpoint.getProperties().getTwitter().updateStatus(status);	
status id 

private Status updateStatus(String status) throws Exception {	Status response = endpoint.getProperties().getTwitter().updateStatus(status);	
updated status 

private Status updateStatus(String status) throws Exception {	Status response = endpoint.getProperties().getTwitter().updateStatus(status);	
status id 

========================= camel sample_14235 =========================

if (hostHeader != null) {	httpRequest.setHeader("Host", hostHeader);	}	}	if (getEndpoint().isConnectionClose()) {	httpRequest.addHeader("Connection", HTTP.CONN_CLOSE);	}	HttpResponse httpResponse = null;	try {	if (LOG.isDebugEnabled()) {	
executing http method 

}	if (getEndpoint().isConnectionClose()) {	httpRequest.addHeader("Connection", HTTP.CONN_CLOSE);	}	HttpResponse httpResponse = null;	try {	if (LOG.isDebugEnabled()) {	}	httpResponse = executeMethod(httpRequest);	int responseCode = httpResponse.getStatusLine().getStatusCode();	
http responsecode 

if (rewriteUrl != null) {	url = rewriteUrl;	uri = new URI(url);	}	HttpEntity requestEntity = createRequestEntity(exchange);	HttpMethods methodToUse = HttpMethodHelper.createMethod(exchange, getEndpoint(), requestEntity != null);	HttpRequestBase method = methodToUse.createMethod(url);	if (getEndpoint().isDeleteWithBody() && "DELETE".equals(method.getMethod())) {	method = new HttpDeleteWithBodyMethod(url, requestEntity);	}	
using url with method 

}	HttpEntity requestEntity = createRequestEntity(exchange);	HttpMethods methodToUse = HttpMethodHelper.createMethod(exchange, getEndpoint(), requestEntity != null);	HttpRequestBase method = methodToUse.createMethod(url);	if (getEndpoint().isDeleteWithBody() && "DELETE".equals(method.getMethod())) {	method = new HttpDeleteWithBodyMethod(url, requestEntity);	}	if (methodToUse.isEntityEnclosing()) {	((HttpEntityEnclosingRequestBase) method).setEntity(requestEntity);	if (requestEntity != null && requestEntity.getContentType() == null) {	
no content type provided for url with exchange 

========================= camel sample_17049 =========================

public void afterPropertiesSet() throws Exception {	if (ObjectHelper.isEmpty(getId())) {	throw new IllegalArgumentException("Id must be set");	}	PackageScanClassResolver packageResolver = getBeanForType(PackageScanClassResolver.class);	if (packageResolver != null) {	
using custom packagescanclassresolver 

setupCustomServices();	initCustomRegistry(getContext());	initPropertyPlaceholder();	initJMXAgent();	Tracer tracer = getBeanForType(Tracer.class);	if (tracer != null) {	TraceFormatter formatter = getBeanForType(TraceFormatter.class);	if (formatter != null) {	tracer.setFormatter(formatter);	}	
using custom tracer 

Tracer tracer = getBeanForType(Tracer.class);	if (tracer != null) {	TraceFormatter formatter = getBeanForType(TraceFormatter.class);	if (formatter != null) {	tracer.setFormatter(formatter);	}	getContext().addInterceptStrategy(tracer);	}	BacklogTracer backlogTracer = getBeanForType(BacklogTracer.class);	if (backlogTracer != null) {	
using custom backlogtracer 

tracer.setFormatter(formatter);	}	getContext().addInterceptStrategy(tracer);	}	BacklogTracer backlogTracer = getBeanForType(BacklogTracer.class);	if (backlogTracer != null) {	getContext().addInterceptStrategy(backlogTracer);	}	HandleFault handleFault = getBeanForType(HandleFault.class);	if (handleFault != null) {	
using custom handlefault 

BacklogTracer backlogTracer = getBeanForType(BacklogTracer.class);	if (backlogTracer != null) {	getContext().addInterceptStrategy(backlogTracer);	}	HandleFault handleFault = getBeanForType(HandleFault.class);	if (handleFault != null) {	getContext().addInterceptStrategy(handleFault);	}	org.apache.camel.processor.interceptor.Delayer delayer = getBeanForType(org.apache.camel.processor.interceptor.Delayer.class);	if (delayer != null) {	
using custom delayer 

HandleFault handleFault = getBeanForType(HandleFault.class);	if (handleFault != null) {	getContext().addInterceptStrategy(handleFault);	}	org.apache.camel.processor.interceptor.Delayer delayer = getBeanForType(org.apache.camel.processor.interceptor.Delayer.class);	if (delayer != null) {	getContext().addInterceptStrategy(delayer);	}	InflightRepository inflightRepository = getBeanForType(InflightRepository.class);	if (inflightRepository != null) {	
using custom inflightrepository 

org.apache.camel.processor.interceptor.Delayer delayer = getBeanForType(org.apache.camel.processor.interceptor.Delayer.class);	if (delayer != null) {	getContext().addInterceptStrategy(delayer);	}	InflightRepository inflightRepository = getBeanForType(InflightRepository.class);	if (inflightRepository != null) {	getContext().setInflightRepository(inflightRepository);	}	AsyncProcessorAwaitManager asyncProcessorAwaitManager = getBeanForType(AsyncProcessorAwaitManager.class);	if (asyncProcessorAwaitManager != null) {	
using custom asyncprocessorawaitmanager 

InflightRepository inflightRepository = getBeanForType(InflightRepository.class);	if (inflightRepository != null) {	getContext().setInflightRepository(inflightRepository);	}	AsyncProcessorAwaitManager asyncProcessorAwaitManager = getBeanForType(AsyncProcessorAwaitManager.class);	if (asyncProcessorAwaitManager != null) {	getContext().setAsyncProcessorAwaitManager(asyncProcessorAwaitManager);	}	ManagementStrategy managementStrategy = getBeanForType(ManagementStrategy.class);	if (managementStrategy != null) {	
using custom managementstrategy 

AsyncProcessorAwaitManager asyncProcessorAwaitManager = getBeanForType(AsyncProcessorAwaitManager.class);	if (asyncProcessorAwaitManager != null) {	getContext().setAsyncProcessorAwaitManager(asyncProcessorAwaitManager);	}	ManagementStrategy managementStrategy = getBeanForType(ManagementStrategy.class);	if (managementStrategy != null) {	getContext().setManagementStrategy(managementStrategy);	}	ManagementNamingStrategy managementNamingStrategy = getBeanForType(ManagementNamingStrategy.class);	if (managementNamingStrategy != null) {	
using custom managementnamingstrategy 

ManagementStrategy managementStrategy = getBeanForType(ManagementStrategy.class);	if (managementStrategy != null) {	getContext().setManagementStrategy(managementStrategy);	}	ManagementNamingStrategy managementNamingStrategy = getBeanForType(ManagementNamingStrategy.class);	if (managementNamingStrategy != null) {	getContext().getManagementStrategy().setManagementNamingStrategy(managementNamingStrategy);	}	EventFactory eventFactory = getBeanForType(EventFactory.class);	if (eventFactory != null) {	
using custom eventfactory 

ManagementNamingStrategy managementNamingStrategy = getBeanForType(ManagementNamingStrategy.class);	if (managementNamingStrategy != null) {	getContext().getManagementStrategy().setManagementNamingStrategy(managementNamingStrategy);	}	EventFactory eventFactory = getBeanForType(EventFactory.class);	if (eventFactory != null) {	getContext().getManagementStrategy().setEventFactory(eventFactory);	}	UnitOfWorkFactory unitOfWorkFactory = getBeanForType(UnitOfWorkFactory.class);	if (unitOfWorkFactory != null) {	
using custom unitofworkfactory 

EventFactory eventFactory = getBeanForType(EventFactory.class);	if (eventFactory != null) {	getContext().getManagementStrategy().setEventFactory(eventFactory);	}	UnitOfWorkFactory unitOfWorkFactory = getBeanForType(UnitOfWorkFactory.class);	if (unitOfWorkFactory != null) {	getContext().setUnitOfWorkFactory(unitOfWorkFactory);	}	RuntimeEndpointRegistry runtimeEndpointRegistry = getBeanForType(RuntimeEndpointRegistry.class);	if (runtimeEndpointRegistry != null) {	
using custom runtimeendpointregistry 

UnitOfWorkFactory unitOfWorkFactory = getBeanForType(UnitOfWorkFactory.class);	if (unitOfWorkFactory != null) {	getContext().setUnitOfWorkFactory(unitOfWorkFactory);	}	RuntimeEndpointRegistry runtimeEndpointRegistry = getBeanForType(RuntimeEndpointRegistry.class);	if (runtimeEndpointRegistry != null) {	getContext().setRuntimeEndpointRegistry(runtimeEndpointRegistry);	}	HeadersMapFactory headersMapFactory = getBeanForType(HeadersMapFactory.class);	if (headersMapFactory != null) {	
using custom headersmapfactory 

getContext().setRuntimeEndpointRegistry(runtimeEndpointRegistry);	}	HeadersMapFactory headersMapFactory = getBeanForType(HeadersMapFactory.class);	if (headersMapFactory != null) {	getContext().setHeadersMapFactory(headersMapFactory);	}	Map<String, TypeConverters> typeConverters = getContext().getRegistry().findByTypeWithName(TypeConverters.class);	if (typeConverters != null && !typeConverters.isEmpty()) {	for (Entry<String, TypeConverters> entry : typeConverters.entrySet()) {	TypeConverters converter = entry.getValue();	
adding custom typeconverters with id and implementation 

for (Entry<String, TypeConverters> entry : typeConverters.entrySet()) {	TypeConverters converter = entry.getValue();	getContext().getTypeConverterRegistry().addTypeConverters(converter);	}	}	Map<String, EventNotifier> eventNotifiers = getContext().getRegistry().findByTypeWithName(EventNotifier.class);	if (eventNotifiers != null && !eventNotifiers.isEmpty()) {	for (Entry<String, EventNotifier> entry : eventNotifiers.entrySet()) {	EventNotifier notifier = entry.getValue();	if (!getContext().getManagementStrategy().getEventNotifiers().contains(notifier)) {	
using custom eventnotifier with id and implementation 

EventNotifier notifier = entry.getValue();	if (!getContext().getManagementStrategy().getEventNotifiers().contains(notifier)) {	getContext().getManagementStrategy().addEventNotifier(notifier);	}	}	}	Map<String, EndpointStrategy> endpointStrategies = getContext().getRegistry().findByTypeWithName(EndpointStrategy.class);	if (endpointStrategies != null && !endpointStrategies.isEmpty()) {	for (Entry<String, EndpointStrategy> entry : endpointStrategies.entrySet()) {	EndpointStrategy strategy = entry.getValue();	
using custom endpointstrategy with id and implementation 

}	Map<String, EndpointStrategy> endpointStrategies = getContext().getRegistry().findByTypeWithName(EndpointStrategy.class);	if (endpointStrategies != null && !endpointStrategies.isEmpty()) {	for (Entry<String, EndpointStrategy> entry : endpointStrategies.entrySet()) {	EndpointStrategy strategy = entry.getValue();	getContext().addRegisterEndpointCallback(strategy);	}	}	ShutdownStrategy shutdownStrategy = getBeanForType(ShutdownStrategy.class);	if (shutdownStrategy != null) {	
using custom shutdownstrategy 

}	ShutdownStrategy shutdownStrategy = getBeanForType(ShutdownStrategy.class);	if (shutdownStrategy != null) {	getContext().setShutdownStrategy(shutdownStrategy);	}	Map<String, InterceptStrategy> interceptStrategies = getContext().getRegistry().findByTypeWithName(InterceptStrategy.class);	if (interceptStrategies != null && !interceptStrategies.isEmpty()) {	for (Entry<String, InterceptStrategy> entry : interceptStrategies.entrySet()) {	InterceptStrategy strategy = entry.getValue();	if (!getContext().getInterceptStrategies().contains(strategy)) {	
using custom interceptstrategy with id and implementation 

if (!getContext().getInterceptStrategies().contains(strategy)) {	getContext().addInterceptStrategy(strategy);	}	}	}	Map<String, LifecycleStrategy> lifecycleStrategies = getContext().getRegistry().findByTypeWithName(LifecycleStrategy.class);	if (lifecycleStrategies != null && !lifecycleStrategies.isEmpty()) {	for (Entry<String, LifecycleStrategy> entry : lifecycleStrategies.entrySet()) {	LifecycleStrategy strategy = entry.getValue();	if (!getContext().getLifecycleStrategies().contains(strategy)) {	
using custom lifecyclestrategy with id and implementation 

LifecycleStrategy strategy = entry.getValue();	if (!getContext().getLifecycleStrategies().contains(strategy)) {	getContext().addLifecycleStrategy(strategy);	}	}	}	Map<String, CamelClusterService> clusterServices = getContext().getRegistry().findByTypeWithName(CamelClusterService.class);	if (clusterServices != null && !clusterServices.isEmpty()) {	for (Entry<String, CamelClusterService> entry : clusterServices.entrySet()) {	CamelClusterService service = entry.getValue();	
using camelclusterservice with id and implementation 

if (clusterServices != null && !clusterServices.isEmpty()) {	for (Entry<String, CamelClusterService> entry : clusterServices.entrySet()) {	CamelClusterService service = entry.getValue();	getContext().addService(service);	}	}	Map<String, RoutePolicyFactory> routePolicyFactories = getContext().getRegistry().findByTypeWithName(RoutePolicyFactory.class);	if (routePolicyFactories != null && !routePolicyFactories.isEmpty()) {	for (Entry<String, RoutePolicyFactory> entry : routePolicyFactories.entrySet()) {	RoutePolicyFactory factory = entry.getValue();	
using custom routepolicyfactory with id and implementation 

Map<String, RoutePolicyFactory> routePolicyFactories = getContext().getRegistry().findByTypeWithName(RoutePolicyFactory.class);	if (routePolicyFactories != null && !routePolicyFactories.isEmpty()) {	for (Entry<String, RoutePolicyFactory> entry : routePolicyFactories.entrySet()) {	RoutePolicyFactory factory = entry.getValue();	getContext().addRoutePolicyFactory(factory);	}	}	HealthCheckRegistry healthCheckRegistry = getBeanForType(HealthCheckRegistry.class);	if (healthCheckRegistry != null) {	healthCheckRegistry.setCamelContext(getContext());	
using healthcheckregistry 

healthCheckRegistry.setCamelContext(getContext());	}	Set<HealthCheckRepository> repositories = getContext().getRegistry().findByType(HealthCheckRepository.class);	if (ObjectHelper.isNotEmpty(repositories)) {	for (HealthCheckRepository repository: repositories) {	healthCheckRegistry.addRepository(repository);	}	}	HealthCheckService healthCheckService = getBeanForType(HealthCheckService.class);	if (healthCheckService != null) {	
using healthcheckservice 

for (HealthCheckRepository repository: repositories) {	healthCheckRegistry.addRepository(repository);	}	}	HealthCheckService healthCheckService = getBeanForType(HealthCheckService.class);	if (healthCheckService != null) {	getContext().addService(healthCheckService);	}	RouteController routeController = getBeanForType(RouteController.class);	if (routeController != null) {	
using routecontroller 

protected void setupRoutes() throws Exception {	if (routesSetupDone.compareAndSet(false, true)) {	
setting up routes 

if (config.getApiContextPath() != null) {	boolean hasRestApi = false;	for (RouteDefinition route : getContext().getRouteDefinitions()) {	FromDefinition from = route.getInputs().get(0);	if (from.getUri() != null && from.getUri().startsWith("rest-api:")) {	hasRestApi = true;	}	}	if (!hasRestApi) {	RouteDefinition route = RestDefinition.asRouteApiDefinition(getContext(), config);	
adding routeid as rest api route 

}	}	if (!hasRestApi) {	RouteDefinition route = RestDefinition.asRouteApiDefinition(getContext(), config);	getRoutes().add(route);	}	}	}	prepareRoutes();	getContext().addRouteDefinitions(getRoutes());	
found jaxb created routes 

protected void initJMXAgent() throws Exception {	CamelJMXAgentDefinition camelJMXAgent = getCamelJMXAgent();	boolean disabled = false;	if (camelJMXAgent != null) {	disabled = camelJMXAgent.getDisabled() != null && CamelContextHelper.parseBoolean(getContext(), camelJMXAgent.getDisabled());	}	if (disabled) {	
jmxagent disabled 

protected void initJMXAgent() throws Exception {	CamelJMXAgentDefinition camelJMXAgent = getCamelJMXAgent();	boolean disabled = false;	if (camelJMXAgent != null) {	disabled = camelJMXAgent.getDisabled() != null && CamelContextHelper.parseBoolean(getContext(), camelJMXAgent.getDisabled());	}	if (disabled) {	getContext().getLifecycleStrategies().clear();	getContext().setManagementStrategy(new DefaultManagementStrategy());	} else if (camelJMXAgent != null) {	
jmxagent enabled 

protected void initRouteRefs() throws Exception {	if (getRouteRefs() != null) {	for (RouteContextRefDefinition ref : getRouteRefs()) {	List<RouteDefinition> defs = ref.lookupRoutes(getContext());	for (RouteDefinition def : defs) {	
adding route from 

protected void initRestRefs() throws Exception {	if (getRestRefs() != null) {	for (RestContextRefDefinition ref : getRestRefs()) {	List<RestDefinition> defs = ref.lookupRests(getContext());	for (RestDefinition def : defs) {	
adding rest from 

protected void initThreadPoolProfiles(T context) throws Exception {	Set<String> defaultIds = new HashSet<String>();	Map<String, ThreadPoolProfile> profiles = context.getRegistry().findByTypeWithName(ThreadPoolProfile.class);	if (profiles != null && !profiles.isEmpty()) {	for (Entry<String, ThreadPoolProfile> entry : profiles.entrySet()) {	ThreadPoolProfile profile = entry.getValue();	if (profile.isDefaultProfile()) {	
using custom default threadpoolprofile with id and implementation 

context.getExecutorServiceManager().setDefaultThreadPoolProfile(profile);	defaultIds.add(entry.getKey());	} else {	context.getExecutorServiceManager().registerThreadPoolProfile(profile);	}	}	}	if (getThreadPoolProfiles() != null && !getThreadPoolProfiles().isEmpty()) {	for (ThreadPoolProfileDefinition definition : getThreadPoolProfiles()) {	if (definition.isDefaultProfile()) {	
using custom default threadpoolprofile with id and implementation 

private String[] normalizePackages(T context, List<String> unnormalized) throws Exception {	List<String> packages = new ArrayList<String>();	for (String name : unnormalized) {	name = context.resolvePropertyPlaceholders(name);	name = ObjectHelper.normalizeClassName(name);	if (ObjectHelper.isNotEmpty(name)) {	
using package to scan for routebuilder classes 

private void setupCustomServices() {	ModelJAXBContextFactory modelJAXBContextFactory = getBeanForType(ModelJAXBContextFactory.class);	if (modelJAXBContextFactory != null) {	
using custom modeljaxbcontextfactory 

private void setupCustomServices() {	ModelJAXBContextFactory modelJAXBContextFactory = getBeanForType(ModelJAXBContextFactory.class);	if (modelJAXBContextFactory != null) {	getContext().setModelJAXBContextFactory(modelJAXBContextFactory);	}	ClassResolver classResolver = getBeanForType(ClassResolver.class);	if (classResolver != null) {	
using custom classresolver 

ModelJAXBContextFactory modelJAXBContextFactory = getBeanForType(ModelJAXBContextFactory.class);	if (modelJAXBContextFactory != null) {	getContext().setModelJAXBContextFactory(modelJAXBContextFactory);	}	ClassResolver classResolver = getBeanForType(ClassResolver.class);	if (classResolver != null) {	getContext().setClassResolver(classResolver);	}	FactoryFinderResolver factoryFinderResolver = getBeanForType(FactoryFinderResolver.class);	if (factoryFinderResolver != null) {	
using custom factoryfinderresolver 

ClassResolver classResolver = getBeanForType(ClassResolver.class);	if (classResolver != null) {	getContext().setClassResolver(classResolver);	}	FactoryFinderResolver factoryFinderResolver = getBeanForType(FactoryFinderResolver.class);	if (factoryFinderResolver != null) {	getContext().setFactoryFinderResolver(factoryFinderResolver);	}	ExecutorServiceManager executorServiceStrategy = getBeanForType(ExecutorServiceManager.class);	if (executorServiceStrategy != null) {	
using custom executorservicestrategy 

FactoryFinderResolver factoryFinderResolver = getBeanForType(FactoryFinderResolver.class);	if (factoryFinderResolver != null) {	getContext().setFactoryFinderResolver(factoryFinderResolver);	}	ExecutorServiceManager executorServiceStrategy = getBeanForType(ExecutorServiceManager.class);	if (executorServiceStrategy != null) {	getContext().setExecutorServiceManager(executorServiceStrategy);	}	ThreadPoolFactory threadPoolFactory = getBeanForType(ThreadPoolFactory.class);	if (threadPoolFactory != null) {	
using custom threadpoolfactory 

ExecutorServiceManager executorServiceStrategy = getBeanForType(ExecutorServiceManager.class);	if (executorServiceStrategy != null) {	getContext().setExecutorServiceManager(executorServiceStrategy);	}	ThreadPoolFactory threadPoolFactory = getBeanForType(ThreadPoolFactory.class);	if (threadPoolFactory != null) {	getContext().getExecutorServiceManager().setThreadPoolFactory(threadPoolFactory);	}	ProcessorFactory processorFactory = getBeanForType(ProcessorFactory.class);	if (processorFactory != null) {	
using custom processorfactory 

ThreadPoolFactory threadPoolFactory = getBeanForType(ThreadPoolFactory.class);	if (threadPoolFactory != null) {	getContext().getExecutorServiceManager().setThreadPoolFactory(threadPoolFactory);	}	ProcessorFactory processorFactory = getBeanForType(ProcessorFactory.class);	if (processorFactory != null) {	getContext().setProcessorFactory(processorFactory);	}	Debugger debugger = getBeanForType(Debugger.class);	if (debugger != null) {	
using custom debugger 

ProcessorFactory processorFactory = getBeanForType(ProcessorFactory.class);	if (processorFactory != null) {	getContext().setProcessorFactory(processorFactory);	}	Debugger debugger = getBeanForType(Debugger.class);	if (debugger != null) {	getContext().setDebugger(debugger);	}	UuidGenerator uuidGenerator = getBeanForType(UuidGenerator.class);	if (uuidGenerator != null) {	
using custom uuidgenerator 

Debugger debugger = getBeanForType(Debugger.class);	if (debugger != null) {	getContext().setDebugger(debugger);	}	UuidGenerator uuidGenerator = getBeanForType(UuidGenerator.class);	if (uuidGenerator != null) {	getContext().setUuidGenerator(uuidGenerator);	}	NodeIdFactory nodeIdFactory = getBeanForType(NodeIdFactory.class);	if (nodeIdFactory != null) {	
using custom nodeidfactory 

UuidGenerator uuidGenerator = getBeanForType(UuidGenerator.class);	if (uuidGenerator != null) {	getContext().setUuidGenerator(uuidGenerator);	}	NodeIdFactory nodeIdFactory = getBeanForType(NodeIdFactory.class);	if (nodeIdFactory != null) {	getContext().setNodeIdFactory(nodeIdFactory);	}	StreamCachingStrategy streamCachingStrategy = getBeanForType(StreamCachingStrategy.class);	if (streamCachingStrategy != null) {	
using custom streamcachingstrategy 

NodeIdFactory nodeIdFactory = getBeanForType(NodeIdFactory.class);	if (nodeIdFactory != null) {	getContext().setNodeIdFactory(nodeIdFactory);	}	StreamCachingStrategy streamCachingStrategy = getBeanForType(StreamCachingStrategy.class);	if (streamCachingStrategy != null) {	getContext().setStreamCachingStrategy(streamCachingStrategy);	}	MessageHistoryFactory messageHistoryFactory = getBeanForType(MessageHistoryFactory.class);	if (messageHistoryFactory != null) {	
using custom messagehistoryfactory 

========================= camel sample_15074 =========================

public void run() {	if (!isRunAllowed()) {	
purge task not allowed to run 

public void run() {	if (!isRunAllowed()) {	return;	}	
running purge task to see if any entries has been timed out 

public void run() {	if (!isRunAllowed()) {	return;	}	try {	purge();	} catch (Throwable t) {	
exception occurred during purge task this exception will be ignored 

public void purge() {	
there are in the timeout map 

}	long now = currentTime();	List<TimeoutMapEntry<K, V>> expired = new ArrayList<TimeoutMapEntry<K, V>>();	if (useLock) {	lock.lock();	}	try {	for (Map.Entry<K, TimeoutMapEntry<K, V>> entry : map.entrySet()) {	if (entry.getValue().getExpireTime() < now) {	if (isValidForEviction(entry.getValue())) {	
evicting inactive entry id 

return diff > 0 ? 1 : -1;	}	});	List<K> evicts = new ArrayList<K>(expired.size());	try {	for (TimeoutMapEntry<K, V> entry : expired) {	boolean evict = false;	try {	evict = onEviction(entry.getKey(), entry.getValue());	} catch (Throwable t) {	
exception happened during eviction of entry id won t evict and will continue trying 

========================= camel sample_5175 =========================

public static InputStream download(com.google.api.services.drive.model.File fileMetadata, Exchange exchange) throws Exception {	if (fileMetadata.getDownloadUrl() != null && fileMetadata.getDownloadUrl().length() > 0) {	try {	HttpResponse resp = getClient(exchange).getRequestFactory().buildGetRequest(new GenericUrl(fileMetadata.getDownloadUrl())).execute();	return resp.getContent();	} catch (IOException e) {	
could not download file 

========================= camel sample_15424 =========================

public void testLoadTestLevelDBAggregate() throws Exception {	MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(10);	mock.setResultWaitTime(50 * 1000);	ExecutorService executor = Executors.newFixedThreadPool(10);	
staring to send messages 

MockEndpoint mock = getMockEndpoint("mock:result");	mock.expectedMessageCount(10);	mock.setResultWaitTime(50 * 1000);	ExecutorService executor = Executors.newFixedThreadPool(10);	for (int i = 0; i < SIZE; i++) {	final int value = 1;	final int key = i % 10;	executor.submit(new Callable<Object>() {	public Object call() throws Exception {	char id = KEYS[key];	
sending with id 

final int key = i % 10;	executor.submit(new Callable<Object>() {	public Object call() throws Exception {	char id = KEYS[key];	template.sendBodyAndHeader("direct:start", value, "id", "" + id);	Thread.sleep(3);	return null;	}	});	}	
sending all message done now waiting for aggregation to complete 

========================= camel sample_13909 =========================

public void run() {	try {	
waiting for latch 

public void run() {	try {	latch.await(30, TimeUnit.SECONDS);	Thread.sleep(1000);	} catch (Exception e) {	}	
sending late reply 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from(getQueueEndpointName()) .process(new Processor() {	public void process(Exchange exchange) throws Exception {	exchange.setPattern(ExchangePattern.InOnly);	Message in = exchange.getIn();	assertEquals("Hello World", in.getBody());	replyDestination = in.getHeader("JMSReplyTo", Destination.class);	cid = in.getHeader("JMSCorrelationID", String.class);	
replydestination 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from(getQueueEndpointName()) .process(new Processor() {	public void process(Exchange exchange) throws Exception {	exchange.setPattern(ExchangePattern.InOnly);	Message in = exchange.getIn();	assertEquals("Hello World", in.getBody());	replyDestination = in.getHeader("JMSReplyTo", Destination.class);	cid = in.getHeader("JMSCorrelationID", String.class);	
jmscorrelationid 

protected RouteBuilder createRouteBuilder() throws Exception {	return new RouteBuilder() {	public void configure() throws Exception {	from(getQueueEndpointName()) .process(new Processor() {	public void process(Exchange exchange) throws Exception {	exchange.setPattern(ExchangePattern.InOnly);	Message in = exchange.getIn();	assertEquals("Hello World", in.getBody());	replyDestination = in.getHeader("JMSReplyTo", Destination.class);	cid = in.getHeader("JMSCorrelationID", String.class);	
ahh i cannot send a reply someone else must do it 

========================= camel sample_6923 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<GitComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.git.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.git.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_728 =========================

private synchronized void updateOAuthToken() throws IOException {	final long currentTime = System.currentTimeMillis();	if (oAuthToken == null || oAuthToken.getExpiryTime() < currentTime) {	
oauth token doesn t exist or has expired 

private synchronized void updateOAuthToken() throws IOException {	final long currentTime = System.currentTimeMillis();	if (oAuthToken == null || oAuthToken.getExpiryTime() < currentTime) {	final OAuthSecureStorage secureStorage = oAuthParams.getSecureStorage();	if (secureStorage != null) {	oAuthToken = secureStorage.getOAuthToken();	if (oAuthToken != null && oAuthToken.getExpiryTime() > currentTime) {	return;	}	
oauth secure storage returned a null or expired token creating a new token 

oAuthToken = secureStorage.getOAuthToken();	if (oAuthToken != null && oAuthToken.getExpiryTime() > currentTime) {	return;	}	if (oAuthParams.getUserPassword() == null || oAuthParams.getUserPassword().isEmpty()) {	throw new IllegalArgumentException("Missing password for LinkedIn authorization");	}	}	final String refreshToken = getRefreshToken();	this.oAuthToken = getAccessToken(refreshToken);	
oauth token created 

========================= camel sample_8878 =========================

private synchronized Transform getTransform() throws Exception {	if (transform == null) {	if (log.isDebugEnabled()) {	String path = getResourceUri();	
jolt content read from resource with resourceuri for endpoint 

public JoltEndpoint findOrCreateEndpoint(String uri, String newResourceUri) {	String newUri = uri.replace(getResourceUri(), newResourceUri);	
getting endpoint with uri 

protected void onExchange(Exchange exchange) throws Exception {	String path = getResourceUri();	ObjectHelper.notNull(path, "resourceUri");	String newResourceUri = exchange.getIn().getHeader(JoltConstants.JOLT_RESOURCE_URI, String.class);	if (newResourceUri != null) {	exchange.getIn().removeHeader(JoltConstants.JOLT_RESOURCE_URI);	
set to creating new endpoint to handle exchange 

========================= camel sample_12924 =========================

public void testPrimitiveTypeConverter() throws Exception {	StopWatch watch = new StopWatch();	for (int i = 0; i < 10000; i++) {	int num = context.getTypeConverter().convertTo(int.class, "123");	assertEquals(123, num);	}	
time taken 

========================= camel sample_1474 =========================

public void execute() throws MojoExecutionException, MojoFailureException {	if (Arrays.asList(IGNORE_MODULES).contains(project.getArtifactId())) {	
component auto configuration will not be created component contained in the ignore list 

public void execute() throws MojoExecutionException, MojoFailureException {	if (Arrays.asList(IGNORE_MODULES).contains(project.getArtifactId())) {	return;	}	File starterDir = SpringBootHelper.starterDir(baseDir, project.getArtifactId());	if (!starterDir.exists() || !(new File(starterDir, "pom.xml").exists())) {	
component auto configuration will not be created the starter does not exist 

private void executeComponent() throws MojoExecutionException, MojoFailureException {	List<String> componentNames = findComponentNames();	final Set<File> jsonFiles = new TreeSet<File>();	PackageHelper.findJsonFiles(buildDir, jsonFiles, new PackageHelper.CamelComponentsModelFilter());	if (!componentNames.isEmpty()) {	
found components 

private void executeDataFormat() throws MojoExecutionException, MojoFailureException {	List<String> dataFormatNames = findDataFormatNames();	final Set<File> jsonFiles = new TreeSet<File>();	PackageHelper.findJsonFiles(buildDir, jsonFiles, new PackageHelper.CamelComponentsModelFilter());	if (!dataFormatNames.isEmpty()) {	
found dataformats 

private void executeLanguage() throws MojoExecutionException, MojoFailureException {	List<String> languageNames = findLanguageNames();	final Set<File> jsonFiles = new TreeSet<File>();	PackageHelper.findJsonFiles(buildDir, jsonFiles, new PackageHelper.CamelComponentsModelFilter());	if (!languageNames.isEmpty()) {	
found languages 

sb.append("                applicationContext.getEnvironment(),\n");	sb.append("               \"camel.component.customizer\",\n");	sb.append("               \"camel.component.").append(name).append(".customizer\",\n");	sb.append("               ((HasId)customizer).getId())\n");	sb.append("            : HierarchicalPropertiesEvaluator.evaluate(\n");	sb.append("                applicationContext.getEnvironment(),\n");	sb.append("               \"camel.component.customizer\",\n");	sb.append("               \"camel.component.").append(name).append(".customizer\");\n");	sb.append("\n");	sb.append("        if (useCustomizer) {\n");	
logger debug component customizer 

sb.append("                applicationContext.getEnvironment(),\n");	sb.append("               \"camel.dataformat.customizer\",\n");	sb.append("               \"camel.dataformat.").append(name).append(".customizer\",\n");	sb.append("               ((HasId)customizer).getId())\n");	sb.append("            : HierarchicalPropertiesEvaluator.evaluate(\n");	sb.append("                applicationContext.getEnvironment(),\n");	sb.append("               \"camel.dataformat.customizer\",\n");	sb.append("               \"camel.dataformat.").append(name).append(".customizer\");\n");	sb.append("\n");	sb.append("        if (useCustomizer) {\n");	
logger debug dataformat customizer 

sb.append("                applicationContext.getEnvironment(),\n");	sb.append("               \"camel.language.customizer\",\n");	sb.append("               \"camel.language.").append(name).append(".customizer\",\n");	sb.append("               ((HasId)customizer).getId())\n");	sb.append("            : HierarchicalPropertiesEvaluator.evaluate(\n");	sb.append("                applicationContext.getEnvironment(),\n");	sb.append("               \"camel.language.customizer\",\n");	sb.append("               \"camel.language.").append(name).append(".customizer\");\n");	sb.append("\n");	sb.append("        if (useCustomizer) {\n");	
logger debug language customizer 

private void writeSourceIfChanged(String source, String fileName) throws MojoFailureException {	source = Formatter.format(source);	source = source.replaceAll("\\t", "    ");	File target = new File(SpringBootHelper.starterSrcDir(baseDir, project.getArtifactId()), fileName);	deleteFileOnMainArtifact(target);	try {	InputStream is = getClass().getClassLoader().getResourceAsStream("license-header-java.txt");	String header = loadText(is);	String code = source;	code = header + code;	
source code generated 

deleteFileOnMainArtifact(target);	try {	InputStream is = getClass().getClassLoader().getResourceAsStream("license-header-java.txt");	String header = loadText(is);	String code = source;	code = header + code;	if (target.exists()) {	String existing = FileUtils.readFileToString(target);	if (!code.equals(existing)) {	FileUtils.write(target, code, false);	
updated existing file 

try {	InputStream is = getClass().getClassLoader().getResourceAsStream("license-header-java.txt");	String header = loadText(is);	String code = source;	code = header + code;	if (target.exists()) {	String existing = FileUtils.readFileToString(target);	if (!code.equals(existing)) {	FileUtils.write(target, code, false);	} else {	
no changes to existing file 

String code = source;	code = header + code;	if (target.exists()) {	String existing = FileUtils.readFileToString(target);	if (!code.equals(existing)) {	FileUtils.write(target, code, false);	} else {	}	} else {	FileUtils.write(target, code);	
created file 

try {	boolean found = false;	List<String> lines = FileUtils.readLines(target);	for (String line : lines) {	if (line.contains(name)) {	found = true;	break;	}	}	if (found) {	
no changes to existing file 

lastLine = i;	break;	}	}	lines.add(lastLine + 1, lineToAdd);	StringBuilder code = new StringBuilder();	for (String line : lines) {	code.append(line).append("\n");	}	FileUtils.write(target, code.toString(), false);	
updated existing file 

}	} catch (Exception e) {	throw new MojoFailureException("IOError with file " + target, e);	}	} else {	try {	InputStream is = getClass().getClassLoader().getResourceAsStream("license-header.txt");	String header = loadText(is);	String code = sb.toString();	code = header + "\n" + code;	
source code generated 

} catch (Exception e) {	throw new MojoFailureException("IOError with file " + target, e);	}	} else {	try {	InputStream is = getClass().getClassLoader().getResourceAsStream("license-header.txt");	String header = loadText(is);	String code = sb.toString();	code = header + "\n" + code;	FileUtils.write(target, code);	
created file 

deleteFileOnMainArtifact(target);	try {	Gson gson = new GsonBuilder().setPrettyPrinting().create();	Map<String, Object> map = null;	List<Map<String, Object>> properties = null;	if (target.exists()) {	BufferedReader br = new BufferedReader(new FileReader(target));	map = gson.fromJson(br, Map.class);	properties = (List<Map<String, Object>>)map.get("properties");	if (properties != null && properties.stream().anyMatch(m -> fullQualifiedName.equals(m.get("name")))) {	
no changes to existing file 

========================= camel sample_143 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SpringIntegrationComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator .evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.spring-integration.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator .evaluate(applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.spring-integration.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_513 =========================

public void read(String body) {	this.body = body;	
read method on with body 

========================= camel sample_1862 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<AhcComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ahc.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ahc.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_456 =========================

contextAware.setCamelContext(camelContext);	}	}	Map<String, Object> parameters = new HashMap<>();	IntrospectionSupport.getProperties(configuration, parameters, null, false);	CamelPropertiesHelper.setCamelProperties(camelContext, language, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (LanguageCustomizer<SimpleLanguage> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.simple.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.language.customizer", "camel.language.simple.customizer");	if (useCustomizer) {	
configure language with customizer 

========================= camel sample_905 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<JavaSpaceComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.javaspace.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.javaspace.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1161 =========================

public ModelMBean assemble(MBeanServer mBeanServer, Object obj, ObjectName name) throws JMException {	ModelMBeanInfo mbi = null;	ModelMBeanInfo standardMbi = null;	Object custom = null;	if (obj instanceof ManagedInstance) {	custom = ((ManagedInstance) obj).getInstance();	if (custom != null && ObjectHelper.hasAnnotation(custom.getClass().getAnnotations(), ManagedResource.class)) {	
assembling mbeaninfo for from custom managedresource object 

ModelMBeanInfo standardMbi = null;	Object custom = null;	if (obj instanceof ManagedInstance) {	custom = ((ManagedInstance) obj).getInstance();	if (custom != null && ObjectHelper.hasAnnotation(custom.getClass().getAnnotations(), ManagedResource.class)) {	mbi = assembler.getMBeanInfo(obj, custom, name.toString());	standardMbi = assembler.getMBeanInfo(obj, null, name.toString());	}	}	if (mbi == null) {	
assembling mbeaninfo for from managedresource object 

========================= camel sample_4699 =========================

public void notify(EventObject event) throws Exception {	if (!isStarted()) {	
cannot publish event as notifier is not started 

public void notify(EventObject event) throws Exception {	if (!isStarted()) {	return;	}	if (!camelContext.getStatus().isStarted()) {	
cannot publish event as camelcontext is not started 

========================= camel sample_4733 =========================

body = (byte[])message;	} else {	throw new IllegalArgumentException("The message to encode is not a supported type: " + message.getClass().getCanonicalName());	}	IoBuffer buf = IoBuffer.allocate(body.length + 3).setAutoExpand(true);	buf.put((byte)config.getStartByte());	buf.put(body);	buf.put((byte)config.getEndByte1());	buf.put((byte)config.getEndByte2());	buf.flip();	
encoded from to byte stream 

========================= camel sample_11430 =========================

WaitForTaskToComplete wait = waitForTaskToComplete;	if (exchange.getProperty(Exchange.ASYNC_WAIT) != null) {	wait = exchange.getProperty(Exchange.ASYNC_WAIT, WaitForTaskToComplete.class);	}	if (wait == WaitForTaskToComplete.Always || (wait == WaitForTaskToComplete.IfReplyExpected && ExchangeHelper.isOutCapable(exchange))) {	final CountDownLatch latch = new CountDownLatch(1);	copy.addOnCompletion(new SynchronizationAdapter() {	public void onDone(Exchange response) {	if (latch.getCount() == 0) {	if (log.isTraceEnabled()) {	
timeout occurred so response will be ignored 

if (wait == WaitForTaskToComplete.Always || (wait == WaitForTaskToComplete.IfReplyExpected && ExchangeHelper.isOutCapable(exchange))) {	final CountDownLatch latch = new CountDownLatch(1);	copy.addOnCompletion(new SynchronizationAdapter() {	public void onDone(Exchange response) {	if (latch.getCount() == 0) {	if (log.isTraceEnabled()) {	}	return;	} else {	if (log.isTraceEnabled()) {	
with response 

}	public boolean allowHandover() {	return false;	}	public String toString() {	return "onDone at [" + endpoint.getEndpointUri() + "]";	}	});	queue.add(copy);	if (timeout > 0) {	
waiting for task to complete using timeout ms at 

boolean done = false;	try {	done = latch.await(timeout, TimeUnit.MILLISECONDS);	} catch (InterruptedException e) {	}	if (!done) {	exchange.setException(new ExchangeTimedOutException(exchange, timeout));	latch.countDown();	}	} else {	
waiting for task to complete blocking at 

========================= camel sample_14632 =========================

public Processor wrap(RouteContext routeContext, final Processor processor) {	if (LOG.isDebugEnabled()) {	
securing route using shiro policy 

========================= camel sample_12135 =========================

public void configure() throws Exception {	
about to start route direct splunk server 

========================= camel sample_17767 =========================

public void testBigPayload() throws Exception {	
running test for millis 

public void testBigPayload() throws Exception {	Thread.sleep(60 * 1000);	File file = new File("target/data/hawtdb.dat");	assertTrue(file + " should exists", file.exists());	long size = file.length();	
size is 

========================= camel sample_11719 =========================

public void notify(EventObject event) throws Exception {	if (event instanceof ExchangeSendingEvent) {	
sending 

========================= camel sample_1618 =========================

public int processBatch(Queue<Object> exchanges) throws Exception {	int total = exchanges.size();	for (int index = 0; index < total && isBatchAllowed(); index++) {	Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());	exchange.setProperty(Exchange.BATCH_INDEX, index);	exchange.setProperty(Exchange.BATCH_SIZE, total);	exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);	pendingExchanges = total - index - 1;	
processing exchange 

========================= camel sample_8086 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ReactiveStreamsComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.reactive-streams.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.reactive-streams.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_790 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KratiComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.krati.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.krati.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_505 =========================

protected void doStart() throws Exception {	influxDB = CamelContextHelper.mandatoryLookup(getCamelContext(), connectionBean, InfluxDB.class);	
resolved the connection with the name as 

========================= camel sample_11133 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<MockComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mock.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.mock.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_856 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ThriftComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.thrift.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.thrift.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1032 =========================

public void testRouteboxDirectAsyncRequests() throws Exception {	template = new DefaultProducerTemplate(context);	template.start();	context.addRoutes(new RouteBuilder() {	public void configure() {	from(routeboxUri) .to("log:Routes operation performed?showAll=true");	}	});	context.start();	
beginning test testrouteboxdirectasyncrequests 

context.addRoutes(new RouteBuilder() {	public void configure() {	from(routeboxUri) .to("log:Routes operation performed?showAll=true");	}	});	context.start();	Book book = new Book("Sir Arthur Conan Doyle", "The Adventures of Sherlock Holmes");	String response = sendAddToCatalogRequest(template, routeboxUri, "addToCatalog", book);	assertEquals("Book with Author " + book.getAuthor() + " and title " + book.getTitle() + " added to Catalog", response);	book = sendFindBookRequest(template, routeboxUri, "findBook", "Sir Arthur Conan Doyle");	
received book with author and title 

public void configure() {	from(routeboxUri) .to("log:Routes operation performed?showAll=true");	}	});	context.start();	Book book = new Book("Sir Arthur Conan Doyle", "The Adventures of Sherlock Holmes");	String response = sendAddToCatalogRequest(template, routeboxUri, "addToCatalog", book);	assertEquals("Book with Author " + book.getAuthor() + " and title " + book.getTitle() + " added to Catalog", response);	book = sendFindBookRequest(template, routeboxUri, "findBook", "Sir Arthur Conan Doyle");	assertEquals("The Adventures of Sherlock Holmes", book.getTitle());	
completed test testrouteboxdirectasyncrequests 

========================= camel sample_14624 =========================

protected HazelcastDefaultEndpoint doCreateEndpoint(String uri, String remaining, Map<String, Object> parameters, HazelcastInstance hzInstance) throws Exception {	HazelcastDefaultEndpoint endpoint = null;	
the scheme syntax hazelcast has been deprecated use hazelcast instead 

========================= camel sample_9547 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<IgniteMessagingComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ignite-messaging.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ignite-messaging.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1177 =========================

public void doStart() throws Exception {	super.doStart();	ddbClient = configuration.getAmazonDDBClient() != null ? configuration.getAmazonDDBClient() : createDdbClient();	if (ObjectHelper.isNotEmpty(configuration.getAmazonDdbEndpoint())) {	ddbClient.setEndpoint(configuration.getAmazonDdbEndpoint());	}	String tableName = getConfiguration().getTableName();	
querying whether table already exists 

if (ObjectHelper.isNotEmpty(configuration.getAmazonDdbEndpoint())) {	ddbClient.setEndpoint(configuration.getAmazonDdbEndpoint());	}	String tableName = getConfiguration().getTableName();	try {	DescribeTableRequest request = new DescribeTableRequest().withTableName(tableName);	TableDescription tableDescription = ddbClient.describeTable(request).getTable();	if (!isTableActive(tableDescription)) {	waitForTableToBecomeAvailable(tableName);	}	
table already exists 

}	String tableName = getConfiguration().getTableName();	try {	DescribeTableRequest request = new DescribeTableRequest().withTableName(tableName);	TableDescription tableDescription = ddbClient.describeTable(request).getTable();	if (!isTableActive(tableDescription)) {	waitForTableToBecomeAvailable(tableName);	}	return;	} catch (ResourceNotFoundException e) {	
table doesn t exist yet 

}	String tableName = getConfiguration().getTableName();	try {	DescribeTableRequest request = new DescribeTableRequest().withTableName(tableName);	TableDescription tableDescription = ddbClient.describeTable(request).getTable();	if (!isTableActive(tableDescription)) {	waitForTableToBecomeAvailable(tableName);	}	return;	} catch (ResourceNotFoundException e) {	
creating table 

TableDescription tableDescription = ddbClient.describeTable(request).getTable();	if (!isTableActive(tableDescription)) {	waitForTableToBecomeAvailable(tableName);	}	return;	} catch (ResourceNotFoundException e) {	TableDescription tableDescription = createTable(tableName);	if (!isTableActive(tableDescription)) {	waitForTableToBecomeAvailable(tableName);	}	
table created 

private void waitForTableToBecomeAvailable(String tableName) {	
waiting for to become active 

while (waitTime > 0) {	try {	Thread.sleep(1000 * 5);	waitTime -= 5000;	} catch (Exception e) {	}	try {	DescribeTableRequest request = new DescribeTableRequest().withTableName(tableName);	TableDescription tableDescription = getDdbClient().describeTable(request).getTable();	if (isTableActive(tableDescription)) {	
table became active 

Thread.sleep(1000 * 5);	waitTime -= 5000;	} catch (Exception e) {	}	try {	DescribeTableRequest request = new DescribeTableRequest().withTableName(tableName);	TableDescription tableDescription = getDdbClient().describeTable(request).getTable();	if (isTableActive(tableDescription)) {	return;	}	
table not active yet 

========================= camel sample_8706 =========================

connector.setPort(endpoint.getPort());	} else {	connector.setPort(port);	}	if (endpoint.getHost() != null) {	connector.setHost(endpoint.getHost());	} else {	connector.setHost(host);	}	server.addConnector(connector);	
jetty connector added 

server.setHandler(context);	applyCrossOriginFiltering(endpoint, context);	if (endpoint.getStaticResources() != null) {	server = createStaticResourcesServer(server, context, endpoint.getStaticResources());	}	MemoryWebsocketStore memoryStore = new MemoryWebsocketStore();	connectorRef = new ConnectorRef(server, connector, null, memoryStore);	if (endpoint.isSessionSupport()) {	enableSessionSupport(connectorRef.server, connectorKey);	}	
jetty server starting on host 

public void disconnect(WebsocketProducerConsumer prodcon) throws Exception {	WebsocketEndpoint endpoint = prodcon.getEndpoint();	String connectorKey = getConnectorKey(endpoint);	synchronized (CONNECTORS) {	ConnectorRef connectorRef = CONNECTORS.get(connectorKey);	if (connectorRef != null) {	if (connectorRef.decrement() == 0) {	
stopping jetty server as the last connector is disconnecting 

protected Server createStaticResourcesServer(Server server, ServletContextHandler context, String home) throws Exception {	context.setContextPath("/");	SessionHandler sh = new SessionHandler();	context.setSessionHandler(sh);	if (home != null) {	String[] resources = home.split(":");	if (LOG.isDebugEnabled()) {	
protocol found and resource 

String key = getConnectorKey(endpoint);	ConnectorRef connectorRef = getConnectors().get(key);	WebsocketComponentServlet servlet;	if (connectorRef != null) {	String pathSpec = createPathSpec(resourceUri);	servlet = servlets.get(pathSpec);	if (servlet == null) {	ServletContextHandler context = (ServletContextHandler) connectorRef.server.getHandler();	servlet = createServlet(sync, pathSpec, servlets, context);	connectorRef.servlet = servlet;	
websocket servlet added for the following path to the jetty server 

private void enableJmx(Server server) {	MBeanContainer containerToRegister = getMbContainer();	if (containerToRegister != null) {	
jetty jmx extensions is enabled 

protected void doStart() throws Exception {	super.doStart();	if (staticResources != null) {	ObjectHelper.notEmpty(host, "host", this);	ObjectHelper.notNull(port, "port", this);	
starting static resources server with static resource 

connectorRef.connector.stop();	connectorRef.server.stop();	connectorRef.memoryStore.stop();	connectorRef.servlet = null;	}	CONNECTORS.remove(connectorKey);	}	}	CONNECTORS.clear();	if (staticResourcesServer != null) {	
stopping static resources server with static resource 

========================= camel sample_17458 =========================

String badHtml = TidyMarkupTestSupport.loadFileAsString(new File( "src/test/resources/org/apache/camel/dataformat/tagsoup/testfile1.html"));	String evilHtml = TidyMarkupTestSupport.loadFileAsString(new File( "src/test/resources/org/apache/camel/dataformat/tagsoup/testfile2-evilHtml.html"));	template.sendBody("direct:start", badHtml);	template.sendBody("direct:start", evilHtml);	resultEndpoint.assertIsSatisfied();	List<Exchange> list = resultEndpoint.getReceivedExchanges();	for (Exchange exchange : list) {	try {	Message in = exchange.getIn();	Node tidyMarkup = in.getBody(Node.class);	
received 

========================= camel sample_11975 =========================

private void startQuickfixjEngine(QuickfixjEngine engine) throws Exception {	if (!engine.isLazy()) {	
starting quickfix j engine 

private void startQuickfixjEngine(QuickfixjEngine engine) throws Exception {	if (!engine.isLazy()) {	engine.start();	} else {	
quickfix j engine will start lazily 

========================= camel sample_10667 =========================

protected void doProcess(Exchange exchange, MetricsEndpoint endpoint, MetricRegistry registry, String metricsName) throws Exception {	Message in = exchange.getIn();	Histogram histogram = registry.histogram(metricsName);	Long value = endpoint.getValue();	Long finalValue = getLongHeader(in, HEADER_HISTOGRAM_VALUE, value);	if (finalValue != null) {	histogram.update(finalValue);	} else {	
cannot update histogram with null value 

========================= camel sample_13698 =========================

public void testGetTickets() throws Exception {	final Iterable<?> result = requestBody("direct: assertNotNull("getTickets result", result);	int count = 0;	for (Object ticket : result) {	LOG.info(ticket.toString());	count++;	}	
ticket s in total 

========================= camel sample_9394 =========================

public void testSoapHbr() throws Exception {	send("http: StopWatch watch = new StopWatch();	
http log warn ms count watch taken 

========================= camel sample_6431 =========================

public static void main(String[] args) throws Exception {	
about to run splunk camel integration 

========================= camel sample_17771 =========================

public String read(String body, @XPath("/soap:Envelope/soap:Body/foo/text()") String foo) {	this.foo = foo;	this.body = body;	
read method called on 

========================= camel sample_2167 =========================

public void process(Exchange exchange) throws Exception {	Message in = exchange.getIn();	Node node = exchange.getIn().getBody(Node.class);	
got event with node name and action 

========================= camel sample_13227 =========================

traceDoCatch(traced, exchange);	} else if (ProcessorDefinitionHelper.isFirstChildOfType(FinallyDefinition.class, node)) {	traceDoFinally(traced, exchange);	} else if (ProcessorDefinitionHelper.isFirstChildOfType(AggregateDefinition.class, node)) {	traceAggregate(traced, exchange);	} else {	traced.addTraced(new DefaultRouteNode(node, super.getProcessor()));	}	}	} else {	
cannot trace as this exchange does not have an unitofwork 

========================= camel sample_4549 =========================

if (attachmentMultipartBinding != null) {	endpoint.setAttachmentMultipartBinding(attachmentMultipartBinding);	} else {	endpoint.setAttachmentMultipartBinding(isAttachmentMultipartBinding());	}	if (disableStreamCache != null) {	endpoint.setDisableStreamCache(disableStreamCache);	}	if (endpoint.isAttachmentMultipartBinding()) {	if (disableStreamCache == null) {	
disabling stream caching as attachmentmultipartbinding is enabled 

========================= camel sample_14448 =========================

private T getNextElement() {	if (asn1InputStream == null) {	return null;	}	try {	ASN1Primitive current = getNextEntry();	if (current != null) {	T instance = ObjectHelper.cast(clazz, createGenericTypeObject(current, clazz));	return instance;	} else {	
close 

========================= camel sample_9455 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SpringWebserviceComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.spring-ws.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.spring-ws.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1065 =========================

account.setShippingPostalCode("94105");	account.setShippingState("CA");	account.setShippingStreet("1 Market St #300");	account.setShippingLatitude(37.793779);	account.setShippingLongitude(-122.39448);	account.setShipping_Location__Latitude__s(37.793779);	account.setShipping_Location__Longitude__s(-122.39448);	CreateSObjectResult result = template().requestBody("direct:createSObject" + suffix, account, CreateSObjectResult.class);	assertNotNull(result);	assertTrue("Create success", result.getSuccess());	
create 

account.setShipping_Location__Longitude__s(-122.39448);	CreateSObjectResult result = template().requestBody("direct:createSObject" + suffix, account, CreateSObjectResult.class);	assertNotNull(result);	assertTrue("Create success", result.getSuccess());	try {	account = template().requestBody("direct:getSObject" + suffix, result.getId(), Account.class);	assertNotNull(account);	assertNotNull("Billing Address", account.getBillingAddress());	assertNotNull("Shipping Address", account.getShippingAddress());	assertNotNull("Shipping Location", account.getShippingAddress());	
retrieved fields billing address shipping location 

assertNotNull(result);	assertTrue("Create success", result.getSuccess());	try {	account = template().requestBody("direct:getSObject" + suffix, result.getId(), Account.class);	assertNotNull(account);	assertNotNull("Billing Address", account.getBillingAddress());	assertNotNull("Shipping Address", account.getShippingAddress());	assertNotNull("Shipping Location", account.getShippingAddress());	} finally {	assertNull(template().requestBody("direct:deleteSObject" + suffix, result.getId()));	
delete successful 

========================= camel sample_14736 =========================

final int tempI = i;	Runnable worker = new Runnable() {	public void run() {	try {	final String requestText = "Message " + tempI;	final String responseText = "Response Message " + tempI;	String response = template.requestBody("direct:start", requestText, String.class);	assertNotNull(response);	assertEquals(responseText, response);	} catch (Exception e) {	
todo auto generated catch block 

========================= camel sample_12318 =========================

ChannelOption<Object> option = ChannelOption.valueOf(entry.getKey());	if (EndpointHelper.isReferenceParameter(value)) {	String name = value.substring(1);	Object o = CamelContextHelper.mandatoryLookup(camelContext, name);	bootstrap.option(option, o);	} else {	bootstrap.option(option, value);	}	}	}	
created bootstrap 

bootstrap.handler(pipelineFactory);	InetSocketAddress hostAddress = new InetSocketAddress(configuration.getHost(), configuration.getPort());	SubnetUtils multicastSubnet = new SubnetUtils(MULTICAST_SUBNET);	if (multicastSubnet.getInfo().isInRange(configuration.getHost())) {	ChannelFuture channelFuture = bootstrap.bind(configuration.getPort()).sync();	channel = channelFuture.channel();	DatagramChannel datagramChannel = (DatagramChannel) channel;	String networkInterface = configuration.getNetworkInterface() == null ? LOOPBACK_INTERFACE : configuration.getNetworkInterface();	multicastNetworkInterface = NetworkInterface.getByName(networkInterface);	ObjectHelper.notNull(multicastNetworkInterface, "No network interface found for '" + networkInterface + "'.");	
connectionlessbootstrap joining using network interface 

if (multicastSubnet.getInfo().isInRange(configuration.getHost())) {	ChannelFuture channelFuture = bootstrap.bind(configuration.getPort()).sync();	channel = channelFuture.channel();	DatagramChannel datagramChannel = (DatagramChannel) channel;	String networkInterface = configuration.getNetworkInterface() == null ? LOOPBACK_INTERFACE : configuration.getNetworkInterface();	multicastNetworkInterface = NetworkInterface.getByName(networkInterface);	ObjectHelper.notNull(multicastNetworkInterface, "No network interface found for '" + networkInterface + "'.");	datagramChannel.joinGroup(hostAddress, multicastNetworkInterface).syncUninterruptibly();	allChannels.add(datagramChannel);	} else {	
connectionlessbootstrap binding to 

protected void stopServerBootstrap() {	
connectionlessbootstrap disconnecting from 

protected void stopServerBootstrap() {	
closing channels 

========================= camel sample_10260 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<KestrelComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kestrel.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.kestrel.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_417 =========================

public void execute() {	ListDomainsRequest request = new ListDomainsRequest() .withMaxNumberOfDomains(determineMaxNumberOfDomains()) .withNextToken(determineNextToken());	
sending request for exchange 

public void execute() {	ListDomainsRequest request = new ListDomainsRequest() .withMaxNumberOfDomains(determineMaxNumberOfDomains()) .withNextToken(determineNextToken());	ListDomainsResult result = this.sdbClient.listDomains(request);	
received result 

========================= camel sample_8751 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<ConsulComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.consul.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.consul.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_944 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<DdbComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-ddb.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.aws-ddb.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1120 =========================

protected void doStart() throws Exception {	
consuming expected messages from 

EndpointHelper.pollEndpoint(expectedMessageEndpoint, new Processor() {	public void process(Exchange exchange) throws Exception {	Object body = getInBody(exchange);	if (body instanceof WrappedFile) {	body = exchange.getIn().getBody(String.class);	}	if (split) {	Iterator it = ObjectHelper.createIterator(body, delimiter, false, true);	while (it.hasNext()) {	Object line = it.next();	
received message body 

Iterator it = ObjectHelper.createIterator(body, delimiter, false, true);	while (it.hasNext()) {	Object line = it.next();	expectedBodies.add(line);	}	} else {	expectedBodies.add(body);	}	}	}, timeout);	
received expected message s from 

========================= camel sample_4772 =========================

public TrustManager[] createTrustManagers() throws GeneralSecurityException, IOException {	if (trustManager != null) {	return new TrustManager[]{trustManager};	}	
creating trustmanager from trustmanagersparameters 

String tmfAlgorithm = this.parsePropertyValue(this.getAlgorithm());	if (tmfAlgorithm == null) {	tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();	}	TrustManagerFactory tmf;	if (this.getProvider() == null) {	tmf = TrustManagerFactory.getInstance(tmfAlgorithm);	} else {	tmf = TrustManagerFactory.getInstance(tmfAlgorithm, this.parsePropertyValue(this.getProvider()));	}	
trustmanagerfactory is using provider and algorithm 

}	TrustManagerFactory tmf;	if (this.getProvider() == null) {	tmf = TrustManagerFactory.getInstance(tmfAlgorithm);	} else {	tmf = TrustManagerFactory.getInstance(tmfAlgorithm, this.parsePropertyValue(this.getProvider()));	}	KeyStore ks = this.getKeyStore() == null ? null : this.getKeyStore().createKeyStore();	tmf.init(ks);	trustManagers = tmf.getTrustManagers();	
trustmanager initialized from trustmanagerfactory 

========================= camel sample_4288 =========================

public boolean canTest() {	if (System.getProperty("java.vendor").contains("IBM")) {	return false;	}	try {	javax.security.auth.login.Configuration.getConfiguration();	} catch (Exception e) {	
cannot run test due security exception 

========================= camel sample_12174 =========================

public void testFind() throws Exception {	final CreditCardVerification result = requestBody("direct: assertNotNull("find result", result);	
find 

public void testSearch() throws Exception {	final ResourceCollection<CreditCardVerification> result = requestBody("direct: assertNotNull("search result", result);	
search 

========================= camel sample_17376 =========================

public void process(Exchange exchange) throws Exception {	String cacheKey = key.evaluate(exchange, String.class);	if (isValid(cacheManager, cacheName, cacheKey)) {	Ehcache cache = cacheManager.getCache(cacheName);	if (LOG.isDebugEnabled()) {	
replacing token in message with value stored against key in cachename 

========================= camel sample_10519 =========================

public boolean apply(UUID uuid, Object payload) {	Exchange exchange = endpoint.createExchange(ExchangePattern.InOnly);	Message in = exchange.getIn();	in.setBody(payload);	in.setHeader(IgniteConstants.IGNITE_MESSAGING_TOPIC, endpoint.getTopic());	in.setHeader(IgniteConstants.IGNITE_MESSAGING_UUID, uuid);	try {	if (LOG.isTraceEnabled()) {	
processing ignite message for subscription with payload 

Exchange exchange = endpoint.createExchange(ExchangePattern.InOnly);	Message in = exchange.getIn();	in.setBody(payload);	in.setHeader(IgniteConstants.IGNITE_MESSAGING_TOPIC, endpoint.getTopic());	in.setHeader(IgniteConstants.IGNITE_MESSAGING_UUID, uuid);	try {	if (LOG.isTraceEnabled()) {	}	getProcessor().process(exchange);	} catch (Exception e) {	
exception while processing ignite message from topic s 

protected void doStart() throws Exception {	super.doStart();	messaging.localListen(endpoint.getTopic(), predicate);	
started ignite messaging consumer for topic 

protected void doStop() throws Exception {	super.doStop();	messaging.stopLocalListen(endpoint.getTopic(), predicate);	
stopped ignite messaging consumer for topic 

========================= camel sample_11308 =========================

entry.setValue(nestedProperty);	} catch (NoSuchFieldException e) {	}	}	}	CamelPropertiesHelper.setCamelProperties(camelContext, component, parameters, false);	if (ObjectHelper.isNotEmpty(customizers)) {	for (ComponentCustomizer<SshComponent> customizer : customizers) {	boolean useCustomizer = (customizer instanceof HasId) ? HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ssh.customizer", ((HasId) customizer).getId()) : HierarchicalPropertiesEvaluator.evaluate( applicationContext.getEnvironment(), "camel.component.customizer", "camel.component.ssh.customizer");	if (useCustomizer) {	
configure component with customizer 

========================= camel sample_1209 =========================

public void someMethod() {	
invoked somemethod 

========================= camel sample_3371 =========================

public void process(Exchange exchange) throws Exception {	String remotePath = DropboxHelper.getRemotePath(configuration, exchange);	String newRemotePath = DropboxHelper.getNewRemotePath(configuration, exchange);	DropboxConfigurationValidator.validateMoveOp(remotePath, newRemotePath);	DropboxMoveResult result = new DropboxAPIFacade(configuration.getClient(), exchange) .move(remotePath, newRemotePath);	exchange.getIn().setHeader(DropboxResultHeader.MOVED_PATH.name(), result.getOldPath());	exchange.getIn().setBody(result.getNewPath());	
moved from to 

========================= camel sample_8497 =========================

