try {	id = message.getJMSMessageID();	synchronized (semaphore) {	messageIds.add(id);	semaphore.notifyAll();	}	if (countDownLatch != null) {	countDownLatch.countDown();	}	if (LOG.isDebugEnabled()) {	
received message 

public void waitForMessagesToArrive(int messageCount, long maximumDuration) {	
waiting for message s to arrive 

break;	}	long duration = System.currentTimeMillis() - start;	if (duration >= maximumDuration) {	break;	}	synchronized (semaphore) {	semaphore.wait(maximumDuration - duration);	}	} catch (InterruptedException e) {	
caught 

if (duration >= maximumDuration) {	break;	}	synchronized (semaphore) {	semaphore.wait(maximumDuration - duration);	}	} catch (InterruptedException e) {	}	}	long end = System.currentTimeMillis() - start;	
end of wait for millis and received messages 

========================= activemq sample_2631 =========================

protected void start() throws Exception {	
starting monitor 

}	connection = connectionFactory.createConnection();	Session session = connection.createSession(transacted, Session.AUTO_ACKNOWLEDGE);	if (topic) {	destination = session.createTopic(destinationName);	} else {	destination = session.createQueue(destinationName);	}	createPayload(session);	publishAndConsume();	
closing resources 

protected void publishAndConsume() throws Exception {	createConsumers();	createProducers();	int counter = 0;	boolean resetCon = false;	
start sending messages 

========================= activemq sample_1158 =========================

public static Collection<PersistenceAdapterChoice[]> getTestParameters() {	String osName = System.getProperty("os.name");	
running on 

public void testSize() throws Exception {	openConsumer();	assertEquals(0, broker.getAdminView().getStorePercentUsage());	for (int i = 0; i < 5000; i++) {	sendMessage(false);	}	final BrokerView brokerView = broker.getAdminView();	assertTrue("in range with consumer", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	broker.getSystemUsage().getStoreUsage().isFull();	
store percent usage 

assertTrue("in range with consumer", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	broker.getSystemUsage().getStoreUsage().isFull();	return broker.getAdminView().getStorePercentUsage() < minPercentUsageForStore;	}	}));	closeConsumer();	assertTrue("in range with closed consumer", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	broker.getSystemUsage().getStoreUsage().isFull();	
store precent usage 

return broker.getAdminView().getStorePercentUsage() < minPercentUsageForStore;	}	}));	for (int i = 0; i < 5000; i++) {	sendMessage(false);	}	broker.getAdminView().destroyDurableSubscriber("cliID", "subName");	assertTrue("in range after send with consumer", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	broker.getSystemUsage().getStoreUsage().isFull();	
store precent usage 

private void startBroker(boolean deleteMessages) throws Exception {	broker = new BrokerService();	broker.setAdvisorySupport(false);	broker.setBrokerName("testStoreSize");	if (deleteMessages) {	broker.setDeleteAllMessagesOnStartup(true);	}	
starting broker with persistenceadapterchoice 

========================= activemq sample_2774 =========================

private void afterRollback() throws JMSException {	if (synchronizations == null) {	return;	}	Throwable firstException = null;	int size = synchronizations.size();	for (int i = 0; i < size; i++) {	try {	synchronizations.get(i).afterRollback();	} catch (Throwable t) {	
exception from afterrollback on 

private void afterCommit() throws JMSException {	if (synchronizations == null) {	return;	}	Throwable firstException = null;	int size = synchronizations.size();	for (int i = 0; i < size; i++) {	try {	synchronizations.get(i).afterCommit();	} catch (Throwable t) {	
exception from aftercommit on 

synchronizations = null;	beforeEndIndex = 0;	setRollbackOnly(false);	this.transactionId = new LocalTransactionId(getConnectionId(), localTransactionIdGenerator.getNextSequenceId());	TransactionInfo info = new TransactionInfo(getConnectionId(), transactionId, TransactionInfo.BEGIN);	this.connection.ensureConnectionInfoSent();	this.connection.asyncSendPacket(info);	if (localTransactionEventListener != null) {	localTransactionEventListener.beginEvent();	}	
begin 

public void rollback() throws JMSException {	if (isInXATransaction()) {	throw new TransactionInProgressException("Cannot rollback() if an XA transaction is already in progress ");	}	try {	beforeEnd();	} catch (TransactionRolledBackException canOcurrOnFailover) {	
rollback processing error 

LOG.debug("Commit: {} syncCount: {}", transactionId, (synchronizations != null ? synchronizations.size() : 0));	TransactionInfo info = new TransactionInfo(getConnectionId(), transactionId, TransactionInfo.COMMIT_ONE_PHASE);	this.transactionId = null;	try {	this.connection.syncSendPacket(info);	if (localTransactionEventListener != null) {	localTransactionEventListener.commitEvent();	}	afterCommit();	} catch (JMSException cause) {	
commit failed for transaction 

public void start(Xid xid, int flags) throws XAException {	
start flags 

public void end(Xid xid, int flags) throws XAException {	
end flags 

public int prepare(Xid xid) throws XAException {	
prepare 

public int prepare(Xid xid) throws XAException {	XATransactionId x;	if (xid == null || (equals(associatedXid, xid))) {	throw new XAException(XAException.XAER_PROTO);	} else {	x = new XATransactionId(xid);	}	if (rollbackOnly) {	
prepare of failed because it was marked rollback only typically due to failover with pending acks 

try {	TransactionInfo info = new TransactionInfo(getConnectionId(), x, TransactionInfo.PREPARE);	IntegerResponse response = (IntegerResponse)this.connection.syncSendPacket(info);	if (XAResource.XA_RDONLY == response.getResult()) {	List<TransactionContext> l;	synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {	l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);	}	if (l != null) {	if(! l.isEmpty()) {	
firing aftercommit callbacks on xa rdonly from prepare 

if (l != null) {	if(! l.isEmpty()) {	for (TransactionContext ctx : l) {	ctx.afterCommit();	}	}	}	}	return response.getResult();	} catch (JMSException e) {	
prepare of failed with 

} catch (JMSException e) {	List<TransactionContext> l;	synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {	l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);	}	if (l != null) {	for (TransactionContext ctx : l) {	try {	ctx.afterRollback();	} catch (Throwable ignored) {	
failed to firing afterrollback callbacks on prepare failure txid context 

public void rollback(Xid xid) throws XAException {	if (LOG.isDebugEnabled()) {	
rollback 

public void commit(Xid xid, boolean onePhase) throws XAException {	LOG.debug("Commit: {}, onePhase={}", xid, onePhase);	XATransactionId x;	if (xid == null || (equals(associatedXid, xid))) {	throw new XAException(XAException.XAER_PROTO);	} else {	x = new XATransactionId(xid);	}	if (rollbackOnly) {	
commit of failed because it was marked rollback only typically due to failover with pending acks 

this.connection.syncSendPacket(info);	List<TransactionContext> l;	synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {	l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);	}	if (l != null) {	for (TransactionContext ctx : l) {	try {	ctx.afterCommit();	} catch (Exception ignored) {	
ignoring exception from after completion on ended transaction 

}	if (l != null) {	for (TransactionContext ctx : l) {	try {	ctx.afterCommit();	} catch (Exception ignored) {	}	}	}	} catch (JMSException e) {	
commit of failed with 

if (onePhase) {	List<TransactionContext> l;	synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {	l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);	}	if (l != null) {	for (TransactionContext ctx : l) {	try {	ctx.afterRollback();	} catch (Throwable ignored) {	
failed to firing afterrollback callbacks commit failure txid context 

public void forget(Xid xid) throws XAException {	
forget 

public Xid[] recover(int flag) throws XAException {	
recover 

} catch (JMSException e) {	disassociate();	throw toXAException(e);	}	if (xid != null) {	associatedXid = xid;	transactionId = new XATransactionId(xid);	TransactionInfo info = new TransactionInfo(getConnectionId(), transactionId, TransactionInfo.BEGIN);	try {	this.connection.asyncSendPacket(info);	
started xa transaction 

this.connection.asyncSendPacket(info);	} catch (JMSException e) {	disassociate();	throw toXAException(e);	}	} else {	if (transactionId != null) {	TransactionInfo info = new TransactionInfo(getConnectionId(), transactionId, TransactionInfo.END);	try {	this.connection.syncSendPacket(info);	
ended xa transaction 

========================= activemq sample_195 =========================

clientTransport = TransportFactory.connect(new URI(uri));	clientTransport.setTransportListener(new TransportListener() {	public void onCommand(Object command) {	if (command instanceof WireFormatInfo) {	clientWF.set((WireFormatInfo)command);	negociationCounter.countDown();	}	}	public void onException(IOException error) {	if (!ignoreAsycError.get()) {	
client transport error 

private void startServer(String uri) throws IOException, URISyntaxException, Exception {	server = TransportFactory.bind(new URI(uri));	server.setAcceptListener(new TransportAcceptListener() {	public void onAccept(Transport transport) {	try {	
server accepted a connection 

serverTransport = transport;	serverTransport.setTransportListener(new TransportListener() {	public void onCommand(Object command) {	if (command instanceof WireFormatInfo) {	serverWF.set((WireFormatInfo)command);	negociationCounter.countDown();	}	}	public void onException(IOException error) {	if (!ignoreAsycError.get()) {	
server transport error 

========================= activemq sample_2518 =========================

public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {	if (messageId != null) {	QueueViewMBean queueView = getQueueView();	if (queueView != null) {	
moving message to 

public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {	if (messageId != null) {	QueueViewMBean queueView = getQueueView();	if (queueView != null) {	queueView.moveMessageTo(messageId, destination);	} else {	
no queue named 

========================= activemq sample_1334 =========================

public void testSendAndReceive() throws Exception {	clientConnection = createConnection();	clientConnection.setClientID("ClientConnection:" + getSubject());	Session session = clientConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	clientConnection.start();	Destination replyDestination = createTemporaryDestination(session);	clientSideClientID = clientConnection.getClientID();	
both the clientid and destination clientid match properly 

clientConnection.setClientID("ClientConnection:" + getSubject());	Session session = clientConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	clientConnection.start();	Destination replyDestination = createTemporaryDestination(session);	clientSideClientID = clientConnection.getClientID();	MessageProducer requestProducer = session.createProducer(requestDestination);	MessageConsumer replyConsumer = session.createConsumer(replyDestination);	TextMessage requestMessage = session.createTextMessage("Olivier");	requestMessage.setJMSReplyTo(replyDestination);	requestProducer.send(requestMessage);	
sent request 

clientSideClientID = clientConnection.getClientID();	MessageProducer requestProducer = session.createProducer(requestDestination);	MessageConsumer replyConsumer = session.createConsumer(replyDestination);	TextMessage requestMessage = session.createTextMessage("Olivier");	requestMessage.setJMSReplyTo(replyDestination);	requestProducer.send(requestMessage);	LOG.info(requestMessage.toString());	Message msg = replyConsumer.receive(5000);	if (msg instanceof TextMessage) {	TextMessage replyMessage = (TextMessage)msg;	
received reply 

public void onMessage(Message message) {	try {	TextMessage requestMessage = (TextMessage)message;	
received request 

LOG.info(requestMessage.toString());	Destination replyDestination = requestMessage.getJMSReplyTo();	TextMessage replyMessage = serverSession.createTextMessage("Hello: " + requestMessage.getText());	replyMessage.setJMSCorrelationID(requestMessage.getJMSMessageID());	if (dynamicallyCreateProducer) {	replyProducer = serverSession.createProducer(replyDestination);	replyProducer.send(replyMessage);	} else {	replyProducer.send(replyDestination, replyMessage);	}	
sent reply 

protected void syncConsumeLoop(MessageConsumer requestConsumer) {	try {	Message message = requestConsumer.receive(5000);	if (message != null) {	onMessage(message);	} else {	
no message received 

protected void onException(JMSException e) {	
caught 

========================= activemq sample_3831 =========================

consumer = session.createConsumer(queue);	message = consumer.receive(1000);	if (message != null) message.acknowledge();	connection.close();	connection = null;	TimeUnit.SECONDS.sleep(1);	ActiveMQDestination dests[] = broker.getRegionBroker().getDestinations();	for (ActiveMQDestination destination: dests) {	String name = destination.getPhysicalName();	if (name.contains(queue.getPhysicalName())) {	
destination on broker before removing the queue 

}	dests = broker.getRegionBroker().getDestinations();	if (dests == null) {	fail("Should have Destination for: " + queue.getPhysicalName());	}	broker.getAdminView().removeQueue(queue.getPhysicalName());	dests = broker.getRegionBroker().getDestinations();	if (dests != null) {	for (ActiveMQDestination destination: dests) {	String name = destination.getPhysicalName();	
destination on broker after removing the queue 

========================= activemq sample_3562 =========================

protected void writeToXml() {	try {	xmlFile = createXmlFile();	xmlFileWriter = new PrintWriter(new FileOutputStream(xmlFile));	writeXmlHeader();	writeXmlTestSettings();	writeXmlLogFile();	writeXmlPerfSummary();	writeXmlFooter();	xmlFileWriter.close();	
created performance report 

========================= activemq sample_1226 =========================

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue("ActiveMQ.DLQ");	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	TextMessage txtMessage = session.createTextMessage();	txtMessage.setText("Test_Message");	for (int i = 0; i < MSG_COUNT; ++i) {	producer.send(txtMessage, DeliveryMode.PERSISTENT, 4, 1000l);	}	final QueueViewMBean view = getProxyToQueue("ActiveMQ.DLQ");	
waiting for expiry 

txtMessage.setText("Test_Message");	for (int i = 0; i < MSG_COUNT; ++i) {	producer.send(txtMessage, DeliveryMode.PERSISTENT, 4, 1000l);	}	final QueueViewMBean view = getProxyToQueue("ActiveMQ.DLQ");	assertTrue("Queue drained of expired", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return view.getQueueSize() == 0;	}	}));	
finished waiting for expiry 

========================= activemq sample_2959 =========================

}	}	for (CountDownLatch latch: latches) {	assertTrue("write complete", latch.await(5, TimeUnit.SECONDS));	}	boolean someExceptions = false;	for (Location location: locations) {	someExceptions |= (location.getException().get() != null);	}	assertTrue(someExceptions);	
latches count 

}	}	for (CountDownLatch latch: latches) {	assertTrue("write complete", latch.await(5, TimeUnit.SECONDS));	}	boolean someExceptions = false;	for (Location location: locations) {	someExceptions |= (location.getException().get() != null);	}	assertTrue(someExceptions);	
seeks 

========================= activemq sample_1733 =========================

public void start() throws JMSException {	synchronized (runControlMutex) {	if (runningFlag) {	
start request ignored already running 

public void start() throws JMSException {	synchronized (runControlMutex) {	if (runningFlag) {	return;	}	runningFlag = true;	}	
starting run 

public void start() throws JMSException {	synchronized (runControlMutex) {	if (runningFlag) {	return;	}	runningFlag = true;	}	try {	workManager.scheduleWork(this, WorkManager.INDEFINITE, null, new WorkListener() {	public void workAccepted(WorkEvent event) {	
work accepted 

if (runningFlag) {	return;	}	runningFlag = true;	}	try {	workManager.scheduleWork(this, WorkManager.INDEFINITE, null, new WorkListener() {	public void workAccepted(WorkEvent event) {	}	public void workRejected(WorkEvent event) {	
work rejected 

}	runningFlag = true;	}	try {	workManager.scheduleWork(this, WorkManager.INDEFINITE, null, new WorkListener() {	public void workAccepted(WorkEvent event) {	}	public void workRejected(WorkEvent event) {	}	public void workStarted(WorkEvent event) {	
work started 

}	try {	workManager.scheduleWork(this, WorkManager.INDEFINITE, null, new WorkListener() {	public void workAccepted(WorkEvent event) {	}	public void workRejected(WorkEvent event) {	}	public void workStarted(WorkEvent event) {	}	public void workCompleted(WorkEvent event) {	
work completed 

public void run() {	
Running 

public void run() {	currentBatchSize = 0;	while (true) {	
run loop start 

public void run() {	currentBatchSize = 0;	while (true) {	try {	InboundContextSupport.register(this);	if ( session.isRunning() ) {	session.run();	} else {	
jms session with unconsumed is no longer running maybe due to loss of connection marking serversession as stale 

try {	InboundContextSupport.register(this);	if ( session.isRunning() ) {	session.run();	} else {	stale = true;	}	} catch (Throwable e) {	stale = true;	if ( log.isDebugEnabled() ) {	
endpoint failed to process message 

InboundContextSupport.register(this);	if ( session.isRunning() ) {	session.run();	} else {	stale = true;	}	} catch (Throwable e) {	stale = true;	if ( log.isDebugEnabled() ) {	} else if ( log.isInfoEnabled() ) {	
endpoint failed to process message reason 

} else {	stale = true;	}	} catch (Throwable e) {	stale = true;	if ( log.isDebugEnabled() ) {	} else if ( log.isInfoEnabled() ) {	}	} finally {	InboundContextSupport.unregister(this);	
run loop end 

} finally {	InboundContextSupport.unregister(this);	synchronized (runControlMutex) {	if (stale) {	runningFlag = false;	pool.removeFromPool(this);	break;	}	if (!session.hasUncomsumedMessages()) {	runningFlag = false;	
session has no unconsumed message returning to pool 

break;	}	if (!session.hasUncomsumedMessages()) {	runningFlag = false;	pool.returnToPool(this);	break;	}	}	}	}	
run finished 

if (++currentBatchSize >= batchSize || !session.hasUncomsumedMessages()) {	currentBatchSize = 0;	try {	endpoint.afterDelivery();	} catch (Throwable e) {	throw new RuntimeException("Endpoint after delivery notification failure: " + e, e);	} finally {	TransactionContext transactionContext = session.getTransactionContext();	if (transactionContext != null && transactionContext.isInLocalTransaction()) {	if (!useRAManagedTx) {	
local transaction had not been commited commiting now 

} catch (Throwable e) {	throw new RuntimeException("Endpoint after delivery notification failure: " + e, e);	} finally {	TransactionContext transactionContext = session.getTransactionContext();	if (transactionContext != null && transactionContext.isInLocalTransaction()) {	if (!useRAManagedTx) {	}	try {	session.commit();	} catch (JMSException e) {	
commit failed 

public void release() {	
release called 

public void close() {	try {	endpoint.release();	} catch (Throwable e) {	
endpoint did not release properly 

public void close() {	try {	endpoint.release();	} catch (Throwable e) {	}	try {	session.close();	} catch (Throwable e) {	
session did not close properly 

========================= activemq sample_838 =========================

public void testReceiverCloseSendsRemoteClose() throws Exception {	AmqpClient client = createAmqpClient();	assertNotNull(client);	final AtomicBoolean closed = new AtomicBoolean();	client.setValidator(new AmqpValidator() {	public void inspectClosedResource(Session session) {	
session closed 

AmqpClient client = createAmqpClient();	assertNotNull(client);	final AtomicBoolean closed = new AtomicBoolean();	client.setValidator(new AmqpValidator() {	public void inspectClosedResource(Session session) {	}	public void inspectDetachedResource(Receiver receiver) {	markAsInvalid("Broker should not detach receiver linked to closed session.");	}	public void inspectClosedResource(Receiver receiver) {	
receiver closed 

public void testCreateQueueReceiverWithJMSSelector() throws Exception {	AmqpClient client = createAmqpClient();	client.setValidator(new AmqpValidator() {	public void inspectOpenedResource(Receiver receiver) {	
receiver opened 

public void testCreateQueueReceiverWithNoLocalSet() throws Exception {	AmqpClient client = createAmqpClient();	client.setValidator(new AmqpValidator() {	public void inspectOpenedResource(Receiver receiver) {	
receiver opened 

public void testUnsupportedFiltersAreNotListedAsSupported() throws Exception {	AmqpClient client = createAmqpClient();	client.setValidator(new AmqpValidator() {	public void inspectOpenedResource(Receiver receiver) {	
receiver opened 

========================= activemq sample_1549 =========================

public void testUseXbeanConfigFile () throws Exception {	Mockito.when(this.mockXbeanFileResolver.isXBeanFile("x-config-uri-x")).thenReturn(true);	Mockito.when(this.mockXbeanFileResolver.toUrlCompliantAbsolutePath("x-config-uri-x")) .thenReturn("x-transformed-uri-x");	this.startBrokerMojo.execute();	
configuri before transformation x config uri x 

public void testUseXbeanConfigFile () throws Exception {	Mockito.when(this.mockXbeanFileResolver.isXBeanFile("x-config-uri-x")).thenReturn(true);	Mockito.when(this.mockXbeanFileResolver.toUrlCompliantAbsolutePath("x-config-uri-x")) .thenReturn("x-transformed-uri-x");	this.startBrokerMojo.execute();	
configuri after transformation x transformed uri x 

public void testDoNotUseXbeanConfigFile () throws Exception {	Mockito.when(this.mockXbeanFileResolver.isXBeanFile("x-config-uri-x")).thenReturn(false);	this.startBrokerMojo.execute();	
configuri before transformation x config uri x 

public void testDoNotUseXbeanConfigFile () throws Exception {	Mockito.when(this.mockXbeanFileResolver.isXBeanFile("x-config-uri-x")).thenReturn(false);	this.startBrokerMojo.execute();	
configuri after transformation x transformed uri x 

public void testSkip () throws Exception {	this.startBrokerMojo.setSkip(true);	this.startBrokerMojo.execute();	
skipped execution of activemq broker 

========================= activemq sample_1230 =========================

public synchronized void dispose() {	if (!closed) {	try {	this.connection.asyncSendPacket(info.createRemoveCommand());	} catch (JMSException e) {	
failed to send remove command 

deliveredCounter = 0;	} catch (JMSException e) {	connection.onClientInternalException(e);	}	}	DataStructure o = md.getMessage().getDataStructure();	if (o != null && o.getClass() == DestinationInfo.class) {	processDestinationInfo((DestinationInfo)o);	} else {	if (LOG.isDebugEnabled()) {	
unexpected message was dispatched to the advisoryconsumer 

========================= activemq sample_32 =========================

public void testFailoverCommitReplyLost() throws Exception {	broker = createBroker(true);	setDefaultPersistenceAdapter(broker);	broker.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {	super.commitTransaction(context, xid, onePhase);	context.setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
stopping broker post commit 

configureConnectionFactory(cf);	Connection connection = cf.createConnection();	connection.start();	final Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);	Queue destination = session.createQueue(QUEUE_NAME);	MessageConsumer consumer = session.createConsumer(destination);	produceMessage(session, destination);	final CountDownLatch commitDoneLatch = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
doing async commit 

Queue destination = session.createQueue(QUEUE_NAME);	MessageConsumer consumer = session.createConsumer(destination);	produceMessage(session, destination);	final CountDownLatch commitDoneLatch = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	session.commit();	} catch (JMSException e) {	assertTrue(e instanceof TransactionRolledBackException);	
got commit exception 

produceMessage(session, destination);	final CountDownLatch commitDoneLatch = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	session.commit();	} catch (JMSException e) {	assertTrue(e instanceof TransactionRolledBackException);	}	commitDoneLatch.countDown();	
done async commit 

}	commitDoneLatch.countDown();	}	});	broker.waitUntilStopped();	broker = createBroker(false, url);	setDefaultPersistenceAdapter(broker);	broker.start();	assertTrue("tx committed through failover", commitDoneLatch.await(30, TimeUnit.SECONDS));	Message msg = consumer.receive(20000);	
received 

broker.start();	assertTrue("tx committed through failover", commitDoneLatch.await(30, TimeUnit.SECONDS));	Message msg = consumer.receive(20000);	assertNotNull("we got the message", msg);	assertNull("we got just one message", consumer.receive(2000));	session.commit();	consumer.close();	connection.close();	broker.stop();	broker.waitUntilStopped();	
checking for remaining hung messages 

broker = createBroker(false, url);	setDefaultPersistenceAdapter(broker);	broker.start();	cf = new ActiveMQConnectionFactory("failover:(" + url + ")");	configureConnectionFactory(cf);	connection = cf.createConnection();	connection.start();	Session session2 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	consumer = session2.createConsumer(destination);	msg = consumer.receive(1000);	
received 

public void testFailoverCommitReplyLostWithDestinationPathSeparator() throws Exception {	broker = createBroker(true);	setDefaultPersistenceAdapter(broker);	broker.setPlugins(new BrokerPlugin[]{	new DestinationPathSeparatorBroker(), new BrokerPluginSupport() {	public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {	super.commitTransaction(context, xid, onePhase);	context.setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
stopping broker post commit 

configureConnectionFactory(cf);	Connection connection = cf.createConnection();	connection.start();	final Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);	Queue destination = session.createQueue(QUEUE_NAME.replace('.','/') + "?consumer.prefetchSize=0");	MessageConsumer consumer = session.createConsumer(destination);	produceMessage(session, destination);	final CountDownLatch commitDoneLatch = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
doing async commit 

Queue destination = session.createQueue(QUEUE_NAME.replace('.','/') + "?consumer.prefetchSize=0");	MessageConsumer consumer = session.createConsumer(destination);	produceMessage(session, destination);	final CountDownLatch commitDoneLatch = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	session.commit();	} catch (JMSException e) {	assertTrue(e instanceof TransactionRolledBackException);	
got commit exception 

produceMessage(session, destination);	final CountDownLatch commitDoneLatch = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	session.commit();	} catch (JMSException e) {	assertTrue(e instanceof TransactionRolledBackException);	}	commitDoneLatch.countDown();	
done async commit 

commitDoneLatch.countDown();	}	});	broker.waitUntilStopped();	broker = createBroker(false, url);	setDefaultPersistenceAdapter(broker);	broker.setPlugins(new BrokerPlugin[]{new DestinationPathSeparatorBroker()});	broker.start();	assertTrue("tx committed trough failover", commitDoneLatch.await(30, TimeUnit.SECONDS));	Message msg = consumer.receive(20000);	
received 

broker.start();	assertTrue("tx committed trough failover", commitDoneLatch.await(30, TimeUnit.SECONDS));	Message msg = consumer.receive(20000);	assertNotNull("we got the message", msg);	assertNull("we got just one message", consumer.receive(2000));	session.commit();	consumer.close();	connection.close();	broker.stop();	broker.waitUntilStopped();	
checking for remaining hung messages 

setDefaultPersistenceAdapter(broker);	broker.setPlugins(new BrokerPlugin[]{new DestinationPathSeparatorBroker()});	broker.start();	cf = new ActiveMQConnectionFactory("failover:(" + url + ")");	configureConnectionFactory(cf);	connection = cf.createConnection();	connection.start();	Session session2 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	consumer = session2.createConsumer(destination);	msg = consumer.receive(1000);	
received 

configureConnectionFactory(cf);	connection = cf.createConnection();	connection.start();	Session session2 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	consumer = session2.createConsumer(destination);	msg = consumer.receive(1000);	assertNull("no messges left dangling but got: " + msg, msg);	connection.close();	ActiveMQDestination[] destinations = broker.getRegionBroker().getDestinations();	for (ActiveMQDestination dest : destinations) {	
destinations list 

public void testFailoverSendReplyLost() throws Exception {	broker = createBroker(true);	setDefaultPersistenceAdapter(broker);	broker.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	public void send(ProducerBrokerExchange producerExchange, org.apache.activemq.command.Message messageSend) throws Exception {	super.send(producerExchange, messageSend);	producerExchange.getConnectionContext().setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
stopping broker post send 

ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")?jms.watchTopicAdvisories=false");	configureConnectionFactory(cf);	Connection connection = cf.createConnection();	connection.start();	final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	final Queue destination = session.createQueue(QUEUE_NAME);	MessageConsumer consumer = session.createConsumer(destination);	final CountDownLatch sendDoneLatch = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
doing async send 

connection.start();	final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	final Queue destination = session.createQueue(QUEUE_NAME);	MessageConsumer consumer = session.createConsumer(destination);	final CountDownLatch sendDoneLatch = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	produceMessage(session, destination);	} catch (JMSException e) {	
got send exception 

MessageConsumer consumer = session.createConsumer(destination);	final CountDownLatch sendDoneLatch = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	produceMessage(session, destination);	} catch (JMSException e) {	fail("got unexpected send exception" + e);	}	sendDoneLatch.countDown();	
done async send 

produceMessage(session, destination);	} catch (JMSException e) {	fail("got unexpected send exception" + e);	}	sendDoneLatch.countDown();	}	});	broker.waitUntilStopped();	broker = createBroker(false, url);	setDefaultPersistenceAdapter(broker);	
restarting 

}	sendDoneLatch.countDown();	}	});	broker.waitUntilStopped();	broker = createBroker(false, url);	setDefaultPersistenceAdapter(broker);	broker.start();	assertTrue("message sent through failover", sendDoneLatch.await(30, TimeUnit.SECONDS));	Message msg = consumer.receive(20000);	
received 

assertTrue("message sent through failover", sendDoneLatch.await(30, TimeUnit.SECONDS));	Message msg = consumer.receive(20000);	assertNotNull("we got the message", msg);	assertNull("we got just one message", consumer.receive(2000));	consumer.close();	connection.close();	assertEquals("no newly queued messages", 0, ((RegionBroker) broker.getRegionBroker()).getDestinationStatistics().getEnqueues().getCount());	assertEquals("1 dequeue", 1, ((RegionBroker) broker.getRegionBroker()).getDestinationStatistics().getDequeues().getCount());	broker.stop();	broker.waitUntilStopped();	
checking for remaining hung messages with second restart 

broker = createBroker(false, url);	setDefaultPersistenceAdapter(broker);	broker.start();	cf = new ActiveMQConnectionFactory("failover:(" + url + ")");	configureConnectionFactory(cf);	connection = cf.createConnection();	connection.start();	Session session2 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	consumer = session2.createConsumer(destination);	msg = consumer.receive(1000);	
received 

broker.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	private boolean firstSend = true;	public void send(ProducerBrokerExchange producerExchange, org.apache.activemq.command.Message messageSend) throws Exception {	super.send(producerExchange, messageSend);	if (firstSend) {	firstSend = false;	producerExchange.getConnectionContext().setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
stopping connection post send 

ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + proxy.getUrl().toASCIIString() + ")?jms.watchTopicAdvisories=false");	configureConnectionFactory(cf);	Connection connection = cf.createConnection();	connection.start();	final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	final Queue destination = session.createQueue(QUEUE_NAME);	MessageConsumer consumer = session.createConsumer(destination);	final CountDownLatch sendDoneLatch = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
doing async send 

connection.start();	final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	final Queue destination = session.createQueue(QUEUE_NAME);	MessageConsumer consumer = session.createConsumer(destination);	final CountDownLatch sendDoneLatch = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	produceMessage(session, destination);	} catch (JMSException e) {	
got send exception 

final Queue destination = session.createQueue(QUEUE_NAME);	MessageConsumer consumer = session.createConsumer(destination);	final CountDownLatch sendDoneLatch = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	produceMessage(session, destination);	} catch (JMSException e) {	}	sendDoneLatch.countDown();	
done async send 

Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	produceMessage(session, destination);	} catch (JMSException e) {	}	sendDoneLatch.countDown();	}	});	assertTrue("proxy was closed", proxy.waitUntilClosed(30));	
restarting proxy 

produceMessage(session, destination);	} catch (JMSException e) {	}	sendDoneLatch.countDown();	}	});	assertTrue("proxy was closed", proxy.waitUntilClosed(30));	proxy.open();	assertTrue("message sent through failover", sendDoneLatch.await(30, TimeUnit.SECONDS));	Message msg = consumer.receive(20000);	
received 

proxy.open();	assertTrue("message sent through failover", sendDoneLatch.await(30, TimeUnit.SECONDS));	Message msg = consumer.receive(20000);	assertNotNull("we got the message", msg);	assertNull("we got just one message", consumer.receive(2000));	consumer.close();	connection.close();	assertEquals("one queued message", 1, ((RegionBroker) broker.getRegionBroker()).getDestinationStatistics().getEnqueues().getCount());	broker.stop();	broker.waitUntilStopped();	
checking for remaining hung messages with restart 

broker = createBroker(false, url);	setDefaultPersistenceAdapter(broker);	broker.start();	cf = new ActiveMQConnectionFactory("failover:(" + url + ")");	configureConnectionFactory(cf);	connection = cf.createConnection();	connection.start();	Session session2 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	consumer = session2.createConsumer(destination);	msg = consumer.receive(1000);	
received 

public void testFailoverConsumerAckLost() throws Exception {	for (int i = 0; i < 3; i++) {	try {	
iteration 

public void doTestFailoverConsumerAckLost(final int pauseSeconds) throws Exception {	broker = createBroker(true);	setDefaultPersistenceAdapter(broker);	broker.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	public void acknowledge( ConsumerBrokerExchange consumerExchange, final MessageAck ack) throws Exception {	consumerExchange.getConnectionContext().setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
stopping broker on ack 

final Session consumerSession2 = connection.createSession(true, Session.SESSION_TRANSACTED);	final MessageConsumer consumer1 = consumerSession1.createConsumer(destination);	final MessageConsumer consumer2 = consumerSession2.createConsumer(destination);	produceMessage(producerSession, destination);	produceMessage(producerSession, destination);	final Vector<Message> receivedMessages = new Vector<Message>();	final CountDownLatch commitDoneLatch = new CountDownLatch(1);	final AtomicBoolean gotTransactionRolledBackException = new AtomicBoolean(false);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
doing async commit after consume 

final MessageConsumer consumer2 = consumerSession2.createConsumer(destination);	produceMessage(producerSession, destination);	produceMessage(producerSession, destination);	final Vector<Message> receivedMessages = new Vector<Message>();	final CountDownLatch commitDoneLatch = new CountDownLatch(1);	final AtomicBoolean gotTransactionRolledBackException = new AtomicBoolean(false);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	Message msg = consumer1.receive(20000);	
first attempt got message 

final Vector<Message> receivedMessages = new Vector<Message>();	final CountDownLatch commitDoneLatch = new CountDownLatch(1);	final AtomicBoolean gotTransactionRolledBackException = new AtomicBoolean(false);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	Message msg = consumer1.receive(20000);	receivedMessages.add(msg);	TimeUnit.SECONDS.sleep(random.nextInt(5));	msg = consumer1.receive(5000);	
second attempt got message 

Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	Message msg = consumer1.receive(20000);	receivedMessages.add(msg);	TimeUnit.SECONDS.sleep(random.nextInt(5));	msg = consumer1.receive(5000);	if (msg != null) {	receivedMessages.add(msg);	}	
committing session messsage s 

Message msg = consumer1.receive(20000);	receivedMessages.add(msg);	TimeUnit.SECONDS.sleep(random.nextInt(5));	msg = consumer1.receive(5000);	if (msg != null) {	receivedMessages.add(msg);	}	try {	consumerSession1.commit();	} catch (TransactionRolledBackException expected) {	
got exception ex on commit 

msg = consumer1.receive(5000);	if (msg != null) {	receivedMessages.add(msg);	}	try {	consumerSession1.commit();	} catch (TransactionRolledBackException expected) {	gotTransactionRolledBackException.set(true);	}	commitDoneLatch.countDown();	
done async commit 

} catch (Exception e) {	e.printStackTrace();	}	}	});	broker.waitUntilStopped();	broker = createBroker(false, url);	setDefaultPersistenceAdapter(broker);	broker.start();	assertTrue("tx committed through failover", commitDoneLatch.await(30, TimeUnit.SECONDS));	
received message count 

}	}	});	broker.waitUntilStopped();	broker = createBroker(false, url);	setDefaultPersistenceAdapter(broker);	broker.start();	assertTrue("tx committed through failover", commitDoneLatch.await(30, TimeUnit.SECONDS));	for (int i=0; i<2; i++) {	Message msg = consumer1.receive(5000);	
post from received 

broker.waitUntilStopped();	broker = createBroker(false, url);	setDefaultPersistenceAdapter(broker);	broker.start();	assertTrue("tx committed through failover", commitDoneLatch.await(30, TimeUnit.SECONDS));	for (int i=0; i<2; i++) {	Message msg = consumer1.receive(5000);	consumerSession1.commit();	if (msg == null) {	msg = consumer2.receive(10000);	
post from received 

msg = consumer2.receive(10000);	consumerSession2.commit();	}	assertNotNull("got message [" + i + "]", msg);	}	for (Connection c : connections) {	c.close();	}	broker.stop();	broker.waitUntilStopped();	
checking for remaining hung messages 

broker = createBroker(false, url);	setDefaultPersistenceAdapter(broker);	broker.start();	cf = new ActiveMQConnectionFactory("failover:(" + url + ")");	configureConnectionFactory(cf);	connection = cf.createConnection();	connection.start();	Session sweeperSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer sweeper = sweeperSession.createConsumer(destination);	Message msg = sweeper.receive(1000);	
sweep received 

public void testPoolingNConsumesAfterReconnect() throws Exception {	broker = createBroker(true);	setDefaultPersistenceAdapter(broker);	broker.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	int count = 0;	public void removeConsumer(ConnectionContext context, final ConsumerInfo info) throws Exception {	if (count++ == 1) {	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
stopping broker on removeconsumer 

final FailoverTransport failoverTransport = ((ActiveMQConnection) connection).getTransport().narrow(FailoverTransport.class);	final TransportListener delegate = failoverTransport.getTransportListener();	failoverTransport.setTransportListener(new TransportListener() {	public void onCommand(Object command) {	delegate.onCommand(command);	}	public void onException(IOException error) {	delegate.onException(error);	}	public void transportInterupted() {	
transport interrupted HERE 

public void transportInterupted() {	for (int i = 0; i < consumerCount && !consumers.isEmpty(); i++) {	executorService.execute(new Runnable() {	public void run() {	MessageConsumer localConsumer = null;	try {	synchronized (delegate) {	localConsumer = consumers.pop();	}	localConsumer.receive(1);	
calling close 

public void run() {	MessageConsumer localConsumer = null;	try {	synchronized (delegate) {	localConsumer = consumers.pop();	}	localConsumer.receive(1);	localConsumer.close();	} catch (NoSuchElementException nse) {	} catch (Exception ignored) {	
ex on 

delegate.transportInterupted();	}	public void transportResumed() {	delegate.transportResumed();	}	});	MessageConsumer consumer = null;	synchronized (delegate) {	consumer = consumers.pop();	}	
calling close to trigger broker stop 

MessageConsumer consumer = null;	synchronized (delegate) {	consumer = consumers.pop();	}	consumer.close();	broker.waitUntilStopped();	broker = createBroker(false, url);	setDefaultPersistenceAdapter(broker);	broker.start();	consumer = consumerSession.createConsumer(destination);	
finally consuming message 

consumer.close();	broker.waitUntilStopped();	broker = createBroker(false, url);	setDefaultPersistenceAdapter(broker);	broker.start();	consumer = consumerSession.createConsumer(destination);	Message msg = null;	for (int i = 0; i < 4 && msg == null; i++) {	msg = consumer.receive(1000);	}	
post from received 

public void testWaitForMissingRedeliveries() throws Exception {	
testwaitformissingredeliveries 

}	assertNotNull("got message just produced", msg);	broker.stop();	broker = createBroker(false, url);	setPersistenceAdapter(broker, PersistenceAdapterChoice.JDBC);	broker.start();	final CountDownLatch commitDone = new CountDownLatch(1);	final CountDownLatch gotException = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
doing async commit 

public void testReDeliveryWhilePending() throws Exception {	
testredeliverywhilepending 

assertNotNull("got message just produced", msg);	MessageConsumer consumer2 = secondConsumerSession.createConsumer(consumerSession.createQueue(QUEUE_NAME + "?consumer.prefetchSize=1"));	broker.stop();	broker = createBroker(false, url);	broker.start();	final CountDownLatch commitDone = new CountDownLatch(1);	final CountDownLatch gotRollback = new CountDownLatch(1);	final Vector<Exception> exceptions = new Vector<Exception>();	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
doing async commit 

========================= activemq sample_2559 =========================

protected void setParent(CountStatisticImpl child, CountStatisticImpl parent) {	if (child instanceof CountStatisticImpl && parent instanceof CountStatisticImpl) {	CountStatisticImpl c = (CountStatisticImpl)child;	c.setParent((CountStatisticImpl)parent);	} else {	
cannot associate endpoint counters with session level counters as they are not both countstatisticimpl clases endpoint session 

protected void setParent(TimeStatisticImpl child, TimeStatisticImpl parent) {	if (child instanceof TimeStatisticImpl && parent instanceof TimeStatisticImpl) {	TimeStatisticImpl c = (TimeStatisticImpl)child;	c.setParent((TimeStatisticImpl)parent);	} else {	
cannot associate endpoint counters with session level counters as they are not both timestatisticimpl clases endpoint session 

========================= activemq sample_212 =========================

try {	final Connection connection = factory.createConnection();	connection.start();	final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	for (int j = 0; j< jobs*10; j++) {	final MessageProducer producer = session.createProducer(new ActiveMQQueue("Q." + (j%destinationCount)));	producer.send(session.createMessage());	}	connection.close();	allDone.countDown();	
producers done 

final Connection connection = factory.createConnection();	connection.start();	final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	for (int j = 0; j< jobs*10; j++) {	final MessageProducer producer = session.createProducer(new ActiveMQQueue("Q." + (j%destinationCount)));	producer.send(session.createMessage());	}	connection.close();	allDone.countDown();	} catch (Exception ignored) {	
unexpected 

try {	final Connection connection = factory.createConnection();	connection.start();	final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	for (int j = 0; j < jobs; j++) {	final MessageConsumer consumer = session.createConsumer(new ActiveMQQueue("Q.>"));	consumer.receiveNoWait();	}	connection.close();	allDone.countDown();	
consumers done 

final Connection connection = factory.createConnection();	connection.start();	final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	for (int j = 0; j < jobs; j++) {	final MessageConsumer consumer = session.createConsumer(new ActiveMQQueue("Q.>"));	consumer.receiveNoWait();	}	connection.close();	allDone.countDown();	} catch (Exception ignored) {	
unexpected 

}	connection.close();	allDone.countDown();	} catch (Exception ignored) {	exceptions.add(ignored);	}	}	});	}	}	
waiting for completion 

}	}	});	}	}	executor.shutdown();	boolean success = allDone.await(30, TimeUnit.SECONDS);	if (!success) {	dumpAllThreads("hung");	ThreadMXBean bean = ManagementFactory.getThreadMXBean();	
supports dead lock detection 

========================= activemq sample_3718 =========================

public void start() throws Exception {	super.start();	
starting camelroutesbroker 

public void start() throws Exception {	super.start();	camelContext = new DefaultCamelContext();	camelContext.setName("EmbeddedCamel-" + getBrokerName());	camelContext.start();	getBrokerService().getScheduler().executePeriodically(new Runnable() {	public void run() {	try {	loadCamelRoutes();	} catch (Throwable e) {	
failed to load camel routes 

========================= activemq sample_1375 =========================

public void start() throws Exception {	if (started.compareAndSet(false, true)) {	populateMBeanSuppressionMap();	if (connectorHost == null) {	connectorHost = "localhost";	}	getMBeanServer();	if (connectorServer != null) {	try {	if (getMBeanServer().isRegistered(namingServiceObjectName)) {	
invoking start on mbean 

if (connectorHost == null) {	connectorHost = "localhost";	}	getMBeanServer();	if (connectorServer != null) {	try {	if (getMBeanServer().isRegistered(namingServiceObjectName)) {	getMBeanServer().invoke(namingServiceObjectName, "start", null, null);	}	} catch (Throwable ignore) {	
error invoking start on mbean this exception is ignored 

} catch (Throwable ignore) {	}	Thread t = new Thread("JMX connector") {	public void run() {	if (brokerName != null) {	MDC.put("activemq.broker", brokerName);	}	try {	JMXConnectorServer server = connectorServer;	if (started.get() && server != null) {	
starting jmxconnectorserver 

if (started.get() && server != null) {	try {	MDC.remove("activemq.broker");	server.start();	} finally {	if (brokerName != null) {	MDC.put("activemq.broker", brokerName);	}	connectorStarted.countDown();	}	
jmx consoles can connect to 

MDC.remove("activemq.broker");	server.start();	} finally {	if (brokerName != null) {	MDC.put("activemq.broker", brokerName);	}	connectorStarted.countDown();	}	}	} catch (IOException e) {	
failed to start jmx connector will restart management to re create jmx connector trying to remedy this issue 

MDC.remove("activemq.broker");	server.start();	} finally {	if (brokerName != null) {	MDC.put("activemq.broker", brokerName);	}	connectorStarted.countDown();	}	}	} catch (IOException e) {	
reason for failed jmx connector start 

public void stop() throws Exception {	if (started.compareAndSet(true, false)) {	MBeanServer mbeanServer = getMBeanServer();	if (mbeanServer != null) {	for (Map.Entry<ObjectName, ObjectName> entry : registeredMBeanNames.entrySet()) {	ObjectName actualName = entry.getValue();	if (actualName != null && beanServer.isRegistered(actualName)) {	
unregistering mbean 

mbeanServer.unregisterMBean(actualName);	}	}	}	registeredMBeanNames.clear();	JMXConnectorServer server = connectorServer;	connectorServer = null;	if (server != null) {	try {	if (connectorStarted.await(10, TimeUnit.SECONDS)) {	
stopping jmx connector 

}	registeredMBeanNames.clear();	JMXConnectorServer server = connectorServer;	connectorServer = null;	if (server != null) {	try {	if (connectorStarted.await(10, TimeUnit.SECONDS)) {	server.stop();	}	} catch (IOException e) {	
failed to stop jmx connector 

connectorServer = null;	if (server != null) {	try {	if (connectorStarted.await(10, TimeUnit.SECONDS)) {	server.stop();	}	} catch (IOException e) {	}	try {	if (namingServiceObjectName != null && getMBeanServer().isRegistered(namingServiceObjectName)) {	
stopping mbean 

if (server != null) {	try {	if (connectorStarted.await(10, TimeUnit.SECONDS)) {	server.stop();	}	} catch (IOException e) {	}	try {	if (namingServiceObjectName != null && getMBeanServer().isRegistered(namingServiceObjectName)) {	getMBeanServer().invoke(namingServiceObjectName, "stop", null, null);	
unregistering mbean 

server.stop();	}	} catch (IOException e) {	}	try {	if (namingServiceObjectName != null && getMBeanServer().isRegistered(namingServiceObjectName)) {	getMBeanServer().invoke(namingServiceObjectName, "stop", null, null);	getMBeanServer().unregisterMBean(namingServiceObjectName);	}	} catch (Throwable ignore) {	
error stopping and unregsitering mbean due to 

getMBeanServer().invoke(namingServiceObjectName, "stop", null, null);	getMBeanServer().unregisterMBean(namingServiceObjectName);	}	} catch (Throwable ignore) {	}	namingServiceObjectName = null;	}	if (locallyCreateMBeanServer && beanServer != null) {	List<MBeanServer> list = MBeanServerFactory.findMBeanServer(null);	if (list != null && !list.isEmpty() && list.contains(beanServer)) {	
releasing mbeanserver 

List<MBeanServer> list = MBeanServerFactory.findMBeanServer(null);	if (list != null && !list.isEmpty() && list.contains(beanServer)) {	MBeanServerFactory.releaseMBeanServer(beanServer);	}	}	beanServer = null;	}	if (registry != null) {	try {	UnicastRemoteObject.unexportObject(registry, true);	
unexported jmx rmi registry 

if (list != null && !list.isEmpty() && list.contains(beanServer)) {	MBeanServerFactory.releaseMBeanServer(beanServer);	}	}	beanServer = null;	}	if (registry != null) {	try {	UnicastRemoteObject.unexportObject(registry, true);	} catch (NoSuchObjectException e) {	
error occurred while unexporting jmx rmi registry this exception will be ignored 

public ObjectName createCustomComponentMBeanName(String type, String name) {	ObjectName result = null;	String tmp = jmxDomainName + ":" + "type=" + sanitizeString(type) + ",name=" + sanitizeString(name);	try {	result = new ObjectName(tmp);	} catch (MalformedObjectNameException e) {	
couldn t create objectname from 

public void unregisterMBean(ObjectName name) throws JMException {	ObjectName actualName = this.registeredMBeanNames.get(name);	if (beanServer != null && actualName != null && beanServer.isRegistered(actualName) && this.registeredMBeanNames.remove(name) != null) {	
unregistering mbean 

List<MBeanServer> list = MBeanServerFactory.findMBeanServer(null);	if (list != null && list.size() > 0) {	result = list.get(0);	}	}	}	if (result == null && createMBeanServer) {	result = createMBeanServer();	}	} catch (NoClassDefFoundError e) {	
could not load mbeanserver 

if (list != null && list.size() > 0) {	result = list.get(0);	}	}	}	if (result == null && createMBeanServer) {	result = createMBeanServer();	}	} catch (NoClassDefFoundError e) {	} catch (Throwable e) {	
failed to initialize mbeanserver 

try {	Method method = type.getMethod("getPlatformMBeanServer", new Class[0]);	if (method != null) {	Object answer = method.invoke(null, new Object[0]);	if (answer instanceof MBeanServer) {	if (createConnector) {	createConnector((MBeanServer)answer);	}	return (MBeanServer)answer;	} else {	
could not cast into an mbeanserver there must be some classloader strangeness in town 

if (method != null) {	Object answer = method.invoke(null, new Object[0]);	if (answer instanceof MBeanServer) {	if (createConnector) {	createConnector((MBeanServer)answer);	}	return (MBeanServer)answer;	} else {	}	} else {	
method getplatformmbeanserver does not appear visible on type 

if (answer instanceof MBeanServer) {	if (createConnector) {	createConnector((MBeanServer)answer);	}	return (MBeanServer)answer;	} else {	}	} else {	}	} catch (Exception e) {	
failed to call getplatformmbeanserver due to 

createConnector((MBeanServer)answer);	}	return (MBeanServer)answer;	} else {	}	} else {	}	} catch (Exception e) {	}	} else {	
class not found so probably running on java 

private void createConnector(MBeanServer mbeanServer) throws MalformedObjectNameException, IOException {	try {	if (registry == null) {	
creating rmiregistry on port 

try {	if (registry == null) {	registry = LocateRegistry.createRegistry(connectorPort);	}	namingServiceObjectName = ObjectName.getInstance("naming:type=rmiregistry");	Class<?> cl = Class.forName("mx4j.tools.naming.NamingService");	mbeanServer.registerMBean(cl.newInstance(), namingServiceObjectName);	Attribute attr = new Attribute("Port", Integer.valueOf(connectorPort));	mbeanServer.setAttribute(namingServiceObjectName, attr);	} catch(ClassNotFoundException e) {	
probably not using jre 

if (registry == null) {	registry = LocateRegistry.createRegistry(connectorPort);	}	namingServiceObjectName = ObjectName.getInstance("naming:type=rmiregistry");	Class<?> cl = Class.forName("mx4j.tools.naming.NamingService");	mbeanServer.registerMBean(cl.newInstance(), namingServiceObjectName);	Attribute attr = new Attribute("Port", Integer.valueOf(connectorPort));	mbeanServer.setAttribute(namingServiceObjectName, attr);	} catch(ClassNotFoundException e) {	} catch (Throwable e) {	
failed to create local registry this exception will be ignored 

mbeanServer.setAttribute(namingServiceObjectName, attr);	} catch(ClassNotFoundException e) {	} catch (Throwable e) {	}	String rmiServer = "";	if (rmiServerPort != 0) {	rmiServer = ""+getConnectorHost()+":" + rmiServerPort;	}	String serviceURL = "service:jmx:rmi: JMXServiceURL url = new JMXServiceURL(serviceURL);	connectorServer = JMXConnectorServerFactory.newJMXConnectorServer(url, environment, mbeanServer);	
created jmxconnectorserver 

========================= activemq sample_3935 =========================

public void testGetExecutionCount() throws Exception {	final String jobId = "Job-1";	long time = 10000;	final CountDownLatch done = new CountDownLatch(10);	String str = new String("test");	scheduler.schedule(jobId, new ByteSequence(str.getBytes()), "", time, 1000, 10);	int size = scheduler.getAllJobs().size();	assertEquals(size, 1);	scheduler.addListener(new JobListener() {	public void scheduledJob(String id, ByteSequence job) {	
job exectued 

========================= activemq sample_2332 =========================

int redeliveryCount = messageReference.getRedeliveryCounter();	if (RedeliveryPolicy.NO_MAXIMUM_REDELIVERIES == maximumRedeliveries || redeliveryCount < maximumRedeliveries) {	long delay = redeliveryPolicy.getInitialRedeliveryDelay();	for (int i = 0; i < redeliveryCount; i++) {	delay = redeliveryPolicy.getNextRedeliveryDelay(delay);	}	scheduleRedelivery(context, messageReference, delay, ++redeliveryCount);	} else if (isSendToDlqIfMaxRetriesExceeded()) {	return super.sendToDeadLetterQueue(context, messageReference, subscription, poisonCause);	} else {	
discarding message that exceeds max redelivery count 

delay = redeliveryPolicy.getNextRedeliveryDelay(delay);	}	scheduleRedelivery(context, messageReference, delay, ++redeliveryCount);	} else if (isSendToDlqIfMaxRetriesExceeded()) {	return super.sendToDeadLetterQueue(context, messageReference, subscription, poisonCause);	} else {	}	} else if (isFallbackToDeadLetter()) {	return super.sendToDeadLetterQueue(context, messageReference, subscription, poisonCause);	} else {	
ignoring dlq request for redeliverypolicy not found and no fallback for 

private void scheduleRedelivery(ConnectionContext context, MessageReference messageReference, long delay, int redeliveryCount) throws Exception {	if (LOG.isTraceEnabled()) {	Destination regionDestination = (Destination) messageReference.getRegionDestination();	
redelivery of with delay dest 

========================= activemq sample_3870 =========================

private void deleteTheIndex(LevelDBStore store) throws IOException {	for (String index : store.getLogDirectory().list(new FilenameFilter() {	public boolean accept(File dir, String name) {	
dir name 

private void deleteTheIndex(LevelDBStore store) throws IOException {	for (String index : store.getLogDirectory().list(new FilenameFilter() {	public boolean accept(File dir, String name) {	return (name != null && name.endsWith(".index"));	}	})) {	File file = new File(store.getLogDirectory().getAbsoluteFile(), index);	
deleting index directory 

public boolean accept(File dir, String name) {	
dir name 

========================= activemq sample_1267 =========================

final Connection producerConnection = factory.createConnection();	producerConnection.start();	final int fillWithBigCount = 10;	Session session = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(null);	producer.setDeliveryMode(deliveryMode);	for (int idx = 0; idx < fillWithBigCount; ++idx) {	Message message = session.createTextMessage(new String(bigBuf) + idx);	producer.send(bigDestination, message);	messagesSent.incrementAndGet();	
after big system memory usage 

Thread producingThread = new Thread("Producing thread") {	public void run() {	try {	Session session = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(deliveryMode);	for (int idx = 0; idx < toSend; ++idx) {	Message message = session.createTextMessage(new String(buf) + idx);	producer.send(destination, message);	messagesSent.incrementAndGet();	
after little system memory usage 

Thread producingThreadTwo = new Thread("Producing thread") {	public void run() {	try {	Session session = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(deliveryMode);	for (int idx = 0; idx < toSend; ++idx) {	Message message = session.createTextMessage(new String(buf) + idx);	producer.send(destination, message);	messagesSent.incrementAndGet();	
after little system memory usage 

messagesSent.incrementAndGet();	}	} catch (Throwable ex) {	ex.printStackTrace();	}	}	};	producingThreadTwo.start();	assertTrue("producer has sent x in a reasonable time", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
checking for x sent system memory usage sent 

ex.printStackTrace();	}	}	};	producingThreadTwo.start();	assertTrue("producer has sent x in a reasonable time", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return messagesSent.get() > 20;	}	}));	
consuming from big q to allow delivery to smaller q from pending 

producingThreadTwo.start();	assertTrue("producer has sent x in a reasonable time", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return messagesSent.get() > 20;	}	}));	int count = 0;	Message m = null;	for (;count < 10; count++) {	assertTrue((m = consumer.receive(messageReceiveTimeout)) != null);	
recieved message system memory usage 

assertTrue((m = consumer.receive(messageReceiveTimeout)) != null);	messagesConsumed.incrementAndGet();	}	consumer.close();	producingThread.join();	producingThreadTwo.join();	assertEquals("Incorrect number of Messages Sent: " + messagesSent.get(), messagesSent.get(), fillWithBigCount +  toSend*2);	consumer = consumerSession.createConsumer(destination);	for (count = 0;count < toSend*2; count++) {	assertTrue((m = consumer.receive(messageReceiveTimeout)) != null);	
recieved message system memory usage 

public void uncaughtException(Thread t, Throwable e) {	
unexpected unhandeled ex on 

========================= activemq sample_2918 =========================

public void recoverResource() {	try {	if (!Recovery.recover(this)) {	
resource manager is unrecoverable 

public void recoverResource() {	try {	if (!Recovery.recover(this)) {	}	} catch (NoClassDefFoundError e) {	
resource manager is unrecoverable due to missing classes 

public void recoverResource() {	try {	if (!Recovery.recover(this)) {	}	} catch (NoClassDefFoundError e) {	} catch (Throwable e) {	
error while recovering resource manager 

public NamedXAResource getNamedXAResource() throws SystemException {	try {	final XAConnection xaConnection;	if (rm.getUserName() != null && rm.getPassword() != null) {	xaConnection = connFactory.createXAConnection(rm.getUserName(), rm.getPassword());	} else {	xaConnection = connFactory.createXAConnection();	}	final XASession session = xaConnection.createXASession();	xaConnection.start();	
new namedxaresource s connection 

} catch (Exception e) {	SystemException se =  new SystemException("Failed to create ConnectionAndWrapperNamedXAResource, " + e.getLocalizedMessage());	se.initCause(e);	LOGGER.error(se.getLocalizedMessage(), se);	throw se;	}	}	public void returnNamedXAResource(NamedXAResource namedXaResource) {	if (namedXaResource instanceof ConnectionAndWrapperNamedXAResource) {	try {	
closing returned namedxaresource s connection 

se.initCause(e);	LOGGER.error(se.getLocalizedMessage(), se);	throw se;	}	}	public void returnNamedXAResource(NamedXAResource namedXaResource) {	if (namedXaResource instanceof ConnectionAndWrapperNamedXAResource) {	try {	((ConnectionAndWrapperNamedXAResource)namedXaResource).connection.close();	} catch (Exception ignored) {	
failed to close returned namedxaresource 

========================= activemq sample_1322 =========================

}	} else {	KahaTransactionInfo info = getTransactionInfo(txid);	if (preCommit != null) {	preCommit.run();	}	theStore.store(new KahaCommitCommand().setTransactionInfo(info), theStore.isEnableJournalDiskSyncs(), null, postCommit);	forgetRecoveredAcks(txid, false);	}	}else {	
null transaction passed on commit 

========================= activemq sample_1772 =========================

producerExchange.setProducerState(producerState);	producerExchange.setConnectionContext(contextNotInTx);	for (int i = 0; i < count; i++) {	Message message = getMessage(i);	queue.send(producerExchange, message);	}	usage.setFull(false);	try {	queue.wakeup();	} catch(Exception e) {	
queue threw an unexpected exception 

========================= activemq sample_2349 =========================

public void testReconnectMultipleTimesWithSameClientID() throws Exception {	org.apache.log4j.Logger log4jLogger = org.apache.log4j.Logger.getLogger(org.apache.activemq.broker.jmx.ManagedTransportConnection.class);	final AtomicBoolean failed = new AtomicBoolean(false);	Appender appender = new DefaultTestAppender() {	public void doAppend(LoggingEvent event) {	if (event.getMessage().toString().startsWith("Failed to register MBean")) {	
received unexpected log message 

log4jLogger.addAppender(appender);	try {	connection = connectionFactory.createConnection();	useConnection(connection);	for (int i = 1; i < 11; i++) {	Connection connection2 = connectionFactory.createConnection();	try {	useConnection(connection2);	fail("Should have thrown InvalidClientIDException on attempt" + i);	} catch (InvalidClientIDException e) {	
caught expected 

========================= activemq sample_3558 =========================

public void testUnsettledSender() throws Exception {	final int MSG_COUNT = 1000;	final CountDownLatch settled = new CountDownLatch(MSG_COUNT);	AmqpClient client = createAmqpClient();	AmqpConnection connection = trackConnection(client.connect());	connection.setStateInspector(new AmqpValidator() {	public void inspectDeliveryUpdate(Sender sender, Delivery delivery) {	if (delivery.remotelySettled()) {	
remote settled message for sender 

settled.countDown();	}	}	});	AmqpSession session = connection.createSession();	AmqpSender sender = session.createSender("topic: for (int i = 1; i <= MSG_COUNT; ++i) {	AmqpMessage message = new AmqpMessage();	message.setText("Test-Message: " + i);	sender.send(message);	if (i % 1000 == 0) {	
sent message 

public void testPresettledSender() throws Exception {	final int MSG_COUNT = 1000;	AmqpClient client = createAmqpClient();	AmqpConnection connection = trackConnection(client.connect());	AmqpSession session = connection.createSession();	AmqpSender sender = session.createSender("topic: for (int i = 1; i <= MSG_COUNT; ++i) {	AmqpMessage message = new AmqpMessage();	message.setText("Test-Message: " + i);	sender.send(message);	if (i % 1000 == 0) {	
sent message 

========================= activemq sample_1565 =========================

public void init(Map options) {	debug = booleanOption("debug", options);	if (debug) {	
initialized debug 

========================= activemq sample_814 =========================

MessageProducer producer = session.createProducer(theQueue);	MessageConsumer consumer = session.createConsumer(theQueue);	Message message = session.createTextMessage("Test message");	producer.send(message);	Message msg = consumer.receive(4000);	assertNotNull(msg);	bs2 = createBroker("bs2", secondTcpUri);	NetworkConnector networkConnector = bs2.addNetworkConnector("static:(" + firstTcpUri + ")");	networkConnector.setDuplex(true);	bs2.start();	
started brokerservice 

Message message = session.createTextMessage("Test message");	producer.send(message);	Message msg = consumer.receive(4000);	assertNotNull(msg);	bs2 = createBroker("bs2", secondTcpUri);	NetworkConnector networkConnector = bs2.addNetworkConnector("static:(" + firstTcpUri + ")");	networkConnector.setDuplex(true);	bs2.start();	bs2.waitUntilStarted();	TimeUnit.SECONDS.sleep(4);	
stopping brokerservice 

========================= activemq sample_2575 =========================

Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Queue queue = session.createQueue(queueName);	MessageProducer prod = session.createProducer(queue);	for (int i=0; i<10; i++) {	for(String group : groupNames) {	Message message = generateMessage(session, group, i+1);	prod.send(message);	session.commit();	messagesSent++;	}	
sent message seq 

for(String group : groupNames) {	Message message = generateMessage(session, group, i+1);	prod.send(message);	session.commit();	messagesSent++;	}	if (i==0) {	latchMessagesCreated.countDown();	}	if (i==2) {	
prod waiting for groups 

messagesSent++;	}	if (i==0) {	latchMessagesCreated.countDown();	}	if (i==2) {	latchGroupsAcquired.await();	}	Thread.sleep(20);	}	
messages sent 

latchMessagesCreated.countDown();	}	if (i==2) {	latchGroupsAcquired.await();	}	Thread.sleep(20);	}	prod.close();	session.close();	} catch (Exception e) {	
producer failed 

final Thread consumerThread1 = new Thread() {	public void run() {	try {	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Queue queue = session.createQueue(queueName);	MessageConsumer con1 = session.createConsumer(queue);	latchMessagesCreated.await();	while(true) {	Message message = con1.receive(1000);	if (message == null)  break;	
got message 

Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Queue queue = session.createQueue(queueName);	MessageConsumer con1 = session.createConsumer(queue);	latchMessagesCreated.await();	while(true) {	Message message = con1.receive(1000);	if (message == null)  break;	session.commit();	messagesRecvd1++;	if (messagesRecvd1 == groupNames.length) {	
all groups acquired 

Message message = con1.receive(1000);	if (message == null)  break;	session.commit();	messagesRecvd1++;	if (messagesRecvd1 == groupNames.length) {	latchGroupsAcquired.countDown();	Thread.sleep(1000);	}	Thread.sleep(50);	}	
messages received by 

messagesRecvd1++;	if (messagesRecvd1 == groupNames.length) {	latchGroupsAcquired.countDown();	Thread.sleep(1000);	}	Thread.sleep(50);	}	con1.close();	session.close();	} catch (Exception e) {	
consumer failed 

session.close();	} catch (Exception e) {	}	}	};	final Thread consumerThread2 = new Thread() {	public void run() {	try {	latchGroupsAcquired.await();	while(consumerThread1.isAlive()) {	
re starting 

public void run() {	try {	latchGroupsAcquired.await();	while(consumerThread1.isAlive()) {	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Queue queue = session.createQueue(queueName);	MessageConsumer con2 = session.createConsumer(queue);	while(true) {	Message message = con2.receive(500);	if (message == null) break;	
got message 

while(true) {	Message message = con2.receive(500);	if (message == null) break;	session.commit();	messagesRecvd2++;	Thread.sleep(50);	}	con2.close();	session.close();	}	
messages received by 

Message message = con2.receive(500);	if (message == null) break;	session.commit();	messagesRecvd2++;	Thread.sleep(50);	}	con2.close();	session.close();	}	} catch (Exception e) {	
consumer failed 

========================= activemq sample_3671 =========================

public X509Certificate[] getPeerCertificates() {	X509Certificate[] peerCerts = null;	if (next instanceof SslTransport) {	peerCerts = ((SslTransport) next).getPeerCertificates();	}	if (next instanceof  NIOSSLTransport) {	peerCerts = ((NIOSSLTransport)next).getPeerCertificates();	}	if (trace && peerCerts != null) {	
peer identity has been verified 

========================= activemq sample_906 =========================

protected void doStop(ServiceStopper stopper) {	super.doStop(stopper);	for (Iterator<ObjectName> iter = registeredMBeans.iterator(); iter.hasNext();) {	ObjectName name = iter.next();	try {	managementContext.unregisterMBean(name);	} catch (InstanceNotFoundException e) {	
the mbean is no longer registered with jmx 

public void register(ActiveMQDestination destName, Destination destination) {	try {	ObjectName objectName = BrokerMBeanSupport.createDestinationName(brokerObjectName, destName);	DestinationView view;	if (destination instanceof Queue) {	view = new QueueView(this, (Queue)destination);	} else if (destination instanceof Topic) {	view = new TopicView(this, (Topic)destination);	} else {	view = null;	
jmx view is not supported for custom destination 

view = new QueueView(this, (Queue)destination);	} else if (destination instanceof Topic) {	view = new TopicView(this, (Topic)destination);	} else {	view = null;	}	if (view != null) {	registerDestination(objectName, destName, view);	}	} catch (Exception e) {	
failed to register destination 

public void unregister(ActiveMQDestination destName) {	try {	ObjectName objectName = BrokerMBeanSupport.createDestinationName(brokerObjectName, destName);	unregisterDestination(objectName);	} catch (Exception e) {	
failed to unregister 

view = new TopicSubscriptionView(context.getClientId(), userName, (TopicSubscription) sub);	} else {	view = new SubscriptionView(context.getClientId(), userName, sub);	}	}	registerSubscription(objectName, sub.getConsumerInfo(), key, view);	}	subscriptionMap.put(sub, objectName);	return objectName;	} catch (Exception e) {	
failed to register subscription 

ObjectName name = subscriptionMap.remove(sub);	if (name != null) {	try {	SubscriptionKey subscriptionKey = new SubscriptionKey(sub.getContext().getClientId(), sub.getConsumerInfo().getSubscriptionName());	ObjectName inactiveName = subscriptionKeys.remove(subscriptionKey);	if (inactiveName != null) {	inactiveDurableTopicSubscribers.remove(inactiveName);	managementContext.unregisterMBean(inactiveName);	}	} catch (Exception e) {	
failed to unregister subscription 

if (dest.isTemporary()) {	temporaryTopics.put(key, view);	} else {	topics.put(key, view);	}	}	try {	AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, key);	registeredMBeans.add(key);	} catch (Throwable e) {	
failed to register mbean 

if (dest.isTemporary()) {	temporaryTopics.put(key, view);	} else {	topics.put(key, view);	}	}	try {	AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, key);	registeredMBeans.add(key);	} catch (Throwable e) {	
failure reason 

protected void unregisterDestination(ObjectName key) throws Exception {	DestinationView view = removeAndRemember(topics, key, null);	view = removeAndRemember(queues, key, view);	view = removeAndRemember(temporaryQueues, key, view);	view = removeAndRemember(temporaryTopics, key, view);	if (registeredMBeans.remove(key)) {	try {	managementContext.unregisterMBean(key);	} catch (Throwable e) {	
failed to unregister mbean 

protected void unregisterDestination(ObjectName key) throws Exception {	DestinationView view = removeAndRemember(topics, key, null);	view = removeAndRemember(queues, key, view);	view = removeAndRemember(temporaryQueues, key, view);	view = removeAndRemember(temporaryTopics, key, view);	if (registeredMBeans.remove(key)) {	try {	managementContext.unregisterMBean(key);	} catch (Throwable e) {	
failure reason 

managementContext.unregisterMBean(key);	} catch (Throwable e) {	}	}	if (view != null) {	key = view.getSlowConsumerStrategy();	if (key!= null && registeredMBeans.remove(key)) {	try {	managementContext.unregisterMBean(key);	} catch (Throwable e) {	
failed to unregister slow consumer strategy mbean 

managementContext.unregisterMBean(key);	} catch (Throwable e) {	}	}	if (view != null) {	key = view.getSlowConsumerStrategy();	if (key!= null && registeredMBeans.remove(key)) {	try {	managementContext.unregisterMBean(key);	} catch (Throwable e) {	
failure reason 

topicProducers.put(key, view);	}	}	} else {	dynamicDestinationProducers.put(key, view);	}	try {	AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, key);	registeredMBeans.add(key);	} catch (Throwable e) {	
failed to register mbean 

topicProducers.put(key, view);	}	}	} else {	dynamicDestinationProducers.put(key, view);	}	try {	AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, key);	registeredMBeans.add(key);	} catch (Throwable e) {	
failure reason 

protected void unregisterProducer(ObjectName key) throws Exception {	queueProducers.remove(key);	topicProducers.remove(key);	temporaryQueueProducers.remove(key);	temporaryTopicProducers.remove(key);	dynamicDestinationProducers.remove(key);	if (registeredMBeans.remove(key)) {	try {	managementContext.unregisterMBean(key);	} catch (Throwable e) {	
failed to unregister mbean 

protected void unregisterProducer(ObjectName key) throws Exception {	queueProducers.remove(key);	topicProducers.remove(key);	temporaryQueueProducers.remove(key);	temporaryTopicProducers.remove(key);	dynamicDestinationProducers.remove(key);	if (registeredMBeans.remove(key)) {	try {	managementContext.unregisterMBean(key);	} catch (Throwable e) {	
failure reason 

if (info.isDurable()) {	durableTopicSubscribers.put(key, view);	try {	ObjectName inactiveName = subscriptionKeys.get(subscriptionKey);	if (inactiveName != null) {	inactiveDurableTopicSubscribers.remove(inactiveName);	registeredMBeans.remove(inactiveName);	managementContext.unregisterMBean(inactiveName);	}	} catch (Throwable e) {	
unable to unregister inactive durable subscriber 

}	} else {	topicSubscribers.put(key, view);	}	}	}	try {	AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, key);	registeredMBeans.add(key);	} catch (Throwable e) {	
failed to register mbean 

}	} else {	topicSubscribers.put(key, view);	}	}	}	try {	AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, key);	registeredMBeans.add(key);	} catch (Throwable e) {	
failure reason 

protected void unregisterSubscription(ObjectName key, boolean addToInactive) throws Exception {	queueSubscribers.remove(key);	topicSubscribers.remove(key);	temporaryQueueSubscribers.remove(key);	temporaryTopicSubscribers.remove(key);	if (registeredMBeans.remove(key)) {	try {	managementContext.unregisterMBean(key);	} catch (Throwable e) {	
failed to unregister mbean 

protected void unregisterSubscription(ObjectName key, boolean addToInactive) throws Exception {	queueSubscribers.remove(key);	topicSubscribers.remove(key);	temporaryQueueSubscribers.remove(key);	temporaryTopicSubscribers.remove(key);	if (registeredMBeans.remove(key)) {	try {	managementContext.unregisterMBean(key);	} catch (Throwable e) {	
failure reason 

Set<ActiveMQDestination> destinations = destinationFactory.getDestinations();	if (destinations != null) {	for (ActiveMQDestination dest : destinations) {	if (dest.isTopic()) {	SubscriptionInfo[] infos = destinationFactory.getAllDurableSubscriptions((ActiveMQTopic)dest);	if (infos != null) {	for (int i = 0; i < infos.length; i++) {	SubscriptionInfo info = infos[i];	SubscriptionKey key = new SubscriptionKey(info);	if (!alreadyKnown(key)) {	
restoring durable subscription mbean 

private boolean alreadyKnown(SubscriptionKey key) {	boolean known = false;	known = ((TopicRegion) getTopicRegion()).durableSubscriptionExists(key);	
sub with key already registered not 

protected void addInactiveSubscription(SubscriptionKey key, SubscriptionInfo info, Subscription subscription) {	try {	ConsumerInfo offlineConsumerInfo = subscription != null ? subscription.getConsumerInfo() : ((TopicRegion)getTopicRegion()).createInactiveConsumerInfo(info);	ObjectName objectName = BrokerMBeanSupport.createSubscriptionName(brokerObjectName, info.getClientId(), offlineConsumerInfo);	SubscriptionView view = new InactiveDurableSubscriptionView(this, brokerService, key.getClientId(), info, subscription);	try {	AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, objectName);	registeredMBeans.add(objectName);	} catch (Throwable e) {	
failed to register mbean 

protected void addInactiveSubscription(SubscriptionKey key, SubscriptionInfo info, Subscription subscription) {	try {	ConsumerInfo offlineConsumerInfo = subscription != null ? subscription.getConsumerInfo() : ((TopicRegion)getTopicRegion()).createInactiveConsumerInfo(info);	ObjectName objectName = BrokerMBeanSupport.createSubscriptionName(brokerObjectName, info.getClientId(), offlineConsumerInfo);	SubscriptionView view = new InactiveDurableSubscriptionView(this, brokerService, key.getClientId(), info, subscription);	try {	AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, objectName);	registeredMBeans.add(objectName);	} catch (Throwable e) {	
failure reason 

ObjectName objectName = BrokerMBeanSupport.createSubscriptionName(brokerObjectName, info.getClientId(), offlineConsumerInfo);	SubscriptionView view = new InactiveDurableSubscriptionView(this, brokerService, key.getClientId(), info, subscription);	try {	AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, objectName);	registeredMBeans.add(objectName);	} catch (Throwable e) {	}	inactiveDurableTopicSubscribers.put(objectName, view);	subscriptionKeys.put(key, objectName);	} catch (Exception e) {	
failed to register subscription 

public CompositeData[] browse(SubscriptionView view) throws OpenDataException {	Message[] messages = getSubscriberMessages(view);	CompositeData c[] = new CompositeData[messages.length];	for (int i = 0; i < c.length; i++) {	try {	c[i] = OpenTypeSupport.convert(messages[i]);	} catch (Throwable e) {	
failed to browse 

protected Message[] getSubscriberMessages(SubscriptionView view) {	ActiveMQDestination destination = getTopicDestination(view);	if (destination != null) {	Destination topic = getTopicRegion().getDestinationMap().get(destination);	return topic.browse();	} else {	
can t determine topic to browse for sub 

AbortSlowConsumerStrategyView view = null;	if (strategy instanceof AbortSlowAckConsumerStrategy) {	view = new AbortSlowAckConsumerStrategyView(this, (AbortSlowAckConsumerStrategy) strategy);	} else {	view = new AbortSlowConsumerStrategyView(this, strategy);	}	AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, objectName);	registeredMBeans.add(objectName);	}	} catch (Exception e) {	
failed to register mbean 

AbortSlowConsumerStrategyView view = null;	if (strategy instanceof AbortSlowAckConsumerStrategy) {	view = new AbortSlowAckConsumerStrategyView(this, (AbortSlowAckConsumerStrategy) strategy);	} else {	view = new AbortSlowConsumerStrategyView(this, strategy);	}	AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, objectName);	registeredMBeans.add(objectName);	}	} catch (Exception e) {	
failure reason 

public void registerRecoveredTransactionMBean(XATransaction transaction) {	try {	ObjectName objectName = BrokerMBeanSupport.createXATransactionName(brokerObjectName, transaction);	if (!registeredMBeans.contains(objectName))  {	RecoveredXATransactionView view = new RecoveredXATransactionView(this, transaction);	AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, objectName);	registeredMBeans.add(objectName);	}	} catch (Exception e) {	
failed to register prepared transaction mbean 

public void registerRecoveredTransactionMBean(XATransaction transaction) {	try {	ObjectName objectName = BrokerMBeanSupport.createXATransactionName(brokerObjectName, transaction);	if (!registeredMBeans.contains(objectName))  {	RecoveredXATransactionView view = new RecoveredXATransactionView(this, transaction);	AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, objectName);	registeredMBeans.add(objectName);	}	} catch (Exception e) {	
failure reason 

public void unregister(XATransaction transaction) {	try {	ObjectName objectName = BrokerMBeanSupport.createXATransactionName(brokerObjectName, transaction);	if (registeredMBeans.remove(objectName)) {	try {	managementContext.unregisterMBean(objectName);	} catch (Throwable e) {	
failed to unregister mbean 

public void unregister(XATransaction transaction) {	try {	ObjectName objectName = BrokerMBeanSupport.createXATransactionName(brokerObjectName, transaction);	if (registeredMBeans.remove(objectName)) {	try {	managementContext.unregisterMBean(objectName);	} catch (Throwable e) {	
failure reason 

public void unregister(XATransaction transaction) {	try {	ObjectName objectName = BrokerMBeanSupport.createXATransactionName(brokerObjectName, transaction);	if (registeredMBeans.remove(objectName)) {	try {	managementContext.unregisterMBean(objectName);	} catch (Throwable e) {	}	}	} catch (Exception e) {	
failed to create object name to unregister 

========================= activemq sample_3919 =========================

protected MBeanServerConnection getMBeanServerConnection() throws Exception {	JMXConnector connector = this.connector;	if (isConnectionActive(connector)) {	return connector.getMBeanServerConnection();	}	synchronized (this) {	closeConnection();	
creating a new jmx connection to the broker 

}	Collection<JMXServiceURL> jmxUrls = this.configuration.getJmxUrls();	Exception exception = null;	for (JMXServiceURL url : jmxUrls) {	try {	JMXConnector connector = JMXConnectorFactory.connect(url, env);	connector.connect();	MBeanServerConnection connection = connector.getMBeanServerConnection();	Set<ObjectName> brokers = findBrokers(connection);	if (brokers.size() > 0) {	
connected via jmx to the broker at 

protected synchronized void closeConnection() {	if (connector != null) {	try {	
closing a connection to a broker 

========================= activemq sample_1027 =========================

url = args[0];	}	ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);	Destination destination = new ActiveMQQueue("TEST.QUEUE");	Connection connection = connectionFactory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	TextMessage message = session.createTextMessage();	for (int i = 0; i < 1000; i++) {	message.setText("This is message " + (i + 1));	
sending message 

========================= activemq sample_1477 =========================

public void testUriOptionsWork() throws Exception {	String uri = prefix + bindAddress + postfix;	
connecting via 

private void testValidOptionsWork(String options, String msg) {	String uri = prefix + bindAddress + postfix + options;	
connecting via 

private void testInvalidOptionsDoNotWork(String options, String msg) {	String uri = prefix + bindAddress + postfix + options;	
connecting via 

========================= activemq sample_2522 =========================

service.setPersistent(true);	KahaDBPersistenceAdapter pa=new KahaDBPersistenceAdapter();	File dataFile=new File("KahaDB");	pa.setDirectory(dataFile);	pa.setJournalMaxFileLength(10*1024);	pa.setPreallocationScope(Journal.PreallocationScope.ENTIRE_JOURNAL.name());	pa.setCheckpointInterval(TimeUnit.SECONDS.toMillis(5));	pa.setCleanupInterval(TimeUnit.SECONDS.toMillis(5));	if (recover) {	for (File index : FileUtils.listFiles(dataFile, new WildcardFileFilter("*.data"), TrueFileFilter.INSTANCE)) {	
deleting 

public void testDurableSubPrefetchRecovered() throws Exception {	ActiveMQQueue queue = new ActiveMQQueue("MyQueue");	ActiveMQTopic topic = new ActiveMQTopic("MyDurableTopic");	sendMessages(queue);	
there are currently journal log files 

ActiveMQTopic topic = new ActiveMQTopic("MyDurableTopic");	sendMessages(queue);	createInactiveDurableSub(topic);	assertTrue("Should have an inactive durable sub", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(queue);	
there are currently journal log files 

sendMessages(queue);	createInactiveDurableSub(topic);	assertTrue("Should have an inactive durable sub", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(queue);	assertTrue(getNumberOfJournalFiles() > 1);	
restarting the broker 

createInactiveDurableSub(topic);	assertTrue("Should have an inactive durable sub", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(queue);	assertTrue(getNumberOfJournalFiles() > 1);	restartBroker();	
restarted the broker 

createInactiveDurableSub(topic);	assertTrue("Should have an inactive durable sub", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(queue);	assertTrue(getNumberOfJournalFiles() > 1);	restartBroker();	
there are currently journal log files 

ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	service.getAdminView().removeQueue(queue.getQueueName());	assertTrue("Less than two journal files expected, was " + getNumberOfJournalFiles(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getNumberOfJournalFiles() <= 2;	}	}, TimeUnit.MINUTES.toMillis(2)));	
sending messages to the topic 

return subs != null && subs.length == 1 ? true : false;	}	}));	service.getAdminView().removeQueue(queue.getQueueName());	assertTrue("Less than two journal files expected, was " + getNumberOfJournalFiles(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getNumberOfJournalFiles() <= 2;	}	}, TimeUnit.MINUTES.toMillis(2)));	sendMessages(topic);	
attempt to consume messages from the topic 

}	}));	service.getAdminView().removeQueue(queue.getQueueName());	assertTrue("Less than two journal files expected, was " + getNumberOfJournalFiles(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getNumberOfJournalFiles() <= 2;	}	}, TimeUnit.MINUTES.toMillis(2)));	sendMessages(topic);	assertEquals(MSG_COUNT, consumeFromInactiveDurableSub(topic));	
recovering the broker 

}));	service.getAdminView().removeQueue(queue.getQueueName());	assertTrue("Less than two journal files expected, was " + getNumberOfJournalFiles(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getNumberOfJournalFiles() <= 2;	}	}, TimeUnit.MINUTES.toMillis(2)));	sendMessages(topic);	assertEquals(MSG_COUNT, consumeFromInactiveDurableSub(topic));	recoverBroker();	
recovering the broker 

ActiveMQTopic topic = new ActiveMQTopic("MyDurableTopic");	createInactiveDurableSub(topic);	assertTrue("Should have an inactive durable sub", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(topic, 1);	sendMessages(queue);	
before consume there are currently journal log files 

createInactiveDurableSub(topic);	assertTrue("Should have an inactive durable sub", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(topic, 1);	sendMessages(queue);	consumeDurableMessages(topic, 1);	
after consume there are currently journal log files 

assertTrue("Should have an inactive durable sub", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(topic, 1);	sendMessages(queue);	consumeDurableMessages(topic, 1);	sendMessages(queue);	
more queued there are currently journal log files 

public boolean isSatisified() throws Exception {	ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(topic, 1);	sendMessages(queue);	consumeDurableMessages(topic, 1);	sendMessages(queue);	assertTrue(getNumberOfJournalFiles() > 1);	
restarting the broker 

ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(topic, 1);	sendMessages(queue);	consumeDurableMessages(topic, 1);	sendMessages(queue);	assertTrue(getNumberOfJournalFiles() > 1);	restartBroker();	
restarted the broker 

ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(topic, 1);	sendMessages(queue);	consumeDurableMessages(topic, 1);	sendMessages(queue);	assertTrue(getNumberOfJournalFiles() > 1);	restartBroker();	
there are currently journal log files 

return subs != null && subs.length == 1 ? true : false;	}	}));	service.getAdminView().removeQueue(queue.getQueueName());	assertTrue("Less than three journal file expected, was " + getNumberOfJournalFiles(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getNumberOfJournalFiles() <= 3;	}	}, TimeUnit.MINUTES.toMillis(3)));	tryConsumeExpectNone(topic);	
there are currently journal log files 

return subs != null && subs.length == 1 ? true : false;	}	}));	service.getAdminView().removeQueue(queue.getQueueName());	assertTrue("Less than three journal file expected, was " + getNumberOfJournalFiles(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getNumberOfJournalFiles() <= 3;	}	}, TimeUnit.MINUTES.toMillis(3)));	tryConsumeExpectNone(topic);	
recovering the broker 

}	}));	service.getAdminView().removeQueue(queue.getQueueName());	assertTrue("Less than three journal file expected, was " + getNumberOfJournalFiles(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getNumberOfJournalFiles() <= 3;	}	}, TimeUnit.MINUTES.toMillis(3)));	tryConsumeExpectNone(topic);	recoverBroker();	
recovering the broker 

}	}));	service.getAdminView().removeQueue(queue.getQueueName());	assertTrue("Less than three journal file expected, was " + getNumberOfJournalFiles(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getNumberOfJournalFiles() <= 3;	}	}, TimeUnit.MINUTES.toMillis(3)));	tryConsumeExpectNone(topic);	recoverBroker();	
there are currently journal log files 

========================= activemq sample_3763 =========================

}	};	org.apache.log4j.Logger.getRootLogger().addAppender(errorDetectorAppender);	producerThread = new Thread(new Runnable() {	public void run() {	try {	Connection connection = createConnectionFactory() .createConnection();	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Topic destination = session.createTopic("test.AMQ5426");	
created topic 

producerThread = new Thread(new Runnable() {	public void run() {	try {	Connection connection = createConnectionFactory() .createConnection();	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Topic destination = session.createTopic("test.AMQ5426");	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	producer.setTimeToLive(1000);	
created producer 

int i = 1;	while (!Thread.interrupted()) {	try {	TextMessage msg = session.createTextMessage(" testMessage " + i);	producer.send(msg);	try {	Thread.sleep(0, 100);	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	}	
message sent 

public void testConsumerProperlyClosedWithoutError() throws Exception {	Random rn = new Random();	final int NUMBER_OF_RUNS = 1000;	for (int run = 0; run < NUMBER_OF_RUNS; run++) {	final AtomicInteger numberOfMessagesReceived = new AtomicInteger(0);	
starting run of 

public void testConsumerProperlyClosedWithoutError() throws Exception {	Random rn = new Random();	final int NUMBER_OF_RUNS = 1000;	for (int run = 0; run < NUMBER_OF_RUNS; run++) {	final AtomicInteger numberOfMessagesReceived = new AtomicInteger(0);	Connection connection = createConnectionFactory().createConnection();	connection.start();	Session session = connection.createSession(false, Session.DUPS_OK_ACKNOWLEDGE);	Topic destination = session.createTopic("test.AMQ5426");	
created topic 

final int NUMBER_OF_RUNS = 1000;	for (int run = 0; run < NUMBER_OF_RUNS; run++) {	final AtomicInteger numberOfMessagesReceived = new AtomicInteger(0);	Connection connection = createConnectionFactory().createConnection();	connection.start();	Session session = connection.createSession(false, Session.DUPS_OK_ACKNOWLEDGE);	Topic destination = session.createTopic("test.AMQ5426");	MessageConsumer consumer = session.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	
received message 

Connection connection = createConnectionFactory().createConnection();	connection.start();	Session session = connection.createSession(false, Session.DUPS_OK_ACKNOWLEDGE);	Topic destination = session.createTopic("test.AMQ5426");	MessageConsumer consumer = session.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	numberOfMessagesReceived.getAndIncrement();	}	});	
created consumer 

consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	numberOfMessagesReceived.getAndIncrement();	}	});	try {	Thread.sleep(rn.nextInt(5) + 1);	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	}	
closing consumer 

try {	Thread.sleep(rn.nextInt(5) + 1);	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	}	consumer.close();	session.close();	connection.close();	assertFalse("Exception in Producer Thread", hasFailureInProducer.get());	assertFalse("Error detected in Logger", hasErrorInLogger.get());	
run of completed message received 

public void tearDown() throws Exception {	
shutdown producer thread 

========================= activemq sample_2934 =========================

protected void sendWriteBuffer(int commandId, SocketAddress address, byte[] data, boolean redelivery) throws IOException {	if (dropCommandStrategy.shouldDropCommand(commandId, address, redelivery)) {	
dropping datagram with command 

========================= activemq sample_2467 =========================

protected void setUp() throws Exception {	if (broker == null) {	broker = createBroker(bindAddress);	}	factory = createConnectionFactory(clientURI);	Connection con = factory.createConnection();	Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	
running producer s and consumer s per destination s 

Connection con = factory.createConnection();	Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	totalNumberOfConsumers = numberOfConsumers * numberOfDestinations;	totalNumberOfProducers = numberofProducers * numberOfDestinations;	producers = new PerfProducer[totalNumberOfProducers];	consumers = new PerfConsumer[totalNumberOfConsumers];	int consumerCount = 0;	int producerCount = 0;	for (int k = 0; k < numberOfDestinations; k++) {	Destination destination = createDestination(session, destinationName + ":" + k);	
testing against destination 

public void testPerformance() throws JMSException, InterruptedException {	for (int i = 0; i < totalNumberOfConsumers; i++) {	consumers[i].start();	}	for (int i = 0; i < totalNumberOfProducers; i++) {	producers[i].start();	}	
sampling performance times at a ms interval 

========================= activemq sample_3519 =========================

private void deleteDurableQueues(List<ActiveMQQueue> queues) {	try {	for (ActiveMQQueue queue : queues) {	
removing queue subscription for 

DestinationInfo removeAction = new DestinationInfo();	removeAction.setConnectionId(protocol.getConnectionId());	removeAction.setDestination(queue);	removeAction.setOperationType(DestinationInfo.REMOVE_OPERATION_TYPE);	protocol.sendToActiveMQ(removeAction, new ResponseHandler() {	public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {	}	});	}	} catch (Throwable e) {	
could not delete the mqtt queue subscriptions 

private void restoreDurableQueue(List<ActiveMQQueue> queues) {	try {	for (ActiveMQQueue queue : queues) {	String name = queue.getPhysicalName().substring(VIRTUALTOPIC_CONSUMER_PREFIX.length());	StringTokenizer tokenizer = new StringTokenizer(name);	tokenizer.nextToken(":.");	String qosString = tokenizer.nextToken();	tokenizer.nextToken();	String topicName = convertActiveMQToMQTT(tokenizer.nextToken("").substring(1));	QoS qoS = QoS.valueOf(qosString);	
restoring queue subscription 

consumerInfo.setPrefetchSize(ActiveMQPrefetchPolicy.DEFAULT_QUEUE_PREFETCH);	if (protocol.getActiveMQSubscriptionPrefetch() > 0) {	consumerInfo.setPrefetchSize(protocol.getActiveMQSubscriptionPrefetch());	}	consumerInfo.setRetroactive(true);	consumerInfo.setDispatchAsync(true);	doSubscribe(consumerInfo, topicName, qoS);	restoredQueues.add(queue);	}	} catch (IOException e) {	
could not restore the mqtt queue subscriptions 

========================= activemq sample_910 =========================

ConnectionPool connection = createConnectionPool(delegate);	connection.setIdleTimeout(getIdleTimeout());	connection.setExpiryTimeout(getExpiryTimeout());	connection.setMaximumActiveSessionPerConnection(getMaximumActiveSessionPerConnection());	connection.setBlockIfSessionPoolIsFull(isBlockIfSessionPoolIsFull());	if (isBlockIfSessionPoolIsFull() && getBlockIfSessionPoolIsFullTimeout() > 0) {	connection.setBlockIfSessionPoolIsFullTimeout(getBlockIfSessionPoolIsFullTimeout());	}	connection.setUseAnonymousProducers(isUseAnonymousProducers());	connection.setReconnectOnException(isReconnectOnException());	
created new connection 

connection.setBlockIfSessionPoolIsFullTimeout(getBlockIfSessionPoolIsFullTimeout());	}	connection.setUseAnonymousProducers(isUseAnonymousProducers());	connection.setReconnectOnException(isReconnectOnException());	PooledConnectionFactory.this.mostRecentlyCreated.set(connection);	return new DefaultPooledObject<ConnectionPool>(connection);	}	public void destroyObject(ConnectionKey connectionKey, PooledObject<ConnectionPool> pooledObject) throws Exception {	ConnectionPool connection = pooledObject.getObject();	try {	
destroying connection 

connection.setUseAnonymousProducers(isUseAnonymousProducers());	connection.setReconnectOnException(isReconnectOnException());	PooledConnectionFactory.this.mostRecentlyCreated.set(connection);	return new DefaultPooledObject<ConnectionPool>(connection);	}	public void destroyObject(ConnectionKey connectionKey, PooledObject<ConnectionPool> pooledObject) throws Exception {	ConnectionPool connection = pooledObject.getObject();	try {	connection.close();	} catch (Exception e) {	
close connection failed for connection this exception will be ignored 

public void destroyObject(ConnectionKey connectionKey, PooledObject<ConnectionPool> pooledObject) throws Exception {	ConnectionPool connection = pooledObject.getObject();	try {	connection.close();	} catch (Exception e) {	}	}	public boolean validateObject(ConnectionKey connectionKey, PooledObject<ConnectionPool> pooledObject) {	ConnectionPool connection = pooledObject.getObject();	if (connection != null && connection.expiredCheck()) {	
connection has expired and will be destroyed 

public synchronized Connection createConnection(String userName, String password) throws JMSException {	if (stopped.get()) {	
pooledconnectionfactory is stopped skip create new connection 

public void start() {	LOG.debug("Staring the PooledConnectionFactory: create on start = {}", isCreateConnectionOnStartup());	stopped.set(false);	if (isCreateConnectionOnStartup()) {	try {	createConnection().close();	} catch (JMSException e) {	
create pooled connection during start failed this exception will be ignored 

========================= activemq sample_1318 =========================

Topic topic = session.createTopic("test.topic");	Queue queue = session.createQueue("test.queue");	MessageConsumer consumer = session.createDurableSubscriber(topic, "test");	consumer.close();	MessageProducer producer = session.createProducer(topic);	producer.setPriority(9);	for (int i = 0; i < NUM_MESSAGES; i++) {	Message msg = session.createTextMessage("test message:" + i);	producer.send(msg);	}	
sent to topic 

producer.setPriority(9);	for (int i = 0; i < NUM_MESSAGES; i++) {	Message msg = session.createTextMessage("test message:" + i);	producer.send(msg);	}	producer = session.createProducer(queue);	for (int i = 0; i < NUM_MESSAGES; i++) {	Message msg = session.createTextMessage("test message:" + i);	producer.send(msg);	}	
sent to topic 

connection.setClientID("test");	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Topic topic = session.createTopic("test.topic");	Queue queue = session.createQueue("test.queue");	MessageConsumer queueConsumer = session.createConsumer(queue);	for (int i = 0; i < NUM_MESSAGES; ++i) {	TextMessage received = (TextMessage) queueConsumer.receive(1000);	assertNotNull(received);	}	
consumed from queue 

MessageConsumer queueConsumer = session.createConsumer(queue);	for (int i = 0; i < NUM_MESSAGES; ++i) {	TextMessage received = (TextMessage) queueConsumer.receive(1000);	assertNotNull(received);	}	MessageConsumer topicConsumer = session.createDurableSubscriber(topic, "test");	for (int i = 0; i < NUM_MESSAGES; ++i) {	TextMessage received = (TextMessage) topicConsumer.receive(1000);	assertNotNull(received);	}	
consumed from topic 

========================= activemq sample_1748 =========================

private boolean verifySslCredentials(BrokerService broker) throws Exception {	TransportConnector connector = broker.getTransportConnectors().get(0);	URI brokerUri = connector.getConnectUri();	SSLContext context = SSLContext.getInstance("TLS");	CertChainCatcher catcher = new CertChainCatcher();	context.init(null, new TrustManager[] { catcher }, null);	SSLSocketFactory factory = context.getSocketFactory();	
connecting to broker on 

context.init(null, new TrustManager[] { catcher }, null);	SSLSocketFactory factory = context.getSocketFactory();	SSLSocket socket = (SSLSocket) factory.createSocket(brokerUri.getHost(), brokerUri.getPort());	socket.setSoTimeout(2 * 60 * 1000);	socket.startHandshake();	socket.close();	boolean matches = false;	if (catcher.serverCerts != null) {	for (int i = 0; i < catcher.serverCerts.length; i++) {	X509Certificate cert = catcher.serverCerts[i];	
issuer 

========================= activemq sample_2534 =========================

}	public void onException(IOException error) {	gotExceptionEvent.countDown();	}	public void transportInterupted() {	}	public void transportResumed() {	}	});	sendMessage(connection);	
sent one message worked fine 

sendMessage(connection);	createConnectionFailure(connection);	try {	sendMessage(connection);	TestCase.fail("Expected Error");	} catch (JMSException e) {	} finally {	connection.close();	}	TestCase.assertTrue("exception event propagated ok", gotExceptionEvent.await(5, TimeUnit.SECONDS));	
expect new connection after failure 

private void createConnectionFailure(Connection connection) throws Exception {	ActiveMQConnection c = (ActiveMQConnection) ((PooledConnection)connection).getConnection();	MockTransport t = (MockTransport)c.getTransportChannel().narrow(MockTransport.class);	t.onException(new IOException("forcing exception for " + getName() + " to force pool eviction"));	
arranged for failure chucked exception 

========================= activemq sample_785 =========================

protected Transport createProducer() throws Exception {	
producer using uri 

protected Transport createConsumer() throws Exception {	
consumer on port 

========================= activemq sample_2471 =========================

try {	Connection connection = factory.createConnection();	String clientId = clientIdPrefix;	connection.setClientID(clientId);	final Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	Queue queue = session.createQueue(queueName);	MessageConsumer consumer = session.createConsumer(queue);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	
got message 

Connection connection = factory.createConnection();	String clientId = clientIdPrefix;	connection.setClientID(clientId);	final Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	Queue queue = session.createQueue(queueName);	MessageConsumer consumer = session.createConsumer(queue);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	if (message.getJMSRedelivered()) {	
it s a redelivery 

connection.setClientID(clientId);	final Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	Queue queue = session.createQueue(queueName);	MessageConsumer consumer = session.createConsumer(queue);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	if (message.getJMSRedelivered()) {	redelivery.countDown();	}	
calling recover on the session to force redelivery 

========================= activemq sample_2922 =========================

public void doConsume(Object command) {	if (command != null) {	if (transportListener != null) {	transportListener.onCommand(command);	} else {	
no transportlistener available to process inbound command 

public void onException(IOException e) {	if (transportListener != null) {	try {	transportListener.onException(e);	} catch (RuntimeException e2) {	
unexpected runtime exception 

========================= activemq sample_101 =========================

public void setUp() throws Exception {	gotExceptionInLog.set(Boolean.FALSE);	failedToFindMDC.set(Boolean.FALSE);	Logger.getRootLogger().addAppender(appender);	
transport 

========================= activemq sample_2830 =========================

public void testTemporaryQueueAdvisory() throws Exception {	
running testtemporaryqueueadvisory 

waitForMinTopicRegionConsumerCount("BrokerA", 1);	final int iterations = 30;	for (int i = 0; i < iterations; i++) {	sendReceiveTempQueueMessage("BrokerA");	}	waitForMinTopicRegionConsumerCount("BrokerB", 1);	waitForMinTopicRegionConsumerCount("BrokerA", 1);	final DestinationViewMBean brokerAView = createView("BrokerA", "ActiveMQ.Advisory.TempQueue", ActiveMQDestination.TOPIC_TYPE);	assertTrue("exact amount of advisories created on A, one each for creation/deletion", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
brokera temp advisory enque count 

waitForMinTopicRegionConsumerCount("BrokerA", 1);	final DestinationViewMBean brokerAView = createView("BrokerA", "ActiveMQ.Advisory.TempQueue", ActiveMQDestination.TOPIC_TYPE);	assertTrue("exact amount of advisories created on A, one each for creation/deletion", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return iterations * 2 == brokerAView.getEnqueueCount();	}	}));	final DestinationViewMBean brokerBView = createView("BrokerB", "ActiveMQ.Advisory.TempQueue", ActiveMQDestination.TOPIC_TYPE);	assertTrue("exact amount of advisories created on B, one each for creation/deletion", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
brokerb temp advisory enque count 

========================= activemq sample_3722 =========================

public void testDurableSubscriberNonPersistentMessage() {	String interest = "TEST";	
starting durablesubscribernonpersistentmessagetest 

public void testDurableSubscriberNonPersistentMessage() {	String interest = "TEST";	try {	createConsumer(interest, 0);	Thread.sleep(1000);	Producer producer = new Producer(brokerURL, interest, messageSize, ttl);	producer.sendMessages(totalMsgCount);	producer.close();	
messages sent 

try {	createConsumer(interest, 0);	Thread.sleep(1000);	Producer producer = new Producer(brokerURL, interest, messageSize, ttl);	producer.sendMessages(totalMsgCount);	producer.close();	createConsumer(interest, initialMaxMsgs);	Thread.sleep(reconnectSleep);	createConsumer(interest, cleanupMsgCount);	String brokerVersion = (String) mbeanServer.getAttribute(new ObjectName("org.apache.activemq:brokerName=localhost,type=Broker"), "BrokerVersion");	
test run on 

}));	assertTrue("cursorMemoryUsage should be zero", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	Long cursorMemoryUsage = (Long) mbeanServer.getAttribute(new ObjectName(theJmxObject), "CursorMemoryUsage");	LOG.info("cursorMemoryUsage = " + cursorMemoryUsage);	return cursorMemoryUsage.longValue() == 0L;	}	}));	assertTrue(totalMsgReceived == initialMaxMsgs + cleanupMsgCount);	} catch (Exception e) {	
exception executing durablesubscribernonpersistentmessagetest 

public void createConsumer(String interest, int maxMsgs) {	int messageReceived = 0;	int messagesNotReceived = 0;	
starting durablesubscriber 

public void createConsumer(String interest, int maxMsgs) {	int messageReceived = 0;	int messagesNotReceived = 0;	Consumer consumer = null;	try {	consumer = new Consumer(consumerBrokerURL, interest, clientId);	for (int i = 0; i < maxMsgs; i++) {	try {	Message msg = consumer.getMessage(messageTimeout);	if (msg != null) {	
received message 

Consumer consumer = null;	try {	consumer = new Consumer(consumerBrokerURL, interest, clientId);	for (int i = 0; i < maxMsgs; i++) {	try {	Message msg = consumer.getMessage(messageTimeout);	if (msg != null) {	messageReceived++;	totalMsgReceived++;	} else {	
message not received 

try {	Message msg = consumer.getMessage(messageTimeout);	if (msg != null) {	messageReceived++;	totalMsgReceived++;	} else {	messagesNotReceived++;	}	Thread.sleep(sleep);	} catch (InterruptedException ie) {	
exception 

messageReceived++;	totalMsgReceived++;	} else {	messagesNotReceived++;	}	Thread.sleep(sleep);	} catch (InterruptedException ie) {	}	}	consumer.close();	
consumer finished 

messageReceived++;	totalMsgReceived++;	} else {	messagesNotReceived++;	}	Thread.sleep(sleep);	} catch (InterruptedException ie) {	}	}	consumer.close();	
received 

messageReceived++;	totalMsgReceived++;	} else {	messagesNotReceived++;	}	Thread.sleep(sleep);	} catch (InterruptedException ie) {	}	}	consumer.close();	
not received 

totalMsgReceived++;	} else {	messagesNotReceived++;	}	Thread.sleep(sleep);	} catch (InterruptedException ie) {	}	}	consumer.close();	} catch (JMSException e) {	
exception executing simpleconsumer 

========================= activemq sample_3688 =========================

registerDurableForwardSub("BrokerB", dest, "BrokerC");	startAllBrokers();	waitForBridgeFormation();	MessageConsumer clientC = createConsumer("BrokerC", dest);	sendMessages("BrokerA", dest, 100);	final MessageIdList messagesFromC = getConsumerMessages("BrokerC", clientC);	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return messagesFromC.getMessageCount() == 100;	}});	
b got 

}});	assertEquals(100, messagesFromC.getMessageCount());	destroyBroker("BrokerB");	sendMessages("BrokerA", dest, 100);	BrokerService broker = createBroker(new URI( "broker:(tcp: bridgeBrokerPair("BrokerB", "BrokerC");	broker.start();	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return messagesFromC.getMessageCount() == 200;	}});	
b got 

public void setUp() throws Exception {	File dataDir = new File(IOHelper.getDefaultDataDirectory());	
delete datadir 

========================= activemq sample_3667 =========================

protected void messageSent() throws Exception {	if (++inflightMessageCount == failureCount) {	
stopping db 

protected void messageSent() throws Exception {	if (++inflightMessageCount == failureCount) {	final EmbeddedDataSource ds = sharedDs;	ds.setShutdownDatabase("shutdown");	try {	ds.getConnection();	} catch (Exception ignored) {	}	
db stopped 

protected void messageSent() throws Exception {	if (++inflightMessageCount == failureCount) {	final EmbeddedDataSource ds = sharedDs;	ds.setShutdownDatabase("shutdown");	try {	ds.getConnection();	} catch (Exception ignored) {	}	Thread dbRestartThread = new Thread("db-re-start-thread") {	public void run() {	
sleeping for seconds before allowing db restart 

} catch (Exception ignored) {	}	Thread dbRestartThread = new Thread("db-re-start-thread") {	public void run() {	try {	restartDBLatch.await(10, TimeUnit.SECONDS);	} catch (InterruptedException e) {	e.printStackTrace();	}	ds.setShutdownDatabase("false");	
db restarted 

protected void sendToProducer(MessageProducer producer, Destination producerDestination, Message message) throws JMSException {	{	boolean sent = false;	do {	try {	producer.send(producerDestination, message);	if (transactedSends && ((inflightMessageCount+1) %10 == 0 || (inflightMessageCount+1) >= messageCount)) {	
committing on send message 

{	boolean sent = false;	do {	try {	producer.send(producerDestination, message);	if (transactedSends && ((inflightMessageCount+1) %10 == 0 || (inflightMessageCount+1) >= messageCount)) {	session.commit();	}	sent = true;	} catch (JMSException e) {	
exception on producer send 

public void onException(JMSException exception) {	
exception on connection 

========================= activemq sample_2426 =========================

public void onMessage(Message message) {	if (message instanceof ActiveMQMessage) {	ActiveMQMessage activeMessage = (ActiveMQMessage) message;	Object command = activeMessage.getDataStructure();	if (command instanceof DestinationInfo) {	DestinationInfo destinationInfo = (DestinationInfo) command;	DestinationEvent event = new DestinationEvent(this, destinationInfo);	fireDestinationEvent(event);	}	else {	
unknown datastructure 

Object command = activeMessage.getDataStructure();	if (command instanceof DestinationInfo) {	DestinationInfo destinationInfo = (DestinationInfo) command;	DestinationEvent event = new DestinationEvent(this, destinationInfo);	fireDestinationEvent(event);	}	else {	}	}	else {	
unknown message type message ignored 

else if (destination instanceof ActiveMQTempTopic) {	ActiveMQTempTopic topic = (ActiveMQTempTopic) destination;	if (add) {	temporaryTopics.add(topic);	}	else {	temporaryTopics.remove(topic);	}	}	else {	
unknown destination type 

========================= activemq sample_697 =========================

public void serviceFailed(DiscoveryEvent devent) throws IOException {	final SimpleDiscoveryEvent sevent = (SimpleDiscoveryEvent)devent;	if (running.get() && sevent.failed.compareAndSet(false, true)) {	listener.onServiceRemove(sevent);	taskRunner.execute(new Runnable() {	public void run() {	SimpleDiscoveryEvent event = new SimpleDiscoveryEvent(sevent);	if (event.connectTime + minConnectTime > System.currentTimeMillis()) {	
failure occurred soon after the discovery event was generated it will be classified as a connection failure 

public void serviceFailed(DiscoveryEvent devent) throws IOException {	final SimpleDiscoveryEvent sevent = (SimpleDiscoveryEvent)devent;	if (running.get() && sevent.failed.compareAndSet(false, true)) {	listener.onServiceRemove(sevent);	taskRunner.execute(new Runnable() {	public void run() {	SimpleDiscoveryEvent event = new SimpleDiscoveryEvent(sevent);	if (event.connectTime + minConnectTime > System.currentTimeMillis()) {	event.connectFailures++;	if (maxReconnectAttempts > 0 && event.connectFailures >= maxReconnectAttempts) {	
reconnect attempts exceeded tries reconnecting has been disabled for 

if (!useExponentialBackOff || event.reconnectDelay == -1) {	event.reconnectDelay = initialReconnectDelay;	} else {	event.reconnectDelay *= backOffMultiplier;	if (event.reconnectDelay > maxReconnectDelay) {	event.reconnectDelay = maxReconnectDelay;	}	}	doReconnectDelay(event);	} else {	
failure occurred to long after the discovery event was generated it will not be classified as a connection failure 

event.reconnectDelay = maxReconnectDelay;	}	}	doReconnectDelay(event);	} else {	event.connectFailures = 0;	event.reconnectDelay = initialReconnectDelay;	doReconnectDelay(event);	}	if (!running.get()) {	
reconnecting disabled stopped 

protected void doReconnectDelay(SimpleDiscoveryEvent event) {	synchronized (sleepMutex) {	try {	if (!running.get()) {	
reconnecting disabled stopped 

protected void doReconnectDelay(SimpleDiscoveryEvent event) {	synchronized (sleepMutex) {	try {	if (!running.get()) {	return;	}	
waiting ms before attempting to reconnect 

protected void doReconnectDelay(SimpleDiscoveryEvent event) {	synchronized (sleepMutex) {	try {	if (!running.get()) {	return;	}	sleepMutex.wait(event.reconnectDelay);	} catch (InterruptedException ie) {	
reconnecting disabled 

========================= activemq sample_90 =========================

try {	consumer.consumer();	consumerStarted.countDown();	consumer.getLatch().await(60, TimeUnit.SECONDS);	} catch (Exception e) {	fail("Unexpected " + e);	}	}	});	consumerThread.start();	
started consumer 

}	}	});	consumerThread.start();	assertTrue("consumer started eventually", consumerStarted.await(10, TimeUnit.SECONDS));	Thread.sleep(2000);	final RegionBroker regionBroker = (RegionBroker)broker1.getRegionBroker();	assertTrue("Found network destination with priority as expected", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	Map<ActiveMQDestination, Destination> destinationMap = regionBroker.getTopicRegion().getDestinationMap();	
destinations 

consumerThread.start();	assertTrue("consumer started eventually", consumerStarted.await(10, TimeUnit.SECONDS));	Thread.sleep(2000);	final RegionBroker regionBroker = (RegionBroker)broker1.getRegionBroker();	assertTrue("Found network destination with priority as expected", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	Map<ActiveMQDestination, Destination> destinationMap = regionBroker.getTopicRegion().getDestinationMap();	boolean found = false;	for (Destination destination : destinationMap.values()) {	List<Subscription> subscriptions = destination.getConsumers();	
subscriptions 

Thread.sleep(2000);	final RegionBroker regionBroker = (RegionBroker)broker1.getRegionBroker();	assertTrue("Found network destination with priority as expected", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	Map<ActiveMQDestination, Destination> destinationMap = regionBroker.getTopicRegion().getDestinationMap();	boolean found = false;	for (Destination destination : destinationMap.values()) {	List<Subscription> subscriptions = destination.getConsumers();	for (Subscription subscription : subscriptions) {	if (subscription.getConsumerInfo().isNetworkSubscription()) {	
subscription priority 

if (subscription.getConsumerInfo().isNetworkSubscription()) {	assertTrue("priority is < our base: " + subscription.getConsumerInfo().getPriority(), subscription.getConsumerInfo().getPriority() <= BASE_PRIORITY);	found = true;	}	}	}	return found;	}	}));	producerThread.start();	
started producer 

return found;	}	}));	producerThread.start();	producerThread.join();	consumerThread.join();	int duplicateCount = 0;	Map<String, String> map = new HashMap<String, String>();	for (String msg : consumer.getMessageStrings()) {	if (map.containsKey(msg)) {	
got duplicate 

private void createConsumer() throws JMSException {	if (durableSub) {	consumer = session.createDurableSubscriber(topic, durableID);	} else {	consumer = session.createConsumer(topic);	}	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message arg0) {	TextMessage msg = (TextMessage) arg0;	try {	
received message 

private void publish() throws JMSException {	for (int i = 0; i < numMessages; i++) {	TextMessage textMessage = session.createTextMessage();	String message = "message: " + i;	
sending message 

========================= activemq sample_3610 =========================

public void start() {	
starting 

connection = createConnection();	connection.start();	try {	session = createSession();	work();	} finally {	try {	connection.close();	} catch (JMSException ignore) {	}	
stopped 

protected void work() throws Exception {	String data = createMessage();	MessageProducer producer = session.createProducer(destination);	startedLatch.countDown();	while (!done.get()) {	producer.send(session.createTextMessage(data));	long i = size.incrementAndGet();	if ((i % 1000) == 0) {	
produced 

public void testENTMQ220() throws Exception {	
start test 

producer2Started.await(15, TimeUnit.SECONDS);	listener1Started.await(15, TimeUnit.SECONDS);	lastSize.set(listener1.size.get());	for (int i = 0; i < 10; i++) {	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return listener1.size.get() > lastSize.get();	}	});	long size = listener1.size.get();	
listener consumed 

Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return listener1.size.get() > lastSize.get();	}	});	long size = listener1.size.get();	assertTrue("No messages received on iteration: " + i, size > lastSize.get());	lastSize.set(size);	}	} finally {	
stopping clients 

========================= activemq sample_2847 =========================

ConsumerInfo info = sub.getConsumerInfo();	if (info.isNetworkSubscription()) {	boolean highestPrioritySub = true;	for (Iterator<Subscription> it =  duplicateFreeSubs.iterator(); it.hasNext(); ) {	Subscription candidate = it.next();	if (matches(candidate, info)) {	if (hasLowerPriority(candidate, info)) {	it.remove();	} else {	highestPrioritySub = false;	
ignoring lower priority in favour of 

========================= activemq sample_4090 =========================

public void test() throws Exception {	stompConnect();	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "heart-beat:1000,0\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String response = stompConnection.receiveFrame().trim();	
broker sent response 

========================= activemq sample_1441 =========================

public void testCursorHighWaterMark() throws Exception {	int systemUsage = broker1.getSystemUsage().getMemoryUsage().getPercentUsage();	assertEquals("System Usage on broker1 before test", 0, systemUsage);	produceMesssages(MY_QUEUE, 3000);	systemUsage = broker1.getSystemUsage().getMemoryUsage().getPercentUsage();	assertTrue("System Usage on broker1 before test", 60 < systemUsage);	
broker system mem usage 

========================= activemq sample_2797 =========================

}	JobScheduler js = store.getJobScheduler("test");	js.startDispatching();	int count = 0;	long startTime = 10 * 60 * 1000;	long period = startTime;	for (ByteSequence job : list) {	js.schedule("id:" + (count++), job, "", startTime, period, -1);	}	List<Job> test = js.getAllJobs();	
found jobs in the store before restart 

long period = startTime;	for (ByteSequence job : list) {	js.schedule("id:" + (count++), job, "", startTime, period, -1);	}	List<Job> test = js.getAllJobs();	assertEquals(list.size(), test.size());	store.stop();	store.start();	js = store.getJobScheduler("test");	test = js.getAllJobs();	
found jobs in the store after restart 

========================= activemq sample_2328 =========================

msg = sess.createTextMessage("MSG AAAA " + cur);	msg.setIntProperty("SEQ", 100 + cur);	msg.setStringProperty("TEST", "TOPO");	msg.setJMSReplyTo(resp_dest);	if (cur == (num_msg - 1)) msg.setBooleanProperty("end-of-response", true);	req_prod.send(msg);	cur++;	}	cons_client.waitShutdown(5000);	if (cons_client.shutdown()) {	
consumer client shutdown complete 

msg.setIntProperty("SEQ", 100 + cur);	msg.setStringProperty("TEST", "TOPO");	msg.setJMSReplyTo(resp_dest);	if (cur == (num_msg - 1)) msg.setBooleanProperty("end-of-response", true);	req_prod.send(msg);	cur++;	}	cons_client.waitShutdown(5000);	if (cons_client.shutdown()) {	} else {	
consumer client shutdown incomplete 

if (cur == (num_msg - 1)) msg.setBooleanProperty("end-of-response", true);	req_prod.send(msg);	cur++;	}	cons_client.waitShutdown(5000);	if (cons_client.shutdown()) {	} else {	}	tot_expected = num_msg * (echoResponseFill + 1);	if (cons_client.getNumMsgReceived() == tot_expected) {	
have messages as expected 

req_prod.send(msg);	cur++;	}	cons_client.waitShutdown(5000);	if (cons_client.shutdown()) {	} else {	}	tot_expected = num_msg * (echoResponseFill + 1);	if (cons_client.getNumMsgReceived() == tot_expected) {	} else {	
have messages expected 

int echo_id;	EchoService echo_svc;	String echo_queue_name;	Destination prod_dest;	MessageProducer msg_prod;	synchronized (this) {	echo_id = this.nextEchoId;	this.nextEchoId++;	}	echo_queue_name = "echo.queue." + echo_id;	
destroying the echo queue in case an old one exists 

Destination prod_dest;	MessageProducer msg_prod;	synchronized (this) {	echo_id = this.nextEchoId;	this.nextEchoId++;	}	echo_queue_name = "echo.queue." + echo_id;	removeQueue(conn, echo_queue_name);	echo_svc = new EchoService(echo_queue_name, prod_broker_url);	echo_svc.start();	
creating echo queue and producer 

public void testTempTopic(String prod_broker_url, String cons_broker_url) throws Exception {	Connection conn;	Session sess;	Destination cons_dest;	int num_msg;	num_msg = 5;	
testing temp topics messages 

public void testTempTopic(String prod_broker_url, String cons_broker_url) throws Exception {	Connection conn;	Session sess;	Destination cons_dest;	int num_msg;	num_msg = 5;	conn = createConnection(cons_broker_url);	conn.start();	sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	
creating destination 

public void testTopic(String prod_broker_url, String cons_broker_url) throws Exception {	int num_msg;	Connection conn;	Session sess;	String topic_name;	Destination cons_dest;	num_msg = 5;	
testing topics messages 

int num_msg;	Connection conn;	Session sess;	String topic_name;	Destination cons_dest;	num_msg = 5;	conn = createConnection(cons_broker_url);	conn.start();	sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	topic_name = "topotest2.perm.topic";	
removing existing topic 

Connection conn;	Session sess;	String topic_name;	Destination cons_dest;	num_msg = 5;	conn = createConnection(cons_broker_url);	conn.start();	sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	topic_name = "topotest2.perm.topic";	removeTopic(conn, topic_name);	
creating topic 

public void testTempQueue(String prod_broker_url, String cons_broker_url) throws Exception {	int num_msg;	Connection conn;	Session sess;	Destination cons_dest;	num_msg = 5;	
testing temp queues messages 

public void testTempQueue(String prod_broker_url, String cons_broker_url) throws Exception {	int num_msg;	Connection conn;	Session sess;	Destination cons_dest;	num_msg = 5;	conn = createConnection(cons_broker_url);	conn.start();	sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	
creating destination 

public void testQueue(String prod_broker_url, String cons_broker_url) throws Exception {	int num_msg;	Connection conn;	Session sess;	String queue_name;	Destination cons_dest;	num_msg = 5;	
testing queues messages 

int num_msg;	Connection conn;	Session sess;	String queue_name;	Destination cons_dest;	num_msg = 5;	conn = createConnection(cons_broker_url);	conn.start();	sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	queue_name = "topotest2.perm.queue";	
removing existing queue 

Connection conn;	Session sess;	String queue_name;	Destination cons_dest;	num_msg = 5;	conn = createConnection(cons_broker_url);	conn.start();	sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	queue_name = "topotest2.perm.queue";	removeQueue(conn, queue_name);	
creating queue 

public void run() {	CountDownLatch latch;	try {	synchronized (this) {	latch = shutdownLatch;	}	shutdownInd = false;	processMessages();	latch.countDown();	} catch (Exception exc) {	
message client error 

public void waitShutdown(long timeout) {	CountDownLatch latch;	try {	synchronized (this) {	latch = shutdownLatch;	}	if (latch != null) latch.await(timeout, TimeUnit.MILLISECONDS);	
echo client shutdown client does not appear to be active 

public void waitShutdown(long timeout) {	CountDownLatch latch;	try {	synchronized (this) {	latch = shutdownLatch;	}	if (latch != null) latch.await(timeout, TimeUnit.MILLISECONDS);	} catch (InterruptedException int_exc) {	
wait for message client shutdown interrupted 

protected void checkMessage(Message in_msg) throws Exception {	int seq;	
received message 

protected void checkMessage(Message in_msg) throws Exception {	int seq;	if (in_msg.propertyExists("SEQ")) {	seq = in_msg.getIntProperty("SEQ");	if ((haveFirstSeq) && (seq != (lastSeq + 1))) {	
error incorrect sequence number expected but have 

protected void checkMessage(Message in_msg) throws Exception {	int seq;	if (in_msg.propertyExists("SEQ")) {	seq = in_msg.getIntProperty("SEQ");	if ((haveFirstSeq) && (seq != (lastSeq + 1))) {	testError = true;	}	lastSeq = seq;	if (msgCount > expectedCount) {	
have more messages than expected have expect 

seq = in_msg.getIntProperty("SEQ");	if ((haveFirstSeq) && (seq != (lastSeq + 1))) {	testError = true;	}	lastSeq = seq;	if (msgCount > expectedCount) {	testError = true;	}	}	if (in_msg.propertyExists("end-of-response")) {	
received end of response message 

public void run() {	Message req;	try {	
starting echo service 

public void run() {	Message req;	try {	while (!Shutdown_ind) {	req = msg_cons.receive(100);	if (req != null) {	
echo request message 

while (!Shutdown_ind) {	req = msg_cons.receive(100);	if (req != null) {	resp_dest = req.getJMSReplyTo();	if (resp_dest != null) {	msg_prod = sess.createProducer(resp_dest);	msg_prod.send(req);	msg_prod.close();	msg_prod = null;	} else {	
invalid request no reply to destination given 

msg_prod.send(req);	msg_prod.close();	msg_prod = null;	} else {	}	}	}	} catch (Exception ex) {	LOG.error(null, ex);	} finally {	
shutting down test echo service 

} else {	}	}	}	} catch (Exception ex) {	LOG.error(null, ex);	} finally {	try {	jmsConn.stop();	} catch (javax.jms.JMSException jms_exc) {	
error on shutting down jms connection 

public void shutdown() {	CountDownLatch wait_l;	synchronized (this) {	wait_l = waitShutdown;	}	Shutdown_ind = true;	try {	if (wait_l != null) {	if (wait_l.await(3000, TimeUnit.MILLISECONDS)) {	
echo service shutdown complete 

public void shutdown() {	CountDownLatch wait_l;	synchronized (this) {	wait_l = waitShutdown;	}	Shutdown_ind = true;	try {	if (wait_l != null) {	if (wait_l.await(3000, TimeUnit.MILLISECONDS)) {	} else {	
timeout waiting for echo service shutdown 

synchronized (this) {	wait_l = waitShutdown;	}	Shutdown_ind = true;	try {	if (wait_l != null) {	if (wait_l.await(3000, TimeUnit.MILLISECONDS)) {	} else {	}	} else {	
echo service shutdown service does not appear to be active 

}	Shutdown_ind = true;	try {	if (wait_l != null) {	if (wait_l.await(3000, TimeUnit.MILLISECONDS)) {	} else {	}	} else {	}	} catch (InterruptedException int_exc) {	
interrupted while waiting for echo service shutdown 

========================= activemq sample_2778 =========================

}	holder.setServlet(createWSServlet());	contextHandler.addServlet(holder, "/");	contextHandler.setAttribute("acceptListener", getAcceptListener());	server.start();	int port = getConnectorLocalPort();	if (port == -1) {	port = boundTo.getPort();	}	setConnectURI(new URI(boundTo.getScheme(), boundTo.getUserInfo(), boundTo.getHost(), port, boundTo.getPath(), boundTo.getQuery(), boundTo.getFragment()));	
listening for connections at 

========================= activemq sample_1154 =========================

public void addMessage(final ConnectionContext context, final Message message) throws IOException {	MessageId messageId = message.getMessageId();	if (audit != null && audit.isDuplicate(message)) {	if (LOG.isDebugEnabled()) {	
ignoring duplicated add message already stored 

TransactionContext c = persistenceAdapter.getTransactionContext();	try {	adapter.doRecover(c, destination, new JDBCMessageRecoveryListener() {	public boolean recoverMessage(long sequenceId, byte[] data) throws Exception {	if (listener.hasSpace()) {	Message msg = (Message) wireFormat.unmarshal(new ByteSequence(data));	msg.getMessageId().setBrokerSequenceId(sequenceId);	return listener.recoverMessage(msg);	} else {	if (LOG.isTraceEnabled()) {	
message recovery limit reached for messagerecoverylistener 

if (LOG.isTraceEnabled()) {	}	return false;	}	}	public boolean recoverMessageReference(String reference) throws Exception {	if (listener.hasSpace()) {	return listener.recoverMessageReference(new MessageId(reference));	} else {	if (LOG.isTraceEnabled()) {	
message recovery limit reached for messagerecoverylistener 

public void recoverNextMessages(int maxReturned, final MessageRecoveryListener listener) throws Exception {	TransactionContext c = persistenceAdapter.getTransactionContext();	try {	if (LOG.isTraceEnabled()) {	
recovernext lastrecovered minpending 

public void resetBatching() {	if (LOG.isTraceEnabled()) {	
resetbatching last recovered 

public void setBatch(MessageId messageId) {	if (LOG.isTraceEnabled()) {	
setbatch last recovered 

public void setBatch(MessageId messageId) {	if (LOG.isTraceEnabled()) {	}	try {	long[] storedValues = persistenceAdapter.getStoreSequenceIdForMessageId(null, messageId, destination);	setLastRecovered(storedValues[0]);	} catch (IOException ignoredAsAlreadyLogged) {	resetBatching();	}	if (LOG.isTraceEnabled()) {	
setbatch new last recovered 

========================= activemq sample_930 =========================

public void onMessage(javax.jms.Message message) {	long acks = acksReceived.incrementAndGet();	latch.get().countDown();	if (acks % 1 == 0) {	
master now has ack count of 

Worker[] workers = new Worker[NUM_WORKERS];	for (int i = 0; i < NUM_WORKERS; i++) {	workers[i] = new Worker(connection.createSession(false, Session.AUTO_ACKNOWLEDGE));	}	acksReceived.set(0);	latch.set(new CountDownLatch(BATCH_SIZE));	workItemProducer.send(masterSession .createObjectMessage(new WorkMessage(1)));	if (!latch.get().await(WAIT_TIMEOUT, TimeUnit.MILLISECONDS)) {	fail("First batch only received " + acksReceived + " messages");	}	
first batch received 

workItemProducer.send(masterSession .createObjectMessage(new WorkMessage(1)));	if (!latch.get().await(WAIT_TIMEOUT, TimeUnit.MILLISECONDS)) {	fail("First batch only received " + acksReceived + " messages");	}	acksReceived.set(0);	latch.set(new CountDownLatch(BATCH_SIZE));	workItemProducer.send(masterSession .createObjectMessage(new WorkMessage(1)));	if (!latch.get().await(WAIT_TIMEOUT, TimeUnit.MILLISECONDS)) {	fail("Second batch only received " + acksReceived + " messages");	}	
second batch received 

========================= activemq sample_2955 =========================

public void setUp() throws Exception {	File dataDir = new File(IOHelper.getDefaultDataDirectory());	
delete datadir 

========================= activemq sample_3647 =========================

public void testVirtualTopicRouting() throws Exception {	if (connection == null) {	connection = createConnection();	}	connection.start();	
validate no other messages on queues 

if (connection == null) {	connection = createConnection();	}	connection.start();	try {	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	ActiveMQDestination destination1 = getConsumer1Destination();	ActiveMQDestination destination2 = getConsumer2Destination();	MessageConsumer c1 = session.createConsumer(destination1, null);	MessageConsumer c2 = session.createConsumer(destination2, null);	
send one simple message that should go to both consumers 

========================= activemq sample_2390 =========================

if (command.isResponse()) {	Response response = (Response)command;	FutureResponse future = null;	synchronized (requestMap) {	future = requestMap.remove(Integer.valueOf(response.getCorrelationId()));	}	if (future != null) {	future.set(response);	} else {	if (debug) {	
received unexpected response for command id 

========================= activemq sample_121 =========================

public ObjectInstance createMBean(String className, ObjectName name, Object[] params, String[] signature) throws ReflectionException, InstanceAlreadyExistsException, MBeanRegistrationException, MBeanException, NotCompliantMBeanException {	return null;	}	public ObjectInstance createMBean(String className, ObjectName name, ObjectName loaderName, Object[] params, String[] signature) throws ReflectionException, InstanceAlreadyExistsException, MBeanRegistrationException, MBeanException, NotCompliantMBeanException, InstanceNotFoundException {	return null;	}	public ObjectInstance registerMBean(Object object, ObjectName name) throws InstanceAlreadyExistsException, MBeanRegistrationException, NotCompliantMBeanException {	if (mbeans.containsKey(name)) {	throw new InstanceAlreadyExistsException("Got one already: " + name);	}	
register 

========================= activemq sample_3581 =========================

});	duplexInboundLocalBroker.start();	}	localBroker.setTransportListener(new DefaultTransportListener() {	public void onCommand(Object o) {	Command command = (Command) o;	serviceLocalCommand(command);	}	public void onException(IOException error) {	if (!futureLocalBrokerInfo.isDone()) {	
error with pending local brokerinfo on 

serviceLocalException(error);	}	});	remoteBroker.setTransportListener(new DefaultTransportListener() {	public void onCommand(Object o) {	Command command = (Command) o;	serviceRemoteCommand(command);	}	public void onException(IOException error) {	if (!futureRemoteBrokerInfo.isDone()) {	
error with pending remote brokerinfo on 

}	serviceRemoteException(error);	}	});	remoteBroker.start();	localBroker.start();	if (!disposed.get()) {	try {	triggerStartAsyncNetworkBridgeCreation();	} catch (IOException e) {	
caught exception from remote start 

}	});	remoteBroker.start();	localBroker.start();	if (!disposed.get()) {	try {	triggerStartAsyncNetworkBridgeCreation();	} catch (IOException e) {	}	} else {	
bridge was disposed before the start method was fully executed 

public void stop() throws Exception {	if (started.compareAndSet(true, false)) {	if (disposed.compareAndSet(false, true)) {	
stopping bridge to 

if (started.compareAndSet(true, false)) {	if (disposed.compareAndSet(false, true)) {	futureRemoteBrokerInfo.cancel(true);	futureLocalBrokerInfo.cancel(true);	NetworkBridgeListener l = this.networkBridgeListener;	if (l != null) {	l.onStop(this);	}	try {	if (startedLatch.getCount() < 2) {	
unregister bridge to 

brokerService.getBroker().networkBridgeStopped(remoteBrokerInfo);	}	remoteBridgeStarted.set(false);	final CountDownLatch sendShutdown = new CountDownLatch(1);	brokerService.getTaskRunnerFactory().execute(new Runnable() {	public void run() {	try {	serialExecutor.shutdown();	if (!serialExecutor.awaitTermination(5, TimeUnit.SECONDS)) {	List<Runnable> pendingTasks = serialExecutor.shutdownNow();	
pending tasks on stop 

public void run() {	try {	serialExecutor.shutdown();	if (!serialExecutor.awaitTermination(5, TimeUnit.SECONDS)) {	List<Runnable> pendingTasks = serialExecutor.shutdownNow();	}	staticDestinationsLatch.countDown();	syncExecutor.shutdown();	if (!syncExecutor.awaitTermination(5, TimeUnit.SECONDS)) {	List<Runnable> pendingTasks = syncExecutor.shutdownNow();	
pending tasks on stop 

List<Runnable> pendingTasks = serialExecutor.shutdownNow();	}	staticDestinationsLatch.countDown();	syncExecutor.shutdown();	if (!syncExecutor.awaitTermination(5, TimeUnit.SECONDS)) {	List<Runnable> pendingTasks = syncExecutor.shutdownNow();	}	localBroker.oneway(new ShutdownInfo());	remoteBroker.oneway(new ShutdownInfo());	} catch (Throwable e) {	
caught exception sending shutdown 

}	localBroker.oneway(new ShutdownInfo());	remoteBroker.oneway(new ShutdownInfo());	} catch (Throwable e) {	} finally {	sendShutdown.countDown();	}	}	}, "ActiveMQ ForwardingBridge StopTask");	if (!sendShutdown.await(10, TimeUnit.SECONDS)) {	
network could not shutdown in a timely manner 

ss.stop(remoteBroker);	ss.stop(localBroker);	ss.stop(duplexInboundLocalBroker);	startedLatch.countDown();	startedLatch.countDown();	localStartedLatch.countDown();	staticDestinationsLatch.countDown();	ss.throwFirstException();	}	}	
bridge to stopped 

return;	}	try {	localBrokerInfo = futureLocalBrokerInfo.get(timeout, TimeUnit.MILLISECONDS);	if (localBrokerInfo == null) {	serviceLocalException(new Throwable("localBrokerInfo is null"));	return;	}	remoteBrokerId = remoteBrokerInfo.getBrokerId();	if (localBrokerId.equals(remoteBrokerId)) {	
disconnecting remote loop back connector for with id 

if (configuration.getExcludedDestinations() != null) {	excludedDestinations = configuration.getExcludedDestinations().toArray( new ActiveMQDestination[configuration.getExcludedDestinations().size()]);	}	if (configuration.getStaticallyIncludedDestinations() != null) {	staticallyIncludedDestinations = configuration.getStaticallyIncludedDestinations().toArray( new ActiveMQDestination[configuration.getStaticallyIncludedDestinations().size()]);	}	if (configuration.getDynamicallyIncludedDestinations() != null) {	dynamicallyIncludedDestinations = configuration.getDynamicallyIncludedDestinations().toArray( new ActiveMQDestination[configuration.getDynamicallyIncludedDestinations().size()]);	}	} catch (Throwable t) {	
error mapping remote configuration 

duplexInboundLocalBroker.oneway(duplexInboundSession);	duplexInboundLocalBroker.oneway(duplexInboundLocalProducerInfo);	}	brokerService.getBroker().networkBridgeStarted(remoteBrokerInfo, this.createdByDuplex, remoteBroker.toString());	NetworkBridgeListener l = this.networkBridgeListener;	if (l != null) {	l.onStart(this);	}	localBroker.oneway(remoteBrokerInfo);	brokerService.getBroker().addBroker(null, remoteBrokerInfo);	
network connection between and has been established 

duplexInboundLocalBroker.oneway(duplexInboundLocalProducerInfo);	}	brokerService.getBroker().networkBridgeStarted(remoteBrokerInfo, this.createdByDuplex, remoteBroker.toString());	NetworkBridgeListener l = this.networkBridgeListener;	if (l != null) {	l.onStart(this);	}	localBroker.oneway(remoteBrokerInfo);	brokerService.getBroker().addBroker(null, remoteBrokerInfo);	localBroker, remoteBroker, remoteBrokerName });	
register bridge to 

brokerService.getBroker().networkBridgeStarted(remoteBrokerInfo, this.createdByDuplex, remoteBroker.toString());	NetworkBridgeListener l = this.networkBridgeListener;	if (l != null) {	l.onStart(this);	}	localBroker.oneway(remoteBrokerInfo);	brokerService.getBroker().addBroker(null, remoteBrokerInfo);	localBroker, remoteBroker, remoteBrokerName });	configuration.getBrokerName(), this, remoteBrokerName });	} else {	
bridge was disposed before the startlocalbridge method was fully executed 

public void serviceRemoteException(Throwable error) {	if (!disposed.get()) {	if (error instanceof SecurityException || error instanceof GeneralSecurityException) {	
network connection between and shutdown due to a remote error 

public void serviceRemoteException(Throwable error) {	if (!disposed.get()) {	if (error instanceof SecurityException || error instanceof GeneralSecurityException) {	localBroker, remoteBroker, error });	} else {	
network connection between and shutdown due to a remote error 

public void serviceRemoteException(Throwable error) {	if (!disposed.get()) {	if (error instanceof SecurityException || error instanceof GeneralSecurityException) {	localBroker, remoteBroker, error });	} else {	localBroker, remoteBroker, error });	}	
the remote exception was 

protected void addProxyNetworkSubscriptionClientId(final DemandSubscription sub, final String clientId, String subName) {	if (clientId != null && sub != null && subName != null) {	String newClientId = getProxyBridgeClientId(clientId);	final SubscriptionInfo newSubInfo = new SubscriptionInfo(newClientId, subName);	sub.getDurableRemoteSubs().add(newSubInfo);	
adding proxy network subscription to demand subscription 

protected void addProxyNetworkSubscriptionClientId(final DemandSubscription sub, final String clientId, String subName) {	if (clientId != null && sub != null && subName != null) {	String newClientId = getProxyBridgeClientId(clientId);	final SubscriptionInfo newSubInfo = new SubscriptionInfo(newClientId, subName);	sub.getDurableRemoteSubs().add(newSubInfo);	} else {	
skipping addproxynetworksubscription 

} else if (command.isBrokerInfo()) {	futureRemoteBrokerInfo.set((BrokerInfo) command);	} else if (command instanceof BrokerSubscriptionInfo) {	final BrokerSubscriptionInfo brokerSubscriptionInfo = (BrokerSubscriptionInfo) command;	syncExecutor.execute(new Runnable() {	public void run() {	try {	staticDestinationsLatch.await();	if (!disposed.get()) {	BrokerSubscriptionInfo subInfo = brokerSubscriptionInfo;	
received remote brokersubscriptioninfo on from 

for (Iterator<DemandSubscription> i = subscriptionMapByLocalId.values().iterator(); i.hasNext(); ) {	DemandSubscription ds = i.next();	if (NetworkBridgeUtils.matchesDestinations(dynamicallyIncludedDestinations, ds.getLocalInfo().getDestination())) {	cleanupDurableSub(ds, i);	}	}	}	}	}	} catch (Exception e) {	
error processing brokersubscriptioninfo 

} catch (Exception e) {	LOG.debug(e.getMessage(), e);	}	}	});	} else if (command.getClass() == ConnectionError.class) {	ConnectionError ce = (ConnectionError) command;	serviceRemoteException(ce.getException());	} else {	if (isDuplex()) {	
duplex command type 

if (message.isResponseRequired() || configuration.isAlwaysSyncSend()) {	duplexInboundLocalBroker.asyncRequest(message, new ResponseCallback() {	final int correlationId = message.getCommandId();	public void onCompletion(FutureResponse resp) {	try {	Response reply = resp.getResult();	reply.setCorrelationId(correlationId);	remoteBroker.oneway(reply);	networkBridgeStatistics.getReceivedCount().increment();	} catch (IOException error) {	
exception on duplex forward of 

break;	case SessionInfo.DATA_STRUCTURE_TYPE: localBroker.oneway(command);	break;	case ProducerInfo.DATA_STRUCTURE_TYPE: break;	case MessageAck.DATA_STRUCTURE_TYPE: MessageAck ack = (MessageAck) command;	DemandSubscription localSub = subscriptionMapByRemoteId.get(ack.getConsumerId());	if (localSub != null) {	ack.setConsumerId(localSub.getLocalInfo().getConsumerId());	localBroker.oneway(ack);	} else {	
matching local subscription not found for ack 

if (started.get()) {	final ConsumerInfo consumerInfo = (ConsumerInfo) command;	if (isDuplicateSuppressionOff(consumerInfo)) {	addConsumerInfo(consumerInfo);	} else {	synchronized (brokerService.getVmConnectorURI()) {	addConsumerInfo(consumerInfo);	}	}	} else {	
stopping ignoring consumerinfo 

if (isDuplicateSuppressionOff(consumerInfo)) {	addConsumerInfo(consumerInfo);	} else {	synchronized (brokerService.getVmConnectorURI()) {	addConsumerInfo(consumerInfo);	}	}	} else {	}	break;	
stopping network bridge on shutdown of remote broker 

} else {	synchronized (brokerService.getVmConnectorURI()) {	addConsumerInfo(consumerInfo);	}	}	} else {	}	break;	serviceRemoteException(new IOException(command.toString()));	break;	
ignoring remote command 

} else {	}	break;	serviceRemoteException(new IOException(command.toString()));	break;	}	}	} else {	switch (command.getDataStructureType()) {	case KeepAliveInfo.DATA_STRUCTURE_TYPE: case WireFormatInfo.DATA_STRUCTURE_TYPE: case ShutdownInfo.DATA_STRUCTURE_TYPE: break;	
unexpected remote command 

break;	}	}	} else {	switch (command.getDataStructureType()) {	case KeepAliveInfo.DATA_STRUCTURE_TYPE: case WireFormatInfo.DATA_STRUCTURE_TYPE: case ShutdownInfo.DATA_STRUCTURE_TYPE: break;	}	}	}	} catch (Throwable e) {	
exception processing remote command 

private void ackAdvisory(Message message) throws IOException {	demandConsumerDispatched++;	if (demandConsumerDispatched > (demandConsumerInfo.getPrefetchSize() * (configuration.getAdvisoryAckPercentage() / 100f))) {	final MessageAck ack = new MessageAck(message, MessageAck.STANDARD_ACK_TYPE, demandConsumerDispatched);	ack.setConsumerId(demandConsumerInfo.getConsumerId());	brokerService.getTaskRunnerFactory().execute(new Runnable() {	public void run() {	try {	remoteBroker.oneway(ack);	} catch (IOException e) {	
failed to send advisory ack 

private void serviceRemoteConsumerAdvisory(DataStructure data) throws IOException {	final int networkTTL = configuration.getConsumerTTL();	if (data.getClass() == ConsumerInfo.class) {	ConsumerInfo info = (ConsumerInfo) data;	BrokerId[] path = info.getBrokerPath();	if (info.isBrowser()) {	
ignoring sub from browsers explicitly suppressed 

private void serviceRemoteConsumerAdvisory(DataStructure data) throws IOException {	final int networkTTL = configuration.getConsumerTTL();	if (data.getClass() == ConsumerInfo.class) {	ConsumerInfo info = (ConsumerInfo) data;	BrokerId[] path = info.getBrokerPath();	if (info.isBrowser()) {	return;	}	if (path != null && networkTTL > -1 && path.length >= networkTTL) {	
ignoring sub from restricted to network hops only 

ConsumerInfo info = (ConsumerInfo) data;	BrokerId[] path = info.getBrokerPath();	if (info.isBrowser()) {	return;	}	if (path != null && networkTTL > -1 && path.length >= networkTTL) {	configuration.getBrokerName(), remoteBrokerName, networkTTL, info });	return;	}	if (contains(path, localBrokerPath[0])) {	
ignoring sub from already routed through this broker once 

}	if (path != null && networkTTL > -1 && path.length >= networkTTL) {	configuration.getBrokerName(), remoteBrokerName, networkTTL, info });	return;	}	if (contains(path, localBrokerPath[0])) {	configuration.getBrokerName(), remoteBrokerName, info });	return;	}	if (!isPermissableDestination(info.getDestination())) {	
ignoring sub from destination is not permitted 

addConsumerInfo(info);	} else {	synchronized (brokerService.getVmConnectorURI()) {	addConsumerInfo(info);	}	}	} else if (data.getClass() == DestinationInfo.class) {	final DestinationInfo destInfo = (DestinationInfo) data;	BrokerId[] path = destInfo.getBrokerPath();	if (path != null && networkTTL > -1 && path.length >= networkTTL) {	
ignoring destination restricted to network hops only 

}	}	} else if (data.getClass() == DestinationInfo.class) {	final DestinationInfo destInfo = (DestinationInfo) data;	BrokerId[] path = destInfo.getBrokerPath();	if (path != null && networkTTL > -1 && path.length >= networkTTL) {	configuration.getBrokerName(), destInfo, networkTTL });	return;	}	if (contains(destInfo.getBrokerPath(), localBrokerPath[0])) {	
ignoring destination already routed through this broker once 

}	if (contains(destInfo.getBrokerPath(), localBrokerPath[0])) {	return;	}	destInfo.setConnectionId(localConnectionInfo.getConnectionId());	if (destInfo.getDestination() instanceof ActiveMQTempDestination) {	ActiveMQTempDestination tempDest = (ActiveMQTempDestination) destInfo.getDestination();	tempDest.setConnectionId(localSessionInfo.getSessionId().getConnectionId());	}	destInfo.setBrokerPath(appendToBrokerPath(destInfo.getBrokerPath(), getRemoteBrokerPath()));	
bridging destination on from destination 

tempDest.setConnectionId(localSessionInfo.getSessionId().getConnectionId());	}	destInfo.setBrokerPath(appendToBrokerPath(destInfo.getBrokerPath(), getRemoteBrokerPath()));	configuration.getBrokerName(), (destInfo.isAddOperation() ? "add" : "remove"), localBroker, remoteBrokerName, destInfo });	if (destInfo.isRemoveOperation()) {	serialExecutor.execute(new Runnable() {	public void run() {	try {	localBroker.oneway(destInfo);	} catch (IOException e) {	
failed to deliver remove command for destination 

public void serviceLocalException(MessageDispatch messageDispatch, Throwable error) {	
servicelocalexception disposed ex 

public void serviceLocalException(MessageDispatch messageDispatch, Throwable error) {	if (!disposed.get()) {	if (error instanceof DestinationDoesNotExistException && ((DestinationDoesNotExistException) error).isTemporary()) {	if (messageDispatch != null) {	
poisonack of on forwarding error 

public void serviceLocalException(MessageDispatch messageDispatch, Throwable error) {	if (!disposed.get()) {	if (error instanceof DestinationDoesNotExistException && ((DestinationDoesNotExistException) error).isTemporary()) {	if (messageDispatch != null) {	try {	MessageAck poisonAck = new MessageAck(messageDispatch, MessageAck.POSION_ACK_TYPE, 1);	poisonAck.setPoisonCause(error);	localBroker.oneway(poisonAck);	} catch (IOException ioe) {	
failed to posion ack message following forward failure 

if (error instanceof DestinationDoesNotExistException && ((DestinationDoesNotExistException) error).isTemporary()) {	if (messageDispatch != null) {	try {	MessageAck poisonAck = new MessageAck(messageDispatch, MessageAck.POSION_ACK_TYPE, 1);	poisonAck.setPoisonCause(error);	localBroker.oneway(poisonAck);	} catch (IOException ioe) {	}	fireFailedForwardAdvisory(messageDispatch, error);	} else {	
ignoring exception on forwarding to non existent temp dest 

MessageAck poisonAck = new MessageAck(messageDispatch, MessageAck.POSION_ACK_TYPE, 1);	poisonAck.setPoisonCause(error);	localBroker.oneway(poisonAck);	} catch (IOException ioe) {	}	fireFailedForwardAdvisory(messageDispatch, error);	} else {	}	return;	}	
network connection between and shutdown due to a local error 

MessageAck poisonAck = new MessageAck(messageDispatch, MessageAck.POSION_ACK_TYPE, 1);	poisonAck.setPoisonCause(error);	localBroker.oneway(poisonAck);	} catch (IOException ioe) {	}	fireFailedForwardAdvisory(messageDispatch, error);	} else {	}	return;	}	
the local exception was 

advisoryBroker = (AdvisoryBroker) brokerService.getBroker().getAdaptor(AdvisoryBroker.class);	if (advisoryBroker != null) {	ConnectionContext context = new ConnectionContext();	context.setSecurityContext(SecurityContext.BROKER_SECURITY_CONTEXT);	context.setBroker(brokerService.getBroker());	ActiveMQMessage advisoryMessage = new ActiveMQMessage();	advisoryMessage.setStringProperty("cause", error.getLocalizedMessage());	advisoryBroker.fireAdvisory(context, AdvisorySupport.getNetworkBridgeForwardFailureAdvisoryTopic(), messageDispatch.getMessage(), null, advisoryMessage);	}	} catch (Exception e) {	
failed to fire forward failure advisory cause 

advisoryBroker = (AdvisoryBroker) brokerService.getBroker().getAdaptor(AdvisoryBroker.class);	if (advisoryBroker != null) {	ConnectionContext context = new ConnectionContext();	context.setSecurityContext(SecurityContext.BROKER_SECURITY_CONTEXT);	context.setBroker(brokerService.getBroker());	ActiveMQMessage advisoryMessage = new ActiveMQMessage();	advisoryMessage.setStringProperty("cause", error.getLocalizedMessage());	advisoryBroker.fireAdvisory(context, AdvisorySupport.getNetworkBridgeForwardFailureAdvisoryTopic(), messageDispatch.getMessage(), null, advisoryMessage);	}	} catch (Exception e) {	
detail 

protected void removeSubscription(final DemandSubscription sub) throws IOException {	if (sub != null) {	
remove local subscription for remote 

protected void removeSubscription(final DemandSubscription sub) throws IOException {	if (sub != null) {	subscriptionMapByLocalId.remove(sub.getLocalInfo().getConsumerId());	subscriptionMapByRemoteId.remove(sub.getRemoteInfo().getConsumerId());	serialExecutor.execute(new Runnable() {	public void run() {	sub.waitForCompletion();	try {	localBroker.oneway(sub.getLocalInfo().createRemoveCommand());	} catch (IOException e) {	
failed to deliver remove command for local subscription for remote 

protected void serviceLocalCommand(Command command) {	if (!disposed.get()) {	try {	if (command.isMessageDispatch()) {	safeWaitUntilStarted();	networkBridgeStatistics.getEnqueues().increment();	final MessageDispatch md = (MessageDispatch) command;	final DemandSubscription sub = subscriptionMapByLocalId.get(md.getConsumerId());	if (sub != null && md.getMessage() != null && sub.incrementOutstandingResponses()) {	if (suppressMessageDispatch(md, sub)) {	
message not forwarded to because message came from there or fails ttl brokerpath message 

if (suppressMessageDispatch(md, sub)) {	configuration.getBrokerName(), remoteBrokerName, Arrays.toString(md.getMessage().getBrokerPath()), md.getMessage() });	try {	localBroker.oneway(new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1));	} finally {	sub.decrementOutstandingResponses();	}	return;	}	Message message = configureMessage(md);	
bridging consumer destination brokerpath message 

remoteBroker.oneway(message);	localBroker.oneway(new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1));	networkBridgeStatistics.getDequeues().increment();	} finally {	sub.decrementOutstandingResponses();	}	}	serviceOutbound(message);	}	} else {	
no subscription registered with this network bridge for consumerid for message 

sub.decrementOutstandingResponses();	}	}	serviceOutbound(message);	}	} else {	}	} else if (command.isBrokerInfo()) {	futureLocalBrokerInfo.set((BrokerInfo) command);	} else if (command.isShutdownInfo()) {	
shutting down 

futureLocalBrokerInfo.set((BrokerInfo) command);	} else if (command.isShutdownInfo()) {	stop();	} else if (command.getClass() == ConnectionError.class) {	ConnectionError ce = (ConnectionError) command;	serviceLocalException(ce.getException());	} else {	switch (command.getDataStructureType()) {	case WireFormatInfo.DATA_STRUCTURE_TYPE: break;	case BrokerSubscriptionInfo.DATA_STRUCTURE_TYPE: break;	
unexpected local command 

} else if (command.getClass() == ConnectionError.class) {	ConnectionError ce = (ConnectionError) command;	serviceLocalException(ce.getException());	} else {	switch (command.getDataStructureType()) {	case WireFormatInfo.DATA_STRUCTURE_TYPE: break;	case BrokerSubscriptionInfo.DATA_STRUCTURE_TYPE: break;	}	}	} catch (Throwable e) {	
caught an exception processing local command 

ActiveMQDestination[] dests = staticallyIncludedDestinations;	if (dests != null) {	for (ActiveMQDestination dest : dests) {	if (isPermissableDestination(dest)) {	DemandSubscription sub = createDemandSubscription(dest, null);	if (sub != null) {	sub.setStaticallyIncluded(true);	try {	addSubscription(sub);	} catch (IOException e) {	
failed to add static destination 

if (dests != null) {	for (ActiveMQDestination dest : dests) {	if (isPermissableDestination(dest)) {	DemandSubscription sub = createDemandSubscription(dest, null);	if (sub != null) {	sub.setStaticallyIncluded(true);	try {	addSubscription(sub);	} catch (IOException e) {	}	
bridging messages for static destination 

for (ActiveMQDestination dest : dests) {	if (isPermissableDestination(dest)) {	DemandSubscription sub = createDemandSubscription(dest, null);	if (sub != null) {	sub.setStaticallyIncluded(true);	try {	addSubscription(sub);	} catch (IOException e) {	}	} else {	
static destination excluded demand already exists 

DemandSubscription sub = createDemandSubscription(dest, null);	if (sub != null) {	sub.setStaticallyIncluded(true);	try {	addSubscription(sub);	} catch (IOException e) {	}	} else {	}	} else {	
static destination excluded 

if (isProxyNSConsumerBrokerPath(sub.getRemoteInfo()) && info.getSubscriptionName() != null && info.getSubscriptionName().startsWith(DURABLE_SUB_PREFIX)) {	final BrokerId[] path = info.getBrokerPath();	addProxyNetworkSubscriptionBrokerPath(sub, path, consumerInfo.getSubscriptionName());	} else if (isProxyNSConsumerClientId(sub.getRemoteInfo().getClientId()) && isProxyBridgeSubscription(info.getClientId(), info.getSubscriptionName())) {	addProxyNetworkSubscriptionClientId(sub, sub.getRemoteInfo().getClientId(), consumerInfo.getSubscriptionName());	} else {	sub.getDurableRemoteSubs().add(new SubscriptionInfo(sub.getRemoteInfo().getClientId(), consumerInfo.getSubscriptionName()));	}	}	addSubscription(sub);	
new demand subscription 

private boolean hasLowerPriority(Subscription existingSub, ConsumerInfo candidateInfo) {	boolean suppress = false;	if (existingSub.getConsumerInfo().getPriority() >= candidateInfo.getPriority()) {	
ignoring duplicate subscription from sub is duplicate by network subscription with equal or higher network priority networkconsumerids 

private boolean hasLowerPriority(Subscription existingSub, ConsumerInfo candidateInfo) {	boolean suppress = false;	if (existingSub.getConsumerInfo().getPriority() >= candidateInfo.getPriority()) {	configuration.getBrokerName(), remoteBrokerName, candidateInfo, existingSub, existingSub.getConsumerInfo().getNetworkConsumerIds() });	suppress = true;	} else {	try {	removeDuplicateSubscription(existingSub);	
replacing duplicate subscription with sub from which has a higher priority new sub networkconsumerids 

private boolean hasLowerPriority(Subscription existingSub, ConsumerInfo candidateInfo) {	boolean suppress = false;	if (existingSub.getConsumerInfo().getPriority() >= candidateInfo.getPriority()) {	configuration.getBrokerName(), remoteBrokerName, candidateInfo, existingSub, existingSub.getConsumerInfo().getNetworkConsumerIds() });	suppress = true;	} else {	try {	removeDuplicateSubscription(existingSub);	configuration.getBrokerName(), existingSub.getConsumerInfo(), remoteBrokerName, candidateInfo, candidateInfo.getNetworkConsumerIds() });	} catch (IOException e) {	
failed to remove duplicated sub as a result of sub with higher priority sub 

if (info.getDestination().isTemporary()) {	ActiveMQTempDestination dest = (ActiveMQTempDestination) result.getLocalInfo().getDestination();	dest.setConnectionId(localConnectionInfo.getConnectionId().toString());	}	if (configuration.isDecreaseNetworkConsumerPriority()) {	byte priority = (byte) configuration.getConsumerPriorityBase();	if (info.getBrokerPath() != null && info.getBrokerPath().length > 1) {	priority -= info.getBrokerPath().length + 1;	}	result.getLocalInfo().setPriority(priority);	
using priority for subscription 

protected void removeDemandSubscription(ConsumerId id) throws IOException {	DemandSubscription sub = subscriptionMapByRemoteId.remove(id);	
remove request on from consumer id matching sub 

protected void removeDemandSubscription(ConsumerId id) throws IOException {	DemandSubscription sub = subscriptionMapByRemoteId.remove(id);	configuration.getBrokerName(), localBroker, remoteBrokerName, id, sub });	if (sub != null) {	removeSubscription(sub);	
removed sub on from 

protected boolean removeDemandSubscriptionByLocalId(ConsumerId consumerId) {	boolean removeDone = false;	DemandSubscription sub = subscriptionMapByLocalId.get(consumerId);	if (sub != null) {	try {	removeDemandSubscription(sub.getRemoteInfo().getConsumerId());	removeDone = true;	} catch (IOException e) {	
removedemandsubscriptionbylocalid failed for localid 

private void fireBridgeFailed(Throwable reason) {	
fire bridge failed listener 

if (info == null) {	while (!disposed.get()) {	if (slot.await(1, TimeUnit.SECONDS)) {	break;	}	}	}	return info;	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	
operation interrupted 

protected boolean canDuplexDispatch(Message message) {	boolean result = true;	if (configuration.isCheckDuplicateMessagesOnDuplex()){	final long producerSequenceId = message.getMessageId().getProducerSequenceId();	long lastStoredForMessageProducer = getStoredSequenceIdForMessage(message.getMessageId());	if (producerSequenceId <= lastStoredForMessageProducer) {	result = false;	
suppressing duplicate message send from network producer with producersequence less than last stored 

protected long getStoredSequenceIdForMessage(MessageId messageId) {	try {	return brokerService.getPersistenceAdapter().getLastProducerSequenceId(messageId.getProducerId());	} catch (IOException ignored) {	
failed to determine last producer sequence id for 

========================= activemq sample_4244 =========================

private void createProducerAndSendMessages(int numToSend) throws Exception {	session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(queue);	for (int i = 0; i < numToSend; i++) {	TextMessage message = session.createTextMessage("Test Text Message: " + i);	if (i  != 0 && i % 10000 == 0) {	
sent 

========================= activemq sample_3651 =========================

public void testFDSLeak() throws Exception {	ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(connectionURI);	ActiveMQConnection connection = (ActiveMQConnection) factory.createConnection();	connection.start();	int connections = 100;	final long original = openFileDescriptorCount();	
fd count 

connection.start();	} catch (Exception e) {	LOG.debug(getStack(e));	} finally {	try {	connection.close();	} catch (Exception e) {	LOG.debug(getStack(e));	}	done.countDown();	
latch count down called 

try {	connection.close();	} catch (Exception e) {	LOG.debug(getStack(e));	}	done.countDown();	}	}	}.start();	}	
waiting for latch 

connection.close();	} catch (Exception e) {	LOG.debug(getStack(e));	}	done.countDown();	}	}	}.start();	}	done.await();	
latch complete 

connection.close();	} catch (Exception e) {	LOG.debug(getStack(e));	}	done.countDown();	}	}	}.start();	}	done.await();	
fd count 

}	done.countDown();	}	}	}.start();	}	done.await();	assertTrue("Too many open file descriptors: " + openFileDescriptorCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	long openFDs = openFileDescriptorCount();	
current fd count original fd count 

========================= activemq sample_2943 =========================

private void doStartBroker(boolean delete) throws Exception {	doCreateBroker(delete);	
starting broker 

public void testStopOnPageInIOError() throws Exception {	startBroker();	int sent = produceMessagesToConsumeMultipleDataFiles(50);	int numFiles = getNumberOfJournalFiles();	
num journal files 

public void testRecoveryAfterCorruption() throws Exception {	startBroker();	produceMessagesToConsumeMultipleDataFiles(50);	int numFiles = getNumberOfJournalFiles();	
num journal files 

produceMessagesToConsumeMultipleDataFiles(50);	int numFiles = getNumberOfJournalFiles();	assertTrue("more than x files: " + numFiles, numFiles > 4);	File dataDir = broker.getPersistenceAdapter().getDirectory();	if (broker != null) {	broker.stop();	broker.waitUntilStopped();	}	long afterStop = totalOpenFileDescriptorCount(broker);	whackIndex(dataDir);	
num open files with broker stopped 

int numFiles = getNumberOfJournalFiles();	assertTrue("more than x files: " + numFiles, numFiles > 4);	File dataDir = broker.getPersistenceAdapter().getDirectory();	if (broker != null) {	broker.stop();	broker.waitUntilStopped();	}	long afterStop = totalOpenFileDescriptorCount(broker);	whackIndex(dataDir);	doStartBroker(false);	
journal read pool 

File dataDir = broker.getPersistenceAdapter().getDirectory();	if (broker != null) {	broker.stop();	broker.waitUntilStopped();	}	long afterStop = totalOpenFileDescriptorCount(broker);	whackIndex(dataDir);	doStartBroker(false);	assertEquals("one entry in the pool on start", 1, adapter.getStore().getJournal().getAccessorPool().size());	long afterRecovery = totalOpenFileDescriptorCount(broker);	
num open files with broker recovered 

public void testRecoveryWithMissingMssagesWithValidAcks() throws Exception {	doCreateBroker(true);	adapter.setCheckpointInterval(50000);	adapter.setCleanupInterval(50000);	broker.start();	int toSend = 50;	produceMessagesToConsumeMultipleDataFiles(toSend);	int numFiles = getNumberOfJournalFiles();	
num files 

public void testRecoveryWithMissingMssagesWithValidAcks() throws Exception {	doCreateBroker(true);	adapter.setCheckpointInterval(50000);	adapter.setCleanupInterval(50000);	broker.start();	int toSend = 50;	produceMessagesToConsumeMultipleDataFiles(toSend);	int numFiles = getNumberOfJournalFiles();	assertTrue("more than x files: " + numFiles, numFiles > 5);	assertEquals("Drain", 30, tryConsume(destination, 30));	
num files after stopped 

produceMessagesToConsumeMultipleDataFiles(toSend);	int numFiles = getNumberOfJournalFiles();	assertTrue("more than x files: " + numFiles, numFiles > 5);	assertEquals("Drain", 30, tryConsume(destination, 30));	File dataDir = broker.getPersistenceAdapter().getDirectory();	broker.stop();	broker.waitUntilStopped();	whackDataFile(dataDir, 4);	whackIndex(dataDir);	doStartBroker(false);	
num files after restarted 

broker.start();	int toSend = 20000;	payload = new String(new byte[100]);	produceMessagesToConsumeMultipleDataFiles(toSend);	broker.stop();	broker.waitUntilStopped();	Instant b = Instant.now();	doStartBroker(false);	Instant e = Instant.now();	Duration timeElapsed = Duration.between(b, e);	
elapsed 

private void whackFile(File dataDir, String name) throws Exception {	File indexToDelete = new File(dataDir, name);	
whacking index 

========================= activemq sample_1729 =========================

public SlowCloseSocket(InetAddress host, int port) throws IOException {	super(host, port);	}	public SlowCloseSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {	super(host, port, localHost, localPort);	}	public SlowCloseSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {	super(address, port, localAddress, localPort);	}	public synchronized void close() throws IOException {	
delaying close 

public void onException(JMSException exception) {	
exception listener exception 

public void onCommand(Object command) {}	public void onException(IOException error) {	
transport listener exception 

========================= activemq sample_3597 =========================

public void testDestinationNames() throws Exception {	
started waiting for broker and 

public void testDestinationNames() throws Exception {	broker1.waitUntilStarted();	broker2.waitUntilStarted();	
broker and have started 

public void testDestinationNames() throws Exception {	broker1.waitUntilStarted();	broker2.waitUntilStarted();	init();	CountDownLatch monitor = new CountDownLatch(2);	listener1.setCountDown(monitor);	listener2.setCountDown(monitor);	
sending message 

public void testDestinationNames() throws Exception {	broker1.waitUntilStarted();	broker2.waitUntilStarted();	init();	CountDownLatch monitor = new CountDownLatch(2);	listener1.setCountDown(monitor);	listener2.setCountDown(monitor);	TextMessage message = session1.createTextMessage("Hello World !");	producer.send(message);	
waiting for message reception 

========================= activemq sample_2386 =========================

if (version >= 5 && is.readBoolean()) {	ackMessageFileMapLocation = LocationMarshaller.INSTANCE.readPayload(is);	} else {	ackMessageFileMapLocation = null;	}	try {	openwireVersion = is.readInt();	} catch (EOFException expectedOnUpgrade) {	openwireVersion = OpenWireFormat.DEFAULT_LEGACY_VERSION;	}	
kahadb is version 

private void startCheckpoint() {	if (checkpointInterval == 0 && cleanupInterval == 0) {	
periodic checkpoint cleanup disabled will ocurr on clean shutdown restart 

public void run() {	try {	if (opened.get()) {	long now = System.currentTimeMillis();	if (journal.isJournalDiskSyncPeriodic() && journalDiskSyncInterval > 0 && (now - lastSync >= journalDiskSyncInterval)) {	Location currentUpdate = lastAsyncJournalUpdate.get();	if (currentUpdate != null && !currentUpdate.equals(lastAsyncUpdate)) {	lastAsyncUpdate = currentUpdate;	if (LOG.isTraceEnabled()) {	
writing trace command to trigger journal sync 

if (cleanupInterval > 0 && (now - lastCleanup >= cleanupInterval)) {	checkpointCleanup(true);	lastCleanup = now;	lastCheckpoint = now;	} else if (checkpointInterval > 0 && (now - lastCheckpoint >= checkpointInterval)) {	checkpointCleanup(false);	lastCheckpoint = now;	}	}	} catch (IOException ioe) {	
checkpoint failed 

lastCleanup = now;	lastCheckpoint = now;	} else if (checkpointInterval > 0 && (now - lastCheckpoint >= checkpointInterval)) {	checkpointCleanup(false);	lastCheckpoint = now;	}	}	} catch (IOException ioe) {	brokerService.handleIOException(ioe);	} catch (Throwable e) {	
checkpoint failed 

public void open() throws IOException {	if( opened.compareAndSet(false, true) ) {	getJournal().start();	try {	loadPageFile();	} catch (Throwable t) {	
index corrupted recovering the index through journal replay cause 

public void open() throws IOException {	if( opened.compareAndSet(false, true) ) {	getJournal().start();	try {	loadPageFile();	} catch (Throwable t) {	if (LOG.isDebugEnabled()) {	
index load failure 

this.indexLock.writeLock().lock();	try {	IOHelper.mkdirs(directory);	if (deleteAllMessages) {	getJournal().setCheckForCorruptionOnStartup(false);	getJournal().start();	getJournal().delete();	getJournal().close();	journal = null;	getPageFile().delete();	
persistence store purged 

this.indexLock.writeLock().lock();	try {	long start = System.currentTimeMillis();	boolean requiresJournalReplay = recoverProducerAudit();	requiresJournalReplay |= recoverAckMessageFileMap();	Location lastIndoubtPosition = getRecoveryPosition();	Location recoveryPosition = requiresJournalReplay ? journal.getNextLocation(null) : lastIndoubtPosition;	if (recoveryPosition != null) {	int redoCounter = 0;	int dataFileRotationTracker = recoveryPosition.getDataFileId();	
recovering from the journal 

int redoCounter = 0;	int dataFileRotationTracker = recoveryPosition.getDataFileId();	while (recoveryPosition != null) {	try {	JournalCommand<?> message = load(recoveryPosition);	metadata.lastUpdate = recoveryPosition;	process(message, recoveryPosition, lastIndoubtPosition);	redoCounter++;	} catch (IOException failedRecovery) {	if (isIgnoreMissingJournalfiles()) {	
failed to recover data at position 

} else {	throw new IOException("Failed to recover data at position:" + recoveryPosition, failedRecovery);	}	}	recoveryPosition = journal.getNextLocation(recoveryPosition);	if (recoveryPosition != null && dataFileRotationTracker != recoveryPosition.getDataFileId()) {	dataFileRotationTracker = recoveryPosition.getDataFileId();	journal.cleanup();	}	if (LOG.isInfoEnabled() && redoCounter % 100000 == 0) {	
entries recovered 

recoveryPosition = journal.getNextLocation(recoveryPosition);	if (recoveryPosition != null && dataFileRotationTracker != recoveryPosition.getDataFileId()) {	dataFileRotationTracker = recoveryPosition.getDataFileId();	journal.cleanup();	}	if (LOG.isInfoEnabled() && redoCounter % 100000 == 0) {	}	}	if (LOG.isInfoEnabled()) {	long end = System.currentTimeMillis();	
recovery replayed operations from the journal in seconds 

for (Iterator<TransactionId> it = inflightTransactions.keySet().iterator(); it.hasNext(); ) {	TransactionId id = it.next();	if (id.isLocalTransaction()) {	toRollback.add(id);	} else {	toDiscard.add(id);	}	}	for (TransactionId tx: toRollback) {	if (LOG.isDebugEnabled()) {	
rolling back recovered indoubt local transaction 

toDiscard.add(id);	}	}	for (TransactionId tx: toRollback) {	if (LOG.isDebugEnabled()) {	}	store(new KahaRollbackCommand().setTransactionInfo(TransactionIdConversion.convertToLocal(tx)), false, null, null);	}	for (TransactionId tx: toDiscard) {	if (LOG.isDebugEnabled()) {	
discarding recovered in flight xa transaction 

store(new KahaRollbackCommand().setTransactionInfo(TransactionIdConversion.convertToLocal(tx)), false, null, null);	}	for (TransactionId tx: toDiscard) {	if (LOG.isDebugEnabled()) {	}	inflightTransactions.remove(tx);	}	}	synchronized (preparedTransactions) {	for (TransactionId txId : preparedTransactions.keySet()) {	
recovered prepared xa tx 

try {	KahaProducerAuditCommand audit = (KahaProducerAuditCommand) load(metadata.producerSequenceIdTrackerLocation);	ObjectInputStream objectIn = new ObjectInputStream(audit.getAudit().newInput());	int maxNumProducers = getMaxFailoverProducersToTrack();	int maxAuditDepth = getFailoverProducersAuditDepth();	metadata.producerSequenceIdTracker = (ActiveMQMessageAuditNoSync) objectIn.readObject();	metadata.producerSequenceIdTracker.setAuditDepth(maxAuditDepth);	metadata.producerSequenceIdTracker.setMaximumNumberOfProducersToTrack(maxNumProducers);	requiresReplay = false;	} catch (Exception e) {	
cannot recover message audit 

private boolean recoverAckMessageFileMap() throws IOException {	boolean requiresReplay = true;	if (metadata.ackMessageFileMapLocation != null) {	try {	KahaAckMessageFileMapCommand audit = (KahaAckMessageFileMapCommand) load(metadata.ackMessageFileMapLocation);	ObjectInputStream objectIn = new ObjectInputStream(audit.getAckMessageFileMap().newInput());	metadata.ackMessageFileMap = (Map<Integer, Set<Integer>>) objectIn.readObject();	requiresReplay = false;	} catch (Exception e) {	
cannot recover ackmessagefilemap 

sd.messageIdIndex.remove(tx, keys.messageId);	metadata.producerSequenceIdTracker.rollback(keys.messageId);	undoCounter++;	decrementAndSubSizeToStoreStat(key, keys.location.getSize());	}	}	}	if (undoCounter > 0) {	if (LOG.isInfoEnabled()) {	long end = System.currentTimeMillis();	
rolled back messages from the index in seconds 

missingJournalFiles.add((int) ss.removeFirst());	}	for (Entry<Integer, Set<Integer>> entry : metadata.ackMessageFileMap.entrySet()) {	missingJournalFiles.add(entry.getKey());	for (Integer i : entry.getValue()) {	missingJournalFiles.add(i);	}	}	missingJournalFiles.removeAll(journal.getFileMap().keySet());	if (!missingJournalFiles.isEmpty()) {	
some journal files are missing 

protected void matched(Location key, Long value) {	matches.put(value, key);	}	});	if (!matches.isEmpty()) {	if( ignoreMissingJournalfiles ) {	for (Long sequenceId : matches.keySet()) {	MessageKeys keys = sd.orderIndex.remove(tx, sequenceId);	sd.locationIndex.remove(tx, keys.location);	sd.messageIdIndex.remove(tx, keys.messageId);	
dropped at corrupt location 

if (!matches.isEmpty()) {	if( ignoreMissingJournalfiles ) {	for (Long sequenceId : matches.keySet()) {	MessageKeys keys = sd.orderIndex.remove(tx, sequenceId);	sd.locationIndex.remove(tx, keys.location);	sd.messageIdIndex.remove(tx, keys.messageId);	undoCounter++;	decrementAndSubSizeToStoreStat(sdEntry.getKey(), keys.location.getSize());	}	} else {	
references corrupt locations 

decrementAndSubSizeToStoreStat(sdEntry.getKey(), keys.location.getSize());	}	} else {	throw new IOException("Detected missing/corrupt journal files referenced by:[" + sdEntry.getKey() + "] " +matches.size()+" messages affected.");	}	}	}	}	if (!ignoreMissingJournalfiles) {	if (!knownCorruption.isEmpty()) {	
detected corrupt journal files 

throw new IOException("Detected missing/corrupt journal files referenced by:[" + sdEntry.getKey() + "] " +matches.size()+" messages affected.");	}	}	}	}	if (!ignoreMissingJournalfiles) {	if (!knownCorruption.isEmpty()) {	throw new IOException("Detected corrupt journal files. " + knownCorruption);	}	if (!missingJournalFiles.isEmpty()) {	
detected missing journal files 

if (!knownCorruption.isEmpty()) {	throw new IOException("Detected corrupt journal files. " + knownCorruption);	}	if (!missingJournalFiles.isEmpty()) {	throw new IOException("Detected missing journal files. " + missingJournalFiles);	}	}	if (undoCounter > 0) {	if (LOG.isInfoEnabled()) {	long end = System.currentTimeMillis();	
detected missing corrupt journal files dropped messages from the index in seconds 

if( !opened.get() ) {	return;	}	} finally {	this.indexLock.writeLock().unlock();	}	checkpointUpdate(cleanup);	long end = System.currentTimeMillis();	if (LOG_SLOW_ACCESS_TIME > 0 && end - start > LOG_SLOW_ACCESS_TIME) {	if (LOG.isInfoEnabled()) {	
slow kahadb access cleanup took 

long start = System.currentTimeMillis();	location = onJournalStoreComplete == null ? journal.write(sequence, sync) : journal.write(sequence, onJournalStoreComplete) ;	long start2 = System.currentTimeMillis();	if (!sync && journal.isJournalDiskSyncPeriodic()) {	lastAsyncJournalUpdate.set(location);	}	process(data, location, before);	long end = System.currentTimeMillis();	if (LOG_SLOW_ACCESS_TIME > 0 && end - start > LOG_SLOW_ACCESS_TIME) {	if (LOG.isInfoEnabled()) {	
slow kahadb access journal append took ms index update took ms 

checkpointLock.readLock().unlock();	}	if (after != null) {	after.run();	}	if (scheduler == null && opened.get()) {	startCheckpoint();	}	return location;	} catch (IOException ioe) {	
kahadb failed to store to journal command of type 

public JournalCommand<?> load(Location location) throws IOException {	long start = System.currentTimeMillis();	ByteSequence data = journal.read(location);	long end = System.currentTimeMillis();	if( LOG_SLOW_ACCESS_TIME>0 && end-start > LOG_SLOW_ACCESS_TIME) {	if (LOG.isInfoEnabled()) {	
slow kahadb access journal read took ms 

return;	}	journalLogsReferenced.addAll(metadata.ackMessageFileMap.get(journalToAdvance));	} finally {	indexLock.writeLock().unlock();	}	try {	forwardAllAcks(journalToAdvance, journalLogsReferenced);	forwarded = true;	} catch (IOException ioe) {	
forwarding of acks failed 

journalLogsReferenced.addAll(metadata.ackMessageFileMap.get(journalToAdvance));	} finally {	indexLock.writeLock().unlock();	}	try {	forwardAllAcks(journalToAdvance, journalLogsReferenced);	forwarded = true;	} catch (IOException ioe) {	brokerService.handleIOException(ioe);	} catch (Throwable e) {	
forwarding of acks failed 

brokerService.handleIOException(IOExceptionSupport.create(e));	}	} finally {	checkpointLock.readLock().unlock();	}	try {	if (forwarded) {	checkpointUpdate(false);	}	} catch (IOException ioe) {	
checkpoint failed 

} finally {	checkpointLock.readLock().unlock();	}	try {	if (forwarded) {	checkpointUpdate(false);	}	} catch (IOException ioe) {	brokerService.handleIOException(ioe);	} catch (Throwable e) {	
checkpoint failed 

private Location getNextLocationForAckForward(final Location nextLocation, final Location limit) {	Location location = null;	try {	location = journal.getNextLocation(nextLocation, limit);	} catch (IOException e) {	
failed to load next journal location after reason 

private Location getNextLocationForAckForward(final Location nextLocation, final Location limit) {	Location location = null;	try {	location = journal.getNextLocation(nextLocation, limit);	} catch (IOException e) {	if (LOG.isDebugEnabled()) {	
failed to load next journal location after 

protected MessageStoreStatistics getStoreStats(String kahaDestKey) {	MessageStoreStatistics storeStats = null;	try {	MessageStore messageStore = storeCache.get(kahaDestKey);	if (messageStore != null) {	storeStats = messageStore.getMessageStoreStatistics();	}	} catch (Exception e1) {	
getting size counter of destination failed 

protected MessageStoreSubscriptionStatistics getSubStats(String kahaDestKey) {	MessageStoreSubscriptionStatistics subStats = null;	try {	MessageStore messageStore = storeCache.get(kahaDestKey);	if (messageStore instanceof TopicMessageStore) {	subStats = ((TopicMessageStore)messageStore).getMessageStoreSubStatistics();	}	} catch (Exception e1) {	
getting size counter of destination failed 

========================= activemq sample_1816 =========================

assertEquals(1, subs.length);	ObjectName subName = subs[0];	DurableSubscriptionViewMBean sub = (DurableSubscriptionViewMBean) broker.getManagementContext().newProxyInstance(subName, DurableSubscriptionViewMBean.class, true);	CompositeData[] data  = sub.browse();	assertNotNull(data);	assertEquals(10, data.length);	LinkedList<String> idToRemove = new LinkedList<>();	idToRemove.add((String)data[5].get("JMSMessageID"));	idToRemove.add((String)data[9].get("JMSMessageID"));	idToRemove.add((String)data[0].get("JMSMessageID"));	
removing 

}	data  = sub.browse();	assertNotNull(data);	assertEquals(7, data.length);	for (CompositeData c: data) {	String id = (String)c.get("JMSMessageID");	for (String removedId : idToRemove) {	assertNotEquals(id, removedId);	}	}	
repeat remove 

========================= activemq sample_3578 =========================

public void tearDown() throws Exception {	try {	stompDisconnect();	} catch(Exception e) {	} finally {	try {	super.tearDown();	} catch (Exception ex) {	
error on super teardown 

========================= activemq sample_1115 =========================

protected BrokerService createBroker() throws Exception {	BrokerService broker = new BrokerService();	broker.getSystemUsage().getMemoryUsage().setLimit(1 * 1024 * 1024);	broker.deleteAllMessages();	PolicyMap policyMap = new PolicyMap();	PolicyEntry policyEntry = new PolicyEntry();	policyEntry.setExpireMessagesPeriod(0);	policyEntry.setProducerFlowControl(false);	policyMap.put(new ActiveMQQueue(">"), policyEntry);	broker.setDestinationPolicy(policyMap);	
starting broker with persistenceadapterchoice 

BytesMessage bytesMessage = session.createBytesMessage();	bytesMessage.writeBytes(payload);	return bytesMessage;	}	};	producer.setMessageCount(2000);	producer.start();	producer.join();	Thread.sleep(1000);	final Destination dest = broker.getDestination((ActiveMQQueue) queue);	
destination usage 

return bytesMessage;	}	};	producer.setMessageCount(2000);	producer.start();	producer.join();	Thread.sleep(1000);	final Destination dest = broker.getDestination((ActiveMQQueue) queue);	int percentUsage = dest.getMemoryUsage().getPercentUsage();	assertTrue("Should be less than 70% of limit but was: " + percentUsage, percentUsage <= 71);	
broker usage 

Thread.sleep(1000);	final Destination dest = broker.getDestination((ActiveMQQueue) queue);	int percentUsage = dest.getMemoryUsage().getPercentUsage();	assertTrue("Should be less than 70% of limit but was: " + percentUsage, percentUsage <= 71);	assertTrue(broker.getSystemUsage().getMemoryUsage().getPercentUsage() <= 71);	MessageConsumer consumer = sess.createConsumer(queue);	Message msg = consumer.receive(5000);	msg.acknowledge();	assertTrue("Limit is exceeded", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
destination usage 

assertTrue("Should be less than 70% of limit but was: " + percentUsage, percentUsage <= 71);	assertTrue(broker.getSystemUsage().getMemoryUsage().getPercentUsage() <= 71);	MessageConsumer consumer = sess.createConsumer(queue);	Message msg = consumer.receive(5000);	msg.acknowledge();	assertTrue("Limit is exceeded", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return dest.getMemoryUsage().getPercentUsage() >= 200;	}	}));	
broker usage 

========================= activemq sample_3606 =========================

public synchronized void updateHeartBeat() {	lastHeartBeat = System.currentTimeMillis();	if (!failed && failureCount > 0 && (lastHeartBeat - recoveryTime) > 1000 * 60) {	if (LOG.isDebugEnabled()) {	
i now think that the service has recovered 

long reconnectDelay;	if (!useExponentialBackOff) {	reconnectDelay = initialReconnectDelay;	} else {	reconnectDelay = (long)Math.pow(backOffMultiplier, failureCount);	if (reconnectDelay > maxReconnectDelay) {	reconnectDelay = maxReconnectDelay;	}	}	if (LOG.isDebugEnabled()) {	
remote failure of while still receiving multicast advertisements advertising events will be suppressed for ms the current failure count is 

public synchronized boolean doRecovery() {	if (!failed) {	return false;	}	if (maxReconnectAttempts > 0 && failureCount > maxReconnectAttempts) {	if (LOG.isDebugEnabled()) {	
max reconnect attempts of the service has been reached 

}	if (maxReconnectAttempts > 0 && failureCount > maxReconnectAttempts) {	if (LOG.isDebugEnabled()) {	}	return false;	}	if (System.currentTimeMillis() < recoveryTime) {	return false;	}	if (LOG.isDebugEnabled()) {	
resuming event advertisement of the service 

public void start() throws Exception {	if (started.compareAndSet(false, true)) {	if (group == null || group.length() == 0) {	throw new IOException("You must specify a group to discover");	}	String type = getType();	if (!type.endsWith(".")) {	
the type should end with to be a valid discovery type 

doTimeKeepingServices();	try {	mcast.receive(packet);	if (packet.getLength() > 0) {	String str = new String(packet.getData(), packet.getOffset(), packet.getLength());	processData(str);	}	} catch (SocketTimeoutException se) {	} catch (IOException e) {	if (started.get()) {	
failed to process packet 

payload += started.get() ? ALIVE : DEAD;	payload += DELIMITER + "localhost" + DELIMITER;	payload += selfService;	try {	byte[] data = payload.getBytes();	DatagramPacket packet = new DatagramPacket(data, 0, data.length, sockAddress);	mcast.send(packet);	} catch (IOException e) {	if (reportAdvertizeFailed) {	reportAdvertizeFailed = false;	
failed to advertise our service 

payload += DELIMITER + "localhost" + DELIMITER;	payload += selfService;	try {	byte[] data = payload.getBytes();	DatagramPacket packet = new DatagramPacket(data, 0, data.length, sockAddress);	mcast.send(packet);	} catch (IOException e) {	if (reportAdvertizeFailed) {	reportAdvertizeFailed = false;	if ("Operation not permitted".equals(e.getMessage())) {	
the operation not permitted error has been know to be caused by improper firewall network setup please make sure that the os is properly configured to allow multicast traffic over 

========================= activemq sample_86 =========================

public void tearDown() throws Exception {	
shutting down 

public void tearDown() throws Exception {	if (broker != null && broker.isStarted()) {	
broker still running stopping it now 

public void tearDown() throws Exception {	if (broker != null && broker.isStarted()) {	broker.stop();	}	else {	
broker not running nothing to shutdown 

public void testDestinationWildcardThreeEntries() throws Exception {	
testdestinationwildcard called 

PolicyMap policyMap = new PolicyMap();	policyMap.setPolicyEntries(entries);	broker.setDestinationPolicy(policyMap);	broker.start();	broker.waitUntilStarted();	Assert.assertNotNull(broker);	ManagedRegionBroker rb = (ManagedRegionBroker) broker.getRegionBroker();	org.apache.activemq.broker.region.Queue queue = (Queue) rb.addDestination(new ConnectionContext(), new ActiveMQQueue(DESTNAME), true);	Assert.assertTrue("PolicyEntry should have priorityMessages enabled for destination " + DESTNAME, queue.isPrioritizedMessages());	long limit = queue.getMemoryUsage().getLimit();	
memorylimit of expected actual 

public void testDestinationWildcardTwoEntries() throws Exception {	
testdestinationwildcard called 

PolicyMap policyMap = new PolicyMap();	policyMap.setPolicyEntries(entries);	broker.setDestinationPolicy(policyMap);	broker.start();	broker.waitUntilStarted();	Assert.assertNotNull(broker);	ManagedRegionBroker rb = (ManagedRegionBroker) broker.getRegionBroker();	org.apache.activemq.broker.region.Queue queue = (Queue) rb.addDestination(new ConnectionContext(), new ActiveMQQueue(DESTNAME), true);	Assert.assertTrue("PolicyEntry should have priorityMessages enabled for destination " + DESTNAME, queue.isPrioritizedMessages());	long limit = queue.getMemoryUsage().getLimit();	
memorylimit of expected actual 

public void testDestinationWildcardOneEntry() throws Exception {	
called 

entries.add(e1);	PolicyMap policyMap = new PolicyMap();	policyMap.setPolicyEntries(entries);	broker.setDestinationPolicy(policyMap);	broker.start();	broker.waitUntilStarted();	ManagedRegionBroker rb = (ManagedRegionBroker) broker.getRegionBroker();	org.apache.activemq.broker.region.Queue queue = (Queue) rb.addDestination(new ConnectionContext(), new ActiveMQQueue(DESTNAME), true);	Assert.assertTrue("PolicyEntry should have priorityMessages enabled for destination " + DESTNAME, queue.isPrioritizedMessages());	long limit = queue.getMemoryUsage().getLimit();	
memorylimit of expected actual DomainA 

========================= activemq sample_2447 =========================

connection1.send(connectionInfo1);	connection1.send(sessionInfo1);	connection1.request(consumerInfo1);	StubConnection connection2 = createRemoteConnection();	ConnectionInfo connectionInfo2 = createConnectionInfo();	SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);	ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);	connection2.send(connectionInfo2);	connection2.send(sessionInfo2);	connection2.request(consumerInfo2);	
starting the fanout connection 

connection1.send(connectionInfo1);	connection1.send(sessionInfo1);	connection1.request(consumerInfo1);	StubConnection connection2 = createRemoteConnection();	ConnectionInfo connectionInfo2 = createConnectionInfo();	SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);	ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);	connection2.send(connectionInfo2);	connection2.send(sessionInfo2);	connection2.request(consumerInfo2);	
starting the fanout connection 

connection3.send(producerInfo3);	connection3.request(createMessage(producerInfo3, destination, deliveryMode));	assertNotNull(receiveMessage(connection1));	assertNoMessagesLeft(connection1);	assertNotNull(receiveMessage(connection2));	assertNoMessagesLeft(connection2);	final CountDownLatch publishDone = new CountDownLatch(1);	MockTransport mt = (MockTransport)connection3.getTransport().narrow(MockTransport.class);	mt.install(new TransportFilter(mt.getNext()) {	public void oneway(Object command) throws IOException {	
dropping 

public void run() {	try {	connection3.request(createMessage(producerInfo3, destination, deliveryMode));	} catch (Throwable e) {	e.printStackTrace();	}	publishDone.countDown();	}	}.start();	assertFalse(publishDone.await(3, TimeUnit.SECONDS));	
restarting broker 

try {	connection3.request(createMessage(producerInfo3, destination, deliveryMode));	} catch (Throwable e) {	e.printStackTrace();	}	publishDone.countDown();	}	}.start();	assertFalse(publishDone.await(3, TimeUnit.SECONDS));	restartRemoteBroker();	
broker restarted 

========================= activemq sample_2502 =========================

public void onMessage(Message message) {	synchronized (messages) {	messages.add(message);	if (verbose) {	
received 

public void waitForMessageToArrive() {	
waiting for message to arrive 

public void waitForMessageToArrive() {	long start = System.currentTimeMillis();	try {	if (hasReceivedMessage()) {	synchronized (messages) {	messages.wait(4000);	}	}	} catch (InterruptedException e) {	
caught 

long start = System.currentTimeMillis();	try {	if (hasReceivedMessage()) {	synchronized (messages) {	messages.wait(4000);	}	}	} catch (InterruptedException e) {	}	long end = System.currentTimeMillis() - start;	
end of wait for millis 

public void waitForMessagesToArrive(int messageCount,long maxWaitTime) {	long maxRemainingMessageCount = Math.max(0, messageCount - messages.size());	
waiting for message s to arrive 

long endTime = start + maxWaitTime;	while (maxRemainingMessageCount > 0) {	try {	synchronized (messages) {	messages.wait(1000);	}	if (hasReceivedMessages(messageCount) || System.currentTimeMillis() > endTime) {	break;	}	} catch (InterruptedException e) {	
caught 

messages.wait(1000);	}	if (hasReceivedMessages(messageCount) || System.currentTimeMillis() > endTime) {	break;	}	} catch (InterruptedException e) {	}	maxRemainingMessageCount = Math.max(0, messageCount - messages.size());	}	long end = System.currentTimeMillis() - start;	
end of wait for millis 

========================= activemq sample_3743 =========================

public static List<Runnable> shutdownNow(ExecutorService executorService) {	List<Runnable> answer = null;	if (!executorService.isShutdown()) {	
forcing shutdown of executorservice 

public static List<Runnable> shutdownNow(ExecutorService executorService) {	List<Runnable> answer = null;	if (!executorService.isShutdown()) {	answer = executorService.shutdownNow();	if (LOG.isTraceEnabled()) {	
shutdown of executorservice is shutdown and terminated 

private static void doShutdown(ExecutorService executorService, long shutdownAwaitTermination) {	if (executorService == null) {	return;	}	if (!executorService.isShutdown()) {	boolean warned = false;	StopWatch watch = new StopWatch();	
shutdown of executorservice with await termination millis 

return;	}	if (!executorService.isShutdown()) {	boolean warned = false;	StopWatch watch = new StopWatch();	executorService.shutdown();	if (shutdownAwaitTermination > 0) {	try {	if (!awaitTermination(executorService, shutdownAwaitTermination)) {	warned = true;	
forcing shutdown of executorservice due first await termination elapsed 

if (!executorService.isShutdown()) {	boolean warned = false;	StopWatch watch = new StopWatch();	executorService.shutdown();	if (shutdownAwaitTermination > 0) {	try {	if (!awaitTermination(executorService, shutdownAwaitTermination)) {	warned = true;	executorService.shutdownNow();	if (!awaitTermination(executorService, shutdownAwaitTermination)) {	
cannot completely force shutdown of executorservice due second await termination elapsed 

if (shutdownAwaitTermination > 0) {	try {	if (!awaitTermination(executorService, shutdownAwaitTermination)) {	warned = true;	executorService.shutdownNow();	if (!awaitTermination(executorService, shutdownAwaitTermination)) {	}	}	} catch (InterruptedException e) {	warned = true;	
forcing shutdown of executorservice due interrupted 

executorService.shutdownNow();	} finally {	Thread.currentThread().interrupt();	}	}	} else  if (shutdownAwaitTermination < 0) {	try {	awaitTermination(executorService);	} catch (InterruptedException e) {	warned = true;	
forcing shutdown of executorservice due interrupted 

} catch (InterruptedException e) {	warned = true;	try {	executorService.shutdownNow();	} finally {	Thread.currentThread().interrupt();	}	}	}	if (warned) {	
shutdown of executorservice is shutdown and terminated took 

warned = true;	try {	executorService.shutdownNow();	} finally {	Thread.currentThread().interrupt();	}	}	}	if (warned) {	} else if (LOG.isDebugEnabled()) {	
shutdown of executorservice is shutdown and terminated took 

public static void awaitTermination(ExecutorService executorService) throws InterruptedException {	StopWatch watch = new StopWatch();	final long interval = 2000;	while (true) {	if (executorService.awaitTermination(interval, TimeUnit.MILLISECONDS)) {	return;	} else {	
waited for executorservice to terminate 

public static boolean awaitTermination(ExecutorService executorService, long shutdownAwaitTermination) throws InterruptedException {	StopWatch watch = new StopWatch();	long interval = Math.min(2000, shutdownAwaitTermination);	boolean done = false;	while (!done && interval > 0) {	if (executorService.awaitTermination(interval, TimeUnit.MILLISECONDS)) {	done = true;	} else {	
waited for executorservice to terminate 

========================= activemq sample_160 =========================

public void testBrokers() throws Exception {	buildUrlList();	for (int i = 0; i < numBrokers; i++) {	createBroker(i);	}	startAllBrokers();	waitForBridgeFormation(numBrokers - 1);	verifyPeerBrokerInfos(numBrokers - 1);	final List<ConsumerState> consumerStates = startAllGWConsumers(numBrokers);	startAllGWFanoutConsumers(numBrokers);	
waiting for percolation of consumers 

buildUrlList();	for (int i = 0; i < numBrokers; i++) {	createBroker(i);	}	startAllBrokers();	waitForBridgeFormation(numBrokers - 1);	verifyPeerBrokerInfos(numBrokers - 1);	final List<ConsumerState> consumerStates = startAllGWConsumers(numBrokers);	startAllGWFanoutConsumers(numBrokers);	TimeUnit.SECONDS.sleep(5);	
produce mesages 

verifyPeerBrokerInfos(numBrokers - 1);	final List<ConsumerState> consumerStates = startAllGWConsumers(numBrokers);	startAllGWFanoutConsumers(numBrokers);	TimeUnit.SECONDS.sleep(5);	long startTime = System.currentTimeMillis();	produce(numMessages);	assertTrue("Got all sent", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	for (ConsumerState tally : consumerStates) {	final int expected = numMessages * (tally.destination.isComposite() ? tally.destination.getCompositeDestinations().length : 1);	
tally for dest 

if (tally.accumulator.get() != expected) {	LOG.info("Tally for: " + tally.brokerName + ", dest: " + tally.destination + " - " + tally.accumulator.get() + " != " + expected + ", " + tally.expected);	if (tally.accumulator.get() > expected - 50) {	dumpQueueStat(null);	}	if (tally.expected.size() == 1) {	startConsumer(tally.brokerName, tally.destination);	};	return false;	}	
got tally on 

if (tally.expected.size() == 1) {	startConsumer(tally.brokerName, tally.destination);	};	return false;	}	}	return true;	}	}, 1000 * 60 * 1000l, 20*1000));	assertTrue("No exceptions:" + exceptions, exceptions.isEmpty());	
done 

startConsumer(tally.brokerName, tally.destination);	};	return false;	}	}	return true;	}	}, 1000 * 60 * 1000l, 20*1000));	assertTrue("No exceptions:" + exceptions, exceptions.isEmpty());	long duration = System.currentTimeMillis() - startTime;	
duration 

private long dumpQueueStat(ActiveMQDestination destination) throws Exception {	long sumTotal = 0;	Collection<BrokerItem> brokerList = brokers.values();	for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext(); ) {	BrokerService brokerService = i.next().broker;	for (ObjectName objectName : brokerService.getAdminView().getQueues()) {	if (destination != null && objectName.toString().contains(destination.getPhysicalName())) {	QueueViewMBean qViewMBean = (QueueViewMBean) brokerService.getManagementContext().newProxyInstance(objectName, QueueViewMBean.class, false);	
enqueue size 

QueueConnection queueConnection = connectionFactory.createQueueConnection();	queueConnection.start();	final QueueSession queueSession = queueConnection.createQueueSession(true, Session.SESSION_TRANSACTED);	final MessageProducer producer = queueSession.createProducer(compositeQ);	queueSession.createReceiver(new ActiveMQQueue("IN")).setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	producer.send(message);	queueSession.commit();	} catch (Exception e) {	
failed to fanout to gw 

e.printStackTrace();	}	try {	consumerState.accumulator.incrementAndGet();	try {	consumerState.expected.remove(((ActiveMQMessage) message).getProperty("NUM"));	} catch (IOException e) {	e.printStackTrace();	}	} catch (Exception e) {	
failed to commit slow receipt of 

private void verifyPeerBrokerInfo(BrokerItem brokerItem, final int max) throws Exception {	final BrokerService broker = brokerItem.broker;	final RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
verify infos len 

private void verifyPeerBrokerInfo(BrokerItem brokerItem, final int max) throws Exception {	final BrokerService broker = brokerItem.broker;	final RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return max == regionBroker.getPeerBrokerInfos().length;	}	});	
verify infos len 

});	List<String> missing = new ArrayList<String>();	for (int i = 0; i < max; i++) {	missing.add("B" + i);	}	if (max != regionBroker.getPeerBrokerInfos().length) {	for (BrokerInfo info : regionBroker.getPeerBrokerInfos()) {	LOG.info(info.getBrokerName());	missing.remove(info.getBrokerName());	}	
broker infos off 

========================= activemq sample_2781 =========================

public void testFrameSizeToLargeClosesConnection() throws Exception {	
starting test on connector for frame size 

public void testFrameSizeNotExceededWorks() throws Exception {	
starting test on connector for frame size 

========================= activemq sample_863 =========================

protected synchronized void query() throws Exception {	DirContext currentContext = open();	entries.clear();	final SearchControls constraints = new SearchControls();	constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);	DefaultAuthorizationMap newMap = new DefaultAuthorizationMap();	for (PermissionType permissionType : PermissionType.values()) {	try {	processQueryResults(newMap, currentContext.search(queueSearchBase, getFilterForPermissionType(permissionType), constraints), DestinationType.QUEUE, permissionType);	} catch (Exception e) {	
policy not applied error processing policy under with filter 

for (PermissionType permissionType : PermissionType.values()) {	try {	processQueryResults(newMap, currentContext.search(queueSearchBase, getFilterForPermissionType(permissionType), constraints), DestinationType.QUEUE, permissionType);	} catch (Exception e) {	}	}	for (PermissionType permissionType : PermissionType.values()) {	try {	processQueryResults(newMap, currentContext.search(topicSearchBase, getFilterForPermissionType(permissionType), constraints), DestinationType.TOPIC, permissionType);	} catch (Exception e) {	
policy not applied error processing policy under with filter 

for (PermissionType permissionType : PermissionType.values()) {	try {	processQueryResults(newMap, currentContext.search(topicSearchBase, getFilterForPermissionType(permissionType), constraints), DestinationType.TOPIC, permissionType);	} catch (Exception e) {	}	}	for (PermissionType permissionType : PermissionType.values()) {	try {	processQueryResults(newMap, currentContext.search(tempSearchBase, getFilterForPermissionType(permissionType), constraints), DestinationType.TEMP, permissionType);	} catch (Exception e) {	
policy not applied error processing policy under with filter 

protected void processQueryResults(DefaultAuthorizationMap map, NamingEnumeration<SearchResult> results, DestinationType destinationType, PermissionType permissionType) throws Exception {	while (results.hasMore()) {	SearchResult result = results.next();	AuthorizationEntry entry = null;	try {	entry = getEntry(map, new LdapName(result.getNameInNamespace()), destinationType);	} catch (Exception e) {	
policy not applied error parsing authorization policy entry under 

while (memberAttributeEnum.hasMoreElements()) {	String memberDn = (String) memberAttributeEnum.nextElement();	boolean group = false;	boolean user = false;	String principalName = null;	if (!legacyGroupMapping) {	Attributes memberAttributes;	try {	memberAttributes = context.getAttributes(memberDn, new String[] { "objectClass", groupNameAttribute, userNameAttribute });	} catch (NamingException e) {	
policy not applied unknown member in policy entry 

continue;	}	Attribute memberEntryObjectClassAttribute = memberAttributes.get("objectClass");	NamingEnumeration<?> memberEntryObjectClassAttributeEnum = memberEntryObjectClassAttribute.getAll();	while (memberEntryObjectClassAttributeEnum.hasMoreElements()) {	String objectClass = (String) memberEntryObjectClassAttributeEnum.nextElement();	if (objectClass.equalsIgnoreCase(groupObjectClass)) {	group = true;	Attribute name = memberAttributes.get(groupNameAttribute);	if (name == null) {	
policy not applied group does not have name attribute under entry 

Attribute name = memberAttributes.get(groupNameAttribute);	if (name == null) {	break;	}	principalName = (String) name.get();	}	if (objectClass.equalsIgnoreCase(userObjectClass)) {	user = true;	Attribute name = memberAttributes.get(userNameAttribute);	if (name == null) {	
policy not applied user does not have name attribute under entry 

break;	}	principalName = (String) name.get();	}	}	} else {	group = true;	principalName = memberDn.replaceAll("(cn|CN)=", "");	}	if ((!group && !user) || (group && user)) {	
policy not applied can t determine type of member under entry 

throw ne;	}	} else if (!group && user) {	members.add(new UserPrincipal(principalName));	}	}	}	try {	applyAcl(entry, permissionType, members);	} catch (Exception e) {	
policy not applied error adding principals to acl under 

protected void checkForUpdates() {	if (lastUpdated == -1) {	try {	query();	return;	} catch (Exception e) {	
error updating authorization map partial policy may be applied until the next successful update 

this.updaterService.execute(new Runnable() {	public void run() {	if (context == null || (!refreshDisabled && (refreshInterval != -1 && System.currentTimeMillis() >= lastUpdated + refreshInterval))) {	if (!isContextAlive()) {	try {	context = createContext();	} catch (NamingException ne) {	return;	}	}	
updating authorization map 

if (!isContextAlive()) {	try {	context = createContext();	} catch (NamingException ne) {	return;	}	}	try {	query();	} catch (Exception e) {	
error updating authorization map partial policy may be applied until the next successful update 

public void objectAdded(NamingEvent namingEvent, DestinationType destinationType, PermissionType permissionType) {	
adding object 

SearchResult result = (SearchResult) namingEvent.getNewBinding();	try {	DefaultAuthorizationMap map = this.map.get();	LdapName name = new LdapName(result.getName());	AuthorizationEntry entry = getEntry(map, name, destinationType);	applyACL(entry, result, permissionType);	if (!(entry instanceof TempDestinationAuthorizationEntry)) {	map.put(entry.getDestination(), entry);	}	} catch (InvalidNameException e) {	
policy not applied error parsing dn for addition of 

try {	DefaultAuthorizationMap map = this.map.get();	LdapName name = new LdapName(result.getName());	AuthorizationEntry entry = getEntry(map, name, destinationType);	applyACL(entry, result, permissionType);	if (!(entry instanceof TempDestinationAuthorizationEntry)) {	map.put(entry.getDestination(), entry);	}	} catch (InvalidNameException e) {	} catch (Exception e) {	
policy not applied error processing object addition for addition of 

public void objectRemoved(NamingEvent namingEvent, DestinationType destinationType, PermissionType permissionType) {	
removing object 

public void objectRemoved(NamingEvent namingEvent, DestinationType destinationType, PermissionType permissionType) {	Binding result = namingEvent.getOldBinding();	try {	DefaultAuthorizationMap map = this.map.get();	LdapName name = new LdapName(result.getName());	AuthorizationEntry entry = getEntry(map, name, destinationType);	applyAcl(entry, permissionType, new HashSet<Object>());	} catch (InvalidNameException e) {	
policy not applied error parsing dn for object removal for removal of 

public void objectRemoved(NamingEvent namingEvent, DestinationType destinationType, PermissionType permissionType) {	Binding result = namingEvent.getOldBinding();	try {	DefaultAuthorizationMap map = this.map.get();	LdapName name = new LdapName(result.getName());	AuthorizationEntry entry = getEntry(map, name, destinationType);	applyAcl(entry, permissionType, new HashSet<Object>());	} catch (InvalidNameException e) {	} catch (Exception e) {	
policy not applied error processing object removal for removal of 

public void objectRenamed(NamingEvent namingEvent, DestinationType destinationType, PermissionType permissionType) {	Binding oldBinding = namingEvent.getOldBinding();	Binding newBinding = namingEvent.getNewBinding();	
renaming object to 

boolean matchedToType = false;	for (PermissionType newPermissionType : PermissionType.values()) {	NamingEnumeration<SearchResult> results = context.search(newName, getFilterForPermissionType(newPermissionType), controls);	if (results.hasMore()) {	objectAdded(namingEvent, destinationType, newPermissionType);	matchedToType = true;	break;	}	}	if (!matchedToType) {	
policy not applied error processing object rename for rename of to could not determine permission type of new object 

} else {	if (oldDest != null && newDest != null) {	AuthorizationEntry entry = entries.remove(oldDest);	if (entry != null) {	entry.setDestination(newDest);	DefaultAuthorizationMap map = this.map.get();	map.put(newDest, entry);	map.remove(oldDest, entry);	entries.put(newDest, entry);	} else {	
no authorization entry for 

entry.setDestination(newDest);	DefaultAuthorizationMap map = this.map.get();	map.put(newDest, entry);	map.remove(oldDest, entry);	entries.put(newDest, entry);	} else {	}	}	}	} catch (InvalidNameException e) {	
policy not applied error parsing dn for object rename for rename of to 

DefaultAuthorizationMap map = this.map.get();	map.put(newDest, entry);	map.remove(oldDest, entry);	entries.put(newDest, entry);	} else {	}	}	}	} catch (InvalidNameException e) {	} catch (Exception e) {	
policy not applied error processing object rename for rename of to 

public void objectChanged(NamingEvent namingEvent, DestinationType destinationType, PermissionType permissionType) {	
changing object to 

public void namingExceptionThrown(NamingExceptionEvent namingExceptionEvent) {	context = null;	
caught unexpected exception 

========================= activemq sample_4205 =========================

CountDownLatch latch = null;	synchronized (this) {	latch = nextCheckpointCountDownLatch;	lastCheckpointRequest = now;	if (fullCheckpoint) {	this.fullCheckPoint = true;	}	}	checkpointTask.wakeup();	if (sync) {	
waking for checkpoint to complete 

if (fullCheckpoint) {	this.fullCheckPoint = true;	}	}	checkpointTask.wakeup();	if (sync) {	latch.await();	}	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	
request to start checkpoint failed 

public boolean doCheckpoint() {	CountDownLatch latch = null;	boolean fullCheckpoint;	synchronized (this) {	latch = nextCheckpointCountDownLatch;	nextCheckpointCountDownLatch = new CountDownLatch(1);	fullCheckpoint = this.fullCheckPoint;	this.fullCheckPoint = false;	}	try {	
checkpoint started 

try {	final JournalMessageStore ms = iterator.next();	FutureTask<RecordLocation> task = new FutureTask<RecordLocation>(new Callable<RecordLocation>() {	public RecordLocation call() throws Exception {	return ms.checkpoint();	}	});	futureTasks.add(task);	checkpointExecutor.execute(task);	} catch (Exception e) {	
failed to checkpoint a message store 

try {	final JournalTopicMessageStore ms = iterator.next();	FutureTask<RecordLocation> task = new FutureTask<RecordLocation>(new Callable<RecordLocation>() {	public RecordLocation call() throws Exception {	return ms.checkpoint();	}	});	futureTasks.add(task);	checkpointExecutor.execute(task);	} catch (Exception e) {	
failed to checkpoint a message store 

for (Iterator<FutureTask<RecordLocation>> iter = futureTasks.iterator(); iter.hasNext();) {	FutureTask<RecordLocation> ft = iter.next();	RecordLocation mark = ft.get();	if (fullCheckpoint) {	if (mark != null && (newMark == null || newMark.compareTo(mark) < 0)) {	newMark = mark;	}	}	}	} catch (Throwable e) {	
failed to checkpoint a message store 

if (mark != null && (newMark == null || newMark.compareTo(mark) < 0)) {	newMark = mark;	}	}	}	} catch (Throwable e) {	}	if (fullCheckpoint) {	try {	if (newMark != null) {	
marking journal at 

}	}	} catch (Throwable e) {	}	if (fullCheckpoint) {	try {	if (newMark != null) {	journal.setMark(newMark, true);	}	} catch (Exception e) {	
failed to mark the journal 

} catch (Exception e) {	}	if (longTermPersistence instanceof JDBCPersistenceAdapter) {	long now = System.currentTimeMillis();	if (now > lastCleanup + checkpointInterval) {	lastCleanup = now;	((JDBCPersistenceAdapter)longTermPersistence).cleanup();	}	}	}	
checkpoint done 

private void recover() throws IllegalStateException, InvalidRecordLocationException, IOException, IOException {	RecordLocation pos = null;	int transactionCounter = 0;	
journal recovery started from 

((JournalTopicMessageStore)op.store).replayAcknowledge(context, ack.getClientId(), ack.getSubscritionName(), ack.getMessageId());	}	}	transactionCounter++;	break;	case JournalTransaction.LOCAL_ROLLBACK: case JournalTransaction.XA_ROLLBACK: transactionStore.replayRollback(command.getTransactionId());	break;	default: throw new IOException("Invalid journal command type: " + command.getType());	}	} catch (IOException e) {	
recovery failure could not replay reason 

break;	case JournalTransaction.LOCAL_ROLLBACK: case JournalTransaction.XA_ROLLBACK: transactionStore.replayRollback(command.getTransactionId());	break;	default: throw new IOException("Invalid journal command type: " + command.getType());	}	} catch (IOException e) {	}	}	break;	case JournalTrace.DATA_STRUCTURE_TYPE: JournalTrace trace = (JournalTrace)c;	
trace entry 

case JournalTransaction.LOCAL_ROLLBACK: case JournalTransaction.XA_ROLLBACK: transactionStore.replayRollback(command.getTransactionId());	break;	default: throw new IOException("Invalid journal command type: " + command.getType());	}	} catch (IOException e) {	}	}	break;	case JournalTrace.DATA_STRUCTURE_TYPE: JournalTrace trace = (JournalTrace)c;	break;	
unknown type of record in transaction log which will be discarded 

}	}	break;	case JournalTrace.DATA_STRUCTURE_TYPE: JournalTrace trace = (JournalTrace)c;	break;	}	}	}	RecordLocation location = writeTraceMessage("RECOVERED", true);	journal.setMark(location, true);	
journal recovered message s in transactions recovered 

public RecordLocation writeCommand(DataStructure command, boolean sync) throws IOException {	if (started.get()) {	try {	return journal.write(toPacket(wireFormat.marshal(command)), sync);	} catch (IOException ioe) {	
cannot write to the journal 

public void deleteAllMessages() throws IOException {	try {	JournalTrace trace = new JournalTrace();	trace.setMessage("DELETED");	RecordLocation location = journal.write(toPacket(wireFormat.marshal(trace)), false);	journal.setMark(location, true);	
journal deleted 

========================= activemq sample_926 =========================

client = getSendHttpClient();	answer = client.execute(httpMethod);	int status = answer.getStatusLine().getStatusCode();	if (status != HttpStatus.SC_OK) {	throw new IOException("Failed to post command: " + command + " as response was: " + answer);	}	if (command instanceof ShutdownInfo) {	try {	stop();	} catch (Exception e) {	
error trying to stop http client 

public void run() {	if (LOG.isTraceEnabled()) {	
http get consumer thread starting 

URI remoteUrl = getRemoteUrl();	while (!isStopped() && !isStopping()) {	httpMethod = new HttpGet(remoteUrl.toString());	configureMethod(httpMethod);	HttpResponse answer = null;	try {	answer = httpClient.execute(httpMethod);	int status = answer.getStatusLine().getStatusCode();	if (status != HttpStatus.SC_OK) {	if (status == HttpStatus.SC_REQUEST_TIMEOUT) {	
get timed out 

}	} else {	onException(new IOException("Failed to perform GET on: " + remoteUrl + " as response was: " + answer));	break;	}	} else {	receiveCounter++;	DataInputStream stream = createDataInputStream(answer);	Object command = getTextWireFormat().unmarshal(stream);	if (command == null) {	
received null command from url 

protected void doStart() throws Exception {	if (LOG.isTraceEnabled()) {	
http get consumer thread starting 

}	HttpClient httpClient = getReceiveHttpClient();	URI remoteUrl = getRemoteUrl();	HttpHead httpMethod = new HttpHead(remoteUrl.toString());	configureMethod(httpMethod);	HttpOptions optionsMethod = new HttpOptions(remoteUrl.toString());	ResponseHandler<String> handler = new BasicResponseHandler() {	public String handleResponse(HttpResponse response) throws HttpResponseException, IOException {	for(Header header : response.getAllHeaders()) {	if (header.getName().equals("Accepts-Encoding") && header.getValue().contains("gzip")) {	
broker servlet supports gzip compression 

break;	}	}	return super.handleResponse(response);	}	};	try {	httpClient.execute(httpMethod, new BasicResponseHandler());	httpClient.execute(optionsMethod, handler);	} catch(Exception e) {	
error on start 

========================= activemq sample_1142 =========================

protected InboundTransformer getTransformer() {	if (inboundTransformer == null) {	String transformer = session.getConnection().getConfiguredTransformer();	if (transformer.equalsIgnoreCase(InboundTransformer.TRANSFORMER_JMS)) {	inboundTransformer = new JMSMappingInboundTransformer();	} else if (transformer.equalsIgnoreCase(InboundTransformer.TRANSFORMER_NATIVE)) {	inboundTransformer = new AMQPNativeInboundTransformer();	} else if (transformer.equalsIgnoreCase(InboundTransformer.TRANSFORMER_RAW)) {	inboundTransformer = new AMQPRawInboundTransformer();	} else {	
unknown transformer type using native one instead 

MessageId messageId = new MessageId(getProducerId(), messageIdGenerator.getNextSequenceId());	MessageId amqpMessageId = message.getMessageId();	if (amqpMessageId != null) {	if (amqpMessageId.getTextView() != null) {	messageId.setTextView(amqpMessageId.getTextView());	} else {	messageId.setTextView(amqpMessageId.toString());	}	}	message.setMessageId(messageId);	
inbound message from producer 

TransactionalState txAccepted = new TransactionalState();	txAccepted.setOutcome(Accepted.getInstance());	txAccepted.setTxnId(((TransactionalState) remoteState).getTxnId());	delivery.disposition(txAccepted);	} else {	delivery.disposition(Accepted.getInstance());	}	}	}	if (getEndpoint().getCredit() + --sendsInFlight <= (getConfiguredReceiverCredit() * .3)) {	
sending more credit to producer 

========================= activemq sample_1705 =========================

Map<String, Object> headers = new HashMap<String, Object>();	headers.put("cheese", 123);	headers.put("JMSReplyTo", replyQueueName);	headers.put("JMSCorrelationID", correlationID);	headers.put("JMSXGroupID", groupID);	exchange.getIn().setHeaders(headers);	}	});	Message in = reply.getIn();	Object replyTo = in.getHeader("JMSReplyTo");	
reply to is 

Map<String, Object> headers = new HashMap<String, Object>();	headers.put("cheese", 123);	headers.put("JMSReplyTo", replyQueueName);	headers.put("JMSCorrelationID", correlationID);	headers.put("JMSXGroupID", groupID);	exchange.getIn().setHeaders(headers);	}	});	Message in = reply.getIn();	Object replyTo = in.getHeader("JMSReplyTo");	
received headers 

Map<String, Object> headers = new HashMap<String, Object>();	headers.put("cheese", 123);	headers.put("JMSReplyTo", replyQueueName);	headers.put("JMSCorrelationID", correlationID);	headers.put("JMSXGroupID", groupID);	exchange.getIn().setHeaders(headers);	}	});	Message in = reply.getIn();	Object replyTo = in.getHeader("JMSReplyTo");	
received body 

}	});	Message in = reply.getIn();	Object replyTo = in.getHeader("JMSReplyTo");	assertMessageHeader(in, "JMSCorrelationID", correlationID);	Map<String,Object> receivedHeaders = myBean.getHeaders();	assertThat(receivedHeaders, hasKey("JMSReplyTo"));	assertThat(receivedHeaders, hasEntry("JMSXGroupID", groupID));	assertThat(receivedHeaders, hasEntry("JMSCorrelationID", correlationID));	replyTo = receivedHeaders.get("JMSReplyTo");	
reply to is 

public String process(@Headers Map<String,Object> headers, String body) {	this.headers = headers;	
process invoked with headers 

========================= activemq sample_1355 =========================

try {	server.start();	clientManager.start();	if (ALLOW_SUBSCRIPTION_ABANDONMENT) houseKeeper.start();	Thread.sleep(RUNTIME);	assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());	}	catch (Throwable e) {	exit("DurableSubProcessTest.testProcess failed.", e);	}	
done 

private void createNewClient() throws JMSException {	ClientType type = ClientType.randomClientType();	Client client;	synchronized (server.sendMutex) {	client = new Client(++clientRover, type, CLIENT_LIFETIME, CLIENT_ONLINE, CLIENT_OFFLINE);	clients.add(client);	}	client.start();	
created 

boolean sleep = false;	while (true) {	long max = end - System.currentTimeMillis();	if (max <= 0) break;	if (sleep) offline.sleepRandom();	else sleep = true;	process(online.next());	}	if (!ALLOW_SUBSCRIPTION_ABANDONMENT || random(1) > 0) unsubscribe();	else {	
client abandon the subscription 

}	if (!ALLOW_SUBSCRIPTION_ABANDONMENT || random(1) > 0) unsubscribe();	else {	houseKeeper.abandonedSubscriptions.add(conClientId);	}	}	catch (Throwable e) {	exit(toString() + " failed.", e);	}	clientManager.removeClient(this);	
done 

private void process(long millis) throws JMSException {	long end = System.currentTimeMillis() + millis;	long hardEnd = end + 2000;	boolean inTransaction = false;	int transCount = 0;	
online 

}	else {	inTransaction = true;	transCount++;	}	} while (true);	}	finally {	sess.close();	con.close();	
offline 

private void sweep() throws Exception {	
housekeeper sweeping 

private void sweep() throws Exception {	int closed = 0;	ArrayList<String> sweeped = new ArrayList<String>();	try {	for (String clientId: abandonedSubscriptions) {	sweeped.add(clientId);	
sweeping out subscription of 

try {	for (String clientId: abandonedSubscriptions) {	sweeped.add(clientId);	broker.getAdminView().destroyDurableSubscriber(clientId, Client.SUBSCRIPTION_NAME);	closed++;	}	}	finally {	abandonedSubscriptions.removeAll(sweeped);	}	
housekeeper sweeped out subscriptions 

========================= activemq sample_3692 =========================

public void testBlockAndChangeViaJmxReleases() throws Exception {	
initial scheduler usage 

Message message = super.createMessage(i);	message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, WAIT_TIME_MILLS / 2);	return message;	}	};	producer.setMessageCount(100);	producer.start();	assertEquals(7 * 1024, broker.getAdminView().getJobSchedulerStoreLimit());	assertTrue("Usage exhausted", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
scheduler store usage producersent count 

}	};	producer.setMessageCount(100);	producer.start();	assertEquals(7 * 1024, broker.getAdminView().getJobSchedulerStoreLimit());	assertTrue("Usage exhausted", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return broker.getAdminView().getJobSchedulerStorePercentUsage() > 100;	}	}));	
scheduler store usage producersent count 

producer.setMessageCount(100);	producer.start();	assertEquals(7 * 1024, broker.getAdminView().getJobSchedulerStoreLimit());	assertTrue("Usage exhausted", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return broker.getAdminView().getJobSchedulerStorePercentUsage() > 100;	}	}));	assertNotEquals("Producer has not sent all messages", producer.getMessageCount(), producer.getSentCount());	broker.getAdminView().setJobSchedulerStoreLimit(1024 * 1024 * 33);	
scheduler store usage producersent count 

========================= activemq sample_2980 =========================

public void onCommand(Object command) {	if (command.getClass() == ConnectionInfo.class || command.getClass() == BrokerInfo.class) {	synchronized (this) {	try {	
connection attempted on http based transport 

========================= activemq sample_1139 =========================

public void setUp() throws Exception {	super.setUp();	ClientTestSupport.removeMessageStore();	
setting up 

consumerConnection = fac.createConnection();	setPrefetchPolicy((ActiveMQConnection)consumerConnection);	consumerConnection.setClientID(idGen.generateId());	consumerConnection.start();	producerSession = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	producer = producerSession.createProducer(createDestination());	producer.setDeliveryMode(deliveryMode);	consumerSession = consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	consumer = createConsumer();	consumer.setMessageListener(this);	
setup complete 

public void testLargeMessages() throws Exception {	for (int i = 0; i < MESSAGE_COUNT; i++) {	
sending message 

========================= activemq sample_3554 =========================

int messagesReceived = 0;	for (int i=0; i<messagesExpected; i++) {	Destination destination = session.createQueue("TEST");	MessageConsumer consumer = session.createConsumer(destination);	XAResource resource = session.getXAResource();	resource.recover(XAResource.TMSTARTRSCAN);	resource.recover(XAResource.TMNOFLAGS);	Xid tid = createXid();	Message message = null;	try {	
receiving message of 

Destination destination = session.createQueue("TEST");	MessageConsumer consumer = session.createConsumer(destination);	XAResource resource = session.getXAResource();	resource.recover(XAResource.TMSTARTRSCAN);	resource.recover(XAResource.TMNOFLAGS);	Xid tid = createXid();	Message message = null;	try {	resource.start(tid, XAResource.TMNOFLAGS);	message = consumer.receive(2000);	
received 

if (message != null) {	if (onePhase) {	resource.commit(tid, true);	} else {	resource.prepare(tid);	resource.commit(tid, false);	}	messagesReceived++;	}	} catch (Exception e) {	
caught exception 

if (onePhase) {	resource.commit(tid, true);	} else {	resource.prepare(tid);	resource.commit(tid, false);	}	messagesReceived++;	}	} catch (Exception e) {	try {	
rolling back transaction just in case no need to do this as it is implicit in a commit failure 

resource.commit(tid, false);	}	messagesReceived++;	}	} catch (Exception e) {	try {	resource.rollback(tid);	}	catch (XAException ex) {	try {	
caught exception during rollback forgetting transaction 

}	} catch (Exception e) {	try {	resource.rollback(tid);	}	catch (XAException ex) {	try {	resource.forget(tid);	}	catch (XAException ex1) {	
rollback forget failed 

========================= activemq sample_3807 =========================

public void testValidateRedeliveryFlagAfterRestart() throws Exception {	ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(broker.getTransportConnectors().get(0).getPublishableConnectString() + "?jms.prefetchPolicy.all=0");	connection = (ActiveMQConnection) connectionFactory.createConnection();	connection.start();	Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	Destination destination = session.createQueue(queueName);	populateDestination(1, destination, connection);	MessageConsumer consumer = session.createConsumer(destination);	Message msg = consumer.receive(5000);	
got 

consumer.close();	connection.close();	restartBroker();	connectionFactory = new ActiveMQConnectionFactory(broker.getTransportConnectors().get(0).getPublishableConnectString() + "?jms.prefetchPolicy.all=0");	connection = (ActiveMQConnection) connectionFactory.createConnection();	connection.start();	session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	destination = session.createQueue(queueName);	consumer = session.createConsumer(destination);	msg = consumer.receive(5000);	
got 

========================= activemq sample_2345 =========================

protected void doTestInvalidHeaderProcessing(int port, final AmqpHeader header, boolean ssl) throws Exception {	final ClientConnection connection = createClientConnection(ssl);	connection.open("localhost", port);	connection.send(header);	AmqpHeader response = connection.readAmqpHeader();	assertNotNull(response);	
broker responded with 

========================= activemq sample_1586 =========================

public void testConnectionFailures() throws Exception {	final CountDownLatch failed = new CountDownLatch(1);	Connection connection = pooledConnFact.createConnection();	
fetched new connection from the pool 

public void testConnectionFailures() throws Exception {	final CountDownLatch failed = new CountDownLatch(1);	Connection connection = pooledConnFact.createConnection();	connection.setExceptionListener(new ExceptionListener() {	public void onException(JMSException exception) {	
pooled connection failed 

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue(getTestName());	MessageProducer producer = session.createProducer(queue);	brokerService.stop();	assertTrue(failed.await(15, TimeUnit.SECONDS));	createBroker();	try {	producer.send(session.createMessage());	fail("Should be disconnected");	} catch (JMSException ex) {	
producer failed as expected 

brokerService.stop();	assertTrue(failed.await(15, TimeUnit.SECONDS));	createBroker();	try {	producer.send(session.createMessage());	fail("Should be disconnected");	} catch (JMSException ex) {	}	Connection connection2 = pooledConnFact.createConnection();	assertNotSame(connection, connection2);	
fetched new connection from the pool 

========================= activemq sample_1302 =========================

protected synchronized void onLoad(ListNode<String, Location> node, Transaction tx) {	try {	Iterator<Entry<String, Location>> i = node.iterator(tx);	while (i.hasNext()) {	messageSize.addSize(i.next().getValue().getSize());	}	} catch (IOException e) {	
could not increment message size 

========================= activemq sample_1752 =========================

private void validateQueueStats() throws Exception {	final BrokerView brokerView = brokers.get("BrokerA").broker.getAdminView();	assertEquals("enequeue is correct", 1000, brokerView.getTotalEnqueueCount());	assertTrue("dequeue is correct", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
dequeue count want is 

========================= activemq sample_2892 =========================

if (!transport.isConnected()) {	request.onSuccess();	}	if (getEndpoint() != null) {	close(request);	} else {	request.onSuccess();	}	pumpToProtonTransport(request);	} catch (Exception e) {	
caught exception while closing proton connection 

}	}	});	try {	if (closeTimeout <= 0) {	request.sync();	} else {	request.sync(closeTimeout, TimeUnit.MILLISECONDS);	}	} catch (IOException e) {	
error caught while closing provider 

request.sync();	} else {	request.sync(closeTimeout, TimeUnit.MILLISECONDS);	}	} catch (IOException e) {	} finally {	if (transport != null) {	try {	transport.close();	} catch (Exception e) {	
cuaght exception while closing down transport 

} finally {	if (transport != null) {	try {	transport.close();	} catch (Exception e) {	}	}	serializer.shutdownNow();	try {	if (!serializer.awaitTermination(10, TimeUnit.SECONDS)) {	
serializer didn t shutdown cleanly 

public void onData(final ByteBuf incoming) {	ReferenceCountUtil.retain(incoming);	serializer.execute(new Runnable() {	public void run() {	ByteBuffer source = incoming.nioBuffer();	
client received from broker bytes 

public void onData(final ByteBuf incoming) {	ReferenceCountUtil.retain(incoming);	serializer.execute(new Runnable() {	public void run() {	ByteBuffer source = incoming.nioBuffer();	if (protonTransport.isClosed()) {	
ignoring incoming data because transport is closed 

public void onTransportClosed() {	
the transport has unexpectedly closed 

protected void doOpenCompletion() {	if (getEndpoint().getRemoteProperties() == null || !getEndpoint().getRemoteProperties().containsKey(CONNECTION_OPEN_FAILED)) {	if (!isIdleProcessingDisabled()) {	long initialNow = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());	long initialKeepAliveDeadline = protonTransport.tick(initialNow);	if (initialKeepAliveDeadline != 0) {	getScheduler().schedule(new Runnable() {	public void run() {	try {	if (getEndpoint().getLocalState() != EndpointState.CLOSED) {	
client performing next idle check 

long initialKeepAliveDeadline = protonTransport.tick(initialNow);	if (initialKeepAliveDeadline != 0) {	getScheduler().schedule(new Runnable() {	public void run() {	try {	if (getEndpoint().getLocalState() != EndpointState.CLOSED) {	long now = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());	long deadline = protonTransport.tick(now);	pumpToProtonTransport();	if (protonTransport.isClosed()) {	
transport closed after inactivity check 

private void processUpdates() {	try {	Event protonEvent = null;	while ((protonEvent = protonCollector.peek()) != null) {	if (!protonEvent.getType().equals(Type.TRANSPORT)) {	
client new proton event 

amqpEventSink.processDeliveryUpdates(this);	break;	default: break;	}	protonCollector.pop();	}	if (!authenticated) {	processSaslAuthentication();	}	} catch (Exception ex) {	
caught exception during update processing 

========================= activemq sample_1617 =========================

private BrokerService createBroker() throws Exception {	BrokerService broker = new BrokerService();	broker.setBrokerName(brokerName);	KahaDBStore kaha = new KahaDBStore() {	public void start() throws Exception {	
test kahadb class is waiting for signal to complete its start 

private BrokerService createBroker() throws Exception {	BrokerService broker = new BrokerService();	broker.setBrokerName(brokerName);	KahaDBStore kaha = new KahaDBStore() {	public void start() throws Exception {	holdStoreStart.await();	super.start();	
test kahadb class is completed its start 

========================= activemq sample_2312 =========================

public void testReceiveTwoThenCloseConnection() throws Exception {	Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};	beginTx();	while (consumer.receive(1000) != null) {	}	commitTx();	beginTx();	producer.send(outbound[0]);	producer.send(outbound[1]);	commitTx();	
sent 

public void testReceiveTwoThenCloseConnection() throws Exception {	Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};	beginTx();	while (consumer.receive(1000) != null) {	}	commitTx();	beginTx();	producer.send(outbound[0]);	producer.send(outbound[1]);	commitTx();	
sent 

assertEquals(outbound[0], consumer.receive(1000));	consumer.close();	commitTx();	beginTx();	QueueBrowser browser = session.createBrowser((Queue)destination);	Enumeration enumeration = browser.getEnumeration();	assertTrue("should have received the second message", enumeration.hasMoreElements());	assertEquals(outbound[1], (Message)enumeration.nextElement());	assertTrue("Should have received the third message", enumeration.hasMoreElements());	assertEquals(outbound[2], (Message)enumeration.nextElement());	
check for more 

commitTx();	beginTx();	QueueBrowser browser = session.createBrowser((Queue)destination);	Enumeration enumeration = browser.getEnumeration();	assertTrue("should have received the second message", enumeration.hasMoreElements());	assertEquals(outbound[1], (Message)enumeration.nextElement());	assertTrue("Should have received the third message", enumeration.hasMoreElements());	assertEquals(outbound[2], (Message)enumeration.nextElement());	boolean tooMany = false;	while (enumeration.hasMoreElements()) {	
got extra message 

Enumeration enumeration = browser.getEnumeration();	assertTrue("should have received the second message", enumeration.hasMoreElements());	assertEquals(outbound[1], (Message)enumeration.nextElement());	assertTrue("Should have received the third message", enumeration.hasMoreElements());	assertEquals(outbound[2], (Message)enumeration.nextElement());	boolean tooMany = false;	while (enumeration.hasMoreElements()) {	tooMany = true;	}	assertFalse(tooMany);	
close browser 

assertTrue("should have received the second message", enumeration.hasMoreElements());	assertEquals(outbound[1], (Message)enumeration.nextElement());	assertTrue("Should have received the third message", enumeration.hasMoreElements());	assertEquals(outbound[2], (Message)enumeration.nextElement());	boolean tooMany = false;	while (enumeration.hasMoreElements()) {	tooMany = true;	}	assertFalse(tooMany);	browser.close();	
reopen and consume 

========================= activemq sample_3850 =========================

public void starting(Description description) {	
being run 

protected void applyNewConfig(String configName, String newConfigName, long sleep) throws Exception {	Resource resource = Utils.resourceFromString("org/apache/activemq");	File file = new File(resource.getFile(), configName + ".xml");	FileOutputStream current = new FileOutputStream(file);	FileInputStream modifications = new FileInputStream(new File(resource.getFile(), newConfigName + ".xml"));	modifications.getChannel().transferTo(0, Long.MAX_VALUE, current.getChannel());	current.flush();	current.getChannel().force(true);	current.close();	modifications.close();	
updated 

========================= activemq sample_4383 =========================

public void setUri(URI discoveryURI) throws IOException {	this.discoveryUri = discoveryURI;	setDiscoveryAgent(DiscoveryAgentFactory.createDiscoveryAgent(discoveryURI));	try {	parameters = URISupport.parseParameters(discoveryURI);	IntrospectionSupport.setProperties(getDiscoveryAgent(), parameters);	} catch (URISyntaxException e) {	
failed to parse query parameters from discoveryuri 

public void onServiceAdd(DiscoveryEvent event) {	if (serviceSupport.isStopped() || serviceSupport.isStopping()) {	return;	}	String url = event.getServiceName();	if (url != null) {	URI uri;	try {	uri = new URI(url);	} catch (URISyntaxException e) {	
could not connect to remote uri due to bad uri syntax 

}	String url = event.getServiceName();	if (url != null) {	URI uri;	try {	uri = new URI(url);	} catch (URISyntaxException e) {	return;	}	if (localURI.equals(uri)) {	
not connecting loopback 

URI uri;	try {	uri = new URI(url);	} catch (URISyntaxException e) {	return;	}	if (localURI.equals(uri)) {	return;	}	if (connectionFilter != null && !connectionFilter.connectTo(uri)) {	
connectionfilter disallows connection to 

} catch (URISyntaxException e) {	return;	}	if (localURI.equals(uri)) {	return;	}	if (connectionFilter != null && !connectionFilter.connectTo(uri)) {	return;	}	if (activeEvents.putIfAbsent(uri, event) != null) {	
discovery agent generated a duplicate onserviceadd event for 

if (connectionFilter != null && !connectionFilter.connectTo(uri)) {	return;	}	if (activeEvents.putIfAbsent(uri, event) != null) {	return;	}	URI connectUri = uri;	try {	connectUri = URISupport.applyParameters(connectUri, parameters, DISCOVERED_OPTION_PREFIX);	} catch (URISyntaxException e) {	
could not apply query parameters to 

return;	}	if (activeEvents.putIfAbsent(uri, event) != null) {	return;	}	URI connectUri = uri;	try {	connectUri = URISupport.applyParameters(connectUri, parameters, DISCOVERED_OPTION_PREFIX);	} catch (URISyntaxException e) {	}	
establishing network connection from to 

connectUri = URISupport.applyParameters(connectUri, parameters, DISCOVERED_OPTION_PREFIX);	} catch (URISyntaxException e) {	}	Transport remoteTransport;	Transport localTransport;	try {	SslContext.setCurrentSslContext(getBrokerService().getSslContext());	try {	remoteTransport = TransportFactory.connect(connectUri);	} catch (Exception e) {	
could not connect to remote uri 

connectUri = URISupport.applyParameters(connectUri, parameters, DISCOVERED_OPTION_PREFIX);	} catch (URISyntaxException e) {	}	Transport remoteTransport;	Transport localTransport;	try {	SslContext.setCurrentSslContext(getBrokerService().getSslContext());	try {	remoteTransport = TransportFactory.connect(connectUri);	} catch (Exception e) {	
connection failure exception 

Transport remoteTransport;	Transport localTransport;	try {	SslContext.setCurrentSslContext(getBrokerService().getSslContext());	try {	remoteTransport = TransportFactory.connect(connectUri);	} catch (Exception e) {	try {	discoveryAgent.serviceFailed(event);	} catch (IOException e1) {	
failure while handling create remote transport failure event 

try {	discoveryAgent.serviceFailed(event);	} catch (IOException e1) {	}	return;	}	try {	localTransport = createLocalTransport();	} catch (Exception e) {	ServiceSupport.dispose(remoteTransport);	
could not connect to local uri 

try {	discoveryAgent.serviceFailed(event);	} catch (IOException e1) {	}	return;	}	try {	localTransport = createLocalTransport();	} catch (Exception e) {	ServiceSupport.dispose(remoteTransport);	
connection failure exception 

}	return;	}	try {	localTransport = createLocalTransport();	} catch (Exception e) {	ServiceSupport.dispose(remoteTransport);	try {	discoveryAgent.serviceFailed(event);	} catch (IOException e1) {	
failure while handling create local transport failure event 

}	NetworkBridge bridge = createBridge(localTransport, remoteTransport, event);	try {	synchronized (bridges) {	bridges.put(uri, bridge);	}	bridge.start();	} catch (Exception e) {	ServiceSupport.dispose(localTransport);	ServiceSupport.dispose(remoteTransport);	
could not start network bridge between and due to 

}	NetworkBridge bridge = createBridge(localTransport, remoteTransport, event);	try {	synchronized (bridges) {	bridges.put(uri, bridge);	}	bridge.start();	} catch (Exception e) {	ServiceSupport.dispose(localTransport);	ServiceSupport.dispose(remoteTransport);	
start failure exception 

synchronized (bridges) {	bridges.put(uri, bridge);	}	bridge.start();	} catch (Exception e) {	ServiceSupport.dispose(localTransport);	ServiceSupport.dispose(remoteTransport);	try {	discoveryAgent.serviceFailed(event);	} catch (IOException e1) {	
discovery agent failure while handling failure event 

public void onServiceRemove(DiscoveryEvent event) {	String url = event.getServiceName();	if (url != null) {	URI uri;	try {	uri = new URI(url);	} catch (URISyntaxException e) {	
could not connect to remote uri due to bad uri syntax 

========================= activemq sample_4229 =========================

protected ConnectionPool createConnectionPool(Connection connection) {	return new JcaConnectionPool(connection, getTransactionManager(), getName()) {	protected Connection wrap(final Connection connection) {	((ActiveMQConnection)connection).addTransportListener(new TransportListener() {	public void onCommand(Object command) {	}	public void onException(IOException error) {	synchronized (this) {	setHasExpired(true);	if (!stopped.get()) {	
expiring connection on ioexception 

protected ConnectionPool createConnectionPool(Connection connection) {	return new JcaConnectionPool(connection, getTransactionManager(), getName()) {	protected Connection wrap(final Connection connection) {	((ActiveMQConnection)connection).addTransportListener(new TransportListener() {	public void onCommand(Object command) {	}	public void onException(IOException error) {	synchronized (this) {	setHasExpired(true);	if (!stopped.get()) {	
expiring connection on ioexception 

========================= activemq sample_789 =========================

this.index.load(tx);	tx.commit();	long pageCount = index.getPageFile().getPageCount();	assertEquals(1, pageCount);	long freePageCount = index.getPageFile().getFreePageCount();	assertEquals("No free pages", 0, freePageCount);	tx = pf.tx();	doInsert(20);	tx.commit();	pageCount = index.getPageFile().getPageCount();	
page count 

assertEquals("No free pages", 0, freePageCount);	tx = pf.tx();	doInsert(20);	tx.commit();	pageCount = index.getPageFile().getPageCount();	assertTrue("used some pages", pageCount > 1);	tx = pf.tx();	doRemove(20);	tx.commit();	freePageCount = index.getPageFile().getFreePageCount();	
freepage count 

tx = pf.tx();	doInsert(20);	tx.commit();	pageCount = index.getPageFile().getPageCount();	assertTrue("used some pages", pageCount > 1);	tx = pf.tx();	doRemove(20);	tx.commit();	freePageCount = index.getPageFile().getFreePageCount();	assertTrue("Some free pages " + freePageCount, freePageCount > 0);	
add some more to use up free list 

assertTrue("used some pages", pageCount > 1);	tx = pf.tx();	doRemove(20);	tx.commit();	freePageCount = index.getPageFile().getFreePageCount();	assertTrue("Some free pages " + freePageCount, freePageCount > 0);	tx = pf.tx();	doInsert(20);	tx.commit();	freePageCount = index.getPageFile().getFreePageCount();	
freepage count 

createPageFileAndIndex(1024*4);	ListIndex<String, Long> listIndex = ((ListIndex<String, Long>) this.index);	this.index.load(tx);	tx.commit();	final int COUNT = 50000;	long start = System.currentTimeMillis();	for (int i = 0; i < COUNT; i++) {	listIndex.add(tx, key(i), (long) i);	tx.commit();	}	
time to add mills 

createPageFileAndIndex(1024*4);	ListIndex<String, Long> listIndex = ((ListIndex<String, Long>) this.index);	this.index.load(tx);	tx.commit();	final int COUNT = 50000;	long start = System.currentTimeMillis();	for (int i = 0; i < COUNT; i++) {	listIndex.add(tx, key(i), (long) i);	tx.commit();	}	
page count 

tx = pf.tx();	int removeCount = 0;	Iterator<Map.Entry<String, Long>> iterator = index.iterator(tx);	while (iterator.hasNext()) {	iterator.next();	iterator.remove();	removeCount++;	}	tx.commit();	assertEquals("Removed all", COUNT, removeCount);	
time to remove mills 

tx = pf.tx();	int removeCount = 0;	Iterator<Map.Entry<String, Long>> iterator = index.iterator(tx);	while (iterator.hasNext()) {	iterator.next();	iterator.remove();	removeCount++;	}	tx.commit();	assertEquals("Removed all", COUNT, removeCount);	
page count 

tx = pf.tx();	int removeCount = 0;	Iterator<Map.Entry<String, Long>> iterator = index.iterator(tx);	while (iterator.hasNext()) {	iterator.next();	iterator.remove();	removeCount++;	}	tx.commit();	assertEquals("Removed all", COUNT, removeCount);	
page free count 

pf.load();	tx = pf.tx();	long id = tx.allocate().getPageId();	ListIndex<String, SequenceSet> test = new ListIndex<String, SequenceSet>(pf, id);	test.setKeyMarshaller(StringMarshaller.INSTANCE);	test.setValueMarshaller(SequenceSet.Marshaller.INSTANCE);	test.load(tx);	tx.commit();	int expectedListEntries = 0;	int nextSequenceId = 0;	
loading up the listindex with entires and sparsely populating the sequences 

sequenceSet.add(nextSequenceId++);	test.put(tx, String.valueOf(j), sequenceSet);	}	sequenceSet = test.get(tx, String.valueOf(j));	for (int ix = 0; ix < NUM_ITERATIONS - 1; ix++) {	sequenceSet.remove(startSequenceId++);	test.put(tx, String.valueOf(j), sequenceSet);	}	}	}	
checking if index has the expected number of entries 

for (int ix = 0; ix < NUM_ITERATIONS - 1; ix++) {	sequenceSet.remove(startSequenceId++);	test.put(tx, String.valueOf(j), sequenceSet);	}	}	}	for (int i = 0; i < NUM_ITERATIONS; ++i) {	assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));	}	
index has the expected number of entries 

test.put(tx, String.valueOf(j), sequenceSet);	}	}	}	for (int i = 0; i < NUM_ITERATIONS; ++i) {	assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));	}	assertEquals(expectedListEntries, test.size());	for (int i = 0; i < NUM_ITERATIONS; ++i) {	
size of listindex before removal of entry is 

}	}	for (int i = 0; i < NUM_ITERATIONS; ++i) {	assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));	}	assertEquals(expectedListEntries, test.size());	for (int i = 0; i < NUM_ITERATIONS; ++i) {	assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.remove(tx, String.valueOf(i)));	
size of listindex after removal of entry is 

pf.load();	tx = pf.tx();	long id = tx.allocate().getPageId();	ListIndex<String, SequenceSet> test = new ListIndex<String, SequenceSet>(pf, id);	test.setKeyMarshaller(StringMarshaller.INSTANCE);	test.setValueMarshaller(SequenceSet.Marshaller.INSTANCE);	test.load(tx);	tx.commit();	int expectedListEntries = 0;	int nextSequenceId = 0;	
loading up the listindex with entries and sparsely populating the sequences 

sequenceSet.add(nextSequenceId++);	test.put(tx, String.valueOf(j), sequenceSet);	}	sequenceSet = test.get(tx, String.valueOf(j));	for (int ix = 0; ix < NUM_ITERATIONS - 1; ix++) {	sequenceSet.remove(startSequenceId++);	test.put(tx, String.valueOf(j), sequenceSet);	}	}	}	
checking if index has the expected number of entries 

for (int ix = 0; ix < NUM_ITERATIONS - 1; ix++) {	sequenceSet.remove(startSequenceId++);	test.put(tx, String.valueOf(j), sequenceSet);	}	}	}	for (int i = 0; i < NUM_ITERATIONS; ++i) {	assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));	}	
index has the expected number of entries 

test.put(tx, String.valueOf(j), sequenceSet);	}	}	}	for (int i = 0; i < NUM_ITERATIONS; ++i) {	assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));	}	assertEquals(expectedListEntries, test.size());	for (int i = NUM_ITERATIONS - 1; i >= 0; --i) {	
size of listindex before removal of entry is 

}	}	for (int i = 0; i < NUM_ITERATIONS; ++i) {	assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));	}	assertEquals(expectedListEntries, test.size());	for (int i = NUM_ITERATIONS - 1; i >= 0; --i) {	assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.remove(tx, String.valueOf(i)));	
size of listindex after removal of entry is 

SequenceSet sequenceSet  = new SequenceSet();	sequenceSet.add(sequence);	test.add(tx, String.valueOf(i), sequenceSet);	}	long start = System.currentTimeMillis();	SequenceSet sequenceSet = test.get(tx, String.valueOf(NUM_ITERATIONS - 10));	for (int i=0; i<RANGE; i+=2) {	sequenceSet.remove(i);	test.put(tx, String.valueOf(NUM_ITERATIONS -1), sequenceSet);	}	
duration 

pf.load();	tx = pf.tx();	long id = tx.allocate().getPageId();	ListIndex<String, SequenceSet> test = new ListIndex<String, SequenceSet>(pf, id);	test.setKeyMarshaller(StringMarshaller.INSTANCE);	test.setValueMarshaller(SequenceSet.Marshaller.INSTANCE);	test.load(tx);	tx.commit();	int expectedListEntries = 0;	int nextSequenceId = 0;	
loading up the listindex with entires and sparsely populating the sequences 

sequenceSet.add(nextSequenceId++);	test.put(tx, String.valueOf(j), sequenceSet);	}	sequenceSet = test.get(tx, String.valueOf(j));	for (int ix = 0; ix < NUM_ITERATIONS - 1; ix++) {	sequenceSet.remove(startSequenceId++);	test.put(tx, String.valueOf(j), sequenceSet);	}	}	}	
checking if index has the expected number of entries 

for (int ix = 0; ix < NUM_ITERATIONS - 1; ix++) {	sequenceSet.remove(startSequenceId++);	test.put(tx, String.valueOf(j), sequenceSet);	}	}	}	for (int i = 0; i < NUM_ITERATIONS; ++i) {	assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));	}	
index has the expected number of entries 

test.put(tx, String.valueOf(j), sequenceSet);	}	}	}	for (int i = 0; i < NUM_ITERATIONS; ++i) {	assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));	}	assertEquals(expectedListEntries, test.size());	for (int i = 0; i < NUM_ITERATIONS; i += 2) {	
size of listindex before removal of entry is 

}	}	for (int i = 0; i < NUM_ITERATIONS; ++i) {	assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));	}	assertEquals(expectedListEntries, test.size());	for (int i = 0; i < NUM_ITERATIONS; i += 2) {	assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.remove(tx, String.valueOf(i)));	
size of listindex after removal of entry is 

assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));	}	assertEquals(expectedListEntries, test.size());	for (int i = 0; i < NUM_ITERATIONS; i += 2) {	assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.remove(tx, String.valueOf(i)));	assertEquals(--expectedListEntries, test.size());	}	for (int i = NUM_ITERATIONS - 1; i > 0; i -= 2) {	
size of listindex before removal of entry is 

}	assertEquals(expectedListEntries, test.size());	for (int i = 0; i < NUM_ITERATIONS; i += 2) {	assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.remove(tx, String.valueOf(i)));	assertEquals(--expectedListEntries, test.size());	}	for (int i = NUM_ITERATIONS - 1; i > 0; i -= 2) {	assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.remove(tx, String.valueOf(i)));	
size of listindex after removal of entry is 

========================= activemq sample_1744 =========================

public void stop() throws Exception {	if (monitorTask != null) {	try {	this.getBrokerService().getScheduler().cancel(monitorTask);	} catch (Exception letsNotStopStop) {	
failed to cancel config monitor task 

========================= activemq sample_4403 =========================

public Connection createConnection(URI remoteURI, String username, String password, String clientId, boolean syncPublish) throws JMSException {	ConnectionFactory factory = createConnectionFactory(remoteURI, username, password, syncPublish);	Connection connection = factory.createConnection();	connection.setExceptionListener(new ExceptionListener() {	public void onException(JMSException exception) {	
unexpected exception 

public TopicConnection createTopicConnection(URI remoteURI, String username, String password, String clientId, boolean syncPublish) throws JMSException {	TopicConnectionFactory factory = createTopicConnectionFactory(remoteURI, username, password, syncPublish);	TopicConnection connection = factory.createTopicConnection();	connection.setExceptionListener(new ExceptionListener() {	public void onException(JMSException exception) {	
unexpected exception 

public QueueConnection createQueueConnection(URI remoteURI, String username, String password, String clientId, boolean syncPublish) throws JMSException {	QueueConnectionFactory factory = createQueueConnectionFactory(remoteURI, username, password, syncPublish);	QueueConnection connection = factory.createQueueConnection();	connection.setExceptionListener(new ExceptionListener() {	public void onException(JMSException exception) {	
unexpected exception 

case "ssl": case "amqp+ssl": case "auto+ssl": case "amqp+nio+ssl": case "auto+nio+ssl": clientScheme = "amqps: useSSL = true;	break;	case "ws": case "amqp+ws": clientScheme = "amqpws: break;	case "wss": case "amqp+wss": clientScheme = "amqpwss: useSSL = true;	break;	default: clientScheme = "amqp: }	String amqpURI = clientScheme + remoteURI.getHost() + ":" + remoteURI.getPort();	if (useSSL) {	amqpURI += "?transport.verifyHost=false";	}	
in createconnectionfactory using uri 

========================= activemq sample_1601 =========================

public void run() {	try {	while (((RegionBroker)brokerService.getRegionBroker()).getDestinationStatistics().getMessages().getCount() > 0) {	
total messagecount 

public void test() throws Exception {	String activemqQueues = "activemq,activemq2,activemq3,activemq4";	int consumerWaitForConsumption = 5 * 60 * 1000;	ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	
publisher will publish messages to each queue specified 

public void test() throws Exception {	String activemqQueues = "activemq,activemq2,activemq3,activemq4";	int consumerWaitForConsumption = 5 * 60 * 1000;	ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	
building publisher 

public void test() throws Exception {	String activemqQueues = "activemq,activemq2,activemq3,activemq4";	int consumerWaitForConsumption = 5 * 60 * 1000;	ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);	
building consumer 

public void test() throws Exception {	String activemqQueues = "activemq,activemq2,activemq3,activemq4";	int consumerWaitForConsumption = 5 * 60 * 1000;	ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);	consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);	
starting publisher 

public void test() throws Exception {	String activemqQueues = "activemq,activemq2,activemq3,activemq4";	int consumerWaitForConsumption = 5 * 60 * 1000;	ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);	consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);	publisher.start();	
starting consumer 

public void test() throws Exception {	String activemqQueues = "activemq,activemq2,activemq3,activemq4";	int consumerWaitForConsumption = 5 * 60 * 1000;	ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);	consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);	publisher.start();	consumer.start();	int distinctPublishedCount = 0;	
waiting for publisher completion 

ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);	consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);	publisher.start();	consumer.start();	int distinctPublishedCount = 0;	publisher.waitForCompletion();	List publishedIds = publisher.getIDs();	distinctPublishedCount = new TreeSet(publishedIds).size();	
publisher complete published distinct ids published 

publisher.start();	consumer.start();	int distinctPublishedCount = 0;	publisher.waitForCompletion();	List publishedIds = publisher.getIDs();	distinctPublishedCount = new TreeSet(publishedIds).size();	long endWait = System.currentTimeMillis() + consumerWaitForConsumption;	while (!consumer.completed() && System.currentTimeMillis() < endWait) {	try {	int secs = (int) (endWait - System.currentTimeMillis()) / 1000;	
waiting for consumer completion time left secs 

List publishedIds = publisher.getIDs();	distinctPublishedCount = new TreeSet(publishedIds).size();	long endWait = System.currentTimeMillis() + consumerWaitForConsumption;	while (!consumer.completed() && System.currentTimeMillis() < endWait) {	try {	int secs = (int) (endWait - System.currentTimeMillis()) / 1000;	Thread.sleep(10000);	} catch (Exception e) {	}	}	
consumer complete shutting down 

distinctPublishedCount = new TreeSet(publishedIds).size();	long endWait = System.currentTimeMillis() + consumerWaitForConsumption;	while (!consumer.completed() && System.currentTimeMillis() < endWait) {	try {	int secs = (int) (endWait - System.currentTimeMillis()) / 1000;	Thread.sleep(10000);	} catch (Exception e) {	}	}	consumer.shutdown();	
consumer stats 

public boolean completed() {	for (List<ConsumerThread> list : threads.values()) {	for (ConsumerThread ct : list) {	if (ct.isAlive()) {	
thread for is still alive 

public void run() {	try {	int count = 0;	while (!shutdown) {	if (idList.size() >= totalToExpect) {	
got for q 

count++;	if (count == batchSize) {	session.commit();	count = 0;	}	} else {	session.commit();	count = 0;	try {	if (idList.size() < totalToExpect) {	
did not receive on current count 

========================= activemq sample_2884 =========================

medHighPri.join();	final int closeFrequency = MSG_NUM;	final int[] priorities = new int[]{HIGH_PRI, MED_HIGH_PRI, MED_PRI, LOW_PRI};	sub = sess.createDurableSubscriber(topic, subName);	for (int i = 0; i < MSG_NUM * 4; i++) {	Message msg = sub.receive(10000);	LOG.debug("received i=" + i + ", m=" + (msg != null ? msg.getJMSMessageID() + ", priority: " + msg.getJMSPriority() : null));	assertNotNull("Message " + i + " was null", msg);	assertEquals("Message " + i + " has wrong priority", priorities[i / MSG_NUM], msg.getJMSPriority());	if (i > 0 && i % closeFrequency == 0) {	
closing durable sub on 

for (int i = 0; i < MSG_NUM * 4; i++) {	Message msg = sub.receive(10000);	LOG.debug("received i=" + i + ", m=" + (msg != null ? msg.getJMSMessageID() + ", priority: " + msg.getJMSPriority() : null));	assertNotNull("Message " + i + " was null", msg);	assertEquals("Message " + i + " has wrong priority", priorities[i / MSG_NUM], msg.getJMSPriority());	if (i > 0 && i % closeFrequency == 0) {	sub.close();	sub = sess.createDurableSubscriber(topic, subName);	}	}	
closing on done 

sub = consumerSession.createDurableSubscriber(topic, subName);	for (int i = 0; i < MSG_NUM * maxPriority; i++) {	Message msg = sub.receive(10000);	LOG.debug("received i=" + i + ", m=" + (msg != null ? msg.getJMSMessageID() + ", priority: " + msg.getJMSPriority() : null));	assertNotNull("Message " + i + " was null, counts: " + Arrays.toString(messageCounts), msg);	assertNull("no duplicate message failed on : " + msg.getJMSMessageID(), dups.put(msg.getJMSMessageID(), subName));	messageCounts[msg.getJMSPriority()].incrementAndGet();	assertEquals("message is in order : " + msg, messageIds[msg.getJMSPriority()],((ActiveMQMessage)msg).getMessageId().getProducerSequenceId());	messageIds[msg.getJMSPriority()]++;	if (i > 0 && i % closeFrequency == 0) {	
closing durable sub on counts 

assertNotNull("Message " + i + " was null, counts: " + Arrays.toString(messageCounts), msg);	assertNull("no duplicate message failed on : " + msg.getJMSMessageID(), dups.put(msg.getJMSMessageID(), subName));	messageCounts[msg.getJMSPriority()].incrementAndGet();	assertEquals("message is in order : " + msg, messageIds[msg.getJMSPriority()],((ActiveMQMessage)msg).getMessageId().getProducerSequenceId());	messageIds[msg.getJMSPriority()]++;	if (i > 0 && i % closeFrequency == 0) {	sub.close();	sub = consumerSession.createDurableSubscriber(topic, subName);	}	}	
closing on done 

long start;	double max = 0, sum = 0;	MessageProducer messageProducer = sess.createProducer(topic);	TextMessage message = sess.createTextMessage();	for (int i = 0; i < TO_SEND; i++) {	int priority = i % 10;	message.setText(i + "-" + priority);	message.setIntProperty("seq", i);	message.setJMSPriority(priority);	if (i > 0 && i % 1000 == 0) {	
max send time sending message 

}	start = System.currentTimeMillis();	messageProducer.send(message, DeliveryMode.PERSISTENT, message.getJMSPriority(), 0);	long duration = System.currentTimeMillis() - start;	max = Math.max(max, duration);	if (duration == max) {	LOG.info("new max: " + max + " on i=" + i + ", " + message.getText());	}	sum += duration;	}	
sent max send time 

sum += duration;	}	double noConsumerAve = (sum * 100 / TO_SEND);	sub = consumerSession.createDurableSubscriber(topic, subName);	final AtomicInteger count = new AtomicInteger();	sub.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	count.incrementAndGet();	if (count.get() % 100 == 0) {	
onmessage count seqno seq 

sub.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	count.incrementAndGet();	if (count.get() % 100 == 0) {	}	int seqNo = message.getIntProperty("seq");	if (dups[seqNo] == 0) {	dups[seqNo] = 1;	} else {	
duplicate 

if (dups[seqNo] == 0) {	dups[seqNo] = 1;	} else {	duplicates.add(message);	}	} catch (Exception e) {	e.printStackTrace();	}	}	});	
activated consumer 

}	}	});	sum = max = 0;	for (int i = TO_SEND; i < (TO_SEND * 2); i++) {	int priority = i % 10;	message.setText(i + "-" + priority);	message.setIntProperty("seq", i);	message.setJMSPriority(priority);	if (i > 0 && i % 1000 == 0) {	
max send time sending message 

}	start = System.currentTimeMillis();	messageProducer.send(message, DeliveryMode.PERSISTENT, message.getJMSPriority(), 0);	long duration = System.currentTimeMillis() - start;	max = Math.max(max, duration);	if (duration == max) {	LOG.info("new max: " + max + " on i=" + i + ", " + message.getText());	}	sum += duration;	}	
sent another max send time 

if (duration == max) {	LOG.info("new max: " + max + " on i=" + i + ", " + message.getText());	}	sum += duration;	}	double withConsumerAve = (sum * 100 / TO_SEND);	final int reasonableMultiplier = 4;	assertTrue("max X times as slow with consumer:" + withConsumerAve + " , noConsumerMax:" + noConsumerAve, withConsumerAve < noConsumerAve * reasonableMultiplier);	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
count 

message = sess.createTextMessage("A");	messageProducer.send(message);	message = sess.createTextMessage("B");	messageProducer.send(message);	message = null;	assertEquals("three messages pending", 3, messageTableCount());	TimeUnit.SECONDS.sleep(5);	sub = consumerSession.createDurableSubscriber(topic, subName);	message = sub.receive(5000);	assertNotNull("got message", message);	
got 

sub = consumerSession.createDurableSubscriber(topic, subName);	message = sub.receive(5000);	assertNotNull("got message", message);	waitForAck(0, 1);	for (int i=0; i<10; i++) {	jdbc.cleanup();	}	assertEquals("one messages pending", 1, messageTableCount());	message = sub.receive(5000);	assertNotNull("got message two", message);	
got 

========================= activemq sample_3796 =========================

protected ApplicationContext createApplicationContext(String uri) throws MalformedURLException {	Resource resource = Utils.resourceFromString(uri);	
using from 

protected ApplicationContext createApplicationContext(String uri) throws MalformedURLException {	Resource resource = Utils.resourceFromString(uri);	try {	return new ResourceXmlApplicationContext(resource) {	protected void initBeanDefinitionReader(XmlBeanDefinitionReader reader) {	reader.setValidating(isValidate());	}	};	} catch (FatalBeanException errorToLog) {	
failed to load reason 

========================= activemq sample_766 =========================

public void testInvoke() throws Exception {	String result = executeQuery("-QQueue=Q* --view Paused");	assertTrue("got pause status", result.contains("Paused = false"));	result = executeQuery("-QQueue=* --invoke pause");	
result of invoke 

public void testInvoke() throws Exception {	String result = executeQuery("-QQueue=Q* --view Paused");	assertTrue("got pause status", result.contains("Paused = false"));	result = executeQuery("-QQueue=* --invoke pause");	assertTrue("invoked", result.contains("Q1"));	assertTrue("invoked", result.contains("Q2"));	result = executeQuery("-QQueue=Q2 --view Paused");	assertTrue("got pause status", result.contains("Paused = true"));	result = executeQuery("-QQueue=Q2 --invoke resume");	
result of invoke 

assertTrue("invoked", result.contains("Q2"));	result = executeQuery("-QQueue=Q2 --view Paused");	assertTrue("got pause status", result.contains("Paused = true"));	result = executeQuery("-QQueue=Q2 --invoke resume");	assertTrue("invoked", result.contains("Q2"));	result = executeQuery("-QQueue=Q2 --view Paused");	assertTrue("pause status", result.contains("Paused = false"));	result = executeQuery("-QQueue=Q1 --view Paused");	assertTrue("pause status", result.contains("Paused = true"));	result = executeQuery("-QQueue=Q2 --invoke sendTextMessage,hi");	
result of invoke 

========================= activemq sample_1482 =========================

protected Session createConsumer() throws JMSException {	final String consumerText = "Consumer: " + (++consumerCounter);	
creating consumer on destination 

protected Session createConsumer() throws JMSException {	final String consumerText = "Consumer: " + (++consumerCounter);	Session answer = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = answer.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	
received message by message 

========================= activemq sample_3515 =========================

protected void tearDown() throws Exception {	super.tearDown();	if (threadPool != null) {	for (ThreadedMessageReceiver receiver : receivers) {	receiver.setShouldStop(true);	}	
waiting for receivers to shutdown 

protected void tearDown() throws Exception {	super.tearDown();	if (threadPool != null) {	for (ThreadedMessageReceiver receiver : receivers) {	receiver.setShouldStop(true);	}	if (!threadPool.awaitTermination(10, TimeUnit.SECONDS)) {	
not all receivers completed shutdown 

protected void tearDown() throws Exception {	super.tearDown();	if (threadPool != null) {	for (ThreadedMessageReceiver receiver : receivers) {	receiver.setShouldStop(true);	}	if (!threadPool.awaitTermination(10, TimeUnit.SECONDS)) {	} else {	
all receivers shutdown successfully 

protected void tearDown() throws Exception {	super.tearDown();	if (threadPool != null) {	for (ThreadedMessageReceiver receiver : receivers) {	receiver.setShouldStop(true);	}	if (!threadPool.awaitTermination(10, TimeUnit.SECONDS)) {	} else {	}	}	
stoping the broker 

session = queueConnection.createQueueSession(false, QueueSession.AUTO_ACKNOWLEDGE);	queue = session.createQueue(TEST_QUEUE_NAME);	sender = session.createSender(queue);	sender.setDeliveryMode(DeliveryMode.PERSISTENT);	message = session.createTextMessage(String.valueOf(i));	sender.send(message);	if (session.getTransacted()) {	session.commit();	}	if (i % 1000 == 0) {	
message successfully sent to messageid content 

fail("Duplicate message id detected");	}	sendTextMessage(TEST_QUEUE_NAME, i);	}	for (int i = 0; i < CONSUMER_COUNT; i++) {	receivers[i] = new ThreadedMessageReceiver(TEST_QUEUE_NAME, new IMessageHandler() {	public void onMessage(Message message) throws Exception {	synchronized (lock) {	int current = messageCount.incrementAndGet();	if (current % 1000 == 0) {	
received message with content 

}	for (int i = 0; i < CONSUMER_COUNT; i++) {	receivers[i] = new ThreadedMessageReceiver(TEST_QUEUE_NAME, new IMessageHandler() {	public void onMessage(Message message) throws Exception {	synchronized (lock) {	int current = messageCount.incrementAndGet();	if (current % 1000 == 0) {	}	if (messages.containsKey(message.getJMSMessageID())) {	duplicateSignal.countDown();	
duplicate message id detected 

}	});	threadPool.submit(receivers[i]);	}	for (int i = 0; i < TEST_MESSAGE_COUNT / 2; i++) {	if (duplicateSignal.getCount() == 0) {	fail("Duplicate message id detected");	}	sendTextMessage(TEST_QUEUE_NAME, i);	}	
sent all messages 

QueueReceiver receiver = null;	Queue queue = null;	Message message = null;	try {	try {	queueConnection = connectionFactory.createQueueConnection();	session = queueConnection.createQueueSession(TRANSACTED_RECEIVE, QueueSession.AUTO_ACKNOWLEDGE);	queue = session.createQueue(TEST_QUEUE_NAME);	receiver = session.createReceiver(queue);	queueConnection.start();	
receiver connected 

throw e;	}	}	if (message != null && this.handler != null) {	this.handler.onMessage(message);	}	if (session.getTransacted()) {	session.commit();	}	}	
receiver shutting down 

========================= activemq sample_2754 =========================

connectionFactory.setPrefetchPolicy(prefetchPolicy);	Connection c = connectionFactory.createConnection();	c.start();	Session listenerSession = c.createSession(false, 1);	Destination destination = createDestination(listenerSession);	listenerSession.createConsumer(destination).setMessageListener(new TopicProducerToSubFileCursorTest());	final AtomicInteger blockedCounter = new AtomicInteger(0);	listenerSession.createConsumer(new ActiveMQTopic(AdvisorySupport.FULL_TOPIC_PREFIX + ">")).setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	
got full advisory usagename usagecount blockedcounter 

Session listenerSession = c.createSession(false, 1);	Destination destination = createDestination(listenerSession);	listenerSession.createConsumer(destination).setMessageListener(new TopicProducerToSubFileCursorTest());	final AtomicInteger blockedCounter = new AtomicInteger(0);	listenerSession.createConsumer(new ActiveMQTopic(AdvisorySupport.FULL_TOPIC_PREFIX + ">")).setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	blockedCounter.incrementAndGet();	} catch (Exception error) {	error.printStackTrace();	
missing advisory property 

});	final Session session = connectionFactory.createConnection().createSession(false, Session.AUTO_ACKNOWLEDGE);	final MessageProducer producer = session.createProducer(destination);	Thread producingThread = new Thread("Producing Thread") {	public void run() {	try {	for (long i = 0; i < numMessagesToSend; i++) {	producer.send(session.createTextMessage("test"));	long count = produced.incrementAndGet();	if (count % 10000 == 0) {	
produced messages 

public void onMessage(Message message) {	long count = consumed.incrementAndGet();	if (count % 100 == 0) {	try {	Thread.sleep(100);	} catch (InterruptedException e) {	}	}	if (count % 10000 == 0) {	
tconsumed messages 

========================= activemq sample_3684 =========================

public void testMocksAreValid() throws Exception {	expectedEndpoint.expectedMessageCount(1);	expectedEndpoint.message(0).header("JMSXGroupID").isEqualTo("ABC");	MockEndpoint.assertIsSatisfied(camelContext);	List<Exchange> list = expectedEndpoint.getReceivedExchanges();	for (Exchange exchange : list) {	Object body = exchange.getIn().getBody();	
received body of type on 

========================= activemq sample_1343 =========================

public void run() {	long now = System.currentTimeMillis();	if ((now - startTime) >= connectionTimeout && connectCheckerTask != null && !ASYNC_TASKS.isShutdown()) {	
no connection attempt made in time for throwing inactivityioexception 

long now = System.currentTimeMillis();	if ((now - startTime) >= connectionTimeout && connectCheckerTask != null && !ASYNC_TASKS.isShutdown()) {	try {	ASYNC_TASKS.execute(new Runnable() {	public void run() {	onException(new InactivityIOException( "Channel was inactive for too (>" + (connectionTimeout) + ") long: " + next.getRemoteAddress()));	}	});	} catch (RejectedExecutionException ex) {	if (!ASYNC_TASKS.isShutdown()) {	
async connection timeout task was rejected from the executor 

}	}	}	} catch (Exception ex) {	onException(new InactivityIOException( "Exception while performing idle checks for connection: " + next.getRemoteAddress()));	}	}	});	} catch (RejectedExecutionException ex) {	if (!ASYNC_TASKS.isShutdown()) {	
async connection timeout task was rejected from the executor 

========================= activemq sample_1713 =========================

public void testPriorityBackupAndUpdateClients() throws Exception {	addBroker(BROKER_A_NAME, createBroker(BROKER_A_NAME));	addTransportConnector(getBroker(BROKER_A_NAME), "openwire", BROKER_A_CLIENT_TC_ADDRESS, true);	addNetworkBridge(getBroker(BROKER_A_NAME), "A_2_B_Bridge", "static: getBroker(BROKER_A_NAME).start();	addBroker(BROKER_B_NAME, createBroker(BROKER_B_NAME));	addTransportConnector(getBroker(BROKER_B_NAME), "openwire", BROKER_B_CLIENT_TC_ADDRESS, true);	addNetworkBridge(getBroker(BROKER_B_NAME), "B_2_A_Bridge", "static: getBroker(BROKER_B_NAME).start();	getBroker(BROKER_B_NAME).waitUntilStarted();	Thread.sleep(1000);	setClientUrl("failover:(" + BROKER_A_CLIENT_TC_ADDRESS + "," + BROKER_B_CLIENT_TC_ADDRESS + ")?randomize=false&priorityBackup=true&initialReconnectDelay=1000&useExponentialBackOff=false");	
client uri will be 

private void restart(boolean primary, String primaryName, String secondaryName) throws Exception {	Thread.sleep(1000);	if (primary) {	
stopping 

private void restart(boolean primary, String primaryName, String secondaryName) throws Exception {	Thread.sleep(1000);	if (primary) {	stopBroker(primaryName);	} else {	
stopping 

}	Thread.sleep(5000);	if (primary) {	assertAllConnectedTo(urls.get(secondaryName));	assertBrokerInfo(secondaryName);	} else {	assertAllConnectedTo(urls.get(primaryName));	assertBrokerInfo(primaryName);	}	if (primary) {	
starting 

assertAllConnectedTo(urls.get(secondaryName));	assertBrokerInfo(secondaryName);	} else {	assertAllConnectedTo(urls.get(primaryName));	assertBrokerInfo(primaryName);	}	if (primary) {	createBrokerByName(primaryName);	getBroker(primaryName).waitUntilStarted();	} else {	
starting 

========================= activemq sample_2580 =========================

Connection con = factory.createConnection();	Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	createDestination(session, destinationName);	con.close();	for (int i = 0; i < 3; i++) {	Connection connection = factory.createConnection();	connection.start();	Session s = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination dest = s.createTemporaryQueue();	s.createConsumer(dest);	
created connnection 

========================= activemq sample_3542 =========================

MessageProducer producer = session.createProducer(destination);	for (int i = 0; i < 10; ++i) {	producer.send(session.createTextMessage("test"));	}	producer.close();	connection.close();	List<Message> queuedMessages = null;	try {	queuedMessages = dumpMessages();	} catch (Exception ex) {	
caught ex 

protected List<Message> dumpMessages() throws Exception {	WireFormat wireFormat = new OpenWireFormat();	java.sql.Connection conn = ((JDBCPersistenceAdapter) service.getPersistenceAdapter()).getDataSource().getConnection();	PreparedStatement statement = conn.prepareStatement("SELECT ID, MSG FROM MYPREFIX_ACTIVEMQ_MSGS");	ResultSet result = statement.executeQuery();	ArrayList<Message> results = new ArrayList<Message>();	while(result.next()) {	long id = result.getLong(1);	Message message = (Message)wireFormat.unmarshal(new ByteSequence(result.getBytes(2)));	
id message seqid msg 

========================= activemq sample_3810 =========================

public void tearDown() throws Exception {	try {	stopBroker();	} catch(Exception e) {	
error on broker stop 

========================= activemq sample_1084 =========================

public void testNoUserOrPassword() throws Exception {	try {	connection = JMSClientContext.INSTANCE.createConnection(amqpURI, "", "");	connection.start();	fail("Expected JMSException");	} catch (JMSSecurityException ex) {	
failed to authenticate connection with no user password 

public void testUnknownUser() throws Exception {	try {	connection = JMSClientContext.INSTANCE.createConnection(amqpURI, "nosuchuser", "blah");	connection.start();	fail("Expected JMSException");	} catch (JMSSecurityException ex) {	
failed to authenticate connection with unknown user id 

public void testKnownUserWrongPassword() throws Exception {	try {	connection = JMSClientContext.INSTANCE.createConnection(amqpURI, "user", "wrongPassword");	connection.start();	fail("Expected JMSException");	} catch (JMSSecurityException ex) {	
failed to authenticate connection with incorrect password 

public void testRepeatedWrongPasswordAttempts() throws Exception {	for (int i = 0; i < 25; ++i) {	Connection connection = null;	try {	connection = JMSClientContext.INSTANCE.createConnection(amqpURI, "user", "wrongPassword");	connection.start();	fail("Expected JMSException");	} catch (JMSSecurityException ex) {	
failed to authenticate connection with incorrect password 

public void testProducerNotAuthorized() throws Exception {	connection = JMSClientContext.INSTANCE.createConnection(amqpURI, "guest", "guestPassword");	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue("USERS.txQueue");	try {	session.createProducer(queue);	fail("Should not be able to produce here.");	} catch (JMSSecurityException jmsSE) {	
caught expected exception 

public void testAnonymousProducerNotAuthorized() throws Exception {	connection = JMSClientContext.INSTANCE.createConnection(amqpURI, "guest", "guestPassword");	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue("USERS.txQueue");	MessageProducer producer = session.createProducer(null);	try {	producer.send(queue, session.createTextMessage());	fail("Should not be able to produce here.");	} catch (JMSSecurityException jmsSE) {	
caught expected exception 

public void testCreateTemporaryQueueNotAuthorized() throws JMSException {	connection = JMSClientContext.INSTANCE.createConnection(amqpURI, "user", "userPassword");	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	try {	session.createTemporaryQueue();	} catch (JMSSecurityException jmsse) {	} catch (JMSException jmse) {	
client should have thrown a jmssecurityexception but only threw jmsexception 

public void testCreateTemporaryTopicNotAuthorized() throws JMSException {	connection = JMSClientContext.INSTANCE.createConnection(amqpURI, "user", "userPassword");	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	try {	session.createTemporaryTopic();	} catch (JMSSecurityException jmsse) {	} catch (JMSException jmse) {	
client should have thrown a jmssecurityexception but only threw jmsexception 

protected BrokerService createBroker(String uri) throws Exception {	
loading broker configuration from the classpath with uri 

========================= activemq sample_1591 =========================

public void testPropertiesFile() throws Exception {	BrokerService broker = BrokerFactory.createBroker("properties:org/apache/activemq/config/broker.properties");	
created broker 

public void testVmBrokerPropertiesFile() throws Exception {	ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("vm: Connection connection = factory.createConnection();	BrokerService broker = BrokerRegistry.getInstance().lookup("Cheese");	
found broker 

========================= activemq sample_2647 =========================

public void run() {	try {	while (running) {	String result = consume();	if(result != null) {	send(result);	rate.increment();	}	else if (running) {	
failed to consume 

========================= activemq sample_2997 =========================

public void testUnauthorizedProducerIsNotRecreated() throws Exception {	final CountDownLatch connectionDropped = new CountDownLatch(1);	final CountDownLatch connectionRestored = new CountDownLatch(1);	connection = (ActiveMQConnection) cf.createConnection();	connection.addTransportListener(new TransportListener() {	public void transportResumed() {	
connection restored 

final CountDownLatch connectionDropped = new CountDownLatch(1);	final CountDownLatch connectionRestored = new CountDownLatch(1);	connection = (ActiveMQConnection) cf.createConnection();	connection.addTransportListener(new TransportListener() {	public void transportResumed() {	if (connectionDropped.getCount() == 0) {	connectionRestored.countDown();	}	}	public void transportInterupted() {	
connection interrupted 

========================= activemq sample_2581 =========================

protected final void waitForSpace(ConnectionContext context, ProducerBrokerExchange producerBrokerExchange, Usage<?> usage, int highWaterMark, String warning) throws IOException, InterruptedException, ResourceAllocationException {	if (!context.isNetworkConnection() && systemUsage.isSendFailIfNoSpace()) {	if (isFlowControlLogRequired()) {	
sendfailifnospace forcing exception on send usage 

protected final void waitForSpace(ConnectionContext context, ProducerBrokerExchange producerBrokerExchange, Usage<?> usage, int highWaterMark, String warning) throws IOException, InterruptedException, ResourceAllocationException {	if (!context.isNetworkConnection() && systemUsage.isSendFailIfNoSpace()) {	if (isFlowControlLogRequired()) {	} else {	
sendfailifnospace forcing exception on send usage 

protected final void waitForSpace(ConnectionContext context, ProducerBrokerExchange producerBrokerExchange, Usage<?> usage, int highWaterMark, String warning) throws IOException, InterruptedException, ResourceAllocationException {	if (!context.isNetworkConnection() && systemUsage.isSendFailIfNoSpace()) {	if (isFlowControlLogRequired()) {	} else {	}	throw new ResourceAllocationException(warning);	}	if (!context.isNetworkConnection() && systemUsage.getSendFailIfNoSpaceAfterTimeout() != 0) {	if (!usage.waitForSpace(systemUsage.getSendFailIfNoSpaceAfterTimeout(), highWaterMark)) {	if (isFlowControlLogRequired()) {	
sendfailifnospaceaftertimeout expired forcing exception on send usage 

if (!context.isNetworkConnection() && systemUsage.isSendFailIfNoSpace()) {	if (isFlowControlLogRequired()) {	} else {	}	throw new ResourceAllocationException(warning);	}	if (!context.isNetworkConnection() && systemUsage.getSendFailIfNoSpaceAfterTimeout() != 0) {	if (!usage.waitForSpace(systemUsage.getSendFailIfNoSpaceAfterTimeout(), highWaterMark)) {	if (isFlowControlLogRequired()) {	} else {	
sendfailifnospaceaftertimeout expired forcing exception on send usage 

}	} else {	long start = System.currentTimeMillis();	producerBrokerExchange.blockingOnFlowControl(true);	destinationStatistics.getBlockedSends().increment();	while (!usage.waitForSpace(1000, highWaterMark)) {	if (context.getStopping().get()) {	throw new IOException("Connection closed, send aborted.");	}	if (isFlowControlLogRequired()) {	
blocking for s 

public void duplicateFromStore(Message message, Subscription durableSub) {	ConnectionContext connectionContext = createConnectionContext();	
duplicate message from store redirecting for dlq processing 

public void duplicateFromStore(Message message, Subscription durableSub) {	ConnectionContext connectionContext = createConnectionContext();	Throwable cause = new Throwable("duplicate from store for " + destination);	message.setRegionDestination(this);	broker.getRoot().sendToDeadLetterQueue(connectionContext, message, null, cause);	MessageAck messageAck = new MessageAck(message, MessageAck.POSION_ACK_TYPE, 1);	messageAck.setPoisonCause(cause);	try {	acknowledge(connectionContext, durableSub, messageAck, message);	} catch (IOException e) {	
failed to acknowledge duplicate message from with 

========================= activemq sample_4005 =========================

public void remotelyClosed(AmqpConnection connection) {	Exception error = AmqpSupport.convertToException(getEndpoint().getRemoteCondition());	if (endpoint != null) {	endpoint.close();	}	
resource was remotely closed 

public void locallyClosed(AmqpConnection connection, Exception error) {	if (endpoint != null) {	endpoint.close();	}	
resource was locally closed 

public void processRemoteDetach(AmqpConnection connection) throws IOException {	doDetachedInspection();	if (isAwaitingClose()) {	
is now closed 

public void processRemoteClose(AmqpConnection connection) throws IOException {	doClosedInspection();	if (isAwaitingClose()) {	
is now closed 

public void processRemoteClose(AmqpConnection connection) throws IOException {	doClosedInspection();	if (isAwaitingClose()) {	closed();	} else if (isAwaitingOpen()) {	
open of failed 

protected void doOpenCompletion() {	
is now open 

========================= activemq sample_1657 =========================

protected Session createProducer() throws JMSException {	final String consumerText = "Consumer: " + (++consumerCounter);	
creating consumer on destination 

========================= activemq sample_3514 =========================

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	connection = createConnection();	if (durable) {	connection.setClientID(getClass().getName());	}	
created connection 

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	connection = createConnection();	if (durable) {	connection.setClientID(getClass().getName());	}	session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	consumeSession = createConsumerSession();	
created session 

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	connection = createConnection();	if (durable) {	connection.setClientID(getClass().getName());	}	session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	consumeSession = createConsumerSession();	
created consumesession 

producer = session.createProducer(null);	producer.setDeliveryMode(deliveryMode);	LOG.info("Created producer: " + producer + " delivery mode = " + (deliveryMode == DeliveryMode.PERSISTENT ? "PERSISTENT" : "NON_PERSISTENT"));	if (topic) {	consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	} else {	consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	}	
created consumer destination of type 

producer = session.createProducer(null);	producer.setDeliveryMode(deliveryMode);	LOG.info("Created producer: " + producer + " delivery mode = " + (deliveryMode == DeliveryMode.PERSISTENT ? "PERSISTENT" : "NON_PERSISTENT"));	if (topic) {	consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	} else {	consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	}	
created producer destination of type 

if (topic) {	consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	} else {	consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	}	consumer = createConsumer();	consumer.setMessageListener(this);	startConnection();	
created connection 

protected void tearDown() throws Exception {	
closing down connection 

protected MessageConsumer createConsumer() throws JMSException {	if (durable) {	
creating durable consumer 

========================= activemq sample_2610 =========================

public void testDest1Deletion() throws Exception {	
creating first second 

public void testDest1Deletion() throws Exception {	
removing subscribing to 

public void testDest2Deletion() throws Exception {	
creating first second 

public void testDest2Deletion() throws Exception {	
removing subscribing to 

public void testStoreCleanupDeleteDest1First() throws Exception {	
creating first second 

public void testStoreCleanupDeleteDest1First() throws Exception {	
deleting first second 

public void testStoreCleanupDeleteDest2First() throws Exception {	
creating first second 

public void testStoreCleanupDeleteDest2First() throws Exception {	
deleting first second 

========================= activemq sample_3778 =========================

public void testTransactedConsumer() throws Exception {	ActiveMQAdmin.enableJMSFrameTracing();	final int msgCount = 1;	connection = createConnection();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Queue queue = session.createQueue(getDestinationName());	sendMessages(connection, queue, msgCount);	QueueViewMBean queueView = getProxyToQueue(getDestinationName());	
queue size after produce is 

connection = createConnection();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Queue queue = session.createQueue(getDestinationName());	sendMessages(connection, queue, msgCount);	QueueViewMBean queueView = getProxyToQueue(getDestinationName());	assertEquals(msgCount, queueView.getQueueSize());	MessageConsumer consumer = session.createConsumer(queue);	Message msg = consumer.receive(TestConfig.TIMEOUT);	assertNotNull(msg);	assertTrue(msg instanceof TextMessage);	
queue size before session commit is 

Queue queue = session.createQueue(getDestinationName());	sendMessages(connection, queue, msgCount);	QueueViewMBean queueView = getProxyToQueue(getDestinationName());	assertEquals(msgCount, queueView.getQueueSize());	MessageConsumer consumer = session.createConsumer(queue);	Message msg = consumer.receive(TestConfig.TIMEOUT);	assertNotNull(msg);	assertTrue(msg instanceof TextMessage);	assertEquals(msgCount, queueView.getQueueSize());	session.commit();	
queue size after session commit is 

public void testRollbackRececeivedMessage() throws Exception {	ActiveMQAdmin.enableJMSFrameTracing();	final int msgCount = 1;	connection = createConnection();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Queue queue = session.createQueue(getDestinationName());	sendMessages(connection, queue, msgCount);	QueueViewMBean queueView = getProxyToQueue(getDestinationName());	
queue size after produce is 

ActiveMQAdmin.enableJMSFrameTracing();	final int msgCount = 1;	connection = createConnection();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Queue queue = session.createQueue(getDestinationName());	sendMessages(connection, queue, msgCount);	QueueViewMBean queueView = getProxyToQueue(getDestinationName());	assertEquals(msgCount, queueView.getQueueSize());	MessageConsumer consumer = session.createConsumer(queue);	Message msg = consumer.receive(TestConfig.TIMEOUT);	
test received msg 

MessageConsumer consumer = session.createConsumer(queue);	Message msg = consumer.receive(TestConfig.TIMEOUT);	assertNotNull(msg);	assertTrue(msg instanceof TextMessage);	assertEquals(false, msg.getJMSRedelivered());	session.rollback();	msg = consumer.receive(TestConfig.TIMEOUT);	assertNotNull(msg);	assertTrue(msg instanceof TextMessage);	assertEquals(true, msg.getJMSRedelivered());	
queue size after produce is 

assertNotNull(msg);	assertTrue(msg instanceof TextMessage);	assertEquals(false, msg.getJMSRedelivered());	session.rollback();	msg = consumer.receive(TestConfig.TIMEOUT);	assertNotNull(msg);	assertTrue(msg instanceof TextMessage);	assertEquals(true, msg.getJMSRedelivered());	assertEquals(msgCount, queueView.getQueueSize());	session.commit();	
queue size after produce is 

public void testTXConsumerAndLargeNumberOfMessages() throws Exception {	ActiveMQAdmin.enableJMSFrameTracing();	final int msgCount = 300;	connection = createConnection();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Queue queue = session.createQueue(getDestinationName());	sendMessages(connection, queue, msgCount);	QueueViewMBean queueView = getProxyToQueue(getDestinationName());	
queue size after produce is 

connection = createConnection();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Queue queue = session.createQueue(getDestinationName());	sendMessages(connection, queue, msgCount);	QueueViewMBean queueView = getProxyToQueue(getDestinationName());	assertEquals(msgCount, queueView.getQueueSize());	{	MessageConsumer consumer = session.createConsumer(queue);	for (int i = 0; i < msgCount; ++i) {	if ((i % 100) == 0) {	
attempting receive of message 

if ((i % 100) == 0) {	}	Message msg = consumer.receive(TestConfig.TIMEOUT);	assertNotNull("Should receive message: " + i, msg);	assertTrue(msg instanceof TextMessage);	}	session.commit();	consumer.close();	session.close();	}	
queue size after produce is 

try {	for (int i = 0; i < 30; ++i) {	producer.send(m);	synchronized (producer) {	producer.notifyAll();	}	TimeUnit.MILLISECONDS.sleep(100);	}	msg = "Should have thrown an IllegalStateException";	} catch (Exception ex) {	
caught exception on send 

synchronized (session) {	session.notifyAll();	}	if (producer == null) {	msg = "Producer should not be null";	}	TimeUnit.SECONDS.sleep(1);	}	msg = "Should have thrown an IllegalStateException";	} catch (Exception ex) {	
caught exception on create producer 

connection.start();	MessageProducer producer = session.createProducer(queue);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	Message m = session.createTextMessage("Sample text");	producer.send(m);	stopBroker();	try {	session.createConsumer(queue);	fail("Should have thrown an IllegalStateException");	} catch (Exception ex) {	
caught exception on consumer create 

try {	for (int i = 0; i < 10; ++i) {	consumer.receiveNoWait();	synchronized (consumer) {	consumer.notifyAll();	}	TimeUnit.MILLISECONDS.sleep(1000 + (i * 100));	}	msg = "Should have thrown an IllegalStateException";	} catch (Exception ex) {	
caught exception on receivenowait 

public synchronized void run() {	try {	for (int i = 0; i < 10; ++i) {	consumer.receive(100 + (i * 1000));	synchronized (consumer) {	consumer.notifyAll();	}	}	msg = "Should have thrown an IllegalStateException";	} catch (Exception ex) {	
caught exception on receive 

if (m != null) {	msg = "Should have returned null";	return;	}	}	m = consumer.receive();	if (m != null) {	msg = "Should have returned null";	}	} catch (Exception ex) {	
caught exception on receive 

Queue queue = session.createQueue(getDestinationName());	connection.start();	MessageProducer producer = session.createProducer(queue);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	Message m = session.createTextMessage("Sample text");	producer.send(m);	restartBroker();	try {	connection.close();	} catch (Exception ex) {	
should not thrown on disconnected connection close 

public void testConnectionsAreClosed() throws Exception {	ActiveMQAdmin.enableJMSFrameTracing();	final ConnectorViewMBean connector = getProxyToConnectionView(getTargetConnectorName());	
current number of connections is 

public void testConnectionsAreClosed() throws Exception {	ActiveMQAdmin.enableJMSFrameTracing();	final ConnectorViewMBean connector = getProxyToConnectionView(getTargetConnectorName());	ArrayList<Connection> connections = new ArrayList<>();	for (int i = 0; i < 10; i++) {	connections.add(createConnection(null));	}	
current number of connections is 

final ConnectorViewMBean connector = getProxyToConnectionView(getTargetConnectorName());	ArrayList<Connection> connections = new ArrayList<>();	for (int i = 0; i < 10; i++) {	connections.add(createConnection(null));	}	for (Connection connection : connections) {	connection.close();	}	assertTrue("Should have no connections left.", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
current number of connections is 

public void testExecptionListenerCalledOnBrokerStop() throws Exception {	ActiveMQAdmin.enableJMSFrameTracing();	connection = createConnection();	Session s = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	connection.start();	final CountDownLatch called = new CountDownLatch(1);	connection.setExceptionListener(new ExceptionListener() {	public void onException(JMSException exception) {	
exception listener called 

private String createLargeString(int sizeInBytes) {	byte[] base = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};	StringBuilder builder = new StringBuilder();	for (int i = 0; i < sizeInBytes; i++) {	builder.append(base[i % base.length]);	}	
created string with size bytes 

public void testSendLargeMessage() throws JMSException, InterruptedException {	connection = createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	String queueName = getDestinationName();	Queue queue = session.createQueue(queueName);	MessageProducer producer=session.createProducer(queue);	int messageSize = 1024 * 1024;	String messageText = createLargeString(messageSize);	Message m=session.createTextMessage(messageText);	
sending message of bytes on queue 

MessageProducer producer=session.createProducer(queue);	int messageSize = 1024 * 1024;	String messageText = createLargeString(messageSize);	Message m=session.createTextMessage(messageText);	producer.send(m);	MessageConsumer  consumer=session.createConsumer(queue);	Message message = consumer.receive();	assertNotNull(message);	assertTrue(message instanceof TextMessage);	TextMessage textMessage = (TextMessage) message;	
received message of length 

public void testDurableTopicStateAfterSubscriberClosed() throws Exception {	String durableClientId = getDestinationName() + "-ClientId";	String durableSubscriberName = getDestinationName() + "-SubscriptionName";	BrokerView adminView = this.brokerService.getAdminView();	int durableSubscribersAtStart = adminView.getDurableTopicSubscribers().length;	int inactiveSubscribersAtStart = adminView.getInactiveDurableTopicSubscribers().length;	
at start durable subscribers inactivedurablesubscribers 

int durableSubscribersAtStart = adminView.getDurableTopicSubscribers().length;	int inactiveSubscribersAtStart = adminView.getInactiveDurableTopicSubscribers().length;	TopicConnection subscriberConnection = JMSClientContext.INSTANCE.createTopicConnection(getBrokerURI(), "admin", "password");	subscriberConnection.setClientID(durableClientId);	TopicSession subscriberSession = subscriberConnection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);	Topic topic = subscriberSession.createTopic(getDestinationName());	TopicSubscriber messageConsumer = subscriberSession.createDurableSubscriber(topic, durableSubscriberName);	assertNotNull(messageConsumer);	int durableSubscribers = adminView.getDurableTopicSubscribers().length;	int inactiveSubscribers = adminView.getInactiveDurableTopicSubscribers().length;	
durable subscribers after creation inactivedurablesubscribers 

Topic topic = subscriberSession.createTopic(getDestinationName());	TopicSubscriber messageConsumer = subscriberSession.createDurableSubscriber(topic, durableSubscriberName);	assertNotNull(messageConsumer);	int durableSubscribers = adminView.getDurableTopicSubscribers().length;	int inactiveSubscribers = adminView.getInactiveDurableTopicSubscribers().length;	assertEquals("Wrong number of durable subscribers after first subscription", 1, (durableSubscribers - durableSubscribersAtStart));	assertEquals("Wrong number of inactive durable subscribers after first subscription", 0, (inactiveSubscribers - inactiveSubscribersAtStart));	subscriberConnection.close();	durableSubscribers = adminView.getDurableTopicSubscribers().length;	inactiveSubscribers = adminView.getInactiveDurableTopicSubscribers().length;	
durable subscribers after close inactivedurablesubscribers 

} else {	destination = session.createQueue(getDestinationName());	}	MessageConsumer consumer = session.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	message.acknowledge();	done.countDown();	} catch (JMSException ex) {	
caught exception 

========================= activemq sample_1600 =========================

public synchronized boolean recoverMessage(Message message, boolean cached) throws Exception {	
recover priority 

protected synchronized int getStoreSize() {	try {	return store.getMessageCount(clientId, subscriberName);	} catch (Exception e) {	
failed to get the outstanding message count from the store 

protected synchronized long getStoreMessageSize() {	try {	return store.getMessageSize(clientId, subscriberName);	} catch (Exception e) {	
failed to get the outstanding message count from the store 

protected synchronized boolean isStoreEmpty() {	try {	return this.store.isEmpty();	} catch (Exception e) {	
failed to determine if store is empty 

========================= activemq sample_4052 =========================

protected void tearDown() throws Exception {	
closing down connection 

protected void tearDown() throws Exception {	try {	session.close();	session = null;	} catch (Exception e) {	
caught exception while closing resources 

protected void tearDown() throws Exception {	try {	session.close();	session = null;	} catch (Exception e) {	}	try {	connection.close();	connection = null;	} catch (Exception e) {	
caught exception while closing resources 

try {	connection.close();	connection = null;	} catch (Exception e) {	}	try {	broker.stop();	broker.waitUntilStopped();	broker = null;	} catch (Exception e) {	
caught exception while shutting down the broker 

connection.close();	connection = null;	} catch (Exception e) {	}	try {	broker.stop();	broker.waitUntilStopped();	broker = null;	} catch (Exception e) {	}	
connection closed 

protected abstract JmsResourceProvider getJmsResourceProvider();	public void testSendReceiveTransactedBatches() throws Exception {	TextMessage message = session.createTextMessage("Batch Message");	for (int j = 0; j < batchCount; j++) {	
producing bacth of messages 

protected abstract JmsResourceProvider getJmsResourceProvider();	public void testSendReceiveTransactedBatches() throws Exception {	TextMessage message = session.createTextMessage("Batch Message");	for (int j = 0; j < batchCount; j++) {	beginTx();	for (int i = 0; i < batchSize; i++) {	producer.send(message);	}	messageSent();	commitTx();	
consuming bacth of messages 

producer.send(outbound[0]);	commitTx();	beginTx();	producer.send(session.createTextMessage("I'm going to get rolled back."));	rollbackTx();	beginTx();	producer.send(outbound[1]);	commitTx();	beginTx();	ArrayList<Message> messages = new ArrayList<Message>();	
about to consume message 

beginTx();	producer.send(session.createTextMessage("I'm going to get rolled back."));	rollbackTx();	beginTx();	producer.send(outbound[1]);	commitTx();	beginTx();	ArrayList<Message> messages = new ArrayList<Message>();	Message message = consumer.receive(1000);	messages.add(message);	
received 

beginTx();	producer.send(session.createTextMessage("I'm going to get rolled back."));	rollbackTx();	beginTx();	producer.send(outbound[1]);	commitTx();	beginTx();	ArrayList<Message> messages = new ArrayList<Message>();	Message message = consumer.receive(1000);	messages.add(message);	
about to consume message 

rollbackTx();	beginTx();	producer.send(outbound[1]);	commitTx();	beginTx();	ArrayList<Message> messages = new ArrayList<Message>();	Message message = consumer.receive(1000);	messages.add(message);	message = consumer.receive(4000);	messages.add(message);	
received 

public void testAckMessageInTx() throws Exception {	Message[] outbound = new Message[] {session.createTextMessage("First Message")};	beginTx();	producer.send(outbound[0]);	outbound[0].acknowledge();	commitTx();	outbound[0].acknowledge();	beginTx();	ArrayList<Message> messages = new ArrayList<Message>();	
about to consume message 

Message[] outbound = new Message[] {session.createTextMessage("First Message")};	beginTx();	producer.send(outbound[0]);	outbound[0].acknowledge();	commitTx();	outbound[0].acknowledge();	beginTx();	ArrayList<Message> messages = new ArrayList<Message>();	Message message = consumer.receive(1000);	messages.add(message);	
received 

beginTx();	producer.send(outbound[0]);	commitTx();	beginTx();	producer.send(session.createTextMessage("I'm going to get rolled back."));	consumer.close();	reconnectSession();	producer.send(outbound[1]);	commitTx();	ArrayList<Message> messages = new ArrayList<Message>();	
about to consume message 

beginTx();	producer.send(session.createTextMessage("I'm going to get rolled back."));	consumer.close();	reconnectSession();	producer.send(outbound[1]);	commitTx();	ArrayList<Message> messages = new ArrayList<Message>();	beginTx();	Message message = consumer.receive(1000);	messages.add(message);	
received 

beginTx();	producer.send(session.createTextMessage("I'm going to get rolled back."));	consumer.close();	reconnectSession();	producer.send(outbound[1]);	commitTx();	ArrayList<Message> messages = new ArrayList<Message>();	beginTx();	Message message = consumer.receive(1000);	messages.add(message);	
about to consume message 

consumer.close();	reconnectSession();	producer.send(outbound[1]);	commitTx();	ArrayList<Message> messages = new ArrayList<Message>();	beginTx();	Message message = consumer.receive(1000);	messages.add(message);	message = consumer.receive(4000);	messages.add(message);	
received 

commitTx();	beginTx();	producer.send(session.createTextMessage("I'm going to get rolled back."));	consumer.close();	session.close();	reconnect();	beginTx();	producer.send(outbound[1]);	commitTx();	ArrayList<Message> messages = new ArrayList<Message>();	
about to consume message 

consumer.close();	session.close();	reconnect();	beginTx();	producer.send(outbound[1]);	commitTx();	ArrayList<Message> messages = new ArrayList<Message>();	beginTx();	Message message = consumer.receive(1000);	messages.add(message);	
received 

consumer.close();	session.close();	reconnect();	beginTx();	producer.send(outbound[1]);	commitTx();	ArrayList<Message> messages = new ArrayList<Message>();	beginTx();	Message message = consumer.receive(1000);	messages.add(message);	
about to consume message 

reconnect();	beginTx();	producer.send(outbound[1]);	commitTx();	ArrayList<Message> messages = new ArrayList<Message>();	beginTx();	Message message = consumer.receive(1000);	messages.add(message);	message = consumer.receive(4000);	messages.add(message);	
received 

public void testReceiveRollback() throws Exception {	Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};	beginTx();	while (consumer.receive(1000) != null) {	}	commitTx();	beginTx();	producer.send(outbound[0]);	producer.send(outbound[1]);	commitTx();	
sent 

public void testReceiveRollback() throws Exception {	Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};	beginTx();	while (consumer.receive(1000) != null) {	}	commitTx();	beginTx();	producer.send(outbound[0]);	producer.send(outbound[1]);	commitTx();	
sent 

public void testReceiveTwoThenRollback() throws Exception {	Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};	beginTx();	while (consumer.receive(1000) != null) {	}	commitTx();	beginTx();	producer.send(outbound[0]);	producer.send(outbound[1]);	commitTx();	
sent 

public void testReceiveTwoThenRollback() throws Exception {	Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};	beginTx();	while (consumer.receive(1000) != null) {	}	commitTx();	beginTx();	producer.send(outbound[0]);	producer.send(outbound[1]);	commitTx();	
sent 

public void testSendReceiveWithPrefetchOne() throws Exception {	setPrefetchToOne();	Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message"), session.createTextMessage("Third Message"), session.createTextMessage("Fourth Message")};	beginTx();	for (int i = 0; i < outbound.length; i++) {	producer.send(outbound[i]);	}	commitTx();	beginTx();	for (int i = 0; i < outbound.length; i++) {	
about to consume message 

Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message"), session.createTextMessage("Third Message"), session.createTextMessage("Fourth Message")};	beginTx();	for (int i = 0; i < outbound.length; i++) {	producer.send(outbound[i]);	}	commitTx();	beginTx();	for (int i = 0; i < outbound.length; i++) {	Message message = consumer.receive(1000);	assertNotNull(message);	
received 

public void testCloseConsumerBeforeCommit() throws Exception {	TextMessage[] outbound = new TextMessage[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};	beginTx();	while (consumer.receiveNoWait() != null) {	}	commitTx();	beginTx();	producer.send(outbound[0]);	producer.send(outbound[1]);	commitTx();	
sent 

public void testCloseConsumerBeforeCommit() throws Exception {	TextMessage[] outbound = new TextMessage[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};	beginTx();	while (consumer.receiveNoWait() != null) {	}	commitTx();	beginTx();	producer.send(outbound[0]);	producer.send(outbound[1]);	commitTx();	
sent 

beginTx();	producer.send(outbound[0]);	producer.send(outbound[1]);	commitTx();	beginTx();	TextMessage message = (TextMessage)consumer.receive(1000);	assertEquals(outbound[0].getText(), message.getText());	consumer.close();	commitTx();	consumer = resourceProvider.createConsumer(session, destination);	
created consumer 

public void testChangeMutableObjectInObjectMessageThenRollback() throws Exception {	ArrayList<String> list = new ArrayList<String>();	list.add("First");	Message outbound = session.createObjectMessage(list);	outbound.setStringProperty("foo", "abc");	beginTx();	producer.send(outbound);	commitTx();	
about to consume message 

beginTx();	producer.send(outbound);	commitTx();	beginTx();	Message message = consumer.receive(5000);	List<String> body = assertReceivedObjectMessageWithListBody(message);	try {	message.setStringProperty("foo", "def");	fail("Cannot change properties of the object!");	} catch (JMSException e) {	
caught expected exception 

protected List<String> assertReceivedObjectMessageWithListBody(Message message) throws JMSException {	assertNotNull("Should have received a message!", message);	assertEquals("foo header", "abc", message.getStringProperty("foo"));	assertTrue("Should be an object message but was: " + message, message instanceof ObjectMessage);	ObjectMessage objectMessage = (ObjectMessage)message;	List<String> body = (List<String>)objectMessage.getObject();	
received body 

========================= activemq sample_3851 =========================

if (!type.contains("=")) {	type = type + "=*";	}	final ObjectName beanName = new ObjectName("org.apache.activemq:type=Broker,brokerName=" + broker.getBrokerName() + "," + type +",*");	Set<ObjectName> mbeans = null;	int count = 0;	do {	if (timeout > 0) {	Thread.sleep(100);	}	
query name 

========================= activemq sample_2743 =========================

public void stop() {	if (internalClient != null) {	internalClient.stop();	internalClient = null;	}	if (!brokerService.isStopped()) {	try {	brokerService.stop();	} catch (Exception ex) {	
exception encountered stopping embedded activemq broker 

protected void before() throws Throwable {	
starting embedded activemq broker 

protected void after() {	
stopping embedded activemq broker 

========================= activemq sample_1180 =========================

private void assertDenied(String userPass, String destination) {	try {	assertAllowed(userPass, destination);	fail("Expected not allowed exception");	} catch (JMSException expected) {	
got 

========================= activemq sample_4382 =========================

public void testCreateSessionDoesNotBlockWhenNotConfiguredTo() throws Exception {	ExecutorService executor = Executors.newSingleThreadExecutor();	final Future<Boolean> result = executor.submit(new TestRunner());	boolean testPassed = Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return result.isDone() && result.get().booleanValue();	}	}, TimeUnit.SECONDS.toMillis(10), TimeUnit.MILLISECONDS.toMillis(50));	if (!testPassed) {	
call to createsession is blocking but should have returned an error instead 

cf.setConnectionFactory(amq);	cf.setMaxConnections(3);	cf.setMaximumActiveSessionPerConnection(1);	cf.setBlockIfSessionPoolIsFull(false);	conn = cf.createConnection();	one = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	Session two = null;	try {	two = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	two.close();	
expected jmsexception wasn t thrown 

conn = cf.createConnection();	one = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	Session two = null;	try {	two = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	two.close();	fail("seconds call to Connection.createSession() was supposed" + "to raise an JMSException as internal session pool" + "is exhausted. This did not happen and indiates a problem");	return new Boolean(false);	} catch (JMSException ex) {	if (ex.getCause().getClass() == java.util.NoSuchElementException.class) {	
caught expected 

========================= activemq sample_1303 =========================

});	this.pageFile.flush();	if (cleanupInterval > 0) {	if (scheduler == null) {	scheduler = new Scheduler(PListStoreImpl.class.getSimpleName());	scheduler.start();	}	scheduler.executePeriodically(this, cleanupInterval);	}	this.initialized = true;	
initialized 

protected synchronized void doStart() throws Exception {	if (!lazyInit) {	intialize();	} else {	if (this.directory == null) {	this.directory = getDefaultDirectory();	}	cleanupDirectory(this.directory);	cleanupDirectory(this.indexDirectory);	}	
started 

this.pageFile.unload();	}	if (this.journal != null) {	journal.close();	}	if (this.lockFile != null) {	this.lockFile.unlock();	}	this.lockFile = null;	this.initialized = false;	
stopped 

public void run() {	try {	if (isStopping()) {	return;	}	final int lastJournalFileId = journal.getLastAppendLocation().getDataFileId();	final Set<Integer> candidates = journal.getFileMap().keySet();	
full gc candidate set 

synchronized (indexLock) {	synchronized (this) {	plists = new ArrayList<PListImpl>(persistentLists.values());	}	}	for (PListImpl list : plists) {	list.claimFileLocations(candidates);	if (isStopping()) {	return;	}	
remaining gc candidate set after refs from 

synchronized (this) {	plists = new ArrayList<PListImpl>(persistentLists.values());	}	}	for (PListImpl list : plists) {	list.claimFileLocations(candidates);	if (isStopping()) {	return;	}	}	
gc candidate set 

}	for (PListImpl list : plists) {	list.claimFileLocations(candidates);	if (isStopping()) {	return;	}	}	this.journal.removeDataFiles(candidates);	}	} catch (IOException e) {	
exception on periodic cleanup 

File lockFileName = new File(directory, "lock");	lockFile = new LockFile(lockFileName, true);	if (failIfDatabaseIsLocked) {	lockFile.lock();	} else {	while (true) {	try {	lockFile.lock();	break;	} catch (IOException e) {	
database is locked waiting seconds for the database to be unlocked reason 

========================= activemq sample_1753 =========================

protected synchronized int getStoreSize() {	try {	int result = this.store.getMessageCount();	return result;	} catch (IOException e) {	
failed to get message count 

protected synchronized long getStoreMessageSize() {	try {	return this.store.getMessageSize();	} catch (IOException e) {	
failed to get message size 

protected synchronized boolean isStoreEmpty() {	try {	return this.store.isEmpty();	} catch (Exception e) {	
failed to get message count 

protected void setBatch(MessageId messageId) throws Exception {	if (LOG.isTraceEnabled()) {	
setbatch seq loc 

========================= activemq sample_4044 =========================

ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(connectionUri);	Connection connection = connectionFactory.createConnection();	connection.setClientID(getClass().getName());	connection.start();	try {	Session ts = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	try {	ts.unsubscribe("invalid-subscription-name");	fail("this should fail");	} catch (javax.jms.InvalidDestinationException e) {	
test caught correct invalid destination exception 

========================= activemq sample_2893 =========================

} else {	producer.send(m);	}	}	} catch (ResourceAllocationException expectedOnLimitReachedAfterFastAdvisory) {}	Message advCmsg = advisoryConsumer.receive(4000);	assertNotNull(advCmsg);	advCmsg = advisoryWhenFullConsumer.receive(4000);	assertNotNull(advCmsg);	connection.close();	
connection closed destinations should now become inactive 

========================= activemq sample_2939 =========================

protected TextWireFormat asTextWireFormat(WireFormat wireFormat) {	if (wireFormat instanceof TextWireFormat) {	return (TextWireFormat)wireFormat;	}	
not created with a textwireformat 

public Transport compositeConfigure(Transport transport, WireFormat format, Map options) {	transport = super.compositeConfigure(transport, format, options);	HttpClientTransport httpTransport = transport.narrow(HttpClientTransport.class);	if (httpTransport != null && httpTransport.isTrace()) {	try {	transport = TransportLoggerFactory.getInstance().createTransportLogger(transport);	} catch (Throwable e) {	
could not create transportlogger object for reason 

========================= activemq sample_1138 =========================

public void commitTransaction(ConnectionContext context) throws IOException {	if ( shouldBreak ) {	
throwing exception on purpose 

public void commitTransaction(ConnectionContext context) throws IOException {	if ( shouldBreak ) {	throw new IOException("Breaking on purpose");	}	
in committransaction 

========================= activemq sample_3806 =========================

broker = createBroker(true);	final AtomicBoolean first = new AtomicBoolean(false);	broker.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	public int prepareTransaction(final ConnectionContext context, TransactionId xid) throws Exception {	int result = super.prepareTransaction(context, xid);	if (first.compareAndSet(false, true)) {	context.setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
stopping broker on prepare 

broker = createBroker(true);	final AtomicBoolean first = new AtomicBoolean(false);	broker.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	public void commitTransaction(final ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {	super.commitTransaction(context, xid, onePhase);	if (first.compareAndSet(false, true)) {	context.setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
stopping broker on prepare 

========================= activemq sample_2578 =========================

public void delivery(Delivery delivery) throws Exception {	if (!delivery.isReadable()) {	
delivery was not readable 

========================= activemq sample_1704 =========================

public void onMessage(Message message) {	super.onMessage(message);	try {	message.acknowledge();	} catch (JMSException e) {	
failed to acknowledge 

========================= activemq sample_3739 =========================

public void testWorks() throws Exception {	Thread.sleep(2000);	
looking for endpoints 

public void testWorks() throws Exception {	Thread.sleep(2000);	broker.getAdminView().addQueue("runtime");	Thread.sleep(1000);	List<BrowsableEndpoint> endpoints = getEndpoints(camelContext, BrowsableEndpoint.class);	for (BrowsableEndpoint endpoint : endpoints) {	
endpoint 

========================= activemq sample_1354 =========================

protected final synchronized void dispose(ConnectionContext context, Destination dest) throws Exception {	if (this.doCacheTempDestinations) {	cachedDestinations.put(new CachedDestination(dest .getActiveMQDestination()), dest);	}else {	try {	dest.dispose(context);	dest.stop();	} catch (Exception e) {	
failed to dispose of 

private void doDispose(Destination dest) {	ConnectionContext context = new ConnectionContext();	try {	dest.dispose(context);	dest.stop();	} catch (Exception e) {	
failed to dispose of 

========================= activemq sample_4013 =========================

public void testConnectionPerMessage() throws Exception {	final String topicName = "test.topic";	
initializing connection factory for jms to url 

========================= activemq sample_2780 =========================

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	sendConnection = createSendConnection();	sendConnection.start();	receiveConnection = createReceiveConnection();	receiveConnection.start();	
created sendconnection 

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	sendConnection = createSendConnection();	sendConnection.start();	receiveConnection = createReceiveConnection();	receiveConnection.start();	
created receiveconnection 

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	sendConnection = createSendConnection();	sendConnection.start();	receiveConnection = createReceiveConnection();	receiveConnection.start();	session = createSendSession(sendConnection);	receiveSession = createReceiveSession(receiveConnection);	
created sendsession 

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	sendConnection = createSendConnection();	sendConnection.start();	receiveConnection = createReceiveConnection();	receiveConnection.start();	session = createSendSession(sendConnection);	receiveSession = createReceiveSession(receiveConnection);	
created receivesession 

producer = session.createProducer(null);	producer.setDeliveryMode(deliveryMode);	LOG.info("Created producer: " + producer + " delivery mode = " + (deliveryMode == DeliveryMode.PERSISTENT ? "PERSISTENT" : "NON_PERSISTENT"));	if (topic) {	consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	} else {	consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	}	
created consumer destination of type 

producer = session.createProducer(null);	producer.setDeliveryMode(deliveryMode);	LOG.info("Created producer: " + producer + " delivery mode = " + (deliveryMode == DeliveryMode.PERSISTENT ? "PERSISTENT" : "NON_PERSISTENT"));	if (topic) {	consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	} else {	consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	}	
created producer destination of type 

LOG.info("Created producer: " + producer + " delivery mode = " + (deliveryMode == DeliveryMode.PERSISTENT ? "PERSISTENT" : "NON_PERSISTENT"));	if (topic) {	consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	} else {	consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	}	consumer = createConsumer(receiveSession, consumerDestination);	consumer.setMessageListener(this);	
started connections 

========================= activemq sample_3484 =========================

ack.setDestination(destination);	ack.setMessageId(messageId);	ack.setMessageSequenceId(messageId.getBrokerSequenceId());	ack.setSubscritionName(subscriptionName);	ack.setClientId(clientId);	ack.setTransactionId(context.getTransaction() != null ? context.getTransaction().getTransactionId() : null);	final RecordLocation location = peristenceAdapter.writeCommand(ack, false);	final SubscriptionKey key = new SubscriptionKey(clientId, subscriptionName);	if (!context.isInTransaction()) {	if (debug) {	
journalled acknowledge for at 

ack.setClientId(clientId);	ack.setTransactionId(context.getTransaction() != null ? context.getTransaction().getTransactionId() : null);	final RecordLocation location = peristenceAdapter.writeCommand(ack, false);	final SubscriptionKey key = new SubscriptionKey(clientId, subscriptionName);	if (!context.isInTransaction()) {	if (debug) {	}	acknowledge(messageId, location, key);	} else {	if (debug) {	
journalled transacted acknowledge for at 

} else {	if (debug) {	}	synchronized (this) {	inFlightTxLocations.add(location);	}	transactionStore.acknowledge(this, ack, location);	context.getTransaction().addSynchronization(new Synchronization() {	public void afterCommit() throws Exception {	if (debug) {	
transacted acknowledge commit for at 

public void afterCommit() throws Exception {	if (debug) {	}	synchronized (JournalTopicMessageStore.this) {	inFlightTxLocations.remove(location);	acknowledge(messageId, location, key);	}	}	public void afterRollback() throws Exception {	if (debug) {	
transacted acknowledge rollback for at 

public void replayAcknowledge(ConnectionContext context, String clientId, String subscritionName, MessageId messageId) {	try {	SubscriptionInfo sub = longTermStore.lookupSubscription(clientId, subscritionName);	if (sub != null) {	longTermStore.acknowledge(context, clientId, subscritionName, messageId, null);	}	} catch (Throwable e) {	
could not replay acknowledge for message message may have already been acknowledged reason 

========================= activemq sample_927 =========================

} finally {	conn.close();	}	Queue queue = (Queue) broker.getRegionBroker().getDestinationMap().get( destination);	ConnectionContext context = new ConnectionContext( new NonCachedMessageEvaluationContext());	context.setBroker(broker.getBroker());	context.getMessageEvaluationContext().setDestination(destination);	long startTimeMillis = System.currentTimeMillis();	Assert.assertEquals(1, queue .moveMatchingMessagesTo(context, "id=" + (QUEUE_SIZE - 1), createDestination(MOVE_TO_DESTINATION_NAME)));	long durationMillis = System.currentTimeMillis() - startTimeMillis;	
it took ms to move the last message from a queue a messages 

} finally {	conn.close();	}	Queue queue = (Queue) broker.getRegionBroker().getDestinationMap().get( destination);	ConnectionContext context = new ConnectionContext( new NonCachedMessageEvaluationContext());	context.setBroker(broker.getBroker());	context.getMessageEvaluationContext().setDestination(destination);	long startTimeMillis = System.currentTimeMillis();	Assert.assertEquals(1, queue.copyMatchingMessagesTo(context, "id=" + (QUEUE_SIZE - 1), createDestination(MOVE_TO_DESTINATION_NAME)));	long durationMillis = System.currentTimeMillis() - startTimeMillis;	
it took ms to copy the last message from a queue a messages 

} finally {	conn.close();	}	Queue queue = (Queue) broker.getRegionBroker().getDestinationMap().get( destination);	ConnectionContext context = new ConnectionContext( new NonCachedMessageEvaluationContext());	context.setBroker(broker.getBroker());	context.getMessageEvaluationContext().setDestination(destination);	long startTimeMillis = System.currentTimeMillis();	Assert.assertEquals(1, queue.removeMatchingMessages("id=" + (QUEUE_SIZE - 1)));	long durationMillis = System.currentTimeMillis() - startTimeMillis;	
it took ms to remove the last message from a queue a messages 

========================= activemq sample_3607 =========================

public void testRestartSend() throws Exception {	Thread.sleep(1000);	
restarting broker 

public void testRestartSend() throws Exception {	Thread.sleep(1000);	restartBroker("BrokerA");	Thread.sleep(5000);	
sending message 

public void testRestartSend() throws Exception {	Thread.sleep(1000);	restartBroker("BrokerA");	Thread.sleep(5000);	sendMessages("BrokerA", queue, 1);	Thread.sleep(3000);	
consuming message 

public void testSendRestart() throws Exception {	Thread.sleep(1000);	
sending message 

public void testSendRestart() throws Exception {	Thread.sleep(1000);	sendMessages("BrokerA", queue, 1);	Thread.sleep(3000);	
restarting broker 

public void testSendRestart() throws Exception {	Thread.sleep(1000);	sendMessages("BrokerA", queue, 1);	Thread.sleep(3000);	restartBroker("BrokerA");	Thread.sleep(5000);	
consuming message 

========================= activemq sample_3596 =========================

underTest.addMessageLast(msg);	assertTrue("cache is disabled as limit reached", !underTest.isCacheEnabled());	assertEquals("setBatch unset", 0l, queueMessageStore.batch.get());	int dequeueCount = 0;	underTest.setMaxBatchSize(2);	underTest.reset();	while (underTest.hasNext() && dequeueCount < count) {	MessageReference ref = underTest.next();	ref.decrementReferenceCount();	underTest.remove();	
received message with body 

underTest.addMessageLast(msg);	assertTrue("cache is disabled as limit reached", !underTest.isCacheEnabled());	assertEquals("setBatch unset", 0l, queueMessageStore.batch.get());	int dequeueCount = 0;	underTest.setMaxBatchSize(2);	underTest.reset();	while (underTest.hasNext() && dequeueCount < count) {	MessageReference ref = underTest.next();	ref.decrementReferenceCount();	underTest.remove();	
received message with body 

underTest.addMessageLast(msg);	assertTrue("cache is disabled as limit reached", !underTest.isCacheEnabled());	assertEquals("setBatch set", 1l, queueMessageStore.batch.get());	int dequeueCount = 0;	underTest.setMaxBatchSize(2);	underTest.reset();	while (underTest.hasNext() && dequeueCount < count) {	MessageReference ref = underTest.next();	ref.decrementReferenceCount();	underTest.remove();	
received message with body 

underTest.addMessageLast(msg);	assertTrue("cache is disabled as limit reached", !underTest.isCacheEnabled());	assertEquals("setBatch set", 2l, queueMessageStore.batch.get());	int dequeueCount = 0;	underTest.setMaxBatchSize(count);	underTest.reset();	while (underTest.hasNext() && dequeueCount < count) {	MessageReference ref = underTest.next();	ref.decrementReferenceCount();	underTest.remove();	
received message with body 

underTest.addMessageLast(msg);	assertTrue("cache is disabled as limit reached", !underTest.isCacheEnabled());	assertEquals("setBatch set", 2l, queueMessageStore.batch.get());	int dequeueCount = 0;	underTest.setMaxBatchSize(2);	underTest.reset();	while (underTest.hasNext() && dequeueCount < count) {	MessageReference ref = underTest.next();	ref.decrementReferenceCount();	underTest.remove();	
received message with body 

public void recoverNextMessages(int maxReturned, MessageRecoveryListener listener) throws Exception {	for (int i=batch.intValue();i<messages.length;i++) {	
recovered index 

========================= activemq sample_2368 =========================

public void doCleanup() {	long now = System.currentTimeMillis();	for (Map.Entry<SubscriptionKey, DurableTopicSubscription> entry : durableSubscriptions.entrySet()) {	DurableTopicSubscription sub = entry.getValue();	if (!sub.isActive()) {	long offline = sub.getOfflineTimestamp();	if (offline != -1 && now - offline >= broker.getBrokerService().getOfflineDurableSubscriberTimeout()) {	
destroying durable subscriber due to inactivity 

if (offline != -1 && now - offline >= broker.getBrokerService().getOfflineDurableSubscriberTimeout()) {	try {	RemoveSubscriptionInfo info = new RemoveSubscriptionInfo();	info.setClientId(entry.getKey().getClientId());	info.setSubscriptionName(entry.getKey().getSubscriptionName());	ConnectionContext context = new ConnectionContext();	context.setBroker(broker);	context.setClientId(entry.getKey().getClientId());	removeSubscription(context, info);	} catch (Exception e) {	
failed to remove inactive durable subscriber 

protected List<Subscription> addSubscriptionsForDestination(ConnectionContext context, Destination dest) throws Exception {	List<Subscription> rc = super.addSubscriptionsForDestination(context, dest);	Set<Subscription> dupChecker = new HashSet<Subscription>(rc);	TopicMessageStore store = (TopicMessageStore)dest.getMessageStore();	if (store != null) {	SubscriptionInfo[] infos = store.getAllSubscriptions();	for (int i = 0; i < infos.length; i++) {	SubscriptionInfo info = infos[i];	
restoring durable subscription 

TopicSubscription answer = new TopicSubscription(broker, context, info, usageManager);	if (destination != null && broker.getDestinationPolicy() != null) {	PolicyEntry entry = broker.getDestinationPolicy().getEntryFor(destination);	if (entry != null) {	entry.configure(broker, usageManager, answer);	}	}	answer.init();	return answer;	} catch (Exception e) {	
failed to create topicsubscription 

========================= activemq sample_3980 =========================

public void testRedeliverNewSession() throws Exception {	String text = "TEST: " + System.currentTimeMillis();	Message sendMessage = session.createTextMessage(text);	if (verbose) {	
about to send a message with text 

========================= activemq sample_2692 =========================

public void testTopicRequestorOverBridge() throws JMSException {	for (int i = 0; i < MESSAGE_COUNT; i++) {	TextMessage msg = requestServerSession.createTextMessage("test msg: " + i);	
making request 

public void testTopicRequestorOverBridge() throws JMSException {	for (int i = 0; i < MESSAGE_COUNT; i++) {	TextMessage msg = requestServerSession.createTextMessage("test msg: " + i);	TextMessage result = (TextMessage)requestor.request(msg);	assertNotNull(result);	
received result 

public void onMessage(Message msg) {	try {	TextMessage textMsg = (TextMessage)msg;	String payload = "REPLY: " + textMsg.getText();	Destination replyTo;	replyTo = msg.getJMSReplyTo();	textMsg.clearBody();	textMsg.setText(payload);	
sending response 

========================= activemq sample_2738 =========================

public void testTempDestRaceDuplex() throws Exception {	useDuplex = true;	bridgeBrokers(BROKER_A, BROKER_B, false, 3);	bridgeBrokers(BROKER_B, BROKER_C, false, 3);	startAllBrokers();	waitForBridgeFormation(1);	HashSet<NetworkBridge> bridgesStart = new HashSet<NetworkBridge>();	for (NetworkConnector networkConnector : networkConnectors) {	bridgesStart.addAll(networkConnector.activeBridges());	}	
bridges start 

}	ExecutorService senderThreadPool = Executors.newCachedThreadPool();	BrokerItem brokerC = brokers.get(BROKER_C);	ActiveMQConnectionFactory brokerCFactory = new ActiveMQConnectionFactory(brokerC.broker.getTransportConnectorByScheme("tcp").getName() + "?jms.watchTopicAdvisories=false");	for (int i = 0; i < NUM_SENDS; i++) {	senderThreadPool.execute(new MessageSender(brokerCFactory));	}	senderThreadPool.shutdown();	senderThreadPool.awaitTermination(30, TimeUnit.SECONDS);	TimeUnit.SECONDS.sleep(15);	
shutting down 

senderThreadPool.execute(new MessageSender(brokerCFactory));	}	senderThreadPool.shutdown();	senderThreadPool.awaitTermination(30, TimeUnit.SECONDS);	TimeUnit.SECONDS.sleep(15);	shutdown.compareAndSet(false, true);	HashSet<NetworkBridge> bridgesEnd = new HashSet<NetworkBridge>();	for (NetworkConnector networkConnector : networkConnectors) {	bridgesEnd.addAll(networkConnector.activeBridges());	}	
bridges end 

}	senderThreadPool.shutdown();	senderThreadPool.awaitTermination(30, TimeUnit.SECONDS);	TimeUnit.SECONDS.sleep(15);	shutdown.compareAndSet(false, true);	HashSet<NetworkBridge> bridgesEnd = new HashSet<NetworkBridge>();	for (NetworkConnector networkConnector : networkConnectors) {	bridgesEnd.addAll(networkConnector.activeBridges());	}	assertEquals("no new bridges created", bridgesStart, bridgesEnd);	
received respondent error noconsumercount forwardfailures 

}	ExecutorService senderThreadPool = Executors.newCachedThreadPool();	BrokerItem brokerC = brokers.get(BROKER_C);	ActiveMQConnectionFactory brokerCFactory = new ActiveMQConnectionFactory(brokerC.broker.getTransportConnectorByScheme("tcp").getName() + "?jms.watchTopicAdvisories=false");	for (int i = 0; i < NUM_SENDS; i++) {	senderThreadPool.execute(new MessageSender(brokerCFactory));	}	senderThreadPool.shutdown();	senderThreadPool.awaitTermination(30, TimeUnit.SECONDS);	TimeUnit.SECONDS.sleep(10);	
shutting down 

}	senderThreadPool.shutdown();	senderThreadPool.awaitTermination(30, TimeUnit.SECONDS);	TimeUnit.SECONDS.sleep(10);	shutdown.compareAndSet(false, true);	HashSet<NetworkBridge> bridgesEnd = new HashSet<NetworkBridge>();	for (NetworkConnector networkConnector : networkConnectors) {	bridgesEnd.addAll(networkConnector.activeBridges());	}	assertEquals("no new bridges created", bridgesStart, bridgesEnd);	
received respondent error noconsumercount forwardfailures 

public void run() {	try {	TextMessage message = session.createTextMessage("request: message #" + messageCount.getAndIncrement());	message.setJMSReplyTo(tempDest);	producer.send(message);	
sender message has been sent 

public void run() {	try {	TextMessage message = session.createTextMessage("request: message #" + messageCount.getAndIncrement());	message.setJMSReplyTo(tempDest);	producer.send(message);	Message incomingMessage = consumer.receive(timeToSleep);	if (incomingMessage instanceof TextMessage) {	try {	
sender got a response from echo service 

public void run() {	try {	TextMessage message = session.createTextMessage("request: message #" + messageCount.getAndIncrement());	message.setJMSReplyTo(tempDest);	producer.send(message);	Message incomingMessage = consumer.receive(timeToSleep);	if (incomingMessage instanceof TextMessage) {	try {	responseReceived.incrementAndGet();	} catch (JMSException e) {	
sender might want to see why i m getting non text messages 

TextMessage message = session.createTextMessage("request: message #" + messageCount.getAndIncrement());	message.setJMSReplyTo(tempDest);	producer.send(message);	Message incomingMessage = consumer.receive(timeToSleep);	if (incomingMessage instanceof TextMessage) {	try {	responseReceived.incrementAndGet();	} catch (JMSException e) {	}	} else {	
sender did not get a response this time 

producer.send(message);	Message incomingMessage = consumer.receive(timeToSleep);	if (incomingMessage instanceof TextMessage) {	try {	responseReceived.incrementAndGet();	} catch (JMSException e) {	}	} else {	}	} catch (JMSException e) {	
sender could not complete message sending properly 

protected void initConsumer() throws JMSException {	this.consumer = session.createConsumer(tempDest);	
consumer for 

public void run() {	try {	
respondent listening 

public void run() {	try {	while (!shutdown.get()) {	Message incomingMessage = consumer.receive(1000);	if (incomingMessage instanceof TextMessage) {	ActiveMQTextMessage textMessage = (ActiveMQTextMessage) incomingMessage;	try {	
respondent received a message 

Message incomingMessage = consumer.receive(1000);	if (incomingMessage instanceof TextMessage) {	ActiveMQTextMessage textMessage = (ActiveMQTextMessage) incomingMessage;	try {	Message message = session.createTextMessage("reply: " + textMessage.getText());	Destination replyTo = incomingMessage.getJMSReplyTo();	TimeUnit.MILLISECONDS.sleep(timeToSleep);	consumerDemandExists.await(5, TimeUnit.SECONDS);	try {	producer.send(replyTo, message);	
respondent sent reply back to 

if (incomingMessage instanceof TextMessage) {	ActiveMQTextMessage textMessage = (ActiveMQTextMessage) incomingMessage;	try {	Message message = session.createTextMessage("reply: " + textMessage.getText());	Destination replyTo = incomingMessage.getJMSReplyTo();	TimeUnit.MILLISECONDS.sleep(timeToSleep);	consumerDemandExists.await(5, TimeUnit.SECONDS);	try {	producer.send(replyTo, message);	} catch (JMSException e) {	
respondent could not send reply message 

Message message = session.createTextMessage("reply: " + textMessage.getText());	Destination replyTo = incomingMessage.getJMSReplyTo();	TimeUnit.MILLISECONDS.sleep(timeToSleep);	consumerDemandExists.await(5, TimeUnit.SECONDS);	try {	producer.send(replyTo, message);	} catch (JMSException e) {	respondentSendError.incrementAndGet();	}	} catch (JMSException e) {	
respondent could not create the reply message 

Destination replyTo = incomingMessage.getJMSReplyTo();	TimeUnit.MILLISECONDS.sleep(timeToSleep);	consumerDemandExists.await(5, TimeUnit.SECONDS);	try {	producer.send(replyTo, message);	} catch (JMSException e) {	respondentSendError.incrementAndGet();	}	} catch (JMSException e) {	} catch (InterruptedException e) {	
respondent could not generate a random number 

producer.send(replyTo, message);	} catch (JMSException e) {	respondentSendError.incrementAndGet();	}	} catch (JMSException e) {	} catch (InterruptedException e) {	}	}	}	} catch (JMSException e) {	
respondent could not set the message listener on the respondent 

========================= activemq sample_3579 =========================

try {	AdvisoryBroker ab = (AdvisoryBroker) brokerService.getBroker().getAdaptor(AdvisoryBroker.class);	if (ab != null && brokerService.isUseVirtualDestSubs() && config.isUseVirtualDestSubs()) {	for (ConsumerInfo info : ab.getVirtualDestinationConsumers().keySet()) {	if (NetworkBridgeUtils.isForcedDurable(info, config.getDynamicallyIncludedDestinations())) {	subscriptionInfos.add(info.copy());	}	}	}	} catch (Exception e) {	
error processing virtualdestinationsubs for brokersubscriptioninfo 

try {	AdvisoryBroker ab = (AdvisoryBroker) brokerService.getBroker().getAdaptor(AdvisoryBroker.class);	if (ab != null && brokerService.isUseVirtualDestSubs() && config.isUseVirtualDestSubs()) {	for (ConsumerInfo info : ab.getVirtualDestinationConsumers().keySet()) {	if (NetworkBridgeUtils.isForcedDurable(info, config.getDynamicallyIncludedDestinations())) {	subscriptionInfos.add(info.copy());	}	}	}	} catch (Exception e) {	
error processing virtualdestinationsubs for brokersubscriptioninfo 

========================= activemq sample_4195 =========================

message.setPersistent(true);	connection.send(message);	StubConnection connectionC = createConnection();	ConnectionInfo connectionInfoC = createConnectionInfo();	SessionInfo sessionInfoC = createSessionInfo(connectionInfoC);	ConsumerInfo consumerInfo = createConsumerInfo(sessionInfoC, destination);	connectionC.send(connectionInfoC);	connectionC.send(sessionInfoC);	connectionC.send(consumerInfo);	Message m = receiveMessage(connectionC, TimeUnit.SECONDS.toMillis(10));	
received 

SessionInfo sessionInfoC = createSessionInfo(connectionInfoC);	ConsumerInfo consumerInfo = createConsumerInfo(sessionInfoC, destination);	connectionC.send(connectionInfoC);	connectionC.send(sessionInfoC);	connectionC.send(consumerInfo);	Message m = receiveMessage(connectionC, TimeUnit.SECONDS.toMillis(10));	assertNotNull("Got message", m);	assertNull("Got non tx message", m.getTransactionId());	assertNull(receiveMessage(connectionC));	assertNoMessagesLeft(connectionC);	
commit 

connectionC.send(connectionInfoC);	connectionC.send(sessionInfoC);	connectionC.send(consumerInfo);	Message m = receiveMessage(connectionC, TimeUnit.SECONDS.toMillis(10));	assertNotNull("Got message", m);	assertNull("Got non tx message", m.getTransactionId());	assertNull(receiveMessage(connectionC));	assertNoMessagesLeft(connectionC);	connection.request(createCommitTransaction2Phase(connectionInfo, txid));	m = receiveMessage(connectionC, TimeUnit.SECONDS.toMillis(10));	
received 

StubConnection connectionC = createConnection();	ConnectionInfo connectionInfoC = createConnectionInfo();	SessionInfo sessionInfoC = createSessionInfo(connectionInfoC);	ConsumerInfo consumerInfo = createConsumerInfo(sessionInfoC, destination);	connectionC.send(connectionInfoC);	connectionC.send(sessionInfoC);	connectionC.send(consumerInfo);	Message m = null;	for (int i=0; i<3; i++) {	m = receiveMessage(connectionC, TimeUnit.SECONDS.toMillis(10));	
received 

connectionC.send(connectionInfoC);	connectionC.send(sessionInfoC);	connectionC.send(consumerInfo);	Message m = null;	for (int i=0; i<3; i++) {	m = receiveMessage(connectionC, TimeUnit.SECONDS.toMillis(10));	assertNotNull("Got message", m);	assertNull("Got non tx message", m.getTransactionId());	connectionC.request(createAck(consumerInfo, m, 1, MessageAck.STANDARD_ACK_TYPE));	}	
commit 

Message m = null;	for (int i=0; i<3; i++) {	m = receiveMessage(connectionC, TimeUnit.SECONDS.toMillis(10));	assertNotNull("Got message", m);	assertNull("Got non tx message", m.getTransactionId());	connectionC.request(createAck(consumerInfo, m, 1, MessageAck.STANDARD_ACK_TYPE));	}	connection.request(createCommitTransaction2Phase(connectionInfo, txid));	for (int i=0; i<4; i++) {	m = receiveMessage(connectionC, TimeUnit.SECONDS.toMillis(10));	
received 

========================= activemq sample_2942 =========================

public void teardown() throws Exception {	try {	brokerService.stop();	} catch (Exception ex) {	
failed to stop start broker exception 

connection.start();	session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	producer = session.createProducer(session.createQueue(QUEUE_NAME));	producer.setPriority(4);	producer.send(message);	displayQueueViews(brokerService);	MessageConsumer jmsConsumer = session.createConsumer(session.createQueue(QUEUE_NAME));	for (int i = 0; i < 5; i++) {	message = jmsConsumer.receive(4000);	assertNotNull("Got message i=" + i, message);	
received priority 

private void displayQueueViews(BrokerService broker) throws Exception {	Map<ObjectName, DestinationView> queueViews = broker.getAdminView().getBroker().getQueueViews();	for (ObjectName key : queueViews.keySet()) {	DestinationView destinationView = queueViews.get(key);	if (destinationView instanceof QueueView) {	QueueView queueView = (QueueView) destinationView;	
objectname 

private void displayQueueViews(BrokerService broker) throws Exception {	Map<ObjectName, DestinationView> queueViews = broker.getAdminView().getBroker().getQueueViews();	for (ObjectName key : queueViews.keySet()) {	DestinationView destinationView = queueViews.get(key);	if (destinationView instanceof QueueView) {	QueueView queueView = (QueueView) destinationView;	
queueview name 

private void displayQueueViews(BrokerService broker) throws Exception {	Map<ObjectName, DestinationView> queueViews = broker.getAdminView().getBroker().getQueueViews();	for (ObjectName key : queueViews.keySet()) {	DestinationView destinationView = queueViews.get(key);	if (destinationView instanceof QueueView) {	QueueView queueView = (QueueView) destinationView;	
queueview cursorsize 

private void displayQueueViews(BrokerService broker) throws Exception {	Map<ObjectName, DestinationView> queueViews = broker.getAdminView().getBroker().getQueueViews();	for (ObjectName key : queueViews.keySet()) {	DestinationView destinationView = queueViews.get(key);	if (destinationView instanceof QueueView) {	QueueView queueView = (QueueView) destinationView;	
queueview queuesize 

private void displayQueueViews(BrokerService broker) throws Exception {	Map<ObjectName, DestinationView> queueViews = broker.getAdminView().getBroker().getQueueViews();	for (ObjectName key : queueViews.keySet()) {	DestinationView destinationView = queueViews.get(key);	if (destinationView instanceof QueueView) {	QueueView queueView = (QueueView) destinationView;	
queueview enqueue count 

private void displayQueueViews(BrokerService broker) throws Exception {	Map<ObjectName, DestinationView> queueViews = broker.getAdminView().getBroker().getQueueViews();	for (ObjectName key : queueViews.keySet()) {	DestinationView destinationView = queueViews.get(key);	if (destinationView instanceof QueueView) {	QueueView queueView = (QueueView) destinationView;	
queueview dequeue count 

private void displayQueueViews(BrokerService broker) throws Exception {	Map<ObjectName, DestinationView> queueViews = broker.getAdminView().getBroker().getQueueViews();	for (ObjectName key : queueViews.keySet()) {	DestinationView destinationView = queueViews.get(key);	if (destinationView instanceof QueueView) {	QueueView queueView = (QueueView) destinationView;	
queueview inflight count 

private synchronized void stopRestartBroker() {	try {	
shutting broker down 

private synchronized void stopRestartBroker() {	try {	brokerService.stop();	brokerService.waitUntilStopped();	createBroker(false);	brokerService.start();	brokerService.waitUntilStarted();	
broker restarted 

private synchronized void stopRestartBroker() {	try {	brokerService.stop();	brokerService.waitUntilStopped();	createBroker(false);	brokerService.start();	brokerService.waitUntilStarted();	} catch (Exception e) {	
failed to stop start broker exception 

========================= activemq sample_1728 =========================

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	sendConnection = createConnection();	sendConnection.start();	receiveConnection = createConnection();	receiveConnection.start();	
created sendconnection 

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	sendConnection = createConnection();	sendConnection.start();	receiveConnection = createConnection();	receiveConnection.start();	
created receiveconnection 

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	sendConnection = createConnection();	sendConnection.start();	receiveConnection = createConnection();	receiveConnection.start();	session = sendConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	receiveSession = receiveConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	
created sendsession 

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	sendConnection = createConnection();	sendConnection.start();	receiveConnection = createConnection();	receiveConnection.start();	session = sendConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	receiveSession = receiveConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	
created receivesession 

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	sendConnection = createConnection();	sendConnection.start();	receiveConnection = createConnection();	receiveConnection.start();	session = sendConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	receiveSession = receiveConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	producer = session.createProducer(null);	
created producer 

session = sendConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	receiveSession = receiveConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	producer = session.createProducer(null);	if (topic) {	consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	} else {	consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	}	
created consumer destination of type 

session = sendConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	receiveSession = receiveConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	producer = session.createProducer(null);	if (topic) {	consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	} else {	consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	}	
created producer destination of type 

}	Destination[] destinations = getDestinations();	consumers = new MessageConsumer[destinations.length];	messageLists = new List[destinations.length];	for (int i = 0; i < destinations.length; i++) {	Destination dest = destinations[i];	messageLists[i] = createConcurrentList();	consumers[i] = receiveSession.createConsumer(dest);	consumers[i].setMessageListener(createMessageListener(i, messageLists[i]));	}	
started connections 

protected void assertMessagesAreReceived() throws JMSException {	waitForMessagesToBeDelivered();	int size = messageLists.length;	for (int i = 0; i < size; i++) {	
message list contains message s 

========================= activemq sample_3715 =========================

receiveAndDiscard100messages(latch);	}	});	for (int j = 0; j < 10; j++) {	pool.execute(new Runnable() {	public void run() {	send10000messages(latch);	}	});	}	
waiting on the send receive latch 

}	});	for (int j = 0; j < 10; j++) {	pool.execute(new Runnable() {	public void run() {	send10000messages(latch);	}	});	}	latch.await(5, TimeUnit.MINUTES);	
Resumed 

public void destroyQueue() {	try {	Broker broker = this.broker.getBroker();	if (!broker.isStopped()) {	
removing 

public void destroyQueue() {	try {	Broker broker = this.broker.getBroker();	if (!broker.isStopped()) {	broker.removeDestination(this.broker.getAdminConnectionContext(), new ActiveMQQueue(queueName), 10);	}	} catch (Exception e) {	
got an error while removing the test queue 

textMessage.setText(generateBody(1000));	textMessage.setJMSDeliveryMode(DeliveryMode.NON_PERSISTENT);	producer.send(textMessage);	try {	Thread.sleep(10);	} catch (InterruptedException e) {	}	}	producer.close();	} catch (JMSException e) {	
got an error while sending the messages 

ActiveMQConnection activeMQConnection = null;	try {	activeMQConnection = createConnection(null);	Session session = activeMQConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer messageConsumer = session.createConsumer( session.createQueue(queueName));	activeMQConnection.start();	for (int i = 0; i < 100; i++) {	messageConsumer.receive();	}	messageConsumer.close();	
created and disconnected 

try {	activeMQConnection = createConnection(null);	Session session = activeMQConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer messageConsumer = session.createConsumer( session.createQueue(queueName));	activeMQConnection.start();	for (int i = 0; i < 100; i++) {	messageConsumer.receive();	}	messageConsumer.close();	} catch (JMSException e) {	
got an error while receiving the messages 

========================= activemq sample_2807 =========================

public void testSendWithClientWriteTimeout() throws Exception {	final ActiveMQQueue dest = new ActiveMQQueue("testClientWriteTimeout");	messageTextPrefix = initMessagePrefix(80*1024);	URI tcpBrokerUri = URISupport.removeQuery(broker.getTransportConnectors().get(0).getConnectUri());	
consuming using uri 

}	}	});	TimeUnit.SECONDS.sleep(8);	proxy.goOn();	for (int i=0; i<messageCount; i++) {	assertNotNull("Got message " + i  + " after reconnect", consumer.receive(5000));	}	assertTrue("no pending messages when done", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
current total message count 

========================= activemq sample_2554 =========================

} else {	throw new InvalidClientIDException("Broker: " + getBrokerName() + " - Client: " + clientId + " already connected from " + oldContext.getConnection().getRemoteAddress());	}	} else {	clientIdSet.put(clientId, context);	}	}	if (oldContext != null) {	if (oldContext.getConnection() != null) {	Connection connection = oldContext.getConnection();	
stealing link for clientid from connection 

if (oldContext != null) {	if (oldContext.getConnection() != null) {	Connection connection = oldContext.getConnection();	if (connection instanceof TransportConnection) {	TransportConnection transportConnection = (TransportConnection) connection;	transportConnection.stopAsync(new IOException("Stealing link for clientId " + clientId + " From Connection " + oldContext.getConnection().getConnectionId()));	} else {	connection.stop();	}	} else {	
no connection found for 

public synchronized void addBroker(Connection connection, BrokerInfo info) {	BrokerInfo existing = brokerInfos.get(info.getBrokerId());	if (existing == null) {	existing = info.copy();	existing.setPeerBrokerInfos(null);	brokerInfos.put(info.getBrokerId(), existing);	}	existing.incrementRefCount();	
addbroker brokerinfo size 

public synchronized void removeBroker(Connection connection, BrokerInfo info) {	if (info != null) {	BrokerInfo existing = brokerInfos.get(info.getBrokerId());	if (existing != null && existing.decrementRefCount() == 0) {	brokerInfos.remove(info.getBrokerId());	}	
removebroker brokerinfo size 

public void messageExpired(ConnectionContext context, MessageReference node, Subscription subscription) {	
message expired 

public boolean sendToDeadLetterQueue(ConnectionContext context, MessageReference node, Subscription subscription, Throwable poisonCause) {	try {	if (node != null) {	Message message = node.getMessage();	if (message != null && node.getRegionDestination() != null) {	DeadLetterStrategy deadLetterStrategy = ((Destination) node.getRegionDestination()).getDeadLetterStrategy();	if (deadLetterStrategy != null) {	if (deadLetterStrategy.isSendToDeadLetterQueue(message)) {	ActiveMQDestination deadLetterDestination = deadLetterStrategy.getDeadLetterQueueFor(message, subscription);	if (deadLetterDestination.equals(message.getDestination())) {	
not re adding to dlq dest 

}	ConnectionContext adminContext = context;	if (context.getSecurityContext() == null || !context.getSecurityContext().isBrokerContext()) {	adminContext = BrokerSupport.getConnectionContext(this);	}	addDestination(adminContext, deadLetterDestination, false).getActiveMQDestination().setDLQ(true);	BrokerSupport.resendNoCopy(adminContext, message, deadLetterDestination);	return true;	}	} else {	
dead letter message with no dlq strategy in place message id destination 

}	addDestination(adminContext, deadLetterDestination, false).getActiveMQDestination().setDLQ(true);	BrokerSupport.resendNoCopy(adminContext, message, deadLetterDestination);	return true;	}	} else {	}	}	}	} catch (Exception e) {	
caught an exception sending to dlq 

public Broker getRoot() {	try {	return getBrokerService().getBroker();	} catch (Exception e) {	
trying to get root broker 

public void processConsumerControl(ConsumerBrokerExchange consumerExchange, ConsumerControl control) {	ActiveMQDestination destination = control.getDestination();	try {	getRegion(destination).processConsumerControl(consumerExchange, control);	} catch (JMSException jmse) {	
unmatched destination in consumercontrol 

}	}	if (!list.isEmpty()) {	ConnectionContext context = BrokerSupport.getConnectionContext(this);	context.setBroker(this);	for (Destination dest : list) {	Logger log = LOG;	if (dest instanceof BaseDestination) {	log = ((BaseDestination) dest).getLog();	}	
inactive for longer than ms removing 

ConnectionContext context = BrokerSupport.getConnectionContext(this);	context.setBroker(this);	for (Destination dest : list) {	Logger log = LOG;	if (dest instanceof BaseDestination) {	log = ((BaseDestination) dest).getLog();	}	try {	getRoot().removeDestination(context, dest.getActiveMQDestination(), isAllowTempAutoCreationOnSend() ? 1 : 0);	} catch (Exception e) {	
failed to remove inactive destination 

========================= activemq sample_3979 =========================

Connection connection = super.createConnection();	connection.start();	Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	Destination destination = session.createQueue(CREATED_STATIC_FOR_PERSISTENT);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	char[] m = new char[1024];	Arrays.fill(m, 'x');	for (int i = 1; i < 12000; i++) {	producer.send(session.createTextMessage(new String(m)));	
sent message 

========================= activemq sample_2391 =========================

public void beforeDelivery(Method method) throws NoSuchMethodException, ResourceException {	try {	if (xid == null) {	xid = createXid();	}	xaresource.start(xid, 0);	} catch (Throwable e) {	
beforedelivery messagecount ex 

public void afterDelivery() throws ResourceException {	try {	xaresource.end(xid, 0);	xaresource.prepare(xid);	xaresource.commit(xid, false);	xid = null;	} catch (Throwable e) {	
afterdelivery messagecount ex 

public void release() {	
in release messagecount xid 

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	ActiveMQResourceAdapter adapter = new ActiveMQResourceAdapter();	adapter.setServerUrl("vm: adapter.start(new StubBootstrapContext());	final CountDownLatch messageDelivered = new CountDownLatch(10);	final StubMessageEndpoint endpoint = new StubMessageEndpoint() {	public void beforeDelivery(Method method) throws NoSuchMethodException, ResourceException {	}	public void afterDelivery() throws ResourceException {	}	public void onMessage(Message message) {	
message 

try {	if (messageCount == 2) {	xaresource.end(xid, XAResource.TMFAIL);	xaresource.rollback(xid);	} else {	xaresource.end(xid, XAResource.TMSUCCESS);	xaresource.prepare(xid);	xaresource.commit(xid, false);	}	} catch (Throwable e) {	
afterdelivery messagecount ex 

}	MessageProducer producer = session.createProducer(new ActiveMQQueue("TEST"));	for (int i=0; i<5; i++) {	Message message = session.createTextMessage("Hello!");	message.setIntProperty(ORDER_PROP, i);	producer.send(message);	}	connection.close();	assertTrue("Got 5", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
ordered size 

========================= activemq sample_823 =========================

bridge.setConsumerQueue(replyToConsumerQueue);	bridge.setProducerQueue(replyToProducerQueue);	bridge.setProducerConnection((QueueConnection)replyToProducerConnection);	bridge.setConsumerConnection((QueueConnection)replyToConsumerConnection);	bridge.setDoHandleReplyTo(false);	if (bridge.getJmsMessageConvertor() == null) {	bridge.setJmsMessageConvertor(getInboundMessageConvertor());	}	bridge.setJmsConnector(this);	bridge.start();	
created replyto bridge for 

bridge.setProducerQueue(replyToProducerQueue);	bridge.setProducerConnection((QueueConnection)replyToProducerConnection);	bridge.setConsumerConnection((QueueConnection)replyToConsumerConnection);	bridge.setDoHandleReplyTo(false);	if (bridge.getJmsMessageConvertor() == null) {	bridge.setJmsMessageConvertor(getInboundMessageConvertor());	}	bridge.setJmsConnector(this);	bridge.start();	} catch (Exception e) {	
failed to create replyto bridge for queue 

bridge.setConsumerQueue(replyToConsumerQueue);	bridge.setProducerQueue(replyToProducerQueue);	bridge.setProducerConnection((QueueConnection)replyToProducerConnection);	bridge.setConsumerConnection((QueueConnection)replyToConsumerConnection);	bridge.setDoHandleReplyTo(false);	if (bridge.getJmsMessageConvertor() == null) {	bridge.setJmsMessageConvertor(getOutboundMessageConvertor());	}	bridge.setJmsConnector(this);	bridge.start();	
created replyto bridge for 

bridge.setProducerQueue(replyToProducerQueue);	bridge.setProducerConnection((QueueConnection)replyToProducerConnection);	bridge.setConsumerConnection((QueueConnection)replyToConsumerConnection);	bridge.setDoHandleReplyTo(false);	if (bridge.getJmsMessageConvertor() == null) {	bridge.setJmsMessageConvertor(getOutboundMessageConvertor());	}	bridge.setJmsConnector(this);	bridge.start();	} catch (Exception e) {	
failed to create replyto bridge for queue 

========================= activemq sample_4245 =========================

protected void setUp() throws Exception {	File journalFile = new File(JOURNAL_ROOT);	recursiveDelete(journalFile);	
creating broker 

protected void setUp() throws Exception {	File journalFile = new File(JOURNAL_ROOT);	recursiveDelete(journalFile);	broker = createBroker("org/apache/activemq/usecases/activemq.xml");	
Success 

protected void tearDown() throws Exception {	
closing broker 

protected void tearDown() throws Exception {	if (broker != null) {	broker.stop();	}	
broker closed 

========================= activemq sample_3580 =========================

public void testInactivityMonitor() throws Exception {	Thread t1 = new Thread() {	public void run() {	try {	connection = createSocket();	connection.getOutputStream().write('C');	connection.getOutputStream().flush();	} catch (Exception ex) {	
unexpected exception on connect disconnect 

========================= activemq sample_1417 =========================

public static Collection<String[]> getTestParameters() throws IOException {	List<String[]> configUrls = new ArrayList<String[]>();	configUrls.add(new String[]{"xbean:src/release/conf/activemq.xml", "activemq.xml"});	String osName=System.getProperty("os.name");	
os name 

public void testStartBrokerUsingXmlConfig1() throws Exception {	BrokerService broker = null;	
broker config 

} catch (TimeoutException expectedWithNoZk) {	return;	}	} else {	broker.start();	}	try {	for (TransportConnector transport : broker.getTransportConnectors()) {	final URI UriToConnectTo = URISupport.removeQuery(transport.getConnectUri());	if (UriToConnectTo.getScheme().startsWith("stomp")) {	
validating alive with connection to 

}	try {	for (TransportConnector transport : broker.getTransportConnectors()) {	final URI UriToConnectTo = URISupport.removeQuery(transport.getConnectUri());	if (UriToConnectTo.getScheme().startsWith("stomp")) {	StompConnection connection = new StompConnection();	connection.open(UriToConnectTo.getHost(), UriToConnectTo.getPort());	connection.close();	break;	} else if (UriToConnectTo.getScheme().startsWith("tcp")) {	
validating alive with connection to 

connection.open(UriToConnectTo.getHost(), UriToConnectTo.getPort());	connection.close();	break;	} else if (UriToConnectTo.getScheme().startsWith("tcp")) {	ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(UriToConnectTo);	Connection connection = connectionFactory.createConnection(secProps.getProperty("activemq.username"), secProps.getProperty("activemq.password"));	connection.start();	connection.close();	break;	} else {	
not validating connection to 

========================= activemq sample_966 =========================

final MessageProducer producer = sendSession.createProducer(null);	Thread sendThread = new Thread() {	public void run() {	try {	for (int i = 0; i < messageCount; i++) {	boolean filter = i % 2 == 1;	Message message = sendSession.createMessage();	message.setStringProperty("filter", filter ? "true" : "false");	producer.send(topic, message);	if (i > 0 && i % 1000 == 0) {	
sent 

assertEquals(messageCount / 2, listenerF.count);	consumerTrue.close();	session.unsubscribe("true");	consumerFalse.close();	session.unsubscribe("false");	session.close();	con.close();	PersistenceAdapter persistenceAdapter = broker.getPersistenceAdapter();	if( persistenceAdapter instanceof KahaDBStore) {	final KahaDBStore store = ((KahaDBPersistenceAdapter) persistenceAdapter).getStore();	
store page count 

assertEquals(messageCount / 2, listenerF.count);	consumerTrue.close();	session.unsubscribe("true");	consumerFalse.close();	session.unsubscribe("false");	session.close();	con.close();	PersistenceAdapter persistenceAdapter = broker.getPersistenceAdapter();	if( persistenceAdapter instanceof KahaDBStore) {	final KahaDBStore store = ((KahaDBPersistenceAdapter) persistenceAdapter).getStore();	
store free page count 

assertEquals(messageCount / 2, listenerF.count);	consumerTrue.close();	session.unsubscribe("true");	consumerFalse.close();	session.unsubscribe("false");	session.close();	con.close();	PersistenceAdapter persistenceAdapter = broker.getPersistenceAdapter();	if( persistenceAdapter instanceof KahaDBStore) {	final KahaDBStore store = ((KahaDBPersistenceAdapter) persistenceAdapter).getStore();	
store page in use 

========================= activemq sample_3646 =========================

ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("failover:(" + broker.getTransportConnectors().get(0).getPublishableConnectString() + ")?jms.prefetchPolicy.all=0");	connection = (ActiveMQConnection) connectionFactory.createConnection();	connection.start();	Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	Destination destination = session.createQueue(queueName);	populateDestination(10, destination, connection);	MessageConsumer consumer = session.createConsumer(destination);	TextMessage msg = null;	for (int i = 0; i < 5; i++) {	msg = (TextMessage) consumer.receive(20000);	
not redelivered got 

assertNotNull("got the message", msg);	assertEquals("first delivery", 1, msg.getLongProperty("JMSXDeliveryCount"));	assertEquals("not a redelivery", false, msg.getJMSRedelivered());	}	consumer.close();	restartBroker();	connection.getTransport().narrow(FailoverTransport.class).add(true, broker.getTransportConnectors().get(0) .getPublishableConnectString());	consumer = session.createConsumer(destination);	for (int i = 0; i < 5; i++) {	msg = (TextMessage) consumer.receive(4000);	
redelivered got 

consumer = session.createConsumer(destination);	for (int i = 0; i < 5; i++) {	msg = (TextMessage) consumer.receive(4000);	assertNotNull("got the message again", msg);	assertEquals("re delivery flag", true, msg.getJMSRedelivered());	assertEquals("redelivery count survives restart", 2, msg.getLongProperty("JMSXDeliveryCount"));	msg.acknowledge();	}	for (int i = 0; i < 5; i++) {	msg = (TextMessage) consumer.receive(20000);	
not redelivered got 

connection = (ActiveMQConnection) connectionFactory.createConnection();	connection.setClientID("id");	connection.start();	Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	ActiveMQTopic destination = new ActiveMQTopic(queueName);	TopicSubscriber durableSub = session.createDurableSubscriber(destination, "id");	populateDestination(10, destination, connection);	TextMessage msg = null;	for (int i = 0; i < 5; i++) {	msg = (TextMessage) durableSub.receive(20000);	
not redelivered got 

assertNotNull("got the message", msg);	assertEquals("first delivery", 1, msg.getLongProperty("JMSXDeliveryCount"));	assertEquals("not a redelivery", false, msg.getJMSRedelivered());	}	durableSub.close();	restartBroker();	connection.getTransport().narrow(FailoverTransport.class).add(true, broker.getTransportConnectors().get(0) .getPublishableConnectString());	durableSub = session.createDurableSubscriber(destination, "id");	for (int i = 0; i < 10; i++) {	msg = (TextMessage) durableSub.receive(4000);	
redelivered got 

ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("failover:(" + broker.getTransportConnectors().get(0).getPublishableConnectString() + ")?jms.prefetchPolicy.all=0");	connection = (ActiveMQConnection) connectionFactory.createConnection();	connection.start();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Destination destination = session.createQueue(queueName);	populateDestination(10, destination, connection);	MessageConsumer consumer = session.createConsumer(destination);	TextMessage msg = null;	for (int i = 0; i < 5; i++) {	msg = (TextMessage) consumer.receive(20000);	
not redelivered got 

assertEquals("first delivery", 1, msg.getLongProperty("JMSXDeliveryCount"));	assertEquals("not a redelivery", false, msg.getJMSRedelivered());	}	session.rollback();	consumer.close();	restartBroker();	connection.getTransport().narrow(FailoverTransport.class).add(true, broker.getTransportConnectors().get(0) .getPublishableConnectString());	consumer = session.createConsumer(destination);	for (int i = 0; i < 5; i++) {	msg = (TextMessage) consumer.receive(4000);	
redelivered got 

consumer = session.createConsumer(destination);	for (int i = 0; i < 5; i++) {	msg = (TextMessage) consumer.receive(4000);	assertNotNull("got the message again", msg);	assertEquals("redelivery count survives restart", 2, msg.getLongProperty("JMSXDeliveryCount"));	assertEquals("re delivery flag", true, msg.getJMSRedelivered());	}	session.commit();	for (int i = 0; i < 5; i++) {	msg = (TextMessage) consumer.receive(20000);	
not redelivered got 

public void testValidateRedeliveryFlagAfterRecovery() throws Exception {	ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(broker.getTransportConnectors().get(0).getPublishableConnectString() + "?jms.prefetchPolicy.all=0");	connection = (ActiveMQConnection) connectionFactory.createConnection();	connection.start();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Destination destination = session.createQueue(queueName);	populateDestination(1, destination, connection);	MessageConsumer consumer = session.createConsumer(destination);	TextMessage msg = (TextMessage) consumer.receive(5000);	
got 

========================= activemq sample_2407 =========================

assertTrue("Should all be dispatched", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return sub.getDispatchedCounter() == 20;	}	}, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(25)));	assertEquals(20, sub.getEnqueueCounter());	assertEquals(0, sub.getDequeueCounter());	assertEquals(0, sub.getPendingQueueSize());	assertEquals(20, sub.getDispatchedCounter());	assertEquals(20, sub.getDispatchedQueueSize());	
pending queue size with no receives 

}	}, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(25)));	assertEquals(20, sub.getEnqueueCounter());	assertEquals(0, sub.getDequeueCounter());	assertEquals(0, sub.getPendingQueueSize());	assertEquals(20, sub.getDispatchedCounter());	assertEquals(20, sub.getDispatchedQueueSize());	assertNotNull(consumer.receive(1000));	assertNotNull(consumer.receive(1000));	consumer.close();	
pending queue size with two receives 

========================= activemq sample_2811 =========================

public void testSendReceive() throws Exception {	messages.clear();	Destination[] destinations = getDestinations();	int destIdx = 0;	for (int i = 0; i < data.length; i++) {	Message message = session.createTextMessage(data[i]);	if (verbose) {	
about to send a message with text 

========================= activemq sample_3703 =========================

final int COUNT = 10;	final AtomicInteger count = new AtomicInteger();	Connection connection = createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createConsumer(destination);	final CountDownLatch latch = new CountDownLatch(COUNT);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	count.incrementAndGet();	latch.countDown();	
received scheduled message waiting for more 

final int NUMBER = 10;	final AtomicInteger count = new AtomicInteger();	Connection connection = createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createConsumer(destination);	final CountDownLatch latch = new CountDownLatch(NUMBER);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	count.incrementAndGet();	latch.countDown();	
received scheduled message waiting for more 

========================= activemq sample_2329 =========================

for (int i = 0; i < MESSAGE_COUNT; i++) {	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination dest = session.createTemporaryTopic();	session.createConsumer(dest);	MessageProducer mp = session.createProducer(dest);	Message msg = session.createTextMessage("test" + i);	mp.send(msg);	session.close();	releaseDestination(dest);	if (i % 500 == 0) {	
iterator 

========================= activemq sample_3538 =========================

if (enableRecoveryFile) {	recoveryFile = new RecoverableRandomAccessFile(getRecoveryFile(), "rw");	}	boolean needsFreePageRecovery = false;	if (metaData.isCleanShutdown()) {	nextTxid.set(metaData.getLastTxId() + 1);	if (metaData.getFreePages() > 0) {	loadFreeList();	}	} else {	
recovering page file 

while (writes.isEmpty() && checkpointLatch == null && !stopWriter.get()) {	writes.wait(100);	}	if (writes.isEmpty()) {	releaseCheckpointWaiter();	}	}	writeBatch();	}	} catch (Throwable e) {	
an exception was raised while performing poll writes 

}	for (PageWrite w : batch) {	writeFile.seek(toOffset(w.page.getPageId()));	writeFile.write(w.getDiskBound(), 0, pageSize);	w.done();	}	if (enableDiskSyncs) {	writeFile.sync();	}	} catch (IOException ioError) {	
unexpected io error on pagefile write of pages 

for (int i = 0; i < pageCounter; i++) {	long offset = recoveryFile.readLong();	byte[] data = new byte[pageSize];	if (recoveryFile.read(data, 0, pageSize) != pageSize) {	return nextTxId;	}	checksum.update(data, 0, pageSize);	batch.put(offset, data);	}	} catch (Exception e) {	
redo buffer was not fully intact 

========================= activemq sample_1786 =========================

}	});	}	doTheInterrupts.shutdown();	assertTrue("all interrupts done", doTheInterrupts.awaitTermination(30, TimeUnit.SECONDS));	for (Thread thread : threads) {	thread.join();	}	for (ClientThread thread : threads) {	if (thread.error != null) {	
close error on thread 

}	for (ClientThread thread : threads) {	if (thread.error != null) {	}	}	Thread[] remainThreads = new Thread[tg.activeCount()];	tg.enumerate(remainThreads);	for (final Thread t : remainThreads) {	if (t != null && t.isAlive() && !t.isDaemon()) assertTrue("Thread completes:" + t, Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
remaining thread 

public static void visit(ThreadGroup group, int level) {	int numThreads = group.activeCount();	Thread[] threads = new Thread[numThreads * 2];	numThreads = group.enumerate(threads, false);	for (int i = 0; i < numThreads; i++) {	Thread thread = threads[i];	
thread is still running 

========================= activemq sample_2903 =========================

pooled.setConnectionFactory(new ActiveMQConnectionFactory("vm: pooled.setMaxConnections(2);	pooled.setExpiryTimeout(10L);	Thread[] threads = new Thread[10];	for (int i = 0; i < threads.length; i++) {	threads[i] = new Thread(new Runnable() {	public void run() {	while (!done.get() && latch.getCount() > 0) {	try {	final PooledConnection pooledConnection = (PooledConnection) pooled.createConnection();	if (pooledConnection.getConnection() == null) {	
found broken connection 

threads[i] = new Thread(new Runnable() {	public void run() {	while (!done.get() && latch.getCount() > 0) {	try {	final PooledConnection pooledConnection = (PooledConnection) pooled.createConnection();	if (pooledConnection.getConnection() == null) {	latch.countDown();	}	pooledConnection.close();	} catch (JMSException e) {	
caught exception 

========================= activemq sample_1293 =========================

public void testSendAfterRedelivery() throws Exception {	broker = this.createBroker(false);	broker.start();	broker.waitUntilStarted();	
broker started 

ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory( transportURL + "?trace=true&jms.redeliveryPolicy.maximumRedeliveries=0&jms.redeliveryPolicy.preDispatchCheck=true");	Connection connection = factory.createConnection();	connection.start();	try {	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Destination destinationQ1 = session.createQueue(TEST_QUEUE_ONE);	Destination destinationQ2 = session.createQueue(TEST_QUEUE_TWO);	MessageProducer producerQ1 = session.createProducer(destinationQ1);	producerQ1.setDeliveryMode(DeliveryMode.PERSISTENT);	Message m = session.createTextMessage("testMessage");	
send message to broker 

try {	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Destination destinationQ1 = session.createQueue(TEST_QUEUE_ONE);	Destination destinationQ2 = session.createQueue(TEST_QUEUE_TWO);	MessageProducer producerQ1 = session.createProducer(destinationQ1);	producerQ1.setDeliveryMode(DeliveryMode.PERSISTENT);	Message m = session.createTextMessage("testMessage");	producerQ1.send(m);	session.commit();	MessageConsumer consumerQ1 = session.createConsumer(destinationQ1);	
consume message from and rolled back 

Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Destination destinationQ1 = session.createQueue(TEST_QUEUE_ONE);	Destination destinationQ2 = session.createQueue(TEST_QUEUE_TWO);	MessageProducer producerQ1 = session.createProducer(destinationQ1);	producerQ1.setDeliveryMode(DeliveryMode.PERSISTENT);	Message m = session.createTextMessage("testMessage");	producerQ1.send(m);	session.commit();	MessageConsumer consumerQ1 = session.createConsumer(destinationQ1);	TextMessage textMessage = (TextMessage) consumerQ1.receive();	
got redelivered 

Destination destinationQ2 = session.createQueue(TEST_QUEUE_TWO);	MessageProducer producerQ1 = session.createProducer(destinationQ1);	producerQ1.setDeliveryMode(DeliveryMode.PERSISTENT);	Message m = session.createTextMessage("testMessage");	producerQ1.send(m);	session.commit();	MessageConsumer consumerQ1 = session.createConsumer(destinationQ1);	TextMessage textMessage = (TextMessage) consumerQ1.receive();	assertFalse("JMSRedelivered flag is not set", textMessage.getJMSRedelivered());	session.rollback();	
consumed message from again and sending to 

MessageProducer producerQ1 = session.createProducer(destinationQ1);	producerQ1.setDeliveryMode(DeliveryMode.PERSISTENT);	Message m = session.createTextMessage("testMessage");	producerQ1.send(m);	session.commit();	MessageConsumer consumerQ1 = session.createConsumer(destinationQ1);	TextMessage textMessage = (TextMessage) consumerQ1.receive();	assertFalse("JMSRedelivered flag is not set", textMessage.getJMSRedelivered());	session.rollback();	TextMessage textMessage2 = (TextMessage) consumerQ1.receive();	
got 

========================= activemq sample_2846 =========================

subscription.setCursorMemoryHighWaterMark(getCursorMemoryHighWaterMark());	if (pendingMessageLimitStrategy != null) {	int value = pendingMessageLimitStrategy.getMaximumPendingMessageLimit(subscription);	int consumerLimit = subscription.getInfo().getMaximumPendingMessageLimit();	if (consumerLimit > 0) {	if (value < 0 || consumerLimit < value) {	value = consumerLimit;	}	}	if (value >= 0) {	
setting the maximumpendingmessages size to for consumer 

public MessageGroupMapFactory getMessageGroupMapFactory() {	if (messageGroupMapFactory == null) {	try {	messageGroupMapFactory = GroupFactoryFinder.createMessageGroupMapFactory(getMessageGroupMapFactoryType());	}catch(Exception e){	
failed to create message group factory 

========================= activemq sample_4091 =========================

public void testBlockedFailoverSendWillReactToReadInactivityTimeout() throws Exception {	final ActiveMQQueue dest = new ActiveMQQueue("testClientWriteTimeout");	messageTextPrefix = initMessagePrefix(80*1024);	URI tcpBrokerUri = URISupport.removeQuery(broker.getTransportConnectors().get(0).getConnectUri());	
consuming using uri 

SocketProxy proxy = new SocketProxy();	proxy.setTarget(tcpBrokerUri);	proxy.open();	ActiveMQConnectionFactory pFactory = new ActiveMQConnectionFactory("failover:(" + proxy.getUrl() + "?wireFormat.maxInactivityDuration=5000&ignoreRemoteWireFormat=true)?jms.useAsyncSend=true&trackMessages=true&maxCacheSize=6638400");	final ActiveMQConnection pc = (ActiveMQConnection) pFactory.createConnection();	final AtomicInteger interruptCounter = new AtomicInteger(0);	pc.addTransportListener(new TransportListener() {	public void onCommand(Object command) {	}	public void onException(IOException error) {	
got 

public void run() {	try{	Session session = pc.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(dest);	for (int i = 0; i < messageCount; i++) {	producer.send(session.createTextMessage(messageTextPrefix  + i));	sentOne.countDown();	}	producer.close();	session.close();	
done with send of 

public boolean isSatisified() throws Exception {	return interruptCounter.get() > 0;	}	}));	proxy.goOn();	for (int i=0; i<messageCount; i++) {	assertNotNull("Got message " + i  + " after reconnect", consumer.receive(5000));	}	assertTrue("no pending messages when done", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
current total message count 

========================= activemq sample_2562 =========================

protected boolean removeEldestEntry(Map.Entry<Object,Command> eldest) {	boolean result = currentCacheSize > maxCacheSize;	if (result) {	if (eldest.getValue() instanceof Message) {	currentCacheSize -= ((Message)eldest.getValue()).getSize();	} else if (eldest.getValue() instanceof MessagePull) {	currentCacheSize -= MESSAGE_PULL_SIZE;	}	if (LOG.isTraceEnabled()) {	
removing tracked message 

public void restore(Transport transport) throws IOException {	for (Iterator<ConnectionState> iter = connectionStates.values().iterator(); iter.hasNext();) {	ConnectionState connectionState = iter.next();	connectionState.getInfo().setFailoverReconnect(true);	if (LOG.isDebugEnabled()) {	
conn 

restoreTempDestinations(transport, connectionState);	if (restoreSessions) {	restoreSessions(transport, connectionState);	}	if (restoreTransaction) {	restoreTransactions(transport, connectionState);	}	}	for (Command msg : messageCache.values()) {	if (LOG.isDebugEnabled()) {	
command 

private void restoreTransactions(Transport transport, ConnectionState connectionState) throws IOException {	Vector<TransactionInfo> toRollback = new Vector<>();	for (TransactionState transactionState : connectionState.getTransactionStates()) {	if (LOG.isDebugEnabled()) {	
tx 

Vector<TransactionInfo> toRollback = new Vector<>();	for (TransactionState transactionState : connectionState.getTransactionStates()) {	if (LOG.isDebugEnabled()) {	}	if (!transactionState.getCommands().isEmpty()) {	Command lastCommand = transactionState.getCommands().get(transactionState.getCommands().size() - 1);	if (lastCommand instanceof TransactionInfo) {	TransactionInfo transactionInfo = (TransactionInfo) lastCommand;	if (transactionInfo.getType() == TransactionInfo.COMMIT_ONE_PHASE) {	if (LOG.isDebugEnabled()) {	
rolling back potentially completed tx 

if (transactionInfo.getType() == TransactionInfo.COMMIT_ONE_PHASE) {	if (LOG.isDebugEnabled()) {	}	toRollback.add(transactionInfo);	continue;	}	}	}	for (ProducerState producerState : transactionState.getProducerStates().values()) {	if (LOG.isDebugEnabled()) {	
tx replay producer 

}	}	}	for (ProducerState producerState : transactionState.getProducerStates().values()) {	if (LOG.isDebugEnabled()) {	}	transport.oneway(producerState.getInfo());	}	for (Command command : transactionState.getCommands()) {	if (LOG.isDebugEnabled()) {	
tx replay 

}	transport.oneway(producerState.getInfo());	}	for (Command command : transactionState.getCommands()) {	if (LOG.isDebugEnabled()) {	}	transport.oneway(command);	}	for (ProducerState producerState : transactionState.getProducerStates().values()) {	if (LOG.isDebugEnabled()) {	
tx remove replayed producer 

protected void restoreSessions(Transport transport, ConnectionState connectionState) throws IOException {	for (Iterator iter2 = connectionState.getSessionStates().iterator(); iter2.hasNext();) {	SessionState sessionState = (SessionState)iter2.next();	if (LOG.isDebugEnabled()) {	
session 

protected void restoreConsumers(Transport transport, SessionState sessionState) throws IOException {	final ConnectionState connectionState = connectionStates.get(sessionState.getInfo().getSessionId().getParentId());	final boolean connectionInterruptionProcessingComplete = connectionState.isConnectionInterruptProcessingComplete();	for (ConsumerState consumerState : sessionState.getConsumerStates()) {	ConsumerInfo infoToSend = consumerState.getInfo();	if (!connectionInterruptionProcessingComplete && infoToSend.getPrefetchSize() > 0) {	infoToSend = consumerState.getInfo().copy();	connectionState.getRecoveringPullConsumers().put(infoToSend.getConsumerId(), consumerState.getInfo());	infoToSend.setPrefetchSize(0);	if (LOG.isDebugEnabled()) {	
restore consumer in pull mode pending recovery overriding prefetch 

for (ConsumerState consumerState : sessionState.getConsumerStates()) {	ConsumerInfo infoToSend = consumerState.getInfo();	if (!connectionInterruptionProcessingComplete && infoToSend.getPrefetchSize() > 0) {	infoToSend = consumerState.getInfo().copy();	connectionState.getRecoveringPullConsumers().put(infoToSend.getConsumerId(), consumerState.getInfo());	infoToSend.setPrefetchSize(0);	if (LOG.isDebugEnabled()) {	}	}	if (LOG.isDebugEnabled()) {	
consumer 

protected void restoreProducers(Transport transport, SessionState sessionState) throws IOException {	for (Iterator iter3 = sessionState.getProducerStates().iterator(); iter3.hasNext();) {	ProducerState producerState = (ProducerState)iter3.next();	if (LOG.isDebugEnabled()) {	
producer 

protected void restoreTempDestinations(Transport transport, ConnectionState connectionState) throws IOException {	for (Iterator iter2 = connectionState.getTempDestinations().iterator(); iter2.hasNext();) {	DestinationInfo info = (DestinationInfo)iter2.next();	transport.oneway(info);	if (LOG.isDebugEnabled()) {	
tempdest 

if (connectionState != null) {	connectionState.setConnectionInterruptProcessingComplete(true);	Map<ConsumerId, ConsumerInfo> stalledConsumers = connectionState.getRecoveringPullConsumers();	for (Entry<ConsumerId, ConsumerInfo> entry: stalledConsumers.entrySet()) {	ConsumerControl control = new ConsumerControl();	control.setConsumerId(entry.getKey());	control.setPrefetch(entry.getValue().getPrefetchSize());	control.setDestination(entry.getValue().getDestination());	try {	if (LOG.isDebugEnabled()) {	
restored recovering consumer with 

ConsumerControl control = new ConsumerControl();	control.setConsumerId(entry.getKey());	control.setPrefetch(entry.getValue().getPrefetchSize());	control.setDestination(entry.getValue().getDestination());	try {	if (LOG.isDebugEnabled()) {	}	transport.oneway(control);	} catch (Exception ex) {	if (LOG.isDebugEnabled()) {	
failed to submit control for consumer with 

========================= activemq sample_229 =========================

public void testHeapUsage() throws Exception {	Runtime.getRuntime().gc();	final long initUsedMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();	sendMessages(10000);	Runtime.getRuntime().gc();	long usedMem = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() - initUsedMemory;	
mem in use K 

========================= activemq sample_2831 =========================

public void testMessageRerouting() throws Exception {	MessageConsumer consumer = createConsumer("broker-D", dest);	MessageIdList received = getConsumerMessages("broker-D", consumer);	Thread.sleep(2000);	sendMessages("broker-A", dest, MESSAGE_COUNT);	received.waitForMessagesToArrive(MESSAGE_COUNT);	
received messages 

MessageIdList received = getConsumerMessages("broker-D", consumer);	Thread.sleep(2000);	sendMessages("broker-A", dest, MESSAGE_COUNT);	received.waitForMessagesToArrive(MESSAGE_COUNT);	assertEquals(MESSAGE_COUNT, received.getMessageCount());	brokers.get("broker-B").broker.stop();	brokers.get("broker-B").broker.waitUntilStopped();	Thread.sleep(2000);	sendMessages("broker-A", dest, MESSAGE_COUNT);	received.waitForMessagesToArrive(MESSAGE_COUNT);	
received messages 

========================= activemq sample_3723 =========================

stat.setCurrent(200);	assertEquals(200, stat.getCurrent());	assertEquals(50, stat.getLowWaterMark());	assertEquals(200, stat.getHighWaterMark());	Thread.sleep(500);	stat.setCurrent(10);	assertEquals(10, stat.getCurrent());	assertEquals(10, stat.getLowWaterMark());	assertEquals(200, stat.getHighWaterMark());	assertLastTimeNotStartTime(stat);	
stat is 

========================= activemq sample_2974 =========================

if (timeout != null) {	synchronized (messagesWaitingForSpace) {	if (messagesWaitingForSpace.remove(timeout.message.getMessageId()) != null) {	ExceptionResponse response = new ExceptionResponse( new ResourceAllocationException( "Usage Manager Memory Limit Wait Timeout. Stopping producer (" + timeout.message.getProducerId() + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "." + " See http: response.setCorrelationId(timeout.message.getCommandId());	timeout.context.getConnection().dispatchAsync(response);	}	}	}	}	} catch (InterruptedException e) {	
producer flow control timeout task is stopping 

public boolean recoverMessage(Message message) {	recoveredAccumulator++;	if ((recoveredAccumulator % 10000) == 0) {	
cursor for has recovered messages complete 

if (message.isExpired() && broker.isExpired(message)) {	toExpire.add(message);	return true;	}	if (hasSpace()) {	messagesLock.writeLock().lock();	try {	try {	messages.addMessageLast(message);	} catch (Exception e) {	
failed to add message to cursor 

public void addSubscription(ConnectionContext context, Subscription sub) throws Exception {	
add sub dequeues dispatched inflight 

public void removeSubscription(ConnectionContext context, Subscription sub, long lastDeliveredSequenceId) throws Exception {	super.removeSubscription(context, sub, lastDeliveredSequenceId);	pagedInPendingDispatchLock.writeLock().lock();	try {	
remove sub lastdeliveredseqid dequeues dispatched inflight groups 

ConsumerId consumerId = sub.getConsumerInfo().getConsumerId();	getMessageGroupOwners().removeConsumer(consumerId);	boolean markAsRedelivered = false;	MessageReference lastDeliveredRef = null;	List<MessageReference> unAckedMessages = sub.remove(context, this);	if (lastDeliveredSequenceId > RemoveInfo.LAST_DELIVERED_UNSET) {	for (MessageReference ref : unAckedMessages) {	if (ref.getMessageId().getBrokerSequenceId() == lastDeliveredSequenceId) {	lastDeliveredRef = ref;	markAsRedelivered = true;	
found lastdeliveredseqid message reference 

public void send(final ProducerBrokerExchange producerExchange, final Message message) throws Exception {	final ConnectionContext context = producerExchange.getConnectionContext();	message.setRegionDestination(this);	ProducerState state = producerExchange.getProducerState();	if (state == null) {	
send failed for missing producer state for 

ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());	context.getConnection().dispatchAsync(ack);	}	return;	}	if (memoryUsage.isFull()) {	isFull(context, memoryUsage);	fastProducer(context, producerInfo);	if (isProducerFlowControl() && context.isProducerFlowControl()) {	if (isFlowControlLogRequired()) {	
usage manager memory limit reached on size producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it see http memoryusage getlimit getactivemqdestination getqualifiedname destinationstatistics getmessages getcount 

}	messagesWaitingForSpace.put(message.getMessageId(), new Runnable() {	public void run() {	try {	if (message.isInTransaction()) {	if (context.getTransaction().getState() > IN_USE_STATE) {	throw new JMSException("Send transaction completed while waiting for space");	}	}	if (message.isExpired()) {	
message expired waiting for space 

Response response = new Response();	response.setCorrelationId(message.getCommandId());	context.getConnection().dispatchAsync(response);	}	} catch (Exception e) {	if (!sendProducerAck && !context.isInRecoveryMode() && !brokerService.isStopping()) {	ExceptionResponse response = new ExceptionResponse(e);	response.setCorrelationId(message.getCommandId());	context.getConnection().dispatchAsync(response);	} else {	
unexpected exception on deferred send of 

flowControlTimeoutMessages.add(new TimeoutMessage(message, context, systemUsage .getSendFailIfNoSpaceAfterTimeout()));	}	registerCallbackForNotFullNotification();	context.setDontSendReponse(true);	return;	}	} else {	if (memoryUsage.isFull()) {	waitForSpace(context, producerExchange, memoryUsage, "Usage Manager Memory Limit reached. Producer (" + message.getProducerId() + ") stopped to prevent flooding " + getActiveMQDestination().getQualifiedName() + "." + " See http: }	if (message.isExpired()) {	
expired message 

private void doPendingCursorAdditions() throws Exception {	LinkedList<MessageContext> orderedUpdates = new LinkedList<>();	sendLock.lockInterruptibly();	try {	synchronized (indexOrderedCursorUpdates) {	MessageContext candidate = indexOrderedCursorUpdates.peek();	while (candidate != null && candidate.message.getMessageId().getFutureOrSequenceLong() != null) {	candidate = indexOrderedCursorUpdates.removeFirst();	if (candidate.message.getMessageId().getFutureOrSequenceLong() instanceof Long && ((Long)candidate.message.getMessageId().getFutureOrSequenceLong()).compareTo(-1l) == 0) {	
messagestore indicated duplicate add attempt for suppressing duplicate dispatch 

private void expireMessages() {	
expiring messages 

private void expireMessages() {	List<Message> browsedMessages = new InsertionCountList<Message>();	doBrowse(browsedMessages, this.getMaxExpirePageSize());	asyncWakeup();	
expiring messages done 

messagesLock.readLock().unlock();	}	while (shouldPageInMoreForBrowse(max) && maxPageInAttempts-- > 0) {	pageInMessages(!memoryUsage.isFull(110), max);	}	}	doBrowseList(browseList, max, dispatchPendingList, pagedInPendingDispatchLock, connectionContext, "redeliveredWaitingDispatch+pagedInPendingDispatch");	doBrowseList(browseList, max, pagedInMessages, pagedInMessagesLock, connectionContext, "pagedInMessages");	} catch (BrokerStoppedException ignored) {	} catch (Exception e) {	
problem retrieving message for browse 

protected void doBrowseList(List<Message> browseList, int max, PendingList list, ReentrantReadWriteLock lock, ConnectionContext connectionContext, String name) throws Exception {	List<MessageReference> toExpire = new ArrayList<MessageReference>();	lock.readLock().lock();	try {	addAll(list.values(), browseList, max, toExpire);	} finally {	lock.readLock().unlock();	}	for (MessageReference ref : toExpire) {	if (broker.isExpired(ref)) {	
expiring from 

} finally {	pagedInMessagesLock.readLock().unlock();	}	int messagesInQueue = alreadyPagedIn;	messagesLock.readLock().lock();	try {	messagesInQueue += messages.size();	} finally {	messagesLock.readLock().unlock();	}	
max alreadypagedin messagescount memoryusage 

QueueMessageReference r = (QueueMessageReference) ref;	removeMessage(c, r);	} catch (IOException e) {	}	}	} while (!list.isEmpty() && this.destinationStatistics.getMessages().getCount() > 0);	if (getMessages().getMessageAudit() != null) {	getMessages().getMessageAudit().clear();	}	if (this.destinationStatistics.getMessages().getCount() > 0) {	
after purge of messages message count stats report 

}	if (firstConsumer) {	firstConsumer = false;	try {	if (consumersBeforeDispatchStarts > 0) {	int timeout = 1000;	if (timeBeforeDispatchStarts > 0) {	timeout = timeBeforeDispatchStarts;	}	if (consumersBeforeStartsLatch.await(timeout, TimeUnit.MILLISECONDS)) {	
consumers subscribed starting dispatch 

if (firstConsumer) {	firstConsumer = false;	try {	if (consumersBeforeDispatchStarts > 0) {	int timeout = 1000;	if (timeBeforeDispatchStarts > 0) {	timeout = timeBeforeDispatchStarts;	}	if (consumersBeforeStartsLatch.await(timeout, TimeUnit.MILLISECONDS)) {	} else {	
ms elapsed and consumers subscribed starting dispatch 

int timeout = 1000;	if (timeBeforeDispatchStarts > 0) {	timeout = timeBeforeDispatchStarts;	}	if (consumersBeforeStartsLatch.await(timeout, TimeUnit.MILLISECONDS)) {	} else {	}	}	if (timeBeforeDispatchStarts > 0 && consumersBeforeDispatchStarts <= 0) {	iteratingMutex.wait(timeBeforeDispatchStarts);	
ms elapsed starting dispatch 

try {	pageInMoreMessages |= !dispatchPendingList.isEmpty();	} finally {	pagedInPendingDispatchLock.readLock().unlock();	}	boolean hasBrowsers = !browserDispatches.isEmpty();	if (pageInMoreMessages || hasBrowsers || !dispatchPendingList.hasRedeliveries()) {	try {	pageInMessages(hasBrowsers && getMaxBrowsePageSize() > 0, getMaxPageSize());	} catch (Throwable e) {	
failed to page in more queue messages 

} finally {	pagedInMessagesLock.readLock().unlock();	}	Iterator<BrowserDispatch> browsers = browserDispatches.iterator();	while (browsers.hasNext()) {	BrowserDispatch browserDispatch = browsers.next();	try {	MessageEvaluationContext msgContext = new NonCachedMessageEvaluationContext();	msgContext.setDestination(destination);	QueueBrowserSubscription browser = browserDispatch.getBrowser();	
dispatch to browser already dispatched paged count 

}	}	}	if (!added || browser.atMax()) {	browser.decrementQueueRef();	browserDispatches.remove(browserDispatch);	} else {	wakeup();	}	} catch (Exception e) {	
exception on dispatch to browser 

protected void removeMessage(ConnectionContext context, Subscription sub, final QueueMessageReference reference, MessageAck ack) throws IOException {	
ack of with 

public void messageExpired(ConnectionContext context, Subscription subs, MessageReference reference) {	
message expired 

destinationStatistics.getExpired().increment();	try {	removeMessage(context, subs, (QueueMessageReference) reference);	messagesLock.writeLock().lock();	try {	messages.rollback(reference.getMessageId());	} finally {	messagesLock.writeLock().unlock();	}	} catch (IOException e) {	
failed to remove expired message from the store 

private void asyncWakeup() {	try {	pendingWakeups.incrementAndGet();	this.taskRunner.wakeup();	} catch (InterruptedException e) {	
async task runner failed to wakeup 

pagedInPendingDispatchLock.readLock().lock();	try {	pagedInPendingSize = dispatchPendingList.size();	} finally {	pagedInPendingDispatchLock.readLock().unlock();	}	if (isLazyDispatch() && !force) {	toPageIn = Math.min(toPageIn, getConsumerMessageCountBeforeFull());	}	if (LOG.isDebugEnabled()) {	
topagein force inflight pagedinmessages size pagedinpendingdispatch size enqueuecount dequeuecount memusage maxpagesize 

resultList = new PrioritizedPendingList();	} else {	resultList = new OrderedPendingList();	}	for (QueueMessageReference ref : result) {	if (!pagedInMessages.contains(ref)) {	pagedInMessages.addMessageLast(ref);	resultList.addMessageLast(ref);	} else {	ref.decrementReferenceCount();	
duplicate message from cursor is cursor audit disabled or too constrained redirecting to dlq 

for (QueueMessageReference ref : result) {	if (!pagedInMessages.contains(ref)) {	pagedInMessages.addMessageLast(ref);	resultList.addMessageLast(ref);	} else {	ref.decrementReferenceCount();	if (store != null) {	ConnectionContext connectionContext = createConnectionContext();	dropMessage(ref);	if (gotToTheStore(ref.getMessage())) {	
duplicate message from cursor removing from store 

store.removeMessage(connectionContext, new MessageAck(ref.getMessage(), MessageAck.POSION_ACK_TYPE, 1));	}	broker.getRoot().sendToDeadLetterQueue(connectionContext, ref.getMessage(), null, new Throwable("duplicate paged in from cursor for " + destination));	}	}	}	} finally {	pagedInMessagesLock.writeLock().unlock();	}	} else if (!messages.hasSpace() && isFlowControlLogRequired()) {	
cursor blocked no space available to page in messages usage 

MessageReference node = iterator.next();	Subscription target = null;	for (Subscription s : consumers) {	if (s instanceof QueueBrowserSubscription) {	continue;	}	if (!fullConsumers.contains(s)) {	if (!s.isFull()) {	if (dispatchSelector.canSelect(s, node) && assignMessageGroup(s, (QueueMessageReference)node) && !((QueueMessageReference) node).isAcked() ) {	s.add(node);	
assigned to consumer 

if (!fullConsumers.contains(s)) {	if (!s.isFull()) {	if (dispatchSelector.canSelect(s, node) && assignMessageGroup(s, (QueueMessageReference)node) && !((QueueMessageReference) node).isAcked() ) {	s.add(node);	iterator.remove();	target = s;	break;	}	} else {	fullConsumers.add(s);	
subscription full 

========================= activemq sample_4009 =========================

public static void waitForJettySocketToAccept(String bindLocation) throws Exception {	final URL url = new URL(bindLocation);	assertTrue("Jetty endpoint is available", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	boolean canConnect = false;	try {	Socket socket = SocketFactory.getDefault().createSocket(url.getHost(), url.getPort());	socket.close();	canConnect = true;	} catch (Exception e) {	
verify jetty available failed to connect to 

========================= activemq sample_1088 =========================

public static String nameFromDestinationFilter(ActiveMQDestination destination) {	if (destination.getQualifiedName().length() > IOHelper.getMaxFileNameLength()) {	
destination name is longer than maximumfilenamelength system property potential problem with recovery can result from name truncation 

private PersistenceAdapter getMatchingPersistenceAdapter(ActiveMQDestination destination) throws IOException {	Object result = destinationMap.chooseValue(destination);	if (result == null) {	throw new RuntimeException("No matching persistence adapter configured for destination: " + destination + ", options:" + adapters);	}	FilteredKahaDBPersistenceAdapter filteredAdapter = (FilteredKahaDBPersistenceAdapter) result;	if (filteredAdapter.getDestination() == matchAll && filteredAdapter.isPerDestination()) {	filteredAdapter = addAdapter(filteredAdapter, destination);	if (LOG.isTraceEnabled()) {	
created per destination adapter for 

if (result == null) {	throw new RuntimeException("No matching persistence adapter configured for destination: " + destination + ", options:" + adapters);	}	FilteredKahaDBPersistenceAdapter filteredAdapter = (FilteredKahaDBPersistenceAdapter) result;	if (filteredAdapter.getDestination() == matchAll && filteredAdapter.isPerDestination()) {	filteredAdapter = addAdapter(filteredAdapter, destination);	if (LOG.isTraceEnabled()) {	}	}	startAdapter(filteredAdapter.getPersistenceAdapter(), destination.getQualifiedName());	
destination matched persistence adapter 

private void removeMessageStore(PersistenceAdapter adapter, ActiveMQDestination destination) {	stopAdapter(adapter, destination.toString());	File adapterDir = adapter.getDirectory();	if (adapterDir != null) {	if (IOHelper.deleteFile(adapterDir)) {	if (LOG.isTraceEnabled()) {	
deleted per destination adapter directory for 

private void removeMessageStore(PersistenceAdapter adapter, ActiveMQDestination destination) {	stopAdapter(adapter, destination.toString());	File adapterDir = adapter.getDirectory();	if (adapterDir != null) {	if (IOHelper.deleteFile(adapterDir)) {	if (LOG.isTraceEnabled()) {	}	} else {	if (LOG.isTraceEnabled()) {	
failed to deleted per destination adapter directory for 

========================= activemq sample_1821 =========================

public void start() throws Exception {	if (started.compareAndSet(false, true)) {	startDispatching();	
jobscheduler started 

public void stop() throws Exception {	if (started.compareAndSet(true, false)) {	stopDispatching();	timer.cancel();	jobs.clear();	
jobscheduler stopped 

executionTime += period;	}	InMemoryJob newJob = new InMemoryJob(jobId);	newJob.setStart(startTime);	newJob.setCronEntry(cronEntry);	newJob.setDelay(delay);	newJob.setPeriod(period);	newJob.setRepeat(repeat);	newJob.setNextTime(executionTime);	newJob.setPayload(payload.getData());	
jobscheduler adding job to fire at 

private void doReschedule(InMemoryJob job, long nextExecutionTime) {	job.setNextTime(nextExecutionTime);	job.incrementExecutionCount();	if (!job.isCron()) {	job.decrementRepeatCount();	}	
jobscheduler rescheduling job to fire at 

private void doRemoveJob(String jobId) throws IOException {	this.lock.writeLock().lock();	try {	Iterator<Map.Entry<Long, ScheduledTask>> scheduled = jobs.entrySet().iterator();	while (scheduled.hasNext()) {	Map.Entry<Long, ScheduledTask> entry = scheduled.next();	ScheduledTask task = entry.getValue();	if (task.remove(jobId)) {	
jobscheduler removing job 

private void dispatch(InMemoryJob job) throws IllegalStateException, IOException {	if (canDispatch()) {	
firing 

doReschedule(job, nextExecutionTime);	if (repeat != 0) {	String jobId = ID_GENERATOR.generateId();	ByteSequence payload = new ByteSequence(job.getPayload());	schedule(jobId, payload, "", job.getDelay(), job.getPeriod(), job.getRepeat());	}	}	}	}	} catch (Throwable e) {	
error while processing scheduled job s 

========================= activemq sample_3959 =========================

public void onException(IOException error) {	try {	synchronized (reconnectMutex) {	if (transport == null || !transport.isConnected()) {	return;	}	
transport failed starting up reconnect task 

continue;	}	if (fanoutHandler.reconnectDate != 0 && fanoutHandler.reconnectDate > now) {	if (closestReconnectDate == 0 || fanoutHandler.reconnectDate < closestReconnectDate) {	closestReconnectDate = fanoutHandler.reconnectDate;	}	continue;	}	URI uri = fanoutHandler.uri;	try {	
stopped 

continue;	}	if (fanoutHandler.reconnectDate != 0 && fanoutHandler.reconnectDate > now) {	if (closestReconnectDate == 0 || fanoutHandler.reconnectDate < closestReconnectDate) {	closestReconnectDate = fanoutHandler.reconnectDate;	}	continue;	}	URI uri = fanoutHandler.uri;	try {	
attempting connect to 

continue;	}	URI uri = fanoutHandler.uri;	try {	Transport t = TransportFactory.compositeConnect(uri);	fanoutHandler.transport = t;	t.setTransportListener(fanoutHandler);	if (started) {	restoreTransport(fanoutHandler);	}	
connection established 

if (started) {	restoreTransport(fanoutHandler);	}	fanoutHandler.reconnectDelay = initialReconnectDelay;	fanoutHandler.connectFailures = 0;	if (primary == null) {	primary = fanoutHandler;	}	connectedCount++;	} catch (Exception e) {	
connect fail to reason 

if (primary == null) {	primary = fanoutHandler;	}	connectedCount++;	} catch (Exception e) {	if (fanoutHandler.transport != null) {	ServiceSupport.dispose(fanoutHandler.transport);	fanoutHandler.transport = null;	}	if (maxReconnectAttempts > 0 && ++fanoutHandler.connectFailures >= maxReconnectAttempts) {	
failed to connect to transport after attempt s 

if (transports.size() == connectedCount || disposed) {	reconnectMutex.notifyAll();	return false;	}	}	}	}	try {	long reconnectDelay = closestReconnectDate - System.currentTimeMillis();	if (reconnectDelay > 0) {	
waiting ms before attempting connection 

public void start() throws Exception {	synchronized (reconnectMutex) {	
started 

}	started = false;	disposed = true;	connected = false;	for (Iterator<FanoutTransportHandler> iter = transports.iterator(); iter.hasNext();) {	FanoutTransportHandler th = iter.next();	if (th.transport != null) {	ss.stop(th.transport);	}	}	
stopped 

public void oneway(Object o) throws IOException {	final Command command = (Command) o;	try {	synchronized (reconnectMutex) {	while (connectedCount < minAckCount && !disposed && connectionFailure == null) {	
waiting for at least transports to be connected 

int size = fanout ? minAckCount : 1;	requestMap.put(new Integer(command.getCommandId()), new RequestCounter(command, size));	}	if (fanout) {	for (Iterator<FanoutTransportHandler> iter = transports.iterator(); iter.hasNext();) {	FanoutTransportHandler th = iter.next();	if (th.transport != null) {	try {	th.transport.oneway(command);	} catch (IOException e) {	
send attempt failed 

th.transport.oneway(command);	} catch (IOException e) {	th.onException(e);	}	}	}	} else {	try {	primary.transport.oneway(command);	} catch (IOException e) {	
send attempt failed 

public void reconnect() {	
waking up reconnect task 

========================= activemq sample_100 =========================

protected void cleanupConnectionTemporaryDestinations() {	for (TemporaryQueue tempQueue : connTempQueues) {	try {	tempQueue.delete();	} catch (JMSException ex) {	
failed to delete temporary queue tempqueue tostring on closing pooled connection 

try {	tempQueue.delete();	} catch (JMSException ex) {	}	}	connTempQueues.clear();	for (TemporaryTopic tempTopic : connTempTopics) {	try {	tempTopic.delete();	} catch (JMSException ex) {	
failed to delete temporary topic temptopic tostring on closing pooled connection 

protected void cleanupAllLoanedSessions() {	for (PooledSession session : loanedSessions) {	try {	session.close();	} catch (JMSException ex) {	
failed to close laoned session session on closing pooled connection 

========================= activemq sample_1319 =========================

protected void startBroker() throws Exception {	broker = new BrokerService();	broker.setDeleteAllMessagesOnStartup(true);	broker.setPersistent(true);	broker.setUseJmx(true);	broker.setDataDirectory(dataDir.getRoot().getAbsolutePath());	adapter = (KahaDBPersistenceAdapter) broker.getPersistenceAdapter();	adapter.setEnableSubscriptionStatistics(subStatsEnabled);	broker.start();	
starting broker 

========================= activemq sample_1749 =========================

protected void sendWriteBuffer(int commandId, SocketAddress address, ByteBuffer writeBuffer, boolean redelivery) throws IOException {	if (dropCommandStrategy.shouldDropCommand(commandId, address, redelivery)) {	writeBuffer.flip();	
dropping datagram with command 

========================= activemq sample_2470 =========================

public void testDurableSubPrefetchRecovered() throws Exception {	ActiveMQQueue queue = new ActiveMQQueue("MyQueue");	ActiveMQTopic topic = new ActiveMQTopic("MyDurableTopic");	sendMessages(queue);	
there are currently journal log files 

ActiveMQTopic topic = new ActiveMQTopic("MyDurableTopic");	sendMessages(queue);	createInactiveDurableSub(topic);	assertTrue("Should have an inactive durable sub", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(queue);	
there are currently journal log files 

sendMessages(queue);	createInactiveDurableSub(topic);	assertTrue("Should have an inactive durable sub", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(queue);	assertTrue(getNumberOfJournalFiles() > 1);	
restarting the broker 

createInactiveDurableSub(topic);	assertTrue("Should have an inactive durable sub", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(queue);	assertTrue(getNumberOfJournalFiles() > 1);	restartBroker();	
restarted the broker 

createInactiveDurableSub(topic);	assertTrue("Should have an inactive durable sub", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(queue);	assertTrue(getNumberOfJournalFiles() > 1);	restartBroker();	
there are currently journal log files 

ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	service.getAdminView().removeQueue(queue.getQueueName());	assertTrue("Less than two journal files expected, was " + getNumberOfJournalFiles(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getNumberOfJournalFiles() <= 2;	}	}, TimeUnit.MINUTES.toMillis(2)));	
sending messages to the topic 

return subs != null && subs.length == 1 ? true : false;	}	}));	service.getAdminView().removeQueue(queue.getQueueName());	assertTrue("Less than two journal files expected, was " + getNumberOfJournalFiles(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getNumberOfJournalFiles() <= 2;	}	}, TimeUnit.MINUTES.toMillis(2)));	sendMessages(topic);	
attempt to consume messages from the topic 

}	}));	service.getAdminView().removeQueue(queue.getQueueName());	assertTrue("Less than two journal files expected, was " + getNumberOfJournalFiles(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getNumberOfJournalFiles() <= 2;	}	}, TimeUnit.MINUTES.toMillis(2)));	sendMessages(topic);	assertEquals(MSG_COUNT, consumeFromInactiveDurableSub(topic));	
recovering the broker 

}));	service.getAdminView().removeQueue(queue.getQueueName());	assertTrue("Less than two journal files expected, was " + getNumberOfJournalFiles(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getNumberOfJournalFiles() <= 2;	}	}, TimeUnit.MINUTES.toMillis(2)));	sendMessages(topic);	assertEquals(MSG_COUNT, consumeFromInactiveDurableSub(topic));	recoverBroker();	
recovering the broker 

ActiveMQTopic topic = new ActiveMQTopic("MyDurableTopic");	createInactiveDurableSub(topic);	assertTrue("Should have an inactive durable sub", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(topic, 1);	sendMessages(queue);	
before consume there are currently journal log files 

createInactiveDurableSub(topic);	assertTrue("Should have an inactive durable sub", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(topic, 1);	sendMessages(queue);	consumeDurableMessages(topic, 1);	
after consume there are currently journal log files 

assertTrue("Should have an inactive durable sub", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(topic, 1);	sendMessages(queue);	consumeDurableMessages(topic, 1);	sendMessages(queue);	
more queued there are currently journal log files 

public boolean isSatisified() throws Exception {	ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(topic, 1);	sendMessages(queue);	consumeDurableMessages(topic, 1);	sendMessages(queue);	assertTrue(getNumberOfJournalFiles() > 1);	
restarting the broker 

ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(topic, 1);	sendMessages(queue);	consumeDurableMessages(topic, 1);	sendMessages(queue);	assertTrue(getNumberOfJournalFiles() > 1);	restartBroker();	
restarted the broker 

ObjectName[] subs = service.getAdminView().getInactiveDurableTopicSubscribers();	return subs != null && subs.length == 1 ? true : false;	}	}));	sendMessages(topic, 1);	sendMessages(queue);	consumeDurableMessages(topic, 1);	sendMessages(queue);	assertTrue(getNumberOfJournalFiles() > 1);	restartBroker();	
there are currently journal log files 

return subs != null && subs.length == 1 ? true : false;	}	}));	service.getAdminView().removeQueue(queue.getQueueName());	assertTrue("Less than three journal file expected, was " + getNumberOfJournalFiles(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getNumberOfJournalFiles() <= 3;	}	}, TimeUnit.MINUTES.toMillis(3)));	tryConsumeExpectNone(topic);	
there are currently journal log files 

return subs != null && subs.length == 1 ? true : false;	}	}));	service.getAdminView().removeQueue(queue.getQueueName());	assertTrue("Less than three journal file expected, was " + getNumberOfJournalFiles(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getNumberOfJournalFiles() <= 3;	}	}, TimeUnit.MINUTES.toMillis(3)));	tryConsumeExpectNone(topic);	
recovering the broker 

}	}));	service.getAdminView().removeQueue(queue.getQueueName());	assertTrue("Less than three journal file expected, was " + getNumberOfJournalFiles(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getNumberOfJournalFiles() <= 3;	}	}, TimeUnit.MINUTES.toMillis(3)));	tryConsumeExpectNone(topic);	recoverBroker();	
recovering the broker 

}	}));	service.getAdminView().removeQueue(queue.getQueueName());	assertTrue("Less than three journal file expected, was " + getNumberOfJournalFiles(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getNumberOfJournalFiles() <= 3;	}	}, TimeUnit.MINUTES.toMillis(3)));	tryConsumeExpectNone(topic);	recoverBroker();	
there are currently journal log files 

========================= activemq sample_2889 =========================

public void start() throws Exception {	super.start();	try {	BrokerContext brokerContext = next.getBrokerService().getBrokerContext();	if (brokerContext != null) {	configToMonitor = Utils.resourceFromString(brokerContext.getConfigurationUrl());	info("Configuration " + configToMonitor);	} else {	
null brokercontext impossible to determine configuration url resource from broker updates cannot be tracked 

public void start() throws Exception {	super.start();	try {	BrokerContext brokerContext = next.getBrokerService().getBrokerContext();	if (brokerContext != null) {	configToMonitor = Utils.resourceFromString(brokerContext.getConfigurationUrl());	info("Configuration " + configToMonitor);	} else {	}	} catch (Exception error) {	
failed to determine configuration url resource from broker updates cannot be tracked 

protected void registerMbean() {	if (getBrokerService().isUseJmx()) {	ManagementContext managementContext = getBrokerService().getManagementContext();	try {	objectName = new ObjectName(getBrokerService().getBrokerObjectName().toString() + objectNamePropsAppendage);	managementContext.registerMBean(new RuntimeConfigurationView(this), objectName);	} catch (Exception ignored) {	
failed to register runtimeconfigurationmbean 

public String updateNow() {	
manual configuration update triggered 

private void monitorModification(final Resource configToMonitor) {	monitorTask = new Runnable() {	public void run() {	try {	if (configToMonitor.lastModified() > lastModified) {	applyModifications(configToMonitor);	}	} catch (Throwable e) {	
failed to determine lastmodified time on configuration 

private void applyModifications(Resource configToMonitor) {	DtoBroker changed = loadConfiguration(configToMonitor);	if (changed != null && !currentConfiguration.equals(changed)) {	
change in at 

private void applyModifications(Resource configToMonitor) {	DtoBroker changed = loadConfiguration(configToMonitor);	if (changed != null && !currentConfiguration.equals(changed)) {	
current 

private void applyModifications(Resource configToMonitor) {	DtoBroker changed = loadConfiguration(configToMonitor);	if (changed != null && !currentConfiguration.equals(changed)) {	
new 

========================= activemq sample_4398 =========================

if (isDestroyed()) {	return;	}	try {	cleanup();	} finally {	try {	physicalConnection.close();	destroyed = true;	} catch (JMSException e) {	
error occurred during close of a jms connection 

public void onException(JMSException e) {	
connection failed 

public void onException(JMSException e) {	
cause 

========================= activemq sample_854 =========================

public void start() throws Exception {	
connecting 

public void start() throws Exception {	Hashtable<String, String> env = new Hashtable<String, String>();	env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");	this.ldapURI = getUri();	
uri 

public void start() throws Exception {	Hashtable<String, String> env = new Hashtable<String, String>();	env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");	this.ldapURI = getUri();	env.put(Context.PROVIDER_URL, this.ldapURI.toString());	if (anonymousAuthentication) {	
login credentials anonymous 

public void start() throws Exception {	Hashtable<String, String> env = new Hashtable<String, String>();	env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");	this.ldapURI = getUri();	env.put(Context.PROVIDER_URL, this.ldapURI.toString());	if (anonymousAuthentication) {	env.put(Context.SECURITY_AUTHENTICATION, "none");	} else {	
login credentials 

}	}	boolean isConnected = false;	while (!isConnected) {	try {	context = new InitialDirContext(env);	isConnected = true;	} catch (CommunicationException err) {	if (failover) {	this.ldapURI = getUri();	
connection error failover connection to 

if (failover) {	this.ldapURI = getUri();	env.put(Context.PROVIDER_URL, this.ldapURI.toString());	Thread.sleep(curReconnectDelay);	curReconnectDelay = Math.min(curReconnectDelay * 2, maxReconnectDelay);	} else {	throw err;	}	}	}	
searching for network connectors 

if (failover) {	this.ldapURI = getUri();	env.put(Context.PROVIDER_URL, this.ldapURI.toString());	Thread.sleep(curReconnectDelay);	curReconnectDelay = Math.min(curReconnectDelay * 2, maxReconnectDelay);	} else {	throw err;	}	}	}	
base 

if (failover) {	this.ldapURI = getUri();	env.put(Context.PROVIDER_URL, this.ldapURI.toString());	Thread.sleep(curReconnectDelay);	curReconnectDelay = Math.min(curReconnectDelay * 2, maxReconnectDelay);	} else {	throw err;	}	}	}	
filter 

if (failover) {	this.ldapURI = getUri();	env.put(Context.PROVIDER_URL, this.ldapURI.toString());	Thread.sleep(curReconnectDelay);	curReconnectDelay = Math.min(curReconnectDelay * 2, maxReconnectDelay);	} else {	throw err;	}	}	}	
scope 

} else {	throw err;	}	}	}	NamingEnumeration<SearchResult> results = context.search(base, searchFilter, searchControls);	while (results.hasMore()) {	addConnector(results.next());	}	if (searchEventListener) {	
registering persistent search listener 

public void stop() throws Exception {	
stopping context 

protected synchronized void addConnector(SearchResult result) throws Exception {	String uuid = toUUID(result);	if (uuidMap.containsKey(uuid)) {	
connector already regsitered for uuid 

protected synchronized void addConnector(SearchResult result) throws Exception {	String uuid = toUUID(result);	if (uuidMap.containsKey(uuid)) {	return;	}	URI connectorURI = toURI(result);	if (connectorMap.containsKey(connectorURI)) {	int referenceCount = referenceMap.get(connectorURI) + 1;	
connector reference added for uri uuid total reference s 

connector.setExcludedDestinations(getExcludedDestinations());	connector.setDynamicallyIncludedDestinations(getDynamicallyIncludedDestinations());	connector.setDuplex(isDuplex());	connector.setLocalUri(getBrokerService().getVmConnectorURI());	connector.setBrokerName(getBrokerService().getBrokerName());	connector.setDurableDestinations(getBrokerService().getBroker().getDurableDestinations());	connectorMap.put(connectorURI, connector);	referenceMap.put(connectorURI, 1);	uuidMap.put(uuid, connectorURI);	connector.start();	
connector added with uri 

protected synchronized void removeConnector(SearchResult result) throws Exception {	String uuid = toUUID(result);	if (!uuidMap.containsKey(uuid)) {	
connector not registered for uuid 

protected synchronized void removeConnector(SearchResult result) throws Exception {	String uuid = toUUID(result);	if (!uuidMap.containsKey(uuid)) {	return;	}	URI connectorURI = uuidMap.get(uuid);	if (!connectorMap.containsKey(connectorURI)) {	
connector not registered for uri 

if (!uuidMap.containsKey(uuid)) {	return;	}	URI connectorURI = uuidMap.get(uuid);	if (!connectorMap.containsKey(connectorURI)) {	return;	}	int referenceCount = referenceMap.get(connectorURI) - 1;	referenceMap.put(connectorURI, referenceCount);	uuidMap.remove(uuid);	
connector referenced removed for uri uuid remaining reference s 

return;	}	int referenceCount = referenceMap.get(connectorURI) - 1;	referenceMap.put(connectorURI, referenceCount);	uuidMap.remove(uuid);	if (referenceCount > 0) {	return;	}	NetworkConnector connector = connectorMap.remove(connectorURI);	connector.stop();	
connector removed with uri 

protected String toUUID(SearchResult result) {	String uuid = result.getNameInNamespace();	
retrieved uuid from searchresult 

public void objectAdded(NamingEvent event) {	
entry added 

public void objectAdded(NamingEvent event) {	try {	addConnector((SearchResult) event.getNewBinding());	} catch (Exception err) {	
err caught unexpected exception 

public void objectRemoved(NamingEvent event) {	
entry removed 

public void objectRemoved(NamingEvent event) {	try {	removeConnector((SearchResult) event.getOldBinding());	} catch (Exception err) {	
err caught unexpected exception 

public void objectRenamed(NamingEvent event) {	
entry renamed 

public void objectRenamed(NamingEvent event) {	String uuidOld = event.getOldBinding().getName();	String uuidNew = event.getNewBinding().getName();	URI connectorURI = uuidMap.remove(uuidOld);	uuidMap.put(uuidNew, connectorURI);	
connector reference renamed for uri old uuid new uuid 

public void objectChanged(NamingEvent event) {	
entry changed 

public void objectChanged(NamingEvent event) {	try {	SearchResult result = (SearchResult) event.getNewBinding();	removeConnector(result);	addConnector(result);	} catch (Exception err) {	
err caught unexpected exception 

public void namingExceptionThrown(NamingExceptionEvent event) {	
err caught unexpected exception 

========================= activemq sample_4232 =========================

if (setter == null) {	return false;	}	if (value == null || value.getClass() == setter.getParameterTypes()[0]) {	setter.invoke(target, value);	} else {	setter.invoke(target, convert(value, setter.getParameterTypes()[0]));	}	return true;	} catch (Exception e) {	
could not set property s on s 

field.setAccessible(true);	Object o = field.get(target);	if (o != null && o.getClass().isArray()) {	try {	o = Arrays.asList((Object[])o);	} catch (Exception e) {	}	}	map.put(field.getName(), o);	} catch (Exception e) {	
error getting field on class this exception is ignored 

========================= activemq sample_157 =========================

protected boolean matchesForwardingFilter(Message message, MessageEvaluationContext mec) {	if (contains(message.getBrokerPath(), networkBrokerId)) {	if (LOG.isTraceEnabled()) {	
message all ready routed once through target broker path ignoring 

protected boolean matchesForwardingFilter(Message message, MessageEvaluationContext mec) {	if (contains(message.getBrokerPath(), networkBrokerId)) {	if (LOG.isTraceEnabled()) {	}	return false;	}	int hops = message.getBrokerPath() == null ? 0 : message.getBrokerPath().length;	if (messageTTL > -1 && hops >= messageTTL) {	if (LOG.isTraceEnabled()) {	
message restricted to network hops ignoring 

}	int hops = message.getBrokerPath() == null ? 0 : message.getBrokerPath().length;	if (messageTTL > -1 && hops >= messageTTL) {	if (LOG.isTraceEnabled()) {	}	return false;	}	if (message.isAdvisory()) {	if (consumerInfo != null && consumerInfo.isNetworkSubscription() && isAdvisoryInterpretedByNetworkBridge(message)) {	if (LOG.isTraceEnabled()) {	
not propagating advisory to network sub message 

if (message.isAdvisory()) {	if (consumerInfo != null && consumerInfo.isNetworkSubscription() && isAdvisoryInterpretedByNetworkBridge(message)) {	if (LOG.isTraceEnabled()) {	}	return false;	} else if ( message.getDataStructure() != null && message.getDataStructure().getDataStructureType() == CommandTypes.CONSUMER_INFO) {	ConsumerInfo info = (ConsumerInfo)message.getDataStructure();	hops = info.getBrokerPath() == null ? 0 : info.getBrokerPath().length;	if (consumerTTL > -1 && hops >= consumerTTL) {	if (LOG.isTraceEnabled()) {	
consumerinfo advisory restricted to network hops ignoring 

return false;	} else if ( message.getDataStructure() != null && message.getDataStructure().getDataStructureType() == CommandTypes.CONSUMER_INFO) {	ConsumerInfo info = (ConsumerInfo)message.getDataStructure();	hops = info.getBrokerPath() == null ? 0 : info.getBrokerPath().length;	if (consumerTTL > -1 && hops >= consumerTTL) {	if (LOG.isTraceEnabled()) {	}	return false;	}	if (contains(info.getBrokerPath(), networkBrokerId)) {	
consumerinfo advisory all ready routed once through target broker path ignoring 

========================= activemq sample_638 =========================

}	StubSSLSocket socketStub = new StubSSLSocket(null);	StubSslTransport transport = null;	try {	transport = new StubSslTransport(null, socketStub);	} catch (Exception e) {	fail("Unable to create StubSslTransport: " + e.getMessage());	}	if (verbose) {	LOG.info("");	
iteration 

}	StubSSLSocket socketStub = new StubSSLSocket(null);	StubSslTransport transport = null;	try {	transport = new StubSslTransport(null, socketStub);	} catch (Exception e) {	fail("Unable to create StubSslTransport: " + e.getMessage());	}	if (verbose) {	LOG.info("");	
map settings 

for (int x = 0; x < optionSettings.length; x++) {	LOG.info("optionSetting[" + x + "] = " + optionSettings[x]);	}	}	factory.compositeConfigure(transport, new OpenWireFormat(), options);	try {	transport.start();	} catch (Exception e) {	}	if (socketStub.getWantClientAuthStatus() != optionSettings[2]) {	
sheiite 

========================= activemq sample_2523 =========================

protected org.apache.activemq.jms.pool.ConnectionPool createConnectionPool(Connection connection) {	return new ConnectionPool(connection) {	protected Connection wrap(final Connection connection) {	((ActiveMQConnection)connection).addTransportListener(new TransportListener() {	public void onCommand(Object command) {	}	public void onException(IOException error) {	synchronized (this) {	setHasExpired(true);	if (!stopped.get()) {	
expiring connection on ioexception 

protected org.apache.activemq.jms.pool.ConnectionPool createConnectionPool(Connection connection) {	return new ConnectionPool(connection) {	protected Connection wrap(final Connection connection) {	((ActiveMQConnection)connection).addTransportListener(new TransportListener() {	public void onCommand(Object command) {	}	public void onException(IOException error) {	synchronized (this) {	setHasExpired(true);	if (!stopped.get()) {	
expiring connection on ioexception 

========================= activemq sample_792 =========================

public void testIndexDirExists() throws Exception {	produceMessages();	
index dir is configured as 

public void testIndexDirExists() throws Exception {	produceMessages();	assertTrue(kahaDataDir.exists());	assertTrue(kahaIndexDir.exists());	String destName = nameFromDestinationFilter(queue);	String[] index = new File(kahaIndexDir, destName).list(new FilenameFilter() {	public boolean accept(File dir, String name) {	
testing index filename 

assertTrue(kahaDataDir.exists());	assertTrue(kahaIndexDir.exists());	String destName = nameFromDestinationFilter(queue);	String[] index = new File(kahaIndexDir, destName).list(new FilenameFilter() {	public boolean accept(File dir, String name) {	return name.endsWith("data") || name.endsWith("redo");	}	});	String[] journal = new File(kahaDataDir, destName).list(new FilenameFilter() {	public boolean accept(File dir, String name) {	
testing log filename 

========================= activemq sample_3762 =========================

private void initConnection() throws JMSException {	if (connection == null) {	
initializing connection 

public void testTopicIsDurableSmokeTest() throws Exception {	initClient();	MessageConsumer consumer = createMessageConsumer();	
consuming message 

public void testTopicIsDurableSmokeTest() throws Exception {	initClient();	MessageConsumer consumer = createMessageConsumer();	assertNull(consumer.receive(1));	shutdownClient();	consumer.close();	sendMessages();	shutdownClient();	initClient();	consumer = createMessageConsumer();	
consuming message 

private MessageConsumer createMessageConsumer() throws JMSException {	
creating durable subscriber 

private void initClient() throws JMSException {	
initializing client 

private void shutdownClient() throws JMSException {	
closing session and connection 

private void sendMessages() throws JMSException {	initConnection();	initSession();	
creating producer 

private void initSession() throws JMSException {	
initializing session 

private void sendMessage( String msgText, String propertyValue) throws JMSException {	
creating message 

private void sendMessage( String msgText, String propertyValue) throws JMSException {	TextMessage messageToSelect = session.createTextMessage(msgText);	messageToSelect.setStringProperty("name", propertyValue);	
sending message 

========================= activemq sample_2870 =========================

ActiveMQConnectionFactory brokerAFactory = new ActiveMQConnectionFactory(brokerA.getTransportConnectorByScheme("tcp").getPublishableConnectString() + "?jms.watchTopicAdvisories=false");	ActiveMQConnectionFactory brokerBFactory = new ActiveMQConnectionFactory(brokerB.getTransportConnectorByScheme("tcp").getPublishableConnectString() + "?jms.watchTopicAdvisories=false");	final int numDests = 400;	final int numMessagesPerDest = 50;	final int numConsumersPerDest = 5;	populate(brokerAFactory, 0, numDests/2, numMessagesPerDest);	populate(brokerBFactory, numDests/2, numDests, numMessagesPerDest);	List<Connection> connections = new LinkedList<>();	connections.add(demand(brokerBFactory, 0, numDests/2, numConsumersPerDest));	connections.add(demand(brokerAFactory, numDests/2, numDests, numConsumersPerDest));	
allow duplex bridge to connect 

final int numMessagesPerDest = 50;	final int numConsumersPerDest = 5;	populate(brokerAFactory, 0, numDests/2, numMessagesPerDest);	populate(brokerBFactory, numDests/2, numDests, numMessagesPerDest);	List<Connection> connections = new LinkedList<>();	connections.add(demand(brokerBFactory, 0, numDests/2, numConsumersPerDest));	connections.add(demand(brokerAFactory, numDests/2, numDests, numConsumersPerDest));	brokerB.startTransportConnector(brokerB.addConnector(networkConnectorUrlString + "?transport.socketBufferSize=1024"));	if (!Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
received 

========================= activemq sample_3627 =========================

public void testRestartAfterQueueDelete() throws Exception {	assertTrue("Broker doesn't have an Admin View.", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return (broker.getAdminView()) != null;	}	}));	
adding initial destination 

public void testRestartAfterQueueDelete() throws Exception {	assertTrue("Broker doesn't have an Admin View.", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return (broker.getAdminView()) != null;	}	}));	broker.getAdminView().addQueue(destinationName);	assertNotNull(broker.getDestination(new ActiveMQQueue(destinationName)));	
removing initial destination 

public void testRestartAfterQueueDelete() throws Exception {	assertTrue("Broker doesn't have an Admin View.", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return (broker.getAdminView()) != null;	}	}));	broker.getAdminView().addQueue(destinationName);	assertNotNull(broker.getDestination(new ActiveMQQueue(destinationName)));	broker.getAdminView().removeQueue(destinationName);	
adding back destination 

========================= activemq sample_2935 =========================

}	}	}	if (systemUsage.getTempUsage().waitForSpace(maxWaitTime)) {	ByteSequence bs = getByteSequence(node.getMessage());	getDiskList().addLast(node.getMessageId().toString(), bs);	return true;	}	return false;	} catch (Exception e) {	
caught an exception adding a message first to filependingmessagecursor 

flushToDisk();	}	}	}	systemUsage.getTempUsage().waitForSpace();	node.decrementReferenceCount();	ByteSequence bs = getByteSequence(node.getMessage());	Object locator = getDiskList().addFirst(node.getMessageId().toString(), bs);	node.getMessageId().setPlistLocator(locator);	} catch (Exception e) {	
caught an exception adding a message first to filependingmessagecursor 

LOG.trace("{}, flushToDisk() mem list size: {} {}", new Object[] { name, memoryList.size(), (systemUsage != null ? systemUsage.getMemoryUsage() : "") });	}	for (Iterator<MessageReference> iterator = memoryList.iterator(); iterator.hasNext();) {	MessageReference node = iterator.next();	node.decrementReferenceCount();	ByteSequence bs;	try {	bs = getByteSequence(node.getMessage());	getDiskList().addLast(node.getMessageId().toString(), bs);	} catch (IOException e) {	
failed to write to disk list 

public PList getDiskList() {	if (diskList == null) {	try {	diskList = store.getPList(name);	} catch (Exception e) {	
caught an io exception getting the disklist 

private void discardExpiredMessage(MessageReference reference) {	
discarding expired message 

public MessageReference next() {	try {	PListEntry entry = iterator.next();	Message message = getMessage(entry.getByteSequence());	message.getMessageId().setPlistLocator(entry.getLocator());	return message;	} catch (IOException e) {	
i o error 

========================= activemq sample_4048 =========================

for (Iterator<MessageConsumer> it = consumers.values().iterator(); it.hasNext();) {	MessageConsumer consumer = it.next();	it.remove();	try {	consumer.setMessageListener(null);	if (consumer instanceof MessageAvailableConsumer) {	((MessageAvailableConsumer)consumer).setAvailableListener(null);	}	consumer.close();	} catch (JMSException e) {	
caught exception closing consumer 

public synchronized void close() {	try {	if (consumers != null) {	closeConsumers();	}	if (connection != null) {	connection.close();	}	} catch (Exception e) {	
caught exception closing consumer 

public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {	int size = in.readInt();	if (size >= 0) {	consumers = new HashMap<Destination, MessageConsumer>();	for (int i = 0; i < size; i++) {	String destinationName = in.readObject().toString();	try {	Destination destination = destinationName.startsWith("topic: consumers.put(destination, getConsumer(destination, null, true));	} catch (JMSException e) {	
caought exception 

public void send(Destination destination, Message message) throws JMSException {	getProducer().send(destination, message);	if (LOG.isDebugEnabled()) {	
sent to destination message 

public void send(Destination destination, Message message, boolean persistent, int priority, long timeToLive) throws JMSException {	int deliveryMode = persistent ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT;	getProducer().send(destination, message, deliveryMode, priority, timeToLive);	if (LOG.isDebugEnabled()) {	
sent to destination message 

protected static synchronized void initConnectionFactory(ServletContext servletContext) {	if (factory == null) {	factory = (ActiveMQConnectionFactory)servletContext.getAttribute(CONNECTION_FACTORY_ATTRIBUTE);	}	if (factory == null) {	String brokerURL = getInitParameter(servletContext, BROKER_URL_INIT_PARAM);	if (brokerURL == null) {	
couldn t find param trying to find a broker embedded in a local vm 

}	if (factory == null) {	String brokerURL = getInitParameter(servletContext, BROKER_URL_INIT_PARAM);	if (brokerURL == null) {	BrokerService broker = BrokerRegistry.getInstance().findFirst();	if (broker == null) {	throw new IllegalStateException("missing brokerURL (specified via " + BROKER_URL_INIT_PARAM + " init-Param) or embedded broker");	} else {	brokerURL = "vm: }	}	
using broker url 

========================= activemq sample_1026 =========================

public void testCreateSslConnection() throws Exception {	String sslUri = "ssl: broker = createSslBroker(sslUri);	assertNotNull(broker);	ActiveMQSslConnectionFactory cf = getFactory(sslUri);	cf.setTrustStore("server.keystore");	cf.setTrustStorePassword("password");	connection = (ActiveMQConnection)cf.createConnection();	
created client connection 

public void testFailoverSslConnection() throws Exception {	String sslUri = "ssl: broker = createSslBroker(sslUri);	assertNotNull(broker);	ActiveMQSslConnectionFactory cf = getFactory("failover:(" + sslUri + ")?maxReconnectAttempts=4");	cf.setTrustStore("server.keystore");	cf.setTrustStorePassword("password");	connection = (ActiveMQConnection)cf.createConnection();	
created client connection 

public void testFailoverSslConnectionWithKeyAndTrustManagers() throws Exception {	String sslUri = "ssl: broker = createSslBroker(sslUri);	assertNotNull(broker);	ActiveMQSslConnectionFactory cf = getFactory("failover:(" + sslUri + ")?maxReconnectAttempts=4");	cf.setKeyAndTrustManagers(getKeyManager(), getTrustManager(), new SecureRandom());	connection = (ActiveMQConnection)cf.createConnection();	
created client connection 

public void testNegativeCreateSslConnectionWithWrongPassword() throws Exception {	String sslUri = "ssl: broker = createSslBroker(sslUri);	assertNotNull(broker);	ActiveMQSslConnectionFactory cf = getFactory(sslUri);	cf.setTrustStore("server.keystore");	cf.setTrustStorePassword("wrongPassword");	try {	connection = (ActiveMQConnection)cf.createConnection();	}	catch (javax.jms.JMSException ignore) {	
expected java io exception 

public void testNegativeCreateSslConnectionWithWrongCert() throws Exception {	String sslUri = "ssl: broker = createSslBroker(sslUri);	assertNotNull(broker);	ActiveMQSslConnectionFactory cf = getFactory(sslUri);	cf.setTrustStore("dummy.keystore");	cf.setTrustStorePassword("password");	try {	connection = (ActiveMQConnection)cf.createConnection();	}	catch (javax.jms.JMSException ignore) {	
expected sslhandshakeexception 

========================= activemq sample_3735 =========================

session.createProducer(dlq);	for (int i = 0; i < MSG_COUNT; ++i) {	producer.send(session.createMessage(), DeliveryMode.PERSISTENT, Message.DEFAULT_PRIORITY, 1000);	}	final QueueViewMBean queueView = getProxyToQueue(dlq.getQueueName());	assertTrue("Message should be DLQ'd", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getQueueSize() == MSG_COUNT;	}	}));	
dlq has captured all expired messages 

assertTrue("Message should be DLQ'd", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getQueueSize() == MSG_COUNT;	}	}));	Deque<String> browsed = new LinkedList<String>();	CompositeData[] elements = queueView.browse();	assertEquals(MSG_COUNT, elements.length);	for (CompositeData element : elements) {	String messageID = (String) element.get("JMSMessageID");	
messageid 

String messageID = (String) element.get("JMSMessageID");	browsed.add(messageID);	}	String removedMsgId = browsed.removeFirst();	assertTrue(queueView.removeMessage(removedMsgId));	assertEquals(MSG_COUNT - 1, queueView.getQueueSize());	elements = queueView.browse();	assertEquals(MSG_COUNT - 1, elements.length);	for (CompositeData element : elements) {	String messageID = (String) element.get("JMSMessageID");	
messageid 

========================= activemq sample_2827 =========================

public void testPrefetchZeroConsumerThroughRestart() throws Exception {	broker = createBroker(true);	final CountDownLatch pullDone = new CountDownLatch(1);	broker.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	public Response messagePull(ConnectionContext context, final MessagePull pull) throws Exception {	context.setDontSendReponse(true);	pullDone.countDown();	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
stopping broker on pull 

connection.start();	final Session consumerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	final Queue destination = consumerSession.createQueue(QUEUE_NAME + "?consumer.prefetchSize=" + prefetch);	final MessageConsumer consumer = consumerSession.createConsumer(destination);	produceMessage(consumerSession, destination, 1);	final CountDownLatch receiveDone = new CountDownLatch(1);	final Vector<Message> received = new Vector<Message>();	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	
receive one 

final CountDownLatch receiveDone = new CountDownLatch(1);	final Vector<Message> received = new Vector<Message>();	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	Message msg = consumer.receive(30000);	if (msg != null) {	received.add(msg);	}	receiveDone.countDown();	
done receive 

========================= activemq sample_2574 =========================

ActiveMQMessageConsumer replyConsumer = (ActiveMQMessageConsumer) replySession.createConsumer(requestReplyDest);	javax.jms.Message msg = replyConsumer.receive(10000);	assertNotNull("request message not null: " + i, msg);	MessageProducer replyProducer = replySession.createProducer(msg.getJMSReplyTo());	replyProducer.send(session.createTextMessage("reply-" + i));	replyConnection.close();	javax.jms.Message reply = consumer.receive(10000);	assertNotNull("reply message : " + i + ", to: " + tempDest + ", by consumer:" + consumer.getConsumerId(), reply);	consumer.close();	tempDest.delete();	
message processed 

========================= activemq sample_3559 =========================

public boolean isSendToDeadLetterQueue(Message message) {	boolean result = false;	
discarding message sent to dlq dest 

========================= activemq sample_4064 =========================

MessageConsumer consumer = session.createConsumer(destination);	final MyMessageListener listener = new MyMessageListener();	connection.setExceptionListener((ExceptionListener) listener);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	String text = "Hello world! From: " + Thread.currentThread().getName() + " : " + this.hashCode();	TextMessage message;	for (int i=0; i<45; i++) {	message = session.createTextMessage(text);	producer.send(message,1,1,100);	
sent message with expiry msec 

producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	String text = "Hello world! From: " + Thread.currentThread().getName() + " : " + this.hashCode();	TextMessage message;	for (int i=0; i<45; i++) {	message = session.createTextMessage(text);	producer.send(message,1,1,100);	}	for (int i=0; i<60; i++) {	message = session.createTextMessage(text);	producer.send(message,1,1,60000);	
sent message with expiry sec 

producer.send(message,1,1,60000);	}	consumer.setMessageListener(listener);	sleep(1000);	connection.start();	assertTrue("Should receive all expected messages, counter at " + listener.getCounter(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return listener.getCounter() == 60;	}	}));	
received all expected messages with counter at 

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue("TEST.FOO");	MessageConsumer consumer = session.createConsumer(destination);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	String text = "Hello world! From: " + Thread.currentThread().getName() + " : " + this.hashCode();	TextMessage message;	for (int i=0; i<45; i++) {	message = session.createTextMessage(text);	producer.send(message,1,1,10);	
sent message with expiry msec 

producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	String text = "Hello world! From: " + Thread.currentThread().getName() + " : " + this.hashCode();	TextMessage message;	for (int i=0; i<45; i++) {	message = session.createTextMessage(text);	producer.send(message,1,1,10);	}	for (int i=0; i<60; i++) {	message = session.createTextMessage(text);	producer.send(message,1,1,30000);	
sent message with expiry sec 

producer.send(message,1,1,10);	}	for (int i=0; i<60; i++) {	message = session.createTextMessage(text);	producer.send(message,1,1,30000);	}	sleep(200);	int counter = 1;	for (; counter <= 60; ++counter) {	assertNotNull(consumer.receive(2000));	
counter at 

}	for (int i=0; i<60; i++) {	message = session.createTextMessage(text);	producer.send(message,1,1,30000);	}	sleep(200);	int counter = 1;	for (; counter <= 60; ++counter) {	assertNotNull(consumer.receive(2000));	}	
received all expected messages with counter at 

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue("TEST.FOO");	MessageConsumer consumer = session.createConsumer(destination);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	String text = "Hello world! From: " + Thread.currentThread().getName() + " : " + this.hashCode();	TextMessage message;	for (int i=0; i<56; i++) {	message = session.createTextMessage(text);	producer.send(message,1,1,30000);	
sent message with expiry sec 

producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	String text = "Hello world! From: " + Thread.currentThread().getName() + " : " + this.hashCode();	TextMessage message;	for (int i=0; i<56; i++) {	message = session.createTextMessage(text);	producer.send(message,1,1,30000);	}	for (int i=0; i<44; i++) {	message = session.createTextMessage(text);	producer.send(message,1,1,10);	
sent message with expiry msec 

message = session.createTextMessage(text);	producer.send(message,1,1,30000);	}	for (int i=0; i<44; i++) {	message = session.createTextMessage(text);	producer.send(message,1,1,10);	}	for (int i=0; i<4; i++) {	message = session.createTextMessage(text);	producer.send(message,1,1,30000);	
sent message with expiry sec 

producer.send(message,1,1,10);	}	for (int i=0; i<4; i++) {	message = session.createTextMessage(text);	producer.send(message,1,1,30000);	}	sleep(200);	int counter = 1;	for (; counter <= 60; ++counter) {	assertNotNull(consumer.receive(2000));	
counter at 

}	for (int i=0; i<4; i++) {	message = session.createTextMessage(text);	producer.send(message,1,1,30000);	}	sleep(200);	int counter = 1;	for (; counter <= 60; ++counter) {	assertNotNull(consumer.receive(2000));	}	
received all expected messages with counter at 

public void onMessage(final Message message) {	try {	
got message 

public void onMessage(final Message message) {	try {	
counter at 

public synchronized void onException(JMSException ex) {	
jms exception occured shutting down client 

========================= activemq sample_2919 =========================

private InterruptedIOException dealWithInterrupt(InterruptedException e) {	if (LOG.isDebugEnabled()) {	
operation interrupted 

========================= activemq sample_64 =========================

public void testRemvoeJob() throws Exception {	JobSchedulerViewMBean view = getJobSchedulerMBean();	assertNotNull(view);	assertTrue(view.getAllJobs().isEmpty());	scheduleMessage(60000, -1, -1);	assertFalse(view.getAllJobs().isEmpty());	TabularData jobs = view.getAllJobs();	assertEquals(1, jobs.size());	for (Object key : jobs.keySet()) {	String jobId = ((List<?>)key).get(0).toString();	
attempting to remove job 

public void testGetNextScheduledJob() throws Exception {	JobSchedulerViewMBean view = getJobSchedulerMBean();	assertNotNull(view);	assertTrue(view.getAllJobs().isEmpty());	scheduleMessage(60000, -1, -1);	assertFalse(view.getAllJobs().isEmpty());	long before = System.currentTimeMillis() + 57 * 1000;	long toLate = System.currentTimeMillis() + 63 * 1000;	String next = view.getNextScheduleTime();	long nextTime = JobSupport.getDataTime(next);	
next scheduled time should be after 

assertTrue(view.getAllJobs().isEmpty());	scheduleMessage(10000, 1000, 10);	assertFalse(view.getAllJobs().isEmpty());	TabularData jobs = view.getAllJobs();	assertEquals(1, jobs.size());	String jobId = null;	for (Object key : jobs.keySet()) {	jobId = ((List<?>)key).get(0).toString();	}	final String fixedJobId = jobId;	
attempting to get execution count for job 

========================= activemq sample_2333 =========================

if (!pendingDelivery.remotelySettled()) {	continue;	}	DeliveryState state = pendingDelivery.getRemoteState();	AmqpTransactionId txId = (AmqpTransactionId) pendingDelivery.getContext();	AsyncResult pendingRequest = pendingRequests.get(txId);	if (pendingRequest == null) {	throw new IllegalStateException("Pending tx operation with no pending request");	}	if (state instanceof Declared) {	
new tx started 

AmqpTransactionId txId = (AmqpTransactionId) pendingDelivery.getContext();	AsyncResult pendingRequest = pendingRequests.get(txId);	if (pendingRequest == null) {	throw new IllegalStateException("Pending tx operation with no pending request");	}	if (state instanceof Declared) {	Declared declared = (Declared) state;	txId.setRemoteTxId(declared.getTxnId());	pendingRequest.onSuccess();	} else if (state instanceof Rejected) {	
last tx request failed 

Rejected rejected = (Rejected) state;	Exception cause = AmqpSupport.convertToException(rejected.getError());	JMSException failureCause = null;	if (txId.isCommit()) {	failureCause = new TransactionRolledBackException(cause.getMessage());	} else {	failureCause = new JMSException(cause.getMessage());	}	pendingRequest.onFailure(failureCause);	} else {	
last tx request succeeded 

Exception txnError = AmqpSupport.convertToException(getEndpoint().getRemoteCondition());	for (AsyncResult pendingRequest : pendingRequests.values()) {	pendingRequest.onFailure(txnError);	}	pendingDeliveries.clear();	pendingRequests.clear();	if (getEndpoint() != null) {	getEndpoint().close();	getEndpoint().free();	}	
transaction coordinator link was remotely closed 

========================= activemq sample_1661 =========================

return (id + 1) * batchSize;	}	public void run() {	try {	Session connectionSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	int batchSize = getBatchSize();	MessageConsumer messageConsumer = connectionSession.createConsumer(destWithPrefetch(destination));	Message message;	AtomicLong consumed = consumedCounters.get(id);	AtomicLong batches = batchCounters.get(id);	
consumer batchsize totalconsumed consumed 

try {	Session connectionSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	int batchSize = getBatchSize();	MessageConsumer messageConsumer = connectionSession.createConsumer(destWithPrefetch(destination));	Message message;	AtomicLong consumed = consumedCounters.get(id);	AtomicLong batches = batchCounters.get(id);	while (totalConsumed.get() < numMessages) {	message = messageConsumer.receive(10000);	if (message == null) {	
consumer batchsize null message totalconsumed consumed 

}	}	});	TimeUnit.MILLISECONDS.sleep(200);	}	TimeUnit.SECONDS.sleep(1);	produceMessages(numMessages);	executorService.shutdown();	assertTrue("threads done on time", executorService.awaitTermination(10, TimeUnit.MINUTES));	assertEquals("All consumed", numMessages, totalConsumed.intValue());	
distribution 

}	}	});	TimeUnit.MILLISECONDS.sleep(200);	}	TimeUnit.SECONDS.sleep(1);	produceMessages(numMessages);	executorService.shutdown();	assertTrue("threads done on time", executorService.awaitTermination(10, TimeUnit.MINUTES));	assertEquals("All consumed", numMessages, totalConsumed.intValue());	
batches 

========================= activemq sample_3719 =========================

private void doStartBroker(boolean delete) throws Exception {	broker = new BrokerService();	broker.setDeleteAllMessagesOnStartup(delete);	broker.setPersistent(true);	broker.setUseJmx(true);	broker.setDataDirectory(KAHADB_DIRECTORY);	broker.addConnector("tcp: configurePersistence(broker);	connectionUri = "vm: cf = new ActiveMQConnectionFactory(connectionUri);	broker.start();	
starting broker 

private void whackIndex(File dataDir) {	File indexToDelete = new File(dataDir, "db.data");	
whacking index 

int offset = 0;	int end = atEnd ? Integer.MAX_VALUE : 3;	for (int i = 0; i < end; i++) {	int found = bs.indexOf(header, pos);	if (found == -1) {	break;	}	offset = found;	pos++;	}	
whacking batch record in file at offset with fill 

========================= activemq sample_1724 =========================

throw new ResourceException("Endpoint does not implement the onMessage method.");	}	connectWork = new Work() {	long currentReconnectDelay = INITIAL_RECONNECT_DELAY;	public void release() {	}	public void run() {	currentReconnectDelay = INITIAL_RECONNECT_DELAY;	MessageActivationSpec activationSpec = endpointActivationKey.getActivationSpec();	if (LOG.isInfoEnabled()) {	
establishing connection to broker 

currentReconnectDelay = INITIAL_RECONNECT_DELAY;	MessageActivationSpec activationSpec = endpointActivationKey.getActivationSpec();	if (LOG.isInfoEnabled()) {	}	while (connecting.get() && running) {	try {	connection = adapter.makeConnection(activationSpec);	connection.setExceptionListener(new ExceptionListener() {	public void onException(JMSException error) {	if (!serverSessionPool.isClosing()) {	
connection to broker failed 

connection.setExceptionListener(new ExceptionListener() {	public void onException(JMSException error) {	if (!serverSessionPool.isClosing()) {	if (connecting.compareAndSet(false, true)) {	synchronized (connectWork) {	disconnect();	serverSessionPool.closeSessions();	connect();	}	} else {	
connection attempt already in progress ignoring connection exception 

}	});	connection.start();	if (activationSpec.isDurableSubscription()) {	consumer = (ActiveMQConnectionConsumer) connection.createDurableConnectionConsumer( (Topic) dest, activationSpec.getSubscriptionName(), emptyToNull(activationSpec.getMessageSelector()), serverSessionPool, connection.getPrefetchPolicy().getDurableTopicPrefetch(), activationSpec.getNoLocalBooleanValue());	} else {	consumer = (ActiveMQConnectionConsumer) connection.createConnectionConsumer( dest, emptyToNull(activationSpec.getMessageSelector()), serverSessionPool, getPrefetch(activationSpec, connection, dest), activationSpec.getNoLocalBooleanValue());	}	if (connecting.compareAndSet(true, false)) {	if (LOG.isInfoEnabled()) {	
successfully established connection to broker 

connection.start();	if (activationSpec.isDurableSubscription()) {	consumer = (ActiveMQConnectionConsumer) connection.createDurableConnectionConsumer( (Topic) dest, activationSpec.getSubscriptionName(), emptyToNull(activationSpec.getMessageSelector()), serverSessionPool, connection.getPrefetchPolicy().getDurableTopicPrefetch(), activationSpec.getNoLocalBooleanValue());	} else {	consumer = (ActiveMQConnectionConsumer) connection.createConnectionConsumer( dest, emptyToNull(activationSpec.getMessageSelector()), serverSessionPool, getPrefetch(activationSpec, connection, dest), activationSpec.getNoLocalBooleanValue());	}	if (connecting.compareAndSet(true, false)) {	if (LOG.isInfoEnabled()) {	}	} else {	
could not release connection lock 

consumer = (ActiveMQConnectionConsumer) connection.createDurableConnectionConsumer( (Topic) dest, activationSpec.getSubscriptionName(), emptyToNull(activationSpec.getMessageSelector()), serverSessionPool, connection.getPrefetchPolicy().getDurableTopicPrefetch(), activationSpec.getNoLocalBooleanValue());	} else {	consumer = (ActiveMQConnectionConsumer) connection.createConnectionConsumer( dest, emptyToNull(activationSpec.getMessageSelector()), serverSessionPool, getPrefetch(activationSpec, connection, dest), activationSpec.getNoLocalBooleanValue());	}	if (connecting.compareAndSet(true, false)) {	if (LOG.isInfoEnabled()) {	}	} else {	}	if (consumer.getConsumerInfo().getCurrentPrefetchSize() == 0) {	
endpoint will not receive any messages due to broker zero prefetch configuration for 

}	if (connecting.compareAndSet(true, false)) {	if (LOG.isInfoEnabled()) {	}	} else {	}	if (consumer.getConsumerInfo().getCurrentPrefetchSize() == 0) {	}	} catch (JMSException error) {	if (LOG.isDebugEnabled()) {	
failed to connect 

if (destination.isTopic()) {	return connection.getPrefetchPolicy().getTopicPrefetch();	} else if (destination.isQueue()) {	return connection.getPrefetchPolicy().getQueuePrefetch();	} else {	return activationSpec.getMaxMessagesPerSessionsIntValue() * activationSpec.getMaxSessionsIntValue();	}	}	private void pause(JMSException error) {	if (currentReconnectDelay == MAX_RECONNECT_DELAY) {	
failed to connect to broker 

if (destination.isTopic()) {	return connection.getPrefetchPolicy().getTopicPrefetch();	} else if (destination.isQueue()) {	return connection.getPrefetchPolicy().getQueuePrefetch();	} else {	return activationSpec.getMaxMessagesPerSessionsIntValue() * activationSpec.getMaxSessionsIntValue();	}	}	private void pause(JMSException error) {	if (currentReconnectDelay == MAX_RECONNECT_DELAY) {	
endpoint will try to reconnect to the jms broker in seconds 

public static void safeClose(Connection c) {	try {	if (c != null) {	
closing connection to broker 

public static void safeClose(Connection c) {	try {	if (c != null) {	c.close();	}	} catch (JMSException e) {	
failed to close c 

public static void safeClose(ConnectionConsumer cc) {	try {	if (cc != null) {	
closing connectionconsumer 

public static void safeClose(ConnectionConsumer cc) {	try {	if (cc != null) {	cc.close();	}	} catch (JMSException e) {	
failed to close cc 

public void start() throws ResourceException {	synchronized (connectWork) {	if (running) return;	running = true;	if ( connecting.compareAndSet(false, true) ) {	
Starting 

public void start() throws ResourceException {	synchronized (connectWork) {	if (running) return;	running = true;	if ( connecting.compareAndSet(false, true) ) {	serverSessionPool = new ServerSessionPoolImpl(this, endpointActivationKey.getActivationSpec().getMaxSessionsIntValue());	connect();	} else {	
ignoring start command endpointworker is already trying to connect 

public void stop() throws InterruptedException {	synchronized (shutdownMutex) {	if (!running) return;	running = false;	
Stopping 

private void connect() {	synchronized ( connectWork ) {	if (!running) {	return;	}	try {	workManager.scheduleWork(connectWork, WorkManager.INDEFINITE, null, null);	} catch (WorkException e) {	running = false;	
work manager did not accept work 

========================= activemq sample_839 =========================

waitForConsumerToArrive(counter);	Connection connection = secondProducerConnectionFactory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	final int expectedMessagesReceived = 1000;	for (int i = 1; i <= expectedMessagesReceived; i++) {	Message message = session.createMessage();	producer.send(message);	if (i % 200 == 0) {	
sent message 

producer.send(message);	if (i % 200 == 0) {	}	}	for (int i = 1; i <= expectedMessagesReceived; i++) {	Message message = consumer.receive(2000);	if (message == null) {	fail("Didn't receive a message");	}	if (i % 200 == 0) {	
received message 

MessageConsumer consumer = createConsumer(consumerConnectionFactory);	AtomicInteger counter = createConsumerCounter(consumerConnectionFactory);	waitForConsumerToArrive(counter);	final int expectedMessagesReceived = 25;	int actualMessagesReceived = doSendMessage(expectedMessagesReceived, consumer, producerConnectionFactory);	assertEquals("Didn't receive the right amount of messages directly connected", expectedMessagesReceived, actualMessagesReceived);	assertNull("Had extra messages", consumer.receiveNoWait());	actualMessagesReceived = doSendMessage(expectedMessagesReceived, consumer, secondProducerConnectionFactory);	assertEquals("Didn't receive the right amount of messages via network", expectedMessagesReceived, actualMessagesReceived);	assertNull("Had extra messages", consumer.receiveNoWait());	
stopping broker one 

waitForConsumerToArrive(counter);	final int expectedMessagesReceived = 25;	int actualMessagesReceived = doSendMessage(expectedMessagesReceived, consumer, producerConnectionFactory);	assertEquals("Didn't receive the right amount of messages directly connected", expectedMessagesReceived, actualMessagesReceived);	assertNull("Had extra messages", consumer.receiveNoWait());	actualMessagesReceived = doSendMessage(expectedMessagesReceived, consumer, secondProducerConnectionFactory);	assertEquals("Didn't receive the right amount of messages via network", expectedMessagesReceived, actualMessagesReceived);	assertNull("Had extra messages", consumer.receiveNoWait());	stopBrokerOne();	TimeUnit.SECONDS.sleep(1);	
restarting broker 

========================= activemq sample_1118 =========================

public void doTestCacheExhaustion(int prefetch) throws Exception {	createDurableSub(topic, "my_sub_1");	publishMesssages(topic, 20);	org.apache.log4j.Logger log4jLogger = org.apache.log4j.Logger.getLogger(AbstractStoreCursor.class.getCanonicalName());	final AtomicBoolean failed = new AtomicBoolean(false);	Appender appender = new DefaultTestAppender() {	public void doAppend(LoggingEvent event) {	if (event.getLevel() == Level.WARN) {	
got warn event 

========================= activemq sample_3575 =========================

private void waitForConsumerRegistration(final BrokerService brokerService, final int min, final ActiveMQDestination destination) throws Exception {	assertTrue("Internal bridge consumers registered in time", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	Object[] bridges = brokerService.getNetworkConnectors().get(0).bridges.values().toArray();	if (bridges.length > 0) {	
bridges 

private void waitForConsumerRegistration(final BrokerService brokerService, final int min, final ActiveMQDestination destination) throws Exception {	assertTrue("Internal bridge consumers registered in time", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	Object[] bridges = brokerService.getNetworkConnectors().get(0).bridges.values().toArray();	if (bridges.length > 0) {	DemandForwardingBridgeSupport demandForwardingBridgeSupport = (DemandForwardingBridgeSupport) bridges[0];	ConcurrentMap<ConsumerId, DemandSubscription> forwardingBridges = demandForwardingBridgeSupport.getLocalSubscriptionMap();	
bridge localsubs 

private void waitForConsumerRegistration(final BrokerService brokerService, final int min, final ActiveMQDestination destination) throws Exception {	assertTrue("Internal bridge consumers registered in time", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	Object[] bridges = brokerService.getNetworkConnectors().get(0).bridges.values().toArray();	if (bridges.length > 0) {	DemandForwardingBridgeSupport demandForwardingBridgeSupport = (DemandForwardingBridgeSupport) bridges[0];	ConcurrentMap<ConsumerId, DemandSubscription> forwardingBridges = demandForwardingBridgeSupport.getLocalSubscriptionMap();	if (!forwardingBridges.isEmpty()) {	for (DemandSubscription demandSubscription : forwardingBridges.values()) {	if (demandSubscription.getLocalInfo().getDestination().equals(destination)) {	
demandsubscription size 

========================= activemq sample_2734 =========================

broker.setBrokerName(testName.getMethodName());	broker.setDataDirectoryFile(dataDirFile);	if (configurer != null) {	configurer.configure(broker);	}	broker.start();	}	protected void configurePersistenceAdapter(BrokerService brokerService) throws Exception {	}	public void setUp() throws Exception {	
starting test 

dataDirFile = new File("target/"+ testName.getMethodName());	numtoSend = DEFAULT_NUM_TO_SEND;	brokerStopPeriod = DEFAULT_BROKER_STOP_PERIOD;	sleepBetweenSend = SLEEP_BETWEEN_SEND_MS;	brokerURL = DEFAULT_BROKER_URL;	}	public void tearDown() throws Exception {	ExecutorService executor = Executors.newSingleThreadExecutor();	Future<Boolean> future = executor.submit(new TeardownTask(brokerLock, broker));	try {	
teardown started 

sleepBetweenSend = SLEEP_BETWEEN_SEND_MS;	brokerURL = DEFAULT_BROKER_URL;	}	public void tearDown() throws Exception {	ExecutorService executor = Executors.newSingleThreadExecutor();	Future<Boolean> future = executor.submit(new TeardownTask(brokerLock, broker));	try {	long start = System.currentTimeMillis();	Boolean result =  future.get(30, TimeUnit.SECONDS);	long finish = System.currentTimeMillis();	
result of teardown after ms 

}	public long getNextExpectedSeqNo() {	return nextExpectedSeqNum;	}	final int TRANSACITON_BATCH = 500;	boolean resumeOnNextOrPreviousIsOk = false;	public void onMessage(Message message) {	try {	final long seqNum = message.getLongProperty(SEQ_NUM_PROPERTY);	if ((seqNum % TRANSACITON_BATCH) == 0) {	
received 

public long getNextExpectedSeqNo() {	return nextExpectedSeqNum;	}	final int TRANSACITON_BATCH = 500;	boolean resumeOnNextOrPreviousIsOk = false;	public void onMessage(Message message) {	try {	final long seqNum = message.getLongProperty(SEQ_NUM_PROPERTY);	if ((seqNum % TRANSACITON_BATCH) == 0) {	if (transactional) {	
committing 

final long seqNum = message.getLongProperty(SEQ_NUM_PROPERTY);	if ((seqNum % TRANSACITON_BATCH) == 0) {	if (transactional) {	session.commit();	}	}	if (resumeOnNextOrPreviousIsOk) {	if (seqNum != nextExpectedSeqNum) {	if (seqNum == nextExpectedSeqNum - TRANSACITON_BATCH) {	nextExpectedSeqNum -= TRANSACITON_BATCH;	
in doubt commit failed getting replay at 

}	if (resumeOnNextOrPreviousIsOk) {	if (seqNum != nextExpectedSeqNum) {	if (seqNum == nextExpectedSeqNum - TRANSACITON_BATCH) {	nextExpectedSeqNum -= TRANSACITON_BATCH;	}	}	resumeOnNextOrPreviousIsOk = false;	}	if (seqNum != nextExpectedSeqNum) {	
received in msg expected lastid message 

}	resumeOnNextOrPreviousIsOk = false;	}	if (seqNum != nextExpectedSeqNum) {	fail(dest + " received " + seqNum + " expected " + nextExpectedSeqNum);	}	++nextExpectedSeqNum;	lastId = message.getJMSMessageID();	} catch (TransactionRolledBackException expectedSometimesOnFailoverRecovery) {	++nextExpectedSeqNum;	
got rollback 

}	if (seqNum != nextExpectedSeqNum) {	fail(dest + " received " + seqNum + " expected " + nextExpectedSeqNum);	}	++nextExpectedSeqNum;	lastId = message.getJMSMessageID();	} catch (TransactionRolledBackException expectedSometimesOnFailoverRecovery) {	++nextExpectedSeqNum;	if (expectedSometimesOnFailoverRecovery.getMessage().contains("completion in doubt")) {	resumeOnNextOrPreviousIsOk = true;	
in doubt transaction completion ok to get next or previous batch next 

lastId = message.getJMSMessageID();	} catch (TransactionRolledBackException expectedSometimesOnFailoverRecovery) {	++nextExpectedSeqNum;	if (expectedSometimesOnFailoverRecovery.getMessage().contains("completion in doubt")) {	resumeOnNextOrPreviousIsOk = true;	} else {	resumeOnNextOrPreviousIsOk = false;	nextExpectedSeqNum -= TRANSACITON_BATCH;	}	} catch (Throwable e) {	
onmessage error 

connections.add(connection);	}	public void run() {	final String longString = buildLongString();	while (nextSequenceNumber < numtoSend) {	try {	final Message message = session .createTextMessage(longString);	message.setLongProperty(SEQ_NUM_PROPERTY, ++nextSequenceNumber);	messageProducer.send(message);	if ((nextSequenceNumber % 500) == 0) {	
sent 

public void run() {	final String longString = buildLongString();	while (nextSequenceNumber < numtoSend) {	try {	final Message message = session .createTextMessage(longString);	message.setLongProperty(SEQ_NUM_PROPERTY, ++nextSequenceNumber);	messageProducer.send(message);	if ((nextSequenceNumber % 500) == 0) {	}	} catch (javax.jms.IllegalStateException e) {	
bailing on send error 

try {	final Message message = session .createTextMessage(longString);	message.setLongProperty(SEQ_NUM_PROPERTY, ++nextSequenceNumber);	messageProducer.send(message);	if ((nextSequenceNumber % 500) == 0) {	}	} catch (javax.jms.IllegalStateException e) {	exceptions.add(e);	break;	} catch (Exception e) {	
send error 

} catch (javax.jms.IllegalStateException e) {	exceptions.add(e);	break;	} catch (Exception e) {	exceptions.add(e);	}	if (sleepBetweenSend > 0) {	try {	Thread.sleep(sleepBetweenSend);	} catch (InterruptedException e) {	
sleep interrupted 

}	});	expectedSeq = 0;	for (int s = 0; s < 4; s++) {	for (int i = 0; i < batch; i++) {	Message message = messageConsumer.receive(20000);	assertNotNull("s:" + s + ", i:" + i, message);	final long seqNum = message.getLongProperty(SEQ_NUM_PROPERTY);	assertEquals("expected order s:" + s, expectedSeq++, seqNum);	if (i > 0 && i%600 == 0) {	
commit on 

LOG.info("with restart: not asserting qneue/dequeue stat match for: " + dest.getName() + " " + stats.getEnqueues().getCount() + " <= " +stats.getDequeues().getCount());	} else {	assertEquals("qneue/dequeue match for: " + dest.getName(), stats.getEnqueues().getCount(), stats.getDequeues().getCount());	}	}	}	private TimerTask schedualRestartTask(final Timer timer, final Configurer configurer) {	class RestartTask extends TimerTask {	public void run() {	synchronized (brokerLock) {	
stopping broker 

}	}	private TimerTask schedualRestartTask(final Timer timer, final Configurer configurer) {	class RestartTask extends TimerTask {	public void run() {	synchronized (brokerLock) {	try {	broker.stop();	broker.waitUntilStopped();	} catch (Exception e) {	
ex on broker stop 

private TimerTask schedualRestartTask(final Timer timer, final Configurer configurer) {	class RestartTask extends TimerTask {	public void run() {	synchronized (brokerLock) {	try {	broker.stop();	broker.waitUntilStopped();	} catch (Exception e) {	exceptions.add(e);	}	
restarting broker 

try {	broker.stop();	broker.waitUntilStopped();	} catch (Exception e) {	exceptions.add(e);	}	try {	createBroker(configurer);	broker.waitUntilStarted();	} catch (Exception e) {	
ex on broker restart 

} catch (Exception e) {	exceptions.add(e);	}	}	if (++numBrokerRestarts < MAX_BROKER_RESTARTS && timer != null) {	try {	timer.schedule(new RestartTask(), brokerStopPeriod);	} catch (IllegalStateException ignore_alreadyCancelled) {	}	} else {	
no longer stopping broker on reaching max restarts 

final long expiry = System.currentTimeMillis() + 1000 * 60 * 10;	while(!threads.isEmpty() && exceptions.isEmpty() && System.currentTimeMillis() < expiry) {	Thread sendThread = threads.firstElement();	sendThread.join(1000*60*10);	if (!sendThread.isAlive()) {	threads.remove(sendThread);	} else {	AutoFailTestSupport.dumpAllThreads("Send blocked");	}	}	
senders done 

for (Connection connection : connections) {	try {	connection.close();	} catch (Exception ignored) {}	}	connections.clear();	assertTrue("No timeout waiting for senders/receivers to complete", System.currentTimeMillis() < expiry);	if (!exceptions.isEmpty()) {	exceptions.get(0).printStackTrace();	}	
dangling threads 

========================= activemq sample_2958 =========================

draining = true;	MessagePull pullRequest = new MessagePull();	pullRequest.setConsumerId(getConsumerId());	pullRequest.setDestination(getDestination());	pullRequest.setTimeout(-1);	pullRequest.setAlwaysSignalDone(true);	pullRequest.setQuantity(endpointCredit);	LOG.trace("Pull case -> consumer pull request quantity = {}", endpointCredit);	sendToActiveMQ(pullRequest);	} else {	
pull case sending any queued messages and marking drained 

getEndpoint().drained();	session.pumpProtonToSocket();	currentCreditRequest = 0;	logicalDeliveryCount = 0;	}	} else if (endpointCredit >= 0) {	if (endpointCredit == 0 && currentCreditRequest != 0) {	prefetchExtension.set(0);	currentCreditRequest = 0;	logicalDeliveryCount = 0;	
flow credit for sub 

int logicalCredit = currentCreditRequest - logicalDeliveryCount;	if (logicalCredit > 0) {	deltaToAdd -= logicalCredit;	} else {	logicalDeliveryCount = 0;	}	if (deltaToAdd > 0) {	currentCreditRequest = prefetchExtension.addAndGet(deltaToAdd);	subscription.wakeupDestinationsForDispatch();	subscription.setPrefetchSize(0);	
flow credit addition of for sub 

public void commit(LocalTransactionId txnId) throws Exception {	if (!dispatchedInTx.isEmpty()) {	for (final Delivery delivery : dispatchedInTx) {	MessageDispatch dispatch = (MessageDispatch) delivery.getContext();	MessageAck pendingTxAck = new MessageAck(dispatch, MessageAck.INDIVIDUAL_ACK_TYPE, 1);	pendingTxAck.setFirstMessageId(dispatch.getMessage().getMessageId());	pendingTxAck.setTransactionId(txnId);	
sending commit ack to activemq 

public void rollback(LocalTransactionId txnId) throws Exception {	synchronized (outbound) {	
rolling back messages for redelivery 

}	} else {	temp = (ActiveMQMessage) md.getMessage();	}	if (!temp.getProperties().containsKey(JMS_AMQP_MESSAGE_FORMAT)) {	temp.setProperty(JMS_AMQP_MESSAGE_FORMAT, 0);	}	}	final ActiveMQMessage jms = temp;	if (jms == null) {	
sender browse done 

if (jms == null) {	getEndpoint().drained();	draining = false;	currentCreditRequest = 0;	logicalDeliveryCount = 0;	} else {	if (LOG.isTraceEnabled()) {	LOG.trace("Sender:[{}] msgId={} draining={}, drain={}, credit={}, remoteCredit={}, queued={}", getEndpoint().getName(), jms.getJMSMessageID(), draining, getEndpoint().getDrain(), getEndpoint().getCredit(), getEndpoint().getRemoteCredit(), getEndpoint().getQueued());	}	if (draining && getEndpoint().getCredit() == 0) {	
sender browse complete 

} else {	final byte[] tag = tagCache.getNextTag();	currentDelivery = getEndpoint().delivery(tag, 0, tag.length);	}	currentDelivery.setContext(md);	currentDelivery.setMessageFormat((int) amqp.getMessageFormat());	} else {	}	}	} catch (Exception e) {	
error detected while flushing outbound messages 

} else {	MessageDispatch md = (MessageDispatch) delivery.getContext();	lastDeliveredSequenceId = md.getMessage().getMessageId().getBrokerSequenceId();	MessageAck ack = new MessageAck();	ack.setConsumerId(getConsumerId());	ack.setFirstMessageId(md.getMessage().getMessageId());	ack.setLastMessageId(md.getMessage().getMessageId());	ack.setMessageCount(1);	ack.setAckType((byte) ackType);	ack.setDestination(md.getDestination());	
sending ack to activemq 

========================= activemq sample_1698 =========================

public java.sql.Connection initDb() throws Exception {	String createStatement = "CREATE TABLE SCP_INPUT_MESSAGES (" + "id int NOT NULL GENERATED ALWAYS AS IDENTITY, " + "messageId varchar(96) NOT NULL, " + "messageCorrelationId varchar(96) NOT NULL, " + "messageContent varchar(2048) NOT NULL, " + "PRIMARY KEY (id) )";	java.sql.Connection conn = getJDBCConnection();	try {	conn.createStatement().execute(createStatement);	} catch (SQLException alreadyExists) {	
ex on create tables 

public java.sql.Connection initDb() throws Exception {	String createStatement = "CREATE TABLE SCP_INPUT_MESSAGES (" + "id int NOT NULL GENERATED ALWAYS AS IDENTITY, " + "messageId varchar(96) NOT NULL, " + "messageCorrelationId varchar(96) NOT NULL, " + "messageContent varchar(2048) NOT NULL, " + "PRIMARY KEY (id) )";	java.sql.Connection conn = getJDBCConnection();	try {	conn.createStatement().execute(createStatement);	} catch (SQLException alreadyExists) {	}	try {	conn.createStatement().execute("DELETE FROM SCP_INPUT_MESSAGES");	} catch (SQLException ex) {	
ex on create delete all 

private int dumpDb(java.sql.Connection jdbcConn) throws Exception {	int count = 0;	ResultSet resultSet = jdbcConn.createStatement().executeQuery("SELECT * FROM SCP_INPUT_MESSAGES");	while (resultSet.next()) {	count++;	
message seq id corr content 

private boolean consumedFrom(String qName) throws Exception {	ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("vm: factory.setWatchTopicAdvisories(false);	Connection connection = factory.createConnection();	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createConsumer(new ActiveMQQueue(qName));	Message message = consumer.receive(500);	
got from queue 

public String enrich(Exchange exchange) throws Exception {	
got exchange 

public String enrich(Exchange exchange) throws Exception {	
got message 

public String enrich(Exchange exchange) throws Exception {	
current tx 

public String enrich(Exchange exchange) throws Exception {	
marking rollback only 

========================= activemq sample_1362 =========================

return new LRUCache<Destination, DestinationBridge>() {	private static final long serialVersionUID = -7446792754185879286L;	protected boolean removeEldestEntry(Map.Entry<Destination, DestinationBridge> enty) {	if (size() > maxCacheSize) {	Iterator<Map.Entry<Destination, DestinationBridge>> iter = entrySet().iterator();	Map.Entry<Destination, DestinationBridge> lru = iter.next();	remove(lru.getKey());	DestinationBridge bridge = lru.getValue();	try {	bridge.stop();	
expired bridge 

private static final long serialVersionUID = -7446792754185879286L;	protected boolean removeEldestEntry(Map.Entry<Destination, DestinationBridge> enty) {	if (size() > maxCacheSize) {	Iterator<Map.Entry<Destination, DestinationBridge>> iter = entrySet().iterator();	Map.Entry<Destination, DestinationBridge> lru = iter.next();	remove(lru.getKey());	DestinationBridge bridge = lru.getValue();	try {	bridge.stop();	} catch (Exception e) {	
stopping expired bridge caused an exception 

public void start() throws Exception {	if (started.compareAndSet(false, true)) {	init();	for (DestinationBridge bridge : inboundBridges) {	bridge.start();	}	for (DestinationBridge bridge : outboundBridges) {	bridge.start();	}	
jms connector started 

localConnection.get().close();	} catch (Exception e) {	}	}	for (DestinationBridge bridge : inboundBridges) {	bridge.stop();	}	for (DestinationBridge bridge : outboundBridges) {	bridge.stop();	}	
jms connector stopped 

protected abstract void initializeLocalConnection() throws Exception;	protected abstract void initializeForeignConnection() throws Exception;	void handleConnectionFailure(Connection connection) {	if (connection == null || !this.started.get()) {	return;	}	
jmsconnector handling loss of connection 

try {	bridge.stop();	} catch(Exception e) {	}	}	this.connectionService.execute(new Runnable() {	public void run() {	try {	doInitializeConnection(false);	} catch (Exception e) {	
failed to initialize foreign connection for the jmsconnector 

try {	bridge.stop();	} catch(Exception e) {	}	}	this.connectionService.execute(new Runnable() {	public void run() {	try {	doInitializeConnection(true);	} catch (Exception e) {	
failed to initialize local connection for the jmsconnector 

private void scheduleAsyncLocalConnectionReconnect() {	this.connectionService.execute(new Runnable() {	public void run() {	try {	doInitializeConnection(true);	} catch (Exception e) {	
failed to initialize local connection for the jmsconnector 

private void scheduleAsyncForeignConnectionReconnect() {	this.connectionService.execute(new Runnable() {	public void run() {	try {	doInitializeConnection(false);	} catch (Exception e) {	
failed to initialize foreign connection for the jmsconnector 

final int maxRetries;	if (local) {	maxRetries = !localSideInitialized.get() ? policy.getMaxInitialConnectAttempts() : policy.getMaxReconnectAttempts();	} else {	maxRetries = !foreignSideInitialized.get() ? policy.getMaxInitialConnectAttempts() : policy.getMaxReconnectAttempts();	}	do {	if (attempt > 0) {	try {	long nextDelay = policy.getNextDelay(attempt);	
bridge reconnect attempt waiting ms before next attempt 

if (localConnection.get() != null && foreignConnection.get() != null) {	for (DestinationBridge bridge : inboundBridges) {	bridge.start();	}	for (DestinationBridge bridge : outboundBridges) {	bridge.start();	}	}	return;	} catch(Exception e) {	
failed to establish initial connection for jmsconnector local foreign 

========================= activemq sample_4249 =========================

session = consumerConnection.createSession(true, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createConsumer(destination);	ActiveMQTextMessage m = ((ActiveMQTextMessage)consumer.receive(4000));	if (i<=maxRedeliveries) {	assertEquals("1st", m.getText());	assertEquals(i, m.getRedeliveryCounter());	} else {	assertNull("null on exceeding redelivery count", m);	assertTrue("message in dlq", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
total dequeue count 

} else {	assertFalse("listener done", done.await(1, TimeUnit.SECONDS));	}	connection.close();	connections.remove(connection);	}	TextMessage m = (TextMessage)dlqConsumer.receive(1000);	assertNotNull("Got message from DLQ", m);	assertEquals("1st", m.getText());	String cause = m.getStringProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY);	
cause 

policy.setInitialRedeliveryDelay(0);	policy.setUseExponentialBackOff(false);	policy.setMaximumRedeliveries(maxRedeliveries);	connection.start();	final CountDownLatch done = new CountDownLatch(1);	final ActiveMQSession session = (ActiveMQSession) connection.createSession(true, Session.SESSION_TRANSACTED);	session.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	ActiveMQTextMessage m = (ActiveMQTextMessage) message;	
got seq 

policy.setUseExponentialBackOff(false);	connection.setNonBlockingRedelivery(blockingRedelivery);	connection.start();	final CountDownLatch done = new CountDownLatch(3);	final ActiveMQSession session = (ActiveMQSession) connection.createSession(true, Session.SESSION_TRANSACTED);	final List<String> list = new ArrayList<>();	session.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	ActiveMQTextMessage m = (ActiveMQTextMessage) message;	
got seq 

========================= activemq sample_2688 =========================

MessageConsumer remoteConsumer = remoteSession.createConsumer(included);	remoteConsumer.setMessageListener(new MessageListener() {	public void onMessage(Message msg) {	final TextMessage textMsg = (TextMessage)msg;	try {	String payload = "REPLY: " + textMsg.getText() + ", " + textMsg.getJMSMessageID();	Destination replyTo;	replyTo = msg.getJMSReplyTo();	textMsg.clearBody();	textMsg.setText(payload);	
sending response 

remoteConsumer.setMessageListener(new MessageListener() {	public void onMessage(Message msg) {	final TextMessage textMsg = (TextMessage)msg;	try {	String payload = "REPLY: " + textMsg.getText() + ", " + textMsg.getJMSMessageID();	Destination replyTo;	replyTo = msg.getJMSReplyTo();	textMsg.clearBody();	textMsg.setText(payload);	remoteProducer.send(replyTo, textMsg);	
replied with 

try {	String payload = "REPLY: " + textMsg.getText() + ", " + textMsg.getJMSMessageID();	Destination replyTo;	replyTo = msg.getJMSReplyTo();	textMsg.clearBody();	textMsg.setText(payload);	remoteProducer.send(replyTo, textMsg);	} catch (DestinationDoesNotExistException expected) {	replyToNonExistDest.incrementAndGet();	try {	
ned 

textMsg.clearBody();	textMsg.setText(payload);	remoteProducer.send(replyTo, textMsg);	} catch (DestinationDoesNotExistException expected) {	replyToNonExistDest.incrementAndGet();	try {	} catch (JMSException e) {	e.printStackTrace();	};	} catch (Exception e) {	
responder listener caught exception 

}	});	Queue tempQueue = localSession.createTemporaryQueue();	MessageProducer requestProducer = localSession.createProducer(included);	requestProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	MessageConsumer requestConsumer = localSession.createConsumer(tempQueue);	MessageConsumer dlqconsumer = remoteSession.createConsumer(new ActiveMQQueue(SharedDeadLetterStrategy.DEFAULT_DEAD_LETTER_QUEUE_NAME));	dlqconsumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	
dlq 

Thread.sleep(2000);	long done = System.currentTimeMillis() + (MESSAGE_COUNT * 6000);	int i = 0;	while (MESSAGE_COUNT > roundTripComplete.get() + remoteDLQCount.get() + replyToNonExistDest.get() && done > System.currentTimeMillis()) {	if  ( i < MESSAGE_COUNT) {	String payload = "test msg " + i;	i++;	TextMessage msg = localSession.createTextMessage(payload);	msg.setJMSReplyTo(tempQueue);	requestProducer.send(msg);	
sent failing over 

if  ( i < MESSAGE_COUNT) {	String payload = "test msg " + i;	i++;	TextMessage msg = localSession.createTextMessage(payload);	msg.setJMSReplyTo(tempQueue);	requestProducer.send(msg);	((FailoverTransport) ((TransportFilter) ((TransportFilter) ((ActiveMQConnection) localConnection) .getTransport()).getNext()).getNext()) .handleTransportFailure(new IOException("Forcing failover from test"));	}	TextMessage result = (TextMessage)requestConsumer.receive(5000);	if (result != null) {	
got reply 

TextMessage msg = localSession.createTextMessage(payload);	msg.setJMSReplyTo(tempQueue);	requestProducer.send(msg);	((FailoverTransport) ((TransportFilter) ((TransportFilter) ((ActiveMQConnection) localConnection) .getTransport()).getNext()).getNext()) .handleTransportFailure(new IOException("Forcing failover from test"));	}	TextMessage result = (TextMessage)requestConsumer.receive(5000);	if (result != null) {	roundTripComplete.incrementAndGet();	}	}	
complete remotedlqcount replytononexistdest 

========================= activemq sample_2722 =========================

protected void setUp() throws Exception {	deliveryMode = DeliveryMode.NON_PERSISTENT;	topic = false;	super.setUp();	consumerDestination2 = consumeSession.createTopic("FOO.BAR.HUMBUG2");	
created consumer destination of type 

protected void setUp() throws Exception {	deliveryMode = DeliveryMode.NON_PERSISTENT;	topic = false;	super.setUp();	consumerDestination2 = consumeSession.createTopic("FOO.BAR.HUMBUG2");	if (durable) {	
creating durable consumer 

public void testSendReceive() throws Exception {	super.testSendReceive();	messages.clear();	consumer2.setMessageListener(this);	assertMessagesAreReceived();	
messages s received closing down connections 

========================= activemq sample_3830 =========================

public void testInflightWithConsumerPerMessage() throws JMSException {	makeMessages(prefetchSize);	
about to send and receive on destination of type 

========================= activemq sample_3563 =========================

}	final AmqpTransactionId txId = session.getConnection().getNextTransactionId();	final ClientFuture request = new ClientFuture(new ClientFutureSynchronization() {	public void onPendingSuccess() {	transactionId = txId;	}	public void onPendingFailure(Throwable cause) {	transactionId = null;	}	});	
attempting to begin tx 

public void onPendingSuccess() {	transactionId = txId;	}	public void onPendingFailure(Throwable cause) {	transactionId = null;	}	});	session.getScheduler().execute(new Runnable() {	public void run() {	if (coordinator == null || coordinator.isClosed()) {	
creating new coordinator for tx 

transactionId = null;	}	});	session.getScheduler().execute(new Runnable() {	public void run() {	if (coordinator == null || coordinator.isClosed()) {	coordinator = new AmqpTransactionCoordinator(session);	coordinator.open(new AsyncResult() {	public void onSuccess() {	try {	
attempting to declare tx 

}	public void onFailure(Throwable result) {	request.onFailure(result);	}	public boolean isComplete() {	return request.isComplete();	}	});	} else {	try {	
attempting to declare tx 

final ClientFuture request = new ClientFuture(new ClientFutureSynchronization() {	public void onPendingSuccess() {	transactionId = null;	postCommit();	}	public void onPendingFailure(Throwable cause) {	transactionId = null;	postCommit();	}	});	
commit on tx initiated 

postCommit();	}	public void onPendingFailure(Throwable cause) {	transactionId = null;	postCommit();	}	});	session.getScheduler().execute(new Runnable() {	public void run() {	try {	
attempting to commit tx 

final ClientFuture request = new ClientFuture(new ClientFutureSynchronization() {	public void onPendingSuccess() {	transactionId = null;	postRollback();	}	public void onPendingFailure(Throwable cause) {	transactionId = null;	postRollback();	}	});	
rollback on tx initiated 

postRollback();	}	public void onPendingFailure(Throwable cause) {	transactionId = null;	postRollback();	}	});	session.getScheduler().execute(new Runnable() {	public void run() {	try {	
attempting to roll back tx 

========================= activemq sample_1620 =========================

protected void doStart() throws Exception {	
starting 

protected void doStart() throws Exception {	configuredTransport.setTransportListener(new TransportListener() {	public void onCommand(Object o) {	final Command command = (Command)o;	processInboundConnection(command);	}	public void onException(IOException error) {	
caught 

protected void processInboundConnection(Command command) {	DatagramEndpoint endpoint = (DatagramEndpoint)command.getFrom();	if (LOG.isDebugEnabled()) {	
received command on from address command 

protected void processInboundConnection(Command command) {	DatagramEndpoint endpoint = (DatagramEndpoint)command.getFrom();	if (LOG.isDebugEnabled()) {	}	Transport transport = null;	synchronized (transports) {	transport = transports.get(endpoint);	if (transport == null) {	if (usingWireFormatNegotiation && !command.isWireFormatInfo()) {	
received inbound server communication from expecting wireformatinfo but was command 

DatagramEndpoint endpoint = (DatagramEndpoint)command.getFrom();	if (LOG.isDebugEnabled()) {	}	Transport transport = null;	synchronized (transports) {	transport = transports.get(endpoint);	if (transport == null) {	if (usingWireFormatNegotiation && !command.isWireFormatInfo()) {	} else {	if (LOG.isDebugEnabled()) {	
creating a new udp server connection 

if (transport == null) {	if (usingWireFormatNegotiation && !command.isWireFormatInfo()) {	} else {	if (LOG.isDebugEnabled()) {	}	try {	transport = createTransport(command, endpoint);	transport = configureTransport(transport);	transports.put(endpoint, transport);	} catch (IOException e) {	
caught 

}	try {	transport = createTransport(command, endpoint);	transport = configureTransport(transport);	transports.put(endpoint, transport);	} catch (IOException e) {	getAcceptListener().onAcceptError(e);	}	}	} else {	
discarding duplicate command to server from command 

========================= activemq sample_72 =========================

for (int i = 0; i < iterations; i++) {	PList candidate = lists[i % numLists];	Thread.currentThread().setName("ALRF:" + candidate.getName());	synchronized (plistLocks(candidate)) {	Object locator = candidate.addLast(String.valueOf(i), payload);	getFirst(candidate);	assertTrue(candidate.remove(locator));	}	}	} catch (Exception error) {	
unexpcted ex 

File directory = store.getDirectory();	store.stop();	IOHelper.mkdirs(directory);	IOHelper.deleteChildren(directory);	store = new PListStoreImpl();	store.setDirectory(directory);	store.start();	for (int i = 0; i < 2000; i++) {	new Job(i, PListTest.TaskType.ADD, 5).run();	}	
after load index file 

File directory = store.getDirectory();	store.stop();	IOHelper.mkdirs(directory);	IOHelper.deleteChildren(directory);	store = new PListStoreImpl();	store.setDirectory(directory);	store.start();	for (int i = 0; i < 2000; i++) {	new Job(i, PListTest.TaskType.ADD, 5).run();	}	
after remove index file 

IOHelper.mkdirs(directory);	IOHelper.deleteChildren(directory);	store = new PListStoreImpl();	store.setDirectory(directory);	store.setJournalMaxFileLength(1024 * 5);	store.setCleanupInterval(5000);	store.setIndexWriteBatchSize(500);	store.start();	final int iterations = 500;	final int numLists = 10;	
create 

store.setDirectory(directory);	store.setJournalMaxFileLength(1024 * 5);	store.setCleanupInterval(5000);	store.setIndexWriteBatchSize(500);	store.start();	final int iterations = 500;	final int numLists = 10;	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.CREATE, iterations).run();	}	
delete 

store.setIndexWriteBatchSize(500);	store.start();	final int iterations = 500;	final int numLists = 10;	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.CREATE, iterations).run();	}	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.DELETE, iterations).run();	}	
fill 

final int numLists = 10;	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.CREATE, iterations).run();	}	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.DELETE, iterations).run();	}	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.ADD, iterations).run();	}	
remove 

}	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.DELETE, iterations).run();	}	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.ADD, iterations).run();	}	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.REMOVE, iterations).run();	}	
check empty 

}	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.ADD, iterations).run();	}	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.REMOVE, iterations).run();	}	for (int i = 0; i < numLists; i++) {	assertEquals("empty " + i, 0, store.getPList("List-" + i).size());	}	
delete again 

}	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.REMOVE, iterations).run();	}	for (int i = 0; i < numLists; i++) {	assertEquals("empty " + i, 0, store.getPList("List-" + i).size());	}	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.DELETE, iterations).run();	}	
fill again 

}	for (int i = 0; i < numLists; i++) {	assertEquals("empty " + i, 0, store.getPList("List-" + i).size());	}	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.DELETE, iterations).run();	}	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.ADD, iterations).run();	}	
parallel add and remove 

new Job(i, PListTest.TaskType.DELETE, iterations).run();	}	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.ADD, iterations).run();	}	executor = Executors.newFixedThreadPool(numLists * 2);	for (int i = 0; i < numLists * 2; i++) {	executor.execute(new Job(i, i >= numLists ? PListTest.TaskType.ADD : PListTest.TaskType.REMOVE, iterations));	}	executor.shutdown();	
wait for parallel work to complete 

store.stop();	IOHelper.mkdirs(directory);	IOHelper.deleteChildren(directory);	store = new PListStoreImpl();	store.setIndexEnablePageCaching(enablePageCache);	store.setIndexPageSize(2 * 1024);	store.setDirectory(directory);	store.start();	final int iterations = 500;	final int numLists = 10;	
create 

store = new PListStoreImpl();	store.setIndexEnablePageCaching(enablePageCache);	store.setIndexPageSize(2 * 1024);	store.setDirectory(directory);	store.start();	final int iterations = 500;	final int numLists = 10;	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.CREATE, iterations).run();	}	
fill 

store.setDirectory(directory);	store.start();	final int iterations = 500;	final int numLists = 10;	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.CREATE, iterations).run();	}	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.ADD, iterations).run();	}	
parallel add and remove 

executor.execute(new Job(i, PListTest.TaskType.ADD, iterations * 2));	}	for (int k = 0; k < numConsumer; k++) {	executor.execute(new Job(i, TaskType.ITERATE_REMOVE, iterations / 4));	}	}	for (int i = numLists; i < numLists * 10; i++) {	executor.execute(new Job(i, PListTest.TaskType.ADD, iterations));	}	executor.shutdown();	
wait for parallel work to complete 

store = new PListStoreImpl();	store.setIndexPageSize(2 * 1024);	store.setJournalMaxFileLength(1024 * 1024);	store.setDirectory(directory);	store.setCleanupInterval(-1);	store.setIndexEnablePageCaching(false);	store.setIndexWriteBatchSize(100);	store.start();	final int iterations = 250;	final int numLists = 10;	
create 

store.setDirectory(directory);	store.setCleanupInterval(-1);	store.setIndexEnablePageCaching(false);	store.setIndexWriteBatchSize(100);	store.start();	final int iterations = 250;	final int numLists = 10;	for (int i = 0; i < numLists; i++) {	new Job(i, PListTest.TaskType.CREATE, iterations).run();	}	
parallel add and iterate 

final int numConsumer = 10;	for (int i = 0; i < numLists; i++) {	for (int j = 0; j < numProducer; j++) {	executor.execute(new Job(i, PListTest.TaskType.ADD, iterations));	}	for (int k = 0; k < numConsumer; k++) {	executor.execute(new Job(i, TaskType.ITERATE, iterations * 2));	}	}	executor.shutdown();	
wait for parallel work to complete 

executor.execute(new Job(i, PListTest.TaskType.ADD, iterations));	}	for (int k = 0; k < numConsumer; k++) {	executor.execute(new Job(i, TaskType.ITERATE, iterations * 2));	}	}	executor.shutdown();	boolean shutdown = executor.awaitTermination(5 * 60, TimeUnit.SECONDS);	assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());	assertTrue("test did not  timeout ", shutdown);	
num datafiles 

public void run() {	final String threadName = Thread.currentThread().getName();	try {	PListImpl plist = null;	switch (task) {	case CREATE: Thread.currentThread().setName("C:" + id);	plist = store.getPList(String.valueOf(id));	
job create 

for (int j = 0; j < iterations; j++) {	synchronized (plistLocks(plist)) {	if (exceptions.isEmpty()) {	plist.addLast("PL>" + id + idSeed + "-" + j, payload);	} else {	break;	}	}	}	if (exceptions.isEmpty()) {	
job add done 

}	if (exceptions.isEmpty()) {	}	break;	case REMOVE: Thread.currentThread().setName("R:" + id);	plist = store.getPList(String.valueOf(id));	synchronized (plistLocks(plist)) {	for (int j = iterations - 1; j >= 0; j--) {	plist.remove("PL>" + id + idSeed + "-" + j);	if (j > 0 && j % (iterations / 2) == 0) {	
job done remove 

synchronized (plistLocks(plist)) {	Iterator<PListEntry> removeIterator = plist.iterator();	while (removeIterator.hasNext()) {	removeIterator.next();	removeIterator.remove();	if (removeCount++ > iterations) {	break;	}	}	}	
job done remove 

removeIterator.next();	removeIterator.remove();	if (removeCount++ > iterations) {	break;	}	}	}	break;	default: }	} catch (Exception e) {	
job caught exception 

========================= activemq sample_3758 =========================

connect.cleanSession(true);	connect.clientId(new UTF8Buffer(""));	DataByteArrayOutputStream output = new DataByteArrayOutputStream();	wireFormat.marshal(connect.encode(), output);	Buffer marshalled = output.toBuffer();	DataByteArrayInputStream input = new DataByteArrayInputStream(marshalled);	codec.parse(input, marshalled.length());	assertTrue(!frames.isEmpty());	assertEquals(1, frames.size());	connect = new CONNECT().decode(frames.get(0));	
unmarshalled 

connect.cleanSession(true);	connect.clientId(new UTF8Buffer(""));	DataByteArrayOutputStream output = new DataByteArrayOutputStream();	wireFormat.marshal(connect.encode(), output);	Buffer marshalled = output.toBuffer();	DataByteArrayInputStream input = new DataByteArrayInputStream(marshalled);	codec.parse(input, marshalled.length());	assertTrue(!frames.isEmpty());	assertEquals(1, frames.size());	connect = new CONNECT().decode(frames.get(0));	
unmarshalled 

DataByteArrayOutputStream output = new DataByteArrayOutputStream();	wireFormat.marshal(connect.encode(), output);	wireFormat.marshal(connect.encode(), output);	Buffer marshalled = output.toBuffer();	DataByteArrayInputStream input = new DataByteArrayInputStream(marshalled);	codec.parse(input, marshalled.length());	assertTrue(!frames.isEmpty());	assertEquals(2, frames.size());	for (MQTTFrame frame : frames) {	connect = new CONNECT().decode(frame);	
unmarshalled 

wireFormat.marshal(connect.encode(), output);	Buffer marshalled = output.toBuffer();	DataByteArrayInputStream input = new DataByteArrayInputStream(marshalled);	int first = marshalled.length() / 2;	int second = marshalled.length() - first;	codec.parse(input, first);	codec.parse(input, second);	assertTrue(!frames.isEmpty());	assertEquals(1, frames.size());	connect = new CONNECT().decode(frames.get(0));	
unmarshalled 

wireFormat.marshal(connect.encode(), output);	Buffer marshalled = output.toBuffer();	DataByteArrayInputStream input = new DataByteArrayInputStream(marshalled);	int size = marshalled.length();	for (int i = 0; i < size; ++i) {	codec.parse(input, 1);	}	assertTrue(!frames.isEmpty());	assertEquals(1, frames.size());	connect = new CONNECT().decode(frames.get(0));	
unmarshalled 

Buffer marshalled = output.toBuffer();	long startTime = System.currentTimeMillis();	for (int i = 0; i < ITERATIONS; ++i) {	DataByteArrayInputStream input = new DataByteArrayInputStream(marshalled);	codec.parse(input, marshalled.length());	assertTrue(!frames.isEmpty());	publish = new PUBLISH().decode(frames.get(0));	frames.clear();	}	long duration = System.currentTimeMillis() - startTime;	
total time to process 

========================= activemq sample_878 =========================

public void testInactivityMonitor() throws Exception {	Thread t1 = new Thread() {	public void run() {	try {	connection = createConnection();	connection.getOutputStream().write('A');	connection.getOutputStream().flush();	} catch (Exception ex) {	
unexpected exception on connect disconnect 

========================= activemq sample_3471 =========================

public void onMessage(Message message) {	String id = null;	try {	id = message.getJMSMessageID();	synchronized (semaphore) {	messageIds.add(id);	semaphore.notifyAll();	}	if (verbose) {	
received message 

public void waitForMessagesToArrive(int messageCount) {	
waiting for message s to arrive 

break;	}	long duration = System.currentTimeMillis() - start;	if (duration >= maximumDuration) {	break;	}	synchronized (semaphore) {	semaphore.wait(maximumDuration - duration);	}	} catch (InterruptedException e) {	
caught 

if (duration >= maximumDuration) {	break;	}	synchronized (semaphore) {	semaphore.wait(maximumDuration - duration);	}	} catch (InterruptedException e) {	}	}	long end = System.currentTimeMillis() - start;	
end of wait for millis and received messages 

========================= activemq sample_1159 =========================

producerConnection.start();	Session session = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	try {	while (true) {	Message message = session.createTextMessage(new String(buf) + messagesSent.toString());	producer.send(message);	messagesSent.incrementAndGet();	if (messagesSent.get() % 100 == 0) {	
sent message 

producerConnection.start();	Session session = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	try {	while (true) {	Message message = session.createTextMessage(new String(buf) + messagesSent.toString());	producer.send(message);	messagesSent.incrementAndGet();	if (messagesSent.get() % 100 == 0) {	
temp store usage 

try {	while (true) {	Message message = session.createTextMessage(new String(buf) + messagesSent.toString());	producer.send(message);	messagesSent.incrementAndGet();	if (messagesSent.get() % 100 == 0) {	}	}	} catch (ResourceAllocationException ex) {	assertTrue("Should not be able to send 100 messages: ", messagesSent.get() < 100);	
got resource exception after sent 

producerConnection.start();	Session session = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	try {	while (true) {	Message message = session.createTextMessage(new String(buf) + messagesSent.toString());	producer.send(message);	messagesSent.incrementAndGet();	if (messagesSent.get() % 100 == 0) {	
sent message 

producerConnection.start();	Session session = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	try {	while (true) {	Message message = session.createTextMessage(new String(buf) + messagesSent.toString());	producer.send(message);	messagesSent.incrementAndGet();	if (messagesSent.get() % 100 == 0) {	
temp store usage 

try {	while (true) {	Message message = session.createTextMessage(new String(buf) + messagesSent.toString());	producer.send(message);	messagesSent.incrementAndGet();	if (messagesSent.get() % 100 == 0) {	}	}	} catch (ResourceAllocationException ex) {	assertTrue("Should be able to send at least 200 messages but was: " + messagesSent.get(), messagesSent.get() > 200);	
got resource exception after sent 

} catch (ResourceAllocationException ex) {	assertTrue("Should be able to send at least 200 messages but was: " + messagesSent.get(), messagesSent.get() > 200);	}	Connection consumerConnection = factory.createConnection();	consumerConnection.start();	Session consumerSession = consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = consumerSession.createConsumer(destination);	while (consumer.receive(messageReceiveTimeout) != null) {	messagesConsumed.incrementAndGet();	if (messagesConsumed.get() % 1000 == 0) {	
received message 

} catch (ResourceAllocationException ex) {	assertTrue("Should be able to send at least 200 messages but was: " + messagesSent.get(), messagesSent.get() > 200);	}	Connection consumerConnection = factory.createConnection();	consumerConnection.start();	Session consumerSession = consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = consumerSession.createConsumer(destination);	while (consumer.receive(messageReceiveTimeout) != null) {	messagesConsumed.incrementAndGet();	if (messagesConsumed.get() % 1000 == 0) {	
temp store usage 

========================= activemq sample_2775 =========================

public void testManyTempDestinations() throws Exception {	Connection connection = createConnectionFactory().createConnection();	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	for (int i = 0; i < DEST_COUNT; i++) {	destination[i] = session.createTemporaryQueue();	
created temp queue 

========================= activemq sample_2904 =========================

public void testRemoveAfterRestart() throws Exception {	Connection connection = createConnection();	connection.setClientID("cliID");	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	TopicSubscriber subscriber = session.createDurableSubscriber((Topic) createDestination(), "subName");	subscriber.close();	connection.close();	
broker restarting wait for inactive cleanup afterwards 

public void testRemoveAfterRestart() throws Exception {	Connection connection = createConnection();	connection.setClientID("cliID");	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	TopicSubscriber subscriber = session.createDurableSubscriber((Topic) createDestination(), "subName");	subscriber.close();	connection.close();	restartBroker();	
broker restarted wait for inactive cleanup now 

========================= activemq sample_3616 =========================

protected static boolean deRegisterWrite(WriteTimeoutFilter filter, boolean fail, IOException iox) {	boolean result = writers.remove(filter);	if (result) {	if (fail) {	String message = "Forced write timeout for:"+filter.getNext().getRemoteAddress();	LOG.warn(message);	Socket sock = filter.getSocket();	if (sock==null) {	
destination socket is null unable to close socket 

}	}	}	try {	Thread.sleep(getSleep());	error = false;	} catch (InterruptedException x) {	}	}catch (Throwable t) {	if (!error) {	
writetimeout thread unable validate existing sockets 

========================= activemq sample_79 =========================

try {	consumerStartLatch.await(30, TimeUnit.SECONDS);	ConnectionFactory factory = new ActiveMQConnectionFactory("vm: Connection connection = factory.createConnection();	connection.start();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	long currentSendCount;	do {	currentSendCount = messagesSentCountDown.getCount();	TimeUnit.SECONDS.sleep(5);	} while (currentSendCount != messagesSentCountDown.getCount());	
starting consumer at 

TimeUnit.SECONDS.sleep(5);	} while (currentSendCount != messagesSentCountDown.getCount());	MessageConsumer consumer = session.createConsumer(session.createQueue(QUEUE_NAME));	do {	Message message = consumer.receive(5000);	if (message != null) {	session.commit();	messagesReceivedCountDown.countDown();	}	if (messagesReceivedCountDown.getCount() % 500 == 0) {	
remaining to receive 

try {	sendMessages();	} catch (Exception ignored) {	}	}	});	sendExecutor.shutdown();	sendExecutor.awaitTermination(10, TimeUnit.MINUTES);	boolean allMessagesReceived = messagesReceivedCountDown.await(10, TimeUnit.MINUTES);	if (!allMessagesReceived) {	
giving up not all received on time 

try {	sendMessages();	} catch (Exception ignored) {	}	}	});	sendExecutor.shutdown();	sendExecutor.awaitTermination(10, TimeUnit.MINUTES);	boolean allMessagesReceived = messagesReceivedCountDown.await(10, TimeUnit.MINUTES);	if (!allMessagesReceived) {	
system mem usage 

try {	sendMessages();	} catch (Exception ignored) {	}	}	});	sendExecutor.shutdown();	sendExecutor.awaitTermination(10, TimeUnit.MINUTES);	boolean allMessagesReceived = messagesReceivedCountDown.await(10, TimeUnit.MINUTES);	if (!allMessagesReceived) {	
system store usage 

try {	sendMessages();	} catch (Exception ignored) {	}	}	});	sendExecutor.shutdown();	sendExecutor.awaitTermination(10, TimeUnit.MINUTES);	boolean allMessagesReceived = messagesReceivedCountDown.await(10, TimeUnit.MINUTES);	if (!allMessagesReceived) {	
producer sent 

try {	sendMessages();	} catch (Exception ignored) {	}	}	});	sendExecutor.shutdown();	sendExecutor.awaitTermination(10, TimeUnit.MINUTES);	boolean allMessagesReceived = messagesReceivedCountDown.await(10, TimeUnit.MINUTES);	if (!allMessagesReceived) {	
consumer remaining to receive 

Destination shortRetainQueue = session.createQueue(QUEUE_NAME + "-retain-short");	for (int i=0; i<1240; i++) {	producer.send(shortRetainQueue, message);	session.commit();	}	MessageConsumer consumer = session.createConsumer(shortRetainQueue);	for (int i=0; i<1240; i++) {	consumer.receive(4000);	session.commit();	}	
done with retain q mem usage 

Destination shortRetainQueue = session.createQueue(QUEUE_NAME + "-retain-short");	for (int i=0; i<1240; i++) {	producer.send(shortRetainQueue, message);	session.commit();	}	MessageConsumer consumer = session.createConsumer(shortRetainQueue);	for (int i=0; i<1240; i++) {	consumer.receive(4000);	session.commit();	}	
done with retain q store usage 

session.commit();	}	consumerStartLatch.countDown();	for (int i = 0; i < MAX_MESSAGES; i++) {	producer.send(queue,  message);	if (i>0 && i%20 == 0) {	session.commit();	}	messagesSentCountDown.countDown();	if (i>0 && i%500 == 0) {	
sent 

========================= activemq sample_2841 =========================

public void testTransactedStoreUsageSuspendResume() throws Exception {	org.apache.log4j.Logger log4jLogger = org.apache.log4j.Logger.getLogger(MessageDatabase.class);	final AtomicBoolean failed = new AtomicBoolean(false);	final File journalDataDir = ((KahaDBPersistenceAdapter) broker.getPersistenceAdapter()).getStore().getJournal().getDirectory();	Appender appender = new DefaultTestAppender() {	public void doAppend(LoggingEvent event) {	if (event.getLevel().equals(Level.WARN) && event.getMessage().toString().startsWith("Failed to load next journal")) {	
received unexpected log message 

} finally {	log4jLogger.removeAppender(appender);	}	assertFalse("failed on unexpected log event", failed.get());	sendReceive(500);	assertTrue("gc worked ok", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return ((KahaDBPersistenceAdapter) broker.getPersistenceAdapter()).getStore().getJournal().getFileMap().size() < 2;	}	}));	
files 

========================= activemq sample_2791 =========================

protected void addTranportConnectors() throws Exception {	TransportConnector connector = null;	if (isUseTcpConnector()) {	connector = brokerService.addConnector( "stomp: port = connector.getConnectUri().getPort();	
using stomp port 

protected void addTranportConnectors() throws Exception {	TransportConnector connector = null;	if (isUseTcpConnector()) {	connector = brokerService.addConnector( "stomp: port = connector.getConnectUri().getPort();	}	if (isUseSslConnector()) {	connector = brokerService.addConnector( "stomp+ssl: sslPort = connector.getConnectUri().getPort();	
using stomp ssl port 

protected void addTranportConnectors() throws Exception {	TransportConnector connector = null;	if (isUseTcpConnector()) {	connector = brokerService.addConnector( "stomp: port = connector.getConnectUri().getPort();	}	if (isUseSslConnector()) {	connector = brokerService.addConnector( "stomp+ssl: sslPort = connector.getConnectUri().getPort();	}	if (isUseNioConnector()) {	connector = brokerService.addConnector( "stomp+nio: nioPort = connector.getConnectUri().getPort();	
using stomp nio port 

connector = brokerService.addConnector( "stomp: port = connector.getConnectUri().getPort();	}	if (isUseSslConnector()) {	connector = brokerService.addConnector( "stomp+ssl: sslPort = connector.getConnectUri().getPort();	}	if (isUseNioConnector()) {	connector = brokerService.addConnector( "stomp+nio: nioPort = connector.getConnectUri().getPort();	}	if (isUseNioPlusSslConnector()) {	connector = brokerService.addConnector( "stomp+nio+ssl: nioSslPort = connector.getConnectUri().getPort();	
using stomp nio ssl port 

connector = brokerService.addConnector( "stomp+ssl: sslPort = connector.getConnectUri().getPort();	}	if (isUseNioConnector()) {	connector = brokerService.addConnector( "stomp+nio: nioPort = connector.getConnectUri().getPort();	}	if (isUseNioPlusSslConnector()) {	connector = brokerService.addConnector( "stomp+nio+ssl: nioSslPort = connector.getConnectUri().getPort();	}	if (isUseAutoConnector()) {	connector = brokerService.addConnector( "auto: autoPort = connector.getConnectUri().getPort();	
using auto port 

connector = brokerService.addConnector( "stomp+nio: nioPort = connector.getConnectUri().getPort();	}	if (isUseNioPlusSslConnector()) {	connector = brokerService.addConnector( "stomp+nio+ssl: nioSslPort = connector.getConnectUri().getPort();	}	if (isUseAutoConnector()) {	connector = brokerService.addConnector( "auto: autoPort = connector.getConnectUri().getPort();	}	if (isUseAutoSslConnector()) {	connector = brokerService.addConnector( "auto+ssl: autoSslPort = connector.getConnectUri().getPort();	
using auto ssl port 

connector = brokerService.addConnector( "stomp+nio+ssl: nioSslPort = connector.getConnectUri().getPort();	}	if (isUseAutoConnector()) {	connector = brokerService.addConnector( "auto: autoPort = connector.getConnectUri().getPort();	}	if (isUseAutoSslConnector()) {	connector = brokerService.addConnector( "auto+ssl: autoSslPort = connector.getConnectUri().getPort();	}	if (isUseAutoNioConnector()) {	connector = brokerService.addConnector( "auto+nio: autoNioPort = connector.getConnectUri().getPort();	
using auto nio port 

connector = brokerService.addConnector( "auto: autoPort = connector.getConnectUri().getPort();	}	if (isUseAutoSslConnector()) {	connector = brokerService.addConnector( "auto+ssl: autoSslPort = connector.getConnectUri().getPort();	}	if (isUseAutoNioConnector()) {	connector = brokerService.addConnector( "auto+nio: autoNioPort = connector.getConnectUri().getPort();	}	if (isUseAutoNioPlusSslConnector()) {	connector = brokerService.addConnector( "auto+nio+ssl: autoNioSslPort = connector.getConnectUri().getPort();	
using auto nio ssl port 

========================= activemq sample_1447 =========================

public void doStart() throws Exception {	if (lockAcquireSleepInterval < lockable.getLockKeepAlivePeriod()) {	
lockableservice keep alive period which renews the lease is greater than lockacquiresleepinterval the lease duration these values will allow the lease to expire 

public void doStart() throws Exception {	if (lockAcquireSleepInterval < lockable.getLockKeepAlivePeriod()) {	}	
attempting to acquire exclusive lease to become the master 

public void doStart() throws Exception {	if (lockAcquireSleepInterval < lockable.getLockKeepAlivePeriod()) {	}	String sql = getStatements().getLeaseObtainStatement();	
locking query is 

statement.setLong(2, now + lockAcquireSleepInterval);	statement.setLong(3, now);	int result = statement.executeUpdate();	if (result == 1) {	if (keepAlive()) {	break;	}	}	reportLeasOwnerShipAndDuration(connection);	} catch (Exception e) {	
lease acquire failure 

if (isStopping()) {	throw new Exception( "Cannot start broker as being asked to shut down. " + "Interrupted attempt to acquire lock: " + e, e);	}	if (handleStartException) {	throw e;	}	} finally {	close(statement);	close(connection);	}	
failed to acquire lease sleeping for milli s before trying again 

}	} finally {	close(statement);	close(connection);	}	TimeUnit.MILLISECONDS.sleep(lockAcquireSleepInterval);	}	if (isStopping()) {	throw new RuntimeException(getLeaseHolderId() + " failing lease acquire due to stop");	}	
becoming master with lease expiry on datasource 

private void reportLeasOwnerShipAndDuration(Connection connection) throws SQLException {	PreparedStatement statement = null;	try {	statement = connection.prepareStatement(getStatements().getLeaseOwnerStatement());	ResultSet resultSet = statement.executeQuery();	while (resultSet.next()) {	
lease held by till 

protected long determineTimeDifference(Connection connection) throws SQLException {	PreparedStatement statement = connection.prepareStatement(getStatements().getCurrentDateTime());	ResultSet resultSet = statement.executeQuery();	long result = 0l;	if (resultSet.next()) {	Timestamp timestamp = resultSet.getTimestamp(1);	long diff = System.currentTimeMillis() - timestamp.getTime();	if (Math.abs(diff) > maxAllowableDiffFromDBTime) {	result = (-diff);	}	
diff adjust from db db time 

private void releaseLease() {	Connection connection = null;	PreparedStatement statement = null;	try {	connection = getConnection();	statement = connection.prepareStatement(getStatements().getLeaseUpdateStatement());	statement.setString(1, null);	statement.setLong(2, 0l);	statement.setString(3, getLeaseHolderId());	if (statement.executeUpdate() == 1) {	
released lease 

PreparedStatement statement = null;	try {	connection = getConnection();	statement = connection.prepareStatement(getStatements().getLeaseUpdateStatement());	statement.setString(1, null);	statement.setLong(2, 0l);	statement.setString(3, getLeaseHolderId());	if (statement.executeUpdate() == 1) {	}	} catch (Exception e) {	
failed to release lease 

public boolean keepAlive() throws IOException {	boolean result = false;	final String sql = getStatements().getLeaseUpdateStatement();	
lease keepalive query is 

setQueryTimeout(statement);	final long now = System.currentTimeMillis() + diffFromCurrentTime;	statement.setString(1, getLeaseHolderId());	statement.setLong(2, now + lockAcquireSleepInterval);	statement.setString(3, getLeaseHolderId());	result = (statement.executeUpdate() == 1);	if (!result) {	reportLeasOwnerShipAndDuration(connection);	}	} catch (Exception e) {	
failed to update lease 

========================= activemq sample_936 =========================

ConsumerBean messageList2 = new ConsumerBean("2:");	ConsumerBean messageList3 = new ConsumerBean("3:");	messageList1.setVerbose(true);	messageList2.setVerbose(true);	messageList3.setVerbose(true);	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination producerDestination = new ActiveMQTopic("VirtualTopic.TEST.A.IT");	Destination destination1 = new ActiveMQQueue("Consumer.1.VirtualTopic.TEST.>");	Destination destination2 = new ActiveMQQueue("Consumer.1.VirtualTopic.TEST.A.IT");	Destination destination3 = new ActiveMQQueue("Consumer.1.VirtualTopic.TEST.B.IT");	
sending to 

ConsumerBean messageList2 = new ConsumerBean("2:");	ConsumerBean messageList3 = new ConsumerBean("3:");	messageList1.setVerbose(true);	messageList2.setVerbose(true);	messageList3.setVerbose(true);	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination producerDestination = new ActiveMQTopic("VirtualTopic.TEST.A.IT");	Destination destination1 = new ActiveMQQueue("Consumer.1.VirtualTopic.TEST.>");	Destination destination2 = new ActiveMQQueue("Consumer.1.VirtualTopic.TEST.A.IT");	Destination destination3 = new ActiveMQQueue("Consumer.1.VirtualTopic.TEST.B.IT");	
consuming from and and 

protected void assertMessagesArrived(final ConsumerBean messageList1, final ConsumerBean messageList2) {	try {	assertTrue("expected", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
one two 

========================= activemq sample_2400 =========================

Thread consumer1Thread = new Thread(new Runnable() {	public void run() {	try {	while (totalConsumed.get() < NUM_MESSAGES) {	Message message = consumer1.receiveNoWait();	if (message != null) {	workQueue.add(message);	}	}	} catch(Exception e) {	
caught an unexpected error 

Thread consumer2Thread = new Thread(new Runnable() {	public void run() {	try {	while (totalConsumed.get() < NUM_MESSAGES) {	Message message = consumer2.receive(50);	if (message != null) {	workQueue.add(message);	}	}	} catch(Exception e) {	
caught an unexpected error 

});	consumer2Thread.start();	Thread producerThread = new Thread(new Runnable() {	public void run() {	try {	for (int i = 0; i < NUM_MESSAGES; ++i) {	producer.send(session.createTextMessage("TEST"));	TimeUnit.MILLISECONDS.sleep(pause.nextInt(10));	}	} catch(Exception e) {	
caught an unexpected error 

});	producerThread.start();	Thread ackingThread = new Thread(new Runnable() {	public void run() {	try {	while (totalConsumed.get() < NUM_MESSAGES) {	Message message = workQueue.take();	message.acknowledge();	totalConsumed.incrementAndGet();	if ((totalConsumed.get() % 100) == 0) {	
consumed messages so far 

public void run() {	try {	while (totalConsumed.get() < NUM_MESSAGES) {	Message message = workQueue.take();	message.acknowledge();	totalConsumed.incrementAndGet();	if ((totalConsumed.get() % 100) == 0) {	}	}	} catch(Exception e) {	
caught an unexpected error 

========================= activemq sample_2953 =========================

protected void testWithMessageCount(int messageCount) throws JMSException {	makeMessages(messageCount);	
about to send and receive on destination of type 

protected void doValidateConsumerPrefetch(String destination, final long expectedCount, final boolean greaterOrEqual) throws JMSException {	RegionBroker regionBroker = (RegionBroker) BrokerRegistry.getInstance().lookup("localhost").getRegionBroker();	for (org.apache.activemq.broker.region.Destination dest : regionBroker.getTopicRegion().getDestinationMap().values()) {	final org.apache.activemq.broker.region.Destination target = dest;	if (dest.getName().equals(destination)) {	try {	Wait.waitFor(new Condition() {	public boolean isSatisified() throws Exception {	DestinationStatistics stats = target.getDestinationStatistics();	
inflight for 

return stats.getInflight().getCount() >= expectedCount;	} else {	return stats.getInflight().getCount() == expectedCount;	}	}	});	} catch (Exception e) {	throw new JMSException(e.toString());	}	DestinationStatistics stats = dest.getDestinationStatistics();	
inflight for 

========================= activemq sample_3641 =========================

ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory( broker.getTransportConnectors().get(0).getPublishableConnectString());	final Connection connection = factory.createConnection();	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(new ActiveMQQueue(getDestinationName()));	long start = System.currentTimeMillis();	for (int idx = 0; idx < MESSAGES_COUNT; ++idx) {	Message message = session.createTextMessage("" + idx);	producer.send(message);	}	
duration millis 

========================= activemq sample_2816 =========================

public void testNewConsumerCausesNewDestinationToBeAutoCreated() throws Exception {	String wildcardText = "org.*" + getDestinationString().substring("org.apache".length());	wildcard = new ActiveMQQueue(wildcardText);	
using wildcard 

public void testNewConsumerCausesNewDestinationToBeAutoCreated() throws Exception {	String wildcardText = "org.*" + getDestinationString().substring("org.apache".length());	wildcard = new ActiveMQQueue(wildcardText);	
on destination 

========================= activemq sample_3704 =========================

public boolean isSatisified() throws Exception {	return brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic")) .getConsumers().size() == 2;	}	});	currentCount = producerTester.getSentCount();	LOG.info(">>>> currently sent: total=" + currentCount + ", AAPL=" + producerTester.getCountForProperty("AAPL") + ", VIX=" + producerTester.getCountForProperty("VIX"));	Thread.sleep(2000);	currentCount = producerTester.getSentCount();	LOG.info(">>>> currently sent: total=" + currentCount + ", AAPL=" + producerTester.getCountForProperty("AAPL") + ", VIX=" + producerTester.getCountForProperty("VIX"));	final long currentDepth = brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic")) .getDestinationStatistics().getMessages().getCount();	
orphaned messages 

========================= activemq sample_3587 =========================

public void testNetworkedBrokerDetach() throws Exception {	
creating consumer on the networked broker 

public void testNetworkedBrokerDetach() throws Exception {	ConnectionFactory consFactory = createConnectionFactory(networkedBroker);	Connection consConn = consFactory.createConnection();	Session consSession = consConn.createSession(false, Session.AUTO_ACKNOWLEDGE);	ActiveMQDestination destination = (ActiveMQDestination) consSession.createQueue(DESTINATION_NAME);	for(int i=0; i<NUM_CONSUMERS; i++) {	consSession.createConsumer(destination);	}	assertTrue("got expected consumer count from mbean within time limit", verifyConsumerCount(1, destination, broker));	
stopping consumer on the networked broker 

public void testNetworkedBrokerDurableSubAfterRestart() throws Exception {	final AtomicInteger count = new AtomicInteger(0);	MessageListener counter = new MessageListener() {	public void onMessage(Message message) {	count.incrementAndGet();	}	};	
creating durable consumer on each broker 

public void onMessage(Message message) {	count.incrementAndGet();	}	};	ActiveMQTopic destination = registerDurableConsumer(networkedBroker, counter);	registerDurableConsumer(broker, counter);	assertTrue("got expected consumer count from local broker mbean within time limit", verifyConsumerCount(2, destination, broker));	assertTrue("got expected consumer count from network broker mbean within time limit", verifyConsumerCount(2, destination, networkedBroker));	sendMessageTo(destination, broker);	assertTrue("Got one message on each", verifyMessageCount(2, count));	
stopping brokertwo 

}	};	ActiveMQTopic destination = registerDurableConsumer(networkedBroker, counter);	registerDurableConsumer(broker, counter);	assertTrue("got expected consumer count from local broker mbean within time limit", verifyConsumerCount(2, destination, broker));	assertTrue("got expected consumer count from network broker mbean within time limit", verifyConsumerCount(2, destination, networkedBroker));	sendMessageTo(destination, broker);	assertTrue("Got one message on each", verifyMessageCount(2, count));	networkedBroker.stop();	networkedBroker.waitUntilStopped();	
restarting broker two 

ActiveMQTopic destination = registerDurableConsumer(networkedBroker, counter);	registerDurableConsumer(broker, counter);	assertTrue("got expected consumer count from local broker mbean within time limit", verifyConsumerCount(2, destination, broker));	assertTrue("got expected consumer count from network broker mbean within time limit", verifyConsumerCount(2, destination, networkedBroker));	sendMessageTo(destination, broker);	assertTrue("Got one message on each", verifyMessageCount(2, count));	networkedBroker.stop();	networkedBroker.waitUntilStopped();	networkedBroker = createNetworkedBroker();	networkedBroker.start();	
recreating durable consumer on the broker after restart 

try {	ObjectName[] destinations;	if (destination.isQueue()) {	destinations = broker.getAdminView().getQueues();	} else {	destinations = broker.getAdminView().getTopics();	}	for (ObjectName name : destinations) {	DestinationViewMBean view = (DestinationViewMBean) broker.getManagementContext().newProxyInstance(name, DestinationViewMBean.class, true);	if (view.getName().equals(destination.getPhysicalName())) {	
consumers for on 

try {	ObjectName[] destinations;	if (destination.isQueue()) {	destinations = broker.getAdminView().getQueues();	} else {	destinations = broker.getAdminView().getTopics();	}	for (ObjectName name : destinations) {	DestinationViewMBean view = (DestinationViewMBean) broker.getManagementContext().newProxyInstance(name, DestinationViewMBean.class, true);	if (view.getName().equals(destination.getPhysicalName())) {	
subs 

private boolean verifyDurableConsumerCount(final long expectedCount, final BrokerService broker) throws Exception {	return Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	boolean result = false;	BrokerView view = broker.getAdminView();	if (view != null) {	ObjectName[] subs = broker.getAdminView().getInactiveDurableTopicSubscribers();	if (subs != null) {	
inactive durable subs on 

========================= activemq sample_2729 =========================

worker3Started.await();	for (int i = 0; i < perBatch; i++) {	Message msgc = session.createTextMessage("hello c");	msgc.setStringProperty("JMSXGroupID", "C");	producer.send(msgc);	}	doneSignal.await();	List<String> workers = new ArrayList<String>(messageCount.keySet());	Collections.sort(workers);	for (String worker : workers) {	
worker received messages from groups 

producer.send(msgb);	}	new Thread(worker2).start();	worker2Started.await();	for (int i = 0; i < perBatch; i++) {	Message msgc = session.createTextMessage("hello a");	msgc.setStringProperty("JMSXGroupID", "C");	producer.send(msgc);	}	doneSignal.await();	
received worker1 messages from groups worker1 

new Thread(worker2).start();	worker2Started.await();	for (int i = 0; i < perBatch; i++) {	Message msgc = session.createTextMessage("hello a");	msgc.setStringProperty("JMSXGroupID", "C");	producer.send(msgc);	}	doneSignal.await();	assertEquals("worker1 received " + messageCount.get("worker1") + " messages from groups " + messageGroups.get("worker1") , 2 * perBatch, messageCount.get("worker1").intValue());	assertEquals("worker1 received " + messageCount.get("worker1") + " messages from groups " + messageGroups.get("worker1") , 2, messageGroups.get("worker1").size());	
received worker2 messages from groups worker2 

public void run() {	try {	startSignal.await();	log.info(workerName);	Session sess = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	MessageConsumer consumer = sess.createConsumer(queueName);	workerStarted.countDown();	while (true) {	if (counters[0] == 0 && counters[1] == 0 && counters[2] == 0) {	doneSignal.countDown();	
done 

if ("A".equals(group)) {	--counters[0];	update(group);	} else if ("B".equals(group)) {	--counters[1];	update(group);	} else if ("C".equals(group)) {	--counters[2];	update(group);	} else {	
unknown group 

========================= activemq sample_3568 =========================

try {	if (!locker.keepAlive()) {	hasLock = false;	}	}	catch (SuppressReplyException ignoreWhileHandlingInProgress) {	}	catch (IOException ignored) {	}	if (!hasLock) {	
lock keepalive failed no longer lock owner with 

========================= activemq sample_4192 =========================

protected void messageSent() throws Exception {	if (++inflightMessageCount == failureCount) {	Thread.sleep(1000);	
master stopped 

public void testVirtualTopicFailover() throws Exception {	MessageConsumer qConsumer = session.createConsumer(new ActiveMQQueue("Consumer.A.VirtualTopic.TA1"));	assertNull("No message there yet", qConsumer.receive(1000));	qConsumer.close();	assertTrue("master is indeed the master", !master.isSlave());	master.stop();	assertTrue("slave started", slaveStarted.await(60, TimeUnit.SECONDS));	assertTrue(!slave.get().isSlave());	
sending post failover message to vt 

public void testAdvisory() throws Exception {	final MessageConsumer advConsumer = session.createConsumer(AdvisorySupport.getMasterBrokerAdvisoryTopic());	final Message[] advisoryMessage = new Message[1];	advisoryMessage[0] = advConsumer.receive(5000);	
received 

public void testAdvisory() throws Exception {	final MessageConsumer advConsumer = session.createConsumer(AdvisorySupport.getMasterBrokerAdvisoryTopic());	final Message[] advisoryMessage = new Message[1];	advisoryMessage[0] = advConsumer.receive(5000);	assertNotNull("Didn't received advisory", advisoryMessage[0]);	master.stop();	assertTrue("slave started", slaveStarted.await(60, TimeUnit.SECONDS));	
slave started 

advisoryMessage[0] = advConsumer.receive(5000);	assertNotNull("Didn't received advisory", advisoryMessage[0]);	master.stop();	assertTrue("slave started", slaveStarted.await(60, TimeUnit.SECONDS));	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	advisoryMessage[0] = advConsumer.receive(500);	return advisoryMessage[0] != null;	}	});	
received 

========================= activemq sample_2416 =========================

subscribers[i] = new DurableSubscriber(i);	subscribers[i].process();	}	msgProducer.join();	subscribers[(subscribers.length - 1)] = new DurableSubscriber((subscribers.length - 1));	subscribers[(subscribers.length - 1)].subscribe();	MsgProducer msgProducer2 = new MsgProducer();	msgProducer2.send();	subscribers[(subscribers.length - 1)].process();	for (int j = 0; j < (subscribers.length - 1); j++) {	
unsubscribing subscriber 

subscribers[(subscribers.length - 1)].subscribe();	MsgProducer msgProducer2 = new MsgProducer();	msgProducer2.send();	subscribers[(subscribers.length - 1)].process();	for (int j = 0; j < (subscribers.length - 1); j++) {	subscribers[j].unsubscribe();	}	final KahaDBPersistenceAdapter pa = (KahaDBPersistenceAdapter) broker.getPersistenceAdapter();	assertTrue("small number of journal files should be left ", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
journal data file count expected actual 

subscribers[(subscribers.length - 1)].process();	for (int j = 0; j < (subscribers.length - 1); j++) {	subscribers[j].unsubscribe();	}	final KahaDBPersistenceAdapter pa = (KahaDBPersistenceAdapter) broker.getPersistenceAdapter();	assertTrue("small number of journal files should be left ", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return pa.getStore().getJournal().getFileMap().size() <= 4;	}	}, TimeUnit.MINUTES.toMillis(3)));	
done 

private void process() throws JMSException {	long end = System.currentTimeMillis() + 20000;	int transCount = 0;	
online 

if (message == null) {	continue;	}	LOG.info("Received Trans[id=" + message.getIntProperty("TRANS") + ", count=" + transCount + "] in " + this + ".");	} while (true);	} finally {	try {	sess.close();	con.close();	} catch (Exception e) {}	
offline 

public void subscribe() throws JMSException{	
SUBSCRIBING 

if (deleteAllMessages) delete(kahadbData);	broker.setPersistent(true);	KahaDBPersistenceAdapter kahadb = new KahaDBPersistenceAdapter();	kahadb.setDirectory(kahadbData);	kahadb.setJournalMaxFileLength(  10 * 1024);	kahadb.setCleanupInterval(5000);	broker.setPersistenceAdapter(kahadb);	broker.addConnector("tcp: broker.getSystemUsage().getMemoryUsage().setLimit(256 * 1024 * 1024);	broker.getSystemUsage().getTempUsage().setLimit(256 * 1024 * 1024);	broker.getSystemUsage().getStoreUsage().setLimit(256 * 1024 * 1024);	
starting broker 

KahaDBPersistenceAdapter kahadb = new KahaDBPersistenceAdapter();	kahadb.setDirectory(kahadbData);	kahadb.setJournalMaxFileLength(  10 * 1024);	kahadb.setCleanupInterval(5000);	broker.setPersistenceAdapter(kahadb);	broker.addConnector("tcp: broker.getSystemUsage().getMemoryUsage().setLimit(256 * 1024 * 1024);	broker.getSystemUsage().getTempUsage().setLimit(256 * 1024 * 1024);	broker.getSystemUsage().getStoreUsage().setLimit(256 * 1024 * 1024);	broker.start();	broker.waitUntilStarted();	
broker started 

========================= activemq sample_3712 =========================

public X509Certificate[] getPeerCertificates() {	X509Certificate[] clientCertChain = null;	try {	if (sslEngine.getSession() != null) {	clientCertChain = (X509Certificate[]) sslEngine.getSession().getPeerCertificates();	}	} catch (SSLPeerUnverifiedException e) {	if (LOG.isTraceEnabled()) {	
failed to get peer certificates 

========================= activemq sample_131 =========================

connection.start();	Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	Destination destination = session.createQueue(queueName);	populateDestination(10, destination, connection, true);	TextMessage msg = null;	MessageConsumer consumer = session.createConsumer(destination);	Exception expectedException = null;	try {	for (int i = 0; i < 5; i++) {	msg = (TextMessage) consumer.receive(5000);	
not redelivered got 

TextMessage msg = null;	MessageConsumer consumer = session.createConsumer(destination);	Exception expectedException = null;	try {	for (int i = 0; i < 5; i++) {	msg = (TextMessage) consumer.receive(5000);	assertNotNull("got the message", msg);	assertTrue("Should not receive the 5th message", i < 4);	}	} catch (Exception e) {	
got expected 

safeCloseConnection(connection);	restartBroker();	connectionFactory = new ActiveMQConnectionFactory(broker.getTransportConnectors().get(0).getPublishableConnectString() + "?jms.prefetchPolicy.all=0");	connection = (ActiveMQConnection) connectionFactory.createConnection();	connection.start();	session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	destination = session.createQueue(queueName);	consumer = session.createConsumer(destination);	for (int i = 0; i < 4; i++) {	msg = (TextMessage) consumer.receive(4000);	
redelivered got 

consumer = session.createConsumer(destination);	for (int i = 0; i < 4; i++) {	msg = (TextMessage) consumer.receive(4000);	assertNotNull("got the message again", msg);	assertEquals("re delivery flag", true, msg.getJMSRedelivered());	assertTrue("redelivery count survives restart", msg.getLongProperty("JMSXDeliveryCount") > 1);	msg.acknowledge();	}	for (int i = 0; i < 6; i++) {	msg = (TextMessage) consumer.receive(4000);	
not redelivered got 

connection.start();	Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	Destination destination = session.createQueue(queueName);	populateDestination(10, destination, connection, true);	TextMessage msg = null;	MessageConsumer consumer = session.createConsumer(destination);	Exception expectedException = null;	try {	for (int i = 0; i < 5; i++) {	msg = (TextMessage) consumer.receive(5000);	
not redelivered got 

TextMessage msg = null;	MessageConsumer consumer = session.createConsumer(destination);	Exception expectedException = null;	try {	for (int i = 0; i < 5; i++) {	msg = (TextMessage) consumer.receive(5000);	assertNotNull("got the message", msg);	assertTrue("Should not receive the 5th message", i < 4);	}	} catch (Exception e) {	
got expected 

assertNotNull("Expecting an exception when updateMessage fails", expectedException);	consumer.close();	safeCloseConnection(connection);	connection = (ActiveMQConnection) connectionFactory.createConnection();	connection.start();	session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	destination = session.createQueue(queueName);	consumer = session.createConsumer(destination);	for (int i = 0; i < 4; i++) {	msg = (TextMessage) consumer.receive(4000);	
redelivered got 

consumer = session.createConsumer(destination);	for (int i = 0; i < 4; i++) {	msg = (TextMessage) consumer.receive(4000);	assertNotNull("got the message again", msg);	assertEquals("re delivery flag on:" + i, true, msg.getJMSRedelivered());	assertTrue("redelivery count survives reconnect for:" + i, msg.getLongProperty("JMSXDeliveryCount") > 1);	msg.acknowledge();	}	for (int i = 0; i < 6; i++) {	msg = (TextMessage) consumer.receive(4000);	
not redelivered got 

assertFalse("not redelivered", msg.getJMSRedelivered());	}	connection.getTransport().narrow(TcpTransport.class).getTransportListener().onException(new IOException("Die"));	connection = (ActiveMQConnection) connectionFactory.createConnection();	connection.start();	session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	destination = session.createQueue(queueName);	consumer = session.createConsumer(destination);	for (int i = 0; i < 5; i++) {	msg = (TextMessage) consumer.receive(4000);	
redelivered got 

consumer = session.createConsumer(destination);	for (int i = 0; i < 5; i++) {	msg = (TextMessage) consumer.receive(4000);	assertNotNull("got the message again", msg);	assertEquals("redelivery flag set on:" + i, true, msg.getJMSRedelivered());	assertTrue("redelivery count survives reconnect for:" + i, msg.getLongProperty("JMSXDeliveryCount") > 1);	msg.acknowledge();	}	for (int i = 0; i < 5; i++) {	msg = (TextMessage) consumer.receive(4000);	
not redelivered got 

========================= activemq sample_2380 =========================

protected void checkTarget(ConnectionMonitor monitor) {	Target targetDTO = pickBestBroker(monitor);	if( targetDTO == null || targetDTO.ids==null) {	
no partition target found for connection 

protected void checkTarget(ConnectionMonitor monitor) {	Target targetDTO = pickBestBroker(monitor);	if( targetDTO == null || targetDTO.ids==null) {	return;	}	if( targetDTO.ids.contains(getBrokerName()) ) {	
we are a partition target for connection 

protected void checkTarget(ConnectionMonitor monitor) {	Target targetDTO = pickBestBroker(monitor);	if( targetDTO == null || targetDTO.ids==null) {	return;	}	if( targetDTO.ids.contains(getBrokerName()) ) {	return;	}	String connectionString = getConnectionString(targetDTO.ids);	if( connectionString==null ) {	
could not convert to partition targets to connection string 

if( targetDTO == null || targetDTO.ids==null) {	return;	}	if( targetDTO.ids.contains(getBrokerName()) ) {	return;	}	String connectionString = getConnectionString(targetDTO.ids);	if( connectionString==null ) {	return;	}	
redirecting connection to 

========================= activemq sample_1406 =========================

public final void acknowledge(final ConnectionContext context,final MessageAck ack) throws Exception {	boolean callDispatchMatched = false;	Destination destination = null;	if (!okForAckAsDispatchDone.await(0l, TimeUnit.MILLISECONDS)) {	
ignoring ack received before dispatch result of failover with an outstanding ack acked messages will be replayed if present on this broker ignored ack 

public final void acknowledge(final ConnectionContext context,final MessageAck ack) throws Exception {	boolean callDispatchMatched = false;	Destination destination = null;	if (!okForAckAsDispatchDone.await(0l, TimeUnit.MILLISECONDS)) {	return;	}	
ack 

callDispatchMatched = true;	break;	}	}	}	for (final MessageReference node : removeList) {	dispatched.remove(node);	getSubscriptionStatistics().getInflightMessageSize().addSize(-node.getSize());	}	if (!callDispatchMatched) {	
could not correlate acknowledgment with dispatched message 

}	}	}	if (callDispatchMatched && destination != null) {	destination.wakeup();	dispatchPending();	if (pending.isEmpty()) {	wakeupDestinationsForDispatch();	}	} else {	
acknowledgment out of sync normally occurs when failover connection reconnects 

md.setTransmitCallback(new TransmitCallback() {	public void onSuccess() {	onDispatch(node, message);	}	public void onFailure() {	Destination nodeDest = (Destination) node.getRegionDestination();	if (nodeDest != null) {	if (node != QueueMessageReference.NULL_MESSAGE) {	nodeDest.getDestinationStatistics().getDispatched().increment();	nodeDest.getDestinationStatistics().getInflight().increment();	
failed to dispatch dispatched inflight 

protected void onDispatch(final MessageReference node, final Message message) {	Destination nodeDest = (Destination) node.getRegionDestination();	if (nodeDest != null) {	if (node != QueueMessageReference.NULL_MESSAGE) {	nodeDest.getDestinationStatistics().getDispatched().increment();	nodeDest.getDestinationStatistics().getInflight().increment();	
dispatched dispatched inflight 

public void setPrefetchSize(int prefetchSize) {	this.info.setPrefetchSize(prefetchSize);	try {	this.dispatchPending();	} catch (Exception e) {	
caught exception during dispatch after prefetch change 

========================= activemq sample_3987 =========================

consumertoAbort.getValue().assertMessagesReceived(1);	ActiveMQDestination amqDest = (ActiveMQDestination)destination;	ObjectName destinationViewMBean = new ObjectName("org.apache.activemq:destinationType=" + (amqDest.isTopic() ? "Topic" : "Queue") +",destinationName=" + amqDest.getPhysicalName() + ",type=Broker,brokerName=localhost");	DestinationViewMBean queue = (DestinationViewMBean) broker.getManagementContext().newProxyInstance(destinationViewMBean, DestinationViewMBean.class, true);	ObjectName slowConsumerPolicyMBeanName = queue.getSlowConsumerStrategy();	assertNotNull(slowConsumerPolicyMBeanName);	AbortSlowConsumerStrategyViewMBean abortPolicy = (AbortSlowConsumerStrategyViewMBean) broker.getManagementContext().newProxyInstance(slowConsumerPolicyMBeanName, AbortSlowConsumerStrategyViewMBean.class, true);	TimeUnit.SECONDS.sleep(3);	TabularData slowOnes = abortPolicy.getSlowConsumers();	assertEquals("one slow consumers", 1, slowOnes.size());	
slow ones 

ActiveMQDestination amqDest = (ActiveMQDestination)destination;	ObjectName destinationViewMBean = new ObjectName("org.apache.activemq:destinationType=" + (amqDest.isTopic() ? "Topic" : "Queue") +",destinationName=" + amqDest.getPhysicalName() + ",type=Broker,brokerName=localhost");	DestinationViewMBean queue = (DestinationViewMBean) broker.getManagementContext().newProxyInstance(destinationViewMBean, DestinationViewMBean.class, true);	ObjectName slowConsumerPolicyMBeanName = queue.getSlowConsumerStrategy();	assertNotNull(slowConsumerPolicyMBeanName);	AbortSlowConsumerStrategyViewMBean abortPolicy = (AbortSlowConsumerStrategyViewMBean) broker.getManagementContext().newProxyInstance(slowConsumerPolicyMBeanName, AbortSlowConsumerStrategyViewMBean.class, true);	TimeUnit.SECONDS.sleep(3);	TabularData slowOnes = abortPolicy.getSlowConsumers();	assertEquals("one slow consumers", 1, slowOnes.size());	CompositeData slowOne = (CompositeData) slowOnes.values().iterator().next();	
slow one 

startConsumers(withPrefetch(2, destination));	for (MessageIdList list : consumers.values()) {	list.setProcessingDelay(6 * 1000);	}	for (Connection c : connections) {	c.setExceptionListener(this);	}	startProducers(destination, 100);	allMessagesList.waitForMessagesToArrive(consumerCount);	for (MessageConsumer consumer : consumers.keySet()) {	
closing consumer 

messageconsumer.receive(4000).acknowledge();	assertNotNull(messageconsumer.receive(4000));	assertNotNull(messageconsumer.receive(4000));	assertNotNull(messageconsumer.receive(4000));	socketProxy.pause();	ActiveMQDestination amqDest = (ActiveMQDestination)destination;	ObjectName destinationViewMBean = new ObjectName("org.apache.activemq:destinationType=" + (amqDest.isTopic() ? "Topic" : "Queue") +",destinationName=" + amqDest.getPhysicalName() + ",type=Broker,brokerName=localhost");	final DestinationViewMBean destView = (DestinationViewMBean) broker.getManagementContext().newProxyInstance(destinationViewMBean, DestinationViewMBean.class, true);	assertTrue("Consumer gone from broker view", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
destview comsumercount 

========================= activemq sample_2441 =========================

public void onMessage(Message message) {	latch.countDown();	if (++count % LOG_INTERVAL == 0) {	
received message 

producer = session.createProducer(session.createQueue("AMQ2401Test"));	}	public void start() {	thread.start();	}	public void run() {	int count = SEND_COUNT / PRODUCER_COUNT;	for (int i = 1; i <= count; i++) {	try {	if ((i % LOG_INTERVAL) == 0) {	
sending 

========================= activemq sample_2912 =========================

randomAccessFile.seek(recoveryPosition.getOffset() + 1);	byte[] data = new byte[getWriteBatchSize()];	ByteSequence bs = new ByteSequence(data, 0, randomAccessFile.read(data));	int nextOffset = 0;	if (findNextBatchRecord(bs, randomAccessFile) >= 0) {	nextOffset = Math.toIntExact(randomAccessFile.getFilePointer() - bs.remaining());	} else {	nextOffset = Math.toIntExact(randomAccessFile.length());	}	Sequence sequence = new Sequence(recoveryPosition.getOffset(), nextOffset - 1);	
corrupt journal records found in between offsets 

DataFile dataFile = new DataFile(file, num);	fileMap.put(dataFile.getDataFileId(), dataFile);	totalLength.addAndGet(dataFile.getLength());	} catch (NumberFormatException e) {	}	}	LinkedList<DataFile> l = new LinkedList<>(fileMap.values());	Collections.sort(l);	for (DataFile df : l) {	if (df.getLength() == 0) {	
ignoring zero length partially initialised journal data file 

int lastFileLength = dataFiles.getTail().getLength();	if (totalLength.get() > lastFileLength && lastAppendLocation.get().getOffset() > 0) {	totalLength.addAndGet(lastAppendLocation.get().getOffset() - lastFileLength);	}	cleanupTask = scheduler.scheduleAtFixedRate(new Runnable() {	public void run() {	cleanup();	}	}, DEFAULT_CLEANUP_INTERVAL, DEFAULT_CLEANUP_INTERVAL, TimeUnit.MILLISECONDS);	long end = System.currentTimeMillis();	
startup took ms 

if (PreallocationStrategy.OS_KERNEL_COPY == preallocationStrategy) {	doPreallocationKernelCopy(file);	} else if (PreallocationStrategy.ZEROS == preallocationStrategy) {	doPreallocationZeros(file);	} else if (PreallocationStrategy.CHUNKED_ZEROS == preallocationStrategy) {	doPreallocationChunkedZeros(file);	} else {	doPreallocationSparseFile(file);	}	} catch (Throwable continueWithNoPrealloc) {	
cound not preallocate journal data file 

try {	FileChannel channel = file.getChannel();	channel.position(0);	channel.write(journalEof);	channel.position(maxFileLength - 5);	journalEof.rewind();	channel.write(journalEof);	channel.force(false);	channel.position(0);	} catch (ClosedByInterruptException ignored) {	
could not preallocate journal file with sparse file 

FileChannel channel = file.getChannel();	channel.position(0);	channel.write(journalEof);	channel.position(maxFileLength - 5);	journalEof.rewind();	channel.write(journalEof);	channel.force(false);	channel.position(0);	} catch (ClosedByInterruptException ignored) {	} catch (IOException e) {	
could not preallocate journal file with sparse file 

private void doPreallocationZeros(RecoverableRandomAccessFile file) {	preAllocateDirectBuffer.rewind();	try {	FileChannel channel = file.getChannel();	channel.write(preAllocateDirectBuffer);	channel.force(false);	channel.position(0);	} catch (ClosedByInterruptException ignored) {	
could not preallocate journal file with zeros 

private void doPreallocationZeros(RecoverableRandomAccessFile file) {	preAllocateDirectBuffer.rewind();	try {	FileChannel channel = file.getChannel();	channel.write(preAllocateDirectBuffer);	channel.force(false);	channel.position(0);	} catch (ClosedByInterruptException ignored) {	} catch (IOException e) {	
could not preallocate journal file with zeros 

private void doPreallocationKernelCopy(RecoverableRandomAccessFile file) {	try (RandomAccessFile templateRaf = new RandomAccessFile(osKernelCopyTemplateFile, "rw");){	templateRaf.getChannel().transferTo(0, getMaxFileLength(), file.getChannel());	} catch (ClosedByInterruptException ignored) {	
could not preallocate journal file with kernel copy 

private void doPreallocationKernelCopy(RecoverableRandomAccessFile file) {	try (RandomAccessFile templateRaf = new RandomAccessFile(osKernelCopyTemplateFile, "rw");){	templateRaf.getChannel().transferTo(0, getMaxFileLength(), file.getChannel());	} catch (ClosedByInterruptException ignored) {	} catch (FileNotFoundException e) {	
could not find the template file on disk at 

private File createJournalTemplateFile() {	String fileName = "db-log.template";	File rc = new File(directory, fileName);	try (RandomAccessFile templateRaf = new RandomAccessFile(rc, "rw");) {	templateRaf.getChannel().write(ByteBuffer.wrap(EOF_RECORD));	templateRaf.setLength(maxFileLength);	templateRaf.getChannel().force(true);	} catch (FileNotFoundException e) {	
could not find the template file on disk at 

if (remLen < preAllocateDirectBuffer.remaining()) {	preAllocateDirectBuffer.limit(remLen);	}	int writeLen = channel.write(preAllocateDirectBuffer);	remLen -= writeLen;	preAllocateDirectBuffer.rewind();	}	channel.force(false);	channel.position(0);	} catch (ClosedByInterruptException ignored) {	
could not preallocate journal file with zeros 

preAllocateDirectBuffer.limit(remLen);	}	int writeLen = channel.write(preAllocateDirectBuffer);	remLen -= writeLen;	preAllocateDirectBuffer.rewind();	}	channel.force(false);	channel.position(0);	} catch (ClosedByInterruptException ignored) {	} catch (IOException e) {	
could not preallocate journal file with zeros will continue without preallocation 

int size = checkBatchRecord(bs, randomAccessFile);	if (size >= 0 && location.getOffset() + BATCH_CONTROL_RECORD_SIZE + size <= totalFileLength) {	if (size == 0) {	break;	}	location.setOffset(location.getOffset() + BATCH_CONTROL_RECORD_SIZE + size);	} else {	if (findNextBatchRecord(bs, randomAccessFile) >= 0) {	int nextOffset = Math.toIntExact(randomAccessFile.getFilePointer() - bs.remaining());	Sequence sequence = new Sequence(location.getOffset(), nextOffset - 1);	
corrupt journal records found in between offsets 

public void run() {	if (nextDataFile == null) {	synchronized (dataFileIdLock){	try {	nextDataFile = newDataFile();	} catch (IOException e) {	
failed to proactively allocate data file 

private void forceRemoveDataFile(DataFile dataFile) throws IOException {	accessorPool.disposeDataFileAccessors(dataFile);	totalLength.addAndGet(-dataFile.getLength());	if (archiveDataLogs) {	File directoryArchive = getDirectoryArchive();	if (directoryArchive.exists()) {	
archive directory exists 

private void forceRemoveDataFile(DataFile dataFile) throws IOException {	accessorPool.disposeDataFileAccessors(dataFile);	totalLength.addAndGet(-dataFile.getLength());	if (archiveDataLogs) {	File directoryArchive = getDirectoryArchive();	if (directoryArchive.exists()) {	} else {	if (directoryArchive.isAbsolute()) if (LOG.isDebugEnabled()) {	
archive directory does not exist creating it now 

accessorPool.disposeDataFileAccessors(dataFile);	totalLength.addAndGet(-dataFile.getLength());	if (archiveDataLogs) {	File directoryArchive = getDirectoryArchive();	if (directoryArchive.exists()) {	} else {	if (directoryArchive.isAbsolute()) if (LOG.isDebugEnabled()) {	}	IOHelper.mkdirs(directoryArchive);	}	
moving data file to 

totalLength.addAndGet(-dataFile.getLength());	if (archiveDataLogs) {	File directoryArchive = getDirectoryArchive();	if (directoryArchive.exists()) {	} else {	if (directoryArchive.isAbsolute()) if (LOG.isDebugEnabled()) {	}	IOHelper.mkdirs(directoryArchive);	}	dataFile.move(directoryArchive);	
successfully moved data file 

if (archiveDataLogs) {	File directoryArchive = getDirectoryArchive();	if (directoryArchive.exists()) {	} else {	if (directoryArchive.isAbsolute()) if (LOG.isDebugEnabled()) {	}	IOHelper.mkdirs(directoryArchive);	}	dataFile.move(directoryArchive);	} else {	
deleting data file 

File directoryArchive = getDirectoryArchive();	if (directoryArchive.exists()) {	} else {	if (directoryArchive.isAbsolute()) if (LOG.isDebugEnabled()) {	}	IOHelper.mkdirs(directoryArchive);	}	dataFile.move(directoryArchive);	} else {	if (dataFile.delete()) {	
discarded data file 

if (directoryArchive.exists()) {	} else {	if (directoryArchive.isAbsolute()) if (LOG.isDebugEnabled()) {	}	IOHelper.mkdirs(directoryArchive);	}	dataFile.move(directoryArchive);	} else {	if (dataFile.delete()) {	} else {	
failed to discard data file 

if (dataFile.getLength() <= cur.getOffset()) {	synchronized (currentDataFile) {	dataFile = dataFile.getNext();	}	if (dataFile == null) {	return null;	} else {	cur.setDataFileId(dataFile.getDataFileId().intValue());	cur.setOffset(0);	if (limit != null && cur.compareTo(limit) >= 0) {	
reached limit at 

cur.setOffset(0);	if (limit != null && cur.compareTo(limit) >= 0) {	return null;	}	}	}	DataFileAccessor reader = accessorPool.openDataFileAccessor(dataFile);	try {	reader.readLocationDetails(cur);	} catch (EOFException eof) {	
eof on next cur 

========================= activemq sample_1778 =========================

public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {	if (jobId != null) {	JobSchedulerViewMBean jobScheduler = getBrokerFacade().getJobScheduler();	if (jobScheduler != null) {	jobScheduler.removeJob(jobId);	
removed scheduled job 

public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {	if (jobId != null) {	JobSchedulerViewMBean jobScheduler = getBrokerFacade().getJobScheduler();	if (jobScheduler != null) {	jobScheduler.removeJob(jobId);	} else {	
scheduler not configured 

========================= activemq sample_1328 =========================

connections[i] = createConnection(i);	connections[i].setClientID("ClusterTest" + i);	connections[i].start();	Session session = connections[i].createSession(false, Session.AUTO_ACKNOWLEDGE);	producers[i] = session.createProducer(destination);	producers[i].setDeliveryMode(deliveryMode);	MessageConsumer consumer = createMessageConsumer(session, destination);	messageIdList[i] = new MessageIdList();	consumer.setMessageListener(messageIdList[i]);	}	
waiting for cluster to be fully connected 

ActiveMQMessage message = (ActiveMQMessage)consumer.receive(1000);	if (message == null) {	fail("Connection " + i + " saw " + j + " consumers, expected: " + NUMBER_IN_CLUSTER);	}	if (message.getDataStructure() != null && message.getDataStructure().getDataStructureType() == ConsumerInfo.DATA_STRUCTURE_TYPE) {	j++;	}	}	session.close();	}	
cluster is online 

protected Connection createConnection(int i) throws JMSException {	
creating connection 

========================= activemq sample_2504 =========================

protected void handleException(Throwable exception, StompFrame command) throws IOException {	if (command == null) {	
exception occurred while processing a command 

protected void handleException(Throwable exception, StompFrame command) throws IOException {	if (command == null) {	} else {	
exception occurred processing 

protected void handleException(Throwable exception, StompFrame command) throws IOException {	if (command == null) {	} else {	}	if (LOG.isDebugEnabled()) {	
exception detail 

protected void handleException(Throwable exception, StompFrame command) throws IOException {	if (command == null) {	} else {	}	if (LOG.isDebugEnabled()) {	}	if (command != null && LOG.isTraceEnabled()) {	
command that caused the error 

StompInactivityMonitor monitor = this.stompTransport.getInactivityMonitor();	monitor.setReadCheckTime((long) (hbReadInterval * hbGracePeriodMultiplier));	monitor.setInitialDelayTime(Math.min(hbReadInterval, hbWriteInterval));	monitor.setWriteCheckTime(hbWriteInterval);	monitor.startMonitoring();	} catch(Exception ex) {	hbReadInterval = 0;	hbWriteInterval = 0;	}	if (LOG.isDebugEnabled()) {	
stomp connect heartbeat conf rw 

protected void sendReceipt(StompFrame command) {	final String receiptId = command.getHeaders().get(Stomp.Headers.RECEIPT_REQUESTED);	if (receiptId != null) {	StompFrame sc = new StompFrame();	sc.setAction(Stomp.Responses.RECEIPT);	sc.setHeaders(new HashMap<String, String>(1));	sc.getHeaders().put(Stomp.Headers.Response.RECEIPT_ID, receiptId);	try {	sendToStomp(sc);	} catch (IOException e) {	
could not send a receipt for 

========================= activemq sample_1451 =========================

public void run() {	running = true;	MessageConsumer consumer = null;	String threadName = Thread.currentThread().getName();	
wait until messages are consumed 

String threadName = Thread.currentThread().getName();	try {	if (durable && destination instanceof Topic) {	consumer = session.createDurableSubscriber((Topic) destination, getName());	} else {	consumer = session.createConsumer(destination);	}	while (running && received < messageCount) {	Message msg = consumer.receive(receiveTimeOut);	if (msg != null) {	
received 

} else {	consumer = session.createConsumer(destination);	}	while (running && received < messageCount) {	Message msg = consumer.receive(receiveTimeOut);	if (msg != null) {	if (bytesAsText && (msg instanceof BytesMessage)) {	long length = ((BytesMessage) msg).getBodyLength();	byte[] bytes = new byte[(int) length];	((BytesMessage) msg).readBytes(bytes);	
bytesmessage as text string 

((BytesMessage) msg).readBytes(bytes);	}	received++;	} else {	if (breakOnNull) {	break;	}	}	if (session.getTransacted()) {	if (batchSize > 0 && received > 0 && received % batchSize == 0) {	
committing transaction 

Thread.sleep(sleep);	}	}	} catch (Exception e) {	e.printStackTrace();	} finally {	if (finished != null) {	finished.countDown();	}	if (consumer != null) {	
consumed messages 

finished.countDown();	}	if (consumer != null) {	try {	consumer.close();	} catch (JMSException e) {	e.printStackTrace();	}	}	}	
consumer thread finished 

========================= activemq sample_166 =========================

Thread consumingThread = new Thread("Consuming thread") {	public void run() {	try {	int count = 0;	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createConsumer(destination);	while (consumer.receive(messageReceiveTimeout) == null) {	consumerReady.countDown();	}	count++;	
received one waiting 

try {	int count = 0;	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createConsumer(destination);	while (consumer.receive(messageReceiveTimeout) == null) {	consumerReady.countDown();	}	count++;	consumerContinue.await();	if (consumeAll) {	
consuming the rest of the messages 

while (consumer.receive(messageReceiveTimeout) == null) {	consumerReady.countDown();	}	count++;	consumerContinue.await();	if (consumeAll) {	while (consumer.receive(messageReceiveTimeout) != null) {	count++;	}	}	
consumer session closing consumed count 

} catch (Throwable ex) {	ex.printStackTrace();	}	}	};	consumingThread.start();	consumerReady.await();	producingThread.start();	producingThread.join();	final long tempUsageBySubscription = broker.getSystemUsage().getTempUsage().getUsage();	
orig usage currentusage 

};	consumingThread.start();	consumerReady.await();	producingThread.start();	producingThread.join();	final long tempUsageBySubscription = broker.getSystemUsage().getTempUsage().getUsage();	assertTrue("some temp store has been used", tempUsageBySubscription != origTempUsage);	consumerContinue.countDown();	consumingThread.join();	connection.close();	
subscription usage endusage 

========================= activemq sample_2787 =========================

consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	}	});	for (int i = 0; i < 10; i++) {	benchmarkNonCallbackRate();	benchmarkCallbackRate();	}	double callbackRate = benchmarkCallbackRate();	double nonCallbackRate = benchmarkNonCallbackRate();	
asynccallback send rate m s 

consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	}	});	for (int i = 0; i < 10; i++) {	benchmarkNonCallbackRate();	benchmarkCallbackRate();	}	double callbackRate = benchmarkCallbackRate();	double nonCallbackRate = benchmarkNonCallbackRate();	
nonasynccallback send rate m s 

========================= activemq sample_2292 =========================

public void testAjaxClientReceivesMessagesWhichAreSentToQueueWhileClientIsPolling() throws Exception {	
testajaxclientreceivesmessageswhicharesenttoqueuewhileclientispolling 

public void testAjaxClientReceivesMessagesWhichAreSentToQueueWhileClientIsPolling() throws Exception {	int port = getPort();	HttpClient httpClient = new HttpClient();	httpClient.start();	
sending listen 

httpClient.start();	String sessionId = subscribe(httpClient, port, "destination=queue: LOG.debug( "SENDING POLL" );	final StringBuffer buf = new StringBuffer();	final CountDownLatch latch = asyncRequest(httpClient, "http: LOG.debug( "SENDING MESSAGES" );	sendMessages(httpClient, port, ("destination=queue: "d1=queue: "d2=queue: LOG.debug( "DONE POSTING MESSAGES" );	latch.await();	String response = buf.toString();	final StringBuffer buf2 = new StringBuffer();	final CountDownLatch latch2 = asyncRequest(httpClient, "http: latch2.await();	String fullResponse = response + buf2.toString();	
full response 

public void testAjaxClientReceivesMessagesWhichAreSentToTopicWhileClientIsPolling() throws Exception {	
testajaxclientreceivesmessageswhicharesenttotopicwhileclientispolling 

public void testAjaxClientReceivesMessagesWhichAreSentToTopicWhileClientIsPolling() throws Exception {	int port = getPort();	HttpClient httpClient = new HttpClient();	httpClient.start();	
sending listen 

HttpClient httpClient = new HttpClient();	httpClient.start();	String sessionId = subscribe(httpClient, port, "destination=topic: LOG.debug( "SENDING POLL" );	final StringBuffer buf = new StringBuffer();	final CountDownLatch latch = asyncRequest(httpClient, "http: LOG.debug( "SENDING MESSAGES" );	sendMessages(httpClient, port, ("destination=topic: "d1=topic: "d2=topic: latch.await();	String response = buf.toString();	final StringBuffer buf2 = new StringBuffer();	final CountDownLatch latch2 = asyncRequest(httpClient, "http: latch2.await();	String fullResponse = response + buf2.toString();	
full response 

public void testAjaxClientReceivesMessagesWhichAreQueuedBeforeClientSubscribes() throws Exception {	
testajaxclientreceivesmessageswhicharequeuedbeforeclientsubscribes 

public void testAjaxClientReceivesMessagesWhichAreQueuedBeforeClientSubscribes() throws Exception {	int port = getPort();	producer.send( session.createTextMessage("test one") );	producer.send( session.createTextMessage("test two") );	producer.send( session.createTextMessage("test three") );	HttpClient httpClient = new HttpClient();	httpClient.start();	
sending listen 

public void testStompMessagesAreReceivedByAjaxClient() throws Exception {	
teststompmessagesarerecievedbyajaxclient 

public void testStompMessagesAreReceivedByAjaxClient() throws Exception {	int port = getPort();	HttpClient httpClient = new HttpClient();	httpClient.start();	
sending listen 

public void testAjaxMessagesAreReceivedByStompClient() throws Exception {	
testajaxmessagesarereceivedbystompclient 

connection.connect("user", "password");	connection.subscribe( "/queue/test" );	StompFrame message;	String allMessageBodies = "";	try {	while( true ) {	message = connection.receive(5000);	allMessageBodies = allMessageBodies +"\n"+ message.getBody();	}	} catch (SocketTimeoutException e) {}	
all message bodies 

public void testAjaxClientMayUseSelectors() throws Exception {	
testajaxclientmayuseselectors 

public void testAjaxClientMayUseSelectors() throws Exception {	int port = getPort();	Message msg = session.createTextMessage("test one");	msg.setStringProperty( "filter", "one" );	producer.send( msg );	msg = session.createTextMessage("test two");	msg.setStringProperty( "filter", "two" );	producer.send( msg );	HttpClient httpClient = new HttpClient();	httpClient.start();	
sending listen 

public void testMultipleAjaxClientsMayExistInTheSameSession() throws Exception {	
testmultipleajaxclientsmayexistinthesamesession 

public void testMultipleAjaxClientsMayExistInTheSameSession() throws Exception {	int port = getPort();	MessageProducer producerA = session.createProducer(session.createQueue("testA"));	MessageProducer producerB = session.createProducer(session.createQueue("testB"));	producerA.send( session.createTextMessage("A1") );	producerA.send( session.createTextMessage("A2") );	producerB.send( session.createTextMessage("B1") );	producerB.send( session.createTextMessage("B2") );	HttpClient httpClient = new HttpClient();	httpClient.start();	
sending listen 

MessageProducer producerA = session.createProducer(session.createQueue("testA"));	MessageProducer producerB = session.createProducer(session.createQueue("testB"));	producerA.send( session.createTextMessage("A1") );	producerA.send( session.createTextMessage("A2") );	producerB.send( session.createTextMessage("B1") );	producerB.send( session.createTextMessage("B2") );	HttpClient httpClient = new HttpClient();	httpClient.start();	String sessionId = subscribe(httpClient, port, "destination=queue: subscribe(httpClient, port, "destination=queue: final StringBuffer buf = new StringBuffer();	final CountDownLatch latch = asyncRequest(httpClient, "http: latch.await();	
clienta response 

producerB.send( session.createTextMessage("B1") );	producerB.send( session.createTextMessage("B2") );	HttpClient httpClient = new HttpClient();	httpClient.start();	String sessionId = subscribe(httpClient, port, "destination=queue: subscribe(httpClient, port, "destination=queue: final StringBuffer buf = new StringBuffer();	final CountDownLatch latch = asyncRequest(httpClient, "http: latch.await();	String expected1 = "<response id='handlerA' destination='queue: String expected2 = "<response id='handlerA' destination='queue: assertContains( expected1, buf.toString() );	assertContains( expected2, buf.toString() );	final StringBuffer buf2 = new StringBuffer();	final CountDownLatch latch2 = asyncRequest(httpClient, "http: latch2.await();	
clientb response 

public void testAjaxClientReceivesMessagesForMultipleTopics() throws Exception {	
testajaxclientreceivesmessagesformultipletopics 

public void testAjaxClientReceivesMessagesForMultipleTopics() throws Exception {	int port = getPort();	HttpClient httpClient = new HttpClient();	httpClient.start();	
sending listen for topic topica 

httpClient.start();	String sessionId = subscribe(httpClient, port, "destination=topic: LOG.debug( "SENDING LISTEN FOR /topic/topicB" );	subscribe(httpClient, port, "destination=topic: final StringBuffer buf = new StringBuffer();	final CountDownLatch latch = asyncRequest(httpClient, "http: LOG.debug( "SENDING MESSAGES" );	sendMessages(httpClient, port, ("destination=topic: "d1=topic: "d2=topic: "d3=topic: LOG.debug( "DONE POSTING MESSAGES" );	latch.await();	String response = buf.toString();	final StringBuffer buf2 = new StringBuffer();	final CountDownLatch latch2 = asyncRequest(httpClient, "http: latch2.await();	String fullResponse = response + buf2.toString();	
full response 

========================= activemq sample_920 =========================

public boolean waitForBridgeFormation(final BrokerService broker, final int min, final int bridgeIndex, long wait) throws Exception {	boolean result = false;	if (!broker.getNetworkConnectors().isEmpty()) {	result = Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	int activeCount = 0;	for (NetworkBridge bridge : broker.getNetworkConnectors().get(bridgeIndex).activeBridges()) {	if (bridge.getRemoteBrokerName() != null) {	
found bridge to on broker 

protected void waitForMinTopicRegionConsumerCount(final String name, final int count) throws Exception {	final BrokerService broker = brokers.get(name).broker;	final TopicRegion topicRegion =  (TopicRegion) ((RegionBroker) broker.getRegionBroker()).getTopicRegion();	assertTrue("found expected consumers in topic region of" + name, Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
topic consumers 

========================= activemq sample_3483 =========================

int len = deliveryBytes.length;	while (len > 0) {	final int decoded = message.decode(deliveryBytes.data, offset, len);	assert decoded > 0 : "Make progress decoding the message";	offset += decoded;	len -= decoded;	}	final AmqpSession session = (AmqpSession) getEndpoint().getSession().getContext();	final ConnectionId connectionId = session.getConnection().getConnectionId();	final Object action = ((AmqpValue) message.getBody()).getValue();	
coordinator received 

final Object action = ((AmqpValue) message.getBody()).getValue();	if (action instanceof Declare) {	Declare declare = (Declare) action;	if (declare.getGlobalId() != null) {	throw new Exception("don't know how to handle a declare /w a set GlobalId");	}	LocalTransactionId txId = session.getConnection().getNextTransactionId();	TransactionInfo txInfo = new TransactionInfo(connectionId, txId, TransactionInfo.BEGIN);	session.getConnection().registerTransaction(txId, this);	sendToActiveMQ(txInfo, null);	
started transaction 

sendToActiveMQ(txInfo, null);	Declared declared = new Declared();	declared.setTxnId(new Binary(toBytes(txId.getValue())));	delivery.disposition(declared);	delivery.settle();	} else if (action instanceof Discharge) {	final Discharge discharge = (Discharge) action;	final LocalTransactionId txId = new LocalTransactionId(connectionId, toLong(discharge.getTxnId()));	final byte operation;	if (discharge.getFail()) {	
rollback transaction 

declared.setTxnId(new Binary(toBytes(txId.getValue())));	delivery.disposition(declared);	delivery.settle();	} else if (action instanceof Discharge) {	final Discharge discharge = (Discharge) action;	final LocalTransactionId txId = new LocalTransactionId(connectionId, toLong(discharge.getTxnId()));	final byte operation;	if (discharge.getFail()) {	operation = TransactionInfo.ROLLBACK;	} else {	
commit transaction 

sendToActiveMQ(txinfo, new ResponseHandler() {	public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {	if (response.isException()) {	ExceptionResponse er = (ExceptionResponse) response;	Rejected rejected = new Rejected();	rejected.setError(new ErrorCondition(Symbol.valueOf("failed"), er.getException().getMessage()));	delivery.disposition(rejected);	} else {	delivery.disposition(Accepted.getInstance());	}	
tx settling 

private void replenishCredit() {	if (getEndpoint().getCredit() <= (getConfiguredReceiverCredit() * .2)) {	
sending more credit to transaction coordinator on session 

========================= activemq sample_1703 =========================

producer.send(message);	}	} catch (Throwable ex) {	ex.printStackTrace();	}	}	};	producingThread.start();	producingThread.join();	DestinationStatistics view = getDestinationStatistics(broker, destination);	
stats size enqueues dequeues dispatched inflight expiries 

producer.send(message);	}	} catch (Throwable ex) {	ex.printStackTrace();	}	}	};	producingThread.start();	producingThread.join();	DestinationStatistics view = getDestinationStatistics(broker, destination);	
stopping broker 

ex.printStackTrace();	}	}	};	producingThread.start();	producingThread.join();	DestinationStatistics view = getDestinationStatistics(broker, destination);	broker.stop();	broker.waitUntilStopped();	Thread.sleep(5000);	
recovering broker 

DestinationStatistics view = getDestinationStatistics(broker, destination);	broker.stop();	broker.waitUntilStopped();	Thread.sleep(5000);	final boolean deleteAllMessages = false;	final boolean usePrefetchExtension = true;	broker = createBroker(deleteAllMessages, usePrefetchExtension, 5000, destination);	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	DestinationStatistics view = getDestinationStatistics(broker, destination);	
stats size enqueues dequeues dispatched inflight expiries 

producingThread.start();	consumerThread.join();	producingThread.join();	final DestinationStatistics view = getDestinationStatistics(broker, destination);	assertTrue("all inflight messages expired ", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return view.getInflight().getCount() == 0;	}	}));	assertEquals("Wrong inFlightCount: ", 0, view.getInflight().getCount());	
stats received enqueues dequeues dispatched inflight expiries 

========================= activemq sample_3694 =========================

AssertionClause firstMessageExpectations = resultEndpoint.message(0);	firstMessageExpectations.header("cheese").isEqualTo(123);	firstMessageExpectations.header("JMSReplyTo").isEqualTo(replyQueue);	firstMessageExpectations.header("JMSCorrelationID").isEqualTo(correlationID);	firstMessageExpectations.header("JMSType").isEqualTo(messageType);	template.sendBodyAndHeader("activemq:test.a", expectedBody, "cheese", 123);	resultEndpoint.assertIsSatisfied();	List<Exchange> list = resultEndpoint.getReceivedExchanges();	Exchange exchange = list.get(0);	Object replyTo = exchange.getIn().getHeader("JMSReplyTo");	
reply to is 

========================= activemq sample_1353 =========================

public synchronized void executePeriodically(final Runnable task, long period) {	TimerTask existing = timerTasks.get(task);	if (existing != null) {	
task already scheduled cancelling and rescheduling 

========================= activemq sample_721 =========================

protected void setUp() throws Exception {	
starting up the test case 

protected void setUp() throws Exception {	super.setUp();	context = new ClassPathXmlApplicationContext("org/apache/activemq/xbean/spring2.xml");	service = (BrokerService) context.getBean("broker");	service.start();	connection = createConnectionFactory().createConnection();	connection.start();	
started up the test case 

protected void tearDown() throws Exception {	connection.close();	service.stop();	context.close();	super.tearDown();	
closed down the test case 

========================= activemq sample_2590 =========================

public void run() {	try {	Thread.sleep(sampler.getDuration() - sampler.getRampDownTime());	} catch (InterruptedException e) {	e.printStackTrace();	} finally {	
ramping down sampler 

========================= activemq sample_1216 =========================

public synchronized boolean hasNext() {	try {	getNextCursor();	} catch (Exception e) {	
failed to get current cursor 

========================= activemq sample_4043 =========================

public void doTestBytesMessageSetPropertyBeforeCopy(Connection connection) throws Exception {	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(name.toString());	MessageConsumer consumer = session.createConsumer(destination);	MessageProducer producer = session.createProducer(destination);	BytesMessage message = session.createBytesMessage();	for (int i=0; i < ITERATIONS; i++) {	long sendTime = System.currentTimeMillis();	message.setLongProperty("sendTime", sendTime);	producer.send(message);	
receiving message 

assertTrue("On message " + i, receivedMessage instanceof BytesMessage);	BytesMessage receivedBytesMessage = (BytesMessage) receivedMessage;	int numElements = 0;	try {	while (true) {	receivedBytesMessage.readBoolean();	numElements++;	}	} catch (Exception ex) {	}	
iteration received message contained boolean values 

public void doTestStreamMessageSetPropertyBeforeCopy(Connection connection) throws Exception {	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(name.toString());	MessageConsumer consumer = session.createConsumer(destination);	MessageProducer producer = session.createProducer(destination);	StreamMessage message = session.createStreamMessage();	for (int i=0; i < ITERATIONS; i++) {	long sendTime = System.currentTimeMillis();	message.setLongProperty("sendTime", sendTime);	producer.send(message);	
receiving message 

assertTrue("On message " + i, receivedMessage instanceof StreamMessage);	StreamMessage receivedStreamMessage = (StreamMessage) receivedMessage;	int numElements = 0;	try {	while (true) {	receivedStreamMessage.readBoolean();	numElements++;	}	} catch (Exception ex) {	}	
iteration received message contained boolean values 

========================= activemq sample_2894 =========================

public void testMessageOrderAfterRollback() throws Exception {	sendMessages(5);	int counter = 0;	while (counter++ < 20) {	
creating connection using prefetch of 

========================= activemq sample_1611 =========================

public void afterPropertiesSet() throws Exception {	if (pooledConnectionFactory == null && transactionManager != null && resourceName != null) {	try {	
trying to build a jcapooledconnectionfactory 

if (pooledConnectionFactory == null && transactionManager != null && resourceName != null) {	try {	JcaPooledConnectionFactory f = new JcaPooledConnectionFactory();	f.setName(resourceName);	f.setTransactionManager((TransactionManager) transactionManager);	f.setMaxConnections(maxConnections);	f.setMaximumActiveSessionPerConnection(maximumActive);	f.setConnectionFactory(connectionFactory);	this.pooledConnectionFactory = f;	} catch (Throwable t) {	
could not create jca enabled connection factory 

f.setTransactionManager((TransactionManager) transactionManager);	f.setMaxConnections(maxConnections);	f.setMaximumActiveSessionPerConnection(maximumActive);	f.setConnectionFactory(connectionFactory);	this.pooledConnectionFactory = f;	} catch (Throwable t) {	}	}	if (pooledConnectionFactory == null && transactionManager != null) {	try {	
trying to build a xapooledconnectionfactory 

}	if (pooledConnectionFactory == null && transactionManager != null) {	try {	XaPooledConnectionFactory f = new XaPooledConnectionFactory();	f.setTransactionManager((TransactionManager) transactionManager);	f.setMaxConnections(maxConnections);	f.setMaximumActiveSessionPerConnection(maximumActive);	f.setConnectionFactory(connectionFactory);	this.pooledConnectionFactory = f;	} catch (Throwable t) {	
could not create xa enabled connection factory 

f.setTransactionManager((TransactionManager) transactionManager);	f.setMaxConnections(maxConnections);	f.setMaximumActiveSessionPerConnection(maximumActive);	f.setConnectionFactory(connectionFactory);	this.pooledConnectionFactory = f;	} catch (Throwable t) {	}	}	if (pooledConnectionFactory == null) {	try {	
trying to build a pooledconnectionfactory 

}	}	if (pooledConnectionFactory == null) {	try {	PooledConnectionFactory f = new PooledConnectionFactory();	f.setMaxConnections(maxConnections);	f.setMaximumActiveSessionPerConnection(maximumActive);	f.setConnectionFactory(connectionFactory);	this.pooledConnectionFactory = f;	} catch (Throwable t) {	
could not create pooled connection factory 

========================= activemq sample_776 =========================

protected Statement withPotentialTimeout(FrameworkMethod frameworkMethod, Object testInstance, Statement next) {	long testTimeout = getOriginalTimeout(frameworkMethod);	if (testTimeout > 0) {	String multiplierString = System.getProperty("org.apache.activemq.junit.testTimeoutMultiplier");	double multiplier = 0.0;	try {	multiplier = Double.parseDouble(multiplierString);	} catch (NullPointerException npe) {	} catch (NumberFormatException nfe) {	
ignoring testtimeoutmultiplier not set to a valid value 

========================= activemq sample_1168 =========================

protected ObjectName assertRegisteredObjectName(String name) throws MalformedObjectNameException, NullPointerException {	ObjectName objectName = new ObjectName(name);	if (mbeanServer.isRegistered(objectName)) {	
bean registered 

========================= activemq sample_2314 =========================

protected void doPreCommit() throws XAException {	try {	fireBeforeCommit();	} catch (Throwable e) {	
pre commit failed 

protected void doPostCommit() throws XAException {	try {	setCommitted(true);	fireAfterCommit();	} catch (Throwable e) {	
post commit failed 

public void setRollbackOnly(Throwable cause) {	if (!isRollbackOnly()) {	
setting rollback only cause 

========================= activemq sample_3856 =========================

config = new File(configDirectory + File.separator + configType + ".xml");	}	try {	config = copy(config);	} catch (IOException e) {	throw new MojoExecutionException(e.getMessage());	}	args[0] = "start";	args[1] = "xbean:" + (config.toURI()).toString();	}	
starting broker with configuration in 

========================= activemq sample_1187 =========================

}	}	public void onAcceptError(Exception error) {	onAcceptError(error, null);	}	private void onAcceptError(Exception error, String remoteHost) {	if (brokerService != null && brokerService.isStopping()) {	LOG.info("Could not accept connection during shutdown {} : {}", (remoteHost == null ? "" : "from " + remoteHost), error);	} else {	LOG.error("Could not accept connection {} : {}", (remoteHost == null ? "" : "from " + remoteHost), error);	
reason 

getServer().start();	DiscoveryAgent da = getDiscoveryAgent();	if (da != null) {	da.registerService(getPublishableConnectString());	da.start();	}	if (enableStatusMonitor) {	this.statusDector = new TransportStatusDetector(this);	this.statusDector.start();	}	
connector started 

public String getPublishableConnectString() throws Exception {	String publishableConnectString = publishedAddressPolicy.getPublishableConnectString(this);	
publishing for broker transport uri 

ss.stop(server);	}	if (this.statusDector != null) {	this.statusDector.stop();	}	for (TransportConnection connection : connections) {	ss.stop(connection);	}	server = null;	ss.throwFirstException();	
connector stopped 

========================= activemq sample_4110 =========================

}	for (Iterator<QueueBrowser> iter = browsers.iterator(); iter.hasNext();) {	QueueBrowser browser = iter.next();	browser.close();	}	if (transactional && !isXa) {	try {	getInternalSession().rollback();	} catch (JMSException e) {	invalidate = true;	
caught exception trying rollback when putting session back into the pool will invalidate 

}	if (transactional && !isXa) {	try {	getInternalSession().rollback();	} catch (JMSException e) {	invalidate = true;	}	}	} catch (JMSException ex) {	invalidate = true;	
caught exception trying close when putting session back into the pool will invalidate 

for (PooledSessionEventListener listener : this.sessionEventListeners) {	listener.onSessionClosed(this);	}	sessionEventListeners.clear();	}	if (invalidate) {	if (sessionHolder != null) {	try {	sessionHolder.close();	} catch (JMSException e1) {	
ignoring exception on close as discarding session 

if (invalidate) {	if (sessionHolder != null) {	try {	sessionHolder.close();	} catch (JMSException e1) {	}	}	try {	sessionPool.invalidateObject(key, sessionHolder);	} catch (Exception e) {	
ignoring exception on invalidateobject as discarding session 

========================= activemq sample_1312 =========================

public void addBuffer(int commandId, Object buffer) {	if (LOG.isDebugEnabled()) {	
adding command id to replay buffer object 

public void replayMessages(int fromCommandId, int toCommandId, Replayer replayer) throws IOException {	if (replayer == null) {	throw new IllegalArgumentException("No Replayer parameter specified");	}	if (LOG.isDebugEnabled()) {	
buffer replaying messages from to 

========================= activemq sample_55 =========================

public void testBrokerConfig() throws Exception {	BrokerService broker;	broker = createBroker("org/apache/activemq/store/leveldb/leveldb.xml");	
Success 

BrokerService broker;	broker = createBroker("org/apache/activemq/store/leveldb/leveldb.xml");	try {	assertEquals("Broker Config Error (brokerName)", "brokerConfigTest", broker.getBrokerName());	assertEquals("Broker Config Error (populateJMSXUserID)", false, broker.isPopulateJMSXUserID());	assertEquals("Broker Config Error (useLoggingForShutdownErrors)", true, broker.isUseLoggingForShutdownErrors());	assertEquals("Broker Config Error (useJmx)", true, broker.isUseJmx());	assertEquals("Broker Config Error (persistent)", true, broker.isPersistent());	assertEquals("Broker Config Error (useShutdownHook)", false, broker.isUseShutdownHook());	assertEquals("Broker Config Error (deleteAllMessagesOnStartup)", true, broker.isDeleteAllMessagesOnStartup());	
Success 

BrokerService broker;	broker = createBroker("org/apache/activemq/store/leveldb/leveldb.xml");	try {	assertEquals("Broker Config Error (brokerName)", "brokerConfigTest", broker.getBrokerName());	assertEquals("Broker Config Error (populateJMSXUserID)", false, broker.isPopulateJMSXUserID());	assertEquals("Broker Config Error (useLoggingForShutdownErrors)", true, broker.isUseLoggingForShutdownErrors());	assertEquals("Broker Config Error (useJmx)", true, broker.isUseJmx());	assertEquals("Broker Config Error (persistent)", true, broker.isPersistent());	assertEquals("Broker Config Error (useShutdownHook)", false, broker.isUseShutdownHook());	assertEquals("Broker Config Error (deleteAllMessagesOnStartup)", true, broker.isDeleteAllMessagesOnStartup());	
should have a specific vm connector vm log info Success 

assertEquals("Broker Config Error (deleteAllMessagesOnStartup)", true, broker.isDeleteAllMessagesOnStartup());	SystemUsage systemUsage = broker.getSystemUsage();	assertTrue("Should have a SystemUsage", systemUsage != null);	assertEquals("SystemUsage Config Error (MemoryUsage.limit)", 1024 * 1024 * 10, systemUsage.getMemoryUsage().getLimit());	assertEquals("SystemUsage Config Error (MemoryUsage.percentUsageMinDelta)", 20, systemUsage.getMemoryUsage().getPercentUsageMinDelta());	assertEquals("SystemUsage Config Error (TempUsage.limit)", 1024 * 1024 * 100, systemUsage.getTempUsage().getLimit());	assertEquals("SystemUsage Config Error (StoreUsage.limit)", 1024 * 1024 * 1024, systemUsage.getStoreUsage().getLimit());	assertEquals("SystemUsage Config Error (StoreUsage.name)", "foo", systemUsage.getStoreUsage().getName());	assertNotNull(systemUsage.getStoreUsage().getStore());	assertTrue(systemUsage.getStoreUsage().getStore() instanceof LevelDBPersistenceAdapter);	
Success 

========================= activemq sample_760 =========================

public void test() throws Exception {	String activemqQueues = "activemq,activemq2";	int consumerWaitForConsumption = 5 * 60 * 1000;	ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	
publisher will publish messages to each queue specified 

public void test() throws Exception {	String activemqQueues = "activemq,activemq2";	int consumerWaitForConsumption = 5 * 60 * 1000;	ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	
building publisher 

public void test() throws Exception {	String activemqQueues = "activemq,activemq2";	int consumerWaitForConsumption = 5 * 60 * 1000;	ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);	
building consumer 

public void test() throws Exception {	String activemqQueues = "activemq,activemq2";	int consumerWaitForConsumption = 5 * 60 * 1000;	ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);	consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);	
starting publisher 

public void test() throws Exception {	String activemqQueues = "activemq,activemq2";	int consumerWaitForConsumption = 5 * 60 * 1000;	ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);	consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);	publisher.start();	
starting consumer 

public void test() throws Exception {	String activemqQueues = "activemq,activemq2";	int consumerWaitForConsumption = 5 * 60 * 1000;	ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);	consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);	publisher.start();	consumer.start();	int distinctPublishedCount = 0;	
waiting for publisher completion 

ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);	consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);	publisher.start();	consumer.start();	int distinctPublishedCount = 0;	publisher.waitForCompletion();	List<String> publishedIds = publisher.getIDs();	distinctPublishedCount = new TreeSet<String>(publishedIds).size();	
publisher complete published distinct ids published 

publisher.start();	consumer.start();	int distinctPublishedCount = 0;	publisher.waitForCompletion();	List<String> publishedIds = publisher.getIDs();	distinctPublishedCount = new TreeSet<String>(publishedIds).size();	long endWait = System.currentTimeMillis() + consumerWaitForConsumption;	while (!consumer.completed() && System.currentTimeMillis() < endWait) {	try {	int secs = (int) (endWait - System.currentTimeMillis()) / 1000;	
waiting for consumer completion time left secs 

List<String> publishedIds = publisher.getIDs();	distinctPublishedCount = new TreeSet<String>(publishedIds).size();	long endWait = System.currentTimeMillis() + consumerWaitForConsumption;	while (!consumer.completed() && System.currentTimeMillis() < endWait) {	try {	int secs = (int) (endWait - System.currentTimeMillis()) / 1000;	Thread.sleep(10000);	} catch (Exception e) {	}	}	
consumer complete shutting down 

distinctPublishedCount = new TreeSet<String>(publishedIds).size();	long endWait = System.currentTimeMillis() + consumerWaitForConsumption;	while (!consumer.completed() && System.currentTimeMillis() < endWait) {	try {	int secs = (int) (endWait - System.currentTimeMillis()) / 1000;	Thread.sleep(10000);	} catch (Exception e) {	}	}	consumer.shutdown();	
consumer stats 

public boolean completed() {	for (List<ConsumerThread> list : threads.values()) {	for (ConsumerThread ct : list) {	if (ct.isAlive()) {	
thread for is still alive 

public void run() {	try {	int count = 0;	while (!shutdown) {	if (idList.size() >= totalToExpect) {	
got for q 

count++;	if (count == batchSize) {	session.commit();	count = 0;	}	} else {	session.commit();	count = 0;	try {	if (idList.size() < totalToExpect) {	
did not receive on current count 

========================= activemq sample_2882 =========================

public void run() {	try {	consumer.call();	} catch (Throwable e) {	e.printStackTrace();	workerError[0] = e;	}	}	}.start();	}	
waiting for producers and consumers to startup 

try {	consumer.call();	} catch (Throwable e) {	e.printStackTrace();	workerError[0] = e;	}	}	}.start();	}	connectionsEstablished.acquire();	
producers and consumers are now running waiting for system to reach steady state seconds 

consumer.call();	} catch (Throwable e) {	e.printStackTrace();	workerError[0] = e;	}	}	}.start();	}	connectionsEstablished.acquire();	Thread.sleep(1000 * 10);	
starting sample each lasting seconds 

connectionsEstablished.acquire();	Thread.sleep(1000 * 10);	for (int i = 0; i < SAMPLES; i++) {	long start = System.currentTimeMillis();	producedMessages.set(0);	receivedMessages.set(0);	Thread.sleep(SAMPLE_DURATION);	long end = System.currentTimeMillis();	int r = receivedMessages.get();	int p = producedMessages.get();	
published msgs at msgs sec consumed msgs at msgs sec 

Thread.sleep(1000 * 10);	for (int i = 0; i < SAMPLES; i++) {	long start = System.currentTimeMillis();	producedMessages.set(0);	receivedMessages.set(0);	Thread.sleep(SAMPLE_DURATION);	long end = System.currentTimeMillis();	int r = receivedMessages.get();	int p = producedMessages.get();	}	
sample done 

========================= activemq sample_2752 =========================

consumer.close();	producer.close();	tempQueue.delete();	}	AdvisoryBroker ab = (AdvisoryBroker) broker.getBroker().getAdaptor( AdvisoryBroker.class);	assertTrue(ab.getAdvisoryDestinations().size() == 0);	assertTrue(ab.getAdvisoryConsumers().size() == 0);	assertTrue(ab.getAdvisoryProducers().size() == 0);	RegionBroker rb = (RegionBroker) broker.getBroker().getAdaptor(RegionBroker.class);	for (Destination dest : rb.getDestinationMap().values()) {	
destination 

consumer.close();	producer.close();	tempTopic.delete();	}	AdvisoryBroker ab = (AdvisoryBroker) broker.getBroker().getAdaptor( AdvisoryBroker.class);	assertTrue(ab.getAdvisoryDestinations().size() == 0);	assertTrue(ab.getAdvisoryConsumers().size() == 0);	assertTrue(ab.getAdvisoryProducers().size() == 0);	RegionBroker rb = (RegionBroker) broker.getBroker().getAdaptor( RegionBroker.class);	for (Destination dest : rb.getDestinationMap().values()) {	
destination 

========================= activemq sample_3513 =========================

public void start() throws Exception {	
starting a network connection between and has been established 

protected void triggerStartBridge() throws IOException {	Thread thead = new Thread() {	public void run() {	try {	startBridge();	} catch (IOException e) {	
failed to start network bridge 

public void serviceRemoteException(Throwable error) {	
unexpected remote exception 

public void serviceRemoteException(Throwable error) {	
exception trace 

protected void serviceRemoteCommand(Command command) {	try {	if (command.isBrokerInfo()) {	synchronized (this) {	remoteBrokerInfo = (BrokerInfo)command;	remoteBrokerId = remoteBrokerInfo.getBrokerId();	if (localBrokerId != null) {	if (localBrokerId.equals(remoteBrokerId)) {	
disconnecting loop back connection 

remoteBrokerId = remoteBrokerInfo.getBrokerId();	if (localBrokerId != null) {	if (localBrokerId.equals(remoteBrokerId)) {	ServiceSupport.dispose(this);	} else {	triggerStartBridge();	}	}	}	} else {	
unexpected remote command 

public void serviceLocalException(Throwable error) {	
unexpected local exception 

public void serviceLocalException(Throwable error) {	
exception trace 

}	};	remoteBroker.asyncRequest(message, callback);	}	} else if (command.isBrokerInfo()) {	synchronized (this) {	localBrokerInfo = (BrokerInfo)command;	localBrokerId = localBrokerInfo.getBrokerId();	if (remoteBrokerId != null) {	if (remoteBrokerId.equals(localBrokerId)) {	
disconnecting loop back connection 

localBrokerId = localBrokerInfo.getBrokerId();	if (remoteBrokerId != null) {	if (remoteBrokerId.equals(localBrokerId)) {	ServiceSupport.dispose(this);	} else {	triggerStartBridge();	}	}	}	} else {	
unexpected local command 

========================= activemq sample_4239 =========================

writer.writeProperties("tpSamplerSettings", ReflectionUtil.retrieveObjectProperties(tpSampler));	samplers.add(tpSampler);	}	if (requestedSamplers.contains(JmsClientSystemProperties.SAMPLER_CPU)) {	CpuSamplerTask cpuSampler = new CpuSamplerTask();	writer.writeProperties("cpuSamplerSettings", ReflectionUtil.retrieveObjectProperties(cpuSampler));	try {	cpuSampler.createPlugin();	samplers.add(cpuSampler);	} catch (IOException e) {	
unable to start cpu sampler plugin reason 

int numClients = getSysTest().getNumClients();	final CountDownLatch clientCompletionLatch = new CountDownLatch(numClients);	for (int i = 0; i < numClients; i++) {	distributeDestinations(getSysTest().getDestDistro(), i, numClients, getSysTest().getTotalDests());	final String clientName = getSysTest().getClientPrefix() + i;	final int clientDestIndex = this.clientDestIndex;	final int clientDestCount = this.clientDestCount;	Thread t = new Thread(clientThreadGroup, new Runnable() {	public void run() {	runJmsClient(clientName, clientDestIndex, clientDestCount);	
client completed 

t.setName(getSysTest().getClientPrefix() + i + " Thread");	t.start();	}	final CountDownLatch samplerCompletionLatch = new CountDownLatch(requestedSamplers.size());	for (PerformanceSampler sampler : samplers) {	sampler.setPerfReportWriter(writer);	sampler.startSampler(samplerCompletionLatch, getClientRunBasis(), getClientRunDuration());	}	try {	clientCompletionLatch.await();	
all clients completed 

clientCompletionLatch.await();	} catch (InterruptedException e) {	e.printStackTrace();	} finally {	if (getClientRunBasis() == ClientRunBasis.count) {	for (PerformanceSampler sampler : samplers) {	sampler.finishSampling();	}	}	try {	
waiting for samplers to shut down 

} catch (InterruptedException e) {	e.printStackTrace();	} finally {	if (getClientRunBasis() == ClientRunBasis.count) {	for (PerformanceSampler sampler : samplers) {	sampler.finishSampling();	}	}	try {	samplerCompletionLatch.await();	
all samplers completed 

} else {	nextIndex = (clientIndex * destPerClient) + remain;	}	clientDestCount = destPerClient;	clientDestIndex = nextIndex;	} else {	clientDestCount = 1;	clientDestIndex = clientIndex % numDests;	}	} else {	
unknown destination distribution type 

protected ConnectionFactory loadJmsFactory(String spiClass, Properties factorySettings) throws JMSException {	try {	Class<?> spi = Class.forName(spiClass);	SPIConnectionFactory spiFactory = (SPIConnectionFactory)spi.newInstance();	ConnectionFactory jmsFactory = spiFactory.createConnectionFactory(factorySettings);	
created using spiconnectionfactory 

val += ".properties";	}	configFile = new File(val);	}	props.setProperty(key, val);	}	Properties fileProps = new Properties();	try {	if (configFile != null) {	try(FileInputStream inputStream = new FileInputStream(configFile)) {	
loading properties file 

========================= activemq sample_1191 =========================

public void testVerifySessionCloseRedeliveryWithFailoverTransport() throws Throwable {	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageConsumer consumer = session.createConsumer(destination);	Message message = consumer.receive(1000);	String id = message.getJMSMessageID();	assertNotNull(message);	
got message 

public void testVerifyConsumerAndSessionCloseRedeliveryWithFailoverTransport() throws Throwable {	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageConsumer consumer = session.createConsumer(destination);	Message message = consumer.receive(1000);	String id = message.getJMSMessageID();	assertNotNull(message);	
got message 

public void testVerifyConsumerCloseSessionRollbackRedeliveryWithFailoverTransport() throws Throwable {	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageConsumer consumer = session.createConsumer(destination);	Message message = consumer.receive(1000);	String id = message.getJMSMessageID();	assertNotNull(message);	
got message 

========================= activemq sample_2617 =========================

int i;	public void run() {	while (keepGoing.get()) {	done.set(false);	fillerStarted.countDown();	try {	producer.send(session.createTextMessage(oneKb + ++i));	if (i%10 == 0) {	session.commit();	sent.getAndAdd(10);	
committed sent 

public void run() {	while (keepGoing.get()) {	done.set(false);	fillerStarted.countDown();	try {	producer.send(session.createTextMessage(oneKb + ++i));	if (i%10 == 0) {	session.commit();	sent.getAndAdd(10);	}	
sent 

assertTrue("filler started..", fillerStarted.await(20, TimeUnit.SECONDS));	waitForBlocked(done);	connection = (ActiveMQConnection)factory.createConnection();	connections.add(connection);	connection.start();	TextMessage msg;	int received = 0;	for (;received < sent.get(); ++received) {	msg = (TextMessage) consumer.receive(4000);	if (msg == null) {	
received null on count 

connection = (ActiveMQConnection)factory.createConnection();	connections.add(connection);	connection.start();	TextMessage msg;	int received = 0;	for (;received < sent.get(); ++received) {	msg = (TextMessage) consumer.receive(4000);	if (msg == null) {	break;	}	
received msg 

connection.start();	TextMessage msg;	int received = 0;	for (;received < sent.get(); ++received) {	msg = (TextMessage) consumer.receive(4000);	if (msg == null) {	break;	}	if (received%5==0) {	if (received%3==0) {	
rollback on 

int received = 0;	for (;received < sent.get(); ++received) {	msg = (TextMessage) consumer.receive(4000);	if (msg == null) {	break;	}	if (received%5==0) {	if (received%3==0) {	consumerSession.rollback();	} else {	
commit on 

break;	}	if (received%5==0) {	if (received%3==0) {	consumerSession.rollback();	} else {	consumerSession.commit();	}	}	}	
done sent received 

protected void waitForBlocked(final AtomicBoolean done) throws InterruptedException {	while (true) {	Thread.sleep(1000);	if (done.get()) {	
blocked 

========================= activemq sample_2990 =========================

private void startConsumers() {	ActiveMQConnectionFactory connFactory = new ActiveMQConnectionFactory(userName, password, brokerURL);	Connection conn;	try {	conn = connFactory.createConnection();	conn.start();	for (int i = 0; i < consumerCount; i++) {	new ConsumerThread(conn, "ConsumerThread"+i);	}	} catch (JMSException e) {	
failed to start consumers 

public ConsumerThread(Connection conn, String name) {	super();	this.setName(name);	
created new consumer thread 

public ConsumerThread(Connection conn, String name) {	super();	this.setName(name);	try {	session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	consumer = session.createConsumer(dest);	start();	} catch (JMSException e) {	
failed to start consumer thread 

if (nullCount > 10) {	break;	} else {	continue;	}	} else {	nullCount = 0;	}	Thread.sleep(100);	if (logger.isTraceEnabled()) {	
message received 

continue;	}	} else {	nullCount = 0;	}	Thread.sleep(100);	if (logger.isTraceEnabled()) {	}	msgCount++;	} catch (JMSException e) {	
failed to consume 

}	} else {	nullCount = 0;	}	Thread.sleep(100);	if (logger.isTraceEnabled()) {	}	msgCount++;	} catch (JMSException e) {	} catch (InterruptedException e) {	
interrupted 

if (logger.isTraceEnabled()) {	}	msgCount++;	} catch (JMSException e) {	} catch (InterruptedException e) {	}	}	try {	consumer.close();	} catch (JMSException e) {	
failed to close consumer 

} catch (JMSException e) {	} catch (InterruptedException e) {	}	}	try {	consumer.close();	} catch (JMSException e) {	}	consumedCount.addAndGet(msgCount);	consumerLatch.countDown();	
consumed messages using thread 

public ProducerThread(ActiveMQConnectionFactory connFactory, int count, String name) {	super();	this.count = count;	this.setName(name);	
created new producer thread 

super();	this.count = count;	this.setName(name);	try {	conn = connFactory.createConnection();	conn.start();	session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	producer = session.createProducer(dest);	start();	} catch (JMSException e) {	
failed to start producer thread 

int i = 0;	try {	for (; i < count; i++) {	producer.send(session.createTextMessage(msgStr));	Thread.sleep(500);	}	conn.close();	} catch (JMSException e) {	logger.error(e.getMessage(), e);	} catch (InterruptedException e) {	
interrupted 

Thread.sleep(500);	}	conn.close();	} catch (JMSException e) {	logger.error(e.getMessage(), e);	} catch (InterruptedException e) {	}	sentCount.addAndGet(i);	producerLatch.countDown();	if (logger.isTraceEnabled()) {	
sent messages from thread 

========================= activemq sample_3682 =========================

waitForBridgeFormation(a, 1, 0);	waitForBridgeFormation(b, 1, 0);	ActiveMQConnectionFactory sendFactory = createConnectionFactory(a);	ActiveMQConnection sendConnection = createConnection(sendFactory);	ActiveMQSession sendSession = (ActiveMQSession)sendConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = sendSession.createProducer(sendQ);	ActiveMQTempQueue realReplyQ = (ActiveMQTempQueue) sendSession.createTemporaryQueue();	TextMessage message = sendSession.createTextMessage("1");	message.setJMSReplyTo(realReplyQ);	producer.send(message);	
request sent 

ActiveMQTempQueue realReplyQ = (ActiveMQTempQueue) sendSession.createTemporaryQueue();	TextMessage message = sendSession.createTextMessage("1");	message.setJMSReplyTo(realReplyQ);	producer.send(message);	ActiveMQConnectionFactory consumerFactory = createConnectionFactory(b);	ActiveMQConnection consumerConnection = createConnection(consumerFactory);	ActiveMQSession consumerSession = (ActiveMQSession)consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = consumerSession.createConsumer(sendQ);	TextMessage received = (TextMessage) consumer.receive(receiveTimeout);	assertNotNull("got request from sender ok", received);	
got request sending reply 

TextMessage received = (TextMessage) consumer.receive(receiveTimeout);	assertNotNull("got request from sender ok", received);	MessageProducer consumerProducer = consumerSession.createProducer(received.getJMSReplyTo());	consumerProducer.send(consumerSession.createTextMessage("got " + received.getText()));	consumerConnection.close();	MessageConsumer replyConsumer = sendSession.createConsumer(realReplyQ);	TextMessage reply = (TextMessage) replyConsumer.receive(receiveTimeout);	assertNotNull("expected reply message", reply);	assertEquals("text is as expected", "got 1", reply.getText());	sendConnection.close();	
checking for dangling temp destinations 

MessageConsumer replyConsumer = sendSession.createConsumer(realReplyQ);	TextMessage reply = (TextMessage) replyConsumer.receive(receiveTimeout);	assertNotNull("expected reply message", reply);	assertEquals("text is as expected", "got 1", reply.getText());	sendConnection.close();	for (BrokerService brokerService : brokers) {	final RegionBroker regionBroker = (RegionBroker) brokerService.getRegionBroker();	assertTrue("all temps are gone on " + regionBroker.getBrokerName(), Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception {	Map<?,?> tempTopics = regionBroker.getTempTopicRegion().getDestinationMap();	
temp topics on 

TextMessage reply = (TextMessage) replyConsumer.receive(receiveTimeout);	assertNotNull("expected reply message", reply);	assertEquals("text is as expected", "got 1", reply.getText());	sendConnection.close();	for (BrokerService brokerService : brokers) {	final RegionBroker regionBroker = (RegionBroker) brokerService.getRegionBroker();	assertTrue("all temps are gone on " + regionBroker.getBrokerName(), Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception {	Map<?,?> tempTopics = regionBroker.getTempTopicRegion().getDestinationMap();	Map<?,?> tempQ = regionBroker.getTempQueueRegion().getDestinationMap();	
temp queues on 

========================= activemq sample_3728 =========================

protected void initializeStreams() throws IOException {	channel = socket.getChannel();	channel.configureBlocking(false);	selection = SelectorManager.getInstance().register(channel, new SelectorManager.Listener() {	public void onSelect(SelectorSelection selection) {	if (!isStopped()) {	serviceRead();	}	}	public void onError(SelectorSelection selection, Throwable error) {	
error detected 

========================= activemq sample_1715 =========================

private Mechanism findMatchingMechanism(String...remoteMechanisms) {	Mechanism match = null;	List<Mechanism> found = new ArrayList<Mechanism>();	for (String remoteMechanism : remoteMechanisms) {	if(mechanismRestriction != null && !mechanismRestriction.equals(remoteMechanism)) {	
skipping mechanism because it is not the configured mechanism restriction 

continue;	}	Mechanism mechanism = null;	if (remoteMechanism.equalsIgnoreCase("PLAIN")) {	mechanism = new PlainMechanism();	} else if (remoteMechanism.equalsIgnoreCase("ANONYMOUS")) {	mechanism = new AnonymousMechanism();	} else if (remoteMechanism.equalsIgnoreCase("CRAM-MD5")) {	mechanism = new CramMD5Mechanism();	} else {	
unknown remote mechanism skipping 

continue;	}	if (mechanism.isApplicable(username, password)) {	found.add(mechanism);	}	}	if (!found.isEmpty()) {	Collections.sort(found);	match = found.get(found.size() - 1);	}	
best match for sasl auth was 

========================= activemq sample_1650 =========================

protected void setUp() throws Exception {	
starting up the test case 

protected void setUp() throws Exception {	super.setUp();	connection = connectionFactory.createConnection();	connection.start();	
started up the test case 

protected void tearDown() throws Exception {	connection.close();	super.tearDown();	
closed down the test case 

========================= activemq sample_2586 =========================

public void testPerformance() throws Exception {	ConnectionFactory factory = createConnectionFactory();	List<Connection> list = new ArrayList<Connection>();	for (int i = 0; i < CONNECTION_COUNT; i++) {	Connection connection = factory.createConnection();	connection.start();	list.add(connection);	
created 

========================= activemq sample_3544 =========================

public void testDestinationGcAnonymousProducer() throws Exception {	final ActiveMQQueue q = new ActiveMQQueue("Q.TEST.ANONYMOUS.PRODUCER");	brokerService.getAdminView().addQueue(q.getPhysicalName());	assertEquals(2, brokerService.getAdminView().getQueues().length);	final ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("vm: final Connection connection = factory.createConnection();	final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	
waiting for to be marked for gc 

final ActiveMQQueue q = new ActiveMQQueue("Q.TEST.ANONYMOUS.PRODUCER");	brokerService.getAdminView().addQueue(q.getPhysicalName());	assertEquals(2, brokerService.getAdminView().getQueues().length);	final ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("vm: final Connection connection = factory.createConnection();	final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Wait.waitFor(new Condition() {	public boolean isSatisified() throws Exception {	return brokerService.getDestination(q).canGC();	}	}, Wait.MAX_WAIT_MILLIS, 500L);	
sending persistent message to queue 

========================= activemq sample_2355 =========================

}	});	assertTrue("locker failed to obtain lock", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return logCounts.get() > 0;	}	}, 5000, 10));	long releaseTime = System.currentTimeMillis();	System.getProperties().remove(jvmProp);	assertTrue("locker got lock", locked.await(5, TimeUnit.SECONDS));	
releasetime acquiretime 

========================= activemq sample_3817 =========================

public void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	connection = createConnection();	if (durable) {	connection.setClientID(getClass().getName());	}	
created connection 

public void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	connection = createConnection();	if (durable) {	connection.setClientID(getClass().getName());	}	session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	
created session 

connection.setClientID(getClass().getName());	}	session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	if (topic) {	consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	} else {	consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	}	
created consumer destination of type 

connection.setClientID(getClass().getName());	}	session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	if (topic) {	consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	} else {	consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	}	
created producer destination of type 

protected MessageConsumer createConsumer(String selector) throws JMSException {	if (durable) {	
creating durable consumer 

========================= activemq sample_2640 =========================

private void sendMessageToQueueUsingAmqp() throws Exception {	Connection connection = createAmqpConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue(getQueueName());	MessageProducer producer = session.createProducer(queue);	try {	TextMessage message = session.createTextMessage("test-message-amqp-source");	producer.send(message);	
send amqp message with message id 

private void sendMessageToQueueUsingStomp() throws Exception {	Connection connection = createStompConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue(getQueueName());	MessageProducer producer = session.createProducer(queue);	try {	TextMessage message = session.createTextMessage("test-message-stomp-source");	producer.send(message);	
send stomp message with message id 

========================= activemq sample_1596 =========================

final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	final MessageProducer producer = session.createProducer(queue);	producer.setTimeToLive(10L);	executors.submit(new Runnable() {	public void run() {	try {	Thread.sleep(100);	int count = 0;	while (!failed.get() && count < 30) {	producer.send(session.createTextMessage("Hello World: " + count));	
sending 

public void onMessage(Message message) {	try {	Thread.sleep(1000L);	String text = ((TextMessage) message).getText();	
got message 

public void onMessage(Message message) {	try {	Thread.sleep(1000L);	String text = ((TextMessage) message).getText();	} catch (Exception e) {	
in onmessage 

========================= activemq sample_3476 =========================

public static void main(String[] args) {	String destinationName = null;	Context jndiContext = null;	ConnectionFactory connectionFactory = null;	Connection connection = null;	Session session = null;	Destination destination = null;	MessageConsumer consumer = null;	if (args.length != 1) {	
usage java simpleconsumer destination name 

Context jndiContext = null;	ConnectionFactory connectionFactory = null;	Connection connection = null;	Session session = null;	Destination destination = null;	MessageConsumer consumer = null;	if (args.length != 1) {	System.exit(1);	}	destinationName = args[0];	
destination name is 

Session session = null;	Destination destination = null;	MessageConsumer consumer = null;	if (args.length != 1) {	System.exit(1);	}	destinationName = args[0];	try {	jndiContext = new InitialContext();	} catch (NamingException e) {	
could not create jndi api context 

destinationName = args[0];	try {	jndiContext = new InitialContext();	} catch (NamingException e) {	System.exit(1);	}	try {	connectionFactory = (ConnectionFactory)jndiContext.lookup("ConnectionFactory");	destination = (Destination)jndiContext.lookup(destinationName);	} catch (NamingException e) {	
jndi api lookup failed 

try {	connection = connectionFactory.createConnection();	session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	consumer = session.createConsumer(destination);	connection.start();	while (true) {	Message m = consumer.receive(1);	if (m != null) {	if (m instanceof TextMessage) {	TextMessage message = (TextMessage)m;	
reading message 

Message m = consumer.receive(1);	if (m != null) {	if (m instanceof TextMessage) {	TextMessage message = (TextMessage)m;	} else {	break;	}	}	}	} catch (JMSException e) {	
exception occurred 

========================= activemq sample_2267 =========================

public void onMessage(Message message) {	try {	
message received 

public void onMessage(Message message) {	try {	counter++;	if (counter <= 4) {	
message rollback 

public void onMessage(Message message) {	try {	counter++;	if (counter <= 4) {	session.rollback();	} else {	
message commit 

public void onMessage(Message message) {	try {	counter++;	if (counter <= 4) {	session.rollback();	} else {	message.acknowledge();	session.commit();	}	} catch (JMSException e) {	
error when rolling back transaction 

producer.send(message);	message = createTextMessage(session, "2");	producer.send(message);	MessageConsumer consumer = session.createConsumer(queue);	final CountDownLatch gotMessage = new CountDownLatch(2);	final AtomicInteger count = new AtomicInteger(0);	final int maxDeliveries = getRedeliveryPolicy().getMaximumRedeliveries();	final ArrayList<String> received = new ArrayList<String>();	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	
message received 

Queue queue = session.createQueue("queue-" + getTestName());	MessageProducer producer = createProducer(session, queue);	Message message = createTextMessage(session);	producer.send(message);	final Message[] dlqMessage = new Message[1];	ActiveMQDestination dlqDestination = new ActiveMQQueue("ActiveMQ.DLQ");	MessageConsumer dlqConsumer = session.createConsumer(dlqDestination);	final CountDownLatch gotDlqMessage = new CountDownLatch(1);	dlqConsumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	
dlq message received 

public void onMessage(Message message) {	dlqMessage[0] = message;	gotDlqMessage.countDown();	}	});	MessageConsumer consumer = session.createConsumer(queue);	final int maxDeliveries = getRedeliveryPolicy().getMaximumRedeliveries();	final CountDownLatch gotMessage = new CountDownLatch(maxDeliveries);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	
message received 

public void onMessage(Message message) {	gotMessage.countDown();	throw new RuntimeException(getTestName() + " force a redelivery");	}	});	assertTrue("got message before retry expiry", gotMessage.await(20, TimeUnit.SECONDS));	assertTrue("got dlq message", gotDlqMessage.await(20, TimeUnit.SECONDS));	message = dlqMessage[0];	assertNotNull("dlq message captured", message);	String cause = message.getStringProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY);	
dlq d message cause reported as 

MessageProducer producer = createProducer(session, queue);	Message message = createTextMessage(session);	producer.send(message);	session.commit();	final Message[] dlqMessage = new Message[1];	ActiveMQDestination dlqDestination = new ActiveMQQueue("ActiveMQ.DLQ");	MessageConsumer dlqConsumer = session.createConsumer(dlqDestination);	final CountDownLatch gotDlqMessage = new CountDownLatch(1);	dlqConsumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	
dlq message received 

public void onMessage(Message message) {	dlqMessage[0] = message;	gotDlqMessage.countDown();	}	});	MessageConsumer consumer = session.createConsumer(queue);	final int maxDeliveries = getRedeliveryPolicy().getMaximumRedeliveries();	final CountDownLatch gotMessage = new CountDownLatch(maxDeliveries);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	
message received 

e.printStackTrace();	}	throw new RuntimeException(getTestName() + " force a redelivery");	}	});	assertTrue("got message before retry expiry", gotMessage.await(20, TimeUnit.SECONDS));	assertTrue("got dlq message", gotDlqMessage.await(20, TimeUnit.SECONDS));	message = dlqMessage[0];	assertNotNull("dlq message captured", message);	String cause = message.getStringProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY);	
dlq d message cause reported as 

========================= activemq sample_2288 =========================

}	}));	for (int count = 0; count < 10; count++) {	Thread.sleep(5000);	final int i = (int) (Math.random() * consumerThreads.size());	final ThreadSlot slot = consumerThreads.get(i);	slot.thread.interrupt();	consumerThreads.remove(i);	consumerThreads.add(runInThread(slot.runnable));	Queue queue = (Queue) brokerService.getDestination(new ActiveMQQueue("queueA"));	
cursormemoryusage 

}	}));	for (int count = 0; count < 10; count++) {	Thread.sleep(5000);	final int i = (int) (Math.random() * consumerThreads.size());	final ThreadSlot slot = consumerThreads.get(i);	slot.thread.interrupt();	consumerThreads.remove(i);	consumerThreads.add(runInThread(slot.runnable));	Queue queue = (Queue) brokerService.getDestination(new ActiveMQQueue("queueA"));	
messagesstat 

for (int count = 0; count < 10; count++) {	Thread.sleep(5000);	final int i = (int) (Math.random() * consumerThreads.size());	final ThreadSlot slot = consumerThreads.get(i);	slot.thread.interrupt();	consumerThreads.remove(i);	consumerThreads.add(runInThread(slot.runnable));	Queue queue = (Queue) brokerService.getDestination(new ActiveMQQueue("queueA"));	}	Queue queue = (Queue) brokerService.getDestination(new ActiveMQQueue("queueA"));	
cursormemoryusage 

for (int count = 0; count < 10; count++) {	Thread.sleep(5000);	final int i = (int) (Math.random() * consumerThreads.size());	final ThreadSlot slot = consumerThreads.get(i);	slot.thread.interrupt();	consumerThreads.remove(i);	consumerThreads.add(runInThread(slot.runnable));	Queue queue = (Queue) brokerService.getDestination(new ActiveMQQueue("queueA"));	}	Queue queue = (Queue) brokerService.getDestination(new ActiveMQQueue("queueA"));	
messagesstat 

Queue queue = (Queue) brokerService.getDestination(new ActiveMQQueue("queueA"));	for (ThreadSlot threadSlot: producerThreads) {	threadSlot.thread.interrupt();	threadSlot.thread.join(4000);	}	for (ThreadSlot threadSlot : consumerThreads) {	threadSlot.thread.interrupt();	threadSlot.thread.join(4000);	}	consumer(connectionUri, "queueA", 2500, true);	
after drain cursormemoryusage 

Queue queue = (Queue) brokerService.getDestination(new ActiveMQQueue("queueA"));	for (ThreadSlot threadSlot: producerThreads) {	threadSlot.thread.interrupt();	threadSlot.thread.join(4000);	}	for (ThreadSlot threadSlot : consumerThreads) {	threadSlot.thread.interrupt();	threadSlot.thread.join(4000);	}	consumer(connectionUri, "queueA", 2500, true);	
messagesstat 

} else {	while (true) {	consumer.receive();	}	}	} finally {	Thread.interrupted();	if (!drain) {	Thread.sleep(5000);	}	
now closing 

========================= activemq sample_2908 =========================

future.addListener(new ChannelFutureListener() {	public void operationComplete(ChannelFuture future) throws Exception {	if (!future.isSuccess()) {	handleException(future.channel(), IOExceptionSupport.create(future.cause()));	}	}	});	try {	connectLatch.await();	} catch (InterruptedException ex) {	
transport connection was interrupted 

failureCause = IOExceptionSupport.create(ex);	}	if (failureCause != null) {	if (channel != null) {	channel.close().syncUninterruptibly();	channel = null;	}	if (group != null) {	Future<?> fut = group.shutdownGracefully(0, SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS);	if (!fut.awaitUninterruptibly(2 * SHUTDOWN_TIMEOUT)) {	
channel group shutdown failed to complete in allotted time 

if (closed.compareAndSet(false, true)) {	connected.set(false);	try {	if (channel != null) {	channel.close().syncUninterruptibly();	}	} finally {	if (group != null) {	Future<?> fut = group.shutdownGracefully(0, SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS);	if (!fut.awaitUninterruptibly(2 * SHUTDOWN_TIMEOUT)) {	
channel group shutdown failed to complete in allotted time 

public void send(ByteBuf output) throws IOException {	checkConnected();	int length = output.readableBytes();	if (length == 0) {	return;	}	
attempted write of bytes 

protected void handleConnected(Channel channel) throws Exception {	
channel has become active channel is 

protected void handleChannelInactive(Channel channel) throws Exception {	
channel has gone inactive channel is 

protected void handleChannelInactive(Channel channel) throws Exception {	if (connected.compareAndSet(true, false) && !closed.get()) {	
firing ontransportclosed listener 

protected void handleException(Channel channel, Throwable cause) throws Exception {	
exception on channel channel is 

protected void handleException(Channel channel, Throwable cause) throws Exception {	if (connected.compareAndSet(true, false) && !closed.get()) {	
firing ontransporterror listener 

protected void handleException(Channel channel, Throwable cause) throws Exception {	if (connected.compareAndSet(true, false) && !closed.get()) {	if (failureCause != null) {	listener.onTransportError(failureCause);	} else {	listener.onTransportError(cause);	}	} else {	if (failureCause == null) {	
holding error until connect succeeds 

public void channelActive(ChannelHandlerContext context) throws Exception {	if (!isSSL()) {	handleConnected(context.channel());	} else {	SslHandler sslHandler = context.pipeline().get(SslHandler.class);	sslHandler.handshakeFuture().addListener(new GenericFutureListener<Future<Channel>>() {	public void operationComplete(Future<Channel> future) throws Exception {	if (future.isSuccess()) {	
ssl handshake has completed 

public void channelActive(ChannelHandlerContext context) throws Exception {	if (!isSSL()) {	handleConnected(context.channel());	} else {	SslHandler sslHandler = context.pipeline().get(SslHandler.class);	sslHandler.handshakeFuture().addListener(new GenericFutureListener<Future<Channel>>() {	public void operationComplete(Future<Channel> future) throws Exception {	if (future.isSuccess()) {	handleConnected(channel);	} else {	
ssl handshake has failed 

protected void channelRead0(ChannelHandlerContext ctx, ByteBuf buffer) throws Exception {	
new data read bytes incoming 

========================= activemq sample_1627 =========================

public void testTemporaryQueueWithMultipleConnectionUsers() throws Exception {	Connection pooledConnection = null;	Connection pooledConnection2 = null;	Session session = null;	Session session2 = null;	Queue tempQueue = null;	Queue normalQueue = null;	pooledConnection = pooledFactory.createConnection();	session = pooledConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	tempQueue = session.createTemporaryQueue();	
created queue named 

Session session2 = null;	Queue tempQueue = null;	Queue normalQueue = null;	pooledConnection = pooledFactory.createConnection();	session = pooledConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	tempQueue = session.createTemporaryQueue();	assertEquals(1, countBrokerTemporaryQueues());	pooledConnection2 = pooledFactory.createConnection();	session2 = pooledConnection2.createSession(false, Session.AUTO_ACKNOWLEDGE);	normalQueue = session2.createQueue("queue:FOO.TEST");	
created queue named 

public void testTemporaryQueueLeakAfterConnectionClose() throws Exception {	Connection pooledConnection = null;	Session session = null;	Queue tempQueue = null;	for (int i = 0; i < 2; i++) {	pooledConnection = pooledFactory.createConnection();	session = pooledConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	tempQueue = session.createTemporaryQueue();	
created queue named 

public void testTemporaryTopicLeakAfterConnectionClose() throws Exception {	Connection pooledConnection = null;	Session session = null;	Topic tempTopic = null;	for (int i = 0; i < 2; i++) {	pooledConnection = pooledFactory.createConnection();	session = pooledConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	tempTopic = session.createTemporaryTopic();	
created topic named 

========================= activemq sample_1298 =========================

Page<MetaData> page = tx.load(0, metaDataMarshaller);	metaData = page.get();	metaData.page = page;	}	metaData.load(tx);	metaData.loadScheduler(tx, schedulers);	for (LegacyJobSchedulerImpl js : schedulers.values()) {	try {	js.start();	} catch (Exception e) {	
failed to load 

metaData.loadScheduler(tx, schedulers);	for (LegacyJobSchedulerImpl js : schedulers.values()) {	try {	js.start();	} catch (Exception e) {	}	}	}	});	this.pageFile.flush();	
started 

if (this.pageFile != null) {	this.pageFile.unload();	}	if (this.journal != null) {	journal.close();	}	if (this.lockFile != null) {	this.lockFile.unlock();	}	this.lockFile = null;	
stopped 

File lockFileName = new File(directory, "lock");	lockFile = new LockFile(lockFileName, true);	if (failIfDatabaseIsLocked) {	lockFile.lock();	} else {	while (true) {	try {	lockFile.lock();	break;	} catch (IOException e) {	
database is locked waiting seconds for the database to be unlocked reason 

========================= activemq sample_1762 =========================

public void masterFailed() {	if (shutdownOnMasterFailure) {	
the master has failed shutting down 

public void masterFailed() {	if (shutdownOnMasterFailure) {	try {	stop();	} catch (Exception e) {	
failed to stop for master failure 

public void masterFailed() {	if (shutdownOnMasterFailure) {	try {	stop();	} catch (Exception e) {	}	} else {	
master failed starting all connectors 

if (shutdownOnMasterFailure) {	try {	stop();	} catch (Exception e) {	}	} else {	try {	startAllConnectors();	broker.nowMasterBroker();	} catch (Exception e) {	
failed to startallconnectors 

}	}	final BrokerRegistry brokerRegistry = BrokerRegistry.getInstance();	if (brokerRegistry.lookup(getBrokerName()) == null) {	brokerRegistry.bind(getBrokerName(), BrokerService.this);	}	startPersistenceAdapter(startAsync);	startBroker(startAsync);	brokerRegistry.bind(getBrokerName(), BrokerService.this);	} catch (Exception e) {	
failed to start apache activemq 

}	startPersistenceAdapter(startAsync);	startBroker(startAsync);	brokerRegistry.bind(getBrokerName(), BrokerService.this);	} catch (Exception e) {	try {	if (!stopped.get()) {	stop();	}	} catch (Exception ex) {	
failed to stop broker after failure in start this exception will be ignored 

private void doStartPersistenceAdapter() throws Exception {	PersistenceAdapter persistenceAdapterToStart = getPersistenceAdapter();	if (persistenceAdapterToStart == null) {	checkStartException();	throw new ConfigurationException("Cannot start null persistence adapter");	}	persistenceAdapterToStart.setUsageManager(getProducerSystemUsage());	persistenceAdapterToStart.setBrokerName(getBrokerName());	
using persistence adapter 

private void doStartBroker() throws Exception {	checkStartException();	startDestinations();	addShutdownHook();	broker = getBroker();	brokerId = broker.getBrokerId();	
apache activemq is starting 

}	if (ioExceptionHandler == null) {	setIoExceptionHandler(new DefaultIOExceptionHandler());	}	if (isUseJmx() && Log4JConfigView.isLog4JAvailable()) {	ObjectName objectName = BrokerMBeanSupport.createLog4JConfigViewName(getBrokerObjectName().toString());	Log4JConfigView log4jConfigView = new Log4JConfigView();	AnnotatedMBean.registerMBean(getManagementContext(), log4jConfigView, objectName);	}	startAllConnectors();	
apache activemq started 

}	if (ioExceptionHandler == null) {	setIoExceptionHandler(new DefaultIOExceptionHandler());	}	if (isUseJmx() && Log4JConfigView.isLog4JAvailable()) {	ObjectName objectName = BrokerMBeanSupport.createLog4JConfigViewName(getBrokerObjectName().toString());	Log4JConfigView log4jConfigView = new Log4JConfigView();	AnnotatedMBean.registerMBean(getManagementContext(), log4jConfigView, objectName);	}	startAllConnectors();	
for help or more information please see http getbroker brokerservicestarted 

if (preShutdownHooksInvoked.compareAndSet(false, true)) {	for (Runnable hook : preShutdownHooks) {	try {	hook.run();	} catch (Throwable e) {	stopper.onException(hook, e);	}	}	}	if (!stopping.compareAndSet(false, true)) {	
broker already stopping stopped 

}	setStartException(new BrokerStoppedException("Stop invoked"));	MDC.put("activemq.broker", brokerName);	if (systemExitOnShutdown) {	new Thread() {	public void run() {	System.exit(systemExitOnShutdownExitCode);	}	}.start();	}	
apache activemq is shutting down 

this.taskRunnerFactory.shutdown();	this.taskRunnerFactory = null;	}	if (this.executor != null) {	ThreadPoolUtils.shutdownNow(executor);	this.executor = null;	}	this.destinationInterceptors = null;	this.destinationFactory = null;	if (startDate != null) {	
apache activemq uptime 

this.taskRunnerFactory = null;	}	if (this.executor != null) {	ThreadPoolUtils.shutdownNow(executor);	this.executor = null;	}	this.destinationInterceptors = null;	this.destinationFactory = null;	if (startDate != null) {	}	
apache activemq is shutdown 

public boolean checkQueueSize(String queueName) {	long count = 0;	long queueSize = 0;	Map<ActiveMQDestination, Destination> destinationMap = regionBroker.getDestinationMap();	for (Map.Entry<ActiveMQDestination, Destination> entry : destinationMap.entrySet()) {	if (entry.getKey().isQueue()) {	if (entry.getValue().getName().matches(queueName)) {	queueSize = entry.getValue().getDestinationStatistics().getMessages().getCount();	count += queueSize;	if (queueSize > 0) {	
queue has pending message queuesize is 

public void stopGracefully(String connectorName, String queueName, long timeout, long pollInterval) throws Exception {	if (isUseJmx()) {	if (connectorName == null || queueName == null || timeout <= 0) {	throw new Exception( "connectorName and queueName cannot be null and timeout should be >0 for stopGracefully.");	}	if (pollInterval <= 0) {	pollInterval = 30;	}	
stop gracefully with connectorname queuename timeout pollinterval 

long start = System.currentTimeMillis();	while (System.currentTimeMillis() - start < timeout * 1000) {	if (checkQueueSize(queueName)) {	stop();	break;	} else {	Thread.sleep(pollInterval * 1000);	}	}	if (stopped.get()) {	
successfully stop the broker 

while (System.currentTimeMillis() - start < timeout * 1000) {	if (checkQueueSize(queueName)) {	stop();	break;	} else {	Thread.sleep(pollInterval * 1000);	}	}	if (stopped.get()) {	} else {	
there is still pending message on the queue please check and stop the broker manually 

public void setBrokerName(String brokerName) {	if (brokerName == null) {	throw new NullPointerException("The broker name cannot be null");	}	String str = brokerName.replaceAll(brokerNameReplacedCharsRegExp, "_");	if (!str.equals(brokerName)) {	
broker name contained illegal characters matching regexp replaced with 

systemUsage = new SystemUsage("Main", getPersistenceAdapter(), getTempDataStore(), getJobSchedulerStore());	systemUsage.setExecutor(getExecutor());	systemUsage.getMemoryUsage().setLimit(1024L * 1024 * 1024 * 1);	systemUsage.getTempUsage().setLimit(1024L * 1024 * 1024 * 50);	systemUsage.getStoreUsage().setLimit(1024L * 1024 * 1024 * 100);	systemUsage.getJobSchedulerUsage().setLimit(1024L * 1024 * 1024 * 50);	addService(this.systemUsage);	}	return systemUsage;	} catch (IOException e) {	
cannot create systemusage 

for (TransportConnector connector : transportConnectors) {	try {	URI uri = connector.getConnectUri();	if (uri != null) {	String scheme = uri.getScheme();	if (scheme != null) {	answer.put(scheme.toLowerCase(Locale.ENGLISH), uri.toString());	}	}	} catch (Exception e) {	
failed to read uri to build transporturisasmap 

public URI getVmConnectorURI() {	if (vmConnectorURI == null) {	try {	vmConnectorURI = new URI("vm: } catch (URISyntaxException e) {	
badly formed uri from 

public String getDefaultSocketURIString() {	if (started.get()) {	if (this.defaultSocketURIString == null) {	for (TransportConnector tc:this.transportConnectors) {	String result = null;	try {	result = tc.getPublishableConnectString();	} catch (Exception e) {	
failed to get the connecturi for 

}	} catch (IOException e) {	throw new RuntimeException(e);	}	try {	String clazz = "org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter";	PersistenceAdapter adaptor = (PersistenceAdapter)getClass().getClassLoader().loadClass(clazz).newInstance();	jobSchedulerStore = adaptor.createJobSchedulerStore();	jobSchedulerStore.setDirectory(getSchedulerDirectoryFile());	configureService(jobSchedulerStore);	
jobscheduler using directory 

final SystemUsage usage = getSystemUsage();	if (getPersistenceAdapter() != null) {	PersistenceAdapter adapter = getPersistenceAdapter();	checkUsageLimit(adapter.getDirectory(), usage.getStoreUsage(), usage.getStoreUsage().getPercentLimit());	long maxJournalFileSize = 0;	long storeLimit = usage.getStoreUsage().getLimit();	if (adapter instanceof JournaledStore) {	maxJournalFileSize = ((JournaledStore) adapter).getJournalMaxFileLength();	}	if (storeLimit > 0 && storeLimit < maxJournalFileSize) {	
store limit is mb whilst the max journal file size for the store is mb the store will not accept any data when used 

if (isPersistent()) {	long maxJournalFileSize;	PListStore store = usage.getTempUsage().getStore();	if (store != null && store instanceof JournaledStore) {	maxJournalFileSize = ((JournaledStore) store).getJournalMaxFileLength();	} else {	maxJournalFileSize = DEFAULT_MAX_FILE_LENGTH;	}	long storeLimit = usage.getTempUsage().getLimit();	if (storeLimit > 0 && storeLimit < maxJournalFileSize) {	
temporary store limit is mb whilst the max journal file size for the temporary store is mb the temp store will not accept any data when used 

if (totalUsableSpace < 0 || totalSpace < 0) {	final String message = "File system space reported by: " + dir + " was negative, possibly a huge file system, set a sane usage.total to provide some guidance";	LOG.error(message);	throw new ConfigurationException(message);	}	long bytePercentLimit = totalSpace * percentLimit / 100;	int oneMeg = 1024 * 1024;	if (diskUsageCheckRegrowThreshold > -1 && percentLimit > 0 && storeUsage.getTotal() == 0 && storeLimit < bytePercentLimit && storeLimit < totalUsableSpace){	long newLimit = bytePercentLimit > totalUsableSpace ? totalUsableSpace : bytePercentLimit;	if (newLimit - storeLimit >= diskUsageCheckRegrowThreshold) {	
usable disk space has been increased attempting to regrow limit to of the partition size 

final String message = "File system space reported by: " + dir + " was negative, possibly a huge file system, set a sane usage.total to provide some guidance";	LOG.error(message);	throw new ConfigurationException(message);	}	long bytePercentLimit = totalSpace * percentLimit / 100;	int oneMeg = 1024 * 1024;	if (diskUsageCheckRegrowThreshold > -1 && percentLimit > 0 && storeUsage.getTotal() == 0 && storeLimit < bytePercentLimit && storeLimit < totalUsableSpace){	long newLimit = bytePercentLimit > totalUsableSpace ? totalUsableSpace : bytePercentLimit;	if (newLimit - storeLimit >= diskUsageCheckRegrowThreshold) {	storeUsage.setLimit(newLimit);	
limit has been increased to mb of the partition size 

if (newLimit - storeLimit >= diskUsageCheckRegrowThreshold) {	storeUsage.setLimit(newLimit);	}	} else if (storeLimit > totalUsableSpace) {	final String message = storeName + " limit is " +  storeLimit / oneMeg + " mb (current store usage is " + storeCurrent / oneMeg + " mb). The data directory: " + dir.getAbsolutePath() + " only has " + totalUsableSpace / oneMeg + " mb of usable space.";	if (!isAdjustUsageLimits()) {	LOG.error(message);	throw new ConfigurationException(message);	}	if (percentLimit > 0) {	
limit has been set to mb of the partition size but there is not enough usable space the current store limit which may have been adjusted by a previous usage limit check is set to mb but only mb is available resetting limit 

storeUsage.setLimit(newLimit);	}	} else if (storeLimit > totalUsableSpace) {	final String message = storeName + " limit is " +  storeLimit / oneMeg + " mb (current store usage is " + storeCurrent / oneMeg + " mb). The data directory: " + dir.getAbsolutePath() + " only has " + totalUsableSpace / oneMeg + " mb of usable space.";	if (!isAdjustUsageLimits()) {	LOG.error(message);	throw new ConfigurationException(message);	}	if (percentLimit > 0) {	} else {	
resetting to maximum available disk space mb 

protected void scheduleDiskUsageLimitsCheck() throws IOException {	if (schedulePeriodForDiskUsageCheck > 0 && (getPersistenceAdapter() != null || getTmpDataDirectory() != null)) {	Runnable diskLimitCheckTask = new Runnable() {	public void run() {	try {	checkStoreUsageLimits();	} catch (Exception e) {	
failed to check persistent disk usage limits 

if (schedulePeriodForDiskUsageCheck > 0 && (getPersistenceAdapter() != null || getTmpDataDirectory() != null)) {	Runnable diskLimitCheckTask = new Runnable() {	public void run() {	try {	checkStoreUsageLimits();	} catch (Exception e) {	}	try {	checkTmpStoreUsageLimits();	} catch (Exception e) {	
failed to check temporary store usage limits 

protected void checkMemorySystemUsageLimits() throws Exception {	final SystemUsage usage = getSystemUsage();	long memLimit = usage.getMemoryUsage().getLimit();	long jvmLimit = Runtime.getRuntime().maxMemory();	if (memLimit > jvmLimit) {	final String message = "Memory Usage for the Broker (" + memLimit / (1024 * 1024) + "mb) is more than the maximum available for the JVM: " + jvmLimit / (1024 * 1024);	if (adjustUsageLimits) {	usage.getMemoryUsage().setPercentOfJvmHeap(70);	
mb resetting to of maximum available mb 

String schedulerDirPath = schedulerDir.getAbsolutePath();	if (!schedulerDir.isAbsolute()) {	schedulerDir = new File(schedulerDirPath);	}	while (schedulerDir != null && !schedulerDir.isDirectory()) {	schedulerDir = schedulerDir.getParentFile();	}	long schedulerLimit = usage.getJobSchedulerUsage().getLimit();	long dirFreeSpace = schedulerDir.getUsableSpace();	if (schedulerLimit > dirFreeSpace) {	
job scheduler store limit is mb whilst the data directory only has mb of usable space resetting to mb 

protected void unregisterNetworkConnectorMBean(NetworkConnector connector) {	if (isUseJmx()) {	try {	ObjectName objectName = createNetworkConnectorObjectName(connector);	getManagementContext().unregisterMBean(objectName);	} catch (Exception e) {	
network connector could not be unregistered from jmx due this exception is ignored 

protected Broker createRegionBroker(DestinationInterceptor destinationInterceptor) throws IOException {	RegionBroker regionBroker;	if (isUseJmx()) {	try {	regionBroker = new ManagedRegionBroker(this, getManagementContext(), getBrokerObjectName(), getTaskRunnerFactory(), getConsumerSystemUsage(), destinationFactory, destinationInterceptor,getScheduler(),getExecutor());	} catch(MalformedObjectNameException me){	
cannot create managedregionbroker due 

protected Object getPort(Map<?,?> options) {	Object port = options.get("port");	if (port == null) {	port = DEFAULT_PORT;	
no port specified so defaulting to 

protected void removeShutdownHook() {	if (shutdownHook != null) {	try {	Runtime.getRuntime().removeShutdownHook(shutdownHook);	} catch (Exception e) {	
caught exception must be shutting down this exception is ignored 

}	String defaultSocketURI = getDefaultSocketURIString();	if (defaultSocketURI != null) {	connector.setBrokerURL(defaultSocketURI);	}	if (isUseJmx()) {	ObjectName networkMbean = createNetworkConnectorObjectName(connector);	try {	getManagementContext().getObjectInstance(networkMbean);	} catch (InstanceNotFoundException e) {	
network connector mbean not found registering 

try {	getManagementContext().getObjectInstance(networkMbean);	} catch (InstanceNotFoundException e) {	registerNetworkConnectorMBean(connector);	}	}	if (networkConnectorStartExecutor != null) {	networkConnectorStartExecutor.execute(new Runnable() {	public void run() {	try {	
async start of 

} catch (InstanceNotFoundException e) {	registerNetworkConnectorMBean(connector);	}	}	if (networkConnectorStartExecutor != null) {	networkConnectorStartExecutor.execute(new Runnable() {	public void run() {	try {	connector.start();	} catch(Exception e) {	
async start of network connector failed 

public void handleIOException(IOException exception) {	if (ioExceptionHandler != null) {	ioExceptionHandler.handle(exception);	} else {	
no ioexceptionhandler registered ignoring io exception 

for (DestinationInterceptor interceptor : destinationInterceptors) {	if (interceptor instanceof VirtualDestinationInterceptor) {	VirtualDestinationInterceptor virtualDestinationInterceptor = (VirtualDestinationInterceptor) interceptor;	for (VirtualDestination virtualDestination: virtualDestinationInterceptor.getVirtualDestinations()) {	if (virtualDestination instanceof VirtualTopic) {	consumerDestinations.add(new ActiveMQQueue(((VirtualTopic) virtualDestination).getPrefix() + DestinationFilter.ANY_DESCENDENT));	}	if (isUseVirtualDestSubs()) {	try {	broker.virtualDestinationAdded(getAdminConnectionContext(), virtualDestination);	
adding virtual destination 

if (interceptor instanceof VirtualDestinationInterceptor) {	VirtualDestinationInterceptor virtualDestinationInterceptor = (VirtualDestinationInterceptor) interceptor;	for (VirtualDestination virtualDestination: virtualDestinationInterceptor.getVirtualDestinations()) {	if (virtualDestination instanceof VirtualTopic) {	consumerDestinations.add(new ActiveMQQueue(((VirtualTopic) virtualDestination).getPrefix() + DestinationFilter.ANY_DESCENDENT));	}	if (isUseVirtualDestSubs()) {	try {	broker.virtualDestinationAdded(getAdminConnectionContext(), virtualDestination);	} catch (Exception e) {	
could not fire virtual destination consumer advisory 

protected synchronized ThreadPoolExecutor getExecutor() {	if (this.executor == null) {	this.executor = new ThreadPoolExecutor(1, 10, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new ThreadFactory() {	private long i = 0;	public Thread newThread(Runnable runnable) {	this.i++;	Thread thread = new Thread(runnable, "ActiveMQ BrokerService.worker." + this.i);	thread.setDaemon(true);	thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {	public void uncaughtException(final Thread t, final Throwable e) {	
error in thread 

public synchronized Scheduler getScheduler() {	if (this.scheduler==null) {	this.scheduler = new Scheduler("ActiveMQ Broker["+getBrokerName()+"] Scheduler");	try {	this.scheduler.start();	} catch (Exception e) {	
failed to start scheduler 

========================= activemq sample_3972 =========================

e.printStackTrace();	}	}	});	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return messageCount.getCount() < maxMessages - 10;	}	});	assertTrue("some messages consumed", messageCount.getCount() < maxMessages);	
closing pool on 

========================= activemq sample_828 =========================

producer.send(message);	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return receivedCount.get() == 2;	}	});	consumerA.close();	producer.send(message);	producer.send(message);	assertEquals(2, receivedCount.get());	
restarting consumera 

VirtualTopic virtualTopic = new VirtualTopic();	virtualTopic.setName("VirtualOrders.>");	virtualTopic.setSelectorAware(true);	VirtualDestination[] virtualDestinations = { virtualTopic };	interceptor.setVirtualDestinations(virtualDestinations);	broker.setDestinationInterceptors(new DestinationInterceptor[]{interceptor});	broker.setUseJmx(false);	broker.start();	broker.waitUntilStarted();	} catch (Exception e) {	
failed creating broker 

========================= activemq sample_3564 =========================

ConnectionInfo connectionInfo2 = createConnectionInfo();	SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);	connection2.send(connectionInfo2);	connection2.send(sessionInfo2);	ActiveMQDestination destinationInfo2 = createDestinationInfo(connection2, connectionInfo2, ActiveMQDestination.QUEUE_TYPE);	final ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destinationInfo2);	connection2.send(consumerInfo2);	for (int i = 0; i < receiveNumMessages; ++i) {	Message message1 = receiveMessage(connection2, 20000);	assertNotNull(message1);	
on remote got 

assertTrue("JMSActiveMQBrokerPath property present and correct", ((ActiveMQMessage)message1).getStringProperty(ActiveMQMessage.BROKER_PATH_PROPERTY).contains(localBroker.getBroker().getBrokerId().toString()));	}	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	Object[] result = browseQueueWithJmx(localBroker);	return 0 == result.length;	}	});	messages = browseQueueWithJmx(localBroker);	assertEquals(0, messages.length);	
creating demand on second remote 

StubConnection connection3 = createSecondRemoteConnection();	ConnectionInfo connectionInfo3 = createConnectionInfo();	SessionInfo sessionInfo3 = createSessionInfo(connectionInfo3);	connection3.send(connectionInfo3);	connection3.send(sessionInfo3);	ActiveMQDestination destinationInfo3 = createDestinationInfo(connection3, connectionInfo3, ActiveMQDestination.QUEUE_TYPE);	final ConsumerInfo consumerInfoS3 = createConsumerInfo(sessionInfo3, destinationInfo3);	connection3.send(consumerInfoS3);	Message messageExceedingTtl = receiveMessage(connection3, 5000);	if (messageExceedingTtl != null) {	
got message on second remote 

SessionInfo sessionInfo3 = createSessionInfo(connectionInfo3);	connection3.send(connectionInfo3);	connection3.send(sessionInfo3);	ActiveMQDestination destinationInfo3 = createDestinationInfo(connection3, connectionInfo3, ActiveMQDestination.QUEUE_TYPE);	final ConsumerInfo consumerInfoS3 = createConsumerInfo(sessionInfo3, destinationInfo3);	connection3.send(consumerInfoS3);	Message messageExceedingTtl = receiveMessage(connection3, 5000);	if (messageExceedingTtl != null) {	connection3.send(createAck(consumerInfoS3, messageExceedingTtl, 1, MessageAck.INDIVIDUAL_ACK_TYPE));	}	
closing consumer on remote 

connection2.send(connectionInfo2.createRemoveCommand());	assertTrue("correct stuck message count", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	Object[] result = browseQueueWithJmx(remoteBroker);	return 5 == result.length;	}	}));	messages = browseQueueWithJmx(remoteBroker);	assertEquals(5, messages.length);	assertTrue("can see broker path property", ((String)((CompositeData)messages[1]).get("BrokerPath")).contains(localBroker.getBroker().getBrokerId().toString()));	
messages now stuck on remote 

public boolean isSatisified() throws Exception {	Object[] result = browseQueueWithJmx(remoteBroker);	return 5 == result.length;	}	}));	messages = browseQueueWithJmx(remoteBroker);	assertEquals(5, messages.length);	assertTrue("can see broker path property", ((String)((CompositeData)messages[1]).get("BrokerPath")).contains(localBroker.getBroker().getBrokerId().toString()));	ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destinationInfo1);	connection1.send(consumerInfo1);	
create local consumer 

}	}));	messages = browseQueueWithJmx(remoteBroker);	assertEquals(5, messages.length);	assertTrue("can see broker path property", ((String)((CompositeData)messages[1]).get("BrokerPath")).contains(localBroker.getBroker().getBrokerId().toString()));	ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destinationInfo1);	connection1.send(consumerInfo1);	Message message1 = receiveMessage(connection1, 20000);	assertNotNull("Expect to get a replay as remote consumer is gone", message1);	connection1.send(createAck(consumerInfo1, message1, 1, MessageAck.INDIVIDUAL_ACK_TYPE));	
acked one message on origin waiting for all messages to percolate back 

assertNotNull("Expect to get a replay as remote consumer is gone", message1);	connection1.send(createAck(consumerInfo1, message1, 1, MessageAck.INDIVIDUAL_ACK_TYPE));	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	Object[] result = browseQueueWithJmx(localBroker);	return 4 == result.length;	}	});	messages = browseQueueWithJmx(localBroker);	assertEquals(4, messages.length);	
checking for messages on remote again 

messages = list.toArray();	}	finally {	if (session != null) {	session.close();	}	if (connection != null) {	connection.close();	}	}	
browsed with jms 

private Object[] browseQueueWithJmx(BrokerService broker) throws Exception {	Hashtable<String, String> params = new Hashtable<String, String>();	params.put("brokerName", broker.getBrokerName());	params.put("type", "Broker");	params.put("destinationType", "Queue");	params.put("destinationName", queueName);	ObjectName queueObjectName = ObjectName.getInstance(amqDomain, params);	ManagementContext mgmtCtx = broker.getManagementContext();	QueueViewMBean queueView = (QueueViewMBean)mgmtCtx.newProxyInstance(queueObjectName, QueueViewMBean.class, true);	Object[] messages = queueView.browse();	
browsed with jmx 

========================= activemq sample_2725 =========================

if (getJmsProducer() == null) {	if (dest.length == 1) {	createJmsProducer(dest[0]);	} else {	createJmsProducer();	}	}	try {	getConnection().start();	if (client.getMsgFileName() != null) {	
starting to publish messages from file 

if (dest.length == 1) {	createJmsProducer(dest[0]);	} else {	createJmsProducer();	}	}	try {	getConnection().start();	if (client.getMsgFileName() != null) {	} else {	
starting to publish messages of size byte s 

} else {	for (int i = 0; i < messageCount; i++) {	getJmsProducer().send(createJmsTextMessage("Text Message [" + i + "]"));	incThroughput();	sleep();	commitTxIfNecessary();	}	}	}	} finally {	
finished sending 

if (getJmsProducer() == null) {	if (dest.length == 1) {	createJmsProducer(dest[0]);	} else {	createJmsProducer();	}	}	try {	getConnection().start();	if (client.getMsgFileName() != null) {	
starting to publish messages from file for ms 

if (dest.length == 1) {	createJmsProducer(dest[0]);	} else {	createJmsProducer();	}	}	try {	getConnection().start();	if (client.getMsgFileName() != null) {	} else {	
starting to publish byte s messages for ms 

} else {	while (System.currentTimeMillis() < endTime) {	getJmsProducer().send(createJmsTextMessage("Text Message [" + count++ + "]"));	incThroughput();	sleep();	commitTxIfNecessary();	}	}	}	} finally {	
finished sending 

public MessageProducer createJmsProducer() throws JMSException {	jmsProducer = getSession().createProducer(null);	if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_PERSISTENT)) {	
creating producer to possible multiple destinations with persistent delivery 

public MessageProducer createJmsProducer() throws JMSException {	jmsProducer = getSession().createProducer(null);	if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_PERSISTENT)) {	jmsProducer.setDeliveryMode(DeliveryMode.PERSISTENT);	} else if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_NON_PERSISTENT)) {	
creating producer to possible multiple destinations with non persistent delivery 

public MessageProducer createJmsProducer() throws JMSException {	jmsProducer = getSession().createProducer(null);	if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_PERSISTENT)) {	jmsProducer.setDeliveryMode(DeliveryMode.PERSISTENT);	} else if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_NON_PERSISTENT)) {	jmsProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	} else {	
unknown deliverymode value defaulting to non persistent 

public MessageProducer createJmsProducer(Destination dest) throws JMSException {	jmsProducer = getSession().createProducer(dest);	if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_PERSISTENT)) {	
creating producer to with persistent delivery 

public MessageProducer createJmsProducer(Destination dest) throws JMSException {	jmsProducer = getSession().createProducer(dest);	if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_PERSISTENT)) {	jmsProducer.setDeliveryMode(DeliveryMode.PERSISTENT);	} else if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_NON_PERSISTENT)) {	
creating producer to with non persistent delivery 

public MessageProducer createJmsProducer(Destination dest) throws JMSException {	jmsProducer = getSession().createProducer(dest);	if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_PERSISTENT)) {	jmsProducer.setDeliveryMode(DeliveryMode.PERSISTENT);	} else if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_NON_PERSISTENT)) {	jmsProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	} else {	
unknown deliverymode value defaulting to non persistent 

protected Destination createTemporaryDestination(String destName) throws JMSException {	String simpleName = getSimpleName(destName);	byte destinationType = getDestinationType(destName);	if (destinationType == ActiveMQDestination.TEMP_QUEUE_TYPE) {	
creating queue 

protected Destination createTemporaryDestination(String destName) throws JMSException {	String simpleName = getSimpleName(destName);	byte destinationType = getDestinationType(destName);	if (destinationType == ActiveMQDestination.TEMP_QUEUE_TYPE) {	return getSession().createQueue(simpleName);	} else if (destinationType == ActiveMQDestination.TEMP_TOPIC_TYPE) {	
creating topic 

protected void sleep() {	if (client.getSendDelay() > 0) {	try {	
sleeping for milliseconds 

========================= activemq sample_1220 =========================

public boolean isHeaderValid(AmqpHeader header, boolean authenticated) {	if (!header.hasValidPrefix()) {	
amqp header arrived with invalid prefix 

public boolean isHeaderValid(AmqpHeader header, boolean authenticated) {	if (!header.hasValidPrefix()) {	return false;	}	if (!(header.getProtocolId() == 0 || header.getProtocolId() == SASL_PROTOCOL)) {	
amqp header arrived with invalid protocol id 

public boolean isHeaderValid(AmqpHeader header, boolean authenticated) {	if (!header.hasValidPrefix()) {	return false;	}	if (!(header.getProtocolId() == 0 || header.getProtocolId() == SASL_PROTOCOL)) {	return false;	}	if (!authenticated && !isAllowNonSaslConnections() && header.getProtocolId() != SASL_PROTOCOL) {	
amqp header arrived without sasl and server requires sasl 

if (!header.hasValidPrefix()) {	return false;	}	if (!(header.getProtocolId() == 0 || header.getProtocolId() == SASL_PROTOCOL)) {	return false;	}	if (!authenticated && !isAllowNonSaslConnections() && header.getProtocolId() != SASL_PROTOCOL) {	return false;	}	if (header.getMajor() != 1 || header.getMinor() != 0 || header.getRevision() != 0) {	
amqp header arrived invalid version 

========================= activemq sample_1670 =========================

for (int i = 0; i < threadNumber; i++) {	Thread thread = new Thread("thread " + i) {	public void run() {	for (int i = 0; i < 100; i++) {	Connection conn = null;	try {	conn = factory.createConnection();	conn.start();	Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	int sleepTime = rand.nextInt((3000 - 1000) + 1) + 1000;	
sleeping 

Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	int sleepTime = rand.nextInt((3000 - 1000) + 1) + 1000;	Thread.sleep(sleepTime);	} catch (Exception e) {	e.printStackTrace();	errors.incrementAndGet();	}  finally {	try {	conn.close();	} catch (Exception e) {}	
iteration 

Thread.sleep(sleepTime);	} catch (Exception e) {	e.printStackTrace();	errors.incrementAndGet();	}  finally {	try {	conn.close();	} catch (Exception e) {}	}	}	
finished 

conn.close();	} catch (Exception e) {}	}	}	latch.countDown();	}	};	thread.start();	}	latch.await(5, TimeUnit.MINUTES);	
errors 

========================= activemq sample_2549 =========================

public void testRoundTrip() throws Exception {	Destination destination = getMandatoryBean(Destination.class, "consumeFrom");	ConnectionFactory factoryCON = getMandatoryBean(ConnectionFactory.class, "CON");	Connection consumerConnection = factoryCON.createConnection();	consumerConnection.start();	Session consumerSession = consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	
consuming from 

========================= activemq sample_1365 =========================

public boolean isSatisified() throws Exception {	return journalLog.exists();	}	}));	KahaTraceCommand traceCommand = new KahaTraceCommand();	traceCommand.setMessage(new String(new byte[2*1024*1024]));	Location location = null;	for (int i=0; i<20; i++) {	location = store.store(traceCommand);	}	
last location 

public boolean isSatisified() throws Exception {	return journalLog.exists();	}	}));	KahaTraceCommand traceCommand = new KahaTraceCommand();	traceCommand.setMessage(new String(new byte[2*1024*1024]));	Location location = null;	for (int i=0; i<20; i++) {	location = store.store(traceCommand);	}	
store journal files 

final File journalLog = new File(dataDirectory, "db-1.log");	assertTrue("file exists", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return journalLog.exists();	}	}));	FileInputStream is = new FileInputStream(journalLog);	final FileChannel channel = is.getChannel();	assertTrue("file size as expected", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
file size chan size jfilesize length 

public boolean isSatisified() throws Exception {	return Journal.DEFAULT_MAX_FILE_LENGTH == channel.size();	}	}));	channel.position(1 * 1024 * 1024 + 1);	ByteBuffer buff = ByteBuffer.allocate(1);	channel.read(buff);	buff.flip();	buff.position(0);	assertEquals(0x00, buff.get());	
file size 

========================= activemq sample_1735 =========================

continue;	}	try {	message.acknowledge();	} catch(Exception e) {	jmsConnector.handleConnectionFailure(getConnnectionForConsumer());	continue;	}	return;	} catch (Exception e) {	
failed to forward message on attempt reason message 

========================= activemq sample_4258 =========================

super(next);	this.store = store;	this.producerId.setConnectionId(ID_GENERATOR.generateId());	this.context.setSecurityContext(SecurityContext.BROKER_SECURITY_CONTEXT);	this.context.setConnection(new Connection() {	public Connector getConnector() {	return null;	}	public void dispatchSync(Command message) {	if (message instanceof ExceptionResponse) {	
unexpected response 

this.context.setConnection(new Connection() {	public Connector getConnector() {	return null;	}	public void dispatchSync(Command message) {	if (message instanceof ExceptionResponse) {	}	}	public void dispatchAsync(Command command) {	if (command instanceof ExceptionResponse) {	
unexpected response 

}	}	public void dispatchAsync(Command command) {	if (command instanceof ExceptionResponse) {	}	}	public Response service(Command command) {	return null;	}	public void serviceException(Throwable error) {	
unexpected exception 

public ConnectionStatistics getStatistics() {	return null;	}	public boolean isManageable() {	return false;	}	public String getRemoteAddress() {	return null;	}	public void serviceExceptionAsync(IOException e) {	
unexpected async ioexception 

JobSchedulerUsage usage = systemUsage.getJobSchedulerUsage();	if (usage.isFull()) {	final String logMessage = "Job Scheduler Store is Full (" + usage.getPercentUsage() + "% of " + usage.getLimit() + "). Stopping producer (" + messageSend.getProducerId() + ") to prevent flooding of the job scheduler store." + " See http: long start = System.currentTimeMillis();	long nextWarn = start;	while (!usage.waitForSpace(1000)) {	if (context.getStopping().get()) {	throw new IOException("Connection closed, send aborted.");	}	long now = System.currentTimeMillis();	if (now >= nextWarn) {	
blocking for s 

long oldTimestamp = messageSend.getTimestamp();	if (oldExpiration > 0) {	timeToLive = oldExpiration - oldTimestamp;	}	long expiration = timeToLive + newTimeStamp;	if (expiration > oldExpiration) {	if (timeToLive > 0 && expiration > 0) {	messageSend.setExpiration(expiration);	}	messageSend.setTimestamp(newTimeStamp);	
set message timestamp from to 

messageSend.setTimestamp(newTimeStamp);	}	}	messageSend.beforeMarshall(wireFormat);	final ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();	producerExchange.setConnectionContext(context);	producerExchange.setMutable(true);	producerExchange.setProducerState(new ProducerState(new ProducerInfo()));	super.send(producerExchange, messageSend);	} catch (Exception e) {	
failed to send scheduled message 

producerExchange.setConnectionContext(context);	producerExchange.setMutable(true);	producerExchange.setProducerState(new ProducerState(new ProducerInfo()));	try {	context.setProducerFlowControl(false);	this.next.send(producerExchange, msg);	} finally {	context.setProducerFlowControl(originalFlowControl);	}	} catch (Exception e) {	
failed to send scheduled message 

========================= activemq sample_3964 =========================

public void doTestRecovery(final boolean haveOutcome) throws Exception {	final MultiKahaDBPersistenceAdapter persistenceAdapter = (MultiKahaDBPersistenceAdapter) brokerService.getPersistenceAdapter();	MultiKahaDBTransactionStore transactionStore = new MultiKahaDBTransactionStore(persistenceAdapter) {	public void persistOutcome(Tx tx, TransactionId txid) throws IOException {	if (haveOutcome) {	super.persistOutcome(tx, txid);	}	try {	persistenceAdapter.stop();	} catch (Exception e) {	
ex on stop 

}	};	persistenceAdapter.setTransactionStore(transactionStore);	brokerService.start();	ExecutorService executorService = Executors.newCachedThreadPool();	executorService.execute(new Runnable() {	public void run() {	try {	sendMessages(true, "SlowQ,FastQ", 1, 0);	} catch(Exception expected) {	
expected 

exceptions.add(e);	}	}	});	executorService.shutdown();	assertTrue("consumers executor finished on time", executorService.awaitTermination(5*60, TimeUnit.SECONDS));	final SystemUsage usage = brokerService.getSystemUsage();	assertTrue("Store is not hogged", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	long storeUsage = usage.getStoreUsage().getUsage();	
store usage 

========================= activemq sample_3821 =========================

public AmqpConnection connect() throws Exception {	AmqpConnection connection = createConnection();	
attempting to create new connection to peer 

========================= activemq sample_1666 =========================

public void testRestartAfterQueueDelete() throws Exception {	assertTrue("Broker doesn't have an Admin View.", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return (broker.getAdminView()) != null;	}	}));	
adding destinations 

public boolean isSatisified() throws Exception {	return (broker.getAdminView()) != null;	}	}));	sendMessage(DESTINATION_NAME, "test 1");	sendMessage(DESTINATION_NAME_2, "test 1");	sendMessage(DESTINATION_NAME_3, "test 1");	assertNotNull(broker.getDestination(new ActiveMQQueue(DESTINATION_NAME)));	assertNotNull(broker.getDestination(new ActiveMQQueue(DESTINATION_NAME_2)));	assertNotNull(broker.getDestination(new ActiveMQQueue(DESTINATION_NAME_3)));	
removing destination 

return (broker.getAdminView()) != null;	}	}));	sendMessage(DESTINATION_NAME, "test 1");	sendMessage(DESTINATION_NAME_2, "test 1");	sendMessage(DESTINATION_NAME_3, "test 1");	assertNotNull(broker.getDestination(new ActiveMQQueue(DESTINATION_NAME)));	assertNotNull(broker.getDestination(new ActiveMQQueue(DESTINATION_NAME_2)));	assertNotNull(broker.getDestination(new ActiveMQQueue(DESTINATION_NAME_3)));	broker.getAdminView().removeQueue(DESTINATION_NAME_2);	
recreating destination 

========================= activemq sample_2949 =========================

if (subscription.isRecoveryRequired()) {	topicStore.recoverSubscription(clientId, subscriptionName, new MessageRecoveryListener() {	public boolean recoverMessage(Message message) throws Exception {	message.setRegionDestination(Topic.this);	try {	msgContext.setMessageReference(message);	if (subscription.matches(message, msgContext)) {	subscription.add(message);	}	} catch (IOException e) {	
failed to recover this message 

ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());	context.getConnection().dispatchAsync(ack);	}	return;	}	if (memoryUsage.isFull()) {	isFull(context, memoryUsage);	fastProducer(context, producerInfo);	if (isProducerFlowControl() && context.isProducerFlowControl()) {	if (isFlowControlLogRequired()) {	
usage manager memory limit reached producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it see http getactivemqdestination getqualifiedname memoryusage getlimit 

int size = context.getTransaction().size();	LOG.warn("Waiting for space to send transacted message - transaction elements = {} need more space to commit. Message = {}", size, message);	}	count++;	}	} else {	waitForSpace( context, producerExchange, memoryUsage, "Usage Manager Memory Usage limit reached. Stopping producer (" + message.getProducerId() + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "." + " See http: }	}	if (message.isExpired()) {	getDestinationStatistics().getExpired().increment();	
expired message 

}	}	Message[] msgs = subscriptionRecoveryPolicy.browse(getActiveMQDestination());	if (msgs != null) {	for (int i = 0; i < msgs.length && browseList.size() < max; i++) {	browseList.add(msgs[i]);	}	}	}	} catch (Throwable e) {	
failed to browse topic 

MessageAck ack = new MessageAck();	ack.setAckType(MessageAck.STANDARD_ACK_TYPE);	ack.setDestination(destination);	ack.setMessageID(reference.getMessageId());	try {	if (subs instanceof DurableTopicSubscription) {	((DurableTopicSubscription)subs).removePending(reference);	}	acknowledge(context, subs, ack, reference);	} catch (Exception e) {	
failed to remove expired message from the store 

private void clearPendingAndDispatch(DurableTopicSubscription durableTopicSubscription) {	synchronized (durableTopicSubscription.pendingLock) {	durableTopicSubscription.pending.clear();	try {	durableTopicSubscription.dispatchPending();	} catch (IOException exception) {	
after clear of pending failed to dispatch to for pending 

========================= activemq sample_4034 =========================

private void doStartBroker(boolean delete) throws Exception {	doCreateBroker(delete);	
starting broker 

public void testRecoveryOnDeleteFailureMetaDataOk() throws Exception {	startBroker();	int sent = produceMessagesToConsumeMultipleDataFiles(50);	int numFilesAfterSend = getNumberOfJournalFiles();	
sent num journal files 

public void testRecoveryOnDeleteFailureMetaDataOk() throws Exception {	startBroker();	int sent = produceMessagesToConsumeMultipleDataFiles(50);	int numFilesAfterSend = getNumberOfJournalFiles();	assertTrue("more than x files: " + numFilesAfterSend, numFilesAfterSend > 4);	int received = tryConsume(destination, sent/2);	assertEquals("all message received", sent/2, received);	int numFilesAfterRestart = getNumberOfJournalFiles();	
num journal files before gc 

startBroker();	int sent = produceMessagesToConsumeMultipleDataFiles(50);	int numFilesAfterSend = getNumberOfJournalFiles();	assertTrue("more than x files: " + numFilesAfterSend, numFilesAfterSend > 4);	int received = tryConsume(destination, sent/2);	assertEquals("all message received", sent/2, received);	int numFilesAfterRestart = getNumberOfJournalFiles();	((KahaDBPersistenceAdapter) broker.getPersistenceAdapter()).getStore().checkpoint(true);	int numFilesAfterGC = getNumberOfJournalFiles();	assertEquals("all message received", sent/2, received);	
num journal files after restart nd gc 

========================= activemq sample_1723 =========================

connection = new ProxyConnection(localTransport, remoteTransport);	connection.start();	connections.add(connection);	} catch (Exception e) {	onAcceptError(e);	try {	if (connection != null) {	connection.stop();	}	} catch (Exception eoc) {	
could not close broken connection 

onAcceptError(e);	try {	if (connection != null) {	connection.stop();	}	} catch (Exception eoc) {	}	}	}	public void onAcceptError(Exception error) {	
could not accept connection 

connection.stop();	}	} catch (Exception eoc) {	}	}	}	public void onAcceptError(Exception error) {	}	});	getServer().start();	
proxy connector started 

public void stop() throws Exception {	ServiceStopper ss = new ServiceStopper();	if (this.server != null) {	ss.stop(this.server);	}	for (Iterator<ProxyConnection> iter = connections.iterator(); iter.hasNext();) {	
connector stopped stopping proxy 

public void stop() throws Exception {	ServiceStopper ss = new ServiceStopper();	if (this.server != null) {	ss.stop(this.server);	}	for (Iterator<ProxyConnection> iter = connections.iterator(); iter.hasNext();) {	ss.stop(iter.next());	}	connections.clear();	ss.throwFirstException();	
proxy connector stopped 

private Transport createRemoteTransport(final Transport local) throws Exception {	Transport transport = TransportFactory.compositeConnect(remote);	CompositeTransport ct = transport.narrow(CompositeTransport.class);	if (ct != null && localUri != null && proxyToLocalBroker) {	ct.add(false, new URI[] { localUri });	}	transport = new TransportFilter(transport) {	public void stop() throws Exception {	
stopping proxy 

private Transport createRemoteTransport(final Transport local) throws Exception {	Transport transport = TransportFactory.compositeConnect(remote);	CompositeTransport ct = transport.narrow(CompositeTransport.class);	if (ct != null && localUri != null && proxyToLocalBroker) {	ct.add(false, new URI[] { localUri });	}	transport = new TransportFilter(transport) {	public void stop() throws Exception {	super.stop();	ProxyConnection dummy = new ProxyConnection(local, this);	
removing proxyconnection 

========================= activemq sample_4171 =========================

try {	if (selectorExpression == null) {	c.add(OpenTypeSupport.convert(messages[i]));	} else {	ctx.setMessageReference(messages[i]);	if (selectorExpression.matches(ctx)) {	c.add(OpenTypeSupport.convert(messages[i]));	}	}	} catch (Throwable e) {	
exception browsing destination 

message.setReadOnlyBody(true);	if (selectorExpression == null) {	answer.add(message);	} else {	ctx.setMessageReference(message);	if (selectorExpression.matches(ctx)) {	answer.add(message);	}	}	} catch (Throwable e) {	
exception browsing destination 

try {	if (selectorExpression == null) {	rc.put(new CompositeDataSupport(ct, factory.getFields(messages[i])));	} else {	ctx.setMessageReference(messages[i]);	if (selectorExpression.matches(ctx)) {	rc.put(new CompositeDataSupport(ct, factory.getFields(messages[i])));	}	}	} catch (Throwable e) {	
exception browsing destination 

========================= activemq sample_3899 =========================

protected BrokerService createBroker() throws Exception {	String uri = getBrokerXml();	
loading broker configuration from the classpath with uri 

========================= activemq sample_2621 =========================

public void testConnectWithPasswordButNoUsername() throws Exception {	MQTT mqtt = createMQTTConnection();	mqtt.setVersion("3.1.1");	mqtt.setClientId("test");	mqtt.setPassword("bar");	BlockingConnection connection = mqtt.blockingConnection();	try {	connection.connect();	fail("Should not be able to connect in this case.");	} catch (Exception ex) {	
exception expected on connect with password but no username 

doTestRetainedMessages("VirtualTopic/TopicA");	}	public void doTestRetainedMessages(String topicName) throws Exception {	MQTT mqtt = createMQTTConnection();	mqtt.setKeepAlive((short) 60);	final String RETAIN = "RETAIN";	final String TOPICA = topicName;	final String[] clientIds = { null, "foo", "durable" };	for (String clientId : clientIds) {	boolean cleanSession = !"durable".equals(clientId);	
testing now with client id clean 

assertEquals(RETAIN, new String(msg.getPayload()));	msg.ack();	assertNull(connection.receive(500, TimeUnit.MILLISECONDS));	connection.unsubscribe(new String[]{TOPICA});	connection.publish(TOPICA, "".getBytes(), QoS.AT_MOST_ONCE, true);	connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_LEAST_ONCE)});	msg = connection.receive(500, TimeUnit.MILLISECONDS);	assertNull("Retained message not cleared for " + clientId, msg);	connection.unsubscribe(new String[]{TOPICA});	connection.publish(TOPICA, RETAIN.getBytes(), QoS.EXACTLY_ONCE, true);	
performing first subscription 

connection.publish(TOPICA, RETAIN.getBytes(), QoS.EXACTLY_ONCE, true);	connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_LEAST_ONCE)});	msg = connection.receive(5000, TimeUnit.MILLISECONDS);	assertNotNull("No reset retained message for " + clientId, msg);	assertEquals(RETAIN, new String(msg.getPayload()));	msg.ack();	assertNull(connection.receive(500, TimeUnit.MILLISECONDS));	connection.disconnect();	connection = mqtt.blockingConnection();	connection.connect();	
performing second subscription 

assertNull(connection.receive(500, TimeUnit.MILLISECONDS));	connection.disconnect();	connection = mqtt.blockingConnection();	connection.connect();	connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_LEAST_ONCE)});	msg = connection.receive(5000, TimeUnit.MILLISECONDS);	assertNotNull("No reset retained message for " + clientId, msg);	assertEquals(RETAIN, new String(msg.getPayload()));	msg.ack();	assertNull(connection.receive(500, TimeUnit.MILLISECONDS));	
test now unsubscribing from for the last time 

}	}	public void testUniqueMessageIds() throws Exception {	MQTT mqtt = createMQTTConnection();	mqtt.setClientId("foo");	mqtt.setKeepAlive((short) 2);	mqtt.setCleanSession(true);	final List<PUBLISH> publishList = new ArrayList<PUBLISH>();	mqtt.setTracer(new Tracer() {	public void onReceive(MQTTFrame frame) {	
client received 

PUBLISH publish = new PUBLISH();	try {	publish.decode(frame);	} catch (ProtocolException e) {	fail("Error decoding publish " + e.getMessage());	}	publishList.add(publish);	}	}	public void onSend(MQTTFrame frame) {	
client sent 

}	connection.unsubscribe(subs);	connection.disconnect();	}	public void testResendMessageId() throws Exception {	final MQTT mqtt = createMQTTConnection("resend", false);	mqtt.setKeepAlive((short) 5);	final List<PUBLISH> publishList = new ArrayList<PUBLISH>();	mqtt.setTracer(new Tracer() {	public void onReceive(MQTTFrame frame) {	
client received 

PUBLISH publish = new PUBLISH();	try {	publish.decode(frame);	} catch (ProtocolException e) {	fail("Error decoding publish " + e.getMessage());	}	publishList.add(publish);	}	}	public void onSend(MQTTFrame frame) {	
client sent 

assertTrue(publishList.get(2).dup() && publishList.get(3).dup());	connection.unsubscribe(topics);	connection.disconnect();	}	public void testPacketIdGeneratorNonCleanSession() throws Exception {	final MQTT mqtt = createMQTTConnection("nonclean-packetid", false);	mqtt.setKeepAlive((short) 15);	final Map<Short, PUBLISH> publishMap = new ConcurrentHashMap<Short, PUBLISH>();	mqtt.setTracer(new Tracer() {	public void onReceive(MQTTFrame frame) {	
client received 

public void testPacketIdGeneratorNonCleanSession() throws Exception {	final MQTT mqtt = createMQTTConnection("nonclean-packetid", false);	mqtt.setKeepAlive((short) 15);	final Map<Short, PUBLISH> publishMap = new ConcurrentHashMap<Short, PUBLISH>();	mqtt.setTracer(new Tracer() {	public void onReceive(MQTTFrame frame) {	if (frame.messageType() == PUBLISH.TYPE) {	PUBLISH publish = new PUBLISH();	try {	publish.decode(frame);	
publish 

} catch (ProtocolException e) {	fail("Error decoding publish " + e.getMessage());	}	if (publishMap.get(publish.messageId()) != null) {	assertTrue(publish.dup());	}	publishMap.put(publish.messageId(), publish);	}	}	public void onSend(MQTTFrame frame) {	
client sent 

}	public void testPacketIdGeneratorCleanSession() throws Exception {	final String[] cleanClientIds = new String[] { "", "clean-packetid", null };	final Map<Short, PUBLISH> publishMap = new ConcurrentHashMap<Short, PUBLISH>();	MQTT[] mqtts = new MQTT[cleanClientIds.length];	for (int i = 0; i < cleanClientIds.length; i++) {	mqtts[i] = createMQTTConnection("", true);	mqtts[i].setKeepAlive((short) 15);	mqtts[i].setTracer(new Tracer() {	public void onReceive(MQTTFrame frame) {	
client received 

MQTT[] mqtts = new MQTT[cleanClientIds.length];	for (int i = 0; i < cleanClientIds.length; i++) {	mqtts[i] = createMQTTConnection("", true);	mqtts[i].setKeepAlive((short) 15);	mqtts[i].setTracer(new Tracer() {	public void onReceive(MQTTFrame frame) {	if (frame.messageType() == PUBLISH.TYPE) {	PUBLISH publish = new PUBLISH();	try {	publish.decode(frame);	
publish 

} catch (ProtocolException e) {	fail("Error decoding publish " + e.getMessage());	}	if (publishMap.get(publish.messageId()) != null) {	assertTrue(publish.dup());	}	publishMap.put(publish.messageId(), publish);	}	}	public void onSend(MQTTFrame frame) {	
client sent 

private void testPublishWildcard(String version) throws Exception {	MQTT mqttPub = createMQTTConnection("MQTTPub-Client", true);	mqttPub.setVersion(version);	BlockingConnection blockingConnection = mqttPub.blockingConnection();	blockingConnection.connect();	String payload = "Test Message";	try {	blockingConnection.publish("foo/#", payload.getBytes(), QoS.AT_LEAST_ONCE, false);	fail("Should not be able to publish with wildcard in topic.");	} catch (Exception ex) {	
exception expected on publish with wildcard in topic name 

String payload = "Test Message";	try {	blockingConnection.publish("foo/#", payload.getBytes(), QoS.AT_LEAST_ONCE, false);	fail("Should not be able to publish with wildcard in topic.");	} catch (Exception ex) {	}	try {	blockingConnection.publish("foo/+", payload.getBytes(), QoS.AT_LEAST_ONCE, false);	fail("Should not be able to publish with wildcard in topic.");	} catch (Exception ex) {	
exception expected on publish with wildcard in topic name 

}	assertTrue("Old client disconnected", connection2.isConnected());	connection2.publish(TOPICA, TOPICA.getBytes(), QoS.EXACTLY_ONCE, true);	connection2.disconnect();	}	public void testRepeatedLinkStealing() throws Exception {	final String clientId = "duplicateClient";	final AtomicReference<BlockingConnection> oldConnection = new AtomicReference<BlockingConnection>();	final String TOPICA = "TopicA";	for (int i = 1; i <= 10; ++i) {	
creating mqtt connection 

assertNotNull(message);	message.ack();	}	public void testSubscribeWithZeroLengthTopic() throws Exception {	MQTT mqtt = createMQTTConnection();	mqtt.setClientId("MQTT-Client");	mqtt.setCleanSession(false);	Topic topic = new Topic("", QoS.EXACTLY_ONCE);	final BlockingConnection connection = mqtt.blockingConnection();	connection.connect();	
trying to subscrobe to topic 

MQTT mqtt = createMQTTConnection();	mqtt.setClientId("MQTT-Client");	mqtt.setCleanSession(false);	Topic topic = new Topic("", QoS.EXACTLY_ONCE);	final BlockingConnection connection = mqtt.blockingConnection();	connection.connect();	try {	connection.subscribe(new Topic[] { topic });	fail("Should not be able to subscribe with invalid Topic");	} catch (Exception ex) {	
caught expected error on subscribe 

}	}));	}	public void testUnsubscribeWithZeroLengthTopic() throws Exception {	MQTT mqtt = createMQTTConnection();	mqtt.setClientId("MQTT-Client");	mqtt.setCleanSession(false);	Topic topic = new Topic("", QoS.EXACTLY_ONCE);	final BlockingConnection connection = mqtt.blockingConnection();	connection.connect();	
trying to subscrobe to topic 

MQTT mqtt = createMQTTConnection();	mqtt.setClientId("MQTT-Client");	mqtt.setCleanSession(false);	Topic topic = new Topic("", QoS.EXACTLY_ONCE);	final BlockingConnection connection = mqtt.blockingConnection();	connection.connect();	try {	connection.unsubscribe(new String[] { topic.name().toString() });	fail("Should not be able to subscribe with invalid Topic");	} catch (Exception ex) {	
caught expected error on subscribe 

}));	}	public void testSubscribeWithInvalidMultiLevelWildcards() throws Exception {	MQTT mqtt = createMQTTConnection();	mqtt.setClientId("MQTT-Client");	mqtt.setCleanSession(false);	Topic[] topics = { new Topic("#/Foo", QoS.EXACTLY_ONCE), new Topic("#/Foo/#", QoS.EXACTLY_ONCE), new Topic("Foo/#/Level", QoS.EXACTLY_ONCE), new Topic("Foo/X#", QoS.EXACTLY_ONCE) };	for (int i = 0; i < topics.length; ++i) {	final BlockingConnection connection = mqtt.blockingConnection();	connection.connect();	
trying to subscrobe to topic 

mqtt.setClientId("MQTT-Client");	mqtt.setCleanSession(false);	Topic[] topics = { new Topic("#/Foo", QoS.EXACTLY_ONCE), new Topic("#/Foo/#", QoS.EXACTLY_ONCE), new Topic("Foo/#/Level", QoS.EXACTLY_ONCE), new Topic("Foo/X#", QoS.EXACTLY_ONCE) };	for (int i = 0; i < topics.length; ++i) {	final BlockingConnection connection = mqtt.blockingConnection();	connection.connect();	try {	connection.subscribe(new Topic[] { topics[i] });	fail("Should not be able to subscribe with invalid Topic");	} catch (Exception ex) {	
caught expected error on subscribe 

}	}	public void testSubscribeWithInvalidSingleLevelWildcards() throws Exception {	MQTT mqtt = createMQTTConnection();	mqtt.setClientId("MQTT-Client");	mqtt.setCleanSession(false);	Topic[] topics = { new Topic("Foo+", QoS.EXACTLY_ONCE), new Topic("+Foo/#", QoS.EXACTLY_ONCE), new Topic("+#", QoS.EXACTLY_ONCE), new Topic("Foo/+X/Level", QoS.EXACTLY_ONCE), new Topic("Foo/+F", QoS.EXACTLY_ONCE) };	for (int i = 0; i < topics.length; ++i) {	final BlockingConnection connection = mqtt.blockingConnection();	connection.connect();	
trying to subscrobe to topic 

mqtt.setClientId("MQTT-Client");	mqtt.setCleanSession(false);	Topic[] topics = { new Topic("Foo+", QoS.EXACTLY_ONCE), new Topic("+Foo/#", QoS.EXACTLY_ONCE), new Topic("+#", QoS.EXACTLY_ONCE), new Topic("Foo/+X/Level", QoS.EXACTLY_ONCE), new Topic("Foo/+F", QoS.EXACTLY_ONCE) };	for (int i = 0; i < topics.length; ++i) {	final BlockingConnection connection = mqtt.blockingConnection();	connection.connect();	try {	connection.subscribe(new Topic[] { topics[i] });	fail("Should not be able to subscribe with invalid Topic");	} catch (Exception ex) {	
caught expected error on subscribe 

}	}	public void testUnsubscribeWithInvalidMultiLevelWildcards() throws Exception {	MQTT mqtt = createMQTTConnection();	mqtt.setClientId("MQTT-Client");	mqtt.setCleanSession(false);	Topic[] topics = { new Topic("#/Foo", QoS.EXACTLY_ONCE), new Topic("#/Foo/#", QoS.EXACTLY_ONCE), new Topic("Foo/#/Level", QoS.EXACTLY_ONCE), new Topic("Foo/X#", QoS.EXACTLY_ONCE) };	for (int i = 0; i < topics.length; ++i) {	final BlockingConnection connection = mqtt.blockingConnection();	connection.connect();	
trying to subscrobe to topic 

mqtt.setClientId("MQTT-Client");	mqtt.setCleanSession(false);	Topic[] topics = { new Topic("#/Foo", QoS.EXACTLY_ONCE), new Topic("#/Foo/#", QoS.EXACTLY_ONCE), new Topic("Foo/#/Level", QoS.EXACTLY_ONCE), new Topic("Foo/X#", QoS.EXACTLY_ONCE) };	for (int i = 0; i < topics.length; ++i) {	final BlockingConnection connection = mqtt.blockingConnection();	connection.connect();	try {	connection.unsubscribe(new String[] { topics[i].name().toString() });	fail("Should not be able to unsubscribe with invalid Topic");	} catch (Exception ex) {	
caught expected error on subscribe 

}	}	public void testUnsubscribeWithInvalidSingleLevelWildcards() throws Exception {	MQTT mqtt = createMQTTConnection();	mqtt.setClientId("MQTT-Client");	mqtt.setCleanSession(false);	Topic[] topics = { new Topic("Foo+", QoS.EXACTLY_ONCE), new Topic("+Foo/#", QoS.EXACTLY_ONCE), new Topic("+#", QoS.EXACTLY_ONCE), new Topic("Foo/+X/Level", QoS.EXACTLY_ONCE), new Topic("Foo/+F", QoS.EXACTLY_ONCE) };	for (int i = 0; i < topics.length; ++i) {	final BlockingConnection connection = mqtt.blockingConnection();	connection.connect();	
trying to subscrobe to topic 

mqtt.setClientId("MQTT-Client");	mqtt.setCleanSession(false);	Topic[] topics = { new Topic("Foo+", QoS.EXACTLY_ONCE), new Topic("+Foo/#", QoS.EXACTLY_ONCE), new Topic("+#", QoS.EXACTLY_ONCE), new Topic("Foo/+X/Level", QoS.EXACTLY_ONCE), new Topic("Foo/+F", QoS.EXACTLY_ONCE) };	for (int i = 0; i < topics.length; ++i) {	final BlockingConnection connection = mqtt.blockingConnection();	connection.connect();	try {	connection.unsubscribe(new String[] { topics[i].name().toString() });	fail("Should not be able to unsubscribe with invalid Topic");	} catch (Exception ex) {	
caught expected error on subscribe 

for (Topic topic : topics) {	connection.publish(topic.name().toString(), payload, QoS.AT_LEAST_ONCE, false);	}	int received = 0;	for (int i = 0; i < topics.length; ++i) {	Message message = connection.receive();	assertNotNull(message);	received++;	payload = message.getPayload();	String messageContent = new String(payload);	
received message from topic message content 

for (int i = 0; i < messagesPerRun; ++i) {	Message message = connectionSub.receive(5, TimeUnit.SECONDS);	assertNotNull(message);	received++;	assertTrue(Arrays.equals(payload, message.getPayload()));	message.ack();	}	connectionSub.disconnect();	}	} catch (Exception exception) {	
unexpected exception 

for (int i = 0; i < 5; i++) {	String payload = "Message " + i;	connectionPub.publish(topics[0].name().toString(), payload.getBytes(), QoS.EXACTLY_ONCE, false);	}	connectionSub = mqttSub.blockingConnection();	connectionSub.connect();	int received = 0;	for (int i = 0; i < 5; ++i) {	Message message = connectionSub.receive(5, TimeUnit.SECONDS);	assertNotNull("Missing message " + i, message);	
message is 

========================= activemq sample_869 =========================

}	JobScheduler js = store.getJobScheduler("test");	js.startDispatching();	int count = 0;	long startTime = 10 * 60 * 1000;	long period = startTime;	for (ByteSequence job : list) {	js.schedule("id:" + (count++), job, "", startTime, period, -1);	}	List<Job> test = js.getAllJobs();	
found jobs in the store before restart 

long period = startTime;	for (ByteSequence job : list) {	js.schedule("id:" + (count++), job, "", startTime, period, -1);	}	List<Job> test = js.getAllJobs();	assertEquals(list.size(), test.size());	store.stop();	store.start();	js = store.getJobScheduler("test");	test = js.getAllJobs();	
found jobs in the store after restart 

========================= activemq sample_2334 =========================

} else {	name = "low";	}	for (int i = 1; i <= MESSAGE_COUNT_OF_ONE_GROUP; i++) {	TextMessage message = session.createTextMessage(name + "_" + i);	message.setIntProperty("priority", priority);	producer.send(message);	}	}	long end = System.currentTimeMillis();	
sent messages in ms 

for (int i = 0; i < consumerCount; i++) {	String selector = "priority = " + PRIORITIES[i];	connections[i] = connectionFactory.createConnection();	sessions[i] = connections[i].createSession(false, Session.AUTO_ACKNOWLEDGE);	consumers[i] = sessions[i].createConsumer(destination, selector);	consumers[i].setMessageListener(listener);	}	for (Connection connection : connections) {	connection.start();	}	
received messages 

String selector = "priority = " + PRIORITIES[i];	connections[i] = connectionFactory.createConnection();	sessions[i] = connections[i].createSession(false, Session.AUTO_ACKNOWLEDGE);	consumers[i] = sessions[i].createConsumer(destination, selector);	consumers[i].setMessageListener(listener);	}	for (Connection connection : connections) {	connection.start();	}	assertTrue("got all messages in time", finishLatch.await(60, TimeUnit.SECONDS));	
received messages 

========================= activemq sample_2764 =========================

tt.execute(new TransactionCallbackWithoutResult() {	protected void doInTransactionWithoutResult(TransactionStatus status) {	try {	for (final String queue : QUEUES) {	jmsTemplate.send(queue + "," + AUDIT, new MessageCreator() {	public Message createMessage(Session session) throws JMSException {	return session.createTextMessage("P1: " + queue + " - " + BODY);	}	});	Thread.sleep((long) (Math.random() * SLEEP));	
send msg to 

========================= activemq sample_756 =========================

try {	answer[0] = resp.getResult();	} catch (IOException e) {	e.printStackTrace();	}	}	});	remote.stop();	assertTrue("got expected exception response", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
answer 

public void run() {	for(int i = 0; i < 100; ++i) {	try {	local.oneway(new DummyCommand(sequenceId.incrementAndGet()));	} catch (Exception e) {	}	}	}	});	t.start();	
started async delivery wait for remote s queue to fill up 

}	}	}	});	t.start();	assertTrue(Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return remote.getMessageQueue().remainingCapacity() == 0;	}	}));	
remote messageq is full start it and stop all 

public void run() {	for(int i = 0; i < 3; ++i) {	try {	local.oneway(new DummyCommand(sequenceId.incrementAndGet()));	} catch (Exception e) {	}	}	}	});	t.start();	
started async delivery wait for remote s queue to fill up 

}	}	}	});	t.start();	assertTrue(Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return remote.getMessageQueue().remainingCapacity() == 0;	}	}));	
starting async gate open 

}	}	});	remote.start();	t.start();	assertTrue("Remote should receive: " + expect + ", commands but got: " + remoteReceived.size(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return remoteReceived.size() >= expect;	}	}));	
remote listener received messages 

public void TestTwoWayMessageThroughPutSync() throws Exception {	long totalTimes = 0;	final long executions = 20;	for (int i = 0; i < 20; ++i) {	totalTimes += doTestTwoWayMessageThroughPut(false);	}	
total time of one way sync send throughput test ms 

public void TestTwoWayMessageThroughPutAsnyc() throws Exception {	long totalTimes = 0;	final long executions = 50;	for (int i = 0; i < executions; ++i) {	totalTimes += doTestTwoWayMessageThroughPut(false);	}	
total time of one way async send throughput test ms 

assertTrue(Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return remoteReceived.size() == messageCount;	}	}));	assertTrue(Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return localReceived.size() == messageCount;	}	}));	
all messages sent stop all 

public void TestOneWayMessageThroughPutSync() throws Exception {	long totalTimes = 0;	final long executions = 30;	for (int i = 0; i < executions; ++i) {	totalTimes += doTestOneWayMessageThroughPut(false);	}	
total time of one way sync send throughput test ms 

public void TestOneWayMessageThroughPutAsnyc() throws Exception {	long totalTimes = 0;	final long executions = 20;	for (int i = 0; i < 20; ++i) {	totalTimes += doTestOneWayMessageThroughPut(true);	}	
total time of one way async send throughput test ms 

}	});	localSend.start();	localSend.join();	long endTime = System.currentTimeMillis();	assertTrue(Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return remoteReceived.size() == messageCount;	}	}));	
all messages sent stop all 

assertTrue("Remote should have received ("+messageCount+") but got ()" + remoteReceived.size(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return remoteReceived.size() == messageCount;	}	}));	assertTrue("Local should have received ("+messageCount*2+") but got ()" + localReceived.size(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return localReceived.size() == messageCount*2;	}	}));	
all messages sent stop all 

========================= activemq sample_2508 =========================

public Object getObjectInstance(Object object, Name name, Context nameCtx, Hashtable environment) throws Exception {	Object result = null;	if (object instanceof Reference) {	Reference reference = (Reference)object;	if (log.isTraceEnabled()) {	
getting instance of 

JNDIStorableInterface store = (JNDIStorableInterface)theClass.newInstance();	Properties properties = new Properties();	for (Enumeration iter = reference.getAll(); iter.hasMoreElements();) {	StringRefAddr addr = (StringRefAddr)iter.nextElement();	properties.put(addr.getType(), (addr.getContent() == null) ? "" : addr.getContent());	}	store.setProperties(properties);	result = store;	}	} else {	
object is not a reference cannot load 

public static Reference createReference(String instanceClassName, JNDIStorableInterface po) throws NamingException {	if (log.isTraceEnabled()) {	
creating reference 

========================= activemq sample_243 =========================

}	if (request.getSession().getAttribute("secret") == null || !request.getSession().getAttribute("secret").equals(request.getParameter("secret"))) {	throw new UnsupportedOperationException("Possible CSRF attack");	}	}	ServletRequestDataBinder binder = new ServletRequestDataBinder(object, "request");	try {	binder.bind(request);	binder.setIgnoreUnknownFields(true);	if (LOG.isDebugEnabled()) {	
bound pojo is now 

}	}	ServletRequestDataBinder binder = new ServletRequestDataBinder(object, "request");	try {	binder.bind(request);	binder.setIgnoreUnknownFields(true);	if (LOG.isDebugEnabled()) {	}	}	catch (Exception e) {	
caught 

========================= activemq sample_1324 =========================

} else {	if (nextWriteBatch.canAppend(write)) {	nextWriteBatch.append(write);	break;	} else {	try {	while (nextWriteBatch != null) {	final long start = System.currentTimeMillis();	enqueueMutex.wait();	if (maxStat > 0) {	
waiting for write to finish with full batch millis 

return;	}	enqueueMutex.wait();	}	enqueueMutex.notifyAll();	}	if (dataFile != wb.dataFile) {	if (file != null) {	if (periodicSync) {	if (logger.isTraceEnabled()) {	
syncing file on rotate 

}	file.seek(wb.offset);	if (maxStat > 0) {	if (statIdx < maxStat) {	stats[statIdx++] = sequence.getLength();	} else {	long all = 0;	for (;statIdx > 0;) {	all+= stats[--statIdx];	}	
ave writesize 

replicationTarget.replicate(wb.writes.getHead().location, sequence, forceToDisk);	}	if (forceToDisk) {	file.sync();	}	Journal.WriteCommand lastWrite = wb.writes.getTail();	journal.setLastAppendLocation(lastWrite.location);	signalDone(wb);	}	} catch (Throwable error) {	
journal failed while writing at 

signalError(nextWriteBatch, error);	nextWriteBatch = null;	enqueueMutex.notifyAll();	}	}	} finally {	try {	if (file != null) {	if (periodicSync) {	if (logger.isTraceEnabled()) {	
syning file on close 

protected void signalDone(WriteBatch wb) {	Journal.WriteCommand write = wb.writes.getHead();	while (write != null) {	if (!write.sync) {	inflightWrites.remove(new Journal.WriteKey(write.location));	}	if (write.onComplete != null && wb.exception.get() == null) {	try {	write.onComplete.run();	} catch (Throwable e) {	
add exception was raised while executing the run command for oncomplete 

========================= activemq sample_1774 =========================

AmqpConnection connection = trackConnection(client.connect());	AmqpSession session = connection.createSession();	String address = null;	if (topic) {	address = "temp-topic: } else {	address = "temp-queue: }	try {	session.createSender(address);	fail("Should not be able to create sender to a temp destination that doesn't exist.");	} catch (Exception ex) {	
error creating sender 

AmqpConnection connection = trackConnection(client.connect());	AmqpSession session = connection.createSession();	String address = null;	if (topic) {	address = "temp-topic: } else {	address = "temp-queue: }	try {	session.createReceiver(address);	fail("Should not be able to create sender to a temp destination that doesn't exist.");	} catch (Exception ex) {	
error creating sender 

AmqpConnection connection = trackConnection(client.connect());	AmqpSession session = connection.createSession();	AmqpSender sender = session.createSender(target);	assertNotNull(sender);	if (topic) {	assertEquals(1, brokerView.getTemporaryTopics().length);	} else {	assertEquals(1, brokerView.getTemporaryQueues().length);	}	String address = sender.getSender().getRemoteTarget().getAddress();	
new dynamic sender address 

AmqpConnection connection = trackConnection(client.connect());	AmqpSession session = connection.createSession();	AmqpReceiver receiver = session.createReceiver(source);	assertNotNull(receiver);	if (topic) {	assertEquals(1, brokerView.getTemporaryTopics().length);	} else {	assertEquals(1, brokerView.getTemporaryQueues().length);	}	String address = receiver.getReceiver().getRemoteSource().getAddress();	
new dynamic receiver address 

========================= activemq sample_1563 =========================

public Transport compositeConfigure(Transport transport, WireFormat format, Map options) {	TcpTransport tcpTransport = transport.narrow(TcpTransport.class);	IntrospectionSupport.setProperties(tcpTransport, options);	Map<String, Object> socketOptions = IntrospectionSupport.extractProperties(options, "socket.");	tcpTransport.setSocketOptions(socketOptions);	if (tcpTransport.isTrace()) {	try {	transport = TransportLoggerSupport.createTransportLogger(transport, tcpTransport.getLogWriterName(), tcpTransport.isDynamicManagement(), tcpTransport.isStartLogging(), tcpTransport.getJmxPort());	} catch (Throwable e) {	
could not create transportlogger object for reason 

protected Transport createTransport(URI location, WireFormat wf) throws UnknownHostException, IOException {	URI localLocation = null;	String path = location.getPath();	if (path != null && path.length() > 0) {	int localPortIndex = path.indexOf(':');	try {	Integer.parseInt(path.substring(localPortIndex + 1, path.length()));	String localString = location.getScheme() + ":/" + path;	localLocation = new URI(localString);	} catch (Exception e) {	
path isn t a valid local location for tcptransport to use 

URI localLocation = null;	String path = location.getPath();	if (path != null && path.length() > 0) {	int localPortIndex = path.indexOf(':');	try {	Integer.parseInt(path.substring(localPortIndex + 1, path.length()));	String localString = location.getScheme() + ":/" + path;	localLocation = new URI(localString);	} catch (Exception e) {	if(LOG.isDebugEnabled()) {	
failure detail 

========================= activemq sample_111 =========================

StompFrame msg = stompConnection.receive();	assertTrue(msg.getAction().equals("MESSAGE"));	HashMap<String, String> ackHeaders = new HashMap<String, String>();	ackHeaders.put("message-id", msg.getHeaders().get("message-id"));	ackHeaders.put("content-length", "8511");	StompFrame ack = new StompFrame("ACK", ackHeaders);	stompConnection.sendFrame(ack.format());	final QueueViewMBean queueView = getProxyToQueue(getQueueName());	assertTrue("dequeue complete", Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception {	
queueview enqueue dequeue inflight 

sendMessage("first message");	frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("MESSAGE"));	frame = "UNSUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "receipt:1" +  "\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	frame = stompConnection.receiveFrame();	assertTrue("" + frame, frame.startsWith("RECEIPT"));	sendMessage("second message");	try {	frame = stompConnection.receiveFrame(500);	
received frame 

public void testTransformationSendXMLObject() throws Exception {	MessageConsumer consumer = session.createConsumer(queue);	String frame = "CONNECT\n" + "login:system\n" + "passcode:manager\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "transformation:" + Stomp.Transformations.JMS_OBJECT_XML + "\n\n" + xmlObject + Stomp.NULL;	stompConnection.sendFrame(frame);	Message message = consumer.receive(2500);	assertNotNull(message);	
broke sent 

mapMessage.setString("name", "Dejan");	mapMessage.setString("city", "Belgrade");	producer.send(mapMessage);	String frame = "CONNECT\n" + "login:system\n" + "passcode:manager\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	frame = "SUBSCRIBE\n" + "destination:/queue/USERS." + getQueueName() + "\n" + "ack:auto" + "\n" + "transformation:"	+ Stomp.Transformations.JMS_JSON + "\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	StompFrame json = stompConnection.receive();	
transformed frame 

stompConnection.sendFrame(frame);	frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	frame = "SUBSCRIBE\n" + "destination:/queue/USERS." + getQueueName() + "\n" + "ack:auto" + "\n" + "transformation:"	+ Stomp.Transformations.JMS_JSON + "\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	StompFrame json = stompConnection.receive();	SamplePojo pojo = createObjectFromJson(json.getBody());	assertTrue(pojo.getCity().equals("Belgrade"));	assertTrue(pojo.getName().equals("Dejan"));	json = stompConnection.receive();	
transformed frame 

public void testTransformationSendAndReceiveXmlMap() throws Exception {	String frame = "CONNECT\n" + "login:system\n" + "passcode:manager\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:auto" + "\n" + "transformation:" + Stomp.Transformations.JMS_XML + "\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "transformation:" + Stomp.Transformations.JMS_MAP_JSON + "\n\n" + jsonMap + Stomp.NULL;	stompConnection.sendFrame(frame);	StompFrame xmlFrame = stompConnection.receive();	
received frame 

public void testTransformationSendAndReceiveJsonMap() throws Exception {	String frame = "CONNECT\n" + "login:system\n" + "passcode:manager\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:auto" + "\n" + "transformation:" + Stomp.Transformations.JMS_JSON + "\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "transformation:" + Stomp.Transformations.JMS_MAP_XML + "\n\n" + xmlMap + Stomp.NULL;	stompConnection.sendFrame(frame);	StompFrame json = stompConnection.receive();	
received frame 

message.setString("name", "Dejan");	message.setString("city", "Belgrade");	producer.send(message);	String frame = "CONNECT\n" + "login:system\n" + "passcode:manager\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	frame = "SUBSCRIBE\n" + "destination:/queue/USERS." + getQueueName() + "\n" + "ack:auto\n" + "transformation:" + Stomp.Transformations.JMS_MAP_XML + "\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	StompFrame xmlFrame = stompConnection.receive();	
received frame 

message.setString("name", "Dejan");	message.setString("city", "Belgrade");	producer.send(message);	String frame = "CONNECT\n" + "login:system\n" + "passcode:manager\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	frame = "SUBSCRIBE\n" + "destination:/queue/USERS." + getQueueName() + "\n" + "ack:auto\n" + "transformation:" + Stomp.Transformations.JMS_MAP_JSON + "\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	StompFrame json = stompConnection.receive();	
received frame 

private void doTestActiveMQReplyToTempDestination(String type) throws Exception {	
starting test on temp destinations using a temporary 

private void doTestActiveMQReplyToTempDestination(String type) throws Exception {	final String dest = "/" + type + "/" + getQueueName();	final String tempDest = String.format("/temp-%s/2C26441740C0ECC9tt1", type);	
test is using out bound topic and replyto dest 

StompFrame received = stompConnection.receive();	assertNotNull(received);	String remoteReplyTo = received.getHeaders().get(Stomp.Headers.Send.REPLY_TO);	assertNotNull(remoteReplyTo);	assertTrue(remoteReplyTo.startsWith(String.format("/temp-%s/", type)));	LOG.info(String.format("Received request message: %s with %s=%s", received.getAction(), Stomp.Headers.Send.REPLY_TO, remoteReplyTo));	stompConnection.send(remoteReplyTo, "RESPONSE");	StompFrame reply = stompConnection.receive();	assertNotNull(reply);	assertEquals("MESSAGE", reply.getAction());	
response s received 

private void doReplyToAcrossConnections(String type) throws Exception {	
starting test on temp destinations using a temporary 

private void doReplyToAcrossConnections(String type) throws Exception {	StompConnection responder = new StompConnection();	stompConnect(responder);	String frame = "CONNECT\n" + "login:system\n" + "passcode:manager\n\n" + Stomp.NULL;	responder.sendFrame(frame);	frame = responder.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	final String dest = "/" + type + "/" + getQueueName();	final String tempDest = String.format("/temp-%s/2C26441740C0ECC9tt1:1:0:1", type);	
test is using out bound topic and replyto dest 

assertNotNull(received);	String remoteReplyTo = received.getHeaders().get(Stomp.Headers.Send.REPLY_TO);	assertNotNull(remoteReplyTo);	assertTrue(remoteReplyTo.startsWith(String.format("/remote-temp-%s/", type)));	LOG.info(String.format("Received request message: %s with %s=%s", received.getAction(), Stomp.Headers.Send.REPLY_TO, remoteReplyTo));	responder.send(remoteReplyTo, "RESPONSE");	StompFrame reply = stompConnection.receive();	assertNotNull(reply);	assertEquals("MESSAGE", reply.getAction());	assertTrue(reply.getBody().contains("RESPONSE"));	
response s received 

boolean gotMessage = false;	boolean gotReceipt = false;	char[] payload = new char[1024];	Arrays.fill(payload, 'A');	String test = "SEND\n" + "x-type:DEV-3485\n"  + "x-uuid:" + UUID.randomUUID() + "\n"  + "persistent:true\n"  + "receipt:" + UUID.randomUUID() + "\n" + "destination:/queue/test.DEV-3485" + "\n\n" + new String(payload) + Stomp.NULL;	frame = "SUBSCRIBE\n" + "destination:/queue/test.DEV-3485\n" + "ack:auto\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	stompConnection.sendFrame(test);	while (!gotMessage && !gotReceipt) {	frame = stompConnection.receiveFrame();	
received the frame 

public void testHeaderValuesAreTrimmed1_0() throws Exception {	String connectFrame = "CONNECT\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.0\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

StompFrame message = stompConnection.receive();	stompConnection.ack(message, "tx"+j);	}	stompConnection.commit("tx"+j);	}	List<Subscription> subs = getDestinationConsumers(brokerService, ActiveMQDestination.createDestination("test", topic ? ActiveMQDestination.TOPIC_TYPE : ActiveMQDestination.QUEUE_TYPE));	for (Subscription subscription : subs) {	final AbstractSubscription abstractSubscription = (AbstractSubscription) subscription;	assertTrue("prefetchExtension should be back to Zero after commit", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
ext 

========================= activemq sample_1426 =========================

for (int i = 0; i < operations; i++) {	Integer op = removed.poll(1000, TimeUnit.MILLISECONDS);	assertNotNull(op);	ops.add(op);	}	running.set(false);	if (useWaitForSpaceThread) {	try {	waitForSpaceThread.join(1000);	} catch (InterruptedException e) {	
attempt waitforspace never returned 

try {	waitForSpaceThread.join(1000);	} catch (InterruptedException e) {	waitForSpaceThread.interrupt();	waitForSpaceThread.join();	}	}	removeThread.join();	addThread.join();	if (memUsage.getPercentUsage() != 0 || memUsage.getUsage() != memUsage.getPercentUsage()) {	
attempt 

try {	waitForSpaceThread.join(1000);	} catch (InterruptedException e) {	waitForSpaceThread.interrupt();	waitForSpaceThread.join();	}	}	removeThread.join();	addThread.join();	if (memUsage.getPercentUsage() != 0 || memUsage.getUsage() != memUsage.getPercentUsage()) {	
operations 

========================= activemq sample_18 =========================

List<String> features = new ArrayList<String>();	for (Map.Entry<Object, Object> prop : properties.entrySet()) {	String key = (String) prop.getKey();	if (key.startsWith(DOCUMENT_BUILDER_FACTORY_FEATURE)) {	String uri = key.split(DOCUMENT_BUILDER_FACTORY_FEATURE + ":")[1];	Boolean value = Boolean.valueOf((String)prop.getValue());	try {	factory.setFeature(uri, value);	features.add("feature " + uri + " value " + value);	} catch (ParserConfigurationException e) {	
documentbuilderfactory doesn t support the feature with value due to 

========================= activemq sample_668 =========================

public void testNetworkStartupColon() throws Exception {	BrokerService brokerColon = new BrokerService();	brokerColon.setBrokerName("BrokerA:Colon");	brokerColon.setUseJmx(true);	BrokerService brokerColonB = createBroker(new URI("broker:()BrokerB?persistent=false&useJmx=false"));	brokerColonB.addConnector("tcp: brokerColonB.start();	String uri = "static:(" + brokerColonB.getTransportConnectors().get(0).getPublishableConnectString() + ")";	NetworkConnector connector = new DiscoveryNetworkConnector(new URI(uri));	connector.setName("bridge-to-b");	brokerColon.setNetworkConnectors(Arrays.asList(new NetworkConnector[]{connector}));	
starting broker with colon in name 

========================= activemq sample_3698 =========================

public void test() throws Exception {	
starting test 

private void consumeAndRollback() throws JMSException, InterruptedException {	ActiveMQConnection connection = createConnection();	RedeliveryPolicy noRedelivery = new RedeliveryPolicy();	noRedelivery.setMaximumRedeliveries(0);	connection.setRedeliveryPolicy(noRedelivery);	connection.start();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageConsumer consumer = session.createConsumer(dest);	Message m;	while ((m = consumer.receive(4000)) != null) {	
got 

public long getQueueSize() throws Exception {	long queueSize = 0;	try {	QueueViewMBean queueViewMBean = (QueueViewMBean) brokerService.getManagementContext().newProxyInstance( BrokerMBeanSupport.createDestinationName(brokerService.getBrokerObjectName(), dest), QueueViewMBean.class, false);	queueSize = queueViewMBean.getQueueSize();	
queuesize for destination is 

public long getQueueSize() throws Exception {	long queueSize = 0;	try {	QueueViewMBean queueViewMBean = (QueueViewMBean) brokerService.getManagementContext().newProxyInstance( BrokerMBeanSupport.createDestinationName(brokerService.getBrokerObjectName(), dest), QueueViewMBean.class, false);	queueSize = queueViewMBean.getQueueSize();	} catch (Exception ex) {	
error retrieving queuesize from jmx 

========================= activemq sample_2820 =========================

public boolean matches(MessageReference node, MessageEvaluationContext context) throws IOException {	ConsumerId targetConsumerId = node.getTargetConsumerId();	if (targetConsumerId != null) {	if (!targetConsumerId.equals(info.getConsumerId())) {	return false;	}	}	try {	return (selectorExpression == null || selectorExpression.matches(context)) && this.context.isAllowedToConsume(node);	} catch (JMSException e) {	
selector failed to evaluate 

========================= activemq sample_4018 =========================

public void testPersistJMSRedeliveredMessageLossOnIndexRebuild() throws Exception {	sendMessages();	
finished sending messages test starting 

public void testPersistJMSRedeliveredMessageLossOnIndexRebuild() throws Exception {	sendMessages();	long msgCount = getProxyToQueue(QUEUE_NAME).getQueueSize();	final int ITERATIONS = 3;	for (int i = 0; i < ITERATIONS; ++i) {	
consumer and rollback iteration 

========================= activemq sample_2965 =========================

while ((extra = receiveMessage(connection, 0)) != null) {	msg = extra;	printer.increment();	receiveCounter.incrementAndGet();	counter++;	}	}	if (msg != null) {	connection.send(createAck(consumerInfo, msg, counter, MessageAck.STANDARD_ACK_TYPE));	} else if (receiveCounter.get() < consumeCount) {	
consumer stall waiting for message 

producersFinished.release();	}	};	}.start();	}	producersFinished.acquire();	long end1 = System.currentTimeMillis();	consumersFinished.acquire();	long end2 = System.currentTimeMillis();	LOG.info("Results for destination=" + destination + ", producers=" + prodcuerCount + ", consumers=" + consumerCount + ", deliveryMode=" + deliveryMode);	
produced at messages sec 

producersFinished.release();	}	};	}.start();	}	producersFinished.acquire();	long end1 = System.currentTimeMillis();	consumersFinished.acquire();	long end2 = System.currentTimeMillis();	LOG.info("Results for destination=" + destination + ", producers=" + prodcuerCount + ", consumers=" + consumerCount + ", deliveryMode=" + deliveryMode);	
consumed at messages sec 

========================= activemq sample_2318 =========================

public void connectionClosed(ConnectionEvent event) {	try {	((ManagedConnection)event.getSource()).cleanup();	} catch (ResourceException e) {	
error occured during the cleanup of a managed connection 

public void connectionClosed(ConnectionEvent event) {	try {	((ManagedConnection)event.getSource()).cleanup();	} catch (ResourceException e) {	}	try {	((ManagedConnection)event.getSource()).destroy();	} catch (ResourceException e) {	
error occured during the destruction of a managed connection 

public void connectionErrorOccurred(ConnectionEvent event) {	
managed connection experiened an error 

public void connectionErrorOccurred(ConnectionEvent event) {	try {	((ManagedConnection)event.getSource()).cleanup();	} catch (ResourceException e) {	
error occured during the cleanup of a managed connection 

public void connectionErrorOccurred(ConnectionEvent event) {	try {	((ManagedConnection)event.getSource()).cleanup();	} catch (ResourceException e) {	}	try {	((ManagedConnection)event.getSource()).destroy();	} catch (ResourceException e) {	
error occured during the destruction of a managed connection 

========================= activemq sample_845 =========================

if ((networkDestinationContainer = outboundDestinationViewMap.get(destination)) == null) {	ObjectName bridgeObjectName = bridge.getMbeanObjectName();	try {	ObjectName objectName = BrokerMBeanSupport.createNetworkOutBoundDestinationObjectName(bridgeObjectName, destination);	NetworkDestinationView networkDestinationView = new NetworkDestinationView(networkBridgeView, destination.getPhysicalName());	AnnotatedMBean.registerMBean(brokerService.getManagementContext(), networkDestinationView, objectName);	networkDestinationContainer = new NetworkDestinationContainer(networkDestinationView, objectName);	outboundDestinationViewMap.put(destination, networkDestinationContainer);	networkDestinationView.messageSent();	} catch (Exception e) {	
failed to register 

ObjectName bridgeObjectName = bridge.getMbeanObjectName();	try {	ObjectName objectName = BrokerMBeanSupport.createNetworkInBoundDestinationObjectName(bridgeObjectName, destination);	NetworkDestinationView networkDestinationView = new NetworkDestinationView(networkBridgeView, destination.getPhysicalName());	AnnotatedMBean.registerMBean(brokerService.getManagementContext(), networkDestinationView, objectName);	networkBridgeView.addNetworkDestinationView(networkDestinationView);	networkDestinationContainer = new NetworkDestinationContainer(networkDestinationView, objectName);	inboundDestinationViewMap.put(destination, networkDestinationContainer);	networkDestinationView.messageSent();	} catch (Exception e) {	
failed to register 

public void stop() {	if (!brokerService.isUseJmx()) {	return;	}	scheduler.cancel(purgeInactiveDestinationViewTask);	for (NetworkDestinationContainer networkDestinationContainer : inboundDestinationViewMap.values()) {	try {	brokerService.getManagementContext().unregisterMBean(networkDestinationContainer.objectName);	} catch (Exception e) {	
network bridge could not be unregistered in jmx 

for (NetworkDestinationContainer networkDestinationContainer : inboundDestinationViewMap.values()) {	try {	brokerService.getManagementContext().unregisterMBean(networkDestinationContainer.objectName);	} catch (Exception e) {	}	}	for (NetworkDestinationContainer networkDestinationContainer : outboundDestinationViewMap.values()) {	try {	brokerService.getManagementContext().unregisterMBean(networkDestinationContainer.objectName);	} catch (Exception e) {	
network bridge could not be unregistered in jmx 

private void purgeInactiveDestinationView(Map<ActiveMQDestination, NetworkDestinationContainer> map) {	long time = System.currentTimeMillis() - networkBridgeConfiguration.getGcSweepTime();	for (Iterator<Map.Entry<ActiveMQDestination, NetworkDestinationContainer>> it = map.entrySet().iterator(); it.hasNext(); ) {	Map.Entry<ActiveMQDestination, NetworkDestinationContainer> entry = it.next();	if (entry.getValue().view.getLastAccessTime() <= time) {	ObjectName objectName = entry.getValue().objectName;	if (objectName != null) {	try {	brokerService.getManagementContext().unregisterMBean(entry.getValue().objectName);	} catch (Throwable e) {	
network bridge could not be unregistered in jmx 

========================= activemq sample_4223 =========================

}	virtualDestinationInterceptor .setVirtualDestinations(getVirtualDestinations());	plugin.info("applied updates to: " + virtualDestinationInterceptor);	updatedExistingInterceptor = true;	ConnectionContext connectionContext;	try {	connectionContext = plugin.getBrokerService().getAdminConnectionContext();	if (plugin.getBrokerService().isUseVirtualDestSubs()) {	for (VirtualDestination removedVirtualDest : removedVirtualDests) {	plugin.virtualDestinationRemoved(connectionContext, removedVirtualDest);	
removing virtual destination 

updatedExistingInterceptor = true;	ConnectionContext connectionContext;	try {	connectionContext = plugin.getBrokerService().getAdminConnectionContext();	if (plugin.getBrokerService().isUseVirtualDestSubs()) {	for (VirtualDestination removedVirtualDest : removedVirtualDests) {	plugin.virtualDestinationRemoved(connectionContext, removedVirtualDest);	}	for (VirtualDestination addedVirtualDest : addedVirtualDests) {	plugin.virtualDestinationAdded(connectionContext, addedVirtualDest);	
adding virtual destination 

connectionContext = plugin.getBrokerService().getAdminConnectionContext();	if (plugin.getBrokerService().isUseVirtualDestSubs()) {	for (VirtualDestination removedVirtualDest : removedVirtualDests) {	plugin.virtualDestinationRemoved(connectionContext, removedVirtualDest);	}	for (VirtualDestination addedVirtualDest : addedVirtualDests) {	plugin.virtualDestinationAdded(connectionContext, addedVirtualDest);	}	}	} catch (Exception e) {	
could not process virtual destination advisories 

========================= activemq sample_4389 =========================

throw new ProtocolException("Illegal destination name: [" + fallbackName + "] -- ActiveMQ STOMP destinations " + "must begin with one of: /queue/ /topic/ /temp-queue/ /temp-topic/", false, e);	}	} else {	throw new ProtocolException("Illegal destination name: [" + originalName + "] -- ActiveMQ STOMP destinations " + "must begin with one of: /queue/ /topic/ /temp-queue/ /temp-topic/");	}	}	if (i < destinations.length - 1) {	destinationBuilder.append(",");	}	}	
new composite destination name 

========================= activemq sample_1471 =========================

public void testPrematureClosure() throws Exception {	ActiveMQConnection persistentConn = (ActiveMQConnection) createConnection();	persistentConn.start();	Session session = persistentConn.createSession(true, Session.SESSION_TRANSACTED);	MessageProducer producer = session.createProducer(destination);	for (int i = 0; i < NUM_ATTEMPTS; i++) {	
attempt 

========================= activemq sample_2877 =========================

try {	final Connection sendCon = createConnection("send");	final Session sendSession = sendCon.createSession(false, Session.AUTO_ACKNOWLEDGE);	final MessageProducer producer = sendSession.createProducer(null);	for (int i = 0; i < messageCount; i++) {	boolean filter = i % 2 == 1;	Message message = sendSession.createMessage();	message.setStringProperty("filter", filter ? "true" : "false");	producer.send(topic, message);	if (i > 0 && i % 10000 == 0) {	
sent 

}	sendSession.close();	sendCon.close();	} catch (Exception e) {	exceptions.add(e);	}	}	};	sendThread.start();	goOn.await(5, TimeUnit.MINUTES);	
activating consumers 

session.unsubscribe("true");	consumerFalse.close();	session.unsubscribe("false");	consumerAll.close();	session.unsubscribe("all");	session.close();	con.close();	PersistenceAdapter persistenceAdapter = broker.getPersistenceAdapter();	if( persistenceAdapter instanceof KahaDBPersistenceAdapter) {	final KahaDBStore store = ((KahaDBPersistenceAdapter) persistenceAdapter).getStore();	
store page count 

session.unsubscribe("true");	consumerFalse.close();	session.unsubscribe("false");	consumerAll.close();	session.unsubscribe("all");	session.close();	con.close();	PersistenceAdapter persistenceAdapter = broker.getPersistenceAdapter();	if( persistenceAdapter instanceof KahaDBPersistenceAdapter) {	final KahaDBStore store = ((KahaDBPersistenceAdapter) persistenceAdapter).getStore();	
store free page count 

session.unsubscribe("true");	consumerFalse.close();	session.unsubscribe("false");	consumerAll.close();	session.unsubscribe("all");	session.close();	con.close();	PersistenceAdapter persistenceAdapter = broker.getPersistenceAdapter();	if( persistenceAdapter instanceof KahaDBPersistenceAdapter) {	final KahaDBStore store = ((KahaDBPersistenceAdapter) persistenceAdapter).getStore();	
store page in use 

========================= activemq sample_3620 =========================

broker.setUseJmx(true);	broker.addConnector("tcp: SystemUsage systemUsage;	systemUsage = new SystemUsage();	systemUsage.getMemoryUsage().setLimit(10 * 1024 * 1024);	broker.setSystemUsage(systemUsage);	KahaDBPersistenceAdapter kahaDBPersistenceAdapter = new KahaDBPersistenceAdapter();	kahaDBPersistenceAdapter.setJournalMaxFileLength(16*1024);	kahaDBPersistenceAdapter.setCleanupInterval(500);	broker.setPersistenceAdapter(kahaDBPersistenceAdapter);	broker.start();	
starting broker 

buildReceiver(haloConnection, troyToHalo, true, troyReceiver, false);	haloConnection.start();	troyConnection.start();	troyThread.start();	xenaConnection.start();	xenaThread.start();	hectorConnection.start();	hectorThread.start();	waitForMessagesToBeDelivered();	assertEquals(hectorToHaloCtr, counter);	
hectortohalo received messages 

haloConnection.start();	troyConnection.start();	troyThread.start();	xenaConnection.start();	xenaThread.start();	hectorConnection.start();	hectorThread.start();	waitForMessagesToBeDelivered();	assertEquals(hectorToHaloCtr, counter);	assertEquals(xenaToHaloCtr, counter);	
xenatohalo received messages 

troyConnection.start();	troyThread.start();	xenaConnection.start();	xenaThread.start();	hectorConnection.start();	hectorThread.start();	waitForMessagesToBeDelivered();	assertEquals(hectorToHaloCtr, counter);	assertEquals(xenaToHaloCtr, counter);	assertEquals(troyToHaloCtr, counter);	
troytohalo received messages 

troyThread.start();	xenaConnection.start();	xenaThread.start();	hectorConnection.start();	hectorThread.start();	waitForMessagesToBeDelivered();	assertEquals(hectorToHaloCtr, counter);	assertEquals(xenaToHaloCtr, counter);	assertEquals(troyToHaloCtr, counter);	assertEquals(haloToHectorCtr, counter);	
halotohector received messages 

xenaConnection.start();	xenaThread.start();	hectorConnection.start();	hectorThread.start();	waitForMessagesToBeDelivered();	assertEquals(hectorToHaloCtr, counter);	assertEquals(xenaToHaloCtr, counter);	assertEquals(troyToHaloCtr, counter);	assertEquals(haloToHectorCtr, counter);	assertEquals(haloToXenaCtr, counter);	
halotoxena received messages 

xenaThread.start();	hectorConnection.start();	hectorThread.start();	waitForMessagesToBeDelivered();	assertEquals(hectorToHaloCtr, counter);	assertEquals(xenaToHaloCtr, counter);	assertEquals(troyToHaloCtr, counter);	assertEquals(haloToHectorCtr, counter);	assertEquals(haloToXenaCtr, counter);	assertEquals(haloToTroyCtr, counter);	
halototroy received messages 

========================= activemq sample_2932 =========================

public void testDurableTopicResourcesAreRemoved() throws Exception {	
test starting 

public void testDurableTopicResourcesAreRemoved() throws Exception {	ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(connectionURI);	for (int i = 0; i < 2; ++i) {	
test main loop starting iteration 

public void testDurableTopicResourcesAreRemoved() throws Exception {	ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(connectionURI);	for (int i = 0; i < 2; ++i) {	Connection connection = factory.createConnection();	connection.setClientID("client_id");	connection.start();	for (int j = 0; j < 8; j++) {	
test sub loop starting iteration 

subscriber.close();	session.unsubscribe(subscriberName);	session.close();	}	connection.stop();	connection.close();	connection = null;	Thread.sleep(10);	}	assertEquals(0, broker.getSystemUsage().getMemoryUsage().getNumUsageListeners());	
test completed 

========================= activemq sample_2898 =========================

public void testMod() throws Exception {	String configurationSeed = "destinationTest";	final String brokerConfig = configurationSeed + "-destinations";	applyNewConfig(brokerConfig, configurationSeed + "-original");	startBroker(brokerConfig);	assertTrue("broker alive", brokerService.isStarted());	printDestinations();	assertTrue("contains original", containsDestination(new ActiveMQQueue("ORIGINAL")));	
adding destinations 

applyNewConfig(brokerConfig, configurationSeed + "-original");	startBroker(brokerConfig);	assertTrue("broker alive", brokerService.isStarted());	printDestinations();	assertTrue("contains original", containsDestination(new ActiveMQQueue("ORIGINAL")));	applyNewConfig(brokerConfig, configurationSeed + "-add", SLEEP);	printDestinations();	assertTrue("contains original", containsDestination(new ActiveMQQueue("ORIGINAL")));	assertTrue("contains before", containsDestination(new ActiveMQTopic("BEFORE")));	assertTrue("contains after", containsDestination(new ActiveMQQueue("AFTER")));	
removing destinations 

protected void printDestinations() throws Exception {	ActiveMQDestination[] destinations = brokerService.getRegionBroker().getDestinations();	for (ActiveMQDestination destination : destinations) {	
broker destination 

========================= activemq sample_4370 =========================

public void evaluate() throws Throwable {	for (int i = 0; i < repetitions && !untilFailure; i++) {	if (untilFailure) {	
running test iteration 

public void evaluate() throws Throwable {	for (int i = 0; i < repetitions && !untilFailure; i++) {	if (untilFailure) {	} else {	
running test iteration of configured repetitions 

========================= activemq sample_1172 =========================

protected CommandChannel createCommandChannel() throws IOException {	socket = new MulticastSocket(mcastPort);	socket.setLoopbackMode(loopBackMode);	socket.setTimeToLive(timeToLive);	
joining multicast address 

========================= activemq sample_59 =========================

final Connection consumerConnection = factory.createConnection();	consumerConnection.setClientID("subscriber1");	Session consumerMQSession = consumerConnection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	TopicSubscriber activeConsumer = (TopicSubscriber) consumerMQSession.createDurableSubscriber(destination, "myTopic");	consumerConnection.start();	Session session = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(deliveryMode);	final BrokerView brokerView = broker.getAdminView();	assertEquals(1, brokerView.getDurableTopicSubscribers().length);	
current durable topic subscriptions 

consumerConnection.start();	Session session = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(deliveryMode);	final BrokerView brokerView = broker.getAdminView();	assertEquals(1, brokerView.getDurableTopicSubscribers().length);	try {	brokerView.destroyDurableSubscriber("subscriber1", "myTopic");	fail("Expected Exception for Durable consumer is in use");	} catch(Exception e) {	
recieved expected exception 

Session session = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(deliveryMode);	final BrokerView brokerView = broker.getAdminView();	assertEquals(1, brokerView.getDurableTopicSubscribers().length);	try {	brokerView.destroyDurableSubscriber("subscriber1", "myTopic");	fail("Expected Exception for Durable consumer is in use");	} catch(Exception e) {	}	
current durable topic subscriptions 

========================= activemq sample_2861 =========================

public void testRunOutOfSpace() throws Exception {	BrokerService broker = new BrokerService();	File dataDir = new File("/Volumes/NO NAME/");	File useUpSpace = new File(dataDir, "bigFile");	if (!useUpSpace.exists()) {	
using up some space 

filler.close();	File toDelete = new File(dataDir, "toDelete");	filler = new RandomAccessFile(toDelete, "rw");	filler.setLength(1024*1024*32*10);	filler.close();	}	broker.setDataDirectoryFile(dataDir);	broker.start();	AtomicLong consumed = new AtomicLong(0);	consume(consumed);	
consumed 

}	broker.setDataDirectoryFile(dataDir);	broker.start();	AtomicLong consumed = new AtomicLong(0);	consume(consumed);	broker.getPersistenceAdapter().checkpoint(true);	AtomicLong sent = new AtomicLong(0);	try {	produce(sent, 200);	} catch (Exception expected) {	
got ex sent 

broker.setDataDirectoryFile(dataDir);	broker.start();	AtomicLong consumed = new AtomicLong(0);	consume(consumed);	broker.getPersistenceAdapter().checkpoint(true);	AtomicLong sent = new AtomicLong(0);	try {	produce(sent, 200);	} catch (Exception expected) {	}	
sent 

consume(consumed);	broker.getPersistenceAdapter().checkpoint(true);	AtomicLong sent = new AtomicLong(0);	try {	produce(sent, 200);	} catch (Exception expected) {	}	System.out.println("Remove toDelete file and press any key to continue");	int read = System.in.read();	System.err.println("read:" + read);	
trying to send again 

try {	produce(sent, 200);	} catch (Exception expected) {	}	System.out.println("Remove toDelete file and press any key to continue");	int read = System.in.read();	System.err.println("read:" + read);	try {	produce(sent, 200);	} catch (Exception expected) {	
got ex sent 

produce(sent, 200);	} catch (Exception expected) {	}	System.out.println("Remove toDelete file and press any key to continue");	int read = System.in.read();	System.err.println("read:" + read);	try {	produce(sent, 200);	} catch (Exception expected) {	}	
sent 

========================= activemq sample_3773 =========================

public Broker installPlugin(Broker broker) throws Exception {	
installing runtimeconfiguration plugin 

========================= activemq sample_4409 =========================

receiveAndDiscard100messages(latch);	}	});	for (int j = 0; j < 10; j++) {	pool.execute(new Runnable() {	public void run() {	send10000messages(latch);	}	});	}	
waiting on the send receive latch 

}	});	for (int j = 0; j < 10; j++) {	pool.execute(new Runnable() {	public void run() {	send10000messages(latch);	}	});	}	latch.await(5, TimeUnit.MINUTES);	
Resumed 

public void destroyQueue() {	try {	Broker broker = this.broker.getBroker();	if (!broker.isStopped()) {	
removing 

public void destroyQueue() {	try {	Broker broker = this.broker.getBroker();	if (!broker.isStopped()) {	broker.removeDestination(this.broker.getAdminConnectionContext(), new ActiveMQQueue(queueName), 10);	}	} catch (Exception e) {	
got an error while removing the test queue 

textMessage.setText(generateBody(1000));	textMessage.setJMSDeliveryMode(DeliveryMode.NON_PERSISTENT);	producer.send(textMessage);	try {	Thread.sleep(10);	} catch (InterruptedException e) {	}	}	producer.close();	} catch (JMSException e) {	
got an error while sending the messages 

ActiveMQConnection activeMQConnection = null;	try {	activeMQConnection = createConnection(null);	Session session = activeMQConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer messageConsumer = session.createConsumer( session.createQueue(queueName));	activeMQConnection.start();	for (int i = 0; i < 100; i++) {	messageConsumer.receive();	}	messageConsumer.close();	
created and disconnected 

try {	activeMQConnection = createConnection(null);	Session session = activeMQConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer messageConsumer = session.createConsumer( session.createQueue(queueName));	activeMQConnection.start();	for (int i = 0; i < 100; i++) {	messageConsumer.receive();	}	messageConsumer.close();	} catch (JMSException e) {	
got an error while receiving the messages 

========================= activemq sample_2924 =========================

final NetworkConnector networkConnector = local.addNetworkConnector("static:(" + remote.getTransportConnectorByScheme("nio+ssl").getPublishableConnectString().replace("nio+ssl", "ssl") + ")?useExponentialBackOff=false&initialReconnectDelay=10");	local.start();	assertTrue("Bridge created", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return !networkConnector.activeBridges().isEmpty() && (networkConnector.activeBridges().toArray(new DurableConduitBridge[]{})[0].getRemoteBrokerName() != null);	}	}));	final AtomicReference<DurableConduitBridge> bridge = new AtomicReference<>((DurableConduitBridge) networkConnector.activeBridges().iterator().next());	assertTrue("Connected to R", bridge.get().getRemoteBrokerName().equals("R"));	for (int i=0; i<200;  i++) {	
forcing error on nc via remote exception iteration bridge 

========================= activemq sample_2709 =========================

protected void  runTestIteration () throws Throwable {	if ( iterationFoundFailure ) {	
skipping test iteration failure previously detected 

protected void  configureMessageListener (MessageConsumer consumer) throws JMSException {	final MessageConsumer   fConsumer = consumer;	consumer.setMessageListener(new MessageListener() {	public void onMessage (Message msg) {	
got a message on consumer 

protected void  closeConnection (Connection conn) {	try {	conn.close();	} catch ( JMSException jmsExc ) {	
failed to cleanup connection 

protected void  delay (long delayMs, String desc) {	try {	Thread.sleep(delayMs);	} catch ( InterruptedException intExc ) {	
sleep interrupted 

protected void  waitForMessage (long delayMs) {	try {	synchronized ( this.messageReceiveSync ) {	if ( this.receiveCount == 0 ) {	this.messageReceiveSync.wait(delayMs);	}	}	} catch ( InterruptedException intExc ) {	
sleep interrupted wait for message to arrive 

========================= activemq sample_2359 =========================

protected void addTranportConnectors() throws Exception {	TransportConnector connector = null;	if (isUseOpenWireConnector()) {	connector = brokerService.addConnector( "tcp: openwirePort = connector.getConnectUri().getPort();	openwireURI = connector.getPublishableConnectURI();	
using openwire port 

protected void addTranportConnectors() throws Exception {	TransportConnector connector = null;	if (isUseOpenWireConnector()) {	connector = brokerService.addConnector( "tcp: openwirePort = connector.getConnectUri().getPort();	openwireURI = connector.getPublishableConnectURI();	}	if (isUseTcpConnector()) {	connector = brokerService.addConnector( "amqp: amqpPort = connector.getConnectUri().getPort();	amqpURI = connector.getPublishableConnectURI();	
using amqp port 

connector = brokerService.addConnector( "tcp: openwirePort = connector.getConnectUri().getPort();	openwireURI = connector.getPublishableConnectURI();	}	if (isUseTcpConnector()) {	connector = brokerService.addConnector( "amqp: amqpPort = connector.getConnectUri().getPort();	amqpURI = connector.getPublishableConnectURI();	}	if (isUseSslConnector()) {	connector = brokerService.addConnector( "amqp+ssl: amqpSslPort = connector.getConnectUri().getPort();	amqpSslURI = connector.getPublishableConnectURI();	
using amqp ssl port 

connector = brokerService.addConnector( "amqp: amqpPort = connector.getConnectUri().getPort();	amqpURI = connector.getPublishableConnectURI();	}	if (isUseSslConnector()) {	connector = brokerService.addConnector( "amqp+ssl: amqpSslPort = connector.getConnectUri().getPort();	amqpSslURI = connector.getPublishableConnectURI();	}	if (isUseNioConnector()) {	connector = brokerService.addConnector( "amqp+nio: amqpNioPort = connector.getConnectUri().getPort();	amqpNioURI = connector.getPublishableConnectURI();	
using amqp nio port 

connector = brokerService.addConnector( "amqp+ssl: amqpSslPort = connector.getConnectUri().getPort();	amqpSslURI = connector.getPublishableConnectURI();	}	if (isUseNioConnector()) {	connector = brokerService.addConnector( "amqp+nio: amqpNioPort = connector.getConnectUri().getPort();	amqpNioURI = connector.getPublishableConnectURI();	}	if (isUseNioPlusSslConnector()) {	connector = brokerService.addConnector( "amqp+nio+ssl: amqpNioPlusSslPort = connector.getConnectUri().getPort();	amqpNioPlusSslURI = connector.getPublishableConnectURI();	
using amqp nio ssl port 

connector = brokerService.addConnector( "amqp+nio: amqpNioPort = connector.getConnectUri().getPort();	amqpNioURI = connector.getPublishableConnectURI();	}	if (isUseNioPlusSslConnector()) {	connector = brokerService.addConnector( "amqp+nio+ssl: amqpNioPlusSslPort = connector.getConnectUri().getPort();	amqpNioPlusSslURI = connector.getPublishableConnectURI();	}	if (isUseAutoConnector()) {	connector = brokerService.addConnector( "auto: autoPort = connector.getConnectUri().getPort();	autoURI = connector.getPublishableConnectURI();	
using auto port 

connector = brokerService.addConnector( "amqp+nio+ssl: amqpNioPlusSslPort = connector.getConnectUri().getPort();	amqpNioPlusSslURI = connector.getPublishableConnectURI();	}	if (isUseAutoConnector()) {	connector = brokerService.addConnector( "auto: autoPort = connector.getConnectUri().getPort();	autoURI = connector.getPublishableConnectURI();	}	if (isUseAutoSslConnector()) {	connector = brokerService.addConnector( "auto+ssl: autoSslPort = connector.getConnectUri().getPort();	autoSslURI = connector.getPublishableConnectURI();	
using auto ssl port 

connector = brokerService.addConnector( "auto: autoPort = connector.getConnectUri().getPort();	autoURI = connector.getPublishableConnectURI();	}	if (isUseAutoSslConnector()) {	connector = brokerService.addConnector( "auto+ssl: autoSslPort = connector.getConnectUri().getPort();	autoSslURI = connector.getPublishableConnectURI();	}	if (isUseAutoNioConnector()) {	connector = brokerService.addConnector( "auto+nio: autoNioPort = connector.getConnectUri().getPort();	autoNioURI = connector.getPublishableConnectURI();	
using auto nio port 

connector = brokerService.addConnector( "auto+ssl: autoSslPort = connector.getConnectUri().getPort();	autoSslURI = connector.getPublishableConnectURI();	}	if (isUseAutoNioConnector()) {	connector = brokerService.addConnector( "auto+nio: autoNioPort = connector.getConnectUri().getPort();	autoNioURI = connector.getPublishableConnectURI();	}	if (isUseAutoNioPlusSslConnector()) {	connector = brokerService.addConnector( "auto+nio+ssl: autoNioPlusSslPort = connector.getConnectUri().getPort();	autoNioPlusSslURI = connector.getPublishableConnectURI();	
using auto nio ssl port 

connector = brokerService.addConnector( "auto+nio: autoNioPort = connector.getConnectUri().getPort();	autoNioURI = connector.getPublishableConnectURI();	}	if (isUseAutoNioPlusSslConnector()) {	connector = brokerService.addConnector( "auto+nio+ssl: autoNioPlusSslPort = connector.getConnectUri().getPort();	autoNioPlusSslURI = connector.getPublishableConnectURI();	}	if (isUseWsConnector()) {	connector = brokerService.addConnector( "ws: amqpWsPort = connector.getConnectUri().getPort();	amqpWsURI = connector.getPublishableConnectURI();	
using amqp ws port 

connector = brokerService.addConnector( "auto+nio+ssl: autoNioPlusSslPort = connector.getConnectUri().getPort();	autoNioPlusSslURI = connector.getPublishableConnectURI();	}	if (isUseWsConnector()) {	connector = brokerService.addConnector( "ws: amqpWsPort = connector.getConnectUri().getPort();	amqpWsURI = connector.getPublishableConnectURI();	}	if (isUseWssConnector()) {	connector = brokerService.addConnector( "wss: amqpWssPort = connector.getConnectUri().getPort();	amqpWssURI = connector.getPublishableConnectURI();	
using amqp wss port 

public void stopBroker() throws Exception {	
entering amqptestsupport stopbroker 

public void stopBroker() throws Exception {	if (brokerService != null) {	brokerService.stop();	brokerService.waitUntilStopped();	brokerService = null;	}	
exiting amqptestsupport stopbroker 

========================= activemq sample_1575 =========================

public Broker installPlugin(Broker broker) throws Exception {	StatisticsBroker answer = new StatisticsBroker(broker);	
installing staticsbroker 

========================= activemq sample_4262 =========================

public void testInactivityMonitor() throws Exception {	Thread t1 = new Thread() {	public void run() {	try {	connection = createSocket();	connection.getOutputStream().write('S');	connection.getOutputStream().flush();	} catch (Exception ex) {	
unexpected exception on connect disconnect 

========================= activemq sample_1430 =========================

public void run() {	
tcp consumer thread for starting 

IntrospectionSupport.setProperties(socket, copy);	if (!copy.isEmpty()) {	throw new IllegalArgumentException("Invalid socket parameters: " + copy);	}	}	try {	if (socketBufferSize > 0) {	sock.setReceiveBufferSize(socketBufferSize);	sock.setSendBufferSize(socketBufferSize);	} else {	
socket buffer size was set to skipping this setting as the size must be a positive number 

}	}	try {	if (socketBufferSize > 0) {	sock.setReceiveBufferSize(socketBufferSize);	sock.setSendBufferSize(socketBufferSize);	} else {	}	} catch (SocketException se) {	LOG.warn("Cannot set socket buffer size = " + socketBufferSize);	
cannot set socket buffer size reason this exception is ignored 

protected void doStop(ServiceStopper stopper) throws Exception {	if (LOG.isDebugEnabled()) {	
stopping transport 

protected void doStop(ServiceStopper stopper) throws Exception {	if (LOG.isDebugEnabled()) {	}	if (socket != null) {	if (closeAsync) {	final CountDownLatch latch = new CountDownLatch(1);	final TaskRunnerFactory taskRunnerFactory = new TaskRunnerFactory();	taskRunnerFactory.execute(new Runnable() {	public void run() {	
closing socket 

if (LOG.isDebugEnabled()) {	}	if (socket != null) {	if (closeAsync) {	final CountDownLatch latch = new CountDownLatch(1);	final TaskRunnerFactory taskRunnerFactory = new TaskRunnerFactory();	taskRunnerFactory.execute(new Runnable() {	public void run() {	try {	socket.close();	
closed socket 

if (socket != null) {	if (closeAsync) {	final CountDownLatch latch = new CountDownLatch(1);	final TaskRunnerFactory taskRunnerFactory = new TaskRunnerFactory();	taskRunnerFactory.execute(new Runnable() {	public void run() {	try {	socket.close();	} catch (IOException e) {	if (LOG.isDebugEnabled()) {	
caught exception closing socket this exception will be ignored 

}	});	try {	latch.await(1,TimeUnit.SECONDS);	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	} finally {	taskRunnerFactory.shutdownNow();	}	} else {	
closing socket 

try {	latch.await(1,TimeUnit.SECONDS);	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	} finally {	taskRunnerFactory.shutdownNow();	}	} else {	try {	socket.close();	
closed socket 

} catch (InterruptedException e) {	Thread.currentThread().interrupt();	} finally {	taskRunnerFactory.shutdownNow();	}	} else {	try {	socket.close();	} catch (IOException e) {	if (LOG.isDebugEnabled()) {	
caught exception closing socket this exception will be ignored 

if (sock == null || (!this.diffServChosen && !this.typeOfServiceChosen)) {	return false;	}	if (this.diffServChosen && this.typeOfServiceChosen) {	throw new IllegalArgumentException("Cannot set both the " + " Differentiated Services and Type of Services transport " + " options on the same connection.");	}	sock.setTrafficClass(this.trafficClass);	int resultTrafficClass = sock.getTrafficClass();	if (this.trafficClass != resultTrafficClass) {	if ((this.trafficClass >> 2) == (resultTrafficClass >> 2) && (this.trafficClass & 3) != (resultTrafficClass & 3)) {	
attempted to set the traffic class to but the result traffic class was please check that your system allows you to set the ecn bits the first two bits 

return false;	}	if (this.diffServChosen && this.typeOfServiceChosen) {	throw new IllegalArgumentException("Cannot set both the " + " Differentiated Services and Type of Services transport " + " options on the same connection.");	}	sock.setTrafficClass(this.trafficClass);	int resultTrafficClass = sock.getTrafficClass();	if (this.trafficClass != resultTrafficClass) {	if ((this.trafficClass >> 2) == (resultTrafficClass >> 2) && (this.trafficClass & 3) != (resultTrafficClass & 3)) {	} else {	
attempted to set the traffic class to but the result traffic class was please check that your system supports java net settrafficclass 

========================= activemq sample_107 =========================

assertNotNull(consumer);	Topic advisoryTopic = AdvisorySupport.getSlowConsumerAdvisoryTopic( ActiveMQDestination.createDestination(topicA, ActiveMQDestination.TOPIC_TYPE));	session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer advisoryConsumer = session.createConsumer(advisoryTopic);	MessageProducer producer = session.createProducer(null);	producer.send(session.createTopic(topicA), session.createMessage());	for (int i = 0; i < MESSAGE_COUNT; i++) {	BytesMessage m = session.createBytesMessage();	m.writeBytes(new byte[1024]);	Topic newTopic = session.createTopic(topicPrefix + UUID.randomUUID().toString());	
sending message to next topic 

========================= activemq sample_2836 =========================

public void parse(ByteBuffer incoming) throws IOException {	while (incoming.hasRemaining()) {	frameSize += ((incoming.get() & 0xFF) << --multiplier * Byte.SIZE);	if (multiplier == 0) {	
next incoming frame length 

public void parse(ByteBuffer incoming) throws IOException {	int length = Math.min(incoming.remaining(), frame.getLength() - frame.offset);	incoming.get(frame.data, frame.offset, length);	frame.offset += length;	if (frame.offset == frame.length) {	
contents of size have been read 

========================= activemq sample_1719 =========================

Runnable tester = new Runnable() {	public void run() {	for (int i = 0; i < NUM_ITER; i++) {	Connection conn = null;	try {	conn = brokerA.createConnection();	conn.start();	final Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = sess.createQueue(ECHO_QUEUE_NAME);	MessageProducer producer = sess.createProducer(destination);	
starting iter 

ExecutorService threadService = Executors.newFixedThreadPool(2);	threadService.submit(tester);	threadService.submit(tester);	threadService.shutdown();	assertTrue("executor done on time", threadService.awaitTermination(30l, TimeUnit.SECONDS));	BrokerItem brokerC = brokers.get(BROKER_C);	RegionBroker regionBroker = (RegionBroker) brokerC.broker.getRegionBroker();	final AbstractRegion region = (AbstractRegion) regionBroker.getTempQueueRegion();	assertTrue("There were no lingering temp-queue destinations", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
lingering temps 

public void testSubscriptionsCleanedUpAfterConnectionClose() throws Exception {	final BrokerItem brokerA = brokers.get(BROKER_A);	for (int i = 0; i < NUM_ITER; i++) {	Connection conn = null;	try {	conn = brokerA.createConnection();	conn.start();	final Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = sess.createQueue(ECHO_QUEUE_NAME);	MessageProducer producer = sess.createProducer(destination);	
starting iter 

} catch (Exception e) {	e.printStackTrace();	fail();	}	}	BrokerItem brokerC = brokers.get(BROKER_C);	RegionBroker regionBroker = (RegionBroker) brokerC.broker.getRegionBroker();	final AbstractRegion region = (AbstractRegion) regionBroker.getTempQueueRegion();	assertTrue("There were no lingering temp-queue destinations", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
lingering temps 

final Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = sess.createQueue(ECHO_QUEUE_NAME);	MessageConsumer consumer = sess.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	TextMessage textMessage = (TextMessage) message;	try {	Destination replyTo = message.getJMSReplyTo();	MessageProducer producer = sess.createProducer(replyTo);	Message response = sess.createTextMessage(textMessage.getText());	
replying to this request 

========================= activemq sample_3724 =========================

final AtomicBoolean first = new AtomicBoolean(false);	broker.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	public void send(final ProducerBrokerExchange producerExchange, org.apache.activemq.command.Message messageSend) throws Exception {	super.send(producerExchange, messageSend);	if (first.compareAndSet(false, true)) {	producerExchange.getConnectionContext().setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	
waiting for recepit 

new BrokerPluginSupport() {	public void send(final ProducerBrokerExchange producerExchange, org.apache.activemq.command.Message messageSend) throws Exception {	super.send(producerExchange, messageSend);	if (first.compareAndSet(false, true)) {	producerExchange.getConnectionContext().setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	assertTrue("message received on time", gotMessageLatch.await(60, TimeUnit.SECONDS));	assertTrue("new producers done on time", producersDone.await(120, TimeUnit.SECONDS));	
stopping connection post send and receive and multiple producers 

};	Connection receiveConnection;	Session receiveSession = null;	receiveConnection = cf.createConnection();	receiveConnection.start();	receiveSession = receiveConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	receiveSession.createConsumer(destination).setMessageListener(listener);	final CountDownLatch sendDoneLatch = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
doing async send 

receiveConnection = cf.createConnection();	receiveConnection.start();	receiveSession = receiveConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	receiveSession.createConsumer(destination).setMessageListener(listener);	final CountDownLatch sendDoneLatch = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	produceMessage(sendSession, destination, "will resend", 1);	} catch (JMSException e) {	
got send exception 

receiveSession.createConsumer(destination).setMessageListener(listener);	final CountDownLatch sendDoneLatch = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	produceMessage(sendSession, destination, "will resend", 1);	} catch (JMSException e) {	fail("got unexpected send exception" + e);	}	sendDoneLatch.countDown();	
done async send 

sendDoneLatch.countDown();	}	});	assertTrue("one message got through on time", gotMessageLatch.await(20, TimeUnit.SECONDS));	final int numProducers = 1050;	final int numPerProducer = 2;	final int totalSent = numPerProducer * numProducers + 1;	for (int i=0; i<numProducers; i++) {	produceMessage(receiveSession, destination, "new producer " + i, numPerProducer);	if (i == 1025) {	
count down producers done 

final int totalSent = numPerProducer * numProducers + 1;	for (int i=0; i<numProducers; i++) {	produceMessage(receiveSession, destination, "new producer " + i, numPerProducer);	if (i == 1025) {	producersDone.countDown();	}	}	assertTrue("message sent complete through failover", sendDoneLatch.await(30, TimeUnit.SECONDS));	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
received count 

public boolean isSatisified() throws Exception {	return totalSent <= receivedCount.get();	}	});	assertEquals("we got all produced messages", totalSent, receivedCount.get());	sendConnection.close();	receiveConnection.close();	assertEquals("expect all messages are dequeued with one duplicate to dlq", totalSent + 2, ((RegionBroker) broker.getRegionBroker()).getDestinationStatistics().getEnqueues().getCount());	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
dequeues 

receiveConnection.close();	assertEquals("expect all messages are dequeued with one duplicate to dlq", totalSent + 2, ((RegionBroker) broker.getRegionBroker()).getDestinationStatistics().getEnqueues().getCount());	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return  totalSent + 1 <= ((RegionBroker) broker.getRegionBroker()).getDestinationStatistics().getDequeues().getCount();	}	});	assertEquals("dequeue correct, including duplicate dispatch poisoned", totalSent  + 1, ((RegionBroker) broker.getRegionBroker()).getDestinationStatistics().getDequeues().getCount());	broker.stop();	broker.waitUntilStopped();	
checking for remaining hung messages with second restart 

========================= activemq sample_2565 =========================

assertEquals(100, stat.getMinTime());	assertEquals(403, stat.getMaxTime());	stat.addTime(50);	assertEquals(3, stat.getCount());	assertEquals(50, stat.getMinTime());	assertEquals(403, stat.getMaxTime());	assertEquals(553, stat.getTotalTime());	Thread.sleep(500);	stat.addTime(10);	assertLastTimeNotStartTime(stat);	
stat is 

========================= activemq sample_2973 =========================

Message msga = session.createTextMessage("hello a");	msga.setStringProperty("JMSXGroupID", "A");	producer.send(msga);	Message msgb = session.createTextMessage("hello b");	msgb.setStringProperty("JMSXGroupID", "B");	producer.send(msgb);	Message msgc = session.createTextMessage("hello c");	msgc.setStringProperty("JMSXGroupID", "C");	producer.send(msgc);	}	
messages sent to group a b c 

Worker worker2 = new Worker(connection, destination, "worker2", startSignal, doneSignal, counters, messageCount, messageGroups);	messageCount.put("worker3", 0);	messageGroups.put("worker3", new HashSet<String>());	Worker worker3 = new Worker(connection, destination, "worker3", startSignal, doneSignal, counters, messageCount, messageGroups);	new Thread(worker1).start();	new Thread(worker2).start();	new Thread(worker3).start();	startSignal.countDown();	doneSignal.await();	if (consumersBeforeDispatchStarts == 0 && timeBeforeDispatchStarts == 0) {	
ignoring results because both parameters are 

Worker worker3 = new Worker(connection, destination, "worker3", startSignal, doneSignal, counters, messageCount, messageGroups);	new Thread(worker1).start();	new Thread(worker2).start();	new Thread(worker3).start();	startSignal.countDown();	doneSignal.await();	if (consumersBeforeDispatchStarts == 0 && timeBeforeDispatchStarts == 0) {	return;	}	for (String worker : messageCount.keySet()) {	
worker received messages from groups 

public void run() {	try {	log.info(workerName);	startSignal.await();	Session sess = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	MessageConsumer consumer = sess.createConsumer(queueName);	while (true) {	if (counters[0] == 0 && counters[1] == 0 && counters[2] == 0) {	doneSignal.countDown();	
done 

Thread.sleep(500);	} else if ("B".equals(group)) {	--counters[1];	update(group);	Thread.sleep(100);	} else if ("C".equals(group)) {	--counters[2];	update(group);	Thread.sleep(10);	} else {	
unknown group 

========================= activemq sample_3661 =========================

public void startBroker() throws Exception {	broker = createBroker();	broker.deleteAllMessages();	broker.start();	broker.waitUntilStarted();	
broker started 

public void stopBroker() throws Exception {	if (broker != null) {	
stopping broker 

public void testTransactedProducerCommitWithDBShutdown() throws Exception {	String failoverTransportURL = "failover:(" + transportUrl + ")?timeout=1000";	this.createDurableConsumer(MY_TEST_TOPIC, failoverTransportURL);	try {	this.sendMessage(MY_TEST_TOPIC, failoverTransportURL, true, true);	fail("Expect rollback after failover - inddoubt commit");	} catch (javax.jms.TransactionRolledBackException expectedInDoubt) {	
got rollback after failover failed commit 

public void createDurableConsumer(String topic, String transportURL) throws JMSException {	Connection connection = null;	
createdurableconsumer called 

public void sendMessage(String topic, String transportURL, boolean transacted, boolean commit) throws JMSException {	Connection connection = null;	try {	ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory( transportURL);	connection = factory.createConnection();	Session session = connection.createSession(transacted, transacted ? Session.SESSION_TRANSACTED : Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createTopic(topic);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	Message m = session.createTextMessage("testMessage");	
send message to broker 

Message m = session.createTextMessage("testMessage");	throwSQLException = new CountDownLatch(1);	producer.send(m);	if (transacted) {	if (commit) {	session.commit();	} else {	session.rollback();	}	}	
finished send message to broker 

========================= activemq sample_2837 =========================

public void testSendToDlq() throws Exception {	sendJMSMessageToKickOffRoute();	
wait for dlq message 

public String  enrich(String body) throws Exception {	
got body 

========================= activemq sample_1348 =========================

final ExecutorService executorService = Executors.newFixedThreadPool(2);	broker.setPlugins(new BrokerPlugin[] {	new BrokerPluginSupport() {	int sendCount = 0;	public void send(ProducerBrokerExchange producerExchange, org.apache.activemq.command.Message messageSend) throws Exception {	super.send(producerExchange, messageSend);	sendCount++;	if (sendCount > 1) {	executorService.execute(new Runnable() {	public void run() {	
stopping broker before commit 

final MessageProducer consumerProducer = consumerSession.createProducer(out);	final CountDownLatch commitDoneLatch = new CountDownLatch(1);	final CountDownLatch messagesReceived = new CountDownLatch(1);	final CountDownLatch brokerDisconnectedLatch = new CountDownLatch(1);	final AtomicInteger receivedCount = new AtomicInteger();	final AtomicBoolean gotDisconnect = new AtomicBoolean();	final AtomicBoolean gotReconnected = new AtomicBoolean();	final MessageConsumer testConsumer = consumerSession.createConsumer(in);	testConsumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	
consume one and commit 

testConsumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	assertNotNull("got message", message);	receivedCount.incrementAndGet();	messagesReceived.countDown();	try {	TimeUnit.SECONDS.sleep(1);	consumerProducer.send(message);	((ActiveMQSession) consumerSession).getTransactionContext().addSynchronization(new Synchronization() {	public void beforeEnd() throws Exception {	
waiting for failover reconnect 

TimeUnit.SECONDS.sleep(1);	consumerProducer.send(message);	((ActiveMQSession) consumerSession).getTransactionContext().addSynchronization(new Synchronization() {	public void beforeEnd() throws Exception {	gotDisconnect.set(Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return !((ActiveMQSession) consumerSession).getConnection().getTransport().isConnected();	}	}));	brokerDisconnectedLatch.countDown();	
got disconnect 

public boolean isSatisified() throws Exception {	return !((ActiveMQSession) consumerSession).getConnection().getTransport().isConnected();	}	}));	brokerDisconnectedLatch.countDown();	gotReconnected.set(Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return ((ActiveMQSession) consumerSession).getConnection().getTransport().isConnected();	}	}));	
got failover reconnect 

}));	brokerDisconnectedLatch.countDown();	gotReconnected.set(Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return ((ActiveMQSession) consumerSession).getConnection().getTransport().isConnected();	}	}));	}	});	consumerSession.commit();	
done commit 

consumerSession.commit();	} catch (Exception e) {	e.printStackTrace();	} finally {	commitDoneLatch.countDown();	}	}	});	executorService.execute(new Runnable() {	public void run() {	
producer started 

});	executorService.execute(new Runnable() {	public void run() {	try {	produceMessage(producerSession, in, 1);	} catch (javax.jms.IllegalStateException SessionClosedExpectedOnShutdown) {	} catch (JMSException e) {	e.printStackTrace();	fail("unexpceted ex on producer: " + e);	}	
producer done 

========================= activemq sample_2564 =========================

assertEquals(0, stat.getCount());	stat.increment();	assertEquals(1, stat.getCount());	stat.increment();	assertEquals(2, stat.getCount());	stat.decrement();	assertEquals(1, stat.getCount());	Thread.sleep(500);	stat.increment();	assertLastTimeNotStartTime(stat);	
counter is 

========================= activemq sample_2972 =========================

private void assertNoUnhandeledExceptions() {	for( Entry<Thread, Throwable> e: unhandeledExceptions.entrySet()) {	
thread had unexpected 

========================= activemq sample_3660 =========================

private void executeStatement(TransactionContext transactionContext, String createStatement, boolean ignoreStatementExecutionFailure) throws IOException {	Statement statement = null;	try {	
executing sql 

private void executeStatement(TransactionContext transactionContext, String createStatement, boolean ignoreStatementExecutionFailure) throws IOException {	Statement statement = null;	try {	statement = transactionContext.getConnection().createStatement();	statement.execute(createStatement);	commitIfAutoCommitIsDisabled(transactionContext);	} catch (SQLException e) {	if (ignoreStatementExecutionFailure) {	
could not create jdbc tables the message table already existed 

private void executeStatement(TransactionContext transactionContext, String createStatement, boolean ignoreStatementExecutionFailure) throws IOException {	Statement statement = null;	try {	statement = transactionContext.getConnection().createStatement();	statement.execute(createStatement);	commitIfAutoCommitIsDisabled(transactionContext);	} catch (SQLException e) {	if (ignoreStatementExecutionFailure) {	} else {	
could not create jdbc tables they could already exist 

public void doDropTables(TransactionContext c) throws SQLException, IOException {	Statement s = null;	try {	s = c.getConnection().createStatement();	String[] dropStatments = this.statements.getDropSchemaStatements();	for (int i = 0; i < dropStatments.length; i++) {	try {	
executing sql 

public void doDropTables(TransactionContext c) throws SQLException, IOException {	Statement s = null;	try {	s = c.getConnection().createStatement();	String[] dropStatments = this.statements.getDropSchemaStatements();	for (int i = 0; i < dropStatments.length; i++) {	try {	s.execute(dropStatments[i]);	} catch (SQLException e) {	
could not drop jdbc tables they may not exist failure was message sqlstate vendor code 

ResultSet rs = null;	try {	s = c.getConnection().prepareStatement(this.statements.getFindAllMessageIdsStatement());	s.setMaxRows(limit);	rs = s.executeQuery();	LinkedList<MessageId> reverseOrderIds = new LinkedList<MessageId>();	while (rs.next()) {	reverseOrderIds.addFirst(new MessageId(rs.getString(2), rs.getLong(3)));	}	if (LOG.isDebugEnabled()) {	
messageidscan with limit resulted in ids 

public void doDeleteOldMessages(TransactionContext c) throws SQLException, IOException {	PreparedStatement s = null;	try {	
executing sql 

public void doDeleteOldMessages(TransactionContext c) throws SQLException, IOException {	PreparedStatement s = null;	try {	s = c.getExclusiveConnection().prepareStatement(this.statements.getDeleteOldMessagesStatementWithPriority());	int priority = priorityIterator++%10;	s.setInt(1, priority);	s.setInt(2, priority);	int i = s.executeUpdate();	
deleted old message s at priority 

public void setBatchStatments(boolean batchStatments) {	
batchstatments is deprecated and will be removed in a future release use batchstatements instead note the e in statement 

} else {	s.setLong(paramId, lastRecoveredEntries[0]);	}	rs = s.executeQuery();	int count = 0;	if (this.statements.isUseExternalMessageReferences()) {	while (rs.next() && count < maxReturned) {	if (listener.recoverMessageReference(rs.getString(1))) {	count++;	} else {	
stopped recover next messages 

count++;	} else {	break;	}	}	} else {	while (rs.next() && count < maxReturned) {	if (listener.recoverMessage(rs.getLong(1), getBinaryData(rs, 2))) {	count++;	} else {	
stopped recover next messages 

} else {	while (rs.next() && count < maxReturned) {	if (listener.recoverMessage(rs.getLong(1), getBinaryData(rs, 2))) {	count++;	} else {	break;	}	}	}	} catch (Exception e) {	
exception recovering next messages 

========================= activemq sample_940 =========================

if(!AmqpSupport.CONTAINER_ID.equals(value)) {	markAsInvalid("Info map does not contain expected value: " + value);	}	}	}	});	try {	connection2.connect();	fail("Should not be able to connect with same container Id.");	} catch (Exception ex) {	
second connection with same container id failed as expected 

final int PAYLOAD_SIZE = 1024 * 1024;	byte[] payload = new byte[PAYLOAD_SIZE];	for (int i = 0; i < PAYLOAD_SIZE; i++) {	payload[i] = (byte) (i % PAYLOAD_SIZE);	}	message.setMessageId("msg" + 1);	message.setMessageAnnotation("serialNo", 1);	message.setBytes(payload);	sender.send(message);	sender.close();	
attempting to read message with receiver 

========================= activemq sample_1574 =========================

public synchronized ReloadableProperties obtained() {	if (reloadTime < 0 || (key.isReload() && hasModificationAfter(reloadTime))) {	props = new Properties();	try {	load(key.file(), props);	invertedProps = null;	invertedValueProps = null;	if (key.isDebug()) {	
load of 

public synchronized ReloadableProperties obtained() {	if (reloadTime < 0 || (key.isReload() && hasModificationAfter(reloadTime))) {	props = new Properties();	try {	load(key.file(), props);	invertedProps = null;	invertedValueProps = null;	if (key.isDebug()) {	}	} catch (IOException e) {	
failed to load reason 

if (reloadTime < 0 || (key.isReload() && hasModificationAfter(reloadTime))) {	props = new Properties();	try {	load(key.file(), props);	invertedProps = null;	invertedValueProps = null;	if (key.isDebug()) {	}	} catch (IOException e) {	if (key.isDebug()) {	
load of failure exception 

private void load(final File source, Properties props) throws IOException {	FileInputStream in = new FileInputStream(source);	try {	props.load(in);	if (key.isDecrypt()) {	try {	EncryptionSupport.decrypt(this.props);	} catch (NoClassDefFoundError e) {	key.setDecrypt(false);	
jasypt is not on the classpath password decryption disabled 

========================= activemq sample_805 =========================

public void start() throws Exception {	super.start();	
starting statisticsbroker 

========================= activemq sample_4263 =========================

public boolean matches(Object arg0) {	ObjectName other = (ObjectName) arg0;	ObjectName mine = (ObjectName) name;	
match vs 

allowing(managementContext).registerMBean(with(any(Object.class)), with(equal( new ObjectName("Test:type=Broker,brokerName=BrokerNC,service=Health"))));	allowing(managementContext).registerMBean(with(any(Object.class)), with(equal( new ObjectName("Test:type=Broker,brokerName=BrokerNC,connector=networkConnectors,networkConnectorName=NC"))));	allowing(managementContext).registerMBean(with(any(Object.class)), with(equal( new ObjectName("Test:type=Broker,brokerName=BrokerNC,service=Log4JConfiguration"))));	allowing(managementContext).registerMBean(with(any(Object.class)), with(equal( new ObjectName("Test:type=Broker,brokerName=BrokerNC,destinationType=Topic,destinationName=ActiveMQ.Advisory.Connection"))));	allowing(managementContext).registerMBean(with(any(Object.class)), with(equal( new ObjectName("Test:type=Broker,brokerName=BrokerNC,destinationType=Topic,destinationName=ActiveMQ.Advisory.NetworkBridge"))));	allowing(managementContext).registerMBean(with(any(Object.class)), with(equal( new ObjectName("Test:type=Broker,brokerName=BrokerNC,destinationType=Topic,destinationName=ActiveMQ.Advisory.MasterBroker"))));	allowing(managementContext).registerMBean(with(any(Object.class)), with(equal( new ObjectName("Test:type=Broker,brokerName=BrokerNC,service=jobScheduler,jobSchedulerName=JMS"))));	allowing(managementContext).getObjectInstance(with(equal( new ObjectName("Test:type=Broker,brokerName=BrokerNC,connector=networkConnectors,networkConnectorName=NC"))));	atLeast(maxReconnects - 1).of (managementContext).registerMBean(with(any(Object.class)), with(new NetworkBridgeObjectNameMatcher<ObjectName>( new ObjectName("Test:type=Broker,brokerName=BrokerNC,connector=networkConnectors,networkConnectorName=NC,networkBridge=localhost/127.0.0.1_" + proxy.getUrl().getPort())))); will(new CustomAction("signal register network mbean") {	public Object invoke(Invocation invocation) throws Throwable {	
mbean registered 

allowing(managementContext).registerMBean(with(any(Object.class)), with(equal( new ObjectName("Test:type=Broker,brokerName=BrokerNC,service=jobScheduler,jobSchedulerName=JMS"))));	allowing(managementContext).getObjectInstance(with(equal( new ObjectName("Test:type=Broker,brokerName=BrokerNC,connector=networkConnectors,networkConnectorName=NC"))));	atLeast(maxReconnects - 1).of (managementContext).registerMBean(with(any(Object.class)), with(new NetworkBridgeObjectNameMatcher<ObjectName>( new ObjectName("Test:type=Broker,brokerName=BrokerNC,connector=networkConnectors,networkConnectorName=NC,networkBridge=localhost/127.0.0.1_" + proxy.getUrl().getPort())))); will(new CustomAction("signal register network mbean") {	public Object invoke(Invocation invocation) throws Throwable {	mbeanRegistered.release();	return new ObjectInstance((ObjectName)invocation.getParameter(1), "discription");	}	});	atLeast(maxReconnects - 1).of (managementContext).unregisterMBean(with(new NetworkBridgeObjectNameMatcher<ObjectName>( new ObjectName("Test:type=Broker,brokerName=BrokerNC,connector=networkConnectors,networkConnectorName=NC,networkBridge=localhost/127.0.0.1_" + proxy.getUrl().getPort())))); will(new CustomAction("signal unregister network mbean") {	public Object invoke(Invocation invocation) throws Throwable {	
mbean unregistered 

========================= activemq sample_2499 =========================

final CountDownLatch done = new CountDownLatch(MSG_COUNT);	byte buffer[] = new byte[SIZE];	for (int i = 0; i < SIZE; ++i) {	buffer[i] = (byte) 128;	}	for (int i = 0; i < MSG_COUNT; ++i) {	BytesMessage message = session.createBytesMessage();	message.writeBytes(buffer);	producer.send(message);	if ((i % 1000) == 0) {	
sent message 

}	for (int i = 0; i < MSG_COUNT; ++i) {	BytesMessage message = session.createBytesMessage();	message.writeBytes(buffer);	producer.send(message);	if ((i % 1000) == 0) {	session.commit();	}	}	session.commit();	
finished sending all messages 

if ((i % 1000) == 0) {	session.commit();	}	}	session.commit();	MessageConsumer consumer = session.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	if ((done.getCount() % 1000) == 0) {	try {	
received message 

try {	session.commit();	} catch (JMSException e) {	}	}	done.countDown();	}	});	done.await(15, TimeUnit.MINUTES);	session.commit();	
finished receiving all messages 

});	done.await(15, TimeUnit.MINUTES);	session.commit();	assertTrue("Should < 3 logfiles left.", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	levelDBView.compact();	return countLogFiles() < 3;	}	}, TimeUnit.MINUTES.toMillis(5), (int)TimeUnit.SECONDS.toMillis(30)));	levelDBView.compact();	
current number of logs 

========================= activemq sample_2925 =========================

public void testModifiable() throws Exception {	final String brokerConfig =  "SpringBeanTest-broker";	applyNewConfig(brokerConfig, "emptyUpdatableConfig1000-spring-bean");	startBroker(brokerConfig);	assertTrue("broker alive", brokerService.isStarted());	ObjectName objectName = new ObjectName(brokerService.getBrokerObjectName().toString() + RuntimeConfigurationBroker.objectNamePropsAppendage);	RuntimeConfigurationViewMBean runtimeConfigurationView = (RuntimeConfigurationViewMBean) brokerService.getManagementContext().newProxyInstance(objectName, RuntimeConfigurationViewMBean.class, false);	String propOfInterest = "modified";	HashMap<String, String> props = new HashMap<String, String>();	IntrospectionSupport.getProperties(runtimeConfigurationView, props, null);	
mbean attributes before 

applyNewConfig(brokerConfig, "emptyUpdatableConfig1000-spring-bean");	startBroker(brokerConfig);	assertTrue("broker alive", brokerService.isStarted());	ObjectName objectName = new ObjectName(brokerService.getBrokerObjectName().toString() + RuntimeConfigurationBroker.objectNamePropsAppendage);	RuntimeConfigurationViewMBean runtimeConfigurationView = (RuntimeConfigurationViewMBean) brokerService.getManagementContext().newProxyInstance(objectName, RuntimeConfigurationViewMBean.class, false);	String propOfInterest = "modified";	HashMap<String, String> props = new HashMap<String, String>();	IntrospectionSupport.getProperties(runtimeConfigurationView, props, null);	assertNotEquals("unknown", props.get(propOfInterest));	String result = runtimeConfigurationView.updateNow();	
result from update 

ObjectName objectName = new ObjectName(brokerService.getBrokerObjectName().toString() + RuntimeConfigurationBroker.objectNamePropsAppendage);	RuntimeConfigurationViewMBean runtimeConfigurationView = (RuntimeConfigurationViewMBean) brokerService.getManagementContext().newProxyInstance(objectName, RuntimeConfigurationViewMBean.class, false);	String propOfInterest = "modified";	HashMap<String, String> props = new HashMap<String, String>();	IntrospectionSupport.getProperties(runtimeConfigurationView, props, null);	assertNotEquals("unknown", props.get(propOfInterest));	String result = runtimeConfigurationView.updateNow();	assertTrue("got sensible result", result.contains("No material change"));	HashMap<String, String> propsAfter = new HashMap<String, String>();	IntrospectionSupport.getProperties(runtimeConfigurationView, propsAfter, null);	
mbean attributes after 

System.setProperty("network.uri", "static:(tcp: System.setProperty("props.base", "classpath:");	final String brokerConfig = "SpringPropertyTestFileList-broker";	applyNewConfig(brokerConfig, "emptyUpdatableConfig1000-spring-property-file-list");	startBroker(brokerConfig);	assertTrue("broker alive", brokerService.isStarted());	ObjectName objectName = new ObjectName(brokerService.getBrokerObjectName().toString() + RuntimeConfigurationBroker.objectNamePropsAppendage);	RuntimeConfigurationViewMBean runtimeConfigurationView = (RuntimeConfigurationViewMBean) brokerService.getManagementContext().newProxyInstance(objectName, RuntimeConfigurationViewMBean.class, false);	String propOfInterest = "modified";	HashMap<String, String> props = new HashMap<String, String>();	IntrospectionSupport.getProperties(runtimeConfigurationView, props, null);	
mbean attributes before 

System.setProperty("network.uri", "static:(tcp: System.setProperty("props.base", "classpath:");	final String brokerConfig = "SpringPropertyTestFileListBeanFactory-broker";	applyNewConfig(brokerConfig, "emptyUpdatableConfig1000-spring-property-file-list-and-beanFactory");	startBroker(brokerConfig);	assertTrue("broker alive", brokerService.isStarted());	ObjectName objectName = new ObjectName(brokerService.getBrokerObjectName().toString() + RuntimeConfigurationBroker.objectNamePropsAppendage);	RuntimeConfigurationViewMBean runtimeConfigurationView = (RuntimeConfigurationViewMBean) brokerService.getManagementContext().newProxyInstance(objectName, RuntimeConfigurationViewMBean.class, false);	String propOfInterest = "modified";	HashMap<String, String> props = new HashMap<String, String>();	IntrospectionSupport.getProperties(runtimeConfigurationView, props, null);	
mbean attributes before 

========================= activemq sample_4371 =========================

if (sub != null) {	sub.getLocalInfo().setSubscriptionName(getSubscriberName(dest));	sub.setStaticallyIncluded(true);	addSubscription(sub);	break;	}	}	}	}	} catch (IOException e) {	
failed to add static destination 

sub.getLocalInfo().setSubscriptionName(getSubscriberName(dest));	sub.setStaticallyIncluded(true);	addSubscription(sub);	break;	}	}	}	}	} catch (IOException e) {	}	
forwarding messages for durable destination 

try {	DurableTopicSubscription durableSub = (DurableTopicSubscription) subscription;	if (durableSub.getSubscriptionKey().getClientId().equals(localClientId)) {	RemoveSubscriptionInfo sending = new RemoveSubscriptionInfo();	sending.setClientId(localClientId);	sending.setSubscriptionName(subName);	sending.setConnectionId(this.localConnectionInfo.getConnectionId());	localBroker.oneway(sending);	}	} catch (IOException e) {	
exception removing nc durable subscription 

========================= activemq sample_4234 =========================

if (values == null) {	values = new ArrayList<>();	}	if (!values.contains(jobLocation)) {	values.add(jobLocation);	this.store.incrementJournalCount(tx, location);	this.index.put(tx, nextExecutionTime, values);	this.scheduleTime.newJob();	} else {	this.index.put(tx, nextExecutionTime, values);	
job already in scheduler at this time 

if (jl.getJobId().equals(command.getJobId())) {	current.remove(i);	if (!current.isEmpty()) {	this.index.put(tx, command.getExecutionTime(), current);	}	result = jl;	break;	}	}	} else {	
process reschedule command for job non existent executime time 

target = new ArrayList<>();	}	target.add(result);	this.store.incrementJournalCount(tx, location);	if (previousUpdate != null) {	this.store.decrementJournalCount(tx, previousUpdate);	}	this.index.put(tx, command.getNextExecutionTime(), target);	this.scheduleTime.newJob();	} else {	
process reschedule command for non scheduled job at executime time 

if (entry.getKey().longValue() <= finish) {	keys.add(entry.getKey());	} else {	break;	}	}	for (Long executionTime : keys) {	List<JobLocation> values = this.index.remove(tx, executionTime);	if (location != null) {	for (JobLocation job : values) {	
removing scheduled at 

public void run() {	try {	mainLoop();	} catch (Throwable e) {	if (this.running.get() && isStarted()) {	
caught exception in mainloop 

try {	mainLoop();	} catch (Throwable e) {	if (this.running.get() && isStarted()) {	}	} finally {	if (running.get()) {	try {	stop();	} catch (Exception e) {	
failed to stop 

if (timeUntilNextScheduled < this.scheduleTime.getWaitTime()) {	this.scheduleTime.setWaitTime(timeUntilNextScheduled);	}	}	} else {	this.scheduleTime.setWaitTime(executionTime - currentTime);	}	}	this.scheduleTime.pause();	} catch (Exception ioe) {	
failed to schedule job 

}	} else {	this.scheduleTime.setWaitTime(executionTime - currentTime);	}	}	this.scheduleTime.pause();	} catch (Exception ioe) {	try {	this.store.stop();	} catch (Exception e) {	
failed to shutdown jobschedulerstore 

========================= activemq sample_1759 =========================

}	});	}	executorService.shutdown();	executorService.awaitTermination(30, TimeUnit.MINUTES);	assertTrue("Producers done in time", executorService.isTerminated());	assertTrue("No exceptions: " + exceptions, exceptions.isEmpty());	long totalSent  = toSend * payloadString.length();	double duration =  System.currentTimeMillis() - start;	stopBroker();	
duration ms 

}	});	}	executorService.shutdown();	executorService.awaitTermination(30, TimeUnit.MINUTES);	assertTrue("Producers done in time", executorService.isTerminated());	assertTrue("No exceptions: " + exceptions, exceptions.isEmpty());	long totalSent  = toSend * payloadString.length();	double duration =  System.currentTimeMillis() - start;	stopBroker();	
rate m s 

}	});	}	executorService.shutdown();	executorService.awaitTermination(30, TimeUnit.MINUTES);	assertTrue("Producers done in time", executorService.isTerminated());	assertTrue("No exceptions: " + exceptions, exceptions.isEmpty());	long totalSent  = toSend * payloadString.length();	double duration =  System.currentTimeMillis() - start;	stopBroker();	
total send 

}	});	}	executorService.shutdown();	executorService.awaitTermination(30, TimeUnit.MINUTES);	assertTrue("Producers done in time", executorService.isTerminated());	assertTrue("No exceptions: " + exceptions, exceptions.isEmpty());	long totalSent  = toSend * payloadString.length();	double duration =  System.currentTimeMillis() - start;	stopBroker();	
total journal write 

}	});	}	executorService.shutdown();	executorService.awaitTermination(30, TimeUnit.MINUTES);	assertTrue("Producers done in time", executorService.isTerminated());	assertTrue("No exceptions: " + exceptions, exceptions.isEmpty());	long totalSent  = toSend * payloadString.length();	double duration =  System.currentTimeMillis() - start;	stopBroker();	
total index size 

}	});	}	executorService.shutdown();	executorService.awaitTermination(30, TimeUnit.MINUTES);	assertTrue("Producers done in time", executorService.isTerminated());	assertTrue("No exceptions: " + exceptions, exceptions.isEmpty());	long totalSent  = toSend * payloadString.length();	double duration =  System.currentTimeMillis() - start;	stopBroker();	
total store size 

}	});	}	executorService.shutdown();	executorService.awaitTermination(30, TimeUnit.MINUTES);	assertTrue("Producers done in time", executorService.isTerminated());	assertTrue("No exceptions: " + exceptions, exceptions.isEmpty());	long totalSent  = toSend * payloadString.length();	double duration =  System.currentTimeMillis() - start;	stopBroker();	
journal writes 

});	}	executorService.shutdown();	executorService.awaitTermination(30, TimeUnit.MINUTES);	assertTrue("Producers done in time", executorService.isTerminated());	assertTrue("No exceptions: " + exceptions, exceptions.isEmpty());	long totalSent  = toSend * payloadString.length();	broker.getAdminView().gc();	double duration =  System.currentTimeMillis() - start;	stopBroker();	
duration ms 

});	}	executorService.shutdown();	executorService.awaitTermination(30, TimeUnit.MINUTES);	assertTrue("Producers done in time", executorService.isTerminated());	assertTrue("No exceptions: " + exceptions, exceptions.isEmpty());	long totalSent  = toSend * payloadString.length();	broker.getAdminView().gc();	double duration =  System.currentTimeMillis() - start;	stopBroker();	
rate m s 

});	}	executorService.shutdown();	executorService.awaitTermination(30, TimeUnit.MINUTES);	assertTrue("Producers done in time", executorService.isTerminated());	assertTrue("No exceptions: " + exceptions, exceptions.isEmpty());	long totalSent  = toSend * payloadString.length();	broker.getAdminView().gc();	double duration =  System.currentTimeMillis() - start;	stopBroker();	
total send 

});	}	executorService.shutdown();	executorService.awaitTermination(30, TimeUnit.MINUTES);	assertTrue("Producers done in time", executorService.isTerminated());	assertTrue("No exceptions: " + exceptions, exceptions.isEmpty());	long totalSent  = toSend * payloadString.length();	broker.getAdminView().gc();	double duration =  System.currentTimeMillis() - start;	stopBroker();	
total journal write 

});	}	executorService.shutdown();	executorService.awaitTermination(30, TimeUnit.MINUTES);	assertTrue("Producers done in time", executorService.isTerminated());	assertTrue("No exceptions: " + exceptions, exceptions.isEmpty());	long totalSent  = toSend * payloadString.length();	broker.getAdminView().gc();	double duration =  System.currentTimeMillis() - start;	stopBroker();	
total index size 

});	}	executorService.shutdown();	executorService.awaitTermination(30, TimeUnit.MINUTES);	assertTrue("Producers done in time", executorService.isTerminated());	assertTrue("No exceptions: " + exceptions, exceptions.isEmpty());	long totalSent  = toSend * payloadString.length();	broker.getAdminView().gc();	double duration =  System.currentTimeMillis() - start;	stopBroker();	
total store size 

});	}	executorService.shutdown();	executorService.awaitTermination(30, TimeUnit.MINUTES);	assertTrue("Producers done in time", executorService.isTerminated());	assertTrue("No exceptions: " + exceptions, exceptions.isEmpty());	long totalSent  = toSend * payloadString.length();	broker.getAdminView().gc();	double duration =  System.currentTimeMillis() - start;	stopBroker();	
journal writes 

Message message = null;	if (useBytesMessage) {	message = session.createBytesMessage();	((BytesMessage) message).writeBytes(payloadString.getBytes());	} else {	message = session.createTextMessage(payloadString);	}	producer.send(message, DeliveryMode.PERSISTENT, 5, expiry);	if (i != toSend && i%sampleRate == 0) {	long now = System.currentTimeMillis();	
remainder rate m s 

========================= activemq sample_3764 =========================

public ConnectionPool(Connection connection) {	final GenericKeyedObjectPoolConfig poolConfig = new GenericKeyedObjectPoolConfig();	poolConfig.setJmxEnabled(false);	this.connection = wrap(connection);	try {	this.connection.setExceptionListener(this);	} catch (JMSException ex) {	
could not set exception listener on create of connectionpool 

========================= activemq sample_1309 =========================

try {	lastDelay = closeIter.get(this.address);	if (lastDelay == null) {	lastDelayVal = 0;	} else {	lastDelayVal = lastDelay.intValue();	if (lastDelayVal > 10) lastDelayVal += 20;	else lastDelayVal += 1;	}	lastDelay = new Integer(lastDelayVal);	
trying to close client socket in milliseconds 

lastDelay = new Integer(lastDelayVal);	try {	Thread.sleep(lastDelayVal);	} catch (InterruptedException e) {	this.processus.interrupt();	Thread.currentThread().interrupt();	} catch (IllegalArgumentException e) {	}	this.socket.close();	closeIter.put(this.address, lastDelay);	
client socket is closed 

public SocketTstFactory() {	super();	
creating a new sockettstfactory 

========================= activemq sample_2525 =========================

protected void doTest() throws Exception {	connection.start();	ActiveMQConnection amqConnection = (ActiveMQConnection) connection;	rollbackCount = amqConnection.getRedeliveryPolicy().getMaximumRedeliveries() + 1;	
will redeliver messages times 

========================= activemq sample_2460 =========================

Message consumedMessage = consumer.receive();	if (consumedMessage != null) {	done.countDown();	consumedMessage.acknowledge();	if (ackMode == Session.SESSION_TRANSACTED && commitBatch && ((i + 1) % 50) == 0) {	consumerSession.commit();	}	}	}	} catch (Exception ex) {	
caught exception during receive 

}	}	}	} catch (Exception ex) {	error.set(true);	} finally {	if (ackMode == Session.SESSION_TRANSACTED) {	try {	consumerSession.commit();	} catch (JMSException e) {	
caught exception on commit 

========================= activemq sample_3621 =========================

try {	produce(numMessages);	} catch (Exception e) {	}	}	};	threads.add(producer);	producer.start();	boolean allGood = receivedLatch.await(90, TimeUnit.SECONDS);	for (Throwable t : exceptions) {	
failing test with first exception 

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setTimeToLive(0);	connection.start();	for (int i = 0; i < count; i++) {	int id = i + 1;	TextMessage message = session.createTextMessage(name.getMethodName() + " Message " + id);	message.setIntProperty("MsgNumber", id);	producer.send(message);	if (id % 500 == 0) {	
sent ith 

connection.start();	for (int i = 0; i < count; i++) {	int id = i + 1;	TextMessage message = session.createTextMessage(name.getMethodName() + " Message " + id);	message.setIntProperty("MsgNumber", id);	producer.send(message);	if (id % 500 == 0) {	}	}	} catch (JMSException e) {	
unexpected ex on produce 

ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(CONSUMER_BROKER_URL);	Connection connection = connectionFactory.createConnection();	connection.setExceptionListener(testCase);	connection.setClientID(getName());	session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	MessageConsumer consumer = session.createDurableSubscriber(destination, getName());	consumer.setMessageListener(this);	connection.start();	started.countDown();	} catch (JMSException exception) {	
unexpected ex in consumer run 

try {	counter++;	int messageNumber = message.getIntProperty("MsgNumber");	if (messageNumber % 2 == 0) {	session.recover();	recoveries++;	} else {	message.acknowledge();	}	if (counter % 200 == 0) {	
recoveries received counter th 

if (messageNumber % 2 == 0) {	session.recover();	recoveries++;	} else {	message.acknowledge();	}	if (counter % 200 == 0) {	}	receivedLatch.countDown();	} catch (Exception e) {	
unexpected ex on onmessage 

public void onException(JMSException exception) {	
unexpected jmsexception 

public void uncaughtException(Thread thread, Throwable exception) {	
unexpected exception from thread ex 

========================= activemq sample_2933 =========================

public void testGetBrokerName() throws URISyntaxException, JMSException {	ActiveMQConnectionFactory cf = getXAConnectionFactory("vm: connection = (ActiveMQConnection)cf.createConnection();	connection.start();	String brokerName = connection.getBrokerName();	
got broker name 

ActiveMQConnectionFactory cf = getXAConnectionFactory(broker.getTransportConnectors().get(0).getConnectUri());	XAConnection connection = (XAConnection)cf.createConnection();	connection.start();	XASession session = connection.createXASession();	XAResource resource = session.getXAResource();	Xid tid = createXid();	try {	resource.rollback(tid);	fail("Expected xa exception on no tx");	} catch (XAException expected) {	
got expected xa 

protected void assertCreateConnection(String uri) throws Exception {	broker = new BrokerService();	broker.setPersistent(false);	broker.setUseJmx(false);	TransportConnector connector = broker.addConnector(uri);	broker.start();	URI temp = new URI(uri);	URI currentURI = new URI(connector.getPublishableConnectString());	URI connectURI = new URI(temp.getScheme(), temp.getUserInfo(), temp.getHost(), currentURI.getPort(), temp.getPath(), temp.getQuery(), temp.getFragment());	
connection uri is 

========================= activemq sample_2749 =========================

protected boolean matchesForwardingFilter(Message message, final MessageEvaluationContext mec) {	boolean match = true;	if (mec.getDestination().isQueue() && contains(message.getBrokerPath(), networkBrokerId)) {	match = allowReplayWhenNoConsumers && hasNoLocalConsumers(message, mec) && hasNotJustArrived(message);	if (match) {	
replaying for back to origin in the absence of a local consumer 

protected boolean matchesForwardingFilter(Message message, final MessageEvaluationContext mec) {	boolean match = true;	if (mec.getDestination().isQueue() && contains(message.getBrokerPath(), networkBrokerId)) {	match = allowReplayWhenNoConsumers && hasNoLocalConsumers(message, mec) && hasNotJustArrived(message);	if (match) {	} else {	
suppressing replay of for back to origin 

boolean match = true;	if (mec.getDestination().isQueue() && contains(message.getBrokerPath(), networkBrokerId)) {	match = allowReplayWhenNoConsumers && hasNoLocalConsumers(message, mec) && hasNotJustArrived(message);	if (match) {	} else {	}	} else {	match = super.matchesForwardingFilter(message, mec);	}	if (match && rateLimitExceeded()) {	
throttled network consumer rejecting for 

private boolean hasNoLocalConsumers(final Message message, final MessageEvaluationContext mec) {	Destination regionDestination = (Destination) mec.getMessageReference().getRegionDestination();	List<Subscription> consumers = regionDestination.getConsumers();	for (Subscription sub : consumers) {	if (!sub.getConsumerInfo().isNetworkSubscription() && !sub.getConsumerInfo().isBrowser()) {	
not replaying for to origin due to existing local consumer 

========================= activemq sample_4222 =========================

public void beforeDelivery(Method method) throws NoSuchMethodException, ResourceException {	
invoking messageendpoint beforedelivery 

public void onMessage(Message message) {	
invoking messageendpoint onmethod 

public void afterDelivery() throws ResourceException {	
invoking messageendpoint afterdelivery 

public void release() {	
invoking messageendpoint release 

========================= activemq sample_844 =========================

StringBuilder sb = new StringBuilder();	for (char ch : hostName.toCharArray()) {	if (ch < 127) {	sb.append(ch);	} else {	changed = true;	}	}	if (changed) {	String newHost = sb.toString();	
sanitized hostname from to 

========================= activemq sample_147 =========================

public void doTestFailoverConsumerDups(final boolean watchTopicAdvisories) throws Exception {	broker = createBroker(true);	broker.setPlugins(new BrokerPlugin[] {	new BrokerPluginSupport() {	public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {	context.setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
stopping broker before commit 

final ActiveMQConnection connection = (ActiveMQConnection) cf.createConnection();	connection.start();	final Session producerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	final Queue destination = producerSession.createQueue(QUEUE_NAME + "?consumer.prefetchSize=" + prefetch);	final Session consumerSession = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);	final CountDownLatch commitDoneLatch = new CountDownLatch(1);	final CountDownLatch messagesReceived = new CountDownLatch(2);	final MessageConsumer testConsumer = consumerSession.createConsumer(destination);	testConsumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	
consume one and commit 

testConsumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	assertNotNull("got message", message);	try {	consumerSession.commit();	} catch (JMSException e) {	e.printStackTrace();	}	commitDoneLatch.countDown();	messagesReceived.countDown();	
done commit 

consumerSession.commit();	} catch (JMSException e) {	e.printStackTrace();	}	commitDoneLatch.countDown();	messagesReceived.countDown();	}	});	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
producer started 

});	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	produceMessage(producerSession, destination, prefetch * 2);	} catch (javax.jms.IllegalStateException SessionClosedExpectedOnShutdown) {	} catch (JMSException e) {	e.printStackTrace();	fail("unexpceted ex on producer: " + e);	}	
producer done 

public void doTestFailoverConsumerOutstandingSendTx(final boolean doActualBrokerCommit) throws Exception {	final boolean watchTopicAdvisories = true;	broker = createBroker(true);	broker.setPlugins(new BrokerPlugin[] { new BrokerPluginSupport() {	public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {	if (doActualBrokerCommit) {	
doing actual broker commit 

final boolean watchTopicAdvisories = true;	broker = createBroker(true);	broker.setPlugins(new BrokerPlugin[] { new BrokerPluginSupport() {	public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {	if (doActualBrokerCommit) {	super.commitTransaction(context, xid, onePhase);	}	context.setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
stopping broker before commit 

final Queue destination = producerSession.createQueue(QUEUE_NAME + "?consumer.prefetchSize=" + prefetch);	final Queue signalDestination = producerSession.createQueue(QUEUE_NAME + ".signal" + "?consumer.prefetchSize=" + prefetch);	final Session consumerSession = connection.createSession(true, Session.SESSION_TRANSACTED);	final CountDownLatch commitDoneLatch = new CountDownLatch(1);	final CountDownLatch messagesReceived = new CountDownLatch(3);	final AtomicBoolean gotCommitException = new AtomicBoolean(false);	final ArrayList<TextMessage> receivedMessages = new ArrayList<TextMessage>();	final MessageConsumer testConsumer = consumerSession.createConsumer(destination);	testConsumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	
consume one and commit 

final ArrayList<TextMessage> receivedMessages = new ArrayList<TextMessage>();	final MessageConsumer testConsumer = consumerSession.createConsumer(destination);	testConsumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	assertNotNull("got message", message);	receivedMessages.add((TextMessage) message);	try {	produceMessage(consumerSession, signalDestination, 1);	consumerSession.commit();	} catch (JMSException e) {	
commit exception 

assertNotNull("got message", message);	receivedMessages.add((TextMessage) message);	try {	produceMessage(consumerSession, signalDestination, 1);	consumerSession.commit();	} catch (JMSException e) {	gotCommitException.set(true);	}	commitDoneLatch.countDown();	messagesReceived.countDown();	
done commit 

consumerSession.commit();	} catch (JMSException e) {	gotCommitException.set(true);	}	commitDoneLatch.countDown();	messagesReceived.countDown();	}	});	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
producer started 

});	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	produceMessage(producerSession, destination, prefetch * 2);	} catch (javax.jms.IllegalStateException SessionClosedExpectedOnShutdown) {	} catch (JMSException e) {	e.printStackTrace();	fail("unexpceted ex on producer: " + e);	}	
producer done 

========================= activemq sample_2572 =========================

public DurableSubscriptionOffline2Test(Boolean keepDurableSubsActive) {	this.keepDurableSubsActive = keepDurableSubsActive.booleanValue();	
running with keepdurablesubsactive 

producer.send(topic, message);	}	session.close();	con.close();	con = createConnection("cliId1");	session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);	for (int i=0; i<sent/2; i++) {	Message m =  consumer.receive(4000);	assertNotNull("got message: " + i, m);	
got 

session.close();	con.close();	con = createConnection("cliId1");	session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);	for (int i=0; i<sent/2; i++) {	Message m =  consumer.receive(4000);	assertNotNull("got message: " + i, m);	}	ObjectName activeDurableSubName = broker.getAdminView().getDurableTopicSubscribers()[0];	
active durable sub name 

}));	assertEquals("correct dequeue", 5, durableSubscriptionView.getDequeueCounter());	ObjectName destinationName = broker.getAdminView().getTopics()[0];	TopicViewMBean topicView = (TopicViewMBean) broker.getManagementContext().newProxyInstance(destinationName, TopicViewMBean.class, true);	assertEquals("correct enqueue", 10, topicView.getEnqueueCount());	assertEquals("topic view dequeue not updated", 5, topicView.getDequeueCount());	assertEquals("inflight", 5, topicView.getInFlightCount());	session.close();	con.close();	ObjectName inActiveDurableSubName = broker.getAdminView().getInactiveDurableTopicSubscribers()[0];	
inactive durable sub name 

assertEquals("correct dequeue", keepDurableSubsActive ? 5 : 0, durableSubscriptionView1.getDequeueCounter());	assertEquals("correct enqueue", 10, topicView.getEnqueueCount());	assertEquals("topic view dequeue not updated", 5, topicView.getDequeueCount());	assertEquals("inflight back to 0 after deactivate", 0, topicView.getInFlightCount());	con = createConnection("cliId1");	session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	consumer = session.createDurableSubscriber(topic, "SubsId", null, true);	for (int i=0; i<sent/2;i++) {	Message m =  consumer.receive(30000);	assertNotNull("got message: " + i, m);	
got 

assertEquals("topic view dequeue not updated", 5, topicView.getDequeueCount());	assertEquals("inflight back to 0 after deactivate", 0, topicView.getInFlightCount());	con = createConnection("cliId1");	session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	consumer = session.createDurableSubscriber(topic, "SubsId", null, true);	for (int i=0; i<sent/2;i++) {	Message m =  consumer.receive(30000);	assertNotNull("got message: " + i, m);	}	activeDurableSubName = broker.getAdminView().getDurableTopicSubscribers()[0];	
durable sub name 

Message m =  consumer.receive(30000);	assertNotNull("got message: " + i, m);	}	activeDurableSubName = broker.getAdminView().getDurableTopicSubscribers()[0];	final DurableSubscriptionViewMBean durableSubscriptionView2 = (DurableSubscriptionViewMBean) broker.getManagementContext().newProxyInstance(activeDurableSubName, DurableSubscriptionViewMBean.class, true);	assertTrue("is active", durableSubscriptionView2.isActive());	assertEquals("all enqueued", keepDurableSubsActive ? 10 : 0, durableSubscriptionView2.getEnqueueCounter());	assertTrue("correct dequeue", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	long val = durableSubscriptionView2.getDequeueCounter();	
dequeue count 

========================= activemq sample_3699 =========================

public void testLostMessage() {	Connection connection = null;	try {	ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("vm: connection = connectionFactory.createConnection();	connection.start();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Destination test_data_destination = session.createQueue("test"+System.currentTimeMillis());	MessageConsumer consumer = session.createConsumer(test_data_destination);	
consumer connected 

try {	ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("vm: connection = connectionFactory.createConnection();	connection.start();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Destination test_data_destination = session.createQueue("test"+System.currentTimeMillis());	MessageConsumer consumer = session.createConsumer(test_data_destination);	MessageProducer producer = session.createProducer(test_data_destination);	producer.send(session.createTextMessage("Message 1"));	session.commit();	producer.send(session.createTextMessage("Message 2"));	
closing consumer 

connection.start();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Destination test_data_destination = session.createQueue("test"+System.currentTimeMillis());	MessageConsumer consumer = session.createConsumer(test_data_destination);	MessageProducer producer = session.createProducer(test_data_destination);	producer.send(session.createTextMessage("Message 1"));	session.commit();	producer.send(session.createTextMessage("Message 2"));	consumer.close();	consumer = session.createConsumer(test_data_destination);	
consumer connected 

Destination test_data_destination = session.createQueue("test"+System.currentTimeMillis());	MessageConsumer consumer = session.createConsumer(test_data_destination);	MessageProducer producer = session.createProducer(test_data_destination);	producer.send(session.createTextMessage("Message 1"));	session.commit();	producer.send(session.createTextMessage("Message 2"));	consumer.close();	consumer = session.createConsumer(test_data_destination);	Message message = consumer.receive(10000);	if (message != null) {	
got message 

producer.send(session.createTextMessage("Message 1"));	session.commit();	producer.send(session.createTextMessage("Message 2"));	consumer.close();	consumer = session.createConsumer(test_data_destination);	Message message = consumer.receive(10000);	if (message != null) {	assertEquals("expected message", "Message 1", ((TextMessage) message).getText());	session.commit();	} else {	
expected message but it never arrived 

========================= activemq sample_2821 =========================

private boolean tryMatchingCachedSubs(final Broker broker, Destination dest, MessageEvaluationContext msgContext) {	boolean matches = false;	
no active consumer match found will try cache if configured 

========================= activemq sample_4019 =========================

final MessageConsumer consumer = session.createConsumer(session.createQueue(QUEUE_NAME));	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	afterRestart.await();	final TextMessage txtMsg = (TextMessage) message;	if (txtMsg.getText().equals("test")) {	producer.send(session.createTextMessage("test 1"));	TimeUnit.SECONDS.sleep(5);	producer.send(session.createTextMessage("test 2"));	
two new messages produced 

twoNewMessages.countDown();	} else if (txtMsg.getText().equals("test 3")) {	thirdMessageReceived.countDown();	}	} catch (Exception e) {	LOG.error(e.toString());	throw new RuntimeException(e);	}	}	});	
stopping broker 

} else if (txtMsg.getText().equals("test 3")) {	thirdMessageReceived.countDown();	}	} catch (Exception e) {	LOG.error(e.toString());	throw new RuntimeException(e);	}	}	});	broker.stop();	
creating new broker 

========================= activemq sample_2964 =========================

protected void makeConsumer() throws JMSException {	Destination destination = getDestination();	
consuming from 

protected void makeDlqConsumer() throws Exception {	dlqDestination = createDlqDestination();	
consuming from dead letter on 

protected void makeDlqBrowser() throws Exception {	dlqDestination = createDlqDestination();	
browsing dead letter on 

protected void sendMessages() throws JMSException {	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	producer = session.createProducer(getDestination());	producer.setDeliveryMode(deliveryMode);	producer.setTimeToLive(timeToLive);	
sending messages to 

protected void assertMessage(Message message, int i) throws Exception {	
received message 

private void validateConsumerPrefetch(String destination, long expectedCount) {	try {	Thread.sleep(100);	} catch (InterruptedException e) {	}	RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();	for (org.apache.activemq.broker.region.Destination dest : regionBroker.getQueueRegion().getDestinationMap().values()) {	if (dest.getName().equals(destination)) {	DestinationStatistics stats = dest.getDestinationStatistics();	
inflight for 

========================= activemq sample_2437 =========================

public void testSendReceiveAfterPause() throws Exception {	final CountDownLatch failed = new CountDownLatch(1);	Connection connection = factory.createConnection();	connection.start();	connection.setExceptionListener(new ExceptionListener() {	public void onException(JMSException exception) {	
connection failed due to 

========================= activemq sample_1098 =========================

public void doStart() throws Exception {	
attempting to acquire the exclusive lock to become the master broker 

public void doStart() throws Exception {	String sql = getStatements().getLockCreateStatement();	
locking query is 

break;	} catch (Exception e) {	try {	if (isStopping()) {	throw new Exception( "Cannot start broker as being asked to shut down. " + "Interrupted attempt to acquire lock: " + e, e);	}	if (exceptionHandler != null) {	try {	exceptionHandler.handle(e);	} catch (Throwable handlerException) {	
the exception handler threw this exception while trying to handle this exception 

try {	if (isStopping()) {	throw new Exception( "Cannot start broker as being asked to shut down. " + "Interrupted attempt to acquire lock: " + e, e);	}	if (exceptionHandler != null) {	try {	exceptionHandler.handle(e);	} catch (Throwable handlerException) {	}	} else {	
lock failure 

exceptionHandler.handle(e);	} catch (Throwable handlerException) {	}	} else {	}	} finally {	if (null != connection) {	try {	connection.rollback();	} catch (SQLException e1) {	
caught exception during rollback on connection 

}	} finally {	if (null != connection) {	try {	connection.rollback();	} catch (SQLException e1) {	}	try {	connection.close();	} catch (SQLException e1) {	
caught exception while closing connection 

} catch (SQLException e1) {	}	connection = null;	}	}	} finally {	if (null != lockCreateStatement) {	try {	lockCreateStatement.close();	} catch (SQLException e1) {	
caught while closing statement 

}	} finally {	if (null != lockCreateStatement) {	try {	lockCreateStatement.close();	} catch (SQLException e1) {	}	lockCreateStatement = null;	}	}	
failed to acquire lock sleeping for milli s before trying again 

try {	lockCreateStatement.close();	} catch (SQLException e1) {	}	lockCreateStatement = null;	}	}	try {	Thread.sleep(lockAcquireSleepInterval);	} catch (InterruptedException ie) {	
master lock retry sleep interrupted 

} catch (SQLException e1) {	}	lockCreateStatement = null;	}	}	try {	Thread.sleep(lockAcquireSleepInterval);	} catch (InterruptedException ie) {	}	}	
becoming the master on datasource 

public void doStop(ServiceStopper stopper) throws Exception {	try {	if (lockCreateStatement != null) {	lockCreateStatement.cancel();	}	} catch (SQLFeatureNotSupportedException e) {	
failed to cancel locking query on datasource 

if (lockCreateStatement != null) {	lockCreateStatement.cancel();	}	} catch (SQLFeatureNotSupportedException e) {	}	try {	if (lockUpdateStatement != null) {	lockUpdateStatement.cancel();	}	} catch (SQLFeatureNotSupportedException e) {	
failed to cancel locking query on datasource 

try {	if (lockUpdateStatement != null) {	lockUpdateStatement.cancel();	}	} catch (SQLFeatureNotSupportedException e) {	}	if (connection != null) {	try {	connection.rollback();	} catch (SQLException sqle) {	
exception while rollbacking the connection on shutdown this exception is ignored 

} catch (SQLFeatureNotSupportedException e) {	}	if (connection != null) {	try {	connection.rollback();	} catch (SQLException sqle) {	} finally {	try {	connection.close();	} catch (SQLException ignored) {	
exception while closing connection on shutdown this exception is ignored 

boolean result = false;	try {	lockUpdateStatement = connection.prepareStatement(getStatements().getLockUpdateStatement());	lockUpdateStatement.setLong(1, System.currentTimeMillis());	setQueryTimeout(lockUpdateStatement);	int rows = lockUpdateStatement.executeUpdate();	if (rows == 1) {	result=true;	}	} catch (Exception e) {	
failed to update database lock 

int rows = lockUpdateStatement.executeUpdate();	if (rows == 1) {	result=true;	}	} catch (Exception e) {	} finally {	if (lockUpdateStatement != null) {	try {	lockUpdateStatement.close();	} catch (SQLException e) {	
failed to close statement 

========================= activemq sample_956 =========================

public void testSubscribeToCompositeQueue() throws Exception {	stompConnect();	String destinationA = "StompA";	String destinationB = "StompB";	String frame = "CONNECT\n" + "login:system\n" + "passcode:manager\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	
subscribing to destination 

public void testSubscribeToCompositeQueueTrailersDefault() throws Exception {	stompConnect();	String destinationA = "StompA";	String destinationB = "StompB";	String frame = "CONNECT\n" + "login:system\n" + "passcode:manager\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	
subscribing to destination 

public void testSubscribeToCompositeTopics() throws Exception {	stompConnect();	String destinationA = "StompA";	String destinationB = "StompB";	String frame = "CONNECT\n" + "login:system\n" + "passcode:manager\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	
subscribing to destination 

String frame = "CONNECT\n" + "login:system\n" + "passcode:manager\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	frame = "SEND\n" + "destination:" + destinationA + "," + destinationB + "\n\n" + "Hello World" + Stomp.NULL;	stompConnection.sendFrame(frame);	final BrokerViewMBean brokerView = getProxyToBroker();	assertTrue("Should be two destinations for the dispatch", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	for(ObjectName queueName : brokerView.getQueues()) {	
broker has queue 

========================= activemq sample_1427 =========================

super.removeDestination(context, destination, timeout);	DestinationInfo info = destinations.remove(destination);	if (info != null) {	if (getBrokerService().isUseVirtualDestSubs()) {	for (ConsumerInfo consumerInfo : virtualDestinationConsumers.keySet()) {	VirtualDestination virtualDestination = virtualDestinationConsumers.get(consumerInfo);	if (virtualDestinationMatcher.matches(virtualDestination, destination)) {	VirtualConsumerPair key = new VirtualConsumerPair(virtualDestination, destination);	ConsumerInfo i = brokerConsumerDests.get(key);	if (consumerInfo.equals(i) && brokerConsumerDests.remove(key) != null) {	
virtual consumer pair removed for consumer 

public void removeSubscription(ConnectionContext context, RemoveSubscriptionInfo info) throws Exception {	SubscriptionKey key = new SubscriptionKey(context.getClientId(), info.getSubscriptionName());	RegionBroker regionBroker = null;	if (next instanceof RegionBroker) {	regionBroker = (RegionBroker) next;	} else {	BrokerService service = next.getBrokerService();	regionBroker = (RegionBroker) service.getRegionBroker();	}	if (regionBroker == null) {	
cannot locate a regionbroker instance to pass along the removesubscription call 

} else {	BrokerService service = next.getBrokerService();	regionBroker = (RegionBroker) service.getRegionBroker();	}	if (regionBroker == null) {	throw new IllegalStateException("No RegionBroker found.");	}	DurableTopicSubscription sub = ((TopicRegion) regionBroker.getTopicRegion()).getDurableSubscription(key);	super.removeSubscription(context, info);	if (sub == null) {	
we cannot send an advisory message for a durable sub removal when we don t know about the durable sub 

public void virtualDestinationAdded(ConnectionContext context, VirtualDestination virtualDestination) {	super.virtualDestinationAdded(context, virtualDestination);	if (virtualDestinations.add(virtualDestination)) {	
virtual destination added 

private void fireVirtualDestinationAddAdvisory(ConnectionContext context, ConsumerInfo info, ActiveMQDestination activeMQDest, VirtualDestination virtualDestination) throws Exception {	if (info == null) {	VirtualConsumerPair pair = new VirtualConsumerPair(virtualDestination, activeMQDest);	if (brokerConsumerDests.get(pair) == null) {	ConnectionId connectionId = new ConnectionId(connectionIdGenerator.generateId());	SessionId sessionId = new SessionId(connectionId, sessionIdGenerator.getNextSequenceId());	ConsumerId consumerId = new ConsumerId(sessionId, consumerIdGenerator.getNextSequenceId());	info = new ConsumerInfo(consumerId);	if(brokerConsumerDests.putIfAbsent(pair, info) == null) {	
virtual consumer pair added for consumer 

VirtualConsumerPair pair = new VirtualConsumerPair(virtualDestination, activeMQDest);	if (brokerConsumerDests.get(pair) == null) {	ConnectionId connectionId = new ConnectionId(connectionIdGenerator.generateId());	SessionId sessionId = new SessionId(connectionId, sessionIdGenerator.getNextSequenceId());	ConsumerId consumerId = new ConsumerId(sessionId, consumerIdGenerator.getNextSequenceId());	info = new ConsumerInfo(consumerId);	if(brokerConsumerDests.putIfAbsent(pair, info) == null) {	setConsumerInfoVirtualDest(info, virtualDestination, activeMQDest);	ActiveMQTopic topic = AdvisorySupport.getVirtualDestinationConsumerAdvisoryTopic(info.getDestination());	if (virtualDestinationConsumers.putIfAbsent(info, virtualDestination) == null) {	
virtual consumer added for virtual destination 

if (virtualDestinationConsumers.putIfAbsent(info, virtualDestination) == null) {	fireConsumerAdvisory(context, info.getDestination(), topic, info);	}	}	}	} else {	info = info.copy();	setConsumerInfoVirtualDest(info, virtualDestination, activeMQDest);	ActiveMQTopic topic = AdvisorySupport.getVirtualDestinationConsumerAdvisoryTopic(info.getDestination());	if (virtualDestinationConsumers.putIfAbsent(info, virtualDestination) == null) {	
virtual consumer added for virtual destination 

public void virtualDestinationRemoved(ConnectionContext context, VirtualDestination virtualDestination) {	super.virtualDestinationRemoved(context, virtualDestination);	if (virtualDestinations.remove(virtualDestination)) {	
virtual destination removed 

consumersLock.readLock().lock();	try {	if (getBrokerService().isUseVirtualDestSubsOnCreation()) {	if (!AdvisorySupport.isAdvisoryTopic(virtualDestination.getVirtualDestination())) {	for (ConsumerInfo info : virtualDestinationConsumers.keySet()) {	if (virtualDestinationConsumers.get(info).equals(virtualDestination)) {	fireVirtualDestinationRemoveAdvisory(context, info);	for (VirtualConsumerPair activeMQDest : brokerConsumerDests.keySet()) {	ConsumerInfo i = brokerConsumerDests.get(activeMQDest);	if (info.equals(i) && brokerConsumerDests.remove(activeMQDest) != null) {	
virtual consumer pair removed for consumer 

private void fireVirtualDestinationRemoveAdvisory(ConnectionContext context, ConsumerInfo info) throws Exception {	VirtualDestination virtualDestination = virtualDestinationConsumers.remove(info);	if (virtualDestination != null) {	
virtual consumer removed for virtual destination 

private void handleFireFailure(String message, Throwable cause) {	
failed to fire advisory reason 

private void handleFireFailure(String message, Throwable cause) {	
detail 

========================= activemq sample_4275 =========================

public void sendMessages(String destName, int msgNum) throws Exception {	ConnectionFactory factory = new org.apache.activemq.ActiveMQConnectionFactory("tcp: Connection conn = factory.createConnection();	Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination dest = sess.createQueue(destName);	MessageProducer producer = sess.createProducer(dest);	for (int i = 0; i < msgNum; i++) {	String messageText = i +" test";	
sending message 

========================= activemq sample_757 =========================

public void testWaitForNoBrokerInRegistry() throws Exception {	long startTime = System.currentTimeMillis();	try {	ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory(new URI(VM_BROKER_URI_SHORT_WAIT_FOR_START));	cf.createConnection();	fail("expect broker not exist exception");	} catch (JMSException expectedOnNoBrokerAndNoCreate) {	}	long endTime = System.currentTimeMillis();	
total wait time was 

broker.setPersistent(false);	BrokerRegistry.getInstance().bind("localhost", broker);	long startTime = System.currentTimeMillis();	try {	ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory(new URI(VM_BROKER_URI_SHORT_WAIT_FOR_START));	cf.createConnection();	fail("expect broker not exist exception");	} catch (JMSException expectedOnNoBrokerAndNoCreate) {	}	long endTime = System.currentTimeMillis();	
total wait time was 

========================= activemq sample_2509 =========================

public void close() throws IOException {	if (!closed) {	if (nextWriteBatch != null) {	
close of targeted appender flushing last batch 

}	file.seek(nextWriteBatch.offset);	if (maxStat > 0) {	if (statIdx < maxStat) {	stats[statIdx++] = sequence.getLength();	} else {	long all = 0;	for (; statIdx > 0;) {	all += stats[--statIdx];	}	
ave writesize 

}	}	file.write(sequence.getData(), sequence.getOffset(), sequence.getLength());	ReplicationTarget replicationTarget = journal.getReplicationTarget();	if (replicationTarget != null) {	replicationTarget.replicate(nextWriteBatch.writes.getHead().location, sequence, true);	}	file.sync();	signalDone(nextWriteBatch);	} catch (IOException e) {	
journal failed while writing at 

private void signalDone(WriteBatch writeBatch) {	Journal.WriteCommand write = writeBatch.writes.getHead();	while (write != null) {	if (!write.sync) {	inflightWrites.remove(new Journal.WriteKey(write.location));	}	if (write.onComplete != null) {	try {	write.onComplete.run();	} catch (Throwable e) {	
add exception was raised while executing the run command for oncomplete 

========================= activemq sample_1775 =========================

if (leftValue instanceof Comparable && rightValue instanceof Comparable) {	if (getSortOrder().toLowerCase().equals("desc")) {	return ((Comparable) rightValue).compareTo(leftValue);	} else {	return ((Comparable) leftValue).compareTo(rightValue);	}	}	}	return 0;	} catch (Exception e) {	
exception sorting destinations 

========================= activemq sample_3932 =========================

protected void setUp() throws Exception {	super.setUp();	messages.clear();	String temp = System.getProperty("messageCount");	if (temp != null) {	int i = Integer.parseInt(temp);	if (i > 0) {	messageCount = i;	}	}	
message count for test case is 

public void testSendReceive() throws Exception {	Thread.sleep(100);	sendMessages();	assertMessagesAreReceived();	
messages s received closing down connections 

protected void sendMessages() throws Exception {	for (int i = 0; i < data.length; i++) {	Message message = createMessage(i);	configureMessage(message);	if (verbose) {	
about to send a message with text 

protected void assertMessageValid(int index, Message message) throws JMSException {	TextMessage textMessage = (TextMessage)message;	String text = textMessage.getText();	if (verbose) {	
received text 

protected void consumeMessage(Message message, List<Message> messageList) {	if (verbose) {	
received message 

========================= activemq sample_2620 =========================

public void afterPropertiesSet() throws Exception {	
created loggingbrokerplugin 

public void acknowledge(ConsumerBrokerExchange consumerExchange, MessageAck ack) throws Exception {	if (isLogAll() || isLogConsumerEvents()) {	LOG.info("Acknowledging message for client ID: {}{}", consumerExchange.getConnectionContext().getClientId(), (ack.getMessageCount() == 1 ? ", " + ack.getLastMessageId() : ""));	if (ack.getMessageCount() > 1) {	
message count first message id last message id 

public Response messagePull(ConnectionContext context, MessagePull pull) throws Exception {	if (isLogAll() || isLogConsumerEvents()) {	
message pull from on 

public void addConnection(ConnectionContext context, ConnectionInfo info) throws Exception {	if (isLogAll() || isLogConnectionEvents()) {	
adding connection 

public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {	if (isLogAll() || isLogConsumerEvents()) {	
adding consumer 

public void addProducer(ConnectionContext context, ProducerInfo info) throws Exception {	if (isLogAll() || isLogProducerEvents()) {	
adding producer 

public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {	if (isLogAll() || isLogTransactionEvents()) {	
committing transaction 

public void removeSubscription(ConnectionContext context, RemoveSubscriptionInfo info) throws Exception {	if (isLogAll() || isLogConsumerEvents()) {	
removing subscription 

public TransactionId[] getPreparedTransactions(ConnectionContext context) throws Exception {	TransactionId[] result = super.getPreparedTransactions(context);	if ((isLogAll() || isLogTransactionEvents()) && result != null) {	StringBuffer tids = new StringBuffer();	for (TransactionId tid : result) {	if (tids.length() > 0) {	tids.append(", ");	}	tids.append(tid.getTransactionKey());	}	
prepared transactions 

public int prepareTransaction(ConnectionContext context, TransactionId xid) throws Exception {	if (isLogAll() || isLogTransactionEvents()) {	
preparing transaction 

public void removeConnection(ConnectionContext context, ConnectionInfo info, Throwable error) throws Exception {	if (isLogAll() || isLogConnectionEvents()) {	
removing connection 

public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {	if (isLogAll() || isLogConsumerEvents()) {	
removing consumer 

public void removeProducer(ConnectionContext context, ProducerInfo info) throws Exception {	if (isLogAll() || isLogProducerEvents()) {	
removing producer 

public void rollbackTransaction(ConnectionContext context, TransactionId xid) throws Exception {	if (isLogAll() || isLogTransactionEvents()) {	
rolling back transaction 

public void beginTransaction(ConnectionContext context, TransactionId xid) throws Exception {	if (isLogAll() || isLogTransactionEvents()) {	
beginning transaction 

public void forgetTransaction(ConnectionContext context, TransactionId transactionId) throws Exception {	if (isLogAll() || isLogTransactionEvents()) {	
forgetting transaction 

public Connection[] getClients() throws Exception {	Connection[] result = super.getClients();	if (isLogAll() || isLogInternalEvents()) {	if (result == null) {	
get clients returned empty list 

public Connection[] getClients() throws Exception {	Connection[] result = super.getClients();	if (isLogAll() || isLogInternalEvents()) {	if (result == null) {	} else {	StringBuffer cids = new StringBuffer();	for (Connection c : result) {	cids.append(cids.length() > 0 ? ", " : "");	cids.append(c.getConnectionId());	}	
connected clients 

public org.apache.activemq.broker.region.Destination addDestination(ConnectionContext context, ActiveMQDestination destination, boolean create) throws Exception {	if (isLogAll() || isLogInternalEvents()) {	
adding destination 

public void removeDestination(ConnectionContext context, ActiveMQDestination destination, long timeout) throws Exception {	if (isLogAll() || isLogInternalEvents()) {	
removing destination 

public ActiveMQDestination[] getDestinations() throws Exception {	ActiveMQDestination[] result = super.getDestinations();	if (isLogAll() || isLogInternalEvents()) {	if (result == null) {	
get destinations returned empty list 

public ActiveMQDestination[] getDestinations() throws Exception {	ActiveMQDestination[] result = super.getDestinations();	if (isLogAll() || isLogInternalEvents()) {	if (result == null) {	} else {	StringBuffer destinations = new StringBuffer();	for (ActiveMQDestination dest : result) {	destinations.append(destinations.length() > 0 ? ", " : "");	destinations.append(dest.getPhysicalName());	}	
get destinations 

public void start() throws Exception {	if (isLogAll() || isLogInternalEvents()) {	
starting 

public void stop() throws Exception {	if (isLogAll() || isLogInternalEvents()) {	
stopping 

public void addSession(ConnectionContext context, SessionInfo info) throws Exception {	if (isLogAll() || isLogSessionEvents()) {	
adding session 

public void removeSession(ConnectionContext context, SessionInfo info) throws Exception {	if (isLogAll() || isLogSessionEvents()) {	
removing session 

public void addBroker(Connection connection, BrokerInfo info) {	if (isLogAll() || isLogInternalEvents()) {	
adding broker 

public void removeBroker(Connection connection, BrokerInfo info) {	if (isLogAll() || isLogInternalEvents()) {	
removing broker 

public BrokerInfo[] getPeerBrokerInfos() {	BrokerInfo[] result = super.getPeerBrokerInfos();	if (isLogAll() || isLogInternalEvents()) {	if (result == null) {	
get peer broker infos returned empty list 

public BrokerInfo[] getPeerBrokerInfos() {	BrokerInfo[] result = super.getPeerBrokerInfos();	if (isLogAll() || isLogInternalEvents()) {	if (result == null) {	} else {	StringBuffer peers = new StringBuffer();	for (BrokerInfo bi : result) {	peers.append(peers.length() > 0 ? ", " : "");	peers.append(bi.getBrokerName());	}	
get peer broker infos 

public void preProcessDispatch(MessageDispatch messageDispatch) {	if (isLogAll() || isLogInternalEvents() || isLogConsumerEvents()) {	
preprocessdispatch 

public void postProcessDispatch(MessageDispatch messageDispatch) {	if (isLogAll() || isLogInternalEvents() || isLogConsumerEvents()) {	
postprocessdispatch 

public void processDispatchNotification(MessageDispatchNotification messageDispatchNotification) throws Exception {	if (isLogAll() || isLogInternalEvents() || isLogConsumerEvents()) {	
processdispatchnotification 

public Set<ActiveMQDestination> getDurableDestinations() {	Set<ActiveMQDestination> result = super.getDurableDestinations();	if (isLogAll() || isLogInternalEvents()) {	if (result == null) {	
get durable destinations returned empty list 

public Set<ActiveMQDestination> getDurableDestinations() {	Set<ActiveMQDestination> result = super.getDurableDestinations();	if (isLogAll() || isLogInternalEvents()) {	if (result == null) {	} else {	StringBuffer destinations = new StringBuffer();	for (ActiveMQDestination dest : result) {	destinations.append(destinations.length() > 0 ? ", " : "");	destinations.append(dest.getPhysicalName());	}	
get durable destinations 

public void addDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception {	if (isLogAll() || isLogInternalEvents()) {	
adding destination info 

public void removeDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception {	if (isLogAll() || isLogInternalEvents()) {	
removing destination info 

public void messageExpired(ConnectionContext context, MessageReference message, Subscription subscription) {	if (isLogAll() || isLogInternalEvents()) {	String msg = "Unable to display message.";	msg = message.getMessage().toString();	
message has expired 

public boolean sendToDeadLetterQueue(ConnectionContext context, MessageReference messageReference, Subscription subscription, Throwable poisonCause) {	if (isLogAll() || isLogInternalEvents()) {	String msg = "Unable to display message.";	msg = messageReference.getMessage().toString();	
sending to dlq 

public void fastProducer(ConnectionContext context, ProducerInfo producerInfo,ActiveMQDestination destination) {	if (isLogAll() || isLogProducerEvents() || isLogInternalEvents()) {	
fast producer 

public void isFull(ConnectionContext context, Destination destination, Usage<?> usage) {	if (isLogAll() || isLogProducerEvents() || isLogInternalEvents()) {	
destination is full 

public void messageConsumed(ConnectionContext context, MessageReference messageReference) {	if (isLogAll() || isLogConsumerEvents() || isLogInternalEvents()) {	String msg = "Unable to display message.";	msg = messageReference.getMessage().toString();	
message consumed 

public void messageDelivered(ConnectionContext context, MessageReference messageReference) {	if (isLogAll() || isLogConsumerEvents() || isLogInternalEvents()) {	String msg = "Unable to display message.";	msg = messageReference.getMessage().toString();	
message delivered 

public void messageDiscarded(ConnectionContext context, Subscription sub, MessageReference messageReference) {	if (isLogAll() || isLogInternalEvents()) {	String msg = "Unable to display message.";	msg = messageReference.getMessage().toString();	
message discarded 

public void slowConsumer(ConnectionContext context, Destination destination, Subscription subs) {	if (isLogAll() || isLogConsumerEvents() || isLogInternalEvents()) {	
detected slow consumer on 

public void nowMasterBroker() {	if (isLogAll() || isLogInternalEvents()) {	
is now the master broker 

========================= activemq sample_3877 =========================

public void testTempPercentUsageDecreases() throws Exception {	MessageConsumer messageConsumer = createConsumer();	sendMessages(MESSAGES_TO_SEND);	final BrokerViewMBean brokerView = getBrokerView(broker);	
temppercentageusage is 

public void testTempPercentUsageDecreases() throws Exception {	MessageConsumer messageConsumer = createConsumer();	sendMessages(MESSAGES_TO_SEND);	final BrokerViewMBean brokerView = getBrokerView(broker);	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
temppercentageusage now 

Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return brokerView.getTempPercentUsage() > 50;	}	});	final int tempPercentUsageWithConsumer = brokerView.getTempPercentUsage();	assertTrue(" tempPercentageUsage ", (50 < tempPercentUsageWithConsumer));	messageConsumer.close();	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
temppercentageusage now after consumer closed 

final String blob = new String(new byte[4 * 1024]);	try {	Session producerSession = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageProducer jmsProducer = producerSession.createProducer(producerSession.createTopic(DESTINATION));	Message sendMessage = producerSession.createTextMessage(blob);	for (int i = 0; i < messageCount; i++) {	jmsProducer.send(sendMessage);	producerSession.commit();	numberOfMessageSent++;	}	
finished after producing 

Session producerSession = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageProducer jmsProducer = producerSession.createProducer(producerSession.createTopic(DESTINATION));	Message sendMessage = producerSession.createTextMessage(blob);	for (int i = 0; i < messageCount; i++) {	jmsProducer.send(sendMessage);	producerSession.commit();	numberOfMessageSent++;	}	return numberOfMessageSent;	} catch (Exception ex) {	
exception received producing 

Session producerSession = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageProducer jmsProducer = producerSession.createProducer(producerSession.createTopic(DESTINATION));	Message sendMessage = producerSession.createTextMessage(blob);	for (int i = 0; i < messageCount; i++) {	jmsProducer.send(sendMessage);	producerSession.commit();	numberOfMessageSent++;	}	return numberOfMessageSent;	} catch (Exception ex) {	
finishing after exception 

========================= activemq sample_2765 =========================

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue(getDestinationName());	MessageProducer producer = session.createProducer(queue);	byte[] buffer = new byte[MESSAGE_SIZE];	for (count = 0; count < MESSAGE_SIZE; count++) {	String s = String.valueOf(count % 10);	Character c = s.charAt(0);	int value = c.charValue();	buffer[count] = (byte) value;	}	
sending messages to destination 

========================= activemq sample_1667 =========================

broker.setDataDirectory(KAHADB_DIRECTORY);	broker.addConnector("tcp: PolicyMap policyMap = new PolicyMap();	PolicyEntry defaultEntry = new PolicyEntry();	defaultEntry.setUseCache(false);	defaultEntry.setExpireMessagesPeriod(0);	policyMap.setDefaultEntry(defaultEntry);	broker.setDestinationPolicy(policyMap);	configurePersistence(broker);	connectionUri = "vm: cf = new ActiveMQConnectionFactory(connectionUri);	broker.start();	
starting broker 

RecoverableRandomAccessFile randomAccessFile = dataFile.openRandomAccessFile();	final ByteSequence header = new ByteSequence(Journal.BATCH_CONTROL_RECORD_HEADER);	byte data[] = new byte[1024 * 20];	ByteSequence bs = new ByteSequence(data, 0, randomAccessFile.read(data, 0, data.length));	int offset = bs.indexOf(header, 0);	offset += Journal.BATCH_CONTROL_RECORD_SIZE;	if (fillLength >= 10) {	offset += 4;	offset += 1;	}	
whacking batch record in file at offset with fill 

========================= activemq sample_1722 =========================

protected void assertRemoteAdvisoryCount(final MessageConsumer advisoryConsumer, final int count) throws JMSException {	int available = 0;	ActiveMQMessage message = null;	while ((message = (ActiveMQMessage) advisoryConsumer.receive(1000)) != null) {	available++;	
advisory data structure 

========================= activemq sample_2732 =========================

public void testBadVMTransportOptionsJMSPrefix() throws Exception {	try{	final String vmUri = "vm: "jms.redeliveryPolicy.maximumRedeliveries=0&" + "jms.redeliveryPolicy.initialRedeliveryDelay=500&" + "jms.useAsyncSend=false&jms.sendTimeout=ABC&" + "jms.maxXXXXReconnectAttempts=1&jms.timeout=3000";	
creating context with bad uri 

public void testBadVMTransportOptionsBrokerPrefix() throws Exception {	try {	final String vmUri = "vm: "broker.XXX=foo&broker.persistent=XXX&broker.useJmx=false";	
creating context with bad uri 

========================= activemq sample_1364 =========================

cons_client = new MessageClient(resp_cons, num_msg);	cons_client.start();	cur = 0;	while ((cur < num_msg) && (!fatalTestError)) {	msg = sess.createTextMessage("MSG AAAA " + cur);	msg.setIntProperty("SEQ", 100 + cur);	msg.setStringProperty("TEST", "TOPO");	msg.setJMSReplyTo(resp_dest);	if (cur == (num_msg - 1)) msg.setBooleanProperty("end-of-response", true);	sendWithRetryOnDeletedDest(req_prod, msg);	
sent 

while ((cur < num_msg) && (!fatalTestError)) {	msg = sess.createTextMessage("MSG AAAA " + cur);	msg.setIntProperty("SEQ", 100 + cur);	msg.setStringProperty("TEST", "TOPO");	msg.setJMSReplyTo(resp_dest);	if (cur == (num_msg - 1)) msg.setBooleanProperty("end-of-response", true);	sendWithRetryOnDeletedDest(req_prod, msg);	cur++;	}	cons_client.waitShutdown(5000);	
consumer client shutdown complete 

while ((cur < num_msg) && (!fatalTestError)) {	msg = sess.createTextMessage("MSG AAAA " + cur);	msg.setIntProperty("SEQ", 100 + cur);	msg.setStringProperty("TEST", "TOPO");	msg.setJMSReplyTo(resp_dest);	if (cur == (num_msg - 1)) msg.setBooleanProperty("end-of-response", true);	sendWithRetryOnDeletedDest(req_prod, msg);	cur++;	}	cons_client.waitShutdown(5000);	
consumer client shutdown incomplete 

msg.setIntProperty("SEQ", 100 + cur);	msg.setStringProperty("TEST", "TOPO");	msg.setJMSReplyTo(resp_dest);	if (cur == (num_msg - 1)) msg.setBooleanProperty("end-of-response", true);	sendWithRetryOnDeletedDest(req_prod, msg);	cur++;	}	cons_client.waitShutdown(5000);	tot_expected = num_msg * (echoResponseFill + 1);	if (cons_client.getNumMsgReceived() == tot_expected) {	
have messages as expected 

if (cur == (num_msg - 1)) msg.setBooleanProperty("end-of-response", true);	sendWithRetryOnDeletedDest(req_prod, msg);	cur++;	}	cons_client.waitShutdown(5000);	tot_expected = num_msg * (echoResponseFill + 1);	if (cons_client.getNumMsgReceived() == tot_expected) {	} else {	testError = true;	if (cons_client.getNumMsgReceived() == 0) fatalTestError = true;	
have messages expected on destination 

protected void sendWithRetryOnDeletedDest(MessageProducer prod, Message msg) throws JMSException {	try {	
sending request message 

public void testOneDest(Connection conn, Session sess, Destination cons_dest, int num_msg) throws Exception {	Destination prod_dest;	MessageProducer msg_prod;	
creating echo queue and producer 

public void testTempTopic(String prod_broker_url, String cons_broker_url) throws Exception {	Connection conn;	Session sess;	Destination cons_dest;	int num_msg;	num_msg = 5;	
testing temp topics messages 

public void testTempTopic(String prod_broker_url, String cons_broker_url) throws Exception {	Connection conn;	Session sess;	Destination cons_dest;	int num_msg;	num_msg = 5;	conn = createConnection(cons_broker_url);	conn.start();	sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	
creating destination 

public void testTopic(String prod_broker_url, String cons_broker_url) throws Exception {	int num_msg;	Connection conn;	Session sess;	String topic_name;	Destination cons_dest;	num_msg = 5;	
testing topics messages 

int num_msg;	Connection conn;	Session sess;	String topic_name;	Destination cons_dest;	num_msg = 5;	conn = createConnection(cons_broker_url);	conn.start();	sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	topic_name = "topotest2.perm.topic";	
removing existing topic 

Connection conn;	Session sess;	String topic_name;	Destination cons_dest;	num_msg = 5;	conn = createConnection(cons_broker_url);	conn.start();	sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	topic_name = "topotest2.perm.topic";	removeTopic(conn, topic_name);	
creating topic 

public void testTempQueue(String prod_broker_url, String cons_broker_url) throws Exception {	int num_msg;	Connection conn;	Session sess;	Destination cons_dest;	num_msg = 5;	
testing temp queues messages 

public void testTempQueue(String prod_broker_url, String cons_broker_url) throws Exception {	int num_msg;	Connection conn;	Session sess;	Destination cons_dest;	num_msg = 5;	conn = createConnection(cons_broker_url);	conn.start();	sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	
creating destination 

public void testQueue(String prod_broker_url, String cons_broker_url) throws Exception {	int num_msg;	Connection conn;	Session sess;	String queue_name;	Destination cons_dest;	num_msg = 5;	
testing queues messages 

int num_msg;	Connection conn;	Session sess;	String queue_name;	Destination cons_dest;	num_msg = 5;	conn = createConnection(cons_broker_url);	conn.start();	sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	queue_name = "topotest2.perm.queue";	
removing existing queue 

Connection conn;	Session sess;	String queue_name;	Destination cons_dest;	num_msg = 5;	conn = createConnection(cons_broker_url);	conn.start();	sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	queue_name = "topotest2.perm.queue";	removeQueue(conn, queue_name);	
creating queue 

start3.start();	start4.start();	start1.join();	start2.join();	start3.join();	start4.join();	traffic_gen = new TopicTrafficGenerator(edge1.getConnectionUrl(), edge2.getConnectionUrl());	traffic_gen.start();	echo_svc = new EchoService("echo", edge1.getConnectionUrl());	echo_svc.start();	
starting temp topic tests 

traffic_gen.start();	echo_svc = new EchoService("echo", edge1.getConnectionUrl());	echo_svc.start();	iter = 0;	while ((iter < TOTAL_CLIENT_ITER) && (!fatalTestError)) {	clientExecPool.execute(new Runnable() {	public void run() {	try {	RequestReplyToTopicViaThreeNetworkHopsTest.this.testTempTopic(edge1.getConnectionUrl(), edge2.getConnectionUrl());	} catch (Exception exc) {	
test exception 

} catch (Exception exc) {	fatalTestError = true;	testError = true;	}	clientCompletionLatch.countDown();	}	});	iter++;	}	boolean allDoneOnTime = clientCompletionLatch.await(20, TimeUnit.MINUTES);	
finished temp topic tests after iterations testerror fatal ontime 

public void run() {	CountDownLatch latch;	try {	synchronized (this) {	latch = shutdownLatch;	}	shutdownInd = false;	processMessages();	latch.countDown();	} catch (Exception exc) {	
message client error 

public void waitShutdown(long timeout) {	CountDownLatch latch;	try {	synchronized (this) {	latch = shutdownLatch;	}	if (latch != null) latch.await(timeout, TimeUnit.MILLISECONDS);	
echo client shutdown client does not appear to be active 

public void waitShutdown(long timeout) {	CountDownLatch latch;	try {	synchronized (this) {	latch = shutdownLatch;	}	if (latch != null) latch.await(timeout, TimeUnit.MILLISECONDS);	} catch (InterruptedException int_exc) {	
wait for message client shutdown interrupted 

protected void checkMessage(Message in_msg) throws Exception {	int seq;	
received message from 

protected void checkMessage(Message in_msg) throws Exception {	int seq;	if (in_msg.propertyExists("SEQ")) {	seq = in_msg.getIntProperty("SEQ");	if ((haveFirstSeq) && (seq != (lastSeq + 1))) {	
error incorrect sequence number expected but have 

protected void checkMessage(Message in_msg) throws Exception {	int seq;	if (in_msg.propertyExists("SEQ")) {	seq = in_msg.getIntProperty("SEQ");	if ((haveFirstSeq) && (seq != (lastSeq + 1))) {	testError = true;	}	lastSeq = seq;	if (msgCount > expectedCount) {	
have more messages than expected have expect 

seq = in_msg.getIntProperty("SEQ");	if ((haveFirstSeq) && (seq != (lastSeq + 1))) {	testError = true;	}	lastSeq = seq;	if (msgCount > expectedCount) {	testError = true;	}	}	if (in_msg.propertyExists("end-of-response")) {	
received end of response message 

public void run() {	Message req;	try {	
starting echo service 

public void run() {	Message req;	try {	while (!Shutdown_ind) {	req = msg_cons.receive(100);	if (req != null) {	processorPool.execute(new EchoRequestProcessor(sess, req));	}	}	} catch (Exception ex) {	
error processing echo service requests 

Message req;	try {	while (!Shutdown_ind) {	req = msg_cons.receive(100);	if (req != null) {	processorPool.execute(new EchoRequestProcessor(sess, req));	}	}	} catch (Exception ex) {	} finally {	
shutting down test echo service 

req = msg_cons.receive(100);	if (req != null) {	processorPool.execute(new EchoRequestProcessor(sess, req));	}	}	} catch (Exception ex) {	} finally {	try {	jmsConn.stop();	} catch (javax.jms.JMSException jms_exc) {	
error on shutting down jms connection 

public void shutdown() {	CountDownLatch wait_l;	synchronized (this) {	wait_l = waitShutdown;	}	Shutdown_ind = true;	try {	if (wait_l != null) {	
echo service shutdown complete 

public void shutdown() {	CountDownLatch wait_l;	synchronized (this) {	wait_l = waitShutdown;	}	Shutdown_ind = true;	try {	if (wait_l != null) {	
timeout waiting for echo service shutdown 

public void shutdown() {	CountDownLatch wait_l;	synchronized (this) {	wait_l = waitShutdown;	}	Shutdown_ind = true;	try {	if (wait_l != null) {	} else {	
echo service shutdown service does not appear to be active 

CountDownLatch wait_l;	synchronized (this) {	wait_l = waitShutdown;	}	Shutdown_ind = true;	try {	if (wait_l != null) {	} else {	}	} catch (InterruptedException int_exc) {	
interrupted while waiting for echo service shutdown 

public void run() {	try {	this.processRequest(this.request);	} catch (Exception ex) {	
failed to process request 

protected void processRequest(Message req) throws Exception {	
echo request message 

protected void processRequest(Message req) throws Exception {	resp_dest = req.getJMSReplyTo();	if (resp_dest != null) {	msg_prod = session.createProducer(resp_dest);	
sending echo response to 

protected void processRequest(Message req) throws Exception {	resp_dest = req.getJMSReplyTo();	if (resp_dest != null) {	msg_prod = session.createProducer(resp_dest);	msg_prod.send(req);	
sent echo response to 

protected void processRequest(Message req) throws Exception {	resp_dest = req.getJMSReplyTo();	if (resp_dest != null) {	msg_prod = session.createProducer(resp_dest);	msg_prod.send(req);	msg_prod.close();	msg_prod = null;	} else {	
invalid request no reply to destination given 

public void run() {	Message msg;	try {	
starting topic traffic generator 

public void run() {	Message msg;	try {	while (!Shutdown_ind) {	msg = sess1.createTextMessage("TRAFFIC");	prod.send(msg);	send_count++;	msg = cons.receive(250);	}	} catch (JMSException jms_exc) {	
traffic generator failed on jms exception 

send_count++;	msg = cons.receive(250);	}	} catch (JMSException jms_exc) {	} finally {	LOG.info("Shutdown of Topic Traffic Generator; send count = " + send_count);	if (conn1 != null) {	try {	conn1.stop();	} catch (JMSException jms_exc) {	
failed to shutdown connection 

if (conn1 != null) {	try {	conn1.stop();	} catch (JMSException jms_exc) {	}	}	if (conn2 != null) {	try {	conn2.stop();	} catch (JMSException jms_exc) {	
failed to shutdown connection 

========================= activemq sample_3709 =========================

public void testMaxFileLengthGrow() throws Exception {	MessageStore messageStore = createStore(8 * ONE_MB);	addMessages(messageStore, 4);	long sizeBeforeChange = store.getJournal().getDiskSize();	
journal size before 

public void testMaxFileLengthGrow() throws Exception {	MessageStore messageStore = createStore(8 * ONE_MB);	addMessages(messageStore, 4);	long sizeBeforeChange = store.getJournal().getDiskSize();	store.stop();	messageStore = createStore(6 * ONE_MB);	verifyMessages(messageStore, 4);	long sizeAfterChange = store.getJournal().getDiskSize();	
journal size after 

public void testMaxFileLengthShrink() throws Exception {	MessageStore messageStore = createStore(8 * ONE_MB);	addMessages(messageStore, 4);	long sizeBeforeChange = store.getJournal().getDiskSize();	
journal size before 

public void testMaxFileLengthShrink() throws Exception {	MessageStore messageStore = createStore(8 * ONE_MB);	addMessages(messageStore, 4);	long sizeBeforeChange = store.getJournal().getDiskSize();	store.stop();	messageStore = createStore(2 * ONE_MB);	verifyMessages(messageStore, 4);	long sizeAfterChange = store.getJournal().getDiskSize();	
journal size after 

========================= activemq sample_1734 =========================

protected BrokerService createBroker(String uri) throws Exception {	
loading broker configuration from the classpath with uri 

========================= activemq sample_2661 =========================

public void setUp() throws Exception {	
configuring broker programmatically 

public void testAMQConnectionExecutorThreadCleanUp() throws Exception {	
testamqconnectionexecutorthreadcleanup started 

public void testAMQConnectionExecutorThreadCleanUp() throws Exception {	ActiveMQResourceAdapter ra = new ActiveMQResourceAdapter();	ra.setServerUrl(broker.getTransportConnectorByScheme("tcp").getPublishableConnectString());	
using brokerurl 

public void testAMQConnectionExecutorThreadCleanUp() throws Exception {	ActiveMQResourceAdapter ra = new ActiveMQResourceAdapter();	ra.setServerUrl(broker.getTransportConnectorByScheme("tcp").getPublishableConnectString());	for (int i=0; i<10; i++) {	
iteration 

public boolean hasActiveMQConnectionExceutorThread() {	Set<Thread> threadSet = Thread.getAllStackTraces().keySet();	Iterator<Thread> iter = threadSet.iterator();	while (iter.hasNext()) {	Thread thread = (Thread)iter.next();	if (thread.getName().startsWith(AMQ_CONN_EXECUTOR_THREAD_NAME )) {	
thread with name found 

public boolean hasActiveMQConnectionExceutorThread() {	Set<Thread> threadSet = Thread.getAllStackTraces().keySet();	Iterator<Thread> iter = threadSet.iterator();	while (iter.hasNext()) {	Thread thread = (Thread)iter.next();	if (thread.getName().startsWith(AMQ_CONN_EXECUTOR_THREAD_NAME )) {	return true;	}	}	
thread with name not found 

========================= activemq sample_829 =========================

public void testSessionClosedDoesNotGetReceiverDetachFromRemote() throws Exception {	AmqpClient client = createAmqpClient();	assertNotNull(client);	client.setValidator(new AmqpValidator() {	public void inspectClosedResource(Session session) {	
session closed 

========================= activemq sample_1558 =========================

advisoryTopicsForTempQueues = countTopicsByName("BrokerC", "ActiveMQ.Advisory.Consumer.Queue.ID");	assertEquals("Advisory topic should be present", 1, advisoryTopicsForTempQueues);	stompConnection.disconnect();	Thread.sleep(1000);	advisoryTopicsForTempQueues = countTopicsByName("BrokerA", "ActiveMQ.Advisory.Consumer.Queue.ID");	assertEquals("Advisory topic should have been deleted", 0, advisoryTopicsForTempQueues);	advisoryTopicsForTempQueues = countTopicsByName("BrokerB", "ActiveMQ.Advisory.Consumer.Queue.ID");	assertEquals("Advisory topic should have been deleted", 0, advisoryTopicsForTempQueues);	advisoryTopicsForTempQueues = countTopicsByName("BrokerC", "ActiveMQ.Advisory.Consumer.Queue.ID");	assertEquals("Advisory topic should have been deleted", 0, advisoryTopicsForTempQueues);	
restarting brokera 

========================= activemq sample_3565 =========================

public void onWebSocketBinary(byte[] data, int offset, int length) {	if (data ==null || length <= 0) {	return;	}	MQTTFrame frame = null;	try {	frame = (MQTTFrame)wireFormat.unmarshal(new ByteSequence(data, offset, length));	} catch (IOException e) {	
could not decode incoming mqtt frame 

}	MQTTFrame frame = null;	try {	frame = (MQTTFrame)wireFormat.unmarshal(new ByteSequence(data, offset, length));	} catch (IOException e) {	connection.close();	}	try {	switch (frame.messageType()) {	case PINGREQ.TYPE: PINGREQ ping = new PINGREQ().decode(frame);	
ws client read frame 

try {	frame = (MQTTFrame)wireFormat.unmarshal(new ByteSequence(data, offset, length));	} catch (IOException e) {	connection.close();	}	try {	switch (frame.messageType()) {	case PINGREQ.TYPE: PINGREQ ping = new PINGREQ().decode(frame);	sendFrame(PING_RESP_FRAME);	break;	
ws client ping response received 

} catch (IOException e) {	connection.close();	}	try {	switch (frame.messageType()) {	case PINGREQ.TYPE: PINGREQ ping = new PINGREQ().decode(frame);	sendFrame(PING_RESP_FRAME);	break;	break;	case CONNACK.TYPE: CONNACK connAck = new CONNACK().decode(frame);	
ws client read frame 

try {	switch (frame.messageType()) {	case PINGREQ.TYPE: PINGREQ ping = new PINGREQ().decode(frame);	sendFrame(PING_RESP_FRAME);	break;	break;	case CONNACK.TYPE: CONNACK connAck = new CONNACK().decode(frame);	prefetch.put(frame);	break;	case SUBACK.TYPE: SUBACK subAck = new SUBACK().decode(frame);	
ws client read frame 

sendFrame(PING_RESP_FRAME);	break;	break;	case CONNACK.TYPE: CONNACK connAck = new CONNACK().decode(frame);	prefetch.put(frame);	break;	case SUBACK.TYPE: SUBACK subAck = new SUBACK().decode(frame);	prefetch.put(frame);	break;	case PUBLISH.TYPE: PUBLISH publish = new PUBLISH().decode(frame);	
ws client read frame 

case CONNACK.TYPE: CONNACK connAck = new CONNACK().decode(frame);	prefetch.put(frame);	break;	case SUBACK.TYPE: SUBACK subAck = new SUBACK().decode(frame);	prefetch.put(frame);	break;	case PUBLISH.TYPE: PUBLISH publish = new PUBLISH().decode(frame);	prefetch.put(frame);	break;	case PUBACK.TYPE: PUBACK pubAck = new PUBACK().decode(frame);	
ws client read frame 

case SUBACK.TYPE: SUBACK subAck = new SUBACK().decode(frame);	prefetch.put(frame);	break;	case PUBLISH.TYPE: PUBLISH publish = new PUBLISH().decode(frame);	prefetch.put(frame);	break;	case PUBACK.TYPE: PUBACK pubAck = new PUBACK().decode(frame);	prefetch.put(frame);	break;	case PUBREC.TYPE: PUBREC pubRec = new PUBREC().decode(frame);	
ws client read frame 

case PUBLISH.TYPE: PUBLISH publish = new PUBLISH().decode(frame);	prefetch.put(frame);	break;	case PUBACK.TYPE: PUBACK pubAck = new PUBACK().decode(frame);	prefetch.put(frame);	break;	case PUBREC.TYPE: PUBREC pubRec = new PUBREC().decode(frame);	prefetch.put(frame);	break;	case PUBREL.TYPE: PUBREL pubRel = new PUBREL().decode(frame);	
ws client read frame 

case PUBACK.TYPE: PUBACK pubAck = new PUBACK().decode(frame);	prefetch.put(frame);	break;	case PUBREC.TYPE: PUBREC pubRec = new PUBREC().decode(frame);	prefetch.put(frame);	break;	case PUBREL.TYPE: PUBREL pubRel = new PUBREL().decode(frame);	prefetch.put(frame);	break;	case PUBCOMP.TYPE: PUBCOMP pubComp = new PUBCOMP().decode(frame);	
ws client read frame 

break;	case PUBREC.TYPE: PUBREC pubRec = new PUBREC().decode(frame);	prefetch.put(frame);	break;	case PUBREL.TYPE: PUBREL pubRel = new PUBREL().decode(frame);	prefetch.put(frame);	break;	case PUBCOMP.TYPE: PUBCOMP pubComp = new PUBCOMP().decode(frame);	prefetch.put(frame);	break;	
unknown mqtt frame received 

break;	case PUBREL.TYPE: PUBREL pubRel = new PUBREL().decode(frame);	prefetch.put(frame);	break;	case PUBCOMP.TYPE: PUBCOMP pubComp = new PUBCOMP().decode(frame);	prefetch.put(frame);	break;	connection.close();	}	} catch (Exception e) {	
could not decode incoming mqtt frame 

public void onWebSocketClose(int statusCode, String reason) {	
mqtt ws connection closed code message 

========================= activemq sample_1108 =========================

public static SSLContext createSslContext(NettyTransportSslOptions options) throws Exception {	try {	String contextProtocol = options.getContextProtocol();	
getting sslcontext instance using protocol 

public static SSLContext createSslContext(NettyTransportSslOptions options) throws Exception {	try {	String contextProtocol = options.getContextProtocol();	SSLContext context = SSLContext.getInstance(contextProtocol);	KeyManager[] keyMgrs = loadKeyManagers(options);	TrustManager[] trustManagers = loadTrustManagers(options);	context.init(keyMgrs, trustManagers, new SecureRandom());	return context;	} catch (Exception e) {	
failed to create sslcontext 

private static String[] buildEnabledProtocols(SSLEngine engine, NettyTransportSslOptions options) {	List<String> enabledProtocols = new ArrayList<String>();	if (options.getEnabledProtocols() != null) {	List<String> configuredProtocols = Arrays.asList(options.getEnabledProtocols());	
configured protocols from transport options 

private static String[] buildEnabledProtocols(SSLEngine engine, NettyTransportSslOptions options) {	List<String> enabledProtocols = new ArrayList<String>();	if (options.getEnabledProtocols() != null) {	List<String> configuredProtocols = Arrays.asList(options.getEnabledProtocols());	enabledProtocols.addAll(configuredProtocols);	} else {	List<String> engineProtocols = Arrays.asList(engine.getEnabledProtocols());	
default protocols from the sslengine 

if (options.getEnabledProtocols() != null) {	List<String> configuredProtocols = Arrays.asList(options.getEnabledProtocols());	enabledProtocols.addAll(configuredProtocols);	} else {	List<String> engineProtocols = Arrays.asList(engine.getEnabledProtocols());	enabledProtocols.addAll(engineProtocols);	}	String[] disabledProtocols = options.getDisabledProtocols();	if (disabledProtocols != null) {	List<String> disabled = Arrays.asList(disabledProtocols);	
disabled protocols 

enabledProtocols.addAll(configuredProtocols);	} else {	List<String> engineProtocols = Arrays.asList(engine.getEnabledProtocols());	enabledProtocols.addAll(engineProtocols);	}	String[] disabledProtocols = options.getDisabledProtocols();	if (disabledProtocols != null) {	List<String> disabled = Arrays.asList(disabledProtocols);	enabledProtocols.removeAll(disabled);	}	
enabled protocols 

private static String[] buildEnabledCipherSuites(SSLEngine engine, NettyTransportSslOptions options) {	List<String> enabledCipherSuites = new ArrayList<String>();	if (options.getEnabledCipherSuites() != null) {	List<String> configuredCipherSuites = Arrays.asList(options.getEnabledCipherSuites());	
configured cipher suites from transport options 

private static String[] buildEnabledCipherSuites(SSLEngine engine, NettyTransportSslOptions options) {	List<String> enabledCipherSuites = new ArrayList<String>();	if (options.getEnabledCipherSuites() != null) {	List<String> configuredCipherSuites = Arrays.asList(options.getEnabledCipherSuites());	enabledCipherSuites.addAll(configuredCipherSuites);	} else {	List<String> engineCipherSuites = Arrays.asList(engine.getEnabledCipherSuites());	
default cipher suites from the sslengine 

if (options.getEnabledCipherSuites() != null) {	List<String> configuredCipherSuites = Arrays.asList(options.getEnabledCipherSuites());	enabledCipherSuites.addAll(configuredCipherSuites);	} else {	List<String> engineCipherSuites = Arrays.asList(engine.getEnabledCipherSuites());	enabledCipherSuites.addAll(engineCipherSuites);	}	String[] disabledCipherSuites = options.getDisabledCipherSuites();	if (disabledCipherSuites != null) {	List<String> disabled = Arrays.asList(disabledCipherSuites);	
disabled cipher suites 

enabledCipherSuites.addAll(configuredCipherSuites);	} else {	List<String> engineCipherSuites = Arrays.asList(engine.getEnabledCipherSuites());	enabledCipherSuites.addAll(engineCipherSuites);	}	String[] disabledCipherSuites = options.getDisabledCipherSuites();	if (disabledCipherSuites != null) {	List<String> disabled = Arrays.asList(disabledCipherSuites);	enabledCipherSuites.removeAll(disabled);	}	
enabled cipher suites 

if (options.isTrustAll()) {	return new TrustManager[] { createTrustAllTrustManager() };	}	if (options.getTrustStoreLocation() == null) {	return null;	}	TrustManagerFactory fact = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());	String storeLocation = options.getTrustStoreLocation();	String storePassword = options.getTrustStorePassword();	String storeType = options.getStoreType();	
attempt to load truststore from location of type 

private static KeyManager[] loadKeyManagers(NettyTransportSslOptions options) throws Exception {	if (options.getKeyStoreLocation() == null) {	return null;	}	KeyManagerFactory fact = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());	String storeLocation = options.getKeyStoreLocation();	String storePassword = options.getKeyStorePassword();	String storeType = options.getStoreType();	String alias = options.getKeyAlias();	
attempt to load keystore from location of type 

========================= activemq sample_1626 =========================

for (int i = 0; i < NUM_MESSAGES; i++) {	Connection connection = connectionFactory.createConnection();	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(QUEUE);	MessageProducer producer = session.createProducer(destination);	String msgTo = "hello";	TextMessage message = session.createTextMessage(msgTo);	producer.send(message);	connection.close();	
sent messages using 

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(QUEUE);	MessageConsumer consumer = session.createConsumer(destination);	for (int i = 0; i < NUM_MESSAGES; ++i) {	Message msg = consumer.receive(5000);	if (msg == null) {	return;	}	numReceived++;	if (numReceived % 20 == 0) {	
received messages 

}	} catch (Exception e) {	throw new RuntimeException(e);	}	}	});	thread.start();	ExecutorService threads = Executors.newFixedThreadPool(2);	final CyclicBarrier barrier = new CyclicBarrier(2, new Runnable() {	public void run() {	
starting threads to send messages 

========================= activemq sample_1299 =========================

public void load() throws IOException {	store = new LegacyJobSchedulerStoreImpl();	store.setDirectory(legacyStoreDirectory);	store.setFailIfDatabaseIsLocked(true);	try {	store.start();	} catch (IOException ioe) {	
legacy store load failed 

public void load() throws IOException {	store = new LegacyJobSchedulerStoreImpl();	store.setDirectory(legacyStoreDirectory);	store.setFailIfDatabaseIsLocked(true);	try {	store.start();	} catch (IOException ioe) {	throw ioe;	} catch (Exception e) {	
legacy store load failed 

public void unload() throws IOException {	if (store != null) {	try {	store.stop();	} catch (Exception e) {	
legacy store unload failed 

public void startReplay(JobSchedulerStoreImpl targetStore) throws IOException {	checkLoaded();	if (targetStore == null) {	throw new IOException("Cannot replay to a null store");	}	try {	Set<String> schedulers = store.getJobSchedulerNames();	if (!schedulers.isEmpty()) {	for (String name : schedulers) {	LegacyJobSchedulerImpl scheduler = store.getJobScheduler(name);	
replay of legacy store starting 

throw new IOException("Cannot replay to a null store");	}	try {	Set<String> schedulers = store.getJobSchedulerNames();	if (!schedulers.isEmpty()) {	for (String name : schedulers) {	LegacyJobSchedulerImpl scheduler = store.getJobScheduler(name);	replayScheduler(scheduler, targetStore);	}	}	
replay of legacy store complate 

}	try {	Set<String> schedulers = store.getJobSchedulerNames();	if (!schedulers.isEmpty()) {	for (String name : schedulers) {	LegacyJobSchedulerImpl scheduler = store.getJobScheduler(name);	replayScheduler(scheduler, targetStore);	}	}	} catch (IOException ioe) {	
failed during replay of legacy store 

Set<String> schedulers = store.getJobSchedulerNames();	if (!schedulers.isEmpty()) {	for (String name : schedulers) {	LegacyJobSchedulerImpl scheduler = store.getJobScheduler(name);	replayScheduler(scheduler, targetStore);	}	}	} catch (IOException ioe) {	throw ioe;	} catch (Exception e) {	
failed during replay of legacy store 

private final void replayScheduler(LegacyJobSchedulerImpl legacy, JobSchedulerStoreImpl target) throws Exception {	List<LegacyJobImpl> jobs = legacy.getAllJobs();	String schedulerName = legacy.getName();	for (LegacyJobImpl job : jobs) {	
storing job from legacy store to new store 

========================= activemq sample_1763 =========================

public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {	if (messageId != null) {	QueueViewMBean queueView = getQueueView();	if (queueView != null) {	
removing message 

public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {	if (messageId != null) {	QueueViewMBean queueView = getQueueView();	if (queueView != null) {	queueView.removeMessage(messageId);	} else {	
no queue named 

========================= activemq sample_1333 =========================

public void oneway(Object command, SocketAddress address) throws IOException {	if (LOG.isDebugEnabled()) {	
sending oneway from to target command 

public void run() {	
consumer thread starting for 

public void run() {	while (!isStopped()) {	try {	Command command = commandChannel.read();	doConsume(command);	} catch (AsynchronousCloseException e) {	try {	stop();	} catch (Exception e2) {	
caught in while closing now closed 

while (!isStopped()) {	try {	Command command = commandChannel.read();	doConsume(command);	} catch (AsynchronousCloseException e) {	try {	stop();	} catch (Exception e2) {	}	} catch (SocketException e) {	
socket closed 

doConsume(command);	} catch (AsynchronousCloseException e) {	try {	stop();	} catch (Exception e2) {	}	} catch (SocketException e) {	try {	stop();	} catch (Exception e2) {	
caught in while closing now closed 

try {	stop();	} catch (Exception e2) {	}	} catch (SocketException e) {	try {	stop();	} catch (Exception e2) {	}	} catch (EOFException e) {	
socket closed 

}	} catch (SocketException e) {	try {	stop();	} catch (Exception e2) {	}	} catch (EOFException e) {	try {	stop();	} catch (Exception e2) {	
caught in while closing now closed 

}	} catch (EOFException e) {	try {	stop();	} catch (Exception e2) {	}	} catch (Exception e) {	try {	stop();	} catch (Exception e2) {	
caught in while closing now closed 

} catch (Exception e2) {	}	} catch (Exception e) {	try {	stop();	} catch (Exception e2) {	}	if (e instanceof IOException) {	onException((IOException)e);	} else {	
caught 

protected void bind(DatagramSocket socket, SocketAddress localAddress) throws IOException {	channel.configureBlocking(true);	if (LOG.isDebugEnabled()) {	
binding to address 

========================= activemq sample_74 =========================

String queueName = null;	Context jndiContext = null;	QueueConnectionFactory queueConnectionFactory = null;	QueueConnection queueConnection = null;	QueueSession queueSession = null;	Queue queue = null;	QueueSender queueSender = null;	TextMessage message = null;	final int numMsgs;	if ((args.length < 1) || (args.length > 2)) {	
usage java simplequeuesender queue name number of messages 

QueueConnection queueConnection = null;	QueueSession queueSession = null;	Queue queue = null;	QueueSender queueSender = null;	TextMessage message = null;	final int numMsgs;	if ((args.length < 1) || (args.length > 2)) {	System.exit(1);	}	queueName = args[0];	
queue name is 

}	queueName = args[0];	if (args.length == 2) {	numMsgs = (new Integer(args[1])).intValue();	} else {	numMsgs = 1;	}	try {	jndiContext = new InitialContext();	} catch (NamingException e) {	
could not create jndi api context 

}	try {	jndiContext = new InitialContext();	} catch (NamingException e) {	System.exit(1);	}	try {	queueConnectionFactory = (QueueConnectionFactory)jndiContext.lookup("QueueConnectionFactory");	queue = (Queue)jndiContext.lookup(queueName);	} catch (NamingException e) {	
jndi api lookup failed 

} catch (NamingException e) {	System.exit(1);	}	try {	queueConnection = queueConnectionFactory.createQueueConnection();	queueSession = queueConnection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);	queueSender = queueSession.createSender(queue);	message = queueSession.createTextMessage();	for (int i = 0; i < numMsgs; i++) {	message.setText("This is message " + (i + 1));	
sending message 

queueConnection = queueConnectionFactory.createQueueConnection();	queueSession = queueConnection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);	queueSender = queueSession.createSender(queue);	message = queueSession.createTextMessage();	for (int i = 0; i < numMsgs; i++) {	message.setText("This is message " + (i + 1));	queueSender.send(message);	}	queueSender.send(queueSession.createMessage());	} catch (JMSException e) {	
exception occurred 

========================= activemq sample_2266 =========================

producer.close();	producerSession.commit();	producerSession.close();	Session consumerSession = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageConsumer consumer = consumerSession.createConsumer(consumerSession.createQueue("myQueue"));	Message consumerMessage = consumer.receive(1000);	try {	String txId = consumerMessage.getStringProperty("JMSXProducerTXID");	assertNotNull(txId);	} catch(Exception e) {	
caught exception that was not expected 

========================= activemq sample_2773 =========================

public void run() {	long now = System.currentTimeMillis();	if ((now - startTime) >= connectionTimeout && connectCheckerTask != null && !ASYNC_TASKS.isShutdown()) {	if (LOG.isDebugEnabled()) {	
no connect frame received in time for throwing inactivityioexception 

if (LOG.isDebugEnabled()) {	}	try {	ASYNC_TASKS.execute(new Runnable() {	public void run() {	onException(new InactivityIOException("Channel was inactive for too (>" + (readKeepAliveTime + readGraceTime) + ") long: " + next.getRemoteAddress()));	}	});	} catch (RejectedExecutionException ex) {	if (!ASYNC_TASKS.isShutdown()) {	
async connection timeout task was rejected from the executor 

public void run() {	long now = System.currentTimeMillis();	int currentCounter = next.getReceiveCounter();	int previousCounter = lastReceiveCounter.getAndSet(currentCounter);	if (inReceive.get() || currentCounter != previousCounter) {	if (LOG.isTraceEnabled()) {	
command received since last read check 

int currentCounter = next.getReceiveCounter();	int previousCounter = lastReceiveCounter.getAndSet(currentCounter);	if (inReceive.get() || currentCounter != previousCounter) {	if (LOG.isTraceEnabled()) {	}	lastReceiveTime = now;	return;	}	if ((now - lastReceiveTime) >= readKeepAliveTime + readGraceTime && readCheckerTask != null && !ASYNC_TASKS.isShutdown()) {	if (LOG.isDebugEnabled()) {	
no message received since last read check for throwing inactivityioexception 

if (LOG.isDebugEnabled()) {	}	try {	ASYNC_TASKS.execute(new Runnable() {	public void run() {	onException(new InactivityIOException("Channel was inactive for too (>" + (connectionTimeout) + ") long: " + next.getRemoteAddress()));	}	});	} catch (RejectedExecutionException ex) {	if (!ASYNC_TASKS.isShutdown()) {	
async connection timeout task was rejected from the executor 

========================= activemq sample_891 =========================

publisher = session.createProducer(topic);	assertNotNull(publisher);	MapMessage msg = session.createMapMessage();	assertNotNull(msg);	msg.setString("key1", "value1");	int loop;	for (loop = 0; loop < MESSAGE_COUNT; loop++) {	msg.setInt("key2", loop);	publisher.send(msg, DELIVERY_MODE, DELIVERY_PRIORITY, Message.DEFAULT_TIME_TO_LIVE);	if (loop % 5000 == 0) {	
sent messages 

session = connection.createSession(false, javax.jms.Session.AUTO_ACKNOWLEDGE);	assertNotNull(session);	topic = session.createTopic(TOPIC_NAME);	assertNotNull(topic);	subscriber = session.createDurableSubscriber(topic, SUBID, "", false);	assertNotNull(subscriber);	int loop;	for (loop = 0; loop < MESSAGE_COUNT; loop++) {	subscriber.receive();	if (loop % 500 == 0) {	
received messages 

========================= activemq sample_3532 =========================

public void onMessage(Message msg) {	super.onMessage(msg);	
got a msg 

========================= activemq sample_3545 =========================

protected void setUp() throws Exception {	
properties 

========================= activemq sample_2641 =========================

private String createLargeString(int sizeInBytes) {	byte[] base = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};	StringBuilder builder = new StringBuilder();	for (int i = 0; i < sizeInBytes; i++) {	builder.append(base[i % base.length]);	}	
created string with size bytes 

public void doTestSendLargeMessage(int expectedSize) throws JMSException{	
dotestsendlargemessage called with expectedsize 

assertEquals(expectedSize, payload.getBytes().length);	Connection connection = JMSClientContext.INSTANCE.createConnection(getBrokerAmqpConnectionURI());	long startTime = System.currentTimeMillis();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue(testName.getMethodName());	MessageProducer producer = session.createProducer(queue);	TextMessage message = session.createTextMessage();	message.setText(payload);	producer.send(message);	long endTime = System.currentTimeMillis();	
returned from send after ms 

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue(testName.getMethodName());	MessageProducer producer = session.createProducer(queue);	TextMessage message = session.createTextMessage();	message.setText(payload);	producer.send(message);	long endTime = System.currentTimeMillis();	startTime = System.currentTimeMillis();	MessageConsumer consumer = session.createConsumer(queue);	connection.start();	
calling receive 

long endTime = System.currentTimeMillis();	startTime = System.currentTimeMillis();	MessageConsumer consumer = session.createConsumer(queue);	connection.start();	Message receivedMessage = consumer.receive();	assertNotNull(receivedMessage);	assertTrue(receivedMessage instanceof TextMessage);	TextMessage receivedTextMessage = (TextMessage) receivedMessage;	assertNotNull(receivedMessage);	endTime = System.currentTimeMillis();	
returned from receive after ms 

========================= activemq sample_1597 =========================

protected Transport createTransport(int backups) throws Exception {	String connectionUri = "failover: broker1.getTransportConnectors().get(0).getPublishableConnectString() + "," + broker2.getTransportConnectors().get(0).getPublishableConnectString() + "," + broker3.getTransportConnectors().get(0).getPublishableConnectString() + ")";	if (backups > 0) {	connectionUri += "?randomize=false&backup=true&backupPoolSize=" + backups;	}	Transport transport = TransportFactory.connect(new URI(connectionUri));	transport.setTransportListener(new TransportListener() {	public void onCommand(Object command) {	
test transport listener received command 

protected Transport createTransport(int backups) throws Exception {	String connectionUri = "failover: broker1.getTransportConnectors().get(0).getPublishableConnectString() + "," + broker2.getTransportConnectors().get(0).getPublishableConnectString() + "," + broker3.getTransportConnectors().get(0).getPublishableConnectString() + ")";	if (backups > 0) {	connectionUri += "?randomize=false&backup=true&backupPoolSize=" + backups;	}	Transport transport = TransportFactory.connect(new URI(connectionUri));	transport.setTransportListener(new TransportListener() {	public void onCommand(Object command) {	if (command instanceof BrokerInfo) {	currentBrokerInfo = (BrokerInfo) command;	
brokerinfo 

connectionUri += "?randomize=false&backup=true&backupPoolSize=" + backups;	}	Transport transport = TransportFactory.connect(new URI(connectionUri));	transport.setTransportListener(new TransportListener() {	public void onCommand(Object command) {	if (command instanceof BrokerInfo) {	currentBrokerInfo = (BrokerInfo) command;	}	}	public void onException(IOException error) {	
test transport listener received exception 

transport.setTransportListener(new TransportListener() {	public void onCommand(Object command) {	if (command instanceof BrokerInfo) {	currentBrokerInfo = (BrokerInfo) command;	}	}	public void onException(IOException error) {	}	public void transportInterupted() {	transportInterruptions++;	
test transport listener records transport interrupted 

currentBrokerInfo = (BrokerInfo) command;	}	}	public void onException(IOException error) {	}	public void transportInterupted() {	transportInterruptions++;	}	public void transportResumed() {	transportResumptions++;	
test transport listener records transport resumed 

========================= activemq sample_2568 =========================

public void testSendTextMessage() throws Exception {	String expectedBody = "Hello there!";	template.sendBodyAndHeader(startEndpointUri, expectedBody, "cheese", 123);	listener.assertMessagesArrived(1);	List<Message> list = listener.flushMessages();	assertTrue("Should have received some messages!", !list.isEmpty());	Message message = list.get(0);	
received 

========================= activemq sample_1344 =========================

public DurableSubscriptionOffline4Test(Boolean keepDurableSubsActive) {	this.journalMaxFileLength = 64 * 1024;	this.keepDurableSubsActive = keepDurableSubsActive.booleanValue();	
running with keepdurablesubsactive journalmaxfilelength 

final String payload = new byte[40*1024].toString();	int sent = 0;	for (int i = sent; i < toSend; i++) {	Message message = session.createTextMessage(payload);	message.setStringProperty("filter", "false");	message.setIntProperty("ID", i);	producer.send(topic, message);	sent++;	}	con.close();	
sent 

session.unsubscribe("SubsId");	destroyBroker();	createBroker(false);	con = createConnection("cli2");	session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);	final DurableSubscriptionOfflineTestListener listener = new DurableSubscriptionOfflineTestListener();	consumer.setMessageListener(listener);	assertTrue("got all sent", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
want current 

========================= activemq sample_3683 =========================

public void testDurableSubNetwork() throws Exception {	
testdurablesubnetwork started 

public void testDurableSubNetwork() throws Exception {	ActiveMQConnectionFactory fact = new ActiveMQConnectionFactory(connector.getConnectUri().toString());	Connection conn = fact.createConnection();	conn.setClientID("clientID1");	Session session = conn.createSession(false, 1);	Destination dest = session.createTopic(topicName);	TopicSubscriber sub = session.createDurableSubscriber((Topic)dest, subName);	
durable subscription of name created 

Connection conn = fact.createConnection();	conn.setClientID("clientID1");	Session session = conn.createSession(false, 1);	Destination dest = session.createTopic(topicName);	TopicSubscriber sub = session.createDurableSubscriber((Topic)dest, subName);	Thread.sleep(100);	assertTrue(foundSubInLocalBroker(subName));	assertTrue(foundSubInRemoteBrokerByTopicName(topicName));	sub.close();	session.unsubscribe(subName);	
unsubscribed from durable subscription 

public void testTwoDurableSubsInNetworkWithUnsubscribe() throws Exception{	ActiveMQConnectionFactory fact = new ActiveMQConnectionFactory(connector.getConnectUri().toString());	Connection conn = fact.createConnection();	conn.setClientID("clientID1");	Session session = conn.createSession(false, 1);	Destination dest = session.createTopic(topicName);	TopicSubscriber sub = session.createDurableSubscriber((Topic)dest, subName);	
durable subscription of name created 

public void testTwoDurableSubsInNetworkWithUnsubscribe() throws Exception{	ActiveMQConnectionFactory fact = new ActiveMQConnectionFactory(connector.getConnectUri().toString());	Connection conn = fact.createConnection();	conn.setClientID("clientID1");	Session session = conn.createSession(false, 1);	Destination dest = session.createTopic(topicName);	TopicSubscriber sub = session.createDurableSubscriber((Topic)dest, subName);	TopicSubscriber sub2 = session.createDurableSubscriber((Topic) dest, subName2);	
durable subscription of name created 

Session session = conn.createSession(false, 1);	Destination dest = session.createTopic(topicName);	TopicSubscriber sub = session.createDurableSubscriber((Topic)dest, subName);	TopicSubscriber sub2 = session.createDurableSubscriber((Topic) dest, subName2);	Thread.sleep(100);	assertTrue(foundSubInLocalBroker(subName));	assertTrue(foundSubInLocalBroker(subName2));	assertTrue(foundSubInRemoteBrokerByTopicName(topicName));	sub.close();	session.unsubscribe(subName);	
unsubscribed from durable subscription 

========================= activemq sample_3729 =========================

public void testForceBrokerRestart() throws Exception {	brokerService.stop();	brokerService.waitUntilStopped();	brokerService.start(true);	brokerService.waitUntilStarted();	
try and connect to restarted broker 

========================= activemq sample_2587 =========================

protected BrokerService createBroker(String uri) throws Exception {	
loading broker configuration from the classpath with uri 

========================= activemq sample_2303 =========================

int nextCounter = actualCounter;	boolean empty = commands.isEmpty();	if (!empty) {	Command nextAvailable = commands.first();	nextCounter = nextAvailable.getCommandId();	}	try {	boolean keep = replayStrategy.onDroppedPackets(this, expectedCounter, actualCounter, nextCounter);	if (keep) {	if (LOG.isDebugEnabled()) {	
received out of order command which is being buffered for later 

protected void onMissingResponse(Command command, FutureResponse response) {	
still waiting for response on to command sending replay message 

protected void replayCommands(ReplayCommand command) {	try {	if (replayer == null) {	onException(new IOException("Cannot replay commands. No replayer property configured"));	}	if (LOG.isDebugEnabled()) {	
processing replay command 

========================= activemq sample_54 =========================

public void testBrokerConfig() throws Exception {	BrokerService broker;	broker = createBroker("org/apache/activemq/store/mKahaDB.xml");	
Success 

public void testBrokerConfig() throws Exception {	BrokerService broker;	broker = createBroker("org/apache/activemq/store/mKahaDB.xml");	try {	assertEquals("Broker Config Error (brokerName)", "brokerConfigTest", broker.getBrokerName());	assertEquals("Broker Config Error (populateJMSXUserID)", false, broker.isPopulateJMSXUserID());	assertEquals("Broker Config Error (persistent)", true, broker.isPersistent());	
Success 

try {	assertEquals("Broker Config Error (brokerName)", "brokerConfigTest", broker.getBrokerName());	assertEquals("Broker Config Error (populateJMSXUserID)", false, broker.isPopulateJMSXUserID());	assertEquals("Broker Config Error (persistent)", true, broker.isPersistent());	SystemUsage systemUsage = broker.getSystemUsage();	assertTrue("Should have a SystemUsage", systemUsage != null);	assertEquals("SystemUsage Config Error (StoreUsage.limit)", 1 * 1024 * 1024 * 1024, systemUsage.getStoreUsage().getLimit());	assertEquals("SystemUsage Config Error (StoreUsage.name)", "foo", systemUsage.getStoreUsage().getName());	assertNotNull(systemUsage.getStoreUsage().getStore());	assertTrue(systemUsage.getStoreUsage().getStore() instanceof MultiKahaDBPersistenceAdapter);	
Success 

========================= activemq sample_761 =========================

final StringBuffer failureMessage = new StringBuffer();	consumer.setMessageListener(new MessageListener() {	int lowestPrioritySeen = 10;	boolean firstMessage = true;	public void onMessage(Message msg) {	try {	int currentPriority = msg.getJMSPriority();	LOG.debug(currentPriority + "<=" + lowestPrioritySeen);	if (firstMessage == true) {	firstMessage = false;	
ignoring first message since it was prefetched 

========================= activemq sample_2929 =========================

return destA.getDestinationStatistics().getConsumers().getCount() == 1;	}	}));	assertTrue("Should have only one inactive subscription", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return brokerService.getAdminView().getInactiveDurableTopicSubscribers().length == 1;	}	}));	brokerService.stop();	brokerService.waitUntilStopped();	
broker stopped 

assertTrue("Should have only one inactive subscription", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return brokerService.getAdminView().getInactiveDurableTopicSubscribers().length == 1;	}	}));	brokerService.stop();	brokerService.waitUntilStopped();	brokerService = createBroker(false);	brokerService.start();	brokerService.waitUntilStarted();	
broker restarted 

========================= activemq sample_2883 =========================

String destinationName = "AMQ4920Test" + System.currentTimeMillis();	Destination destination = session.createTopic(destinationName);	connection.start();	ExecutorService executor = Executors.newCachedThreadPool();	for (int i = 0; i < CONSUMER_COUNT; i++) {	ConsumerTask consumerTask = new ConsumerTask(initLatch, destinationName, remoteURI, "Consumer-" + i, latch, ITERATIONS);	executor.submit(consumerTask);	}	connection.start();	initLatch.await();	
at start latch is 

Destination destination = session.createTopic(destinationName);	connection.start();	ExecutorService executor = Executors.newCachedThreadPool();	for (int i = 0; i < CONSUMER_COUNT; i++) {	ConsumerTask consumerTask = new ConsumerTask(initLatch, destinationName, remoteURI, "Consumer-" + i, latch, ITERATIONS);	executor.submit(consumerTask);	}	connection.start();	initLatch.await();	sendMessages(connection, destination, ITERATIONS, 10);	
after send latch is 

connection.start();	ExecutorService executor = Executors.newCachedThreadPool();	for (int i = 0; i < CONSUMER_COUNT; i++) {	ConsumerTask consumerTask = new ConsumerTask(initLatch, destinationName, remoteURI, "Consumer-" + i, latch, ITERATIONS);	executor.submit(consumerTask);	}	connection.start();	initLatch.await();	sendMessages(connection, destination, ITERATIONS, 10);	latch.await(15, TimeUnit.SECONDS);	
after await latch is 

public void sendMessages(Connection connection, Destination destination, int count, int sleepInterval) throws Exception {	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	for (int i = 0; i < count; i++) {	TextMessage message = session.createTextMessage();	message.setText(TEXT_MESSAGE + i);	
sending message 

public Boolean call() throws Exception {	
starting 

connection = JMSClientContext.INSTANCE.createConnection(amqpURI, "admin", "admin", false);	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createTopic(destinationName);	MessageConsumer consumer = session.createConsumer(destination);	connection.start();	started.countDown();	int receivedCount = 0;	while (receivedCount < expectedMessageCount) {	Message message = consumer.receive(2000);	if (message == null) {	
consumer got null message on iteration 

MessageConsumer consumer = session.createConsumer(destination);	connection.start();	started.countDown();	int receivedCount = 0;	while (receivedCount < expectedMessageCount) {	Message message = consumer.receive(2000);	if (message == null) {	return false;	}	if (!(message instanceof TextMessage)) {	
consumer expected text message on iteration but got 

while (receivedCount < expectedMessageCount) {	Message message = consumer.receive(2000);	if (message == null) {	return false;	}	if (!(message instanceof TextMessage)) {	return false;	}	TextMessage tm = (TextMessage) message;	if (!tm.getText().equals(TEXT_MESSAGE + receivedCount)) {	
consumer expected got message 

if (message == null) {	return false;	}	if (!(message instanceof TextMessage)) {	return false;	}	TextMessage tm = (TextMessage) message;	if (!tm.getText().equals(TEXT_MESSAGE + receivedCount)) {	return false;	}	
consumer expected got message 

return false;	}	TextMessage tm = (TextMessage) message;	if (!tm.getText().equals(TEXT_MESSAGE + receivedCount)) {	return false;	}	messagesReceived.countDown();	receivedCount++;	}	} catch (Exception e) {	
unexpectedexception in 

========================= activemq sample_1539 =========================

protected void runTask(List<String> tokens) throws Exception {	
connecting to url as user 

protected void runTask(List<String> tokens) throws Exception {	
producing messages to 

protected void runTask(List<String> tokens) throws Exception {	
using persistent non persistent messages 

protected void runTask(List<String> tokens) throws Exception {	
sleeping between sends ms 

protected void runTask(List<String> tokens) throws Exception {	
running parallel threads 

========================= activemq sample_1493 =========================

public abstract byte getDestinationType();	protected abstract void createClient() throws JMSException;	protected void before() throws Throwable {	
starting 

protected void after() {	
stopping 

}	session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	createClient();	} catch (JMSException jmsEx) {	throw new RuntimeException("Producer initialization failed" + this.getClass().getSimpleName(), jmsEx);	}	connection.start();	} catch (JMSException jmsEx) {	throw new IllegalStateException("Producer failed to start", jmsEx);	}	
ready to produce messages to 

public void stop() {	try {	connection.close();	} catch (JMSException jmsEx) {	
exception encountered closing jms connection 

========================= activemq sample_1169 =========================

public void testLongOperationTimesOut() throws Exception {	sendMessages(messageCount);	
produced messages to the broker 

public void testLongOperationTimesOut() throws Exception {	sendMessages(messageCount);	String objectNameStr = broker.getBrokerObjectName().toString();	objectNameStr += ",destinationType=Queue,destinationName="+destinationName;	ObjectName queueViewMBeanName = assertRegisteredObjectName(objectNameStr);	QueueViewMBean proxy = (QueueViewMBean)MBeanServerInvocationHandler.newProxyInstance(mbeanServer, queueViewMBeanName, QueueViewMBean.class, true);	long count = proxy.getQueueSize();	assertEquals("Queue size", count, messageCount);	
attempting to move one message timeoutexception expected 

protected ObjectName assertRegisteredObjectName(String name) throws MalformedObjectNameException, NullPointerException {	ObjectName objectName = new ObjectName(name);	if (mbeanServer.isRegistered(objectName)) {	
bean registered 

========================= activemq sample_2315 =========================

public void start() throws Exception {	super.start();	
broker plugin started 

public void stop() throws Exception {	super.stop();	
broker plugin stopped 

========================= activemq sample_3857 =========================

protected void exerciseVirtualTopic(String prefix, String topic) throws Exception {	ActiveMQConnection connection = new ActiveMQConnectionFactory("vm: connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	ActiveMQMessageConsumer consumer = (ActiveMQMessageConsumer) session.createConsumer(session.createQueue(prefix + topic));	
new consumer for 

protected void exerciseCompositeQueue(String dest, String consumerQ) throws Exception {	ActiveMQConnection connection = new ActiveMQConnectionFactory("vm: connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	ActiveMQMessageConsumer consumer = (ActiveMQMessageConsumer) session.createConsumer(session.createQueue(consumerQ));	
new consumer for 

protected void exerciseFilteredCompositeQueue(String dest, String consumerDestination, String acceptedHeaderValue) throws Exception {	ActiveMQConnection connection = new ActiveMQConnectionFactory("vm: connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	ActiveMQMessageConsumer consumer = (ActiveMQMessageConsumer) session.createConsumer(session.createQueue(consumerDestination));	
new consumer for 

protected Message sendAndReceiveMessage(Session session, ActiveMQMessageConsumer consumer, MessageProducer producer, final String messageBody, Map<String, String> propertiesMap) throws Exception {	TextMessage messageToSend = session.createTextMessage(messageBody);	if (propertiesMap != null) {	for (String headerKey : propertiesMap.keySet()) {	messageToSend.setStringProperty(headerKey, propertiesMap.get(headerKey));	}	}	producer.send(messageToSend);	
sent to 

========================= activemq sample_4384 =========================

public void setResourceAdapter(ResourceAdapter adapter) throws ResourceException {	if (!(adapter instanceof MessageResourceAdapter)) {	throw new ResourceException("ResourceAdapter is not of type: " + MessageResourceAdapter.class.getName());	} else {	if (log.isDebugEnabled()) {	
copying standard resourceadapter configuration properties 

========================= activemq sample_848 =========================

protected Transport createTransport(URI location, WireFormat wf) throws UnknownHostException, IOException {	URI localLocation = null;	String path = location.getPath();	if (path != null && path.length() > 0) {	int localPortIndex = path.indexOf(':');	try {	Integer.parseInt(path.substring(localPortIndex + 1, path.length()));	String localString = location.getScheme() + ":/" + path;	localLocation = new URI(localString);	} catch (Exception e) {	
path isn t a valid local location for tcptransport to use 

========================= activemq sample_2529 =========================

protected Connection createConnection() throws JMSException, NamingException {	InitialContext context = createInitialContext();	
looking up connectionfactory with jndiname 

protected InitialContext createInitialContext() throws NamingException {	if (initialContextFactoryName == null) {	return new InitialContext();	} else {	Hashtable<String, String> env = new Hashtable<String, String>();	env.put(Context.INITIAL_CONTEXT_FACTORY, initialContextFactoryName);	if (providerURL != null) {	env.put(Context.PROVIDER_URL, providerURL);	} else {	
you have set initialcontextfactoryname option but not the providerurl this is likely to cause problems 

} else {	}	if (urlPkgPrefixes != null) {	env.put(Context.URL_PKG_PREFIXES, urlPkgPrefixes);	}	if (securityPrincipalName != null) {	env.put(Context.SECURITY_PRINCIPAL, securityPrincipalName);	if (securityCredentials != null) {	env.put(Context.SECURITY_CREDENTIALS, securityCredentials);	} else {	
you have set securityprincipalname option but not the securitycredentials this is likely to cause problems 

if (urlPkgPrefixes != null) {	env.put(Context.URL_PKG_PREFIXES, urlPkgPrefixes);	}	if (securityPrincipalName != null) {	env.put(Context.SECURITY_PRINCIPAL, securityPrincipalName);	if (securityCredentials != null) {	env.put(Context.SECURITY_CREDENTIALS, securityCredentials);	} else {	}	}	
looking up jndi context with environment 

========================= activemq sample_1240 =========================

}	if (System.getProperty("basedir") == null) {	File file = new File(".");	System.setProperty("basedir", file.getAbsolutePath());	}	broker = createBroker();	broker.setSslContext(sslContext);	String connectorURI = getConnectorURI();	TransportConnector connector = broker.addConnector(connectorURI);	port = connector.getConnectUri().getPort();	
ssl port is 

public void createConnectionFactory(String name) {	try {	
creating a connection factory using port 

========================= activemq sample_1610 =========================

printLockTable(connection);	} catch (Exception e) {	e.printStackTrace();	}	}	});	TimeUnit.SECONDS.sleep(2);	assertTrue("no start", lockedSet.isEmpty());	assertFalse("A is blocked", lockerA.keepAlive());	assertFalse("B is blocked", lockerB.keepAlive());	
releasing phony lock 

});	TimeUnit.SECONDS.sleep(2);	assertTrue("no start", lockedSet.isEmpty());	assertFalse("A is blocked", lockerA.keepAlive());	assertFalse("B is blocked", lockerB.keepAlive());	statement = connection.prepareStatement(jdbc.getStatements().getLeaseUpdateStatement());	statement.setString(1, null);	statement.setLong(2, 0l);	statement.setString(3, fakeId);	assertEquals("we released " + fakeId, 1, statement.executeUpdate());	
released 

========================= activemq sample_3800 =========================

public void testIsStarted() throws Exception {	
testisstarted is starting 

public void testIsStarted() throws Exception {	
adding network connector 

public void testIsStarted() throws Exception {	NetworkConnector nc = localBroker.addNetworkConnector("static:(" + REMOTE_BROKER_TRANSPORT_URI + ")");	nc.setName("NC1");	
starting network connector 

public void testIsStarted() throws Exception {	NetworkConnector nc = localBroker.addNetworkConnector("static:(" + REMOTE_BROKER_TRANSPORT_URI + ")");	nc.setName("NC1");	nc.start();	assertTrue(nc.isStarted());	
stopping network connector 

public void testIsStarted() throws Exception {	NetworkConnector nc = localBroker.addNetworkConnector("static:(" + REMOTE_BROKER_TRANSPORT_URI + ")");	nc.setName("NC1");	nc.start();	assertTrue(nc.isStarted());	nc.stop();	while (nc.isStopping()) {	
still stopping 

NetworkConnector nc = localBroker.addNetworkConnector("static:(" + REMOTE_BROKER_TRANSPORT_URI + ")");	nc.setName("NC1");	nc.start();	assertTrue(nc.isStarted());	nc.stop();	while (nc.isStopping()) {	Thread.sleep(100);	}	assertTrue(nc.isStopped());	assertFalse(nc.isStarted());	
starting network connector 

nc.start();	assertTrue(nc.isStarted());	nc.stop();	while (nc.isStopping()) {	Thread.sleep(100);	}	assertTrue(nc.isStopped());	assertFalse(nc.isStarted());	nc.start();	assertTrue(nc.isStarted());	
stopping network connector 

nc.stop();	while (nc.isStopping()) {	Thread.sleep(100);	}	assertTrue(nc.isStopped());	assertFalse(nc.isStarted());	nc.start();	assertTrue(nc.isStarted());	nc.stop();	while (nc.isStopping()) {	
still stopping 

public void testNetworkConnectionRestart() throws Exception {	
testnetworkconnectionrestart is starting 

public void testNetworkConnectionRestart() throws Exception {	
adding network connector 

public void testNetworkConnectionRestart() throws Exception {	NetworkConnector nc = localBroker.addNetworkConnector("static:(" + REMOTE_BROKER_TRANSPORT_URI + ")");	nc.setName("NC1");	nc.start();	assertTrue(nc.isStarted());	
setting up message producer and consumer 

localConnection.start();	Session localSession = localConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer localProducer = localSession.createProducer(destination);	ActiveMQConnectionFactory remoteFactory = new ActiveMQConnectionFactory(REMOTE_BROKER_TRANSPORT_URI);	Connection remoteConnection = remoteFactory.createConnection();	remoteConnection.start();	Session remoteSession = remoteConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer remoteConsumer = remoteSession.createConsumer(destination);	Message message = localSession.createTextMessage("test");	localProducer.send(message);	
testing initial network connection 

MessageProducer localProducer = localSession.createProducer(destination);	ActiveMQConnectionFactory remoteFactory = new ActiveMQConnectionFactory(REMOTE_BROKER_TRANSPORT_URI);	Connection remoteConnection = remoteFactory.createConnection();	remoteConnection.start();	Session remoteSession = remoteConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer remoteConsumer = remoteSession.createConsumer(destination);	Message message = localSession.createTextMessage("test");	localProducer.send(message);	message = remoteConsumer.receive(10000);	assertNotNull(message);	
stopping network connection 

Connection remoteConnection = remoteFactory.createConnection();	remoteConnection.start();	Session remoteSession = remoteConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer remoteConsumer = remoteSession.createConsumer(destination);	Message message = localSession.createTextMessage("test");	localProducer.send(message);	message = remoteConsumer.receive(10000);	assertNotNull(message);	nc.stop();	assertFalse(nc.isStarted());	
sending message 

Message message = localSession.createTextMessage("test");	localProducer.send(message);	message = remoteConsumer.receive(10000);	assertNotNull(message);	nc.stop();	assertFalse(nc.isStarted());	message = localSession.createTextMessage("test stop");	localProducer.send(message);	message = remoteConsumer.receive(1000);	assertNull("Message should not have been delivered since NetworkConnector was stopped", message);	
re starting network connection 

message = remoteConsumer.receive(10000);	assertNotNull(message);	nc.stop();	assertFalse(nc.isStarted());	message = localSession.createTextMessage("test stop");	localProducer.send(message);	message = remoteConsumer.receive(1000);	assertNull("Message should not have been delivered since NetworkConnector was stopped", message);	nc.start();	assertTrue(nc.isStarted());	
wait for message to get forwarded and received 

public void testNetworkConnectionReAddURI() throws Exception {	
testnetworkconnectionreadduri is starting 

public void testNetworkConnectionReAddURI() throws Exception {	
adding network connector 

public void testNetworkConnectionReAddURI() throws Exception {	NetworkConnector nc = localBroker.addNetworkConnector("static:(" + REMOTE_BROKER_TRANSPORT_URI + ")");	nc.setName("NC1");	nc.start();	assertTrue(nc.isStarted());	
looking up network connector by name 

public void testNetworkConnectionReAddURI() throws Exception {	NetworkConnector nc = localBroker.addNetworkConnector("static:(" + REMOTE_BROKER_TRANSPORT_URI + ")");	nc.setName("NC1");	nc.start();	assertTrue(nc.isStarted());	NetworkConnector nc1 = localBroker.getNetworkConnectorByName("NC1");	assertNotNull("Should find network connector 'NC1'", nc1);	assertTrue(nc1.isStarted());	assertEquals(nc, nc1);	
setting up producer and consumer 

localConnection.start();	Session localSession = localConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer localProducer = localSession.createProducer(destination);	ActiveMQConnectionFactory remoteFactory = new ActiveMQConnectionFactory(REMOTE_BROKER_TRANSPORT_URI);	Connection remoteConnection = remoteFactory.createConnection();	remoteConnection.start();	Session remoteSession = remoteConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer remoteConsumer = remoteSession.createConsumer(destination);	Message message = localSession.createTextMessage("test");	localProducer.send(message);	
testing initial network connection 

MessageProducer localProducer = localSession.createProducer(destination);	ActiveMQConnectionFactory remoteFactory = new ActiveMQConnectionFactory(REMOTE_BROKER_TRANSPORT_URI);	Connection remoteConnection = remoteFactory.createConnection();	remoteConnection.start();	Session remoteSession = remoteConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer remoteConsumer = remoteSession.createConsumer(destination);	Message message = localSession.createTextMessage("test");	localProducer.send(message);	message = remoteConsumer.receive(10000);	assertNotNull(message);	
stopping network connector 

Connection remoteConnection = remoteFactory.createConnection();	remoteConnection.start();	Session remoteSession = remoteConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer remoteConsumer = remoteSession.createConsumer(destination);	Message message = localSession.createTextMessage("test");	localProducer.send(message);	message = remoteConsumer.receive(10000);	assertNotNull(message);	nc.stop();	assertFalse(nc.isStarted());	
removing network connector 

MessageConsumer remoteConsumer = remoteSession.createConsumer(destination);	Message message = localSession.createTextMessage("test");	localProducer.send(message);	message = remoteConsumer.receive(10000);	assertNotNull(message);	nc.stop();	assertFalse(nc.isStarted());	assertTrue(localBroker.removeNetworkConnector(nc));	nc1 = localBroker.getNetworkConnectorByName("NC1");	assertNull("Should not find network connector 'NC1'", nc1);	
re adding network connector 

assertNotNull(message);	nc.stop();	assertFalse(nc.isStarted());	assertTrue(localBroker.removeNetworkConnector(nc));	nc1 = localBroker.getNetworkConnectorByName("NC1");	assertNull("Should not find network connector 'NC1'", nc1);	nc = localBroker.addNetworkConnector("static:(" + REMOTE_BROKER_TRANSPORT_URI + ")");	nc.setName("NC2");	nc.start();	assertTrue(nc.isStarted());	
looking up network connector by name 

nc1 = localBroker.getNetworkConnectorByName("NC1");	assertNull("Should not find network connector 'NC1'", nc1);	nc = localBroker.addNetworkConnector("static:(" + REMOTE_BROKER_TRANSPORT_URI + ")");	nc.setName("NC2");	nc.start();	assertTrue(nc.isStarted());	NetworkConnector nc2 = localBroker.getNetworkConnectorByName("NC2");	assertNotNull(nc2);	assertTrue(nc2.isStarted());	assertEquals(nc, nc2);	
testing re added network connection 

nc.start();	assertTrue(nc.isStarted());	NetworkConnector nc2 = localBroker.getNetworkConnectorByName("NC2");	assertNotNull(nc2);	assertTrue(nc2.isStarted());	assertEquals(nc, nc2);	message = localSession.createTextMessage("test");	localProducer.send(message);	message = remoteConsumer.receive(10000);	assertNotNull(message);	
stopping network connector 

NetworkConnector nc2 = localBroker.getNetworkConnectorByName("NC2");	assertNotNull(nc2);	assertTrue(nc2.isStarted());	assertEquals(nc, nc2);	message = localSession.createTextMessage("test");	localProducer.send(message);	message = remoteConsumer.receive(10000);	assertNotNull(message);	nc.stop();	assertFalse(nc.isStarted());	
removing network connection 

protected void setUp() throws Exception {	
setting up localbroker 

protected void setUp() throws Exception {	localBroker = new BrokerService();	localBroker.setBrokerName("LocalBroker");	localBroker.setUseJmx(false);	localBroker.setPersistent(false);	localBroker.setTransportConnectorURIs(new String[]{LOCAL_BROKER_TRANSPORT_URI});	localBroker.start();	localBroker.waitUntilStarted();	
setting up remotebroker 

protected void tearDown() throws Exception {	if (localBroker.isStarted()) {	
stopping localbroker 

protected void tearDown() throws Exception {	if (localBroker.isStarted()) {	localBroker.stop();	localBroker.waitUntilStopped();	localBroker = null;	}	if (remoteBroker.isStarted()) {	
stopping remotebroker 

========================= activemq sample_2712 =========================

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createConsumer(destination);	final CountDownLatch latch = new CountDownLatch(COUNT);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	count.incrementAndGet();	latch.countDown();	assertTrue(message instanceof TextMessage);	TextMessage tm = (TextMessage) message;	try {	
received count 

MessageConsumer consumer = session.createConsumer(destination);	final CountDownLatch latch = new CountDownLatch(COUNT);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	count.incrementAndGet();	latch.countDown();	assertTrue(message instanceof TextMessage);	TextMessage tm = (TextMessage) message;	try {	} catch (JMSException e) {	
unexpected exception in onmessage 

fail("Unexpected exception in onMessage: " + e.getMessage());	}	}	});	connection.start();	for (int i = 0; i < COUNT; i++) {	MessageProducer producer = session.createProducer(destination);	TextMessage message = session.createTextMessage("test msg "+ i);	message.setStringProperty(ScheduledMessage.AMQ_SCHEDULED_CRON, "* * * * *");	producer.send(message);	
message sent at 

========================= activemq sample_2342 =========================

}	headers.put("JMSCorrelationID", correlationID);	headers.put("JMSType", messageType);	headers.put("JMSXGroupID", groupID);	template.sendBodyAndHeaders("activemq:test.a", expectedBody, headers);	resultEndpoint.assertIsSatisfied();	List<Exchange> list = resultEndpoint.getReceivedExchanges();	Exchange exchange = list.get(0);	Message in = exchange.getIn();	Object replyTo = in.getHeader("JMSReplyTo");	
reply to is 

========================= activemq sample_1352 =========================

private int getMaxPrefetchLimit(int value) {	int result = Math.min(value, MAX_PREFETCH_SIZE);	if (result < value) {	
maximum prefetch limit has been reset from to 

========================= activemq sample_235 =========================

public void assertAuthentication(JMXConnector connector) throws Exception {	connector.connect();	MBeanServerConnection connection = connector.getMBeanServerConnection();	ObjectName name = new ObjectName("test.domain:type=Broker,brokerName=localhost");	BrokerViewMBean mbean = MBeanServerInvocationHandler .newProxyInstance(connection, name, BrokerViewMBean.class, true);	
broker 

========================= activemq sample_2591 =========================

if (messagesSent.get() == 50) {	try {	broker.getAdminView().removeTopic(destination.getTopicName());	} catch (Exception e1) {	fail("Unable to remove destination:" + destination.getPhysicalName());	}	}	try {	producer.send(producerSession.createTextMessage());	int val = messagesSent.incrementAndGet();	
sent message 

public void onMessage(Message message) {	try {	message.acknowledge();	int val = messagesReceived.incrementAndGet();	
received message 

========================= activemq sample_2968 =========================

StringBuilder connectorURI = new StringBuilder();	connectorURI.append(getProtocolScheme());	connectorURI.append(": String protocolConfig = getProtocolConfig();	if (protocolConfig != null && !protocolConfig.isEmpty()) {	connectorURI.append("?").append(protocolConfig);	}	TransportConnector connector = new TransportConnector();	connector.setUri(new URI(connectorURI.toString()));	connector.setName("mqtt");	brokerService.addConnector(connector);	
added connector to broker 

protected Tracer createTracer() {	return new Tracer() {	public void onReceive(MQTTFrame frame) {	
client received 

protected Tracer createTracer() {	return new Tracer() {	public void onReceive(MQTTFrame frame) {	}	public void onSend(MQTTFrame frame) {	
client sent 

========================= activemq sample_864 =========================

public void testBlockedProducerConnectionTimeout() throws Exception {	final ActiveMQConnection cx = (ActiveMQConnection)createConnection();	final ActiveMQDestination queue = createDestination("testqueue");	cx.setSendTimeout(10000);	Runnable r = new Runnable() {	public void run() {	try {	
sender thread starting 

Runnable r = new Runnable() {	public void run() {	try {	Session session = cx.createSession(false, 1);	MessageProducer producer = session.createProducer(queue);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	TextMessage message = session.createTextMessage(createMessageText());	for(int count=0; count<messageCount; count++){	producer.send(message);	}	
done sending 

public void testBlockedProducerUsageSendFailTimeout() throws Exception {	final ActiveMQConnection cx = (ActiveMQConnection)createConnection();	final ActiveMQDestination queue = createDestination("testqueue");	broker.getSystemUsage().setSendFailIfNoSpaceAfterTimeout(5000);	Runnable r = new Runnable() {	public void run() {	try {	
sender thread starting 

Runnable r = new Runnable() {	public void run() {	try {	Session session = cx.createSession(false, 1);	MessageProducer producer = session.createProducer(queue);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	TextMessage message = session.createTextMessage(createMessageText());	for(int count=0; count<messageCount; count++){	producer.send(message);	}	
done sending 

========================= activemq sample_2786 =========================

private void sendMessage() {	try {	producer.send(session.createTextMessage("Test"));	long i = size.incrementAndGet();	if( (i % 1000) == 0 ) {	
produced 

public void start() {	
starting jms listener 

started.countDown();	while( !done.get() ) {	Message msg = consumer.receive(100);	if(msg!=null ) {	size.incrementAndGet();	session.commit();	}	}	} finally {	connection.close();	
stopped jms listener 

public void testAMQ4351() throws InterruptedException, JMSException {	
start test 

listener1.start();	listener2.start();	listener3.start();	List<ConsumingClient> subscribers = new ArrayList<ConsumingClient>(subs);	for (int i = 4; i < subs; i++) {	ConsumingClient client = new ConsumingClient("subscriber-" + i, startedLatch, shutdownLatch);	subscribers.add(client);	client.start();	}	startedLatch.await(10, TimeUnit.SECONDS);	
all subscribers started 

listener2.start();	listener3.start();	List<ConsumingClient> subscribers = new ArrayList<ConsumingClient>(subs);	for (int i = 4; i < subs; i++) {	ConsumingClient client = new ConsumingClient("subscriber-" + i, startedLatch, shutdownLatch);	subscribers.add(client);	client.start();	}	startedLatch.await(10, TimeUnit.SECONDS);	producer.sendMessage();	
stopping subscribers 

ConsumingClient client = new ConsumingClient("subscriber-" + i, startedLatch, shutdownLatch);	subscribers.add(client);	client.start();	}	startedLatch.await(10, TimeUnit.SECONDS);	producer.sendMessage();	for (ConsumingClient client : subscribers) {	client.stopAsync();	}	shutdownLatch.await(10, TimeUnit.SECONDS);	
starting mass message producer 

producer.sendMessage();	for (ConsumingClient client : subscribers) {	client.stopAsync();	}	shutdownLatch.await(10, TimeUnit.SECONDS);	producer.start();	long lastSize = listener1.size.get();	for( int i=0 ; i < 10; i++ ) {	Thread.sleep(1000);	long size = listener1.size.get();	
listener consumed 

shutdownLatch.await(10, TimeUnit.SECONDS);	producer.start();	long lastSize = listener1.size.get();	for( int i=0 ; i < 10; i++ ) {	Thread.sleep(1000);	long size = listener1.size.get();	assertTrue( size > lastSize );	lastSize = size;	}	} finally {	
stopping clients 

========================= activemq sample_2293 =========================

consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	latch.countDown();	}	});	MessageConsumer browser = session.createConsumer(browseDest);	final CountDownLatch browsedLatch = new CountDownLatch(COUNT);	browser.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	browsedLatch.countDown();	
scheduled message browser got message 

consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	latch.countDown();	}	});	MessageConsumer browser = session.createConsumer(browseDest);	final CountDownLatch browsedLatch = new CountDownLatch(COUNT);	browser.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	browsedLatch.countDown();	
scheduled message browser got message 

consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	latch.countDown();	}	});	MessageConsumer browser = session.createConsumer(browseDest);	final CountDownLatch browsedLatch = new CountDownLatch(COUNT);	browser.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	browsedLatch.countDown();	
scheduled message browser got message 

========================= activemq sample_2339 =========================

public void testUseURIToSetUseClientIDPrefixOnConnectionFactory() throws URISyntaxException, JMSException {	ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory( "vm: assertEquals("Cheese", cf.getClientIDPrefix());	connection = (ActiveMQConnection)cf.createConnection();	connection.start();	String clientID = connection.getClientID();	
got client id 

public void testGetBrokerName() throws URISyntaxException, JMSException {	ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory( "vm: connection = (ActiveMQConnection)cf.createConnection();	connection.start();	String brokerName = connection.getBrokerName();	
got broker name 

broker = new BrokerService();	broker.setPersistent(false);	broker.setUseJmx(false);	broker.setAdvisorySupport(false);	broker.setSchedulerSupport(false);	TransportConnector connector = broker.addConnector(uri);	broker.start();	URI temp = new URI(uri);	URI currentURI = new URI(connector.getPublishableConnectString());	URI connectURI = new URI(temp.getScheme(), temp.getUserInfo(), temp.getHost(), currentURI.getPort(), temp.getPath(), temp.getQuery(), temp.getFragment());	
connection uri is 

========================= activemq sample_3482 =========================

private void assertDeqInflight(final int dequeue, final int inflight) throws Exception {	assertTrue("deq and inflight as expected", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	RegionBroker regionBroker = (RegionBroker) brokers.get("A").broker.getRegionBroker();	
a deq 

private void assertDeqInflight(final int dequeue, final int inflight) throws Exception {	assertTrue("deq and inflight as expected", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	RegionBroker regionBroker = (RegionBroker) brokers.get("A").broker.getRegionBroker();	
a inflight 

startAllBrokers();	verifyPeerBrokerInfo(brokers.get("A"), 1);	verifyPeerBrokerInfo(brokers.get("B"), 1);	MessageConsumer consumerB = createConsumer("B", advisoryQueue);	createConsumer("A", new ActiveMQTopic("FOO"));	MessageIdList messagesB = getConsumerMessages("B", consumerB);	messagesB.waitForMessagesToArrive(2);	assertTrue("deq and inflight as expected", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	RegionBroker regionBroker = (RegionBroker) brokers.get("A").broker.getRegionBroker();	
a deq 

startAllBrokers();	verifyPeerBrokerInfo(brokers.get("A"), 1);	verifyPeerBrokerInfo(brokers.get("B"), 1);	MessageConsumer consumerB = createConsumer("B", advisoryQueue);	createConsumer("A", new ActiveMQTopic("FOO"));	MessageIdList messagesB = getConsumerMessages("B", consumerB);	messagesB.waitForMessagesToArrive(2);	assertTrue("deq and inflight as expected", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	RegionBroker regionBroker = (RegionBroker) brokers.get("A").broker.getRegionBroker();	
a inflight 

private void verifyPeerBrokerInfo(BrokerItem brokerItem, final int max) throws Exception {	final BrokerService broker = brokerItem.broker;	final RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
verify infos len 

private void verifyPeerBrokerInfo(BrokerItem brokerItem, final int max) throws Exception {	final BrokerService broker = brokerItem.broker;	final RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return max == regionBroker.getPeerBrokerInfos().length;	}	}, 120 * 1000);	
verify infos len 

========================= activemq sample_3601 =========================

public void testMBeanPresenceOnRestart() throws Exception {	createBroker(true);	sendMessages();	verifyPresenceOfQueueMbean();	
restart 

private void verifyPresenceOfQueueMbean() throws Exception {	for (ObjectName name : broker.getManagementContext().queryNames(null, null)) {	
candidate 

private void verifyPresenceOfQueueMbean() throws Exception {	for (ObjectName name : broker.getManagementContext().queryNames(null, null)) {	String type = name.getKeyProperty("destinationType");	if (type != null && type.equals("Queue")) {	assertEquals( JMXSupport.encodeObjectNamePart(((ActiveMQQueue) createDestination()).getPhysicalName()), name.getKeyProperty("destinationName"));	
found mbbean 

========================= activemq sample_2381 =========================

Connection c = connectionFactory.createConnection();	c.start();	Session listenerSession = c.createSession(false, 1);	Destination destination = createDestination(listenerSession);	listenerSession.createConsumer(destination).setMessageListener(new TopicProducerFlowControlTest());	final AtomicInteger blockedCounter = new AtomicInteger(0);	listenerSession.createConsumer(new ActiveMQTopic(AdvisorySupport.FULL_TOPIC_PREFIX + ">")).setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	if (blockedCounter.get() % 100 == 0) {	
got full advisory usagename usagecount blockedcounter 

listenerSession.createConsumer(destination).setMessageListener(new TopicProducerFlowControlTest());	final AtomicInteger blockedCounter = new AtomicInteger(0);	listenerSession.createConsumer(new ActiveMQTopic(AdvisorySupport.FULL_TOPIC_PREFIX + ">")).setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	if (blockedCounter.get() % 100 == 0) {	}	blockedCounter.incrementAndGet();	} catch (Exception error) {	error.printStackTrace();	
missing advisory property 

blockedCounter.incrementAndGet();	} catch (Exception error) {	error.printStackTrace();	}	}	});	final AtomicInteger warnings = new AtomicInteger();	Appender appender = new DefaultTestAppender() {	public void doAppend(LoggingEvent event) {	if (event.getLevel().equals(Level.INFO) && event.getMessage().toString().contains("Usage Manager memory limit reached")) {	
received log message 

try {	final Session session = connectionFactory.createConnection().createSession(false, Session.AUTO_ACKNOWLEDGE);	final MessageProducer producer = session.createProducer(destination);	Thread producingThread = new Thread("Producing Thread") {	public void run() {	try {	for (long i = 0; i < numMessagesToSend; i++) {	producer.send(session.createTextMessage("test"));	long count = produced.incrementAndGet();	if (count % 10000 == 0) {	
produced messages 

return consumed.get() == numMessagesToSend;	}	}, 5 * 60 * 1000);	assertEquals("Didn't produce all messages", numMessagesToSend, produced.get());	assertEquals("Didn't consume all messages", numMessagesToSend, consumed.get());	assertTrue("Producer got blocked", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return blockedCounter.get() > 0;	}	}, 5 * 1000));	
blockedcount warnings 

public void onMessage(Message message) {	long count = consumed.incrementAndGet();	if (count % 100 == 0) {	try {	Thread.sleep(100);	} catch (InterruptedException e) {	}	}	if (count % 10000 == 0) {	
tconsumed messages 

========================= activemq sample_3590 =========================

protected void tearDown() throws Exception {	
shutting down broker 

session = null;	if (connection != null) {	connection.close();	}	connection = null;	if (broker != null) {	broker.stop();	broker.waitUntilStopped();	}	broker = null;	
broker shut down 

========================= activemq sample_4310 =========================

if (value instanceof EnhancedConnection) {	connection = (EnhancedConnection) value;	} else {	throw new IllegalArgumentException("Created JMS Connection is not an EnhancedConnection: " + value);	}	connection.start();	}	source = connection.getDestinationSource();	}	} catch (Throwable t) {	
can t get destination source endpoint completer will not work 

========================= activemq sample_1391 =========================

public void testPriorityMessages() throws Exception {	for (int i = 0; i < ITERATIONS; i++) {	produceMessages(4, 4, "TestQ");	produceMessages(1, 5, "TestQ");	
on iteration 

public void testPriorityMessages() throws Exception {	for (int i = 0; i < ITERATIONS; i++) {	produceMessages(4, 4, "TestQ");	produceMessages(1, 5, "TestQ");	Thread.sleep(500);	ArrayList<Message> consumeList = consumeMessages("TestQ");	
consumed list 

public void testPriorityMessagesMoreThanPageSize() throws Exception {	final int numToSend = 450;	for (int i = 0; i < ITERATIONS; i++) {	produceMessages(numToSend - 1, 4, "TestQ");	Thread.sleep(700);	produceMessages(1, 5, "TestQ");	Thread.sleep(500);	
on iteration 

public void testPriorityMessagesMoreThanPageSize() throws Exception {	final int numToSend = 450;	for (int i = 0; i < ITERATIONS; i++) {	produceMessages(numToSend - 1, 4, "TestQ");	Thread.sleep(700);	produceMessages(1, 5, "TestQ");	Thread.sleep(500);	ArrayList<Message> consumeList = consumeMessages("TestQ");	
consumed list 

for (int i = 0; i < ITERATIONS; i++) {	produceMessages(numToSend - 1, 4, "TestQ");	produceMessages(1, 5, "TestQ");	Message message = consumer.receive(4000);	assertEquals("message should be priority high", 5, message.getJMSPriority());	}	} finally {	connection.close();	}	ArrayList<Message> consumeList = consumeMessages("TestQ");	
consumed list 

public void testPriorityMessagesWithJmsBrowser() throws Exception {	final int numToSend = 250;	for (int i = 0; i < ITERATIONS; i++) {	produceMessages(numToSend - 1, 4, "TestQ");	ArrayList<Message> browsed = browseMessages("TestQ");	
browsed 

public void testPriorityMessagesWithJmsBrowser() throws Exception {	final int numToSend = 250;	for (int i = 0; i < ITERATIONS; i++) {	produceMessages(numToSend - 1, 4, "TestQ");	ArrayList<Message> browsed = browseMessages("TestQ");	produceMessages(1, 5, "TestQ");	Thread.sleep(500);	
on iteration 

final int numToSend = 250;	for (int i = 0; i < ITERATIONS; i++) {	produceMessages(numToSend - 1, 4, "TestQ");	ArrayList<Message> browsed = browseMessages("TestQ");	produceMessages(1, 5, "TestQ");	Thread.sleep(500);	Message message = consumeOneMessage("TestQ");	assertNotNull(message);	assertEquals(5, message.getJMSPriority());	ArrayList<Message> consumeList = consumeMessages("TestQ");	
consumed list 

public void testJmsBrowserGetsPagedIn() throws Exception {	final int numToSend = 10;	for (int i = 0; i < ITERATIONS; i++) {	produceMessages(numToSend, 4, "TestQ");	ArrayList<Message> browsed = browseMessages("TestQ");	
browsed 

public void testJmsBrowserGetsPagedIn() throws Exception {	final int numToSend = 10;	for (int i = 0; i < ITERATIONS; i++) {	produceMessages(numToSend, 4, "TestQ");	ArrayList<Message> browsed = browseMessages("TestQ");	assertEquals(0, browsed.size());	Message message = consumeOneMessage("TestQ", Session.CLIENT_ACKNOWLEDGE);	assertNotNull(message);	browsed = browseMessages("TestQ");	
browsed 

final int numToSend = 10;	for (int i = 0; i < ITERATIONS; i++) {	produceMessages(numToSend, 4, "TestQ");	ArrayList<Message> browsed = browseMessages("TestQ");	assertEquals(0, browsed.size());	Message message = consumeOneMessage("TestQ", Session.CLIENT_ACKNOWLEDGE);	assertNotNull(message);	browsed = browseMessages("TestQ");	assertEquals("see only the paged in for pull", 1, browsed.size());	ArrayList<Message> consumeList = consumeMessages("TestQ");	
consumed list 

========================= activemq sample_3656 =========================

public void handle(IOException exception) {	if (!broker.isStarted() || ignoreAllErrors) {	allowIOResumption();	
ignoring io exception 

public void handle(IOException exception) {	if (!broker.isStarted() || ignoreAllErrors) {	allowIOResumption();	return;	}	if (ignoreNoSpaceErrors) {	Throwable cause = exception;	while (cause != null && cause instanceof IOException) {	String message = cause.getMessage();	if (message != null && message.contains(noSpaceMessage)) {	
ignoring no space left exception 

}	if (ignoreSQLExceptions) {	Throwable cause = exception;	while (cause != null) {	if (cause instanceof SQLException) {	String message = cause.getMessage();	if (message == null) {	message = "";	}	if (message.contains(sqlExceptionMessage)) {	
ignoring sqlexception 

}	if (message.contains(sqlExceptionMessage)) {	return;	}	}	cause = cause.getCause();	}	}	if (stopStartConnectors) {	if (handlingException.compareAndSet(false, true)) {	
initiating stop restart of transports on due to io exception 

cause = cause.getCause();	}	}	if (stopStartConnectors) {	if (handlingException.compareAndSet(false, true)) {	new Thread("IOExceptionHandler: stop transports") {	public void run() {	try {	ServiceStopper stopper = new ServiceStopper();	broker.stopAllConnectors(stopper);	
successfully stopped transports on 

}	}	if (stopStartConnectors) {	if (handlingException.compareAndSet(false, true)) {	new Thread("IOExceptionHandler: stop transports") {	public void run() {	try {	ServiceStopper stopper = new ServiceStopper();	broker.stopAllConnectors(stopper);	} catch (Exception e) {	
failure occurred while stopping broker connectors 

try {	ServiceStopper stopper = new ServiceStopper();	broker.stopAllConnectors(stopper);	} catch (Exception e) {	} finally {	new Thread("IOExceptionHandler: restart transports") {	public void run() {	try {	allowIOResumption();	while (hasLockOwnership() && isPersistenceAdapterDown()) {	
waiting for broker persistence adapter checkpoint to succeed before restarting transports 

Map<ActiveMQDestination, Destination> destinations = ((RegionBroker)broker.getRegionBroker()).getDestinationMap();	for (Destination destination : destinations.values()) {	if (destination instanceof Queue) {	Queue queue = (Queue)destination;	if (queue.isResetNeeded()) {	queue.clearPendingMessages();	}	}	}	broker.startAllConnectors();	
successfully restarted transports on 

if (destination instanceof Queue) {	Queue queue = (Queue)destination;	if (queue.isResetNeeded()) {	queue.clearPendingMessages();	}	}	}	broker.startAllConnectors();	}	} catch (Exception e) {	
stopping due to failure restarting transports 

protected void allowIOResumption() {	try {	if (broker.getPersistenceAdapter() != null) {	broker.getPersistenceAdapter().allowIOResumption();	}	} catch (IOException e) {	
failed to allow io resumption 

private void stopBroker(Exception exception) {	
stopping due to exception 

private void stopBroker(Exception exception) {	new Thread("IOExceptionHandler: stopping " + broker) {	public void run() {	try {	if( broker.isRestartAllowed() ) {	broker.requestRestart();	}	broker.setSystemExitOnShutdown(isSystemExitOnShutdown());	broker.stop();	} catch (Exception e) {	
failure occurred while stopping broker 

========================= activemq sample_4193 =========================

ExecutorService executorService = Executors.newFixedThreadPool(NUMBER_OF_PRODUCERS);	QueueView queueView = getQueueView(broker, DESTINATION_ONE);	try {	for (int i = 0; i < NUMBER_OF_PRODUCERS; i++) {	executorService.submit(new ProducerTask());	}	waitForProducerFlowControl(broker, queueView);	try {	sendMessages(1, DESTINATION_TWO, false);	} catch (Exception ex) {	
ex on send new connection 

QueueView queueView = getQueueView(broker, DESTINATION_ONE);	try {	for (int i = 0; i < NUMBER_OF_PRODUCERS; i++) {	executorService.submit(new ProducerTask());	}	waitForProducerFlowControl(broker, queueView);	assertTrue("Producer view blocked", getProducerView(broker, DESTINATION_ONE).isProducerBlocked());	try {	Session producerSession = exisitngConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	} catch (Exception ex) {	
ex on create session 

private void waitForProducerFlowControl(BrokerService broker, QueueView queueView) throws Exception {	boolean blockingAllSends;	do {	blockingAllSends = queueView.getBlockedSends() >= 10;	
blocking all sends 

}	connection.start();	try {	Session producerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer jmsProducer = producerSession.createProducer(producerSession.createQueue(destination));	Message sendMessage = createTextMessage(producerSession);	for (int i = 0; i < messageCount; i++) {	jmsProducer.send(sendMessage);	numberOfMessageSent++;	}	
finished after producing 

try {	Session producerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer jmsProducer = producerSession.createProducer(producerSession.createQueue(destination));	Message sendMessage = createTextMessage(producerSession);	for (int i = 0; i < messageCount; i++) {	jmsProducer.send(sendMessage);	numberOfMessageSent++;	}	return numberOfMessageSent;	} catch (JMSException expected) {	
exception received producing 

private ProducerViewMBean getProducerView(BrokerService broker, String qName) throws Exception {	ObjectName[] qProducers = broker.getAdminView().getQueueProducers();	for (ObjectName name : qProducers) {	ProducerViewMBean proxy = (ProducerViewMBean) broker.getManagementContext() .newProxyInstance(name, ProducerViewMBean.class, true);	
dest blocked 

========================= activemq sample_2552 =========================

public void waitForCompletion() {	if (dispatched.get() > 0) {	
waiting for completion for sub dispatched 

if (dispatched.get() > 0) {	activeWaiter.set(true);	if (dispatched.get() > 0) {	synchronized (activeWaiter) {	try {	activeWaiter.wait(TimeUnit.SECONDS.toMillis(30));	} catch (InterruptedException ignored) {	}	}	if (this.dispatched.get() > 0) {	
demand sub interrupted or timedout while waiting for outstanding responses expect potentially duplicate forwards 

========================= activemq sample_4243 =========================

public synchronized void onMessage(Message message) {	try {	Message msgCopy = (Message)((org.apache.activemq.command.Message)message).copy();	replyProducer.send(msgCopy);	super.onMessage(message);	} catch (JMSException e) {	
failed to send message 

protected void setUp() throws Exception {	super.setUp();	Destination replyDestination = null;	if (topic) {	replyDestination = receiveSession.createTopic("REPLY." + getSubject());	} else {	replyDestination = receiveSession.createQueue("REPLY." + getSubject());	}	replyProducer = receiveSession.createProducer(replyDestination);	
created replyproducer 

========================= activemq sample_3586 =========================

} catch (Exception e) {	e.printStackTrace();	}	}	});	}	executor.shutdown();	executor.awaitTermination(5, TimeUnit.MINUTES);	long endTime = System.currentTimeMillis();	long seconds = (endTime - startTime) / 1000;	
for numthreads duration 

e.printStackTrace();	}	}	});	}	executor.shutdown();	executor.awaitTermination(5, TimeUnit.MINUTES);	long endTime = System.currentTimeMillis();	long seconds = (endTime - startTime) / 1000;	results.put(numThreads, seconds);	
broker got messages 

});	}	executor.shutdown();	executor.awaitTermination(5, TimeUnit.MINUTES);	long endTime = System.currentTimeMillis();	long seconds = (endTime - startTime) / 1000;	results.put(numThreads, seconds);	}	brokerService.stop();	brokerService.waitUntilStopped();	
results 

public void testPerf() throws Exception {	LinkedHashMap<Integer, Long> resultsT = new LinkedHashMap<Integer, Long>();	LinkedHashMap<Integer, Long> resultsF = new LinkedHashMap<Integer, Long>();	for (int i=2;i<11;i++) {	for (Boolean concurrent : new Boolean[]{true, false}) {	startBroker(i, concurrent, false);	long startTime = System.currentTimeMillis();	produceMessages(new AtomicLong(messageCount), target);	long endTime = System.currentTimeMillis();	long seconds = (endTime - startTime) / 1000;	
for routes duration 

long seconds = (endTime - startTime) / 1000;	if (concurrent) {	resultsT.put(i, seconds);	} else {	resultsF.put(i, seconds);	}	brokerService.stop();	brokerService.waitUntilStopped();	}	}	
results t f 

========================= activemq sample_2397 =========================

protected void setUp() throws Exception {	LOG.info("===============================================================================");	
running test case 

========================= activemq sample_2728 =========================

underTest.addMessageLast(msg);	}	assertTrue("cache is disabled as limit reached", !underTest.isCacheEnabled());	int dequeueCount = 0;	underTest.setMaxBatchSize(2);	underTest.reset();	while (underTest.hasNext() && dequeueCount < count) {	MessageReference ref = underTest.next();	ref.decrementReferenceCount();	underTest.remove();	
received message with body 

========================= activemq sample_2378 =========================

protected void stopBroker() {	try {	if (broker != null) {	broker.stop();	broker.waitUntilStopped();	broker = null;	}	} catch (Exception e) {	
error during broker stop 

========================= activemq sample_1104 =========================

public void testHanging() throws Exception {	registerDurableSubscription();	produceExpiredAndOneNonExpiredMessages();	TimeUnit.SECONDS.sleep(10);	Message message = collectMessagesFromDurableSubscriptionForOneMinute();	
got message 

TopicSession session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);	Topic topic = session.createTopic(topicName);	MessageProducer producer = session.createProducer(topic);	producer.setTimeToLive(TimeUnit.SECONDS.toMillis(1));	for(int i=0; i<40000; i++) {	sendRandomMessage(session, producer);	}	producer.setTimeToLive(TimeUnit.DAYS.toMillis(1));	sendRandomMessage(session, producer);	connection.close();	
produceexpiredandonenonexpiredmessages done 

private void registerDurableSubscription() throws JMSException {	ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("vm: TopicConnection connection = connectionFactory.createTopicConnection();	connection.setClientID(clientID);	TopicSession topicSession = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);	Topic topic = topicSession.createTopic(topicName);	TopicSubscriber durableSubscriber = topicSession.createDurableSubscriber(topic, durableSubName);	connection.start();	durableSubscriber.close();	connection.close();	
durable sub registered 

private Message collectMessagesFromDurableSubscriptionForOneMinute() throws Exception {	ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("vm: TopicConnection connection = connectionFactory.createTopicConnection();	connection.setClientID(clientID);	TopicSession topicSession = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);	Topic topic = topicSession.createTopic(topicName);	connection.start();	TopicSubscriber subscriber = topicSession.createDurableSubscriber(topic, durableSubName);	
about to receive messages 

private Message collectMessagesFromDurableSubscriptionForOneMinute() throws Exception {	ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("vm: TopicConnection connection = connectionFactory.createTopicConnection();	connection.setClientID(clientID);	TopicSession topicSession = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);	Topic topic = topicSession.createTopic(topicName);	connection.start();	TopicSubscriber subscriber = topicSession.createDurableSubscriber(topic, durableSubName);	Message message = subscriber.receive(120000);	subscriber.close();	connection.close();	
collectmessagesfromdurablesubscriptionforoneminute done 

========================= activemq sample_3569 =========================

AmqpConnection connection = trackConnection(client.createConnection());	connection.setContainerId(getTestName());	connection.connect();	AmqpSession session = connection.createSession();	assertEquals(0, brokerView.getDurableTopicSubscribers().length);	assertEquals(0, brokerView.getInactiveDurableTopicSubscribers().length);	try {	session.lookupSubscription(getTestName());	fail("Should throw an exception since there is not subscription");	} catch (Exception e) {	
error on lookup 

========================= activemq sample_1554 =========================

public void testVirtualTopicRemoval() throws Exception {	
running testvirtualtopicremoval 

protected MBeanServerConnection connectJMXBroker() throws IOException {	JMXServiceURL url =  new JMXServiceURL("service:jmx:rmi: JMXConnector jmxc = JMXConnectorFactory.connect(url, null);	MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();	
jmx connection established 

public void setBrokerService(BrokerService brokerService) {	
setbrokerservice 

public Destination intercept(final Destination destination) {	
intercept 

public Destination intercept(final Destination destination) {	if (!destination.getActiveMQDestination().getPhysicalName().startsWith("ActiveMQ")) {	return new DestinationFilter(destination) {	public void send(ProducerBrokerExchange context, Message message) throws Exception {	if (LOG.isDebugEnabled()) {	
simpledestinationinterceptor sending message to destination 

public void remove(Destination destination) {	
remove 

public void create(Broker broker, ConnectionContext context, ActiveMQDestination destination) throws Exception {	
create 

========================= activemq sample_2401 =========================

try {	Thread.sleep(3000);	} catch (Exception e) {	}	Producer producer = new Producer(producerConnection);	Thread producerThread = new Thread(producer);	producerThread.start();	consumerThread.join();	producer.stop = true;	if (consumer.getCount() == testSize) LOG.info("test complete .... all messsages consumed!!");	
test failed sent messages intended to be consumed total but only consumed 

try {	Thread.sleep(3000);	} catch (Exception e) {	}	Producer producer = new Producer(producerConnection);	Thread producerThread = new Thread(producer);	producerThread.start();	consumerThread.join();	producer.stop = true;	if (consumer.getCount() == (testSize / 2)) {	
test complete all messsages consumed 

Thread.sleep(3000);	} catch (Exception e) {	}	Producer producer = new Producer(producerConnection);	Thread producerThread = new Thread(producer);	producerThread.start();	consumerThread.join();	producer.stop = true;	if (consumer.getCount() == (testSize / 2)) {	} else {	
test failed sent original messages only half of which were intended to be consumed consumer paused at 

counterSent++;	message = session.createTextMessage("*** Ill ....... Ini ***");	message.setJMSType(JMSTYPE_IGNOREME);	producer.send(message, DeliveryMode.NON_PERSISTENT, 0, 1800000);	counterSent++;	}	session.close();	} catch (Exception e) {	e.printStackTrace();	}	
producer thread complete messages sent to the queue 

========================= activemq sample_3705 =========================

public void test() throws Exception {	String activemqQueues = "activemq";	for (int i=1;i<numDests;i++) {	activemqQueues +=",activemq"+i;	}	int consumerWaitForConsumption = 5 * 60 * 1000;	ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	
publisher will publish messages to each queue specified 

public void test() throws Exception {	String activemqQueues = "activemq";	for (int i=1;i<numDests;i++) {	activemqQueues +=",activemq"+i;	}	int consumerWaitForConsumption = 5 * 60 * 1000;	ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	
building publisher 

public void test() throws Exception {	String activemqQueues = "activemq";	for (int i=1;i<numDests;i++) {	activemqQueues +=",activemq"+i;	}	int consumerWaitForConsumption = 5 * 60 * 1000;	ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);	
building consumer 

String activemqQueues = "activemq";	for (int i=1;i<numDests;i++) {	activemqQueues +=",activemq"+i;	}	int consumerWaitForConsumption = 5 * 60 * 1000;	ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);	consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);	long totalStart = System.currentTimeMillis();	
starting publisher 

for (int i=1;i<numDests;i++) {	activemqQueues +=",activemq"+i;	}	int consumerWaitForConsumption = 5 * 60 * 1000;	ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);	consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);	long totalStart = System.currentTimeMillis();	publisher.start();	
starting consumer 

}	int consumerWaitForConsumption = 5 * 60 * 1000;	ExportQueuePublisher publisher = null;	ExportQueueConsumer consumer = null;	publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);	consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);	long totalStart = System.currentTimeMillis();	publisher.start();	consumer.start();	int distinctPublishedCount = 0;	
waiting for publisher completion 

ExportQueueConsumer consumer = null;	publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);	consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);	long totalStart = System.currentTimeMillis();	publisher.start();	consumer.start();	int distinctPublishedCount = 0;	publisher.waitForCompletion();	List publishedIds = publisher.getIDs();	distinctPublishedCount = new TreeSet(publishedIds).size();	
publisher complete published distinct ids published 

ExportQueueConsumer consumer = null;	publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);	consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);	long totalStart = System.currentTimeMillis();	publisher.start();	consumer.start();	int distinctPublishedCount = 0;	publisher.waitForCompletion();	List publishedIds = publisher.getIDs();	distinctPublishedCount = new TreeSet(publishedIds).size();	
publisher duration 

publisher.start();	consumer.start();	int distinctPublishedCount = 0;	publisher.waitForCompletion();	List publishedIds = publisher.getIDs();	distinctPublishedCount = new TreeSet(publishedIds).size();	long endWait = System.currentTimeMillis() + consumerWaitForConsumption;	while (!consumer.completed() && System.currentTimeMillis() < endWait) {	try {	int secs = (int) (endWait - System.currentTimeMillis()) / 1000;	
waiting for consumer completion time left secs 

List publishedIds = publisher.getIDs();	distinctPublishedCount = new TreeSet(publishedIds).size();	long endWait = System.currentTimeMillis() + consumerWaitForConsumption;	while (!consumer.completed() && System.currentTimeMillis() < endWait) {	try {	int secs = (int) (endWait - System.currentTimeMillis()) / 1000;	Thread.sleep(1000);	} catch (Exception e) {	}	}	
consumer complete shutting down 

List publishedIds = publisher.getIDs();	distinctPublishedCount = new TreeSet(publishedIds).size();	long endWait = System.currentTimeMillis() + consumerWaitForConsumption;	while (!consumer.completed() && System.currentTimeMillis() < endWait) {	try {	int secs = (int) (endWait - System.currentTimeMillis()) / 1000;	Thread.sleep(1000);	} catch (Exception e) {	}	}	
total duration 

long endWait = System.currentTimeMillis() + consumerWaitForConsumption;	while (!consumer.completed() && System.currentTimeMillis() < endWait) {	try {	int secs = (int) (endWait - System.currentTimeMillis()) / 1000;	Thread.sleep(1000);	} catch (Exception e) {	}	}	consumer.shutdown();	TimeUnit.SECONDS.sleep(2);	
consumer stats 

public boolean completed() {	for (List<ConsumerThread> list : threads.values()) {	for (ConsumerThread ct : list) {	if (ct.isAlive()) {	
thread for is still alive 

public void run() {	try {	int count = 0;	while (!shutdown) {	if (idList.size() >= totalToExpect) {	
got for q 

if (m != null) {	idList.add(m.getStringProperty("KEY"));	count++;	if (count == batchSize) {	count = 0;	}	} else {	count = 0;	try {	if (idList.size() < totalToExpect) {	
did not receive on current count 

========================= activemq sample_2790 =========================

try {	ByteArrayOutputStream baos = new ByteArrayOutputStream(maxTraceDatagramSize);	DataOutputStream out = new DataOutputStream(baos);	wireFormat.marshal(brokerId, out);	wireFormat.marshal(command, out);	out.close();	ByteSequence sequence = baos.toByteSequence();	DatagramPacket datagram = new DatagramPacket(sequence.getData(), sequence.getOffset(), sequence.getLength(), address);	socket.send(datagram);	} catch (Throwable e) {	
failed to trace 

========================= activemq sample_3882 =========================

public void run() {	MessageProducer producer = null;	String threadName = Thread.currentThread().getName();	try {	producer = session.createProducer(destination);	producer.setDeliveryMode(persistent ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT);	producer.setTimeToLive(msgTTL);	initPayLoad();	running = true;	
started to calculate elapsed time 

sentCount.incrementAndGet();	}	}else{	for (sentCount.set(0); sentCount.get() < messageCount && running; sentCount.incrementAndGet()) {	synchronized (this) {	paused.await();	}	sendMessage(producer, threadName);	}	}	
produced messages 

}else{	for (sentCount.set(0); sentCount.get() < messageCount && running; sentCount.incrementAndGet()) {	synchronized (this) {	paused.await();	}	sendMessage(producer, threadName);	}	}	long tEnd = System.currentTimeMillis();	long elapsed = (tEnd - tStart) / 1000;	
elapsed time in second s 

}else{	for (sentCount.set(0); sentCount.get() < messageCount && running; sentCount.incrementAndGet()) {	synchronized (this) {	paused.await();	}	sendMessage(producer, threadName);	}	}	long tEnd = System.currentTimeMillis();	long elapsed = (tEnd - tStart) / 1000;	
elapsed time in milli second milli seconds 

private void sendMessage(MessageProducer producer, String threadName) throws Exception {	Message message = createMessage(sentCount.get());	producer.send(message);	if (LOG.isDebugEnabled()) {	
sent 

private void sendMessage(MessageProducer producer, String threadName) throws Exception {	Message message = createMessage(sentCount.get());	producer.send(message);	if (LOG.isDebugEnabled()) {	}	if (transactionBatchSize > 0 && sentCount.get() > 0 && sentCount.get() % transactionBatchSize == 0) {	
committing transaction 

========================= activemq sample_171 =========================

private Connection lockAndWrapped(Lock toLock) throws IOException {	if (connection == null) {	toLock.lock();	try {	connection = dataSource.getConnection();	if (persistenceAdapter.isChangeAutoCommitAllowed()) {	boolean autoCommit = !inTx;	if (connection.getAutoCommit() != autoCommit) {	
setting auto commit to on connection 

connection.setAutoCommit(autoCommit);	}	}	connection = new UnlockOnCloseConnection(connection, toLock);	} catch (SQLException e) {	JDBCPersistenceAdapter.log("Could not get JDBC connection: ", e);	inTx = false;	try {	toLock.unlock();	} catch (IllegalMonitorStateException oops) {	
thread does not hold the context lock on close of 

close();	IOException ioe = IOExceptionSupport.create(e);	if (persistenceAdapter.getBrokerService() != null) {	persistenceAdapter.getBrokerService().handleIOException(ioe);	}	throw ioe;	}	try {	connection.setTransactionIsolation(transactionIsolation);	} catch (Throwable e) {	
cannot set transaction isolation to due this exception is ignored 

JDBCPersistenceAdapter.log("Error while closing connection: ", e);	IOException ioe = IOExceptionSupport.create(e);	persistenceAdapter.getBrokerService().handleIOException(ioe);	throw ioe;	} finally {	try {	if (connection != null) {	connection.close();	}	} catch (Throwable e) {	
closing connection failed due this exception is ignored 

========================= activemq sample_937 =========================

protected void processStompFrame(String data) {	if (!transportStartedAtLeastOnce()) {	
waiting for stompsocket to be properly started 

protected void processStompFrame(String data) {	if (!transportStartedAtLeastOnce()) {	try {	socketTransportStarted.await();	} catch (InterruptedException e) {	
while waiting for stompsocket to be properly started we got interrupted should be okay but you could see race conditions 

========================= activemq sample_1153 =========================

}	for( int i=0; i < messageToSend; i++ ) {	producer.send(session.createTextMessage(data));	}	QueueBrowser browser = session.createBrowser(queue);	Enumeration<?> enumeration = browser.getEnumeration();	int received = 0;	while (enumeration.hasMoreElements()) {	Message m = (Message) enumeration.nextElement();	received++;	
browsed message 

}	Thread browserThread = new Thread() {	public void run() {	try {	QueueBrowser browser = session.createBrowser(queue);	Enumeration<?> enumeration = browser.getEnumeration();	int received = 0;	while (enumeration.hasMoreElements()) {	Message m = (Message) enumeration.nextElement();	received++;	
browsed message 

}	for( int i=0; i < messageToSend; i++ ) {	producer.send(session.createTextMessage(data));	}	QueueBrowser browser = session.createBrowser(queue);	Enumeration<?> enumeration = browser.getEnumeration();	int received = 0;	while (enumeration.hasMoreElements()) {	Message m = (Message) enumeration.nextElement();	received++;	
browsed message 

========================= activemq sample_3617 =========================

private void startClient() throws Exception, URISyntaxException {	clientTransport = TransportFactory.connect(new URI("tcp: clientTransport.setTransportListener(new TransportListener() {	public void onCommand(Object command) {	clientReceiveCount.incrementAndGet();	if (clientRunOnCommand != null) {	clientRunOnCommand.run();	}	}	public void onException(IOException error) {	if (!ignoreClientError.get()) {	
client transport error 

public void onAccept(Transport transport) {	try {	
server accepted a connection 

serverTransport = transport;	serverTransport.setTransportListener(new TransportListener() {	public void onCommand(Object command) {	serverReceiveCount.incrementAndGet();	if (serverRunOnCommand != null) {	serverRunOnCommand.run();	}	}	public void onException(IOException error) {	if (!ignoreClientError.get()) {	
server transport error 

public void testClientHang() throws Exception {	clientTransport = new TcpTransport(new OpenWireFormat(), SocketFactory.getDefault(), new URI("tcp: clientTransport.setTransportListener(new TransportListener() {	public void onCommand(Object command) {	clientReceiveCount.incrementAndGet();	if (clientRunOnCommand != null) {	clientRunOnCommand.run();	}	}	public void onException(IOException error) {	if (!ignoreClientError.get()) {	
client transport error 

public void initCombosForTestNoClientHangWithServerBlock() throws Exception {	startClient();	addCombinationValues("clientInactivityLimit", new Object[] {Long.valueOf(1000)});	addCombinationValues("serverInactivityLimit", new Object[] {Long.valueOf(1000)});	addCombinationValues("serverRunOnCommand", new Object[] {new Runnable() {	public void run() {	try {	
Sleeping 

========================= activemq sample_2513 =========================

public void testFailedConnectThenSucceeds() throws JMSException {	Connection connection = pooledConnFact.createConnection("invalid", "credentials");	try {	connection.start();	fail("Should fail to connect");	} catch (JMSSecurityException ex) {	
caught expected security error 

public void testFailedConnectThenSucceeds() throws JMSException {	Connection connection = pooledConnFact.createConnection("invalid", "credentials");	try {	connection.start();	fail("Should fail to connect");	} catch (JMSSecurityException ex) {	}	connection = pooledConnFact.createConnection("system", "manager");	connection.start();	
successfully create new connection 

public void testFailedConnectThenSucceedsWithListener() throws JMSException {	Connection connection = pooledConnFact.createConnection("invalid", "credentials");	connection.setExceptionListener(new ExceptionListener() {	public void onException(JMSException exception) {	
connection get error 

public void testFailedConnectThenSucceedsWithListener() throws JMSException {	Connection connection = pooledConnFact.createConnection("invalid", "credentials");	connection.setExceptionListener(new ExceptionListener() {	public void onException(JMSException exception) {	}	});	try {	connection.start();	fail("Should fail to connect");	} catch (JMSSecurityException ex) {	
caught expected security error 

public void onException(JMSException exception) {	}	});	try {	connection.start();	fail("Should fail to connect");	} catch (JMSSecurityException ex) {	}	connection = pooledConnFact.createConnection("system", "manager");	connection.start();	
successfully create new connection 

public void testFailureGetsNewConnectionOnRetry() throws Exception {	pooledConnFact.setMaxConnections(1);	final PooledConnection connection1 = (PooledConnection) pooledConnFact.createConnection("invalid", "credentials");	try {	connection1.start();	fail("Should fail to connect");	} catch (JMSSecurityException ex) {	
caught expected security error 

public boolean isSatisified() throws Exception {	return connection1.getConnection() != ((PooledConnection) pooledConnFact.createConnection("invalid", "credentials")).getConnection();	}	}));	final PooledConnection connection2 = (PooledConnection) pooledConnFact.createConnection("invalid", "credentials");	assertNotSame(connection1.getConnection(), connection2.getConnection());	try {	connection2.start();	fail("Should fail to connect");	} catch (JMSSecurityException ex) {	
caught expected security error 

public void testFailureGetsNewConnectionOnRetryBigPool() throws JMSException {	pooledConnFact.setMaxConnections(10);	Connection connection1 = pooledConnFact.createConnection("invalid", "credentials");	try {	connection1.start();	fail("Should fail to connect");	} catch (JMSSecurityException ex) {	
caught expected security error 

try {	connection1.start();	fail("Should fail to connect");	} catch (JMSSecurityException ex) {	}	Connection connection2 = pooledConnFact.createConnection("invalid", "credentials");	try {	connection2.start();	fail("Should fail to connect");	} catch (JMSSecurityException ex) {	
caught expected security error 

public void testFailoverWithInvalidCredentialsCanConnect() throws JMSException {	ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory( "failover:(" + connectionURI + ")");	pooledConnFact = new PooledConnectionFactory();	pooledConnFact.setConnectionFactory(cf);	pooledConnFact.setMaxConnections(1);	Connection connection = pooledConnFact.createConnection("invalid", "credentials");	try {	connection.start();	fail("Should fail to connect");	} catch (JMSSecurityException ex) {	
caught expected security error 

pooledConnFact.setConnectionFactory(cf);	pooledConnFact.setMaxConnections(1);	Connection connection = pooledConnFact.createConnection("invalid", "credentials");	try {	connection.start();	fail("Should fail to connect");	} catch (JMSSecurityException ex) {	}	connection = pooledConnFact.createConnection("system", "manager");	connection.start();	
successfully create new connection 

public void testFailoverWithInvalidCredentials() throws Exception {	ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory( "failover:(" + connectionURI + "?trace=true)");	pooledConnFact = new PooledConnectionFactory();	pooledConnFact.setConnectionFactory(cf);	pooledConnFact.setMaxConnections(1);	final PooledConnection connection1 = (PooledConnection) pooledConnFact.createConnection("invalid", "credentials");	try {	connection1.start();	fail("Should fail to connect");	} catch (JMSSecurityException ex) {	
caught expected security error 

public boolean isSatisified() throws Exception {	return connection1.getConnection() != ((PooledConnection) pooledConnFact.createConnection("invalid", "credentials")).getConnection();	}	}));	final PooledConnection connection2 = (PooledConnection) pooledConnFact.createConnection("invalid", "credentials");	assertNotSame(connection1.getConnection(), connection2.getConnection());	try {	connection2.start();	fail("Should fail to connect");	} catch (JMSSecurityException ex) {	
caught expected security error 

public void testFailedCreateConsumerConnectionStillWorks() throws JMSException {	Connection connection = pooledConnFact.createConnection("guest", "password");	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue(name.getMethodName());	try {	session.createConsumer(queue);	fail("Should fail to create consumer");	} catch (JMSSecurityException ex) {	
caught expected security error 

========================= activemq sample_1295 =========================

connection = createConnection();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Queue queue = session.createQueue(getDestinationName());	session.close();	for (int i = 1; i <= NUM_ITERATIONS; ++i) {	session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	QueueBrowser browser = session.createBrowser(queue, "JMSXGroupSeq=0");	int j = 1;	Enumeration<?> enums = browser.getEnumeration();	if (!enums.hasMoreElements()) {	
no messages in 

session.close();	for (int i = 1; i <= NUM_ITERATIONS; ++i) {	session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	QueueBrowser browser = session.createBrowser(queue, "JMSXGroupSeq=0");	int j = 1;	Enumeration<?> enums = browser.getEnumeration();	if (!enums.hasMoreElements()) {	} else {	Message message = (Message) enums.nextElement();	if (message != null) {	
received message from 

session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	QueueBrowser browser = session.createBrowser(queue, "JMSXGroupSeq=0");	int j = 1;	Enumeration<?> enums = browser.getEnumeration();	if (!enums.hasMoreElements()) {	} else {	Message message = (Message) enums.nextElement();	if (message != null) {	}	}	
close browser for 

Enumeration<?> enums = browser.getEnumeration();	if (!enums.hasMoreElements()) {	} else {	Message message = (Message) enums.nextElement();	if (message != null) {	}	}	try {	browser.close();	} catch (JMSException e) {	
error on browser close 

} else {	Message message = (Message) enums.nextElement();	if (message != null) {	}	}	try {	browser.close();	} catch (JMSException e) {	}	browser = null;	
close session for 

}	}	try {	browser.close();	} catch (JMSException e) {	}	browser = null;	try {	session.close();	} catch (JMSException e) {	
error on session close 

browser.close();	} catch (JMSException e) {	}	browser = null;	try {	session.close();	} catch (JMSException e) {	}	session = null;	}	
task complete capture heap dump now 

========================= activemq sample_1594 =========================

public void testClashWithPublishAndGC() throws Exception {	org.apache.log4j.Logger log4jLogger = org.apache.log4j.Logger.getLogger(RegionBroker.class);	final AtomicBoolean failed = new AtomicBoolean(false);	Appender appender = new DefaultTestAppender() {	public void doAppend(LoggingEvent event) {	if (event.getLevel().equals(Level.ERROR) && event.getMessage().toString().startsWith("Failed to remove inactive")) {	
received unexpected log message 

producer.send(new ActiveMQTopic("A." + j), message);	}	} catch (Exception ignored) {	ignored.printStackTrace();	}	}	});	}	executorService.shutdown();	executorService.awaitTermination(60, TimeUnit.SECONDS);	
Done 

public void testAddRemoveWildcardWithGc() throws Exception {	org.apache.log4j.Logger log4jLogger = org.apache.log4j.Logger.getLogger(RegionBroker.class);	final AtomicBoolean failed = new AtomicBoolean(false);	Appender appender = new DefaultTestAppender() {	public void doAppend(LoggingEvent event) {	if (event.getLevel().equals(Level.ERROR) && event.getMessage().toString().startsWith("Failed to remove inactive")) {	
received unexpected log message 

try {	MessageConsumer messageConsumer = session.createConsumer(new ActiveMQTopic(">"));	messageConsumer.close();	} catch (Exception ignored) {	}	}	}	});	executorService.shutdown();	executorService.awaitTermination(60, TimeUnit.SECONDS);	
Done 

========================= activemq sample_2357 =========================

protected void setUp() throws Exception {	super.setUp();	String temp = System.getProperty("messageCount");	if (temp != null) {	int i = Integer.parseInt(temp);	if (i > 0) {	messageCount = i;	}	}	
message count for test case is 

public void testSendReceive() throws Exception {	messages.clear();	for (int i = 0; i < data.length; i++) {	Message message = session.createTextMessage(data[i]);	message.setStringProperty("stringProperty", data[i]);	message.setIntProperty("intProperty", i);	if (verbose) {	if (LOG.isDebugEnabled()) {	
about to send a message with text 

message.setStringProperty("stringProperty", data[i]);	message.setIntProperty("intProperty", i);	if (verbose) {	if (LOG.isDebugEnabled()) {	}	}	sendToProducer(producer, producerDestination, message);	messageSent();	}	assertMessagesAreReceived();	
messages s received closing down connections 

}	}	assertEquals("Not enough messages received", data.length, receivedMessages.size());	for (int i = 0; i < data.length; i++) {	TextMessage received = (TextMessage)receivedMessages.get(i);	String text = received.getText();	String stringProperty = received.getStringProperty("stringProperty");	int intProperty = received.getIntProperty("intProperty");	if (verbose) {	if (LOG.isDebugEnabled()) {	
received text 

protected void consumeMessage(Message message, List<Message> messageList) {	if (verbose) {	if (LOG.isDebugEnabled()) {	
received message 

========================= activemq sample_3546 =========================

connection1.send(connectionInfo1);	connection1.send(sessionInfo1);	connection1.request(consumerInfo1);	StubConnection connection2 = createRemoteConnection();	ConnectionInfo connectionInfo2 = createConnectionInfo();	SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);	ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);	connection2.send(connectionInfo2);	connection2.send(sessionInfo2);	connection2.request(consumerInfo2);	
starting the failover connection 

connectionA = connection1;	connectionB = connection2;	serverA = connector;	} else {	connectionA = connection2;	connectionB = connection1;	serverA = remoteConnector;	}	assertNotNull(receiveMessage(connectionA));	assertNoMessagesLeft(connectionB);	
disconnecting the active connection 

public void testNoBrokersInBrokerInfo() throws Exception {	final BrokerInfo info[] = new BrokerInfo[1];	TransportListener listener = new TransportListener() {	public void onCommand(Object command) {	
got command 

========================= activemq sample_2584 =========================

public void setHeader(String encodedHeader) {	if (encodedHeader.endsWith(":")) {	encodedHeader = encodedHeader.substring(0, encodedHeader.length()-1);	}	String headers[] = encodedHeader.split(":");	for (String h : headers) {	String tokens[] = h.split("=");	if (tokens.length != 2 || tokens[0].equals("") || tokens[1].equals("") ) {	
error parsing message headers header h this header will be ignored 

public void setMsgFileName(String file) {	
specified will ignore setting 

========================= activemq sample_1202 =========================

Destination sendTo = sendSession.createTopic(SENDER_TOPIC);	Destination receiveFrom = receiverSession1.createTopic(RECEIVER_TOPIC);	TextMessage message = sendSession.createTextMessage(MSG_STRING);	MessageConsumer receiver1 = receiverSession1.createConsumer(receiveFrom);	MessageConsumer receiver2 = receiverSession2.createConsumer(receiveFrom);	MessageProducer sender = sendSession.createProducer(sendTo);	for( int i = 0; i < MSG_COUNT; ++i ) {	sender.send(message);	}	for( int i = 0; i < MSG_COUNT; ++i ) {	
attempting received for message 

private void createCamelContext() throws Exception {	final String fromEndpoint = "activemq:topic:" + SENDER_TOPIC;	final String toEndpoint = "activemq:topic:" + RECEIVER_TOPIC;	
creating context and sending message 

========================= activemq sample_1347 =========================

public void testNoExceptionOnRedeliveryAckWithSimpleTopicConsumer() throws Exception {	Destination destination = createDestination(getClass().getName());	Connection connection = createConnection();	final AtomicBoolean gotException = new AtomicBoolean();	connection.setExceptionListener(new ExceptionListener() {	public void onException(JMSException exception) {	
unexpected ex 

========================= activemq sample_3680 =========================

connection.setClientID(getClass().getName());	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createTopic("DurableTopic");	MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, "EnqueueSub");	BrokerView view = brokerService.getAdminView();	view.getDurableTopicSubscribers();	ObjectName subName = view.getDurableTopicSubscribers()[0];	DurableSubscriptionViewMBean sub = (DurableSubscriptionViewMBean) brokerService.getManagementContext().newProxyInstance(subName, DurableSubscriptionViewMBean.class, true);	assertEquals(0, sub.getEnqueueCounter());	
enqueue counter for sub before pull requests 

view.getDurableTopicSubscribers();	ObjectName subName = view.getDurableTopicSubscribers()[0];	DurableSubscriptionViewMBean sub = (DurableSubscriptionViewMBean) brokerService.getManagementContext().newProxyInstance(subName, DurableSubscriptionViewMBean.class, true);	assertEquals(0, sub.getEnqueueCounter());	consumer.receive(500);	consumer.receive(500);	consumer.receive(500);	consumer.receive(500);	consumer.receive(500);	Thread.sleep(600);	
enqueue counter for sub after pull requests 

========================= activemq sample_2838 =========================

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	
creating send connection 

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	sendConnection = createSendConnection();	
starting send connection 

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	sendConnection = createSendConnection();	sendConnection.start();	
creating receive connection 

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	sendConnection = createSendConnection();	sendConnection.start();	receiveConnection = createReceiveConnection();	
starting receive connection 

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	sendConnection = createSendConnection();	sendConnection.start();	receiveConnection = createReceiveConnection();	receiveConnection.start();	
created sendconnection 

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	sendConnection = createSendConnection();	sendConnection.start();	receiveConnection = createReceiveConnection();	receiveConnection.start();	
created receiveconnection 

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	sendConnection = createSendConnection();	sendConnection.start();	receiveConnection = createReceiveConnection();	receiveConnection.start();	session = sendConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	receiveSession = receiveConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	
created sendsession 

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	sendConnection = createSendConnection();	sendConnection.start();	receiveConnection = createReceiveConnection();	receiveConnection.start();	session = sendConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	receiveSession = receiveConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	
created receivesession 

producer = session.createProducer(null);	producer.setDeliveryMode(deliveryMode);	LOG.info("Created producer: " + producer + " delivery mode = " + (deliveryMode == DeliveryMode.PERSISTENT ? "PERSISTENT" : "NON_PERSISTENT"));	if (topic) {	consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	} else {	consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	}	
created consumer destination of type 

producer = session.createProducer(null);	producer.setDeliveryMode(deliveryMode);	LOG.info("Created producer: " + producer + " delivery mode = " + (deliveryMode == DeliveryMode.PERSISTENT ? "PERSISTENT" : "NON_PERSISTENT"));	if (topic) {	consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	} else {	consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	}	
created producer destination of type 

LOG.info("Created producer: " + producer + " delivery mode = " + (deliveryMode == DeliveryMode.PERSISTENT ? "PERSISTENT" : "NON_PERSISTENT"));	if (topic) {	consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	} else {	consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	}	consumer = createConsumer();	consumer.setMessageListener(this);	
started connections 

========================= activemq sample_2615 =========================

public void receiveSyncTimeBasedMessages(long duration) throws JMSException {	if (getJmsConsumer() == null) {	createJmsConsumer();	}	try {	getConnection().start();	
starting to synchronously receive messages for ms 

getConnection().start();	long endTime = System.currentTimeMillis() + duration;	while (System.currentTimeMillis() < endTime) {	getJmsConsumer().receive();	incThroughput();	sleep();	commitTxIfNecessary();	}	} finally {	if (client.isDurable() && client.isUnsubscribe()) {	
unsubscribing durable subscriber 

public void receiveSyncCountBasedMessages(long count) throws JMSException {	if (getJmsConsumer() == null) {	createJmsConsumer();	}	try {	getConnection().start();	
starting to synchronously receive messages 

int recvCount = 0;	while (recvCount < count) {	getJmsConsumer().receive();	incThroughput();	recvCount++;	sleep();	commitTxIfNecessary();	}	} finally {	if (client.isDurable() && client.isUnsubscribe()) {	
unsubscribing durable subscriber 

if (getJmsConsumer() == null) {	createJmsConsumer();	}	getJmsConsumer().setMessageListener(new MessageListener() {	public void onMessage(Message msg) {	incThroughput();	sleep();	try {	commitTxIfNecessary();	} catch (JMSException ex) {	
error committing transaction 

incThroughput();	sleep();	try {	commitTxIfNecessary();	} catch (JMSException ex) {	}	}	});	try {	getConnection().start();	
starting to asynchronously receive messages for ms 

});	try {	getConnection().start();	try {	Thread.sleep(duration);	} catch (InterruptedException e) {	throw new JMSException("JMS consumer thread sleep has been interrupted. Message: " + e.getMessage());	}	} finally {	if (client.isDurable() && client.isUnsubscribe()) {	
unsubscribing durable subscriber 

public void onMessage(Message msg) {	incThroughput();	sleep();	recvCount.incrementAndGet();	synchronized (recvCount) {	recvCount.notify();	}	try {	commitTxIfNecessary();	} catch (JMSException ex) {	
error committing transaction 

recvCount.notify();	}	try {	commitTxIfNecessary();	} catch (JMSException ex) {	}	}	});	try {	getConnection().start();	
starting to asynchronously receive messages 

while (recvCount.get() < count) {	synchronized (recvCount) {	recvCount.wait();	}	}	} catch (InterruptedException e) {	throw new JMSException("JMS consumer thread wait has been interrupted. Message: " + e.getMessage());	}	} finally {	if (client.isDurable() && client.isUnsubscribe()) {	
unsubscribing durable subscriber 

public MessageConsumer createJmsConsumer() throws JMSException {	Destination[] dest = createDestinations(destCount);	Destination consumedDestination = dest[0];	if (dest.length > 1) {	String destinationName = ((ActiveMQDestination) consumedDestination).getPhysicalName();	
multiple destinations requested for consumer using only first 

public MessageConsumer createJmsConsumer(Destination dest) throws JMSException {	if (client.isDurable()) {	String clientName = getClientName();	if (clientName == null) {	clientName = "JmsConsumer";	setClientName(clientName);	}	
creating durable subscriber to 

public MessageConsumer createJmsConsumer(Destination dest) throws JMSException {	if (client.isDurable()) {	String clientName = getClientName();	if (clientName == null) {	clientName = "JmsConsumer";	setClientName(clientName);	}	jmsConsumer = getSession().createDurableSubscriber((Topic) dest, clientName);	} else {	
creating non durable consumer to 

public MessageConsumer createJmsConsumer(Destination dest, String selector, boolean noLocal) throws JMSException {	if (client.isDurable()) {	String clientName = getClientName();	if (clientName == null) {	clientName = "JmsConsumer";	setClientName(clientName);	}	
creating durable subscriber to 

public MessageConsumer createJmsConsumer(Destination dest, String selector, boolean noLocal) throws JMSException {	if (client.isDurable()) {	String clientName = getClientName();	if (clientName == null) {	clientName = "JmsConsumer";	setClientName(clientName);	}	jmsConsumer = getSession().createDurableSubscriber((Topic) dest, clientName, selector, noLocal);	} else {	
creating non durable consumer to 

protected void sleep() {	if (client.getRecvDelay() > 0) {	try {	
sleeping for milliseconds 

========================= activemq sample_1193 =========================

public void waitForJettySocketToAccept(String bindLocation) throws Exception {	final URL url = new URL(bindLocation);	assertTrue("Jetty endpoint is available", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	boolean canConnect = false;	try {	Socket socket = SocketFactory.getDefault().createSocket(url.getHost(), url.getPort());	socket.close();	canConnect = true;	} catch (Exception e) {	
verify jetty available failed to connect to 

========================= activemq sample_918 =========================

protected MessageConsumer createConsumer(Destination dest) throws JMSException {	final String consumerText = "Consumer: " + (++consumerCounter);	
creating consumer on destination 

protected MessageConsumer createConsumer(Destination dest) throws JMSException {	final String consumerText = "Consumer: " + (++consumerCounter);	MessageConsumer consumer = session.createConsumer(dest);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	
received message by message 

========================= activemq sample_3511 =========================

producerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	consumerSession = connection.createSession(true, 0);	producer = producerSession.createProducer(queue);	consumer = consumerSession.createConsumer(queue);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message m) {	try {	TextMessage tm = (TextMessage)m;	receivedText = tm.getText();	latch.countDown();	
consumer received message 

consumerSession = connection.createSession(true, 0);	producer = producerSession.createProducer(queue);	consumer = consumerSession.createConsumer(queue);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message m) {	try {	TextMessage tm = (TextMessage)m;	receivedText = tm.getText();	latch.countDown();	consumerSession.commit();	
committed transaction 

consumer.setMessageListener(new MessageListener() {	public void onMessage(Message m) {	try {	TextMessage tm = (TextMessage)m;	receivedText = tm.getText();	latch.countDown();	consumerSession.commit();	} catch (JMSException e) {	try {	consumerSession.rollback();	
rolled back transaction 

e.printStackTrace();	}	}	});	connection.start();	TextMessage tm = null;	try {	tm = producerSession.createTextMessage();	tm.setText("Hello, " + new Date());	producer.send(tm);	
producer sent message 

});	connection.start();	TextMessage tm = null;	try {	tm = producerSession.createTextMessage();	tm.setText("Hello, " + new Date());	producer.send(tm);	} catch (JMSException e) {	e.printStackTrace();	}	
waiting for latch 

========================= activemq sample_3638 =========================

public void testGenerateAndReParsingIsTheSame() throws Exception {	ByteArrayOutputStream buffer = new ByteArrayOutputStream();	DataOutputStream ds = new DataOutputStream(buffer);	Object expected = createObject();	
created 

public void testGenerateAndReParsingIsTheSame() throws Exception {	ByteArrayOutputStream buffer = new ByteArrayOutputStream();	DataOutputStream ds = new DataOutputStream(buffer);	Object expected = createObject();	openWireformat.marshal(expected, ds);	ds.close();	ByteArrayInputStream in = new ByteArrayInputStream(buffer.toByteArray());	DataInputStream dis = new DataInputStream(in);	Object actual = openWireformat.unmarshal(dis);	assertBeansEqual("", new HashSet<Object>(), expected, actual);	
parsed 

PropertyDescriptor descriptor = descriptors[i];	Method method = descriptor.getReadMethod();	if (method != null) {	String name = descriptor.getName();	Object expectedValue = null;	Object actualValue = null;	try {	expectedValue = method.invoke(expected, EMPTY_ARGUMENTS);	actualValue = method.invoke(actual, EMPTY_ARGUMENTS);	} catch (Exception e) {	
failed to access property 

========================= activemq sample_3268 =========================

public void slowConsumer(ConnectionContext context, Subscription subs) {	if (maxSlowCount < 0 && maxSlowDuration < 0) {	
no limits set slowconsumer strategy has nothing to do 

if (maxSlowDuration > 0) {	for (SlowConsumerEntry entry : slowConsumers.values()) {	entry.mark();	}	}	HashMap<Subscription, SlowConsumerEntry> toAbort = new HashMap<Subscription, SlowConsumerEntry>();	for (Entry<Subscription, SlowConsumerEntry> entry : slowConsumers.entrySet()) {	Subscription subscription = entry.getKey();	if (isIgnoreNetworkSubscriptions() && subscription.getConsumerInfo().isNetworkSubscription()) {	if (slowConsumers.remove(subscription) != null) {	
network sub is no longer slow 

if (slowConsumers.remove(subscription) != null) {	}	continue;	}	if (entry.getKey().isSlowConsumer()) {	if (maxSlowDuration > 0 && (entry.getValue().markCount * checkPeriod >= maxSlowDuration) || maxSlowCount > 0 && entry.getValue().slowCount >= maxSlowCount) {	toAbort.put(entry.getKey(), entry.getValue());	slowConsumers.remove(entry.getKey());	}	} else {	
sub is no longer slow 

protected void abortSubscription(Map<Subscription, SlowConsumerEntry> toAbort, boolean abortSubscriberConnection) {	Map<Connection, List<Subscription>> abortMap = new HashMap<Connection, List<Subscription>>();	for (final Entry<Subscription, SlowConsumerEntry> entry : toAbort.entrySet()) {	ConnectionContext connectionContext = entry.getValue().context;	if (connectionContext == null) {	continue;	}	Connection connection = connectionContext.getConnection();	if (connection == null) {	
slowconsumer abort ignored no connection in context 

}	if (!abortMap.containsKey(connection)) {	abortMap.put(connection, new ArrayList<Subscription>());	}	abortMap.get(connection).add(entry.getKey());	}	for (Entry<Connection, List<Subscription>> entry : abortMap.entrySet()) {	final Connection connection = entry.getKey();	final List<Subscription> subscriptions = entry.getValue();	if (abortSubscriberConnection) {	
aborting connection with slow consumers 

abortMap.put(connection, new ArrayList<Subscription>());	}	abortMap.get(connection).add(entry.getKey());	}	for (Entry<Connection, List<Subscription>> entry : abortMap.entrySet()) {	final Connection connection = entry.getKey();	final List<Subscription> subscriptions = entry.getValue();	if (abortSubscriberConnection) {	if (LOG.isTraceEnabled()) {	for (Subscription subscription : subscriptions) {	
connection being aborted because of slow consumer on destination 

if (LOG.isTraceEnabled()) {	for (Subscription subscription : subscriptions) {	}	}	try {	scheduler.executeAfterDelay(new Runnable() {	public void run() {	connection.serviceException(new InactivityIOException( subscriptions.size() + " Consumers was slow too often (>" + maxSlowCount +  ") or too long (>" + maxSlowDuration + "): "));	}}, 0l);	} catch (Exception e) {	
exception on aborting connection with slow consumers 

try {	scheduler.executeAfterDelay(new Runnable() {	public void run() {	connection.serviceException(new InactivityIOException( subscriptions.size() + " Consumers was slow too often (>" + maxSlowCount +  ") or too long (>" + maxSlowDuration + "): "));	}}, 0l);	} catch (Exception e) {	}	} else {	for (Subscription subscription : subscriptions) {	final Subscription subToClose = subscription;	
aborting slow consumer for destination 

}	} else {	for (Subscription subscription : subscriptions) {	final Subscription subToClose = subscription;	try {	ConsumerControl stopConsumer = new ConsumerControl();	stopConsumer.setConsumerId(subscription.getConsumerInfo().getConsumerId());	stopConsumer.setClose(true);	connection.dispatchAsync(stopConsumer);	} catch (Exception e) {	
exception on aborting slow consumer 

public void run() {	try {	RemoveInfo removeCommand = subToClose.getConsumerInfo().createRemoveCommand();	if (connection instanceof CommandVisitor) {	removeCommand.visit((CommandVisitor) connection);	} else {	connection.service(removeCommand);	}	} catch (IllegalStateException ignoredAsRemoteHasDoneTheJob) {	} catch (Exception e) {	
exception on local remove of slow consumer 

if (connection instanceof CommandVisitor) {	removeCommand.visit((CommandVisitor) connection);	} else {	connection.service(removeCommand);	}	} catch (IllegalStateException ignoredAsRemoteHasDoneTheJob) {	} catch (Exception e) {	}	}}, 1000l);	} catch (Exception e) {	
exception on local remove of slow consumer 

public void abortConsumer(Subscription sub, boolean abortSubscriberConnection) {	if (sub != null) {	SlowConsumerEntry entry = slowConsumers.remove(sub);	if (entry != null) {	Map<Subscription, SlowConsumerEntry> toAbort = new HashMap<Subscription, SlowConsumerEntry>();	toAbort.put(sub, entry);	abortSubscription(toAbort, abortSubscriberConnection);	} else {	
cannot abort subscription as it no longer exists in the map of slow consumers 

========================= activemq sample_4057 =========================

protected BytesMessage createMessage(int count, Session session, int maxMessageSize, AtomicLong publishedMessageSize) throws JMSException {	final BytesMessage message = session.createBytesMessage();	final Random randomSize = new Random();	int size = randomSize.nextInt((maxMessageSize - 100) + 1) + 100;	
creating message to publish size 

========================= activemq sample_3792 =========================

protected Transport createProducer() throws Exception {	
producer using uri 

protected Transport createConsumer() throws Exception {	
consumer on port 

========================= activemq sample_2479 =========================

public void testWriteTimeout() throws Exception {	Destination dest = new ActiveMQQueue("testWriteTimeout");	messageTextPrefix = initMessagePrefix(8*1024);	sendMessages(dest, 500);	URI tcpBrokerUri = URISupport.removeQuery(broker.getTransportConnectors().get(0).getConnectUri());	
consuming using uri 

public void testWriteTimeoutStompNio() throws Exception {	ActiveMQQueue dest = new ActiveMQQueue("testWriteTimeout");	messageTextPrefix = initMessagePrefix(8*1024);	sendMessages(dest, 500);	URI stompBrokerUri = URISupport.removeQuery(broker.getTransportConnectors().get(1).getConnectUri());	
consuming using uri 

TimeUnit.SECONDS.sleep(10);	proxy.goOn();	frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("MESSAGE"));	try {	for (int i=0; i<200; i++) {	stompConnection.send("/queue/" + dest.getPhysicalName(),  "ShouldBeDeadConnectionText" + i);	}	fail("expected send to fail with timeout out connection");	} catch (SocketException expected) {	
got exception on send after timeout 

========================= activemq sample_2496 =========================

public TransactionManager getTransactionManager() {	if (transactionManager == null && tmFromJndi) {	try {	transactionManager = (TransactionManager) new InitialContext().lookup(getTmJndiName());	} catch (Throwable ignored) {	if (LOG.isTraceEnabled()) {	
exception on tmfromjndi 

name = name.substring(0, name.lastIndexOf('/')) + "/conf" + name.substring(name.lastIndexOf('/'));	try {	InitialContext ctx = new InitialContext();	NamingEnumeration<Binding> bindings = ctx.listBindings(name);	while (bindings.hasMore()) {	Binding bd = bindings.next();	IntrospectionSupport.setProperty(this, bd.getName(), bd.getObject());	}	} catch (Exception ignored) {	if (LOG.isTraceEnabled()) {	
exception on config from jndi 

========================= activemq sample_1310 =========================

protected void dump() {	
dumping current state 

========================= activemq sample_2603 =========================

connection = connectionFactory.createConnection();	connection.start();	Session session = connection.createSession(transacted, authMode);	destination = createDestination();	MessageProducer producer = session.createProducer(destination);	for (int i = 0; i < messageCount; i++) {	Message message = session.createTextMessage("Message: " + i);	producer.send(message);	}	long usageBeforMove = broker.getPersistenceAdapter().size();	
store usage 

long count = proxy.getQueueSize();	assertEquals("Queue size", count, 0);	assertEquals("Browse size", proxy.browseMessages().size(), 0);	objectNameStr = broker.getBrokerObjectName().toString();	objectNameStr += ",destinationType=Queue,destinationName="+to.getQueueName();	queueViewMBeanName = assertRegisteredObjectName(objectNameStr);	QueueViewMBean toProxy = (QueueViewMBean)MBeanServerInvocationHandler.newProxyInstance(mbeanServer, queueViewMBeanName, QueueViewMBean.class, true);	count = toProxy.getQueueSize();	assertEquals("Queue size", count, messageCount);	long usageAfterMove = broker.getPersistenceAdapter().size();	
store usage before after 

long count = proxy.getQueueSize();	assertEquals("Queue size", count, 0);	assertEquals("Browse size", proxy.browseMessages().size(), 0);	objectNameStr = broker.getBrokerObjectName().toString();	objectNameStr += ",destinationType=Queue,destinationName="+to.getQueueName();	queueViewMBeanName = assertRegisteredObjectName(objectNameStr);	QueueViewMBean toProxy = (QueueViewMBean)MBeanServerInvocationHandler.newProxyInstance(mbeanServer, queueViewMBeanName, QueueViewMBean.class, true);	count = toProxy.getQueueSize();	assertEquals("Queue size", count, messageCount);	long usageAfterMove = broker.getPersistenceAdapter().size();	
store size increase 

protected ObjectName assertRegisteredObjectName(String name) throws MalformedObjectNameException, NullPointerException {	ObjectName objectName = new ObjectName(name);	if (mbeanServer.isRegistered(objectName)) {	
bean registered 

========================= activemq sample_2316 =========================

public XATransaction(TransactionStore transactionStore, XATransactionId xid, TransactionBroker broker, ConnectionId connectionId) {	this.transactionStore = transactionStore;	this.xid = xid;	this.broker = broker;	this.connectionId = connectionId;	if (LOG.isDebugEnabled()) {	
xa transaction new begin 

public void commit(boolean onePhase) throws XAException, IOException {	if (LOG.isDebugEnabled()) {	
xa transaction commit onephase xid 

private void storeCommit(TransactionId txid, boolean wasPrepared, Runnable preCommit,Runnable postCommit) throws XAException, IOException {	try {	transactionStore.commit(getTransactionId(), wasPrepared, preCommitTask, postCommitTask);	waitPostCommitDone(postCommitTask);	} catch (XAException xae) {	throw xae;	} catch (Throwable t) {	
store commit failed 

private void doPrePrepare() throws XAException, IOException {	try {	prePrepare();	} catch (XAException e) {	throw e;	} catch (Throwable e) {	
pre prepare failed 

public void rollback() throws XAException, IOException {	if (LOG.isDebugEnabled()) {	
xa transaction rollback 

private void doPostRollback() throws XAException {	try {	fireAfterRollback();	} catch (Throwable e) {	
post rollback failed 

public int prepare() throws XAException, IOException {	if (LOG.isDebugEnabled()) {	
xa transaction prepare 

========================= activemq sample_3854 =========================

public void testVoidSupport() throws Exception {	sendMessage();	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(name.getMethodName());	MessageConsumer consumer = session.createConsumer(destination);	ActiveMQObjectMessage msg = (ActiveMQObjectMessage) consumer.receive();	AMQ5921MessagePayload payload = (AMQ5921MessagePayload) msg.getObject();	
received 

========================= activemq sample_2896 =========================

public void testQueueSendThenAddConsumer() throws Exception {	long start;	long end;	ActiveMQDestination destination = new ActiveMQQueue("TEST");	connection.setUseCompression(false);	connection.getPrefetchPolicy().setAll(10);	connection.start();	Session session = connection.createSession(false, Session.DUPS_OK_ACKNOWLEDGE);	
receiving messages that are in the queue 

while ((end - start) < 5000) {	msg = (BytesMessage)consumer.receive(5000);	if (msg == null) {	break;	}	counter++;	consumed++;	end = System.currentTimeMillis();	size += msg.getBodyLength();	}	
consumed messages sec megs sec 

if (msg == null) {	break;	}	counter++;	consumed++;	end = System.currentTimeMillis();	size += msg.getBodyLength();	}	}	consumer.close();	
consumed messages from the queue 

}	counter++;	consumed++;	end = System.currentTimeMillis();	size += msg.getBodyLength();	}	}	consumer.close();	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	
sending messages that are k large 

end = start = System.currentTimeMillis();	int produceCount = 0;	while ((end - start) < 5000 && !stop.get()) {	BytesMessage bm = session.createBytesMessage();	bm.writeBytes(new byte[messageSize]);	producer.send(bm);	produceCount++;	produced++;	end = System.currentTimeMillis();	}	
produced messages sec megs sec 

int produceCount = 0;	while ((end - start) < 5000 && !stop.get()) {	BytesMessage bm = session.createBytesMessage();	bm.writeBytes(new byte[messageSize]);	producer.send(bm);	produceCount++;	produced++;	end = System.currentTimeMillis();	}	}	
prodcued messages to the queue 

========================= activemq sample_3784 =========================

Matcher matcher = byteMatchers[i].matcher(str);	if (matcher.matches()) {	long value = Long.parseLong(matcher.group(1));	for (int j=1; j<=i; j++) {	value *= 1024;	}	return String.valueOf(value);	}	}	} catch (NumberFormatException ignored) {	
nfe on 

}	}	}	for (String value : propertiesClazzes) {	try {	Object springBean = getClass().getClassLoader().loadClass(value).newInstance();	if (springBean instanceof FactoryBean) {	initialProperties.putAll((Properties) FactoryBean.class.getMethod("getObject", (Class<?>[]) null).invoke(springBean));	}	} catch (Throwable e) {	
unexpected exception processing properties bean class 

} catch (Throwable e) {	}	}	List<Resource> propResources = new LinkedList<Resource>();	for (String value : resources) {	try {	if (!value.isEmpty()) {	propResources.add(Utils.resourceFromString(filter(value)));	}	} catch (MalformedURLException e) {	
failed to resolve resource 

propResources.add(Utils.resourceFromString(filter(value)));	}	} catch (MalformedURLException e) {	}	}	for (Resource resource : propResources) {	Properties properties = new Properties();	try {	properties.load(resource.getInputStream());	} catch (IOException e) {	
failed to load properties resource 

========================= activemq sample_4411 =========================

public void tearDown() throws Exception {	try {	
teardown started 

public void tearDown() throws Exception {	try {	if (connection != null) {	
in closeconnectiontask call calling connection close 

========================= activemq sample_1613 =========================

public void testDLQRecovery() throws Exception {	sendMessage(new ActiveMQQueue("QName"));	TimeUnit.SECONDS.sleep(3);	
check for expired message moving to dlq 

public void testDLQRecovery() throws Exception {	sendMessage(new ActiveMQQueue("QName"));	TimeUnit.SECONDS.sleep(3);	Queue dlqQueue = (Queue) createDlqDestination();	verifyIsDlq(dlqQueue);	final QueueViewMBean queueViewMBean = getProxyToQueue(dlqQueue.getQueueName());	assertTrue("The message expired", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
dlq stats enqueues dispatches expired inflight 

private void sendMessage(Destination destination) throws Exception {	Connection connection = createConnection();	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.send(destination, session.createTextMessage("DLQ message"), DeliveryMode.PERSISTENT, 4, 1000);	connection.stop();	
send message that will expire 

========================= activemq sample_2879 =========================

private void verifyPrefetch(final int val, final Destination dest) throws Exception {	assertTrue("success in time", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	try {	Subscription sub = brokerService.getRegionBroker().getDestinationMap().get(ActiveMQDestination.transform(dest)).getConsumers().get(0);	
sub prefetch 

========================= activemq sample_1428 =========================

protected void close(Connection connection) {	if (null != connection) {	try {	connection.close();	} catch (SQLException e1) {	
exception while closing connection 

protected void close(Statement statement) {	if (null != statement) {	try {	statement.close();	} catch (SQLException e1) {	
exception while closing statement 

public void preStart() {	if (createTablesOnStartup) {	String[] createStatements = getStatements().getCreateLockSchemaStatements();	Connection connection = null;	Statement statement = null;	try {	connection = getConnection();	statement = connection.createStatement();	setQueryTimeout(statement);	for (int i = 0; i < createStatements.length; i++) {	
executing sql 

Connection connection = null;	Statement statement = null;	try {	connection = getConnection();	statement = connection.createStatement();	setQueryTimeout(statement);	for (int i = 0; i < createStatements.length; i++) {	try {	statement.execute(createStatements[i]);	} catch (SQLException e) {	
could not create lock tables they could already exist failure was message sqlstate vendor code 

connection = getConnection();	statement = connection.createStatement();	setQueryTimeout(statement);	for (int i = 0; i < createStatements.length; i++) {	try {	statement.execute(createStatements[i]);	} catch (SQLException e) {	}	}	} catch (SQLException e) {	
could not create lock tables failure message sqlstate vendor code 

========================= activemq sample_959 =========================

public void testConnectorRestart() throws Exception {	MessageConsumer remoteConsumer = remoteSession.createConsumer(included);	MessageProducer localProducer = localSession.createProducer(included);	localProducer.send(localSession.createTextMessage("before"));	Message before = remoteConsumer.receive(1000);	assertNotNull(before);	assertEquals("before", ((TextMessage)before).getText());	Thread.sleep(1000);	NetworkConnector connector = localBroker.getNetworkConnectorByName("networkConnector");	
stopping connector 

MessageConsumer remoteConsumer = remoteSession.createConsumer(included);	MessageProducer localProducer = localSession.createProducer(included);	localProducer.send(localSession.createTextMessage("before"));	Message before = remoteConsumer.receive(1000);	assertNotNull(before);	assertEquals("before", ((TextMessage)before).getText());	Thread.sleep(1000);	NetworkConnector connector = localBroker.getNetworkConnectorByName("networkConnector");	connector.stop();	Thread.sleep(5000);	
starting connector 

public void testConnectorReAdd() throws Exception {	MessageConsumer remoteConsumer = remoteSession.createConsumer(included);	MessageProducer localProducer = localSession.createProducer(included);	localProducer.send(localSession.createTextMessage("before"));	Message before = remoteConsumer.receive(1000);	assertNotNull(before);	assertEquals("before", ((TextMessage)before).getText());	Thread.sleep(1000);	NetworkConnector connector = localBroker.getNetworkConnectorByName("networkConnector");	
removing connector 

MessageProducer localProducer = localSession.createProducer(included);	localProducer.send(localSession.createTextMessage("before"));	Message before = remoteConsumer.receive(1000);	assertNotNull(before);	assertEquals("before", ((TextMessage)before).getText());	Thread.sleep(1000);	NetworkConnector connector = localBroker.getNetworkConnectorByName("networkConnector");	connector.stop();	localBroker.removeNetworkConnector(connector);	Thread.sleep(5000);	
re adding connector 

========================= activemq sample_2711 =========================

final Session consumerSession = connection.createSession(true, Session.SESSION_TRANSACTED);	final Queue queue = producerSession.createQueue("FOO.BAR");	final MessageProducer producer = producerSession.createProducer(queue);	final MessageConsumer consumer = consumerSession.createConsumer(queue);	final CountDownLatch sentAll = new CountDownLatch(8);	connection.start();	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	
rolling back incoming message 

final MessageProducer producer = producerSession.createProducer(queue);	final MessageConsumer consumer = consumerSession.createConsumer(queue);	final CountDownLatch sentAll = new CountDownLatch(8);	connection.start();	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	consumerSession.rollback();	} catch (JMSException e) {	
failed to rollback on incoming message 

}	}	});	ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();	executor.scheduleWithFixedDelay(new Runnable() {	public void run() {	try {	BytesMessage message = producerSession.createBytesMessage();	message.writeBytes(payload.data, payload.offset, payload.length);	producer.send(message);	
send next message to queue 

});	ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();	executor.scheduleWithFixedDelay(new Runnable() {	public void run() {	try {	BytesMessage message = producerSession.createBytesMessage();	message.writeBytes(payload.data, payload.offset, payload.length);	producer.send(message);	sentAll.countDown();	} catch (JMSException e) {	
send of message did not complete 

========================= activemq sample_2341 =========================

ActiveMQDestination destination = info.getDestination();	if (destination != null && broker.getDestinationPolicy() != null) {	PolicyEntry entry = broker.getDestinationPolicy().getEntryFor(destination);	if (entry != null) {	entry.configure(broker, usageManager, answer);	}	}	answer.init();	return answer;	} catch (Exception e) {	
failed to create topicsubscription 

========================= activemq sample_4016 =========================

public PooledTaskRunner(Executor executor, final Task task, int maxIterationsPerRun) {	this.executor = executor;	this.maxIterationsPerRun = maxIterationsPerRun;	this.task = task;	runable = new Runnable() {	public void run() {	runningThread = Thread.currentThread();	try {	runTask();	} finally {	
run task done 

public void shutdown(long timeout) throws InterruptedException {	
shutdown timeout task 

========================= activemq sample_723 =========================

public void open() {	
session opened 

public void close() {	
session closed 

public void createReceiver(final Receiver protonReceiver) throws Exception {	org.apache.qpid.proton.amqp.transport.Target remoteTarget = protonReceiver.getRemoteTarget();	ProducerInfo producerInfo = new ProducerInfo(getNextProducerId());	final AmqpReceiver receiver = new AmqpReceiver(this, protonReceiver, producerInfo);	
opening new receiver on link 

public void createSender(final Sender protonSender) throws Exception {	org.apache.qpid.proton.amqp.messaging.Source source = (org.apache.qpid.proton.amqp.messaging.Source) protonSender.getRemoteSource();	ConsumerInfo consumerInfo = new ConsumerInfo(getNextConsumerId());	final AmqpSender sender = new AmqpSender(this, protonSender, consumerInfo);	
opening new sender on link 

========================= activemq sample_1701 =========================

public void stop() {	try {	if (this.transportLoggerControlCreated) {	this.managementContext.unregisterMBean(this.objectName);	this.managementContext.stop();	this.managementContext = null;	}	} catch (Exception e) {	
transportloggerfactory could not be stopped reason 

========================= activemq sample_4153 =========================

protected void testAsyncNetworkStartup(String transport) throws Exception {	String brokerBUri = transport + ": String brokerCUri = transport + ": BrokerService brokerA = brokers.get("BrokerA").broker;	bridgeBroker(brokerA, brokerBUri);	bridgeBroker(brokerA, brokerCUri);	
starting a no blocking on failed network connectors 

protected void testAsyncNetworkStartup(String transport) throws Exception {	String brokerBUri = transport + ": String brokerCUri = transport + ": BrokerService brokerA = brokers.get("BrokerA").broker;	bridgeBroker(brokerA, brokerBUri);	bridgeBroker(brokerA, brokerCUri);	brokerA.start();	
starting c transport connector 

protected void testAsyncNetworkStartup(String transport) throws Exception {	String brokerBUri = transport + ": String brokerCUri = transport + ": BrokerService brokerA = brokers.get("BrokerA").broker;	bridgeBroker(brokerA, brokerBUri);	bridgeBroker(brokerA, brokerCUri);	brokerA.start();	BrokerService brokerC = brokers.get("BrokerC").broker;	brokerC.addConnector(brokerCUri);	brokerC.start();	assertTrue("got bridge to C", waitForBridgeFormation(brokerA, 1, 1));	
got bridge a c 

protected void testAsyncNetworkStartup(String transport) throws Exception {	String brokerBUri = transport + ": String brokerCUri = transport + ": BrokerService brokerA = brokers.get("BrokerA").broker;	bridgeBroker(brokerA, brokerBUri);	bridgeBroker(brokerA, brokerCUri);	brokerA.start();	BrokerService brokerC = brokers.get("BrokerC").broker;	brokerC.addConnector(brokerCUri);	brokerC.start();	assertTrue("got bridge to C", waitForBridgeFormation(brokerA, 1, 1));	
starting b transport connector 

bridgeBroker(brokerA, proxyToB.getUrl().toString());	bridgeBroker(brokerA, proxyToB.getUrl().toString());	bridgeBroker(brokerA, proxyToB.getUrl().toString());	bridgeBroker(brokerA, proxyToB.getUrl().toString());	bridgeBroker(brokerA, proxyToB.getUrl().toString());	bridgeBroker(brokerA, proxyToB.getUrl().toString());	bridgeBroker(brokerA, brokerCUri);	Executor e = Executors.newCachedThreadPool();	e.execute(new Runnable() {	public void run() {	
starting a 

bridgeBroker(brokerA, proxyToB.getUrl().toString());	bridgeBroker(brokerA, proxyToB.getUrl().toString());	bridgeBroker(brokerA, brokerCUri);	Executor e = Executors.newCachedThreadPool();	e.execute(new Runnable() {	public void run() {	try {	brokerA.setNetworkConnectorStartAsync(true);	brokerA.start();	} catch (Exception e) {	
start failed 

Executor e = Executors.newCachedThreadPool();	e.execute(new Runnable() {	public void run() {	try {	brokerA.setNetworkConnectorStartAsync(true);	brokerA.start();	} catch (Exception e) {	}	}	});	
starting transport connector on c 

========================= activemq sample_3696 =========================

public void onWebSocketBinary(byte[] payload, int offset, int length) {	if (!transportStartedAtLeastOnce()) {	
waiting for websocket to be properly started 

public void onWebSocketBinary(byte[] payload, int offset, int length) {	if (!transportStartedAtLeastOnce()) {	try {	socketTransportStarted.await();	} catch (InterruptedException e) {	
while waiting for websocket to be properly started we got interrupted should be okay but you could see race conditions 

public void onWebSocketText(String data) {	if (!transportStartedAtLeastOnce()) {	
waiting for websocket to be properly started 

public void onWebSocketText(String data) {	if (!transportStartedAtLeastOnce()) {	try {	socketTransportStarted.await();	} catch (InterruptedException e) {	
while waiting for websocket to be properly started we got interrupted should be okay but you could see race conditions 

public void onWebSocketClose(int statusCode, String reason) {	try {	if (protocolLock.tryLock() || protocolLock.tryLock(ORDERLY_CLOSE_TIMEOUT, TimeUnit.SECONDS)) {	
websocket closed code message 

public void onWebSocketClose(int statusCode, String reason) {	try {	if (protocolLock.tryLock() || protocolLock.tryLock(ORDERLY_CLOSE_TIMEOUT, TimeUnit.SECONDS)) {	wsTransport.onWebSocketClosed();	}	} catch (Exception e) {	
failed to close websocket cleanly 

public void onSocketOutboundText(String data) throws IOException {	if (!transportStartedAtLeastOnce()) {	
waiting for websocket to be properly started 

public void onSocketOutboundText(String data) throws IOException {	if (!transportStartedAtLeastOnce()) {	try {	socketTransportStarted.await();	} catch (InterruptedException e) {	
while waiting for websocket to be properly started we got interrupted should be okay but you could see race conditions 

public void onSocketOutboundText(String data) throws IOException {	if (!transportStartedAtLeastOnce()) {	try {	socketTransportStarted.await();	} catch (InterruptedException e) {	}	}	
ws proxy sending string of size out 

public void onSocketOutboundBinary(ByteBuffer data) throws IOException {	if (!transportStartedAtLeastOnce()) {	
waiting for websocket to be properly started 

public void onSocketOutboundBinary(ByteBuffer data) throws IOException {	if (!transportStartedAtLeastOnce()) {	try {	socketTransportStarted.await();	} catch (InterruptedException e) {	
while waiting for websocket to be properly started we got interrupted should be okay but you could see race conditions 

public void onSocketOutboundBinary(ByteBuffer data) throws IOException {	if (!transportStartedAtLeastOnce()) {	try {	socketTransportStarted.await();	} catch (InterruptedException e) {	}	}	
ws proxy sending bytes out 

========================= activemq sample_1146 =========================

executorService.execute(new Runnable() {	public void run() {	try {	MQTT mqtt = createMQTTConnection();	mqtt.setClientId("client-" + clientIdGemeratpr.incrementAndGet());	mqtt.setCleanSession(true);	BlockingConnection connection = mqtt.blockingConnection();	connection.connect();	connection.disconnect();	} catch (Exception e) {	
unexpected exception on connect disconnect 

public void testInactivityMonitor() throws Exception {	Thread t1 = new Thread() {	public void run() {	try {	connection = createConnection();	connection.getOutputStream().write(0);	connection.getOutputStream().flush();	} catch (Exception ex) {	
unexpected exception on connect disconnect 

========================= activemq sample_888 =========================

public void testCannotUseMessageListener() throws Exception {	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createConsumer(queue);	MessageListener listener = new SpringConsumer();	try {	consumer.setMessageListener(listener);	fail("Should have thrown JMSException as we cannot use MessageListener with zero prefetch");	} catch (JMSException e) {	
received expected exception 

========================= activemq sample_2290 =========================

public void testOrder() throws Exception {	
producing messages 

public void testOrder() throws Exception {	Destination destination = session.createQueue(DESTINATION);	final MessageProducer messageProducer = session .createProducer(destination);	try {	for (int i = 0; i < 30; ++i) {	final Message message = session .createTextMessage(createMessageText(i));	message.setStringProperty("JMSXGroupID", "FOO");	messageProducer.send(message);	
sent 

final MessageProducer messageProducer = session .createProducer(destination);	try {	for (int i = 0; i < 30; ++i) {	final Message message = session .createTextMessage(createMessageText(i));	message.setStringProperty("JMSXGroupID", "FOO");	messageProducer.send(message);	}	} finally {	messageProducer.close();	}	
consuming messages 

try {	for (int i = 0; i < 30; ++i) {	final Message message = session .createTextMessage(createMessageText(i));	message.setStringProperty("JMSXGroupID", "FOO");	messageProducer.send(message);	}	} finally {	messageProducer.close();	}	consumeBatch();	
consuming messages 

for (int i = 0; i < 30; ++i) {	final Message message = session .createTextMessage(createMessageText(i));	message.setStringProperty("JMSXGroupID", "FOO");	messageProducer.send(message);	}	} finally {	messageProducer.close();	}	consumeBatch();	consumeBatch();	
consuming messages 

protected void consumeBatch() throws Exception {	Destination destination = session.createQueue(DESTINATION);	final MessageConsumer messageConsumer = session.createConsumer(destination);	try {	for (int i = 0; i < 10; ++i) {	final Message message = messageConsumer.receive(1000L);	
received 

========================= activemq sample_2785 =========================

assertEquals(outbound[0], consumer.receive(1000));	consumer.close();	QueueBrowser browser = session.createBrowser(destination);	Enumeration<?> enumeration = browser.getEnumeration();	assertTrue("should have received the second message", enumeration.hasMoreElements());	assertEquals(outbound[1], enumeration.nextElement());	assertTrue("Should have received the third message", enumeration.hasMoreElements());	assertEquals(outbound[2], enumeration.nextElement());	boolean tooMany = false;	while (enumeration.hasMoreElements()) {	
got extra message 

for (int i=0; i<10; i++) {	outbound[i] = session.createTextMessage( i + " Message");	};	while (consumer.receive(1000) != null) {	}	consumer.close();	for (int i=0;i<outbound.length; i++) {	producer.send(outbound[i]);	}	ObjectName queueViewMBeanName = new ObjectName("org.apache.activemq:type=Broker,brokerName=localhost,destinationType=Queue,destinationName=TEST");	
create queueview mbean 

};	while (consumer.receive(1000) != null) {	}	consumer.close();	for (int i=0;i<outbound.length; i++) {	producer.send(outbound[i]);	}	ObjectName queueViewMBeanName = new ObjectName("org.apache.activemq:type=Broker,brokerName=localhost,destinationType=Queue,destinationName=TEST");	QueueViewMBean proxy = (QueueViewMBean) broker.getManagementContext().newProxyInstance(queueViewMBeanName, QueueViewMBean.class, true);	long concount = proxy.getConsumerCount();	
consumer count 

while (consumer.receive(1000) != null) {	}	consumer.close();	for (int i=0;i<outbound.length; i++) {	producer.send(outbound[i]);	}	ObjectName queueViewMBeanName = new ObjectName("org.apache.activemq:type=Broker,brokerName=localhost,destinationType=Queue,destinationName=TEST");	QueueViewMBean proxy = (QueueViewMBean) broker.getManagementContext().newProxyInstance(queueViewMBeanName, QueueViewMBean.class, true);	long concount = proxy.getConsumerCount();	long messcount = proxy.getQueueSize();	
current number of messages in the queue 

long concount = proxy.getConsumerCount();	long messcount = proxy.getQueueSize();	CompositeData[] compdatalist = proxy.browse();	if (compdatalist.length == 0) {	fail("There is no message in the queue:");	}	String[] messageIDs = new String[compdatalist.length];	for (int i = 0; i < compdatalist.length; i++) {	CompositeData cdata = compdatalist[i];	if (i == 0) {	
columns 

CompositeData[] compdatalist = proxy.browse();	if (compdatalist.length == 0) {	fail("There is no message in the queue:");	}	String[] messageIDs = new String[compdatalist.length];	for (int i = 0; i < compdatalist.length; i++) {	CompositeData cdata = compdatalist[i];	if (i == 0) {	}	messageIDs[i] = (String)cdata.get("JMSMessageID");	
message 

fail("There is no message in the queue:");	}	String[] messageIDs = new String[compdatalist.length];	for (int i = 0; i < compdatalist.length; i++) {	CompositeData cdata = compdatalist[i];	if (i == 0) {	}	messageIDs[i] = (String)cdata.get("JMSMessageID");	}	TabularData table = proxy.browseAsTable();	
found tabular data 

CompositeData cdata = compdatalist[i];	if (i == 0) {	}	messageIDs[i] = (String)cdata.get("JMSMessageID");	}	TabularData table = proxy.browseAsTable();	assertTrue("Table should not be empty!", table.size() > 0);	assertEquals("Queue size", outbound.length, proxy.getQueueSize());	assertEquals("Queue size", outbound.length, compdatalist.length);	assertEquals("Queue size", outbound.length, table.size());	
send another 

messageIDs[i] = (String)cdata.get("JMSMessageID");	}	TabularData table = proxy.browseAsTable();	assertTrue("Table should not be empty!", table.size() > 0);	assertEquals("Queue size", outbound.length, proxy.getQueueSize());	assertEquals("Queue size", outbound.length, compdatalist.length);	assertEquals("Queue size", outbound.length, table.size());	for (int i=0;i<outbound.length; i++) {	producer.send(outbound[i]);	}	
browse again 

}	TabularData table = proxy.browseAsTable();	assertTrue("Table should not be empty!", table.size() > 0);	assertEquals("Queue size", outbound.length, proxy.getQueueSize());	assertEquals("Queue size", outbound.length, compdatalist.length);	assertEquals("Queue size", outbound.length, table.size());	for (int i=0;i<outbound.length; i++) {	producer.send(outbound[i]);	}	messcount = proxy.getQueueSize();	
current number of messages in the queue 

}	messcount = proxy.getQueueSize();	compdatalist = proxy.browse();	if (compdatalist.length == 0) {	fail("There is no message in the queue:");	}	messageIDs = new String[compdatalist.length];	for (int i = 0; i < compdatalist.length; i++) {	CompositeData cdata = compdatalist[i];	if (i == 0) {	
columns 

compdatalist = proxy.browse();	if (compdatalist.length == 0) {	fail("There is no message in the queue:");	}	messageIDs = new String[compdatalist.length];	for (int i = 0; i < compdatalist.length; i++) {	CompositeData cdata = compdatalist[i];	if (i == 0) {	}	messageIDs[i] = (String)cdata.get("JMSMessageID");	
message 

fail("There is no message in the queue:");	}	messageIDs = new String[compdatalist.length];	for (int i = 0; i < compdatalist.length; i++) {	CompositeData cdata = compdatalist[i];	if (i == 0) {	}	messageIDs[i] = (String)cdata.get("JMSMessageID");	}	table = proxy.browseAsTable();	
found tabular data 

for (int i = 0; i < numberOfMessages; i++) {	producer.send(session.createTextMessage("Message: "  + i));	}	QueueBrowser browser = session.createBrowser(destination);	Enumeration<?> enumeration = browser.getEnumeration();	assertTrue(enumeration.hasMoreElements());	int numberBrowsed = 0;	while (enumeration.hasMoreElements()) {	Message browsed = (Message) enumeration.nextElement();	if (LOG.isDebugEnabled()) {	
browsed message 

========================= activemq sample_3747 =========================

Topic topic = consumerSession.createTopic(topicName);	consumerConnection.start();	MessageConsumer consumer = consumerSession.createDurableSubscriber(topic, consumerName);	counsumerStarted.countDown();	Message msg = null;	do {	msg = consumer.receive(5000);	if (msg != null) {	receivedCount.incrementAndGet();	if (received != 0 && received % 100 == 0) {	
received msg 

((ActiveMQConnection) producerConnection).setWatchTopicAdvisories(false);	Session producerSession = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Topic topic = producerSession.createTopic(topicName);	MessageProducer producer = producerSession.createProducer(topic);	producerConnection.start();	for (int i = 0; i < numMessages; i++) {	BytesMessage msg = producerSession.createBytesMessage();	msg.writeBytes(payload);	producer.send(msg);	if (i != 0 && i % 100 == 0) {	
sent msg 

BytesMessage msg = producerSession.createBytesMessage();	msg.writeBytes(payload);	producer.send(msg);	if (i != 0 && i % 100 == 0) {	}	}	executor.shutdown();	executor.awaitTermination(30, TimeUnit.SECONDS);	Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception{	
receivedcount 

broker.start();	Connection producerConnection = factory.createConnection();	Session producerSession = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = producerSession.createProducer(topic);	producerConnection.start();	for (int i = 0; i < COUNT; i++) {	BytesMessage msg = producerSession.createBytesMessage();	msg.writeBytes(payload);	producer.send(msg);	if (i != 0 && i % 1000 == 0) {	
sent msg 

broker.start();	consumerConnection = factory.createConnection();	consumerConnection.setClientID(CONSUMER_NAME);	consumerConnection.start();	consumerSession = consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	consumer = consumerSession.createDurableSubscriber(topic, CONSUMER_NAME);	for (int i = 0; i < COUNT; i++) {	Message msg = consumer.receive(10000);	assertNotNull("Missing message: " + i, msg);	if (i != 0 && i % 1000 == 0) {	
received msg 

========================= activemq sample_2910 =========================

public void testBrokers() throws Exception {	int X = 20;	int i;	
creating x brokers 

public void testBrokers() throws Exception {	int X = 20;	int i;	for (i = 0; i < X; i++) {	createBroker("Broker" + i);	}	bridgeAllBrokers();	startAllBrokers();	waitForBridgeFormation(X-1);	
waiting for complete formation 

createBroker("Broker" + i);	}	bridgeAllBrokers();	startAllBrokers();	waitForBridgeFormation(X-1);	try {	Thread.sleep(20000);	} catch (Exception e) {	}	verifyPeerBrokerInfos(X-1);	
stopping half the brokers 

startAllBrokers();	waitForBridgeFormation(X-1);	try {	Thread.sleep(20000);	} catch (Exception e) {	}	verifyPeerBrokerInfos(X-1);	for (i = 0; i < X/2; i++) {	destroyBroker("Broker" + i);	}	
waiting for complete stop 

}	verifyPeerBrokerInfos(X-1);	for (i = 0; i < X/2; i++) {	destroyBroker("Broker" + i);	}	try {	Thread.sleep(20000);	} catch (Exception e) {	}	verifyPeerBrokerInfos((X/2) - 1);	
recreating first half 

Thread.sleep(20000);	} catch (Exception e) {	}	verifyPeerBrokerInfos((X/2) - 1);	for (i = 0; i < X/2; i++) {	createBroker("Broker" + i);	}	bridgeAllBrokers();	startAllBrokers();	waitForBridgeFormation(X-1);	
waiting for complete reformation 

private void verifyPeerBrokerInfo(BrokerItem brokerItem, final int max) throws Exception {	final BrokerService broker = brokerItem.broker;	final RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
verify infos len 

private void verifyPeerBrokerInfo(BrokerItem brokerItem, final int max) throws Exception {	final BrokerService broker = brokerItem.broker;	final RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return max == regionBroker.getPeerBrokerInfos().length;	}	}, 120 * 1000);	
verify infos len 

========================= activemq sample_3602 =========================

protected void doTest() throws Exception {	messageCount = 200;	connection.start();	ActiveMQConnection amqConnection = (ActiveMQConnection) connection;	rollbackCount = amqConnection.getRedeliveryPolicy().getMaximumRedeliveries() + 1;	
will redeliver messages times 

protected void makeDlqConsumer() throws JMSException {	dlqDestination = createDlqDestination();	
consuming from dead letter on 

public void onMessage(Message message) {	try {	int expectedMessageId = rollbacks.get() / deliveryCount;	
expecting messageid 

public void onMessage(Message message) {	try {	int expectedMessageId = rollbacks.get() / deliveryCount;	assertMessage(message, expectedMessageId);	if (rollbacks.incrementAndGet() > maxRollbacks) {	fail("received too many messages, already done too many rollbacks: " + rollbacks);	}	session.rollback();	} catch (Throwable e) {	
unexpected exception 

========================= activemq sample_2443 =========================

public void testBrowseByteMessageFails() throws Exception {	ActiveMQBytesMessage bm = new ActiveMQBytesMessage();	bm.writeBytes("123456".getBytes());	Object result = OpenTypeSupport.convert(bm);	
result 

========================= activemq sample_2697 =========================

if (t > 0) {	metadata.binsActive++;	}	metadata.size += t;	}	}	}	calcThresholds();	metadata.state = OPEN_STATE;	tx.store(metadataPage, metadataMarshaller, true);	
hashindex loaded using bins starting at page 

private void resize(Transaction tx, final int newSize) throws IOException {	
resizing to 

metadata.binsActive++;	}	}	}	tx.free(metadata.binPageId, metadata.binCapacity);	metadata.binCapacity = resizeCapacity;	metadata.binPageId = resizePageId;	metadata.state = OPEN_STATE;	tx.store(metadata.page, metadataMarshaller, true);	calcThresholds();	
resizing done new bins start at 

========================= activemq sample_1812 =========================

protected BrokerService createBroker(String uri) throws Exception {	
loading broker configuration from the classpath with uri 

public void testConnectionStartThrowsJMSSecurityException() throws Exception {	Connection connection = factory.createConnection("badUser", "password");	try {	connection.start();	fail("Should throw JMSSecurityException");	} catch (JMSSecurityException jmsEx) {	} catch (Exception e) {	
expected jmssecurityexception but was 

public void testSecurityContextClearedOnPurge() throws Exception {	connection.close();	ActiveMQConnectionFactory tcpFactory = new ActiveMQConnectionFactory(broker.getTransportConnectors().get(0).getPublishableConnectString());	ActiveMQConnection conn = (ActiveMQConnection) tcpFactory.createConnection("user", "password");	Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	conn.start();	
dest list at start 

ActiveMQConnection conn = (ActiveMQConnection) tcpFactory.createConnection("user", "password");	Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	conn.start();	final int numDests = broker.getRegionBroker().getDestinations().length;	for (int i=0; i<10; i++) {	MessageProducer p = sess.createProducer(new ActiveMQQueue("USERS.PURGE." + i));	p.close();	}	assertTrue("dests are purged", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
dest list 

ActiveMQConnection conn = (ActiveMQConnection) tcpFactory.createConnection("user", "password");	Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	conn.start();	final int numDests = broker.getRegionBroker().getDestinations().length;	for (int i=0; i<10; i++) {	MessageProducer p = sess.createProducer(new ActiveMQQueue("USERS.PURGE." + i));	p.close();	}	assertTrue("dests are purged", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
dests orig now 

========================= activemq sample_2678 =========================

connection.send(message);	connection.send(createPrepareTransaction(connectionInfo, txid));	}	Response response = connection.request(new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER));	assertNotNull(response);	DataArrayResponse dar = (DataArrayResponse)response;	assertEquals(4, dar.getData().length);	if (broker.getPersistenceAdapter() instanceof KahaDBPersistenceAdapter) {	PersistenceAdapterViewMBean kahadbView = getProxyToPersistenceAdapter(broker.getPersistenceAdapter().toString());	String txFromView = kahadbView.getTransactions();	
tx view fromm pa 

connection.request(closeConnectionInfo(connectionInfo));	connection = createConnection();	connectionInfo = createConnectionInfo();	sessionInfo = createSessionInfo(connectionInfo);	connection.send(connectionInfo);	connection.send(sessionInfo);	consumerInfo = createConsumerInfo(sessionInfo, destination);	connection.send(consumerInfo);	for (int i = 0; i < dar.getData().length; i++) {	TransactionId transactionId = (TransactionId) dar.getData()[i];	
commit 

connection.send(sessionInfo);	consumerInfo = createConsumerInfo(sessionInfo, destination);	connection.send(consumerInfo);	for (int i = 0; i < dar.getData().length; i++) {	TransactionId transactionId = (TransactionId) dar.getData()[i];	connection.request(createCommitTransaction2Phase(connectionInfo, transactionId));	}	final int countToReceive = expectedMessageCount(4, destination);	for (int i = 0; i < countToReceive ; i++) {	Message m = receiveMessage(connection, TimeUnit.SECONDS.toMillis(10));	
received 

connection = createConnection();	connectionInfo = createConnectionInfo();	sessionInfo = createSessionInfo(connectionInfo);	connection.send(connectionInfo);	connection.send(sessionInfo);	consumerInfo = createConsumerInfo(sessionInfo, destination);	connection.send(consumerInfo);	int countToReceive = expectedMessageCount(1, destination);	for (int i=0; i< countToReceive; i++) {	Message m = receiveMessage(connection, TimeUnit.SECONDS.toMillis(10));	
received 

DataArrayResponse dar = (DataArrayResponse)response;	assertEquals(4, dar.getData().length);	connection.request(closeConnectionInfo(connectionInfo));	connection = createConnection();	connectionInfo = createConnectionInfo();	sessionInfo = createSessionInfo(connectionInfo);	connection.send(connectionInfo);	connection.send(sessionInfo);	for (int i = 0; i < dar.getData().length; i++) {	TransactionId transactionId = (TransactionId) dar.getData()[i];	
commit 

connection.send(sessionInfo);	for (int i = 0; i < dar.getData().length; i++) {	TransactionId transactionId = (TransactionId) dar.getData()[i];	connection.request(createCommitTransaction2Phase(connectionInfo, transactionId));	}	consumerInfo = createConsumerInfo(sessionInfo, destination);	connection.send(consumerInfo);	countToReceive = expectedMessageCount(5, destination);	for (int i = 0; i < countToReceive ; i++) {	Message m = receiveMessage(connection, TimeUnit.SECONDS.toMillis(10));	
received 

assertEquals("there is a prepared tx", 1, dataArrayResponse.getData().length);	assertEquals("it matches", txid, dataArrayResponse.getData()[0]);	sessionInfo = createSessionInfo(connectionInfo);	connection.send(sessionInfo);	consumerInfo = createConsumerInfo(sessionInfo, destination);	connection.send(consumerInfo);	message = receiveMessage(connection);	assertNull(message);	assertNoMessagesLeft(connection);	connection.request(createRollbackTransaction(connectionInfo, txid));	
new tx for redelivery 

assertEquals("there is a prepared tx", 1, dataArrayResponse.getData().length);	assertEquals("it matches", txid, dataArrayResponse.getData()[0]);	connection.send(sessionInfo);	for (ConsumerInfo info : consumerInfos) {	connection.send(info);	}	message = receiveMessage(connection);	assertNull(message);	assertNoMessagesLeft(connection);	connection.request(createRollbackTransaction(connectionInfo, txid));	
new tx for redelivery 

assertEquals("it matches", txid, dataArrayResponse.getData()[0]);	sessionInfo = createSessionInfo(connectionInfo);	connection.send(sessionInfo);	consumerInfo = createConsumerInfo(sessionInfo, destination);	consumerInfo.setSubscriptionName("durable");	connection.send(consumerInfo);	message = receiveMessage(connection);	assertNull(message);	assertNoMessagesLeft(connection);	connection.request(createRollbackTransaction(connectionInfo, txid));	
new tx for redelivery 

Message message = null;	for (int i = 0; i < numMessages; i++) {	message = receiveMessage(connection);	assertNotNull(message);	}	MessageAck ack = createAck(consumerInfo, message, numMessages, MessageAck.STANDARD_ACK_TYPE);	ack.setTransactionId(txid);	connection.send(ack);	connection.request(createPrepareTransaction(connectionInfo, txid));	connection.request(createRollbackTransaction(connectionInfo, txid));	
new consumer tx for redelivery 

========================= activemq sample_2382 =========================

private void createProducerAndSendMessages(int numToSend) throws Exception {	queue = session.createQueue("test1");	MessageProducer producer = session.createProducer(queue);	for (int i = 0; i < numToSend; i++) {	TextMessage message = session.createTextMessage(MESSAGE_TEXT + i);	if (i  != 0 && i % 50000 == 0) {	
sent 

========================= activemq sample_2802 =========================

sendMessages(name.getMethodName(), MSG_COUNT, false);	QueueViewMBean proxy = getProxyToQueue(getDestinationName());	assertEquals(MSG_COUNT, proxy.getQueueSize());	QueueBrowser browser = session.createBrowser(queue);	assertNotNull(browser);	Enumeration<?> enumeration = browser.getEnumeration();	int count = 0;	while (count < MSG_COUNT && enumeration.hasMoreElements()) {	Message msg = (Message) enumeration.nextElement();	assertNotNull(msg);	
recv 

assertEquals(MSG_COUNT, proxy.getQueueSize());	QueueBrowser browser = session.createBrowser(queue);	assertNotNull(browser);	Enumeration<?> enumeration = browser.getEnumeration();	int count = 0;	while (count < MSG_COUNT && enumeration.hasMoreElements()) {	Message msg = (Message) enumeration.nextElement();	assertNotNull(msg);	count++;	}	
received all expected message checking that hasmoreelements returns false 

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue(getDestinationName());	MessageProducer producer = session.createProducer(queue);	producer.send(session.createTextMessage("hello"));	producer.close();	QueueBrowser browser = session.createBrowser(queue);	Enumeration<?> enumeration = browser.getEnumeration();	while (enumeration.hasMoreElements()) {	Message m = (Message) enumeration.nextElement();	assertTrue(m instanceof TextMessage);	
browsed message from queue 

sendMessages(name.getMethodName(), 5, false);	QueueViewMBean proxy = getProxyToQueue(getDestinationName());	assertEquals(5, proxy.getQueueSize());	QueueBrowser browser = session.createBrowser(queue);	assertNotNull(browser);	Enumeration<?> enumeration = browser.getEnumeration();	int count = 0;	while (enumeration.hasMoreElements()) {	Message msg = (Message) enumeration.nextElement();	assertNotNull(msg);	
recv 

sendMessages(name.getMethodName(), 5, false);	QueueViewMBean proxy = getProxyToQueue(getDestinationName());	assertEquals(5, proxy.getQueueSize());	QueueBrowser browser = session.createBrowser(queue);	assertNotNull(browser);	Enumeration<?> enumeration = browser.getEnumeration();	int count = 0;	while (enumeration.hasMoreElements()) {	Message msg = (Message) enumeration.nextElement();	assertNotNull(msg);	
recv 

sendMessages(name.getMethodName(), 5, false);	QueueViewMBean proxy = getProxyToQueue(getDestinationName());	assertEquals(5, proxy.getQueueSize());	QueueBrowser browser = session.createBrowser(queue);	assertNotNull(browser);	Enumeration<?> enumeration = browser.getEnumeration();	int count = 0;	while (enumeration.hasMoreElements()) {	Message msg = (Message) enumeration.nextElement();	assertNotNull(msg);	
recv 

txProducer.send(session.createMessage());	}	assertEquals(5, proxy.getQueueSize());	QueueBrowser browser = session.createBrowser(queue);	assertNotNull(browser);	Enumeration<?> enumeration = browser.getEnumeration();	int count = 0;	while (enumeration.hasMoreElements()) {	Message msg = (Message) enumeration.nextElement();	assertNotNull(msg);	
recv 

sendMessages(name.getMethodName(), MSG_COUNT, false);	QueueViewMBean proxy = getProxyToQueue(getDestinationName());	assertEquals(MSG_COUNT, proxy.getQueueSize());	QueueBrowser browser = session.createBrowser(queue);	assertNotNull(browser);	Enumeration<?> enumeration = browser.getEnumeration();	int count = 0;	while (enumeration.hasMoreElements()) {	Message msg = (Message) enumeration.nextElement();	assertNotNull(msg);	
recv 

========================= activemq sample_1668 =========================

public void testRejectInvalidHeartbeats1() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "heart-beat:0\n" + "host:localhost\n" + "\n" + Stomp.NULL;	wsStompConnection.sendRawFrame(connectFrame);	try {	String incoming = wsStompConnection.receive(30, TimeUnit.SECONDS);	assertTrue(incoming.startsWith("ERROR"));	assertTrue(incoming.indexOf("heart-beat") >= 0);	assertTrue(incoming.indexOf("message:") >= 0);	} catch (IOException ex) {	
connection closed before frame was read 

public void testRejectInvalidHeartbeats2() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "heart-beat:T,0\n" + "host:localhost\n" + "\n" + Stomp.NULL;	wsStompConnection.sendRawFrame(connectFrame);	try {	String incoming = wsStompConnection.receive(30, TimeUnit.SECONDS);	assertTrue(incoming.startsWith("ERROR"));	assertTrue(incoming.indexOf("heart-beat") >= 0);	assertTrue(incoming.indexOf("message:") >= 0);	} catch (IOException ex) {	
connection closed before frame was read 

public void testRejectInvalidHeartbeats3() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "heart-beat:100,10,50\n" + "host:localhost\n" + "\n" + Stomp.NULL;	wsStompConnection.sendRawFrame(connectFrame);	try {	String incoming = wsStompConnection.receive(30, TimeUnit.SECONDS);	assertTrue(incoming.startsWith("ERROR"));	assertTrue(incoming.indexOf("heart-beat") >= 0);	assertTrue(incoming.indexOf("message:") >= 0);	} catch (IOException ex) {	
connection closed before frame was read 

assertTrue(incoming.startsWith("CONNECTED"));	assertTrue(incoming.indexOf("version:1.1") >= 0);	assertTrue(incoming.indexOf("heart-beat:") >= 0);	assertTrue(incoming.indexOf("session:") >= 0);	String message = "SEND\n" + "destination:/queue/" + getTestName() + "\n\n" + "Hello World" + Stomp.NULL;	wsStompConnection.sendRawFrame(message);	ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();	service.scheduleAtFixedRate(new Runnable() {	public void run() {	try {	
sending next keepalive 

TimeUnit.SECONDS.sleep(15);	String frame = "SUBSCRIBE\n" + "destination:/queue/" + getTestName() + "\n" + "id:12345\n" + "ack:auto\n\n" + Stomp.NULL;	wsStompConnection.sendRawFrame(frame);	incoming = wsStompConnection.receive(30, TimeUnit.SECONDS);	assertTrue(incoming.startsWith("MESSAGE"));	service.shutdownNow();	service.awaitTermination(5, TimeUnit.SECONDS);	try {	wsStompConnection.sendFrame(new StompFrame(Stomp.Commands.DISCONNECT));	} catch (Exception ex) {	
caught exception on write of disconnect 

String message = "SEND\n" + "destination:/queue/" + getTestName() + "\nescaped-header:one\\ntwo\\cthree\n\n" + "Hello World" + Stomp.NULL;	wsStompConnection.sendRawFrame(message);	String frame = "SUBSCRIBE\n" + "destination:/queue/" + getTestName() + "\n" + "id:12345\n" + "ack:auto\n\n" + Stomp.NULL;	wsStompConnection.sendRawFrame(frame);	incoming = wsStompConnection.receive(30, TimeUnit.SECONDS);	assertTrue(incoming.startsWith("MESSAGE"));	assertTrue(incoming.indexOf("escaped-header:one\\ntwo\\cthree") >= 0);	try {	wsStompConnection.sendFrame(new StompFrame(Stomp.Commands.DISCONNECT));	} catch (Exception ex) {	
caught exception on write of disconnect 

========================= activemq sample_1107 =========================

protected void setUp() throws Exception {	
starting 

========================= activemq sample_826 =========================

protected boolean addToAlreadyInterestedConsumers(ConsumerInfo info, boolean isForcedDurable) {	if (info.isNetworkSubscription() && info.getDestination().isQueue() && !configuration.isConduitNetworkQueueSubscriptions()) {	return false;	}	boolean matched = false;	for (DemandSubscription ds : subscriptionMapByLocalId.values()) {	DestinationFilter filter = DestinationFilter.parseFilter(ds.getLocalInfo().getDestination());	if (canConduit(ds) && filter.matches(info.getDestination())) {	
with ids matched add interest 

protected void removeDemandSubscription(ConsumerId id) throws IOException {	List<DemandSubscription> tmpList = new ArrayList<DemandSubscription>();	for (DemandSubscription ds : subscriptionMapByLocalId.values()) {	if (ds.remove(id)) {	
on from removed interest for from 

for (DemandSubscription ds : subscriptionMapByLocalId.values()) {	if (ds.remove(id)) {	configuration.getBrokerName(), localBroker, remoteBrokerName, id, ds });	}	if (ds.isEmpty()) {	tmpList.add(ds);	}	}	for (DemandSubscription ds : tmpList) {	removeSubscription(ds);	
on from removed 

========================= activemq sample_4240 =========================

Thread.sleep(1000);	for (int i = 0; i < NMSG / 4; i++) {	BytesMessage message = session2.createBytesMessage();	message.writeBytes(new byte[MSIZE]);	message.setStringProperty("test", "test");	message.setIntProperty(COUNT_PROPERY_NAME, count);	message.setJMSType("test");	producer2.send(consumerDestination2, message);	Thread.sleep(50);	if (verbose) {	
sent 

========================= activemq sample_2814 =========================

public PersistenceAdapter setPersistenceAdapter(BrokerService broker, PersistenceAdapterChoice choice) throws IOException {	PersistenceAdapter adapter = null;	switch (choice) {	
setpersistenceadapter to jdbc 

public PersistenceAdapter setPersistenceAdapter(BrokerService broker, PersistenceAdapterChoice choice) throws IOException {	PersistenceAdapter adapter = null;	switch (choice) {	adapter = new JDBCPersistenceAdapter();	break;	
setpersistenceadapter to kahadb 

public PersistenceAdapter setPersistenceAdapter(BrokerService broker, PersistenceAdapterChoice choice) throws IOException {	PersistenceAdapter adapter = null;	switch (choice) {	adapter = new JDBCPersistenceAdapter();	break;	adapter = new KahaDBPersistenceAdapter();	break;	
setpersistenceadapter to leveldb 

public PersistenceAdapter setPersistenceAdapter(BrokerService broker, PersistenceAdapterChoice choice) throws IOException {	PersistenceAdapter adapter = null;	switch (choice) {	adapter = new JDBCPersistenceAdapter();	break;	adapter = new KahaDBPersistenceAdapter();	break;	adapter = new LevelDBPersistenceAdapter();	break;	
setpersistenceadapter to mem 

========================= activemq sample_3643 =========================

public static int kill(String threadName, boolean isStarredExp, String motivation) {	String me = "ThreadExplorer.kill: ";	if (logger.isDebugEnabled()) {	
entering with isstarred 

if (thread == null) continue;	boolean matches = false;	if (isStarredExp) {	Matcher matcher = mypattern.matcher(thread.getName().toLowerCase());	matches = matcher.matches();	}	else {	matches = (thread.getName().equalsIgnoreCase(threadName));	}	if (matches && (Thread.currentThread() != thread) && !thread.getName().equals("main")) {	
killing thread named 

}	else {	matches = (thread.getName().equalsIgnoreCase(threadName));	}	if (matches && (Thread.currentThread() != thread) && !thread.getName().equals("main")) {	ret++;	try {	thread.stop();	}	catch (ThreadDeath e) {	
thread already death 

========================= activemq sample_2951 =========================

public void testSendingToQueueIsMirrored() throws Exception {	if (connection == null) {	connection = createConnection();	}	connection.start();	ConsumerBean messageList = new ConsumerBean();	messageList.setVerbose(true);	Destination consumeDestination = createConsumeDestination();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	
consuming from 

connection = createConnection();	}	connection.start();	ConsumerBean messageList = new ConsumerBean();	messageList.setVerbose(true);	Destination consumeDestination = createConsumeDestination();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer c1 = session.createConsumer(consumeDestination);	c1.setMessageListener(messageList);	ActiveMQQueue sendDestination = new ActiveMQQueue(getQueueName());	
sending to 

MessageConsumer c1 = session.createConsumer(consumeDestination);	c1.setMessageListener(messageList);	ActiveMQQueue sendDestination = new ActiveMQQueue(getQueueName());	MessageProducer producer = session.createProducer(sendDestination);	assertNotNull(producer);	int total = 10;	for (int i = 0; i < total; i++) {	producer.send(session.createTextMessage("message: " + i));	}	messageList.assertMessagesArrived(total);	
received 

========================= activemq sample_2402 =========================

public void testFunctionCall() throws Exception {	Object filter = parse("REGEX('sales.*', group)");	assertTrue("expected type", filter instanceof BooleanFunctionCallExpr);	
function exp 

public void testParseXPath() throws Exception {	BooleanExpression filter = parse("XPATH ' assertTrue("Created XPath expression", filter instanceof XPathExpression);	
expression 

public void testParseWithParensAround() throws Exception {	String[] values = {"x = 1 and y = 2", "(x = 1) and (y = 2)", "((x = 1) and (y = 2))"};	for (int i = 0; i < values.length; i++) {	String value = values[i];	
parsing 

========================= activemq sample_2286 =========================

public void onWebSocketClose(int arg0, String arg1) {	try {	if (protocolLock.tryLock() || protocolLock.tryLock(ORDERLY_CLOSE_TIMEOUT, TimeUnit.SECONDS)) {	
stomp websocket closed code message 

public void onWebSocketClose(int arg0, String arg1) {	try {	if (protocolLock.tryLock() || protocolLock.tryLock(ORDERLY_CLOSE_TIMEOUT, TimeUnit.SECONDS)) {	protocolConverter.onStompCommand(new StompFrame(Stomp.Commands.DISCONNECT));	}	} catch (Exception e) {	
failed to close stomp websocket cleanly 

========================= activemq sample_1150 =========================

final AtomicInteger counter = new AtomicInteger(0);	final CountDownLatch closeDone = new CountDownLatch(1);	connection.start();	Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	destination = createDestination(session, ActiveMQDestination.QUEUE_TYPE);	sendMessages(session, destination, 2000);	final ActiveMQMessageConsumer consumer = (ActiveMQMessageConsumer)session.createConsumer(destination);	final Map<Thread, Throwable> exceptions = Collections.synchronizedMap(new HashMap<Thread, Throwable>());	Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {	public void uncaughtException(Thread t, Throwable e) {	
uncaught exception 

if (count == 590) {	consumer.close();	closeDone.countDown();	}	if (count % 200 == 0) {	try {	message.acknowledge();	} catch (IllegalStateException okForAck) {}	}	} catch (Exception e) {	
exception on close or ack 

connection.getPrefetchPolicy().setAll(1);	connection.setOptimizedMessageDispatch(false);	connection.start();	Session session = connection.createSession(false, ackMode);	destination = createDestination(session, destinationType);	MessageConsumer consumer = session.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message m) {	try {	TextMessage tm = (TextMessage)m;	
got in first listener 

connections.add(connection);	connection.getPrefetchPolicy().setAll(1);	connection.start();	final CountDownLatch done2 = new CountDownLatch(1);	session = connection.createSession(false, ackMode);	consumer = session.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message m) {	try {	TextMessage tm = (TextMessage)m;	
got in second listener 

consumer = session.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message m) {	try {	TextMessage tm = (TextMessage)m;	counter.incrementAndGet();	if (counter.get() == 4) {	done2.countDown();	}	} catch (Throwable e) {	
unexpected ex onmessage 

connection.getPrefetchPolicy().setAll(1);	connection.setOptimizedMessageDispatch(false);	connection.start();	Session session = connection.createSession(false, ackMode);	destination = createDestination(session, destinationType);	MessageConsumer consumer = session.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message m) {	try {	TextMessage tm = (TextMessage)m;	
got in first listener 

connections.add(connection);	connection.getPrefetchPolicy().setAll(1);	connection.start();	final CountDownLatch done2 = new CountDownLatch(1);	session = connection.createSession(false, ackMode);	consumer = session.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message m) {	try {	TextMessage tm = (TextMessage)m;	
got in second listener 

consumer = session.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message m) {	try {	TextMessage tm = (TextMessage)m;	counter.incrementAndGet();	if (counter.get() == 4) {	done2.countDown();	}	} catch (Throwable e) {	
unexpected ex onmessage 

========================= activemq sample_3478 =========================

try {	if (location.exists()) {	reader = new BufferedReader(new FileReader(location));	String destination;	Broker broker = getBrokerService().getBroker();	while ((destination = reader.readLine()) != null) {	broker.addDestination(getBrokerService().getAdminConnectionContext(), ActiveMQDestination.createDestination(destination, ActiveMQDestination.QUEUE_TYPE), true);	}	}	} catch (Exception e) {	
exception loading destinations 

protected void exportDestinations() throws Exception {	PrintWriter pw = null;	try {	location.getParentFile().mkdirs();	FileOutputStream fos = new FileOutputStream(location);	pw = new PrintWriter(fos);	for (ActiveMQDestination destination : destinations) {	pw.println(destination);	}	} catch (Exception e) {	
exception saving destinations 

========================= activemq sample_3881 =========================

public void onMessage(Message message) {	receivedMessages.release();	if (count.incrementAndGet() % 100 == 0) {	
received message 

producer = session.createProducer(session.createQueue("AMQ2401Test"));	}	public void start() {	thread.start();	}	public void run() {	int i = 1;	for (; i <= TO_SEND; i++) {	try {	if (+i % 100 == 0) {	
sending message 

}	message = session.createBytesMessage();	message.writeBytes(new byte[1024]);	producer.setDeliveryMode(deliveryMode);	producer.send(message);	} catch (JMSException jmse) {	jmse.printStackTrace();	break;	}	}	
sent 

========================= activemq sample_2793 =========================

consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	MessageConsumer consumer = createConsumer();	connection.start();	for (int i = 0; i < data.length; i++) {	Message message = session.createTextMessage(data[i]);	message.setStringProperty("stringProperty", data[i]);	message.setIntProperty("intProperty", i);	if (verbose) {	if (LOG.isDebugEnabled()) {	
about to send a queue message with text 

dlqMessages.add(received);	};	assertEquals("got dlq messages", data.length - 1, dlqMessages.size());	final DestinationStatistics view = getDestinationStatistics(BrokerRegistry.getInstance().findFirst(), ActiveMQDestination.transform(consumerDestination));	assertTrue("all inflight messages expired ", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return view.getInflight().getCount() == 0;	}	}));	assertEquals("Wrong inFlightCount: ", 0, view.getInflight().getCount());	
stats received messages enqueues dequeues dispatched inflight expired 

consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	MessageConsumer consumer = createConsumer();	connection.start();	for (int i = 0; i < data.length; i++) {	Message message = session.createTextMessage(data[i]);	message.setStringProperty("stringProperty", data[i]);	message.setIntProperty("intProperty", i);	if (verbose) {	if (LOG.isDebugEnabled()) {	
about to send a queue message with text 

consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	MessageConsumer consumer = createConsumer();	connection.start();	for (int i = 0; i < data.length; i++) {	Message message = session.createTextMessage(data[i]);	message.setStringProperty("stringProperty", data[i]);	message.setIntProperty("intProperty", i);	if (verbose) {	if (LOG.isDebugEnabled()) {	
about to send a topic message with text 

consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	MessageConsumer consumer = createConsumer();	connection.start();	for (int i = 0; i < data.length; i++) {	Message message = session.createTextMessage(data[i]);	message.setStringProperty("stringProperty", data[i]);	message.setIntProperty("intProperty", i);	if (verbose) {	if (LOG.isDebugEnabled()) {	
about to send a topic message with text 

protected MessageConsumer createConsumer() throws JMSException {	if (durable) {	
creating durable consumer 

protected void tearDown() throws Exception {	
dumping stats 

protected void tearDown() throws Exception {	
closing down connection 

========================= activemq sample_2639 =========================

public Boolean call() {	Session one = null;	try {	if (PooledConnectionFactoryMaximumActiveTest.conn == null) {	
connection not yet initialized aborting test 

public Boolean call() {	Session one = null;	try {	if (PooledConnectionFactoryMaximumActiveTest.conn == null) {	return new Boolean(false);	}	one = PooledConnectionFactoryMaximumActiveTest.conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	
created new session with id 

========================= activemq sample_1296 =========================

public void testNoThreadLeak() throws Exception {	Thread[] threads = filterDaemonThreads(ThreadExplorer.listThreads());	final int originalThreadCount = threads.length;	
threads at beginning 

broker.setPersistent(false);	broker.addConnector("tcp: broker.start();	cf = new ActiveMQConnectionFactory("tcp: connection = cf.createConnection("system", "manager");	connection.start();	connection.close();	broker.stop();	broker.waitUntilStopped();	final AtomicInteger threadCountAfterStop = new AtomicInteger();	boolean ok = Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
active after stop 

public Thread[] filterDaemonThreads(Thread[] threads) throws Exception {	List<Thread> threadList = new ArrayList<Thread>(Arrays.asList(threads));	for (int i = 0 ; i < threadList.size(); i++) {	Thread thread = threadList.get(i);	
inspecting thread 

public Thread[] filterDaemonThreads(Thread[] threads) throws Exception {	List<Thread> threadList = new ArrayList<Thread>(Arrays.asList(threads));	for (int i = 0 ; i < threadList.size(); i++) {	Thread thread = threadList.get(i);	if (thread.isDaemon() && !thread.getName().contains("ActiveMQ")) {	
removing deamon thread 

public Thread[] filterDaemonThreads(Thread[] threads) throws Exception {	List<Thread> threadList = new ArrayList<Thread>(Arrays.asList(threads));	for (int i = 0 ; i < threadList.size(); i++) {	Thread thread = threadList.get(i);	if (thread.isDaemon() && !thread.getName().contains("ActiveMQ")) {	threadList.remove(thread);	Thread.sleep(100);	}	}	
converting list back to array 

========================= activemq sample_2510 =========================

count = extractConsumerCountFromMessage(message, count);	fireConsumerEvent(new ConsumerStartedEvent(this, destination, (ConsumerInfo)command, count));	} else if (command instanceof RemoveInfo) {	RemoveInfo removeInfo = (RemoveInfo)command;	if (removeInfo.isConsumerRemove()) {	count = consumerCount.decrementAndGet();	count = extractConsumerCountFromMessage(message, count);	fireConsumerEvent(new ConsumerStoppedEvent(this, destination, (ConsumerId)removeInfo.getObjectId(), count));	}	} else {	
unknown command 

} else if (command instanceof RemoveInfo) {	RemoveInfo removeInfo = (RemoveInfo)command;	if (removeInfo.isConsumerRemove()) {	count = consumerCount.decrementAndGet();	count = extractConsumerCountFromMessage(message, count);	fireConsumerEvent(new ConsumerStoppedEvent(this, destination, (ConsumerId)removeInfo.getObjectId(), count));	}	} else {	}	} else {	
unknown message type message ignored 

protected int extractConsumerCountFromMessage(Message message, int count) {	try {	Object value = message.getObjectProperty("consumerCount");	if (value instanceof Number) {	Number n = (Number)value;	return n.intValue();	}	
no consumercount header available on the message 

protected int extractConsumerCountFromMessage(Message message, int count) {	try {	Object value = message.getObjectProperty("consumerCount");	if (value instanceof Number) {	Number n = (Number)value;	return n.intValue();	}	} catch (Exception e) {	
failed to extract consumercount from message reason 

========================= activemq sample_693 =========================

connectorB.setName("openwire");	connectorB.setRebalanceClusterClients(true);	connectorB.setUpdateClusterClients(true);	connectorB.setUpdateClusterClientsOnRemove(true);	addNetworkBridge(getBroker(BROKER_B_NAME), "B_2_A_Bridge", "static: getBroker(BROKER_B_NAME).start();	getBroker(BROKER_B_NAME).waitUntilStarted();	Thread.sleep(1000);	setClientUrl("failover:(" + BROKER_A_CLIENT_TC_ADDRESS + ")?useExponentialBackOff=true");	createClients(1);	Thread.sleep(5000);	
stopping broker a whose address is 

private void runTests(boolean multi, String tcParams, String clusterFilter, String destinationFilter) throws Exception, InterruptedException {	assertClientsConnectedToThreeBrokers();	
stopping brokerc in prep for restart 

private void runTests(boolean multi, String tcParams, String clusterFilter, String destinationFilter) throws Exception, InterruptedException {	assertClientsConnectedToThreeBrokers();	getBroker(BROKER_C_NAME).stop();	getBroker(BROKER_C_NAME).waitUntilStopped();	removeBroker(BROKER_C_NAME);	assertClientsConnectedToTwoBrokers();	
recreating brokerc after stop 

========================= activemq sample_2567 =========================

assertTrue(brokerService.isPersistent());	Connection connection = createAMQConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue(name.getMethodName());	MessageProducer producer = session.createProducer(queue);	TextMessage message = null;	for (int i = 0; i < messagesSent; i++) {	message = session.createTextMessage();	String messageText = "Hello " + i + " sent at " + new java.util.Date().toString();	message.setText(messageText);	
sent 

connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue(name.getMethodName());	MessageProducer p = session.createProducer(queue);	TextMessage message = session.createTextMessage();	String messageText = "Hello sent at " + new java.util.Date().toString();	message.setText(messageText);	p.send(message);	restartBroker(connection, session);	String selector = "JMSMessageID = '" + message.getJMSMessageID() + "'";	
using selector 

Connection connection = createAMQConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(name.getMethodName());	MessageProducer p = session.createProducer(destination);	TextMessage message = session.createTextMessage();	String messageText = "Hello sent at " + new java.util.Date().toString();	message.setText(messageText);	p.send(message);	restartBroker(connection, session);	String selector = "JMSMessageID = '" + message.getJMSMessageID() + "'";	
using selector 

Connection connection = JMSClientContext.INSTANCE.createConnection(amqpURI);	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue(name.getMethodName());	MessageProducer p = session.createProducer(queue);	TextMessage message = null;	for (int i=0; i < messagesSent; i++) {	message = session.createTextMessage();	String messageText = "Hello " + i + " sent at " + new java.util.Date().toString();	message.setText(messageText);	
sent 

consumer = session.createConsumer(queue);	} else {	consumer = session.createConsumer(queue, selector);	}	try {	QueueViewMBean queueView = getProxyToQueue(queue.getQueueName());	if (queueView.getQueueSize() == 0) {	return 0;	}	} catch (Exception e) {	
error during destination check 

if (queueView.getQueueSize() == 0) {	return 0;	}	} catch (Exception e) {	}	Message msg = consumer.receive(1000);	while(msg != null) {	assertNotNull(msg);	assertTrue(msg instanceof TextMessage);	TextMessage textMessage = (TextMessage) msg;	
received 

private Connection createAMQConnection() throws JMSException {	
in createconnection using port 

========================= activemq sample_1598 =========================

public void init(ServletConfig servletConfig) throws ServletException {	super.init(servletConfig);	destinationOptions = servletConfig.getInitParameter("destinationOptions");	String name = servletConfig.getInitParameter("topic");	if (name != null) {	defaultTopicFlag = asBoolean(name);	}	if (LOG.isDebugEnabled()) {	
defaulting to use topics 

for (Iterator iter = parameters.entrySet().iterator(); iter.hasNext();) {	Map.Entry entry = (Map.Entry)iter.next();	String name = (String)entry.getKey();	if (!destinationParameter.equals(name) && !typeParameter.equals(name) && !bodyParameter.equals(name) && !"JMSDeliveryMode".equals(name) && !"JMSPriority".equals(name) && !"JMSTimeToLive".equals(name)) {	Object value = entry.getValue();	if (value instanceof Object[]) {	Object[] array = (Object[])value;	if (array.length == 1) {	value = array[0];	} else {	
can t use property which is of type value 

========================= activemq sample_1062 =========================

protected abstract void configurePersistenceAdapter(final BrokerService broker) throws IOException;	public void testMessagesAreValid() throws Exception {	if (this.useTopic) {	Assume.assumeTrue(reduceMemoryFootPrint);	}	ExecutorService tasks = Executors.newFixedThreadPool(NUM_TASKS);	for (int i = 0; i < NUM_CONSUMERS; i++) {	
created consumer 

protected abstract void configurePersistenceAdapter(final BrokerService broker) throws IOException;	public void testMessagesAreValid() throws Exception {	if (this.useTopic) {	Assume.assumeTrue(reduceMemoryFootPrint);	}	ExecutorService tasks = Executors.newFixedThreadPool(NUM_TASKS);	for (int i = 0; i < NUM_CONSUMERS; i++) {	tasks.execute(new HelloWorldConsumer(useTopic));	}	for (int i = 0; i < NUM_PRODUCERS; i++) {	
created producer 

public void run() {	try {	ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(getBrokerURI());	Connection connection = connectionFactory.createConnection();	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = useTopic ? session.createTopic(testTopicName) : session.createTopic("VirtualTopic.AMQ6218Test");	MessageProducer producer = session.createProducer(destination);	
producer 

mapMessage.setString("text", text);	message = mapMessage;	} else if (messageType.equals(MessageType.OBJECT)) {	ObjectMessage objectMessage = session.createObjectMessage();	objectMessage.setObject(text);	message = objectMessage;	} else {	message = session.createTextMessage(text);	}	producer.send(message);	
sent message 

ObjectMessage objectMessage = session.createObjectMessage();	objectMessage.setObject(text);	message = objectMessage;	} else {	message = session.createTextMessage(text);	}	producer.send(message);	}	connection.close();	} catch (Exception e) {	
caught 

MessageConsumer consumer = useTopic ? session.createDurableSubscriber((Topic) destination, "sub" + i) : session.createConsumer(destination);	ready.countDown();	while (!failure.get()) {	Message message = consumer.receive(500);	if (message != null) {	synchronized (this) {	if (MessageId != null) {	if (message.getJMSMessageID().equalsIgnoreCase(MessageId)) {	MessageCount++;	} else {	
count of message is 

if (messageType.equals(MessageType.OBJECT) && message instanceof ObjectMessage) {	ObjectMessage objectMessage = (ObjectMessage) message;	text = (String) objectMessage.getObject();	} else if (messageType.equals(MessageType.TEXT) && message instanceof TextMessage) {	TextMessage textMessage = (TextMessage) message;	text = textMessage.getText();	} else if (messageType.equals(MessageType.MAP) && message instanceof MapMessage) {	MapMessage mapMessage = (MapMessage) message;	text = mapMessage.getString("text");	} else {	
message is not a instanceof message id 

text = (String) objectMessage.getObject();	} else if (messageType.equals(MessageType.TEXT) && message instanceof TextMessage) {	TextMessage textMessage = (TextMessage) message;	text = textMessage.getText();	} else if (messageType.equals(MessageType.MAP) && message instanceof MapMessage) {	MapMessage mapMessage = (MapMessage) message;	text = mapMessage.getString("text");	} else {	}	if (text == null) {	
text received as a null 

TextMessage textMessage = (TextMessage) message;	text = textMessage.getText();	} else if (messageType.equals(MessageType.MAP) && message instanceof MapMessage) {	MapMessage mapMessage = (MapMessage) message;	text = mapMessage.getString("text");	} else {	}	if (text == null) {	failure.set(true);	} else {	
text message id 

}	if (text == null) {	failure.set(true);	} else {	}	message.acknowledge();	}	}	connection.close();	} catch (Exception e) {	
caught 

public synchronized void onException(JMSException ex) {	
jms exception occurred shutting down client 

========================= activemq sample_3819 =========================

public void testRequestResponse() throws Exception {	ConsumerInfo expected = new ConsumerInfo();	expected.setSelector("Edam");	expected.setResponseRequired(true);	
about to send 

public void testRequestResponse() throws Exception {	ConsumerInfo expected = new ConsumerInfo();	expected.setSelector("Edam");	expected.setResponseRequired(true);	Response response = (Response) producer.request(expected, 2000);	
received 

protected Transport createProducer() throws Exception {	
producer using uri 

========================= activemq sample_2475 =========================

broker.setDeleteAllMessagesOnStartup(delete);	broker.setPersistent(true);	broker.setUseJmx(false);	broker.addConnector("tcp: PolicyMap map = new PolicyMap();	PolicyEntry entry = new PolicyEntry();	entry.setUseCache(false);	map.setDefaultEntry(entry);	broker.setDestinationPolicy(map);	configurePersistence(broker, delete);	broker.start();	
starting broker 

consumer.setBreakOnNull(false);	consumer.setMessageCount(messageCount);	producer.start();	producer.join();	consumer.start();	consumer.join();	assertEquals("consumer got all produced messages", producer.getMessageCount(), consumer.getReceived());	assertTrue("gc worked", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	int fileCount = getFileCount(kahaDbDir);	
current filecount 

========================= activemq sample_2926 =========================

protected boolean configuredOk() throws IOException {	if (!isConfigured) {	return false;	}	
stomp inactivity monitor read check interval ms write check interval ms 

========================= activemq sample_1465 =========================

private void rollback() {	try {	session.rollback();	} catch (JMSException e) {	
failed to rollback 

========================= activemq sample_2619 =========================

private void assertDenied(String userPass, String destination) {	try {	assertAllowed(userPass, destination);	fail("Expected not allowed exception");	} catch (JMSException expected) {	
got 

========================= activemq sample_4372 =========================

protected void setUp() throws Exception {	File journalFile = new File(JOURNAL_ROOT);	recursiveDelete(journalFile);	
creating broker 

protected void setUp() throws Exception {	File journalFile = new File(JOURNAL_ROOT);	recursiveDelete(journalFile);	broker = createBroker("org/apache/activemq/usecases/activemq.xml");	
Success 

protected void tearDown() throws Exception {	
closing broker 

protected void tearDown() throws Exception {	if (broker != null) {	broker.stop();	}	
broker closed 

========================= activemq sample_3622 =========================

public void startBroker() throws Exception {	broker = new BrokerService();	broker.setDeleteAllMessagesOnStartup(true);	broker.setPersistent(true);	broker.setUseJmx(true);	broker.addConnector("tcp: broker.start();	
starting broker 

buildReceiver(haloConnection, troyToHalo, true, troyReceiver);	haloConnection.start();	troyConnection.start();	troyThread.start();	xenaConnection.start();	xenaThread.start();	hectorConnection.start();	hectorThread.start();	waitForMessagesToBeDelivered();	assertEquals(hectorToHaloCtr, counter);	
hectortohalo received messages 

haloConnection.start();	troyConnection.start();	troyThread.start();	xenaConnection.start();	xenaThread.start();	hectorConnection.start();	hectorThread.start();	waitForMessagesToBeDelivered();	assertEquals(hectorToHaloCtr, counter);	assertEquals(xenaToHaloCtr, counter);	
xenatohalo received messages 

troyConnection.start();	troyThread.start();	xenaConnection.start();	xenaThread.start();	hectorConnection.start();	hectorThread.start();	waitForMessagesToBeDelivered();	assertEquals(hectorToHaloCtr, counter);	assertEquals(xenaToHaloCtr, counter);	assertEquals(troyToHaloCtr, counter);	
troytohalo received messages 

troyThread.start();	xenaConnection.start();	xenaThread.start();	hectorConnection.start();	hectorThread.start();	waitForMessagesToBeDelivered();	assertEquals(hectorToHaloCtr, counter);	assertEquals(xenaToHaloCtr, counter);	assertEquals(troyToHaloCtr, counter);	assertEquals(haloToHectorCtr, counter);	
halotohector received messages 

xenaConnection.start();	xenaThread.start();	hectorConnection.start();	hectorThread.start();	waitForMessagesToBeDelivered();	assertEquals(hectorToHaloCtr, counter);	assertEquals(xenaToHaloCtr, counter);	assertEquals(troyToHaloCtr, counter);	assertEquals(haloToHectorCtr, counter);	assertEquals(haloToXenaCtr, counter);	
halotoxena received messages 

xenaThread.start();	hectorConnection.start();	hectorThread.start();	waitForMessagesToBeDelivered();	assertEquals(hectorToHaloCtr, counter);	assertEquals(xenaToHaloCtr, counter);	assertEquals(troyToHaloCtr, counter);	assertEquals(haloToHectorCtr, counter);	assertEquals(haloToXenaCtr, counter);	assertEquals(haloToTroyCtr, counter);	
halototroy received messages 

========================= activemq sample_2875 =========================

public void serviceTransportException(IOException e) {	if (!stopping.get() && !pendingStop.get()) {	transportException.set(e);	if (TRANSPORTLOG.isDebugEnabled()) {	
failed 

public void serviceTransportException(IOException e) {	if (!stopping.get() && !pendingStop.get()) {	transportException.set(e);	if (TRANSPORTLOG.isDebugEnabled()) {	} else if (TRANSPORTLOG.isWarnEnabled() && !expected(e)) {	
failed 

public void serviceException(Throwable e) {	if (e instanceof IOException) {	serviceTransportException((IOException) e);	} else if (e.getClass() == BrokerStoppedException.class) {	if (!stopping.get()) {	
broker has been stopped notifying client and closing his connection 

Thread.sleep(500);	} catch (InterruptedException ie) {	Thread.currentThread().interrupt();	}	stopAsync();	}	} else if (!stopping.get() && !inServiceException) {	inServiceException = true;	try {	if (SERVICELOG.isDebugEnabled()) {	
async error occurred 

} catch (InterruptedException ie) {	Thread.currentThread().interrupt();	}	stopAsync();	}	} else if (!stopping.get() && !inServiceException) {	inServiceException = true;	try {	if (SERVICELOG.isDebugEnabled()) {	} else {	
async error occurred 

boolean responseRequired = command.isResponseRequired();	int commandId = command.getCommandId();	try {	if (!pendingStop.get()) {	response = command.visit(this);	} else {	response = new ExceptionResponse(transportException.get());	}	} catch (Throwable e) {	if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {	
error occured while processing sync async command exception 

try {	if (!pendingStop.get()) {	response = command.visit(this);	} else {	response = new ExceptionResponse(transportException.get());	}	} catch (Throwable e) {	if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {	}	if (e instanceof SuppressReplyException || (e.getCause() instanceof SuppressReplyException)) {	
suppressing reply to on cause 

response = new ExceptionResponse(transportException.get());	}	} catch (Throwable e) {	if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {	}	if (e instanceof SuppressReplyException || (e.getCause() instanceof SuppressReplyException)) {	responseRequired = false;	}	if (responseRequired) {	if (e instanceof SecurityException || e.getCause() instanceof SecurityException) {	
security error occurred on connection to 

private void forceRollbackOnlyOnFailedAsyncTransactionOp(Throwable e, Command command) {	if (brokerService.isRollbackOnlyOnAsyncException() && !(e instanceof IOException) && isInTransaction(command)) {	Transaction transaction = getActiveTransaction(command);	if (transaction != null && !transaction.isRollbackOnly()) {	
on async exception force rollback of transaction for 

ProducerBrokerExchange producerExchange = getProducerBrokerExchange(producerId);	transaction = producerExchange.getConnectionContext().getTransactions().get(messageSend.getTransactionId());	} else if (command instanceof  MessageAck) {	MessageAck messageAck = (MessageAck) command;	ConsumerBrokerExchange consumerExchange = getConsumerBrokerExchange(messageAck.getConsumerId());	if (consumerExchange != null) {	transaction = consumerExchange.getConnectionContext().getTransactions().get(messageAck.getTransactionId());	}	}	} catch(Exception ignored){	
failed to find active transaction for command 

public Response processMessageAck(MessageAck ack) throws Exception {	ConsumerBrokerExchange consumerExchange = getConsumerBrokerExchange(ack.getConsumerId());	if (consumerExchange != null) {	broker.acknowledge(consumerExchange, ack);	} else if (ack.isInTransaction()) {	
no matching consumer ignoring ack 

public Response processAddSession(SessionInfo info) throws Exception {	ConnectionId connectionId = info.getSessionId().getParentId();	TransportConnectionState cs = lookupConnectionState(connectionId);	if (cs != null && !cs.getSessionIds().contains(info.getSessionId())) {	broker.addSession(cs.getContext(), info);	try {	cs.addSession(info);	} catch (IllegalStateException e) {	
failed to add session 

}	SessionState session = cs.getSessionState(id);	if (session == null) {	throw new IllegalStateException("Cannot remove session that had not been registered: " + id);	}	session.shutdown();	for (ConsumerId consumerId : session.getConsumerIds()) {	try {	processRemoveConsumer(consumerId, lastDeliveredSequenceId);	} catch (Throwable e) {	
failed to remove consumer 

for (ConsumerId consumerId : session.getConsumerIds()) {	try {	processRemoveConsumer(consumerId, lastDeliveredSequenceId);	} catch (Throwable e) {	}	}	for (ProducerId producerId : session.getProducerIds()) {	try {	processRemoveProducer(producerId);	} catch (Throwable e) {	
failed to remove producer 

synchronized (brokerConnectionStates) {	state = (TransportConnectionState) brokerConnectionStates.get(info.getConnectionId());	if (state == null) {	state = new TransportConnectionState(info, this);	brokerConnectionStates.put(info.getConnectionId(), state);	}	state.incrementReference();	}	synchronized (state.getConnectionMutex()) {	if (state.getConnection() != this) {	
killing previous stale connection 

state = (TransportConnectionState) brokerConnectionStates.get(info.getConnectionId());	if (state == null) {	state = new TransportConnectionState(info, this);	brokerConnectionStates.put(info.getConnectionId(), state);	}	state.incrementReference();	}	synchronized (state.getConnectionMutex()) {	if (state.getConnection() != this) {	state.getConnection().stop();	
connection taking over previous connection 

state.incrementReference();	}	synchronized (state.getConnectionMutex()) {	if (state.getConnection() != this) {	state.getConnection().stop();	state.setConnection(this);	state.reset(info);	}	}	registerConnectionState(info.getConnectionId(), state);	
setting up new connection id address info 

public synchronized Response processRemoveConnection(ConnectionId id, long lastDeliveredSequenceId) throws InterruptedException {	
remove connection id 

public synchronized Response processRemoveConnection(ConnectionId id, long lastDeliveredSequenceId) throws InterruptedException {	TransportConnectionState cs = lookupConnectionState(id);	if (cs != null) {	cs.shutdown();	for (SessionId sessionId : cs.getSessionIds()) {	try {	processRemoveSession(sessionId, lastDeliveredSequenceId);	} catch (Throwable e) {	
failed to remove session 

try {	processRemoveSession(sessionId, lastDeliveredSequenceId);	} catch (Throwable e) {	}	}	for (Iterator<DestinationInfo> iter = cs.getTempDestinations().iterator(); iter.hasNext(); ) {	DestinationInfo di = iter.next();	try {	broker.removeDestination(cs.getContext(), di.getDestination(), 0);	} catch (Throwable e) {	
failed to remove tmp destination 

DestinationInfo di = iter.next();	try {	broker.removeDestination(cs.getContext(), di.getDestination(), 0);	} catch (Throwable e) {	}	iter.remove();	}	try {	broker.removeConnection(cs.getContext(), cs.getInfo(), transportException.get());	} catch (Throwable e) {	
failed to remove connection 

if (messageDispatch != null) {	TransmitCallback sub = messageDispatch.getTransmitCallback();	broker.postProcessDispatch(messageDispatch);	if (sub != null) {	sub.onFailure();	}	messageDispatch = null;	throw e;	} else {	if (TRANSPORTLOG.isDebugEnabled()) {	
unexpected exception on asyncdispatch command of type 

}	dispatchAsync(info);	connector.onStarted(this);	}	} catch (Exception e) {	pendingStop.set(true);	throw e;	} finally {	setStarting(false);	if (isPendingStop()) {	
calling the delayed stop after start 

public void stop() throws Exception {	stopAsync();	while (!stopped.await(5, TimeUnit.SECONDS)) {	
the connection to is taking a long time to shutdown 

synchronized (this) {	pendingStop.set(true);	transportException.set(cause);	}	try {	stopTaskRunnerFactory.execute(new Runnable() {	public void run() {	try {	Thread.sleep(waitTime);	stopAsync();	
stopping because 

stopTaskRunnerFactory.execute(new Runnable() {	public void run() {	try {	Thread.sleep(waitTime);	stopAsync();	} catch (InterruptedException e) {	}	}	});	} catch (Throwable t) {	
cannot create stopasync this exception will be ignored 

public void stopAsync() {	synchronized (this) {	pendingStop.set(true);	if (starting.get()) {	
stopasync called in the middle of start delaying till start completes 

connectionContext.getStopping().set(true);	}	}	try {	stopTaskRunnerFactory.execute(new Runnable() {	public void run() {	serviceLock.writeLock().lock();	try {	doStop();	} catch (Throwable e) {	
error occurred while shutting down a connection 

try {	doStop();	} catch (Throwable e) {	} finally {	stopped.countDown();	serviceLock.writeLock().unlock();	}	}	});	} catch (Throwable t) {	
cannot create async transport stopper thread this exception is ignored not waiting for stop to complete 

protected void doStop() throws Exception {	
stopping connection 

protected void doStop() throws Exception {	connector.onStopped(this);	try {	synchronized (this) {	if (duplexBridge != null) {	duplexBridge.stop();	}	}	} catch (Exception ignore) {	
exception caught stopping this exception is ignored 

try {	synchronized (this) {	if (duplexBridge != null) {	duplexBridge.stop();	}	}	} catch (Exception ignore) {	}	try {	transport.stop();	
stopped transport 

synchronized (this) {	if (duplexBridge != null) {	duplexBridge.stop();	}	}	} catch (Exception ignore) {	}	try {	transport.stop();	} catch (Exception e) {	
could not stop transport to this exception is ignored 

}	}	dispatchQueue.clear();	}	if (!broker.isStopped()) {	List<TransportConnectionState> connectionStates = listConnectionStates();	connectionStates = listConnectionStates();	for (TransportConnectionState cs : connectionStates) {	cs.getContext().getStopping().set(true);	try {	
cleaning up connection resources 

dispatchQueue.clear();	}	if (!broker.isStopped()) {	List<TransportConnectionState> connectionStates = listConnectionStates();	connectionStates = listConnectionStates();	for (TransportConnectionState cs : connectionStates) {	cs.getContext().getStopping().set(true);	try {	processRemoveConnection(cs.getInfo().getConnectionId(), RemoveInfo.LAST_DELIVERED_UNKNOWN);	} catch (Throwable ignore) {	
exception caught removing connection this exception is ignored 

List<TransportConnectionState> connectionStates = listConnectionStates();	connectionStates = listConnectionStates();	for (TransportConnectionState cs : connectionStates) {	cs.getContext().getStopping().set(true);	try {	processRemoveConnection(cs.getInfo().getConnectionId(), RemoveInfo.LAST_DELIVERED_UNKNOWN);	} catch (Throwable ignore) {	}	}	}	
connection stopped 

public Response processBrokerInfo(BrokerInfo info) {	if (info.isSlaveBroker()) {	
slave brokers are no longer supported slave trying to attach is 

public Response processBrokerInfo(BrokerInfo info) {	if (info.isSlaveBroker()) {	} else if (info.isNetworkConnection() && !info.isDuplexConnection()) {	try {	NetworkBridgeConfiguration config = getNetworkConfiguration(info);	if (config.isSyncDurableSubs() && protocolVersion.get() >= CommandTypes.PROTOCOL_VERSION_DURABLE_SYNC) {	
syncdurablesubs is enabled sending brokersubscriptioninfo 

public Response processBrokerInfo(BrokerInfo info) {	if (info.isSlaveBroker()) {	} else if (info.isNetworkConnection() && !info.isDuplexConnection()) {	try {	NetworkBridgeConfiguration config = getNetworkConfiguration(info);	if (config.isSyncDurableSubs() && protocolVersion.get() >= CommandTypes.PROTOCOL_VERSION_DURABLE_SYNC) {	dispatchSync(NetworkBridgeUtils.getBrokerSubscriptionInfo(this.broker.getBrokerService(), config));	}	} catch (Exception e) {	
failed to respond to network bridge creation from broker 

dispatchSync(NetworkBridgeUtils.getBrokerSubscriptionInfo(this.broker.getBrokerService(), config));	}	} catch (Exception e) {	return null;	}	} else if (info.isNetworkConnection() && info.isDuplexConnection()) {	try {	NetworkBridgeConfiguration config = getNetworkConfiguration(info);	config.setBrokerName(broker.getBrokerName());	if (config.isSyncDurableSubs() && protocolVersion.get() >= CommandTypes.PROTOCOL_VERSION_DURABLE_SYNC) {	
syncdurablesubs is enabled sending brokersubscriptioninfo 

config.setBrokerName(broker.getBrokerName());	if (config.isSyncDurableSubs() && protocolVersion.get() >= CommandTypes.PROTOCOL_VERSION_DURABLE_SYNC) {	dispatchSync(NetworkBridgeUtils.getBrokerSubscriptionInfo(this.broker.getBrokerService(), config));	}	String duplexNetworkConnectorId = config.getName() + "@" + info.getBrokerId();	CopyOnWriteArrayList<TransportConnection> connections = this.connector.getConnections();	synchronized (connections) {	for (Iterator<TransportConnection> iter = connections.iterator(); iter.hasNext(); ) {	TransportConnection c = iter.next();	if ((c != this) && (duplexNetworkConnectorId.equals(c.getDuplexNetworkConnectorId()))) {	
stopping an existing active duplex connection for network connector 

duplexName = duplexName.substring(duplexName.lastIndexOf("#"));	}	MBeanNetworkListener listener = new MBeanNetworkListener(brokerService, config, brokerService.createDuplexNetworkConnectorObjectName(duplexName));	listener.setCreatedByDuplex(true);	duplexBridge = config.getBridgeFactory().createNetworkBridge(config, localTransport, remoteBridgeTransport, listener);	duplexBridge.setBrokerService(brokerService);	duplexBridge.setDurableDestinations(NetworkConnector.getDurableTopicDestinations( broker.getDurableDestinations()));	info.setDuplexConnection(false);	duplexBridge.setCreatedByDuplex(true);	duplexBridge.duplexStart(this, brokerInfo, info);	
started responder end of duplex bridge 

MBeanNetworkListener listener = new MBeanNetworkListener(brokerService, config, brokerService.createDuplexNetworkConnectorObjectName(duplexName));	listener.setCreatedByDuplex(true);	duplexBridge = config.getBridgeFactory().createNetworkBridge(config, localTransport, remoteBridgeTransport, listener);	duplexBridge.setBrokerService(brokerService);	duplexBridge.setDurableDestinations(NetworkConnector.getDurableTopicDestinations( broker.getDurableDestinations()));	info.setDuplexConnection(false);	duplexBridge.setCreatedByDuplex(true);	duplexBridge.duplexStart(this, brokerInfo, info);	return null;	} catch (TransportDisposedIOException e) {	
duplex bridge was stopped before it was correctly started 

duplexBridge = config.getBridgeFactory().createNetworkBridge(config, localTransport, remoteBridgeTransport, listener);	duplexBridge.setBrokerService(brokerService);	duplexBridge.setDurableDestinations(NetworkConnector.getDurableTopicDestinations( broker.getDurableDestinations()));	info.setDuplexConnection(false);	duplexBridge.setCreatedByDuplex(true);	duplexBridge.duplexStart(this, brokerInfo, info);	return null;	} catch (TransportDisposedIOException e) {	return null;	} catch (Exception e) {	
failed to create responder end of duplex network bridge 

duplexBridge.setCreatedByDuplex(true);	duplexBridge.duplexStart(this, brokerInfo, info);	return null;	} catch (TransportDisposedIOException e) {	return null;	} catch (Exception e) {	return null;	}	}	if (this.brokerInfo != null) {	
unexpected extra broker info command received 

========================= activemq sample_4108 =========================

protected void setInfo(ActiveMQConnectionRequestInfo connectionRequestInfo) {	info = connectionRequestInfo;	if (log.isDebugEnabled()) {	
setting info to 

public void setClientid(String clientid) {	if (log.isDebugEnabled()) {	
setting clientid to 

public void setPassword(String password) {	if (log.isDebugEnabled()) {	
setting password property 

public void setServerUrl(String url) {	if (log.isDebugEnabled()) {	
setting serverurl to 

public void setTrustStore(String trustStore) {	if (log.isDebugEnabled()) {	
setting truststore to 

public void setTrustStorePassword(String trustStorePassword) {	if (log.isDebugEnabled()) {	
setting truststorepassword to 

public void setKeyStore(String keyStore) {	if (log.isDebugEnabled()) {	
setting keystore to 

public void setKeyStorePassword(String keyStorePassword) {	if (log.isDebugEnabled()) {	
setting keystorepassword to 

public void setKeyStoreKeyPassword(String keyStoreKeyPassword) {	if (log.isDebugEnabled()) {	
setting keystorekeypassword to 

public void setUserName(String userid) {	if (log.isDebugEnabled()) {	
setting username to 

public void setOptimizeDurableTopicPrefetch(Integer optimizeDurableTopicPrefetch) {	if (log.isDebugEnabled()) {	
setting optimizedurabletopicprefetch to 

public void setDurableTopicPrefetch(Integer durableTopicPrefetch) {	if (log.isDebugEnabled()) {	
setting durabletopicprefetch to 

public void setInitialRedeliveryDelay(Long value) {	if (log.isDebugEnabled()) {	
setting initialredeliverydelay to 

public void setMaximumRedeliveryDelay(Long value) {	if (log.isDebugEnabled()) {	
setting maximumredeliverydelay to 

public void setMaximumRedeliveries(Integer value) {	if (log.isDebugEnabled()) {	
setting maximumredeliveries to 

public void setQueueBrowserPrefetch(Integer queueBrowserPrefetch) {	if (log.isDebugEnabled()) {	
setting queuebrowserprefetch to 

public void setQueuePrefetch(Integer queuePrefetch) {	if (log.isDebugEnabled()) {	
setting queueprefetch to 

public void setRedeliveryBackOffMultiplier(Double value) {	if (log.isDebugEnabled()) {	
setting redeliverybackoffmultiplier to 

public void setRedeliveryUseExponentialBackOff(Boolean value) {	if (log.isDebugEnabled()) {	
setting redeliveryuseexponentialbackoff to 

public void setTopicPrefetch(Integer topicPrefetch) {	if (log.isDebugEnabled()) {	
setting topicprefetch to 

public void setUseInboundSession(Boolean useInboundSession) {	if (log.isDebugEnabled()) {	
setting useinboundsession to 

public void setUseSessionArgs(Boolean useSessionArgs) {	if (log.isDebugEnabled()) {	
setting usesessionargs to 

========================= activemq sample_847 =========================

public boolean canDispatch(Message messageSend) {	boolean canDispatch = true;	if (auditProducerSequenceIds && messageSend.isPersistent()) {	final long producerSequenceId = messageSend.getMessageId().getProducerSequenceId();	if (isNetworkProducer) {	long lastStoredForMessageProducer = getStoredSequenceIdForMessage(messageSend.getMessageId());	if (producerSequenceId <= lastStoredForMessageProducer) {	canDispatch = false;	
suppressing duplicate message send from network producer with producersequence less than last stored 

private long getStoredSequenceIdForMessage(MessageId messageId) {	try {	return brokerService.getPersistenceAdapter().getLastProducerSequenceId(messageId.getProducerId());	} catch (IOException ignored) {	
failed to determine last producer sequence id for 

public void setLastStoredSequenceId(long l) {	auditProducerSequenceIds = true;	if (connectionContext.isNetworkConnection()) {	brokerService = connectionContext.getBroker().getBrokerService();	isNetworkProducer = true;	}	lastSendSequenceNumber.set(l);	
last stored sequence id set 

========================= activemq sample_3858 =========================

public void commit() throws JMSException {	checkClosed();	if (!getTransacted()) {	throw new javax.jms.IllegalStateException("Not a transacted session");	}	if (LOG.isDebugEnabled()) {	
transaction commit 

public void rollback() throws JMSException {	checkClosed();	if (!getTransacted()) {	throw new javax.jms.IllegalStateException("Not a transacted session");	}	if (LOG.isDebugEnabled()) {	
transaction rollback txid 

public void run() {	MessageDispatch messageDispatch;	while ((messageDispatch = executor.dequeueNoWait()) != null) {	final MessageDispatch md = messageDispatch;	final ActiveMQMessage message = (ActiveMQMessage)md.getMessage();	MessageAck earlyAck = null;	if (message.isExpired()) {	earlyAck = new MessageAck(md, MessageAck.EXPIRED_ACK_TYPE, 1);	earlyAck.setFirstMessageId(message.getMessageId());	} else if (connection.isDuplicate(ActiveMQSession.this, message)) {	
got duplicate 

earlyAck.setFirstMessageId(message.getMessageId());	} else if (connection.isDuplicate(ActiveMQSession.this, message)) {	earlyAck = new MessageAck(md, MessageAck.POSION_ACK_TYPE, 1);	earlyAck.setFirstMessageId(md.getMessage().getMessageId());	earlyAck.setPoisonCause(new Throwable("Duplicate delivery to " + this));	}	if (earlyAck != null) {	try {	asyncSendPacket(earlyAck);	} catch (Throwable t) {	
error dispatching ack 

synchronized (redeliveryGuard) {	try {	ack.setFirstMessageId(md.getMessage().getMessageId());	doStartTransaction();	ack.setTransactionId(getTransactionContext().getTransactionId());	if (ack.getTransactionId() != null) {	getTransactionContext().addSynchronization(new Synchronization() {	final int clearRequestCount = (clearRequestsCounter.get() == Integer.MAX_VALUE ? clearRequestsCounter.incrementAndGet() : clearRequestsCounter.get());	public void beforeEnd() throws Exception {	if (ack.getTransactionId().isXATransaction() && !connection.hasDispatcher(ack.getConsumerId())) {	
forcing rollback consumer no longer active on 

ack.setFirstMessageId(md.getMessage().getMessageId());	doStartTransaction();	ack.setTransactionId(getTransactionContext().getTransactionId());	if (ack.getTransactionId() != null) {	getTransactionContext().addSynchronization(new Synchronization() {	final int clearRequestCount = (clearRequestsCounter.get() == Integer.MAX_VALUE ? clearRequestsCounter.incrementAndGet() : clearRequestsCounter.get());	public void beforeEnd() throws Exception {	if (ack.getTransactionId().isXATransaction() && !connection.hasDispatcher(ack.getConsumerId())) {	throw new TransactionRolledBackException("consumer " + ack.getConsumerId() + " no longer active on " + connection);	}	
beforeend ack 

if (ack.getTransactionId() != null) {	getTransactionContext().addSynchronization(new Synchronization() {	final int clearRequestCount = (clearRequestsCounter.get() == Integer.MAX_VALUE ? clearRequestsCounter.incrementAndGet() : clearRequestsCounter.get());	public void beforeEnd() throws Exception {	if (ack.getTransactionId().isXATransaction() && !connection.hasDispatcher(ack.getConsumerId())) {	throw new TransactionRolledBackException("consumer " + ack.getConsumerId() + " no longer active on " + connection);	}	sendAck(ack);	}	public void afterRollback() throws Exception {	
rollback here 

final int clearRequestCount = (clearRequestsCounter.get() == Integer.MAX_VALUE ? clearRequestsCounter.incrementAndGet() : clearRequestsCounter.get());	public void beforeEnd() throws Exception {	if (ack.getTransactionId().isXATransaction() && !connection.hasDispatcher(ack.getConsumerId())) {	throw new TransactionRolledBackException("consumer " + ack.getConsumerId() + " no longer active on " + connection);	}	sendAck(ack);	}	public void afterRollback() throws Exception {	connection.rollbackDuplicate(ActiveMQSession.this, md.getMessage());	if (clearRequestsCounter.get() > clearRequestCount) {	
no redelivery of on rollback of due to failover of 

throw new TransactionRolledBackException("consumer " + ack.getConsumerId() + " no longer active on " + connection);	}	sendAck(ack);	}	public void afterRollback() throws Exception {	connection.rollbackDuplicate(ActiveMQSession.this, md.getMessage());	if (clearRequestsCounter.get() > clearRequestCount) {	return;	}	if (ack.getTransactionId().isXATransaction() && !connection.hasDispatcher(ack.getConsumerId())) {	
no local redelivery of on rollback of because consumer is no longer active on 

asyncSendPacket(ack);	} else {	MessageAck ack = new MessageAck(md, MessageAck.REDELIVERED_ACK_TYPE, 1);	ack.setFirstMessageId(md.getMessage().getMessageId());	asyncSendPacket(ack);	long redeliveryDelay = redeliveryPolicy.getInitialRedeliveryDelay();	for (int i = 0; i < redeliveryCounter; i++) {	redeliveryDelay = redeliveryPolicy.getNextRedeliveryDelay(redeliveryDelay);	}	if (!connection.isNonBlockingRedelivery()) {	
blocking session until re delivery 

}	}	}	}	}, redeliveryDelay);	}	md.getMessage().onMessageRolledBack();	}	});	}	
onmessage 

}	}	}, redeliveryDelay);	}	md.getMessage().onMessageRolledBack();	}	});	}	messageListener.onMessage(message);	} catch (Throwable e) {	
error dispatching message 

}	}, redeliveryDelay);	}	md.getMessage().onMessageRolledBack();	}	});	}	messageListener.onMessage(message);	} catch (Throwable e) {	if (getTransactionContext().isInXATransaction()) {	
marking transaction rollbackonly 

asyncSendPacket(ack);	} catch (Throwable e) {	connection.onClientInternalException(e);	}	}	}	if (deliveryListener != null) {	try {	deliveryListener.afterDelivery(this, message);	} catch (Throwable t) {	
unable to call after delivery 

}	msg.setBrokerPath(null);	msg.setTransactionId(txid);	if (connection.isCopyMessageOnSend()) {	msg = (ActiveMQMessage)msg.copy();	}	msg.setConnection(connection);	msg.onSend();	msg.setProducerId(msg.getMessageId().getProducerId());	if (LOG.isTraceEnabled()) {	
sending message 

protected void close(ConsumerId id) {	for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {	ActiveMQMessageConsumer c = iter.next();	if (c.getConsumerId().equals(id)) {	try {	c.close();	} catch (JMSException e) {	
exception closing consumer 

protected void close(ConsumerId id) {	for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {	ActiveMQMessageConsumer c = iter.next();	if (c.getConsumerId().equals(id)) {	try {	c.close();	} catch (JMSException e) {	}	
closed consumer on command 

========================= activemq sample_685 =========================

connection.start();	Session producerSession = connection.createSession(true, Session.SESSION_TRANSACTED);	try {	MessageProducer jmsProducer = producerSession.createProducer(producerSession.createQueue(DESTINATION));	Message sendMessage = producerSession.createTextMessage(createTextMessage(5000));	for (int i = 0; i < messageCount; i++) {	jmsProducer.send(sendMessage);	producerSession.commit();	numberOfMessageSent++;	}	
finished after producing 

try {	MessageProducer jmsProducer = producerSession.createProducer(producerSession.createQueue(DESTINATION));	Message sendMessage = producerSession.createTextMessage(createTextMessage(5000));	for (int i = 0; i < messageCount; i++) {	jmsProducer.send(sendMessage);	producerSession.commit();	numberOfMessageSent++;	}	return numberOfMessageSent;	} catch (Exception ex) {	
exception received producing 

try {	MessageProducer jmsProducer = producerSession.createProducer(producerSession.createQueue(DESTINATION));	Message sendMessage = producerSession.createTextMessage(createTextMessage(5000));	for (int i = 0; i < messageCount; i++) {	jmsProducer.send(sendMessage);	producerSession.commit();	numberOfMessageSent++;	}	return numberOfMessageSent;	} catch (Exception ex) {	
finishing after exception 

try {	MessageProducer jmsProducer = producerSession.createProducer(producerSession.createQueue(DESTINATION));	Message sendMessage = producerSession.createTextMessage(createTextMessage(5000));	for (int i = 0; i < messageCount; i++) {	jmsProducer.send(sendMessage);	producerSession.commit();	numberOfMessageSent++;	}	return numberOfMessageSent;	} catch (Exception ex) {	
rolling back current transaction 

ActiveMQConnectionFactory connectionFactory = newConnectionFactory(broker);	Connection connection = (ActiveMQConnection) connectionFactory.createConnection();	connection.start();	Session consumerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	try {	MessageConsumer jmsConsumer = consumerSession.createConsumer(consumerSession.createQueue(DESTINATION));	for (int i = 0; i < messageCount; i++) {	jmsConsumer.receive(1000);	numberOfMessageConsumed++;	}	
finished after consuming 

connection.start();	Session consumerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	try {	MessageConsumer jmsConsumer = consumerSession.createConsumer(consumerSession.createQueue(DESTINATION));	for (int i = 0; i < messageCount; i++) {	jmsConsumer.receive(1000);	numberOfMessageConsumed++;	}	return numberOfMessageConsumed;	} catch (Exception ex) {	
exception received producing 

connection.start();	Session consumerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	try {	MessageConsumer jmsConsumer = consumerSession.createConsumer(consumerSession.createQueue(DESTINATION));	for (int i = 0; i < messageCount; i++) {	jmsConsumer.receive(1000);	numberOfMessageConsumed++;	}	return numberOfMessageConsumed;	} catch (Exception ex) {	
finishing after exception 

========================= activemq sample_2967 =========================

public void testRollbackAckInterrupted() throws Exception {	publishAMessage();	Xid tid;	session = xaConnection.createXASession();	final MessageConsumer consumer = session.createConsumer(dest);	tid = createXid();	resource = session.getXAResource();	resource.start(tid, XAResource.TMNOFLAGS);	((TransactionContext)resource).addSynchronization(new Synchronization() {	public void beforeEnd() throws Exception {	
interrupting thread Source 

public void testCommitAckInterrupted() throws Exception {	publishAMessage();	session = xaConnection.createXASession();	MessageConsumer consumer = session.createConsumer(dest);	Xid tid = createXid();	resource = session.getXAResource();	resource.start(tid, XAResource.TMNOFLAGS);	((TransactionContext)resource).addSynchronization(new Synchronization() {	public void beforeEnd() throws Exception {	
interrupting thread Source 

private void assertCause(Throwable expectedWithInterrupt, Class[] exceptionClazzes) {	Throwable candidate = expectedWithInterrupt;	while (candidate != null) {	for (Class<?> exceptionClazz: exceptionClazzes) {	if (exceptionClazz.isInstance(candidate)) {	return;	}	}	candidate = candidate.getCause();	}	
ex 

========================= activemq sample_2988 =========================

final Connection connection = factory.createConnection();	connection.start();	Thread producingThread = new Thread("Producing thread") {	public void run() {	try {	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(new ActiveMQQueue(getDestinationName()));	for (int idx = 0; idx < MESSAGES_COUNT; ++idx) {	Message message = session.createTextMessage("" + idx);	producer.send(message);	
sending 

Thread.sleep(1000);	Thread consumingThread = new Thread("Consuming thread") {	public void run() {	try {	Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	MessageConsumer consumer = session.createConsumer(new ActiveMQQueue(getDestinationName()));	int diff = 0;	while (messagesCount != MESSAGES_COUNT) {	Message msg = consumer.receive(messageReceiveTimeout);	if (msg == null) {	
got null message at count continuing 

Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	MessageConsumer consumer = session.createConsumer(new ActiveMQQueue(getDestinationName()));	int diff = 0;	while (messagesCount != MESSAGES_COUNT) {	Message msg = consumer.receive(messageReceiveTimeout);	if (msg == null) {	break;	}	String text = ((TextMessage)msg).getText();	int currentMsgIdx = Integer.parseInt(text);	
received messagecount 

int diff = 0;	while (messagesCount != MESSAGES_COUNT) {	Message msg = consumer.receive(messageReceiveTimeout);	if (msg == null) {	break;	}	String text = ((TextMessage)msg).getText();	int currentMsgIdx = Integer.parseInt(text);	msg.acknowledge();	if ((messagesCount + diff) != currentMsgIdx) {	
message s skipped should be message no but got 

break;	}	String text = ((TextMessage)msg).getText();	int currentMsgIdx = Integer.parseInt(text);	msg.acknowledge();	if ((messagesCount + diff) != currentMsgIdx) {	diff = currentMsgIdx - messagesCount;	}	++messagesCount;	if (messagesCount % messageLogFrequency == 0) {	
received messages so far 

========================= activemq sample_2822 =========================

prod.send(message);	session.commit();	messagesSent++;	LOG.info("Sent message: group=" + i + ", seq="+ seq);	}	if (i % 100 == 0) {	LOG.info("Sent messages: group=" + i);	}	setMessageGroupCount(getMessageGroupCount() + 1);	}	
messages sent 

}	if (i % 100 == 0) {	LOG.info("Sent messages: group=" + i);	}	setMessageGroupCount(getMessageGroupCount() + 1);	}	latchMessagesCreated.countDown();	prod.close();	session.close();	} catch (Exception e) {	
producer failed 

prod.close();	session.close();	} catch (Exception e) {	}	}	};	final Thread consumerThread1 = new Thread() {	public void run() {	try {	latchMessagesCreated.await();	
starting 

final Thread consumerThread1 = new Thread() {	public void run() {	try {	latchMessagesCreated.await();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Queue queue = session.createQueue(queueName);	MessageConsumer con1 = session.createConsumer(queue);	while(true) {	Message message = con1.receive(5000);	if (message == null) break;	
got message 

messagesRecvd1++;	if (messagesRecvd1 % 100 == 0) {	LOG.info("Con1: got messages count=" + messagesRecvd1);	}	}	LOG.info("Con1: total messages=" + messagesRecvd1);	LOG.info("Con1: total message groups=" + messageGroups1.size());	con1.close();	session.close();	} catch (Exception e) {	
consumer failed 

con1.close();	session.close();	} catch (Exception e) {	}	}	};	final Thread consumerThread2 = new Thread() {	public void run() {	try {	latchMessagesCreated.await();	
starting 

final Thread consumerThread2 = new Thread() {	public void run() {	try {	latchMessagesCreated.await();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Queue queue = session.createQueue(queueName);	MessageConsumer con2 = session.createConsumer(queue);	while(true) {	Message message = con2.receive(5000);	if (message == null) { break; }	
got message 

messagesRecvd2++;	if (messagesRecvd2 % 100 == 0) {	LOG.info("Con2: got messages count=" + messagesRecvd2);	}	}	con2.close();	session.close();	LOG.info("Con2: total messages=" + messagesRecvd2);	LOG.info("Con2: total message groups=" + messageGroups2.size());	} catch (Exception e) {	
consumer failed 

========================= activemq sample_3730 =========================

protected Transport createTransport(URI location, WireFormat wf) throws UnknownHostException, IOException {	URI localLocation = null;	String path = location.getPath();	if (path != null && path.length() > 0) {	int localPortIndex = path.indexOf(':');	try {	Integer.parseInt(path.substring(localPortIndex + 1, path.length()));	String localString = location.getScheme() + ":/" + path;	localLocation = new URI(localString);	} catch (Exception e) {	
path isn t a valid local location for ssltransport to use 

========================= activemq sample_113 =========================

AmqpConnection connection = trackConnection(client.connect());	AmqpSession session = connection.createSession();	AmqpSender sender = session.createSender();	assertEquals(1, getProxyToBroker().getDynamicDestinationProducers().length);	AmqpMessage message = new AmqpMessage();	message.setAddress("queue: message.setMessageId("msg" + 1);	message.setMessageAnnotation("serialNo", 1);	message.setText("Test-Message");	sender.send(message);	sender.close();	
attempting to read message with receiver 

========================= activemq sample_1561 =========================

if (warned) {	try {	TimeUnit.MILLISECONDS.sleep(lockable != null ? lockable.getLockKeepAlivePeriod() : 0l);	} catch (InterruptedException e1) {	}	}	locked = keepAlive();	break;	} catch (IOException e) {	if (!warned) {	
database is locked by another server this broker is now in slave mode waiting a lock to be acquired 

TimeUnit.MILLISECONDS.sleep(lockable != null ? lockable.getLockKeepAlivePeriod() : 0l);	} catch (InterruptedException e1) {	}	}	locked = keepAlive();	break;	} catch (IOException e) {	if (!warned) {	warned = true;	}	
database is locked waiting seconds for the database to be unlocked reason 

========================= activemq sample_4299 =========================

public void serviceFailed(DiscoveryEvent devent) throws IOException {	final SimpleDiscoveryEvent event = (SimpleDiscoveryEvent) devent;	if (event.failed.compareAndSet(false, true)) {	discoveryListener.get().onServiceRemove(event);	if (!event.removed.get()) {	Thread thread = new Thread() {	public void run() {	if (event.connectTime + minConnectTime > System.currentTimeMillis()) {	
failure occured soon after the discovery event was generated it will be clasified as a connection failure 

public void serviceFailed(DiscoveryEvent devent) throws IOException {	final SimpleDiscoveryEvent event = (SimpleDiscoveryEvent) devent;	if (event.failed.compareAndSet(false, true)) {	discoveryListener.get().onServiceRemove(event);	if (!event.removed.get()) {	Thread thread = new Thread() {	public void run() {	if (event.connectTime + minConnectTime > System.currentTimeMillis()) {	event.connectFailures++;	if (maxReconnectAttempts > 0 && event.connectFailures >= maxReconnectAttempts) {	
reconnect attempts exceeded tries reconnecting has been disabled 

if (event.connectTime + minConnectTime > System.currentTimeMillis()) {	event.connectFailures++;	if (maxReconnectAttempts > 0 && event.connectFailures >= maxReconnectAttempts) {	return;	}	synchronized (sleepMutex) {	try {	if (!running.get() || event.removed.get()) {	return;	}	
waiting ms before attepting to reconnect 

========================= activemq sample_1131 =========================

public void contextInitialized(ServletContextEvent event) {	
initializing activemq webconsole 

public void contextInitialized(ServletContextEvent event) {	String webconsoleType = getWebconsoleType();	ServletContext servletContext = event.getServletContext();	WebApplicationContext context = createWebapplicationContext(servletContext, webconsoleType);	initializeWebClient(servletContext, context);	if ("embedded".equals(webconsoleType)) {	String port = System.getProperty("jetty.port");	String host = System.getProperty("jetty.host");	if (host != null && port != null) {	
activemq webconsole available at http log info 

public void contextInitialized(ServletContextEvent event) {	String webconsoleType = getWebconsoleType();	ServletContext servletContext = event.getServletContext();	WebApplicationContext context = createWebapplicationContext(servletContext, webconsoleType);	initializeWebClient(servletContext, context);	if ("embedded".equals(webconsoleType)) {	String port = System.getProperty("jetty.port");	String host = System.getProperty("jetty.host");	if (host != null && port != null) {	}	
activemq webconsole initialized 

private WebApplicationContext createWebapplicationContext(ServletContext servletContext, String webconsoleType) {	String configuration = "/WEB-INF/webconsole-" + webconsoleType + ".xml";	
web console type 

========================= activemq sample_1326 =========================

public void testSize() throws Exception {	openConsumer(redeliveryConsumerLatch);	openDlqConsumer(dlqConsumerLatch);	assertEquals(0, broker.getAdminView().getStorePercentUsage());	for (int i = 0; i < numMessages; i++) {	sendMessage(false);	}	final BrokerView brokerView = broker.getAdminView();	broker.getSystemUsage().getStoreUsage().isFull();	
store percent usage 

openDlqConsumer(dlqConsumerLatch);	assertEquals(0, broker.getAdminView().getStorePercentUsage());	for (int i = 0; i < numMessages; i++) {	sendMessage(false);	}	final BrokerView brokerView = broker.getAdminView();	broker.getSystemUsage().getStoreUsage().isFull();	assertTrue("redelivery consumer got all it needs, remaining: " + redeliveryConsumerLatch.getCount(), redeliveryConsumerLatch.await(60, TimeUnit.SECONDS));	assertTrue("dql  consumer got all it needs", dlqConsumerLatch.await(60, TimeUnit.SECONDS));	closeConsumer();	
giving dlq a chance to clear down once topic consumer is closed 

Thread.sleep(5000);	FilenameFilter justLogFiles = new FilenameFilter() {	public boolean accept(File file, String s) {	return s.endsWith(".log");	}	};	int numFiles = ((KahaDBPersistenceAdapter) broker.getPersistenceAdapter()).getDirectory().list(justLogFiles).length;	if (numFiles > 2) {	LOG.info(Arrays.toString(((KahaDBPersistenceAdapter) broker.getPersistenceAdapter()).getDirectory().list(justLogFiles)));	}	
num files 

private void openDlqConsumer(final CountDownLatch received) throws Exception {	dlqConnection = (ActiveMQConnection) createConnection();	Session dlqSession = dlqConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer dlqConsumer = dlqSession.createConsumer(new ActiveMQQueue("ActiveMQ.DLQ"));	dlqConsumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	if (received.getCount() > 0 && received.getCount() % 200 == 0) {	
remaining on dlq 

private void closeDlqConsumer() throws JMSException, InterruptedException {	final long limit = System.currentTimeMillis() + 30 * 1000;	if (dlqConsumerLastReceivedTimeStamp > 0) {	while (System.currentTimeMillis() < dlqConsumerLastReceivedTimeStamp + 5000 && System.currentTimeMillis() < limit) {	
waiting for dlq do drain receivedcount 

========================= activemq sample_2859 =========================

public void dispose() {	if (disposed) {	return;	}	disposed = true;	try {	dataFile.closeRandomAccessFile(file);	} catch (IOException e) {	
failed to close file 

========================= activemq sample_1776 =========================

public void onMessage(Message msg) {	try {	int value = count.incrementAndGet();	if (value % 1000 == 0) {	
consumed message 

public Message createMessage(Session session) throws JMSException {	final BytesMessage message = session.createBytesMessage();	message.writeBytes(bytes);	message.setIntProperty("count", count);	message.setStringProperty("producerName", producerName);	return message;	}	});	}	} catch (final Throwable e) {	
producer is exiting 

========================= activemq sample_754 =========================

public void testAMQ4837viaJMX() throws Throwable {	for (int i = 0; i < 2; i++) {	
iteration 

========================= activemq sample_1263 =========================

private void doStartBroker(boolean delete, boolean recover) throws Exception {	broker = new BrokerService();	broker.setDeleteAllMessagesOnStartup(delete);	broker.setPersistent(true);	broker.setUseJmx(true);	broker.addConnector("tcp: configurePersistence(broker, recover);	connectionUri = "vm: cf = new ActiveMQConnectionFactory(connectionUri);	broker.start();	
starting broker 

public void testNoRestartOnMissingAckDataFile() throws Exception {	startBroker();	makeAckChain();	File dataDir = broker.getPersistenceAdapter().getDirectory();	broker.stop();	broker.waitUntilStopped();	File secondLastDataFile = new File(dataDir, "db-3.log");	
whacking data file with acks 

public void testAckRemovedMessageReplayedAfterRecovery() throws Exception {	startBroker();	StagedConsumer consumer = new StagedConsumer();	int numMessagesAvailable = produceMessagesToConsumeMultipleDataFiles(20);	Message firstUnacked = consumer.receive(10);	
first unacked 

public void testAckRemovedMessageReplayedAfterRecovery() throws Exception {	startBroker();	StagedConsumer consumer = new StagedConsumer();	int numMessagesAvailable = produceMessagesToConsumeMultipleDataFiles(20);	Message firstUnacked = consumer.receive(10);	Message secondUnacked = consumer.receive(1);	
second unacked 

public void testAckRemovedMessageReplayedAfterRecovery() throws Exception {	startBroker();	StagedConsumer consumer = new StagedConsumer();	int numMessagesAvailable = produceMessagesToConsumeMultipleDataFiles(20);	Message firstUnacked = consumer.receive(10);	Message secondUnacked = consumer.receive(1);	numMessagesAvailable -= 11;	numMessagesAvailable += produceMessagesToConsumeMultipleDataFiles(10);	
acking firstunacked 

private int getNumberOfJournalFiles() throws IOException {	Collection<DataFile> files = ((KahaDBPersistenceAdapter) broker.getPersistenceAdapter()).getStore().getJournal().getFileMap().values();	
data files 

public Message receive(int numToReceive, int timeoutInSeconds) throws Exception {	Message msg = null;	for (; numToReceive > 0; numToReceive--) {	do  {	msg = consumer.receive(1*1000);	} while (msg == null && --timeoutInSeconds > 0);	if (numToReceive > 1) {	msg.acknowledge();	}	if (msg != null) {	
received 

========================= activemq sample_2766 =========================

}	if (timeToLive > 0 && ttlCeiling > 0 && timeToLive > ttlCeiling) {	timeToLive = ttlCeiling;	}	long expiration = timeToLive + newTimeStamp;	if(!futureOnly || (expiration > oldExpiration)) {	if (timeToLive > 0 && expiration > 0) {	message.setExpiration(expiration);	}	message.setTimestamp(newTimeStamp);	
set message timestamp from to 

========================= activemq sample_3874 =========================

Connection connection = factory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer mp = session.createProducer(null);	for (int j = 0; j < NUMBER_OF_DESTINATIONS; j++) {	Destination dest = getDestination(session);	for (int i = 0; i < MESSAGE_COUNT; i++) {	Message msg = session.createTextMessage("test" + i);	mp.send(dest, msg);	}	if (j % 500 == 0) {	
iterator 

========================= activemq sample_3527 =========================

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	connection = createConnection();	if (durable) {	connection.setClientID(getClass().getName());	}	
created connection 

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	connection = createConnection();	if (durable) {	connection.setClientID(getClass().getName());	}	session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	
created session 

producer = session.createProducer(null);	producer.setDeliveryMode(deliveryMode);	LOG.info("Created producer: " + producer + " delivery mode = " + (deliveryMode == DeliveryMode.PERSISTENT ? "PERSISTENT" : "NON_PERSISTENT"));	if (topic) {	consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	} else {	consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	}	
created consumer destination of type 

producer = session.createProducer(null);	producer.setDeliveryMode(deliveryMode);	LOG.info("Created producer: " + producer + " delivery mode = " + (deliveryMode == DeliveryMode.PERSISTENT ? "PERSISTENT" : "NON_PERSISTENT"));	if (topic) {	consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	} else {	consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	}	
created producer destination of type 

protected MessageConsumer createConsumer() throws JMSException {	if (durable) {	
creating durable consumer 

protected void tearDown() throws Exception {	
dumping stats 

protected void tearDown() throws Exception {	
closing down connection 

========================= activemq sample_2273 =========================

broker.setPersistent(true);	broker.setUseJmx(true);	KahaDBStore kaha = new KahaDBStore();	kaha.setDirectory(new File("target/activemq-data/kahadb"));	kaha.setEnableJournalDiskSyncs(false);	kaha.setJournalMaxFileLength(1024*1024*100);	kaha.setIndexWriteBatchSize(100);	kaha.setEnableIndexWriteAsync(true);	broker.setPersistenceAdapter(kaha);	broker.addConnector("tcp: broker.start();	
starting broker 

========================= activemq sample_2789 =========================

private boolean hasBeenModified() {	boolean modified = false;	File localFile = new File(file.getAbsolutePath());	if (localFile.exists()) {	if(localFile.lastModified() != lastModified) {	
lock file locked at has been modified at 

private boolean hasBeenModified() {	boolean modified = false;	File localFile = new File(file.getAbsolutePath());	if (localFile.exists()) {	if(localFile.lastModified() != lastModified) {	modified = true;	}	}	else {	
lock file does not exist 

========================= activemq sample_4173 =========================

public java.sql.Connection initDb() throws Exception {	String createStatement = "CREATE TABLE SCP_INPUT_MESSAGES (" + "id int NOT NULL GENERATED ALWAYS AS IDENTITY, " + "messageId varchar(96) NOT NULL, " + "messageCorrelationId varchar(96) NOT NULL, " + "messageContent varchar(2048) NOT NULL, " + "PRIMARY KEY (id) )";	java.sql.Connection conn = getJDBCConnection();	try {	conn.createStatement().execute(createStatement);	} catch (SQLException alreadyExists) {	
ex on create tables 

public java.sql.Connection initDb() throws Exception {	String createStatement = "CREATE TABLE SCP_INPUT_MESSAGES (" + "id int NOT NULL GENERATED ALWAYS AS IDENTITY, " + "messageId varchar(96) NOT NULL, " + "messageCorrelationId varchar(96) NOT NULL, " + "messageContent varchar(2048) NOT NULL, " + "PRIMARY KEY (id) )";	java.sql.Connection conn = getJDBCConnection();	try {	conn.createStatement().execute(createStatement);	} catch (SQLException alreadyExists) {	}	try {	conn.createStatement().execute("DELETE FROM SCP_INPUT_MESSAGES");	} catch (SQLException ex) {	
ex on create delete all 

private int dumpDb(java.sql.Connection jdbcConn) throws Exception {	int count = 0;	ResultSet resultSet = jdbcConn.createStatement().executeQuery("SELECT * FROM SCP_INPUT_MESSAGES");	while (resultSet.next()) {	count++;	
message seq id corr content 

public void testRecoveryCommit() throws Exception {	java.sql.Connection jdbcConn = initDb();	sendJMSMessageToKickOffRoute();	
waiting for route to kick in it will kill the broker on first commit 

public void testRecoveryCommit() throws Exception {	java.sql.Connection jdbcConn = initDb();	sendJMSMessageToKickOffRoute();	broker.waitUntilStopped();	assertEquals("message in db, commit to db worked", 1, dumpDb(jdbcConn));	
broker stopped restarting 

public void testRecoveryCommit() throws Exception {	java.sql.Connection jdbcConn = initDb();	sendJMSMessageToKickOffRoute();	broker.waitUntilStopped();	assertEquals("message in db, commit to db worked", 1, dumpDb(jdbcConn));	broker = createBroker(false);	broker.start();	broker.waitUntilStarted();	assertEquals("pending transactions", 1, broker.getBroker().getPreparedTransactions(null).length);	
waiting for recovery to complete 

broker = createBroker(true);	broker.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {	if (onePhase) {	super.commitTransaction(context, xid, onePhase);	} else {	context.setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
stopping broker post commit 

========================= activemq sample_1371 =========================

private void waitFor(Condition condition) throws Exception {	final long expiry = System.currentTimeMillis() + MAX_WAIT_MILLIS;	while (!condition.isSatisified() && System.currentTimeMillis() < expiry) {	Thread.sleep(1000);	}	if (System.currentTimeMillis() >= expiry) {	
expired while waiting for condition 

public void XtestMigrateConsumerStuckMessages() throws Exception {	boolean suppressQueueDuplicateSubscriptions = false;	bridgeAllBrokers("default", 3, suppressQueueDuplicateSubscriptions);	startAllBrokers();	waitForBridgeFormation();	Destination dest = createDestination("TEST.FOO", false);	
consumer on a 

public void XtestMigrateConsumerStuckMessages() throws Exception {	boolean suppressQueueDuplicateSubscriptions = false;	bridgeAllBrokers("default", 3, suppressQueueDuplicateSubscriptions);	startAllBrokers();	waitForBridgeFormation();	Destination dest = createDestination("TEST.FOO", false);	MessageConsumer clientA = createConsumer("BrokerA", dest);	Thread.sleep(2000);	
consumer on b 

bridgeAllBrokers("default", 3, suppressQueueDuplicateSubscriptions);	startAllBrokers();	waitForBridgeFormation();	Destination dest = createDestination("TEST.FOO", false);	MessageConsumer clientA = createConsumer("BrokerA", dest);	Thread.sleep(2000);	int messageCount = 2000;	CountDownLatch messagesReceived = new CountDownLatch(messageCount/2);	MessageConsumer clientB = createConsumer("BrokerB", dest, messagesReceived);	Thread.sleep(2000);	
close consumer on a 

waitForBridgeFormation();	Destination dest = createDestination("TEST.FOO", false);	MessageConsumer clientA = createConsumer("BrokerA", dest);	Thread.sleep(2000);	int messageCount = 2000;	CountDownLatch messagesReceived = new CountDownLatch(messageCount/2);	MessageConsumer clientB = createConsumer("BrokerB", dest, messagesReceived);	Thread.sleep(2000);	clientA.close();	Thread.sleep(2000);	
send to b 

public void testMigrateConsumer() throws Exception {	boolean suppressQueueDuplicateSubscriptions = true;	boolean decreaseNetworkConsumerPriority = true;	bridgeAllBrokers("default", 3, suppressQueueDuplicateSubscriptions, decreaseNetworkConsumerPriority);	startAllBrokers();	waitForBridgeFormation();	Destination dest = createDestination("TEST.FOO", false);	
consumer on a 

public void testMigrateConsumer() throws Exception {	boolean suppressQueueDuplicateSubscriptions = true;	boolean decreaseNetworkConsumerPriority = true;	bridgeAllBrokers("default", 3, suppressQueueDuplicateSubscriptions, decreaseNetworkConsumerPriority);	startAllBrokers();	waitForBridgeFormation();	Destination dest = createDestination("TEST.FOO", false);	MessageConsumer clientA = createConsumer("BrokerA", dest);	Thread.sleep(2000);	
consumer on b 

waitForBridgeFormation();	Destination dest = createDestination("TEST.FOO", false);	MessageConsumer clientA = createConsumer("BrokerA", dest);	Thread.sleep(2000);	int messageCount = 2000;	CountDownLatch messagesReceived = new CountDownLatch(messageCount);	MessageConsumer clientB = createConsumer("BrokerB", dest, messagesReceived);	MessageIdList msgs = getConsumerMessages("BrokerB", clientB);	msgs.setProcessingDelay(10);	Thread.sleep(2000);	
close consumer on a 

MessageConsumer clientA = createConsumer("BrokerA", dest);	Thread.sleep(2000);	int messageCount = 2000;	CountDownLatch messagesReceived = new CountDownLatch(messageCount);	MessageConsumer clientB = createConsumer("BrokerB", dest, messagesReceived);	MessageIdList msgs = getConsumerMessages("BrokerB", clientB);	msgs.setProcessingDelay(10);	Thread.sleep(2000);	clientA.close();	Thread.sleep(2000);	
send to b 

bridgeAllBrokers("default", 3, suppressQueueDuplicateSubscriptions, decreaseNetworkConsumerPriority);	final Destination dest = createDestination("TEST.FOO", false);	BrokerItem brokerB = brokers.get("BrokerA");	brokerB.broker.setPlugins(new BrokerPlugin[]{new BrokerPlugin() {	public Broker installPlugin(Broker broker) throws Exception {	return new BrokerFilter(broker) {	final AtomicInteger count = new AtomicInteger();	public void preProcessDispatch( MessageDispatch messageDispatch) {	if (messageDispatch.getDestination().getPhysicalName().contains("ActiveMQ.Advisory.Consumer")) {	if (count.getAndIncrement() == 0) {	
sleeping on first advisory 

private void verifyConsumerCount(BrokerService broker, int count, final Destination dest) throws Exception {	final RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();	waitFor(new Condition() {	public boolean isSatisified() throws Exception {	return !regionBroker.getDestinations(ActiveMQDestination.transform(dest)).isEmpty();	}	});	Queue internalQueue = (Queue) regionBroker.getDestinations(ActiveMQDestination.transform(dest)).iterator().next();	
verify consumer count on matches val 

========================= activemq sample_3659 =========================

protected void delayTillRestartRequired() {	if (restartDelay > 2000) {	
delay for more than lease quantum while db is offline master should stay alive but could loose lease 

protected void delayTillRestartRequired() {	if (restartDelay > 2000) {	} else {	
delay for less than lease quantum while db is offline master should stay alive 

========================= activemq sample_2418 =========================

public void testOfflineDurableSubscriberTimeout() throws Exception {	final AtomicBoolean foundLogMessage = new AtomicBoolean(false);	Appender appender = new DefaultTestAppender() {	public void doAppend(LoggingEvent event) {	if (event.getLevel().isGreaterOrEqual(Level.WARN)) {	
received unexpected log message 

}	};	org.apache.log4j.Logger log4jLoggerMRB = org.apache.log4j.Logger.getLogger(ManagedRegionBroker.class);	org.apache.log4j.Logger log4jLoggerT = org.apache.log4j.Logger.getLogger(org.apache.activemq.broker.region.Topic.class);	log4jLoggerMRB.addAppender(appender);	log4jLoggerT.addAppender(appender);	try {	createOfflineDurableSubscribers("topic_new");	assertTrue(Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
broker getadminview getinactivedurabletopicsubscribers 

assertTrue(Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return broker.getAdminView().getInactiveDurableTopicSubscribers().length == 1;	}	}));	assertTrue(Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return broker.getAdminView().getInactiveDurableTopicSubscribers().length == 0;	}	}));	
create consumer for 

========================= activemq sample_3570 =========================

public void testSendReceiveAfterReconnect() throws Exception {	brokerA = createBroker("tcp", "61617", null);	brokerA.start();	brokerB = createBroker("tcp", "62617", new String[]{"61617"});	brokerB.start();	doTestNetworkSendReceive();	
stopping brokera 

public void testSendReceiveAfterReconnect() throws Exception {	brokerA = createBroker("tcp", "61617", null);	brokerA.start();	brokerB = createBroker("tcp", "62617", new String[]{"61617"});	brokerB.start();	doTestNetworkSendReceive();	brokerA.stop();	brokerA.waitUntilStopped();	
restarting brokera 

public void testSendReceiveFailover() throws Exception {	brokerA = createBroker("tcp", "61617", null);	brokerA.start();	brokerB = createBroker("tcp", "62617", new String[]{"61617", "63617"});	brokerB.start();	doTestNetworkSendReceive();	Set<String> bridgeNames = getNetworkBridgeMBeanName(brokerB);	assertEquals("only one bridgeName: " + bridgeNames, 1, bridgeNames.size());	
stopping brokera 

public void testSendReceiveFailover() throws Exception {	brokerA = createBroker("tcp", "61617", null);	brokerA.start();	brokerB = createBroker("tcp", "62617", new String[]{"61617", "63617"});	brokerB.start();	doTestNetworkSendReceive();	Set<String> bridgeNames = getNetworkBridgeMBeanName(brokerB);	assertEquals("only one bridgeName: " + bridgeNames, 1, bridgeNames.size());	brokerA.stop();	brokerA.waitUntilStopped();	
restarting brokera 

}	}	});	executor.shutdown();	HashMap<String, String> networkConnectorProps = new HashMap<String, String>();	networkConnectorProps.put("duplex", "true");	brokerB = createBroker("tcp", "62617", new String[]{"61617", "63617"}, networkConnectorProps);	brokerB.start();	doTestNetworkSendReceive(brokerA, brokerB);	doTestNetworkSendReceive(brokerB, brokerA);	
stopping brokera master shared broker 

brokerB = createBroker("tcp", "62617", new String[]{"61617", "63617"}, networkConnectorProps);	brokerB.start();	assertTrue("all props applied", networkConnectorProps.isEmpty());	networkConnectorProps.put("duplex", "true");	networkConnectorProps.put("networkTTL", "2");	brokerC = createBroker("tcp", "64617", new String[]{"61617", "63617"}, networkConnectorProps);	brokerC.start();	assertTrue("all props applied a second time", networkConnectorProps.isEmpty());	doTestNetworkSendReceive(brokerC, brokerB);	doTestNetworkSendReceive(brokerB, brokerC);	
stopping brokera master shared broker 

while (!done.get()) {	brokerA = createBroker("tcp", "61610", null);	brokerA.setBrokerName("Pair");	brokerA.setBrokerObjectName(new ObjectName(brokerA.getManagementContext().getJmxDomainName() + ":" + "brokerName=" + JMXSupport.encodeObjectNamePart("A") + "," + "Type=Broker"));	((KahaDBPersistenceAdapter)brokerA.getPersistenceAdapter()).getLocker().setLockAcquireSleepInterval(1000);	brokerA.start();	brokerA.waitUntilStopped();	brokerA1.waitUntilStarted();	}	} catch (Exception ignored) {	
a create start unexpected 

while (!done.get()) {	brokerA1 = createBroker("tcp", "61611", null);	brokerA1.setBrokerName("Pair");	brokerA1.setBrokerObjectName(new ObjectName(brokerA.getManagementContext().getJmxDomainName() + ":" + "brokerName=" + JMXSupport.encodeObjectNamePart("A1") + "," + "Type=Broker"));	((KahaDBPersistenceAdapter)brokerA1.getPersistenceAdapter()).getLocker().setLockAcquireSleepInterval(1000);	brokerA1.start();	brokerA1.waitUntilStopped();	brokerA.waitUntilStarted();	}	} catch (Exception ignored) {	
create start unexpected 

brokerA1.start();	brokerA1.waitUntilStopped();	brokerA.waitUntilStarted();	}	} catch (Exception ignored) {	}	}	});	for (int i=0; i<4; i++) {	BrokerService currentMaster =  (i%2 == 0 ? brokerA : brokerA1);	
iteration using brokerName 

brokerA.waitUntilStarted();	}	} catch (Exception ignored) {	}	}	});	for (int i=0; i<4; i++) {	BrokerService currentMaster =  (i%2 == 0 ? brokerA : brokerA1);	currentMaster.waitUntilStarted();	doTestNetworkSendReceive(brokerB, currentMaster);	
stopping brokerName 

}	});	for (int i=0; i<4; i++) {	BrokerService currentMaster =  (i%2 == 0 ? brokerA : brokerA1);	currentMaster.waitUntilStarted();	doTestNetworkSendReceive(brokerB, currentMaster);	currentMaster.stop();	currentMaster.waitUntilStopped();	}	done.set(true);	
all done 

private void doTestNetworkSendReceive(final BrokerService to, final BrokerService from) throws Exception, JMSException {	
creating consumer on the networked broker 

private void doTestNetworkSendReceive(final BrokerService to, final BrokerService from) throws Exception, JMSException {	SslContext.setCurrentSslContext(sslContext);	ConnectionFactory consFactory = createConnectionFactory(from);	Connection consConn = consFactory.createConnection();	consConn.start();	Session consSession = consConn.createSession(false, Session.AUTO_ACKNOWLEDGE);	ActiveMQDestination destination = (ActiveMQDestination) consSession.createQueue(DESTINATION_NAME);	final MessageConsumer consumer = consSession.createConsumer(destination);	
publishing to 

ConnectionFactory consFactory = createConnectionFactory(from);	Connection consConn = consFactory.createConnection();	consConn.start();	Session consSession = consConn.createSession(false, Session.AUTO_ACKNOWLEDGE);	ActiveMQDestination destination = (ActiveMQDestination) consSession.createQueue(DESTINATION_NAME);	final MessageConsumer consumer = consSession.createConsumer(destination);	sendMessageTo(destination, to);	boolean gotMessage = Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	Message message = consumer.receive(5000);	
from brokerName received 

========================= activemq sample_2731 =========================

public void purgeAllMessages() throws IOException, Exception {	List<ObjectInstance> queueList = JmxMBeansUtil.queryMBeans( createJmxConnection(), "type=Broker,brokerName=localbroker,destinationType=Queue,destinationName=*");	for (ObjectInstance oi : queueList) {	ObjectName queueName = oi.getObjectName();	
purging all messages in queue Destination 

try {	addMessages();	validateCounts(MESSAGE_COUNT, MESSAGE_COUNT, MESSAGE_COUNT * 2);	List<String> tokens = Arrays.asList(new String[] { "*" });	for (String token : tokens) {	List<ObjectInstance> queueList = JmxMBeansUtil.queryMBeans( createJmxConnection(), "type=Broker,brokerName=localbroker,destinationType=Queue,destinationName=" + token);	for (ObjectInstance queue : queueList) {	ObjectName queueName = queue .getObjectName();	QueueViewMBean proxy = MBeanServerInvocationHandler .newProxyInstance(createJmxConnection(), queueName, QueueViewMBean.class, true);	int removed = proxy .removeMatchingMessages(MSG_SEL_WITH_PROPERTY);	
removed 

public void testPurgeCommandComplexSQLSelector_AND() throws Exception {	try {	String one = "ID:mac.fritz.box:1213242.3231.1:1:1:100";	String two = "\\*:100";	try {	
string matches 

public void testPurgeCommandComplexSQLSelector_AND() throws Exception {	try {	String one = "ID:mac.fritz.box:1213242.3231.1:1:1:100";	String two = "\\*:100";	try {	
string does not match 

public void testDummy() throws Exception {	try {	String one = "ID:mac.fritz.box:1213242.3231.1:1:1:100";	String two = "ID*:100";	try {	
string matches 

public void testDummy() throws Exception {	try {	String one = "ID:mac.fritz.box:1213242.3231.1:1:1:100";	String two = "ID*:100";	try {	
string does not match 

========================= activemq sample_3823 =========================

public void setPhysicalName(String physicalName) {	super.setPhysicalName(physicalName);	if (!isComposite()) {	int p = this.physicalName.lastIndexOf(":");	if (p >= 0) {	String seqStr = this.physicalName.substring(p + 1).trim();	if (seqStr != null && seqStr.length() > 0) {	try {	sequenceId = Integer.parseInt(seqStr);	} catch (NumberFormatException e) {	
did not parse sequence id from 

========================= activemq sample_580 =========================

public void testTelnetStyleSends() throws Exception {	stompConnection.setVersion(Stomp.V1_2);	String connect = "CONNECT\r\n" + "accept-version:1.2\r\n" + "login:system\r\n" + "passcode:manager\r\n" + "\r\n" + "\u0000\r\n";	stompConnection.sendFrame(connect);	String f = stompConnection.receiveFrame();	
broker sent 

stompConnection.setVersion(Stomp.V1_2);	String connect = "CONNECT\r\n" + "accept-version:1.2\r\n" + "login:system\r\n" + "passcode:manager\r\n" + "\r\n" + "\u0000\r\n";	stompConnection.sendFrame(connect);	String f = stompConnection.receiveFrame();	assertTrue(f.startsWith("CONNECTED"));	assertTrue(f.indexOf("version:1.2") >= 0);	assertTrue(f.indexOf("session:") >= 0);	String send = "SUBSCRIBE\r\n" + "id:1\r\n" + "destination:/queue/" + getQueueName() + "\r\n" + "receipt:1\r\n" + "\r\n"+ "\u0000\r\n";	stompConnection.sendFrame(send);	StompFrame receipt = stompConnection.receive();	
broker sent 

public void testClientAckWithoutAckId() throws Exception {	stompConnection.setVersion(Stomp.V1_2);	String connect = "STOMP\r\n" + "accept-version:1.2\r\n" + "login:system\r\n" + "passcode:manager\r\n" + "\r\n" + "\u0000\r\n";	stompConnection.sendFrame(connect);	String f = stompConnection.receiveFrame();	
broker sent 

stompConnection.setVersion(Stomp.V1_2);	String connect = "STOMP\r\n" + "accept-version:1.2\r\n" + "login:system\r\n" + "passcode:manager\r\n" + "\r\n" + "\u0000\r\n";	stompConnection.sendFrame(connect);	String f = stompConnection.receiveFrame();	assertTrue(f.startsWith("CONNECTED"));	assertTrue(f.indexOf("version:1.2") >= 0);	assertTrue(f.indexOf("session:") >= 0);	String subscribe = "SUBSCRIBE\n" + "id:1\n" + "activemq.prefetchSize=1\n" + "ack:client\n" + "destination:/queue/" + getQueueName() + "\n" + "receipt:1\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(subscribe);	StompFrame receipt = stompConnection.receive();	
broker sent 

String message = "SEND\n" + "destination:/queue/" + getQueueName() + "\n\n" + "1" + Stomp.NULL;	stompConnection.sendFrame(message);	StompFrame received = stompConnection.receive();	assertTrue(received.getAction().equals("MESSAGE"));	assertTrue(received.getHeaders().containsKey(Stomp.Headers.Message.ACK_ID));	assertEquals("1", received.getBody());	String frame = "ACK\n" + "message-id:" + received.getHeaders().get(Stomp.Headers.Message.ACK_ID) + "\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	received = stompConnection.receive();	assertTrue(received.getAction().equals("ERROR"));	
broker sent 

public void testClientAck() throws Exception {	stompConnection.setVersion(Stomp.V1_2);	String connect = "STOMP\r\n" + "accept-version:1.2\r\n" + "login:system\r\n" + "passcode:manager\r\n" + "\r\n" + "\u0000\r\n";	stompConnection.sendFrame(connect);	String f = stompConnection.receiveFrame();	
broker sent 

stompConnection.setVersion(Stomp.V1_2);	String connect = "STOMP\r\n" + "accept-version:1.2\r\n" + "login:system\r\n" + "passcode:manager\r\n" + "\r\n" + "\u0000\r\n";	stompConnection.sendFrame(connect);	String f = stompConnection.receiveFrame();	assertTrue(f.startsWith("CONNECTED"));	assertTrue(f.indexOf("version:1.2") >= 0);	assertTrue(f.indexOf("session:") >= 0);	String subscribe = "SUBSCRIBE\n" + "id:1\n" + "ack:client\n" + "destination:/queue/" + getQueueName() + "\n" + "receipt:1\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(subscribe);	StompFrame receipt = stompConnection.receive();	
broker sent 

stompConnection.sendFrame(subscribe);	StompFrame receipt = stompConnection.receive();	assertTrue(receipt.getAction().startsWith("RECEIPT"));	String receiptId = receipt.getHeaders().get("receipt-id");	assertEquals("1", receiptId);	String message = "SEND\n" + "destination:/queue/" + getQueueName() + "\n\n" + "1" + Stomp.NULL;	stompConnection.sendFrame(message);	message = "SEND\n" + "destination:/queue/" + getQueueName() + "\n\n" + "2" + Stomp.NULL;	stompConnection.sendFrame(message);	StompFrame received = stompConnection.receive();	
stomp message 

assertEquals("1", receiptId);	String message = "SEND\n" + "destination:/queue/" + getQueueName() + "\n\n" + "1" + Stomp.NULL;	stompConnection.sendFrame(message);	message = "SEND\n" + "destination:/queue/" + getQueueName() + "\n\n" + "2" + Stomp.NULL;	stompConnection.sendFrame(message);	StompFrame received = stompConnection.receive();	assertTrue(received.getAction().equals("MESSAGE"));	assertTrue(received.getHeaders().containsKey(Stomp.Headers.Message.ACK_ID));	assertEquals("1", received.getBody());	received = stompConnection.receive();	
stomp message 

frame = "DISCONNECT\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	assertTrue(Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getProxyToBroker().getCurrentConnectionsCount() == 1;	}	}, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(25)));	stompConnect();	stompConnection.sendFrame(connect);	frame = stompConnection.receiveFrame();	
broker sent 

public boolean isSatisified() throws Exception {	return getProxyToBroker().getCurrentConnectionsCount() == 1;	}	}, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(25)));	stompConnect();	stompConnection.sendFrame(connect);	frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	stompConnection.sendFrame(subscribe);	receipt = stompConnection.receive();	
broker sent 

frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	stompConnection.sendFrame(subscribe);	receipt = stompConnection.receive();	assertTrue(receipt.getAction().startsWith("RECEIPT"));	receiptId = receipt.getHeaders().get("receipt-id");	assertEquals("1", receiptId);	message = "SEND\n" + "destination:/queue/" + getQueueName() + "\n\n" + "3" + Stomp.NULL;	stompConnection.sendFrame(message);	received = stompConnection.receive();	
stomp message 

public void testClientIndividualAck() throws Exception {	stompConnection.setVersion(Stomp.V1_2);	String connect = "STOMP\r\n" + "accept-version:1.2\r\n" + "login:system\r\n" + "passcode:manager\r\n" + "\r\n" + "\u0000\r\n";	stompConnection.sendFrame(connect);	String f = stompConnection.receiveFrame();	
broker sent 

stompConnection.setVersion(Stomp.V1_2);	String connect = "STOMP\r\n" + "accept-version:1.2\r\n" + "login:system\r\n" + "passcode:manager\r\n" + "\r\n" + "\u0000\r\n";	stompConnection.sendFrame(connect);	String f = stompConnection.receiveFrame();	assertTrue(f.startsWith("CONNECTED"));	assertTrue(f.indexOf("version:1.2") >= 0);	assertTrue(f.indexOf("session:") >= 0);	String subscribe = "SUBSCRIBE\n" + "id:1\n" + "ack:client-individual\n" + "destination:/queue/" + getQueueName() + "\n" + "receipt:1\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(subscribe);	StompFrame receipt = stompConnection.receive();	
broker sent 

frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getProxyToBroker().getCurrentConnectionsCount() <= 1;	}	}, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(25));	stompConnect();	stompConnection.sendFrame(connect);	frame = stompConnection.receiveFrame();	
broker sent 

public boolean isSatisified() throws Exception {	return getProxyToBroker().getCurrentConnectionsCount() <= 1;	}	}, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(25));	stompConnect();	stompConnection.sendFrame(connect);	frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	stompConnection.sendFrame(subscribe);	receipt = stompConnection.receive();	
broker sent 

public void testQueueBrowerSubscription() throws Exception {	final int MSG_COUNT = 10;	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.2\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

assertEquals("0", repsonse.getHeaders().get(Stomp.Headers.Response.RECEIPT_ID));	}	String subscribe = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "id:12345\n" + "browser:true\n\n" + Stomp.NULL;	stompConnection.sendFrame(subscribe);	for(int i = 0; i < MSG_COUNT; ++i) {	StompFrame message = stompConnection.receive();	assertEquals(Stomp.Responses.MESSAGE, message.getAction());	assertEquals("12345", message.getHeaders().get(Stomp.Headers.Message.SUBSCRIPTION));	}	StompFrame browseDone = stompConnection.receive();	
browse done 

public void testQueueBrowerNotInAutoAckMode() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.2\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

public void testQueueBrowerNotInAutoAckMode() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.2\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	assertTrue(f.startsWith("CONNECTED"));	String subscribe = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:client\n" + "id:12345\n" + "browser:true\n\n" + Stomp.NULL;	stompConnection.sendFrame(subscribe);	StompFrame browseDone = stompConnection.receive();	
browse done 

public void testDurableSubAndUnSub() throws Exception {	BrokerViewMBean view = getProxyToBroker();	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.2\n" + "host:localhost\n" + "client-id:durableSubTest\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String frame = stompConnection.receiveFrame();	
broker sent 

public void testDurableSubAndUnSub() throws Exception {	BrokerViewMBean view = getProxyToBroker();	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.2\n" + "host:localhost\n" + "client-id:durableSubTest\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	assertEquals(view.getDurableTopicSubscribers().length, 0);	frame = "SUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "1" + "\n" + "ack:auto\n" + "receipt:1\n" + "id:durablesub-1\n" + "activemq.subscriptionName:test1\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	StompFrame receipt = stompConnection.receive();	
broker sent 

stompConnection.sendFrame(frame);	stompConnection.close();	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getProxyToBroker().getCurrentConnectionsCount() <= 1;	}	}, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(25));	stompConnect();	stompConnection.sendFrame(connectFrame);	frame = stompConnection.receiveFrame();	
broker sent 

}, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(25));	stompConnect();	stompConnection.sendFrame(connectFrame);	frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	assertEquals(view.getDurableTopicSubscribers().length, 0);	assertEquals(view.getInactiveDurableTopicSubscribers().length, 1);	frame = "UNSUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "1\n" + "id:durablesub-1\n" + "receipt:3\n" + "activemq.subscriptionName:test1\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	receipt = stompConnection.receive();	
broker sent 

public void testSubscribeWithNoId() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.2\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

public void testSizeAndBrokerUsage() throws Exception {	final int MSG_COUNT = 10;	final int numK = 4;	final byte[] bigPropContent = new byte[numK*1024];	Arrays.fill(bigPropContent, Byte.MAX_VALUE);	final String bigProp = new String(bigPropContent);	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.2\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

final String bigProp = new String(bigPropContent);	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.2\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	assertTrue(f.startsWith("CONNECTED"));	long usageStart = brokerService.getSystemUsage().getMemoryUsage().getUsage();	for(int i = 0; i < MSG_COUNT; ++i) {	String message = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "receipt:0\n" + "myXkProp:" + bigProp + "\n"+ "\n" + "Hello World {" + i + "}" + Stomp.NULL;	stompConnection.sendFrame(message);	StompFrame repsonse = stompConnection.receive();	
response 

assertTrue(f.startsWith("CONNECTED"));	long usageStart = brokerService.getSystemUsage().getMemoryUsage().getUsage();	for(int i = 0; i < MSG_COUNT; ++i) {	String message = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "receipt:0\n" + "myXkProp:" + bigProp + "\n"+ "\n" + "Hello World {" + i + "}" + Stomp.NULL;	stompConnection.sendFrame(message);	StompFrame repsonse = stompConnection.receive();	assertEquals("0", repsonse.getHeaders().get(Stomp.Headers.Response.RECEIPT_ID));	}	long usageEnd = brokerService.getSystemUsage().getMemoryUsage().getUsage();	long usageDiff = usageEnd - usageStart;	
usagediff 

========================= activemq sample_1408 =========================

Destination destination = getMandatoryBean(Destination.class, "sendTo");	ConnectionFactory factory = getMandatoryBean(ConnectionFactory.class, "connectionFactory");	Connection connection = factory.createConnection();	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	ObjectMessage message = session.createObjectMessage(expectedBody);	message.setStringProperty("foo", "bar");	producer.send(message);	result.assertIsSatisfied();	
received message 

public void testConsumingViaJMSReceivesMessageFromCamel() throws Exception {	Destination destination = getMandatoryBean(Destination.class, "consumeFrom");	ConnectionFactory factory = getMandatoryBean(ConnectionFactory.class, "connectionFactory");	ProducerTemplate template = getMandatoryBean(ProducerTemplate.class, "camelTemplate");	assertNotNull("template is valid", template);	Connection connection = factory.createConnection();	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	
consuming from 

assertNotNull("template is valid", template);	Connection connection = factory.createConnection();	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createConsumer(destination);	template.sendBody("seda:consumer", expectedBody);	Message message = consumer.receive(5000);	assertNotNull("Should have received a message from destination: " + destination, message);	TextMessage textMessage = assertIsInstanceOf(TextMessage.class, message);	assertEquals("Message body", expectedBody, textMessage.getText());	
received message 

========================= activemq sample_1367 =========================

connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(bigQueue);	producer.setDeliveryMode(deliveryMode);	BytesMessage bytesMessage = session.createBytesMessage();	bytesMessage.writeBytes(new byte[messageSize]);	for (int i = 0; i < messageCount; i++) {	producer.send(bigQueue, bytesMessage);	}	final QueueViewMBean queueViewMBean = (QueueViewMBean) broker.getManagementContext().newProxyInstance(broker.getAdminView().getQueues()[0], QueueViewMBean.class, false);	
size 

BytesMessage bytesMessage = session.createBytesMessage();	bytesMessage.writeBytes(new byte[messageSize]);	for (int i = 0; i < messageCount; i++) {	producer.send(bigQueue, bytesMessage);	}	final QueueViewMBean queueViewMBean = (QueueViewMBean) broker.getManagementContext().newProxyInstance(broker.getAdminView().getQueues()[0], QueueViewMBean.class, false);	connection.close();	assertFalse("Cache disabled on q", queueViewMBean.isCacheEnabled());	final Queue underTest = (Queue) ((RegionBroker)broker.getRegionBroker()).getQueueRegion().getDestinationMap().get(bigQueue);	Message[] browsed = underTest.browse();	
browsed 

for (int i = 0; i < messageCount; i++) {	producer.send(bigQueue, bytesMessage);	}	final QueueViewMBean queueViewMBean = (QueueViewMBean) broker.getManagementContext().newProxyInstance(broker.getAdminView().getQueues()[0], QueueViewMBean.class, false);	connection.close();	assertFalse("Cache disabled on q", queueViewMBean.isCacheEnabled());	final Queue underTest = (Queue) ((RegionBroker)broker.getRegionBroker()).getQueueRegion().getDestinationMap().get(bigQueue);	Message[] browsed = underTest.browse();	assertEquals("maxBrowsePageSize", maxBrowsePageSize, browsed.length);	browsed = underTest.browse();	
browsed 

final QueueViewMBean queueViewMBean = (QueueViewMBean) broker.getManagementContext().newProxyInstance(broker.getAdminView().getQueues()[0], QueueViewMBean.class, false);	connection.close();	assertFalse("Cache disabled on q", queueViewMBean.isCacheEnabled());	final Queue underTest = (Queue) ((RegionBroker)broker.getRegionBroker()).getQueueRegion().getDestinationMap().get(bigQueue);	Message[] browsed = underTest.browse();	assertEquals("maxBrowsePageSize", maxBrowsePageSize, browsed.length);	browsed = underTest.browse();	assertEquals("maxBrowsePageSize", maxBrowsePageSize, browsed.length);	Runtime.getRuntime().gc();	long free = Runtime.getRuntime().freeMemory()/1024;	
free at start of check 

connection.close();	assertFalse("Cache disabled on q", queueViewMBean.isCacheEnabled());	final Queue underTest = (Queue) ((RegionBroker)broker.getRegionBroker()).getQueueRegion().getDestinationMap().get(bigQueue);	Message[] browsed = underTest.browse();	assertEquals("maxBrowsePageSize", maxBrowsePageSize, browsed.length);	browsed = underTest.browse();	assertEquals("maxBrowsePageSize", maxBrowsePageSize, browsed.length);	Runtime.getRuntime().gc();	long free = Runtime.getRuntime().freeMemory()/1024;	for (int i=0; i<10; i++) {	
free 

assertFalse("Cache disabled on q", queueViewMBean.isCacheEnabled());	final Queue underTest = (Queue) ((RegionBroker)broker.getRegionBroker()).getQueueRegion().getDestinationMap().get(bigQueue);	Message[] browsed = underTest.browse();	assertEquals("maxBrowsePageSize", maxBrowsePageSize, browsed.length);	browsed = underTest.browse();	assertEquals("maxBrowsePageSize", maxBrowsePageSize, browsed.length);	Runtime.getRuntime().gc();	long free = Runtime.getRuntime().freeMemory()/1024;	for (int i=0; i<10; i++) {	browsed = underTest.browse();	
browsed 

========================= activemq sample_2818 =========================

producer.send(msg);	}	latch.await(300000, TimeUnit.MILLISECONDS);	producerConnection.close();	consumerConnection.close();	assertEquals("Still dipatching - count down latch not sprung", latch.getCount(), 0);	for (int i = 0; i < senderList.size(); i++) {	Message sent = senderList.get(i);	Message consumed = consumerList.get(i);	if (!sent.equals(consumed)) {	
bad match at pos 

========================= activemq sample_2377 =========================

private void waitForConsumerRegistration(final BrokerService brokerService, final int min, final ActiveMQDestination destination) throws Exception {	assertTrue("Internal bridge consumers registered in time", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	Object[] bridges = brokerService.getNetworkConnectors().get(0).bridges.values().toArray();	if (bridges.length > 0) {	
bridges 

private void waitForConsumerRegistration(final BrokerService brokerService, final int min, final ActiveMQDestination destination) throws Exception {	assertTrue("Internal bridge consumers registered in time", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	Object[] bridges = brokerService.getNetworkConnectors().get(0).bridges.values().toArray();	if (bridges.length > 0) {	DemandForwardingBridgeSupport demandForwardingBridgeSupport = (DemandForwardingBridgeSupport) bridges[0];	ConcurrentMap<ConsumerId, DemandSubscription> forwardingBridges = demandForwardingBridgeSupport.getLocalSubscriptionMap();	
bridge localsubs 

private void waitForConsumerRegistration(final BrokerService brokerService, final int min, final ActiveMQDestination destination) throws Exception {	assertTrue("Internal bridge consumers registered in time", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	Object[] bridges = brokerService.getNetworkConnectors().get(0).bridges.values().toArray();	if (bridges.length > 0) {	DemandForwardingBridgeSupport demandForwardingBridgeSupport = (DemandForwardingBridgeSupport) bridges[0];	ConcurrentMap<ConsumerId, DemandSubscription> forwardingBridges = demandForwardingBridgeSupport.getLocalSubscriptionMap();	if (!forwardingBridges.isEmpty()) {	for (DemandSubscription demandSubscription : forwardingBridges.values()) {	if (demandSubscription.getLocalInfo().getDestination().equals(destination)) {	
demandsubscription size 

Thread.sleep(5000);	doTearDown();	doSetUp(false);	MessageProducer producer = localSession.createProducer(included);	for (int i = 0; i < MESSAGE_COUNT; i++) {	Message test = localSession.createTextMessage("test-" + i);	producer.send(test);	}	Thread.sleep(5000);	localConsumer = localSession.createDurableSubscriber(included, consumerName);	
consume from local consumer 

}	Thread.sleep(5000);	localConsumer = localSession.createDurableSubscriber(included, consumerName);	for (int i = 0; i < MESSAGE_COUNT / 2; i++) {	assertNotNull("message count: " + i, localConsumer.receive(2500));	}	Thread.sleep(5000);	doTearDown();	doSetUp(false);	Thread.sleep(5000);	
consume from remote 

Thread.sleep(5000);	localConsumer = localSession.createDurableSubscriber(included, consumerName);	for (int i = 0; i < MESSAGE_COUNT / 2; i++) {	assertNotNull("message count: " + i, localConsumer.receive(2500));	}	Thread.sleep(5000);	doTearDown();	doSetUp(false);	Thread.sleep(5000);	MessageConsumer remoteConsumer = remoteSession.createDurableSubscriber(included, consumerName);	
remote consumer 

========================= activemq sample_2727 =========================

protected void doStop(ServiceStopper stopper) throws Exception {	if (newConnectionExecutor != null) {	newConnectionExecutor.shutdownNow();	try {	if (!newConnectionExecutor.awaitTermination(3, TimeUnit.SECONDS)) {	
auto transport newconnectionexecutor didn t shutdown cleanly 

try {	if (!newConnectionExecutor.awaitTermination(3, TimeUnit.SECONDS)) {	}	} catch (InterruptedException e) {	}	}	if (protocolDetectionExecutor != null) {	protocolDetectionExecutor.shutdownNow();	try {	if (!protocolDetectionExecutor.awaitTermination(3, TimeUnit.SECONDS)) {	
auto transport protocoldetectionexecutor didn t shutdown cleanly 

protected ProtocolInfo detectProtocol(byte[] buffer) throws IOException {	TcpTransportFactory detectedTransportFactory = transportFactory;	WireFormatFactory detectedWireFormatFactory = wireFormatFactory;	boolean found = false;	for (String scheme : protocolVerifiers.keySet()) {	if (protocolVerifiers.get(scheme).isProtocol(buffer)) {	
detected protocol 

========================= activemq sample_4132 =========================

producer.close();	MessageProducer producer2 = session.createProducer(destination);	producer2.setPriority(9);	sendMessages(session, producer2, 3);	producer2.close();	session.close();	Session consumerSession = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageConsumer messageConsumer = consumerSession.createConsumer(destination);	for (int i = 0; i < 5; i++) {	Message message = messageConsumer.receive(4000);	
messageid 

========================= activemq sample_3618 =========================

protected void doTest() throws Exception {	connection.start();	messageCount = 4;	ActiveMQConnection amqConnection = (ActiveMQConnection) connection;	rollbackCount = amqConnection.getRedeliveryPolicy().getMaximumRedeliveries() + 1;	
will redeliver messages times 

makeConsumer();	sendMessages();	for (int i = 0; i < messageCount; i++) {	consumeAndRollback(i);	}	Queue dlqQueue = (Queue) createDlqDestination();	verifyIsDlq(dlqQueue);	final QueueViewMBean queueViewMBean = getProxyToQueue(dlqQueue.getQueueName());	assertTrue("all dlq messages expired", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
queue size 

assertTrue("all dlq messages expired", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueViewMBean.getExpiredCount() == messageCount;	}	}));	makeDlqConsumer();	assertNull("no message available", dlqConsumer.receive(1000));	final QueueViewMBean sharedDlqViewMBean = getProxyToQueue(SharedDeadLetterStrategy.DEFAULT_DEAD_LETTER_QUEUE_NAME);	assertTrue("messages stay on shared dlq which has default expiration=0", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
q size 

connection.start();	messageCount = 1;	timeToLive = 2000;	deliveryMode = DeliveryMode.NON_PERSISTENT;	sendMessages();	sendMessages();	assertTrue("all messages expired even duplicates!", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	try {	QueueViewMBean queueViewMBean = getProxyToQueue("DLQ.auditConfigured");	
queue size 

public void testNoDLQLoop() throws Exception {	destination = new ActiveMQQueue("loop");	messageCount = 2;	connection.start();	ActiveMQConnection amqConnection = (ActiveMQConnection) connection;	rollbackCount = amqConnection.getRedeliveryPolicy().getMaximumRedeliveries() + 1;	
will redeliver messages times 

ActiveMQConnection amqConnection = (ActiveMQConnection) connection;	rollbackCount = amqConnection.getRedeliveryPolicy().getMaximumRedeliveries() + 1;	makeConsumer();	sendMessages();	for (int i = 0; i < messageCount; i++) {	consumeAndRollback(i);	}	final QueueViewMBean queueViewMBean = getProxyToQueue("DLQ.loop");	assertTrue("all dlq messages expired", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
queue size 

protected void consumeAndRollback(int messageCounter) throws Exception {	for (int i = 0; i < rollbackCount; i++) {	Message message = consumer.receive(5000);	assertNotNull("No message received for message: " + messageCounter + " and rollback loop: " + i, message);	assertMessage(message, messageCounter);	session.rollback();	}	
rolled back times 

========================= activemq sample_2459 =========================

if (nc.isNetworkConsumersEmpty()) {	gcList.add(nc);	}	}	}	}	}	for (ConsumerInfo nc : gcList) {	networkConsumerList.remove(nc);	super.removeConsumer(context, nc);	
removed stale network consumer 

========================= activemq sample_3862 =========================

public void scheduledJob(String id, ByteSequence job) {	latch.countDown();	}	});	long time = TimeUnit.SECONDS.toMillis(30);	for (int i = 0; i < COUNT; i++) {	scheduler.schedule("id" + i, payload, "", time, 0, 0);	}	int size = scheduler.getAllJobs().size();	assertEquals(size, COUNT);	
number of journal log files 

for (int i = 0; i < COUNT; i++) {	scheduler.schedule("id" + i, payload, "", time, 0, 0);	}	int size = scheduler.getAllJobs().size();	assertEquals(size, COUNT);	assertTrue(latch.await(70, TimeUnit.SECONDS));	assertEquals(0, latch.getCount());	for (int i = 0; i < COUNT; i++) {	scheduler.schedule("id" + i, payload, "", time, 0, 0);	}	
number of journal log files 

for (int i = 0; i < COUNT; i++) {	scheduler.schedule("id" + i, payload, "", time, 0, 0);	}	assertTrue(latch.await(70, TimeUnit.SECONDS));	assertEquals(0, latch.getCount());	assertTrue("Should be only one log left: " + getNumJournalFiles(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getNumJournalFiles() == 1;	}	}, TimeUnit.MINUTES.toMillis(2)));	
number of journal log files 

scheduler.schedule("Message-1", new ByteSequence(data), "", time, 0, 0);	assertTrue(latch.await(70, TimeUnit.SECONDS));	assertEquals(0, latch.getCount());	scheduler.schedule("Message-2", payload, "", time, 0, 0);	scheduler.schedule("Message-3", payload, "", time, 0, 0);	assertTrue("Should be only one log left: " + getNumJournalFiles(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getNumJournalFiles() == 1;	}	}, TimeUnit.MINUTES.toMillis(2)));	
number of journal log files 

========================= activemq sample_2320 =========================

public void testSerialization() throws Exception {	ActiveMQMessageAuditNoSync audit = new ActiveMQMessageAuditNoSync();	byte[] bytes =  serialize(audit);	
length 

public void testSerialization() throws Exception {	ActiveMQMessageAuditNoSync audit = new ActiveMQMessageAuditNoSync();	byte[] bytes =  serialize(audit);	audit = recover(bytes);	List<MessageReference> list = new ArrayList<MessageReference>();	for (int j = 0; j < 1000; j++) {	ProducerId pid = new ProducerId();	pid.setConnectionId("test");	pid.setSessionId(0);	pid.setValue(j);	
producer 

for (int i = 0; i < 1000; i++) {	MessageId id = new MessageId();	id.setProducerId(pid);	id.setProducerSequenceId(i);	ActiveMQMessage msg = new ActiveMQMessage();	msg.setMessageId(id);	list.add(msg);	assertFalse(audit.isDuplicate(msg.getMessageId().toString()));	if (i % 100 == 0) {	bytes = serialize(audit);	
length 

if (i % 100 == 0) {	bytes = serialize(audit);	audit = recover(bytes);	}	if (i % 250 == 0) {	for (MessageReference message : list) {	audit.rollback(message.getMessageId().toString());	}	list.clear();	bytes = serialize(audit);	
length 

========================= activemq sample_2635 =========================

public static void main(String[] args) {	Context jndiContext = null;	ConnectionFactory connectionFactory = null;	Connection connection = null;	Session session = null;	Destination destination = null;	MessageProducer producer = null;	String destinationName = null;	final int numMsgs;	if ((args.length < 1) || (args.length > 2)) {	
usage java simpleproducer destination name number of messages 

Connection connection = null;	Session session = null;	Destination destination = null;	MessageProducer producer = null;	String destinationName = null;	final int numMsgs;	if ((args.length < 1) || (args.length > 2)) {	System.exit(1);	}	destinationName = args[0];	
destination name is 

}	destinationName = args[0];	if (args.length == 2) {	numMsgs = (new Integer(args[1])).intValue();	} else {	numMsgs = 1;	}	try {	jndiContext = new InitialContext();	} catch (NamingException e) {	
could not create jndi api context 

}	try {	jndiContext = new InitialContext();	} catch (NamingException e) {	System.exit(1);	}	try {	connectionFactory = (ConnectionFactory)jndiContext.lookup("ConnectionFactory");	destination = (Destination)jndiContext.lookup(destinationName);	} catch (NamingException e) {	
jndi api lookup failed 

} catch (NamingException e) {	System.exit(1);	}	try {	connection = connectionFactory.createConnection();	session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	producer = session.createProducer(destination);	TextMessage message = session.createTextMessage();	for (int i = 0; i < numMsgs; i++) {	message.setText("This is message " + (i + 1));	
sending message 

connection = connectionFactory.createConnection();	session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	producer = session.createProducer(destination);	TextMessage message = session.createTextMessage();	for (int i = 0; i < numMsgs; i++) {	message.setText("This is message " + (i + 1));	producer.send(message);	}	producer.send(session.createMessage());	} catch (JMSException e) {	
exception occurred 

========================= activemq sample_2265 =========================

public void doStart() throws Exception {	
attempting to acquire the exclusive lock to become the master broker 

}	break;	} catch (Exception e) {	if (isStopping()) {	throw new Exception("Cannot start broker as being asked to shut down. Interrupted attempt to acquire lock: " + e, e);	}	if (exceptionHandler != null) {	try {	exceptionHandler.handle(e);	} catch (Throwable handlerException) {	
the exception handler threw this exception while trying to handle this excpetion 

} catch (Exception e) {	if (isStopping()) {	throw new Exception("Cannot start broker as being asked to shut down. Interrupted attempt to acquire lock: " + e, e);	}	if (exceptionHandler != null) {	try {	exceptionHandler.handle(e);	} catch (Throwable handlerException) {	}	} else {	
failed to acquire lock 

exceptionHandler.handle(e);	} catch (Throwable handlerException) {	}	} else {	}	} finally {	if (null != statement) {	try {	statement.close();	} catch (SQLException e1) {	
caught while closing statement 

}	} finally {	if (null != statement) {	try {	statement.close();	} catch (SQLException e1) {	}	statement = null;	}	}	
sleeping for milli s before trying again to get the lock 

try {	statement.close();	} catch (SQLException e1) {	}	statement = null;	}	}	try {	Thread.sleep(lockAcquireSleepInterval);	} catch (InterruptedException ie) {	
master lock retry sleep interrupted 

} catch (SQLException e1) {	}	statement = null;	}	}	try {	Thread.sleep(lockAcquireSleepInterval);	} catch (InterruptedException ie) {	}	}	
becoming the master on datasource 

========================= activemq sample_939 =========================

} catch (InterruptedException e) {	}	}	}	rate.increment();	try {	if (enableAudit && !this.audit.isInOrder(msg.getJMSMessageID())) {	LOG.error("Message out of order!!" + msg.getJMSMessageID() + " LAST = " + lastMsgId);	}	if (enableAudit && this.audit.isDuplicate(msg)){	
duplicate message 

========================= activemq sample_3530 =========================

beginTransaction(context, xid);	XATransaction transaction = (XATransaction) getTransaction(context, xid, false);	for (int i = 0; i < addedMessages.length; i++) {	forceDestinationWakeupOnCompletion(context, transaction, addedMessages[i].getDestination(), addedMessages[i]);	}	for (int i = 0; i < aks.length; i++) {	forceDestinationWakeupOnCompletion(context, transaction, aks[i].getDestination(), aks[i]);	}	transaction.setState(Transaction.PREPARED_STATE);	registerMBean(transaction);	
recovered prepared transaction 

public void afterRollback() throws Exception {	if (!messageSend) {	destination.clearPendingMessages();	
cleared pending from afterrollback 

public void afterCommit() throws Exception {	if (messageSend) {	destination.clearPendingMessages();	destination.getDestinationStatistics().getEnqueues().add(opCount);	destination.getDestinationStatistics().getMessages().add(opCount);	
cleared pending from aftercommit 

public TransactionId[] getPreparedTransactions(ConnectionContext context) throws Exception {	List<TransactionId> txs = new ArrayList<TransactionId>();	synchronized (xaTransactions) {	for (Iterator<XATransaction> iter = xaTransactions.values().iterator(); iter.hasNext();) {	Transaction tx = iter.next();	if (tx.isPrepared()) {	
prepared transaction 

synchronized (xaTransactions) {	for (Iterator<XATransaction> iter = xaTransactions.values().iterator(); iter.hasNext();) {	Transaction tx = iter.next();	if (tx.isPrepared()) {	txs.add(tx.getTransactionId());	}	}	}	XATransactionId rc[] = new XATransactionId[txs.size()];	txs.toArray(rc);	
prepared transaction list size 

public void removeConnection(ConnectionContext context, ConnectionInfo info, Throwable error) throws Exception {	for (Iterator<Transaction> iter = context.getTransactions().values().iterator(); iter.hasNext();) {	try {	Transaction transaction = iter.next();	transaction.rollback();	} catch (Exception e) {	
error rolling back disconnected client s transactions 

ArrayList<XATransaction> txs = new ArrayList<XATransaction>();	for (XATransaction tx : xaTransactions.values()) {	if (tx.getConnectionId() != null && tx.getConnectionId().equals(info.getConnectionId()) && !tx.isPrepared()) {	txs.add(tx);	}	}	for (XATransaction tx : txs) {	try {	tx.rollback();	} catch (Exception e) {	
error rolling back disconnected client s xa transactions 

========================= activemq sample_3863 =========================

}	boolean first = false;	try {	first = message.getBooleanProperty("JMSXGroupFirstForConsumer");	} catch (JMSException e) {	e.printStackTrace();	exceptions.put(Thread.currentThread(), e);	}	assertTrue("Always is first message", first);	if (counter.incrementAndGet() == totalMessageCount) {	
got all 

Connection[] connections = new Connection[consumerCount];	Session[] sessions = new Session[consumerCount];	MessageConsumer[] consumers = new MessageConsumer[consumerCount];	for (int i = 0; i < consumerCount; i++) {	connections[i] = connectionFactory.createConnection();	connections[i].start();	sessions[i] = connections[i].createSession(false, Session.AUTO_ACKNOWLEDGE);	consumers[i] = sessions[i].createConsumer(DESTINATIONS[i%DESTINATIONS.length], null);	consumers[i].setMessageListener(listener);	}	
received messages 

Session[] sessions = new Session[consumerCount];	MessageConsumer[] consumers = new MessageConsumer[consumerCount];	for (int i = 0; i < consumerCount; i++) {	connections[i] = connectionFactory.createConnection();	connections[i].start();	sessions[i] = connections[i].createSession(false, Session.AUTO_ACKNOWLEDGE);	consumers[i] = sessions[i].createConsumer(DESTINATIONS[i%DESTINATIONS.length], null);	consumers[i].setMessageListener(listener);	}	assertTrue("got all messages in time", finishLatch.await(4, TimeUnit.MINUTES));	
received messages 

========================= activemq sample_2771 =========================

Connection connection = connectionFactory.createConnection();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageProducer producer = session.createProducer(new ActiveMQQueue(TEST_QUEUE_NAME));	connection.start();	String messageText = createMessageText();	ActiveMQTextMessage message = new ActiveMQTextMessage();	message.setStringProperty(PROP_NAME, PROP_VALUE);	message.setText(messageText);	producer.send(message);	session.commit();	
attempting to receive non scheduled message 

Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageProducer producer = session.createProducer(new ActiveMQQueue(TEST_QUEUE_NAME));	connection.start();	String messageText = createMessageText();	ActiveMQTextMessage message = new ActiveMQTextMessage();	message.setStringProperty(PROP_NAME, PROP_VALUE);	message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, 1000);	message.setText(messageText);	producer.send(message);	session.commit();	
attempting to receive scheduled message 

========================= activemq sample_2321 =========================

String arg = args[0];	if (arg.equals("-uri")) {	if (args.length == 1) {	printUsage();	System.exit(1);	}	uri = args[1];	idx += 2;	}	String queueName = args[idx];	
connecting to 

String arg = args[0];	if (arg.equals("-uri")) {	if (args.length == 1) {	printUsage();	System.exit(1);	}	uri = args[1];	idx += 2;	}	String queueName = args[idx];	
queue name is 

}	try {	ConnectionFactory factory = new ActiveMQConnectionFactory(uri);	connection = factory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(queueName);	MessageProducer producer = session.createProducer(destination);	Message message = session.createTextMessage(text);	producer.send(message);	} catch (JMSException e) {	
exception occurred 

========================= activemq sample_2264 =========================

final MessageProducer producer = session.createProducer(queueA);	final AtomicBoolean done = new AtomicBoolean(true);	final AtomicBoolean keepGoing = new AtomicBoolean(true);	Thread thread = new Thread("Filler") {	int i;	public void run() {	while (keepGoing.get()) {	done.set(false);	try {	producer.send(session.createTextMessage("Test message " + ++i));	
sent 

}	}	}	};	thread.start();	waitForBlockedOrResourceLimit(done);	MessageConsumer consumer = session.createConsumer(queueA);	TextMessage msg;	for (int idx = 0; idx < 5; ++idx) {	msg = (TextMessage) consumer.receive(1000);	
received msg 

final MessageProducer producer = session.createProducer(queueA);	final AtomicBoolean done = new AtomicBoolean(true);	final AtomicBoolean keepGoing = new AtomicBoolean(true);	Thread thread = new Thread("Filler") {	int i;	public void run() {	while (keepGoing.get()) {	done.set(false);	try {	producer.send(session.createTextMessage("Test message " + ++i));	
sent 

}	}	};	thread.start();	waitForBlockedOrResourceLimit(done);	MessageConsumer consumer = session.createConsumer(queueA);	TextMessage msg;	for (int idx = 0; idx < 5; ++idx) {	msg = (TextMessage) consumer.receive(1000);	assertNotNull("Got a message", msg);	
received msg 

public void testDisableWarning() throws Exception {	final AtomicInteger warnings = new AtomicInteger();	Appender appender = new DefaultTestAppender() {	public void doAppend(LoggingEvent event) {	if (event.getLevel().equals(Level.INFO) && event.getMessage().toString().contains("Usage Manager Memory Limit")) {	
received log message 

========================= activemq sample_3475 =========================

NetworkConnector nc = bridgeBrokers("A", "B");	nc.setDuplex(true);	nc.setDispatchAsync(false);	startAllBrokers();	waitForBridgeFormation();	final int numMessages = 1000;	ActiveMQDestination destA = createDestination("AAA", false);	sendMessages("A", destA, numMessages);	ActiveMQDestination destB = createDestination("BBB", false);	sendMessages("B", destB, numMessages);	
starting consumers 

========================= activemq sample_3619 =========================

protected void doTest() throws Exception {	connection.start();	ActiveMQConnection amqConnection = (ActiveMQConnection) connection;	rollbackCount = amqConnection.getRedeliveryPolicy().getMaximumRedeliveries() + 1;	
will redeliver messages times 

protected void consumeAndRollback(int messageCounter) throws Exception {	for (int i = 0; i < rollbackCount; i++) {	Message message = consumer.receive(5000);	assertNotNull("No message received for message: " + messageCounter + " and rollback loop: " + i, message);	assertMessage(message, messageCounter);	session.rollback();	}	
rolled back times 

========================= activemq sample_2458 =========================

}	connection.start();	ConsumerBean messageList1 = new ConsumerBean();	ConsumerBean messageList2 = new ConsumerBean();	messageList1.setVerbose(true);	messageList2.setVerbose(true);	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination producerDestination = getProducerDestination();	Destination destination1 = getConsumer1Dsetination();	Destination destination2 = getConsumer2Dsetination();	
sending to 

}	connection.start();	ConsumerBean messageList1 = new ConsumerBean();	ConsumerBean messageList2 = new ConsumerBean();	messageList1.setVerbose(true);	messageList2.setVerbose(true);	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination producerDestination = getProducerDestination();	Destination destination1 = getConsumer1Dsetination();	Destination destination2 = getConsumer2Dsetination();	
consuming from and 

========================= activemq sample_2399 =========================

private void createCamelContext() throws Exception {	
creating context and sending message 

private void destroyCamelContext() throws Exception {	
destroying context 

createBroker();	int i = 0;	while (i++ < 5) {	createCamelContext();	Thread.sleep(1000);	destroyCamelContext();	Thread.sleep(1000);	assertEquals(0, brokerService.getConnectorByName(BROKER_URL).getConnections().size());	}	} catch (Exception e) {	
run 

========================= activemq sample_1366 =========================

public X509Certificate[] getPeerCertificates() {	X509Certificate[] peerCerts = null;	if (next instanceof SslTransport) {	peerCerts = ((SslTransport) next).getPeerCertificates();	} else if (next instanceof NIOSSLTransport) {	peerCerts = ((NIOSSLTransport) next).getPeerCertificates();	}	if (trace && peerCerts != null) {	
peer identity has been verified 

========================= activemq sample_1673 =========================

protected Tracer createTracer() {	return new Tracer() {	public void onReceive(MQTTFrame frame) {	
client received 

protected Tracer createTracer() {	return new Tracer() {	public void onReceive(MQTTFrame frame) {	}	public void onSend(MQTTFrame frame) {	
client sent 

========================= activemq sample_2730 =========================

if (receivedCount >= removeIndex + ackWindow) {	for (int j = 0; j < ackBatchSize; j++, removeIndex++) {	ackedCount.incrementAndGet();	MessageAck ack = new MessageAck();	ack.setLastMessageId(new MessageId(mesageIdRoot + removeIndex));	ack.setMessageCount(1);	queue.removeMessage(contextNotInTx, subscription, new IndirectMessageReference( getMessage(removeIndex)), ack);	queue.wakeup();	}	if (removeIndex % 1000 == 0) {	
acked 

========================= activemq sample_2360 =========================

protected BrokerService createBroker(String uri) throws Exception {	
loading broker configuration from the classpath with uri 

========================= activemq sample_2675 =========================

public void onFailure(IOException e) {	if (!shuttingDown.get()) {	
transport error 

========================= activemq sample_4172 =========================

public void testConsume() throws Exception {	
wait for dequeue message 

public void testConsume() throws Exception {	assertTrue(Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return broker.getAdminView().getTotalDequeueCount() >= messageCount;	}	}, 20 * 60 * 1000));	long duration = System.currentTimeMillis() - firstConsumed.get();	
done message consumption in millis 

ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("vm: factory.setWatchTopicAdvisories(false);	Connection connection = factory.createConnection();	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(new ActiveMQQueue("scp_transacted"));	for (int i=0; i<messageCount;i++) {	TextMessage message = session.createTextMessage("Some Text, messageCount:" + i);	message.setJMSCorrelationID("pleaseCorrelate");	producer.send(message);	}	
sent 

public void process(Exchange exchange) throws Exception {	if (consumed.getAndIncrement() == 0) {	firstConsumed.set(System.currentTimeMillis());	}	ActiveMQTextMessage m = (ActiveMQTextMessage) ((JmsMessage)exchange.getIn()).getJmsMessage();	if (consumed.get() %500 == 0) {	
received on 

========================= activemq sample_1370 =========================

try {	Session producerSession = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageProducer jmsProducer = producerSession.createProducer(producerSession.createQueue(DESTINATION));	Message sendMessage = producerSession.createTextMessage("test_message");	for (int i = 0; i < messageCount; i++) {	sendMessage.setIntProperty("appID", i);	jmsProducer.send(sendMessage);	producerSession.commit();	numberOfMessageSent++;	}	
finished after producing 

MessageProducer jmsProducer = producerSession.createProducer(producerSession.createQueue(DESTINATION));	Message sendMessage = producerSession.createTextMessage("test_message");	for (int i = 0; i < messageCount; i++) {	sendMessage.setIntProperty("appID", i);	jmsProducer.send(sendMessage);	producerSession.commit();	numberOfMessageSent++;	}	return numberOfMessageSent;	} catch (Exception ex) {	
exception received producing 

MessageProducer jmsProducer = producerSession.createProducer(producerSession.createQueue(DESTINATION));	Message sendMessage = producerSession.createTextMessage("test_message");	for (int i = 0; i < messageCount; i++) {	sendMessage.setIntProperty("appID", i);	jmsProducer.send(sendMessage);	producerSession.commit();	numberOfMessageSent++;	}	return numberOfMessageSent;	} catch (Exception ex) {	
finishing after exception 

private int consumeMessages(int numberOfMessage) throws Exception {	
creating new consumer for 

ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(broker.getTransportConnectorByScheme("tcp").getPublishableConnectString());	ActiveMQConnection connection = (ActiveMQConnection) connectionFactory.createConnection();	try {	connection.start();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageConsumer jmsConsumer = session.createConsumer(session.createQueue(DESTINATION));	boolean consume = true;	while (consume) {	Message message = jmsConsumer.receive(4000);	if (message == null) {	
break on 

Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageConsumer jmsConsumer = session.createConsumer(session.createQueue(DESTINATION));	boolean consume = true;	while (consume) {	Message message = jmsConsumer.receive(4000);	if (message == null) {	break;	}	int newAppId = message.getIntProperty("appID");	numberConsumedMessage++;	
message newappid 

break;	}	int newAppId = message.getIntProperty("appID");	numberConsumedMessage++;	if (newAppId != (consumedAppId + 1)) {	fail(" newAppId is " + newAppId + " expected " + (consumedAppId + 1));	}	consumedAppId = newAppId;	session.commit();	if (numberConsumedMessage == numberOfMessage) {	
closing consumer after message consumedappid is 

========================= activemq sample_3658 =========================

public void execute() throws MojoExecutionException {	if (skip) {	
skipped execution of activemq broker 

public void execute() throws MojoExecutionException {	if (skip) {	return;	}	this.useBrokerManager().stop();	
stopped the activemq broker 

========================= activemq sample_1235 =========================

broker.start();	broker.waitUntilStarted();	final AtomicInteger count = new AtomicInteger();	Connection connection = cf.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue("test.queue");	MessageConsumer consumer = session.createConsumer(queue);	final CountDownLatch latch = new CountDownLatch(NUMBER);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	
received scheduled message 

========================= activemq sample_2337 =========================

broker.stop();	broker.waitUntilStopped();	broker = null;	final CountDownLatch done = new CountDownLatch(1);	final CountDownLatch started = new CountDownLatch(1);	ExecutorService executor = Executors.newSingleThreadExecutor();	executor.execute(new Runnable() {	public void run() {	try {	started.countDown();	
entering into a sync receive call 

broker.stop();	broker.waitUntilStopped();	broker = null;	final CountDownLatch done = new CountDownLatch(1);	final CountDownLatch started = new CountDownLatch(1);	ExecutorService executor = Executors.newSingleThreadExecutor();	executor.execute(new Runnable() {	public void run() {	try {	started.countDown();	
entering into a sync receivenowait call 

broker.stop();	broker.waitUntilStopped();	broker = null;	final CountDownLatch done = new CountDownLatch(1);	final CountDownLatch started = new CountDownLatch(1);	ExecutorService executor = Executors.newSingleThreadExecutor();	executor.execute(new Runnable() {	public void run() {	try {	started.countDown();	
entering into a timed sync receive call 

========================= activemq sample_2767 =========================

protected void assertMessagesAreReceived() throws JMSException {	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	
caught 

========================= activemq sample_2272 =========================

MessageListener listenerB = new AMQ4899Listener("B", consumersStarted, consumerBtoConsumeCount);	MessageConsumer consumerB = session.createConsumer(consumerQueue, CONSUMER_B_SELECTOR);	consumerB.setMessageListener(listenerB);	consumersStarted.await(10, TimeUnit.SECONDS);	assertEquals("Not all consumers started in time", 0, consumersStarted.getCount());	Destination producerDestination = session.createTopic(PRODUCER_DESTINATION_NAME);	MessageProducer producer = session.createProducer(producerDestination);	int messageIndex = 0;	for (int i=0; i < MESSAGE_LIMIT; i++) {	if (i==3) {	
stopping consumera 

consumersStarted.await(10, TimeUnit.SECONDS);	assertEquals("Not all consumers started in time", 0, consumersStarted.getCount());	Destination producerDestination = session.createTopic(PRODUCER_DESTINATION_NAME);	MessageProducer producer = session.createProducer(producerDestination);	int messageIndex = 0;	for (int i=0; i < MESSAGE_LIMIT; i++) {	if (i==3) {	consumerA.close();	}	if (i == 14) {	
stopping consumer b 

for (int i=0; i < MESSAGE_LIMIT; i++) {	if (i==3) {	consumerA.close();	}	if (i == 14) {	consumerB.close();	}	String messageText = "hello " + messageIndex++ + " sent at " + new java.util.Date().toString();	TextMessage message = session.createTextMessage(messageText);	message.setIntProperty("Order", i);	
sending message 

consumerA.close();	}	if (i == 14) {	consumerB.close();	}	String messageText = "hello " + messageIndex++ + " sent at " + new java.util.Date().toString();	TextMessage message = session.createTextMessage(messageText);	message.setIntProperty("Order", i);	producer.send(message);	}	
restarting consumera 

if (i == 14) {	consumerB.close();	}	String messageText = "hello " + messageIndex++ + " sent at " + new java.util.Date().toString();	TextMessage message = session.createTextMessage(messageText);	message.setIntProperty("Order", i);	producer.send(message);	}	consumerA = session.createConsumer(consumerQueue, CONSUMER_A_SELECTOR);	consumerA.setMessageListener(listenerA);	
restarting consumerb 

TextMessage message = session.createTextMessage(messageText);	message.setIntProperty("Order", i);	producer.send(message);	}	consumerA = session.createConsumer(consumerQueue, CONSUMER_A_SELECTOR);	consumerA.setMessageListener(listenerA);	consumerB = session.createConsumer(consumerQueue, CONSUMER_B_SELECTOR);	consumerB.setMessageListener(listenerB);	consumerAtoConsumeCount.await(5, TimeUnit.SECONDS);	consumerBtoConsumeCount.await(5, TimeUnit.SECONDS);	
unconsumed messages for consumera consumerb 

VirtualDestination[] virtualDestinations = { virtualTopic };	interceptor.setVirtualDestinations(virtualDestinations);	broker.setDestinationInterceptors(new DestinationInterceptor[]{interceptor});	SubQueueSelectorCacheBrokerPlugin subQueueSelectorCacheBrokerPlugin = new SubQueueSelectorCacheBrokerPlugin();	BrokerPlugin[] updatedPlugins = {subQueueSelectorCacheBrokerPlugin};	broker.setPlugins(updatedPlugins);	broker.setUseJmx(false);	broker.start();	broker.waitUntilStarted();	} catch (Exception e) {	
failed creating broker 

public void onMessage(Message message) {	toConsume.countDown();	try {	if (message instanceof TextMessage) {	TextMessage textMessage = (TextMessage) message;	
listener received 

public void onMessage(Message message) {	toConsume.countDown();	try {	if (message instanceof TextMessage) {	TextMessage textMessage = (TextMessage) message;	} else {	
listener expected a textmessage got 

public void onMessage(Message message) {	toConsume.countDown();	try {	if (message instanceof TextMessage) {	TextMessage textMessage = (TextMessage) message;	} else {	}	} catch (JMSException e) {	
unexpected jmsexception in listener 

========================= activemq sample_2788 =========================

MessageIdList listener = new MessageIdList();	listener.setVerbose(true);	consumer.setMessageListener(listener);	MessageProducer producer = session.createProducer(destination);	int updateMessageCount = messageCount - DummyMessageQuery.MESSAGE_COUNT;	for (int i = 0; i < updateMessageCount; i++) {	TextMessage message = session.createTextMessage("Update Message: " + i + " sent at: " + new Date());	producer.send(message);	}	producer.close();	
sent update messages 

protected BrokerService createBroker() throws Exception {	String uri = getBrokerXml();	
loading broker configuration from the classpath with uri 

========================= activemq sample_2622 =========================

public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {	if (messageId != null) {	QueueViewMBean queueView = getQueueView();	if (queueView != null) {	
retrying message 

public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {	if (messageId != null) {	QueueViewMBean queueView = getQueueView();	if (queueView != null) {	queueView.retryMessage(messageId);	} else {	
no queue named 

========================= activemq sample_1327 =========================

}	enqueueMutex.wait();	}	enqueueMutex.notifyAll();	}	wb = (WriteBatch)o;	if (dataFile != wb.dataFile) {	if (file != null) {	if (periodicSync) {	if (logger.isTraceEnabled()) {	
syning file on rotate 

nextWriteBatch.exception.set(e);	nextWriteBatch.latch.countDown();	}	}	} catch (InterruptedException e) {	} finally {	try {	if (file != null) {	if (periodicSync) {	if (logger.isTraceEnabled()) {	
syning file on close 

========================= activemq sample_1777 =========================

ActiveMQMessage activeMessage = ActiveMQMessageTransformation.transformMessage(message, null);	ActiveMQDestination destination = activeMessage.getDestination();	if (destination == null) {	destination = sub.getActiveMQDestination();	activeMessage.setDestination(destination);	}	activeMessage.setRegionDestination(regionDestination);	configure(activeMessage);	sub.addRecoveredMessage(context, activeMessage);	} catch (Throwable e) {	
failed to dispatch initial message into subscription reason 

========================= activemq sample_4060 =========================

public void send(ByteBuf output) throws IOException {	checkConnected();	int length = output.readableBytes();	if (length == 0) {	return;	}	
attempted write of bytes 

protected void handleConnected(Channel channel) throws Exception {	
channel has become active awaiting websocket handshake channel is 

protected void channelRead0(ChannelHandlerContext ctx, Object message) throws Exception {	
new data read incoming 

protected void channelRead0(ChannelHandlerContext ctx, Object message) throws Exception {	Channel ch = ctx.channel();	if (!handshaker.isHandshakeComplete()) {	handshaker.finishHandshake(ch, (FullHttpResponse) message);	
websocket client connected 

NettyWSTransport.super.handleConnected(ch);	return;	}	if (message instanceof FullHttpResponse) {	FullHttpResponse response = (FullHttpResponse) message;	throw new IllegalStateException( "Unexpected FullHttpResponse (getStatus=" + response.status() + ", content=" + response.content().toString(StandardCharsets.UTF_8) + ')');	}	WebSocketFrame frame = (WebSocketFrame) message;	if (frame instanceof TextWebSocketFrame) {	TextWebSocketFrame textFrame = (TextWebSocketFrame) frame;	
websocket client received message 

if (message instanceof FullHttpResponse) {	FullHttpResponse response = (FullHttpResponse) message;	throw new IllegalStateException( "Unexpected FullHttpResponse (getStatus=" + response.status() + ", content=" + response.content().toString(StandardCharsets.UTF_8) + ')');	}	WebSocketFrame frame = (WebSocketFrame) message;	if (frame instanceof TextWebSocketFrame) {	TextWebSocketFrame textFrame = (TextWebSocketFrame) frame;	ctx.fireExceptionCaught(new IOException("Received invalid frame over WebSocket."));	} else if (frame instanceof BinaryWebSocketFrame) {	BinaryWebSocketFrame binaryFrame = (BinaryWebSocketFrame) frame;	
websocket client received data bytes 

}	WebSocketFrame frame = (WebSocketFrame) message;	if (frame instanceof TextWebSocketFrame) {	TextWebSocketFrame textFrame = (TextWebSocketFrame) frame;	ctx.fireExceptionCaught(new IOException("Received invalid frame over WebSocket."));	} else if (frame instanceof BinaryWebSocketFrame) {	BinaryWebSocketFrame binaryFrame = (BinaryWebSocketFrame) frame;	listener.onData(binaryFrame.content());	} else if (frame instanceof ContinuationWebSocketFrame) {	ContinuationWebSocketFrame binaryFrame = (ContinuationWebSocketFrame) frame;	
websocket client received data continuation bytes 

if (frame instanceof TextWebSocketFrame) {	TextWebSocketFrame textFrame = (TextWebSocketFrame) frame;	ctx.fireExceptionCaught(new IOException("Received invalid frame over WebSocket."));	} else if (frame instanceof BinaryWebSocketFrame) {	BinaryWebSocketFrame binaryFrame = (BinaryWebSocketFrame) frame;	listener.onData(binaryFrame.content());	} else if (frame instanceof ContinuationWebSocketFrame) {	ContinuationWebSocketFrame binaryFrame = (ContinuationWebSocketFrame) frame;	listener.onData(binaryFrame.content());	} else if (frame instanceof PingWebSocketFrame) {	
websocket client received ping response with pong 

ctx.fireExceptionCaught(new IOException("Received invalid frame over WebSocket."));	} else if (frame instanceof BinaryWebSocketFrame) {	BinaryWebSocketFrame binaryFrame = (BinaryWebSocketFrame) frame;	listener.onData(binaryFrame.content());	} else if (frame instanceof ContinuationWebSocketFrame) {	ContinuationWebSocketFrame binaryFrame = (ContinuationWebSocketFrame) frame;	listener.onData(binaryFrame.content());	} else if (frame instanceof PingWebSocketFrame) {	ch.write(new PongWebSocketFrame(frame.content()));	} else if (frame instanceof CloseWebSocketFrame) {	
websocket client received closing 

========================= activemq sample_1632 =========================

} else {	if (failureError != null) {	throw JMSExceptionSupport.create(failureError);	} else {	return null;	}	}	} else if (md.getMessage() == null) {	return null;	} else if (consumeExpiredMessage(md)) {	
received expired message 

} else if (md.getMessage() == null) {	return null;	} else if (consumeExpiredMessage(md)) {	beforeMessageIsConsumed(md);	afterMessageIsConsumed(md, true);	if (timeout > 0) {	timeout = Math.max(deadline - System.currentTimeMillis(), 0);	}	sendPullCommand(timeout);	} else if (redeliveryExceeded(md)) {	
received with excessive redelivered 

}	sendPullCommand(timeout);	} else if (redeliveryExceeded(md)) {	posionAck(md, "Dispatch[" + md.getRedeliveryCounter() + "] to " + getConsumerId() + " exceeds redelivery policy limit:" + redeliveryPolicy);	if (timeout > 0) {	timeout = Math.max(deadline - System.currentTimeMillis(), 0);	}	sendPullCommand(timeout);	} else {	if (LOG.isTraceEnabled()) {	
received message 

public void run() {	try {	session.sendAck(ackToSend,true);	} catch (JMSException e) {	
failed to delivered acknowledgements 

synchronized(deliveredMessages) {	deliveredMessages.clear();	}	}	unconsumedMessages.close();	this.session.removeConsumer(this);	List<MessageDispatch> list = unconsumedMessages.removeAll();	if (!this.info.isBrowser()) {	for (MessageDispatch old : list) {	if (old.getMessage() != null) {	
on close rollback duplicate 

synchronized(deliveredMessages) {	MessageAck oldPendingAck = pendingAck;	pendingAck = new MessageAck(md, ackType, deliveredCounter);	pendingAck.setTransactionId(session.getTransactionContext().getTransactionId());	if( oldPendingAck==null ) {	pendingAck.setFirstMessageId(pendingAck.getLastMessageId());	} else if ( oldPendingAck.getAckType() == pendingAck.getAckType() ) {	pendingAck.setFirstMessageId(oldPendingAck.getFirstMessageId());	} else {	if (!oldPendingAck.isDeliveredAck()) {	
sending old pending ack new pending 

pendingAck = new MessageAck(md, ackType, deliveredCounter);	pendingAck.setTransactionId(session.getTransactionContext().getTransactionId());	if( oldPendingAck==null ) {	pendingAck.setFirstMessageId(pendingAck.getLastMessageId());	} else if ( oldPendingAck.getAckType() == pendingAck.getAckType() ) {	pendingAck.setFirstMessageId(oldPendingAck.getFirstMessageId());	} else {	if (!oldPendingAck.isDeliveredAck()) {	session.sendAck(oldPendingAck);	} else {	
dropping old pending ack new pending 

pendingAck.setFirstMessageId(pendingAck.getLastMessageId());	} else if ( oldPendingAck.getAckType() == pendingAck.getAckType() ) {	pendingAck.setFirstMessageId(oldPendingAck.getFirstMessageId());	} else {	if (!oldPendingAck.isDeliveredAck()) {	session.sendAck(oldPendingAck);	} else {	}	}	if ((0.5 * info.getPrefetchSize()) <= (deliveredCounter + ackCounter - additionalWindowSize)) {	
acklater sending 

synchronized(deliveredMessages) {	if (previouslyDeliveredMessages != null) {	for (Entry<MessageId, Boolean> entry: previouslyDeliveredMessages.entrySet()) {	if (!entry.getValue()) {	numberNotReplayed++;	}	}	}	}	if (numberNotReplayed > 0) {	
waiting for redelivery of in transaction to consumer 

private void rollbackOnFailedRecoveryRedelivery() throws JMSException {	if (previouslyDeliveredMessages != null) {	int numberNotReplayed = 0;	for (Entry<MessageId, Boolean> entry: previouslyDeliveredMessages.entrySet()) {	if (!entry.getValue()) {	numberNotReplayed++;	
previously delivered message has not been replayed in transaction messageid 

private void rollbackPreviouslyDeliveredAndNotRedelivered() {	if (previouslyDeliveredMessages != null) {	for (Entry<MessageId, Boolean> entry: previouslyDeliveredMessages.entrySet()) {	if (!entry.getValue()) {	
rollback non redelivered 

}	ActiveMQMessage message = createActiveMQMessage(md);	beforeMessageIsConsumed(md);	try {	boolean expired = isConsumerExpiryCheckEnabled() && message.isExpired();	if (!expired) {	listener.onMessage(message);	}	afterMessageIsConsumed(md, expired);	} catch (RuntimeException e) {	
exception while processing message 

afterMessageIsConsumed(md, true);	if (info.getCurrentPrefetchSize() == 0) {	unconsumedMessages.enqueue(null);	}	}	}	}	} else {	ConsumerId consumerWithPendingTransaction;	if (redeliveryExpectedInCurrentTransaction(md, true)) {	
tracking transacted redelivery 

}	} else {	ConsumerId consumerWithPendingTransaction;	if (redeliveryExpectedInCurrentTransaction(md, true)) {	if (transactedIndividualAck) {	immediateIndividualTransactedAck(md);	} else {	session.sendAck(new MessageAck(md, MessageAck.DELIVERED_ACK_TYPE, 1));	}	} else if ((consumerWithPendingTransaction = redeliveryPendingInCompetingTransaction(md)) != null) {	
delivering duplicate pending transaction completion on will rollback 

if (redeliveryExpectedInCurrentTransaction(md, true)) {	if (transactedIndividualAck) {	immediateIndividualTransactedAck(md);	} else {	session.sendAck(new MessageAck(md, MessageAck.DELIVERED_ACK_TYPE, 1));	}	} else if ((consumerWithPendingTransaction = redeliveryPendingInCompetingTransaction(md)) != null) {	session.getConnection().rollbackDuplicate(this, md.getMessage());	dispatch(md);	} else {	
suppressing duplicate delivery on connection poison acking 

synchronized (deliveredMessages) {	if (clearDeliveredList) {	if (!deliveredMessages.isEmpty()) {	if (session.isTransacted()) {	if (previouslyDeliveredMessages == null) {	previouslyDeliveredMessages = new PreviouslyDeliveredMap<MessageId, Boolean>(session.getTransactionContext().getTransactionId());	}	for (MessageDispatch delivered : deliveredMessages) {	previouslyDeliveredMessages.put(delivered.getMessage().getMessageId(), false);	}	
tracking existing transacted delivered list on transport interrupt 

if (!deliveredMessages.isEmpty()) {	if (session.isTransacted()) {	if (previouslyDeliveredMessages == null) {	previouslyDeliveredMessages = new PreviouslyDeliveredMap<MessageId, Boolean>(session.getTransactionContext().getTransactionId());	}	for (MessageDispatch delivered : deliveredMessages) {	previouslyDeliveredMessages.put(delivered.getMessage().getMessageId(), false);	}	} else {	if (session.isClientAcknowledge()) {	
rolling back delivered list on transport interrupt 

previouslyDeliveredMessages.put(delivered.getMessage().getMessageId(), false);	}	} else {	if (session.isClientAcknowledge()) {	if (!this.info.isBrowser()) {	for (MessageDispatch md: deliveredMessages) {	this.session.connection.rollbackDuplicate(this, md.getMessage());	}	}	}	
clearing delivered list on transport interrupt 

public void setOptimizedAckScheduledAckInterval(long optimizedAckScheduledAckInterval) throws JMSException {	this.optimizedAckScheduledAckInterval = optimizedAckScheduledAckInterval;	if (this.optimizedAckTask != null) {	try {	this.session.connection.getScheduler().cancel(optimizedAckTask);	} catch (JMSException e) {	
caught exception while cancelling old optimized ack task 

} catch (JMSException e) {	throw e;	}	this.optimizedAckTask = null;	}	if (this.optimizeAcknowledge && this.optimizedAckScheduledAckInterval > 0) {	this.optimizedAckTask = new Runnable() {	public void run() {	try {	if (optimizeAcknowledge && !unconsumedMessages.isClosed()) {	
consumer is performing scheduled delivery of outstanding optimized acks 

this.optimizedAckTask = null;	}	if (this.optimizeAcknowledge && this.optimizedAckScheduledAckInterval > 0) {	this.optimizedAckTask = new Runnable() {	public void run() {	try {	if (optimizeAcknowledge && !unconsumedMessages.isClosed()) {	deliverAcks();	}	} catch (Exception e) {	
optimized ack task caught exception during ack 

if (optimizeAcknowledge && !unconsumedMessages.isClosed()) {	deliverAcks();	}	} catch (Exception e) {	}	}	};	try {	this.session.connection.getScheduler().executePeriodically(optimizedAckTask, optimizedAckScheduledAckInterval);	} catch (JMSException e) {	
caught exception while scheduling new optimized ack task 

========================= activemq sample_684 =========================

executor.execute(new Runnable() {	public void run() {	try {	ActiveMQTopic discardedAdvisoryDestination = AdvisorySupport.getMessageDiscardedAdvisoryTopic(destination);	Session advisorySession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	final MessageConsumer consumer = advisorySession.createConsumer(discardedAdvisoryDestination);	consumer.setMessageListener(new MessageListener() {	int advisoriesReceived = 0;	public void onMessage(Message message) {	try {	
advisory 

final CountDownLatch ackDone = new CountDownLatch(1);	final CountDownLatch consumerRegistered = new CountDownLatch(1);	executor.execute(new Runnable() {	public void run() {	try {	final MessageConsumer consumer = session.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	doAck.await(60, TimeUnit.SECONDS);	
acking 

========================= activemq sample_2989 =========================

public void run() {	ActiveMQConnectionFactory connectionFactory = null;	ActiveMQConnection connection = null;	ActiveMQSession session = null;	Destination destination = null;	try {	
started testproducer for destination 

destination = session.createQueue(this.destinationName);	ActiveMQMessageProducer producer = (ActiveMQMessageProducer) session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	for (int i = 0; i < (producerMessages); i++) {	TextMessage message = (TextMessage) session.createTextMessage();	message.setLongProperty("TestTime", (System.currentTimeMillis()));	try {	producer.send(message);	LOG.info("Producer (" + destinationName + ")\n" + message.getJMSMessageID() + " = sent messageId\n");	latch.countDown();	
latch count 

TextMessage message = (TextMessage) session.createTextMessage();	message.setLongProperty("TestTime", (System.currentTimeMillis()));	try {	producer.send(message);	LOG.info("Producer (" + destinationName + ")\n" + message.getJMSMessageID() + " = sent messageId\n");	latch.countDown();	LOG.info("Producer message list size = " + messageList.keySet().size());	messageList.put(message.getJMSMessageID(), new AtomicInteger(0));	LOG.info("Producer message list size = " + messageList.keySet().size());	} catch (Exception deeperException) {	
producer for destination caught 

producer.send(message);	LOG.info("Producer (" + destinationName + ")\n" + message.getJMSMessageID() + " = sent messageId\n");	latch.countDown();	LOG.info("Producer message list size = " + messageList.keySet().size());	messageList.put(message.getJMSMessageID(), new AtomicInteger(0));	LOG.info("Producer message list size = " + messageList.keySet().size());	} catch (Exception deeperException) {	}	Thread.sleep(1000);	}	
finished testproducer for destination 

LOG.info("Producer (" + destinationName + ")\n" + message.getJMSMessageID() + " = sent messageId\n");	latch.countDown();	LOG.info("Producer message list size = " + messageList.keySet().size());	messageList.put(message.getJMSMessageID(), new AtomicInteger(0));	LOG.info("Producer message list size = " + messageList.keySet().size());	} catch (Exception deeperException) {	}	Thread.sleep(1000);	}	} catch (Exception e) {	
terminating testproducer caught 

} catch (Exception e) {	} finally {	try {	if (session != null) {	session.close();	}	if (connection != null) {	connection.close();	}	} catch (Exception e) {	
closing connection session caught 

public void run() {	try {	
started testconsumer for destination 

policy.setUseExponentialBackOff(false);	policy.setMaximumRedeliveries(maxRedeliveries);	connection.setExceptionListener(this);	Destination destination = session.createQueue(destinationName);	consumer = session.createConsumer(destination);	consumer.setMessageListener(this);	connection.start();	while (!bStop) {	Thread.sleep(100);	}	
finished testconsumer for destination name remaining messages 

policy.setMaximumRedeliveries(maxRedeliveries);	connection.setExceptionListener(this);	Destination destination = session.createQueue(destinationName);	consumer = session.createConsumer(destination);	consumer.setMessageListener(this);	connection.start();	while (!bStop) {	Thread.sleep(100);	}	} catch (Exception e) {	
consumer caught 

if (consumer != null) {	consumer.close();	}	if (session != null) {	session.close();	}	if (connection != null) {	connection.close();	}	} catch (Exception e) {	
closing connection session caught 

public synchronized void onException(JMSException ex) {	
consumer for destination jms exception occured shutting down client 

public synchronized void onMessage(Message message) {	receivedMessageCounter++;	latch.countDown();	
consumer for destination latch countdown number messages received 

final String jmsMessageId = message.getJMSMessageID();	assertTrue("Did not find expected ", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return messageList.containsKey(jmsMessageId);	}	}));	AtomicInteger counter = messageList.get(jmsMessageId);	counter.incrementAndGet();	LOG.info("Consumer for destination (" + destinationName + ")\n" + message.getJMSMessageID() + " = currentMessageId\n" + previousMessageId + " = previousMessageId\n" + bMessageReceiptIsOrdered + "= bMessageReceiptIsOrdered\n" + ">>LATENCY " + (System.currentTimeMillis() - message.getLongProperty("TestTime")) + "\n" + "message counter = " + counter.get());	if (!bFakeFail) {	
consumer on destination committing jms session for message 

public boolean isSatisified() throws Exception {	return messageList.containsKey(jmsMessageId);	}	}));	AtomicInteger counter = messageList.get(jmsMessageId);	counter.incrementAndGet();	LOG.info("Consumer for destination (" + destinationName + ")\n" + message.getJMSMessageID() + " = currentMessageId\n" + previousMessageId + " = previousMessageId\n" + bMessageReceiptIsOrdered + "= bMessageReceiptIsOrdered\n" + ">>LATENCY " + (System.currentTimeMillis() - message.getLongProperty("TestTime")) + "\n" + "message counter = " + counter.get());	if (!bFakeFail) {	session.commit();	} else {	
consumer on destination rolling back jms session for message 

AtomicInteger counter = messageList.get(jmsMessageId);	counter.incrementAndGet();	LOG.info("Consumer for destination (" + destinationName + ")\n" + message.getJMSMessageID() + " = currentMessageId\n" + previousMessageId + " = previousMessageId\n" + bMessageReceiptIsOrdered + "= bMessageReceiptIsOrdered\n" + ">>LATENCY " + (System.currentTimeMillis() - message.getLongProperty("TestTime")) + "\n" + "message counter = " + counter.get());	if (!bFakeFail) {	session.commit();	} else {	session.rollback();	}	} catch (Exception ex) {	ex.printStackTrace();	
error reading jms message from destination 

========================= activemq sample_2823 =========================

public void testTimoutDoesNotFailConnectionAttempts() throws Exception {	bs.stop();	long timeout = 1000;	long startTime = System.currentTimeMillis();	ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory( "failover:(" + tcpUri + ")" + "?timeout=" + timeout + "&useExponentialBackOff=false" + "&maxReconnectAttempts=5" + "&initialReconnectDelay=1000");	Connection connection = cf.createConnection();	try {	connection.start();	fail("Should have failed to connect");	} catch (JMSException ex) {	
caught exception on call to start 

long startTime = System.currentTimeMillis();	ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory( "failover:(" + tcpUri + ")" + "?timeout=" + timeout + "&useExponentialBackOff=false" + "&maxReconnectAttempts=5" + "&initialReconnectDelay=1000");	Connection connection = cf.createConnection();	try {	connection.start();	fail("Should have failed to connect");	} catch (JMSException ex) {	}	long endTime = System.currentTimeMillis();	long duration = endTime - startTime;	
time spent waiting to connect ms 

public void doTestInterleaveAndException(final ActiveMQConnection connection, final Command command) throws Exception {	connection.start();	connection.setExceptionListener(new ExceptionListener() {	public void onException(JMSException exception) {	try {	
deal with exception invoke op that may block pending outstanding oneway 

========================= activemq sample_2570 =========================

Attributes attrs = result.getAttributes();	if (attrs == null) {	continue;	}	acls = addAttributeValues(roleAttribute, attrs, acls);	}	for (Iterator<String> iter = acls.iterator(); iter.hasNext();) {	String roleName = iter.next();	LdapName ldapname = new LdapName(roleName);	Rdn rdn = ldapname.getRdn(ldapname.size() - 1);	
found role 

========================= activemq sample_4220 =========================

protected void doCollection(TransportConnection tc) {	
found a blocked client stopping 

protected void doCollection(TransportConnection tc) {	try {	tc.stop();	} catch (Exception e) {	
error stopping 

public void run() {	while (started.get()) {	try {	doCollection();	doSweep();	Thread.sleep(sweepInterval);	} catch (Throwable e) {	
failed to complete a sweep for blocked clients 

========================= activemq sample_3859 =========================

test.setStringProperty("payload", payloadString);	localProducer.send(test);	}	localProducer.close();	final String options = "?persistent=true&useJmx=true&deleteAllMessagesOnStartup=false";	for (int i=0;i<2;i++) {	brokers.get(SPOKE).broker.stop();	sleep(1000);	createBroker(new URI("broker:(tcp: bridge(SPOKE, HUB);	brokers.get(SPOKE).broker.start();	
restarted spoke 

final ObjectName beanName = new ObjectName("org.apache.activemq:type=Broker,brokerName=" + broker.getBrokerName() + "," + type +",*");	Set<ObjectName> mbeans = null;	int count = 0;	do {	if (timeout > 0) {	Thread.sleep(100);	}	mbeans = broker.getManagementContext().queryNames(beanName, null);	if (mbeans != null) {	count = mbeans.size();	
found matching type 

========================= activemq sample_3623 =========================

Topic topic = session.createTopic("test.topic");	Queue queue = session.createQueue("test.queue");	MessageConsumer consumer = session.createDurableSubscriber(topic, "test");	consumer.close();	MessageProducer producer = session.createProducer(topic);	producer.setPriority(9);	for (int i = 0; i < numToSend; i++) {	Message msg = session.createTextMessage("test message:" + i);	producer.send(msg);	}	
sent to topic 

producer.setPriority(9);	for (int i = 0; i < numToSend; i++) {	Message msg = session.createTextMessage("test message:" + i);	producer.send(msg);	}	producer = session.createProducer(queue);	for (int i = 0; i < numToSend; i++) {	Message msg = session.createTextMessage("test message:" + i);	producer.send(msg);	}	
sent to queue 

if (repeats > 0) {	producerSomeMessages(connection, numToSend);	}	MessageConsumer queueConsumer = session.createConsumer(queue);	int count = 0;	for (int i = 0; i < (repeats == 0 ? 1000 : numToSend); i++) {	TextMessage msg = (TextMessage) queueConsumer.receive(10000);	count++;	assertNotNull(msg);	}	
consumed from queue 

count++;	assertNotNull(msg);	}	count = 0;	MessageConsumer topicConsumer = session.createDurableSubscriber(topic, "test");	for (int i = 0; i < (repeats == 0 ? 1000 : numToSend); i++) {	TextMessage msg = (TextMessage) topicConsumer.receive(10000);	count++;	assertNotNull("" + count, msg);	}	
consumed from topic 

========================= activemq sample_3789 =========================

public void testBrowsePriorityMessages() throws Exception {	for (int i = 0; i < 5; i++) {	produceMessages(3, 4, "TestQ");	Thread.sleep(1000);	produceMessages(3, 9, "TestQ");	ArrayList<Integer> browseList = browseQueue("TestQ");	produceMessages(3, 9, "TestQ");	browseList = browseQueue("TestQ");	ArrayList<Integer> consumeList = consumeMessages("TestQ");	if (!browseList.equals(consumeList)) {	
browselist size 

public void testBrowsePriorityMessages() throws Exception {	for (int i = 0; i < 5; i++) {	produceMessages(3, 4, "TestQ");	Thread.sleep(1000);	produceMessages(3, 9, "TestQ");	ArrayList<Integer> browseList = browseQueue("TestQ");	produceMessages(3, 9, "TestQ");	browseList = browseQueue("TestQ");	ArrayList<Integer> consumeList = consumeMessages("TestQ");	if (!browseList.equals(consumeList)) {	
consumelist size 

public void testBrowsePriorityMessages() throws Exception {	for (int i = 0; i < 5; i++) {	produceMessages(3, 4, "TestQ");	Thread.sleep(1000);	produceMessages(3, 9, "TestQ");	ArrayList<Integer> browseList = browseQueue("TestQ");	produceMessages(3, 9, "TestQ");	browseList = browseQueue("TestQ");	ArrayList<Integer> consumeList = consumeMessages("TestQ");	if (!browseList.equals(consumeList)) {	
browselist is 

public void testBrowsePriorityMessages() throws Exception {	for (int i = 0; i < 5; i++) {	produceMessages(3, 4, "TestQ");	Thread.sleep(1000);	produceMessages(3, 9, "TestQ");	ArrayList<Integer> browseList = browseQueue("TestQ");	produceMessages(3, 9, "TestQ");	browseList = browseQueue("TestQ");	ArrayList<Integer> consumeList = consumeMessages("TestQ");	if (!browseList.equals(consumeList)) {	
consumelist is 

========================= activemq sample_2874 =========================

public void testInitialContext() throws Exception {	InitialContext context = new InitialContext();	assertTrue("Created context", context != null);	ActiveMQConnectionFactory connectionFactory = (ActiveMQConnectionFactory)context.lookup("ConnectionFactory");	assertTrue("Should have created a ConnectionFactory", connectionFactory != null);	
created with brokerurl 

public void testInitialContextHasXA() throws Exception {	InitialContext context = new InitialContext();	assertTrue("Created context", context != null);	ActiveMQXAConnectionFactory connectionFactory = (ActiveMQXAConnectionFactory)context.lookup("XAConnectionFactory");	assertTrue("Should have created an XAConnectionFactory", connectionFactory != null);	
created with brokerurl 

========================= activemq sample_3009 =========================

public void end(Xid arg0, int arg1) throws XAException {	
end with 

public Xid[] recover(int arg0) throws XAException {	Xid[] answer = null;	
recover 

public void start(Xid arg0, int arg1) throws XAException {	
start with 

========================= activemq sample_850 =========================

public void testWithMessageListener() throws Throwable {	latch = new CountDownLatch(numberOfMessagesOnQueue);	new DelegatingTransactionalMessageListener(this, connection, destination);	long start = System.currentTimeMillis();	while ((System.currentTimeMillis() - start) < 1000 * 1000) {	if (getFailure() != null) {	throw getFailure();	}	if (latch.await(1, TimeUnit.SECONDS)) {	
received message s 

} catch (JMSException e) {	setFailure(e);	}	try {	assertEquals("Message: " + ackCounter.get(), msgText);	} catch (Throwable e) {	setFailure(e);	}	int value = deliveryCounter.incrementAndGet();	if (value % 2 == 0) {	
rolling back message id content 

}	try {	assertEquals("Message: " + ackCounter.get(), msgText);	} catch (Throwable e) {	setFailure(e);	}	int value = deliveryCounter.incrementAndGet();	if (value % 2 == 0) {	throw new RuntimeException("Dummy exception on message: " + value);	}	
received message id content 

========================= activemq sample_2618 =========================

protected void assertDeniedTemp(String userPass) {	try {	assertAllowedTemp(userPass);	fail("Expected not allowed exception");	} catch (Exception expected) {	
got 

protected void assertDenied(String userPass, String destination) {	try {	assertAllowed(userPass, destination);	fail("Expected not allowed exception");	} catch (JMSException expected) {	
got 

protected void assertDeniedWrite(String userPass, String destination) {	try {	assertAllowedWrite(userPass, destination);	fail("Expected not allowed exception");	} catch (JMSException expected) {	
got 

========================= activemq sample_4373 =========================

public void testSendingSmallMessage() throws Exception {	ConsumerInfo expected = new ConsumerInfo();	expected.setSelector("Cheese");	expected.setExclusive(true);	expected.setExclusive(true);	expected.setPrefetchSize(3456);	try {	
about to send 

expected.setPrefetchSize(3456);	try {	producer.oneway(expected);	Command received = assertCommandReceived();	assertTrue("Should have received a ConsumerInfo but was: " + received, received instanceof ConsumerInfo);	ConsumerInfo actual = (ConsumerInfo)received;	assertEquals("Selector", expected.getSelector(), actual.getSelector());	assertEquals("isExclusive", expected.isExclusive(), actual.isExclusive());	assertEquals("getPrefetchSize", expected.getPrefetchSize(), actual.getPrefetchSize());	} catch (Exception e) {	
caught 

protected void assertSendTextMessage(ActiveMQDestination destination, String text) throws MessageNotWriteableException {	large = true;	ActiveMQTextMessage expected = new ActiveMQTextMessage();	expected.setText(text);	expected.setDestination(destination);	try {	
about to send message of type 

expected.setDestination(destination);	try {	producer.oneway(expected);	producer.oneway(new ProducerInfo());	producer.oneway(new ProducerInfo());	Command received = assertCommandReceived();	assertTrue("Should have received a ActiveMQTextMessage but was: " + received, received instanceof ActiveMQTextMessage);	ActiveMQTextMessage actual = (ActiveMQTextMessage)received;	assertEquals("getDestination", expected.getDestination(), actual.getDestination());	assertEquals("getText", expected.getText(), actual.getText());	
received text message with character s 

try {	producer.oneway(expected);	producer.oneway(new ProducerInfo());	producer.oneway(new ProducerInfo());	Command received = assertCommandReceived();	assertTrue("Should have received a ActiveMQTextMessage but was: " + received, received instanceof ActiveMQTextMessage);	ActiveMQTextMessage actual = (ActiveMQTextMessage)received;	assertEquals("getDestination", expected.getDestination(), actual.getDestination());	assertEquals("getText", expected.getText(), actual.getText());	} catch (Exception e) {	
caught 

server.start();	}	consumer = createConsumer();	if (consumer != null) {	consumer.setTransportListener(this);	consumer.start();	}	producer = createProducer();	producer.setTransportListener(new TransportListener() {	public void onCommand(Object command) {	
producer received 

consumer = createConsumer();	if (consumer != null) {	consumer.setTransportListener(this);	consumer.start();	}	producer = createProducer();	producer.setTransportListener(new TransportListener() {	public void onCommand(Object command) {	}	public void onException(IOException error) {	
producer exception 

public void onCommand(Object o) {	final Command command = (Command)o;	if (command instanceof WireFormatInfo) {	
got wireformatinfo 

public void onCommand(Object o) {	final Command command = (Command)o;	if (command instanceof WireFormatInfo) {	} else {	if (command.isResponseRequired()) {	sendResponse(command);	}	if (large) {	
received command with id 

public void onCommand(Object o) {	final Command command = (Command)o;	if (command instanceof WireFormatInfo) {	} else {	if (command.isResponseRequired()) {	sendResponse(command);	}	if (large) {	} else {	
received command 

if (command.isResponseRequired()) {	sendResponse(command);	}	if (large) {	} else {	}	synchronized (lock) {	if (receivedCommand == null) {	receivedCommand = command;	} else {	
ignoring superfluous command 

protected void sendResponse(Command command) {	Response response = new Response();	response.setCorrelationId(command.getCommandId());	try {	consumer.oneway(response);	} catch (IOException e) {	
caught 

public void onException(IOException error) {	
received error 

public void transportInterupted() {	
transport interrupted 

public void transportResumed() {	
transport resumed 

========================= activemq sample_2474 =========================

}	if (System.getProperty("basedir") == null) {	File file = new File(".");	System.setProperty("basedir", file.getAbsolutePath());	}	broker = createBroker();	broker.setSslContext(sslContext);	String connectorURI = getConnectorURI();	TransportConnector connector = broker.addConnector(connectorURI);	port = connector.getConnectUri().getPort();	
nio ssl port is 

public void createConnectionFactory(String name) {	try {	
creating a connection factory using port 

========================= activemq sample_1608 =========================

public void run() {	Connection connection=null;	try {	
is running 

sleepingTime = 1000 * 1000;	} else {	sleepingTime = 1;	}	counter.incrementAndGet();	Thread.sleep(sleepingTime);	}	}	} catch (Exception e) {	} finally {	
is stopping 

========================= activemq sample_2927 =========================

}	assertTrue("Should be no durable consumers active or inactive.", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return brokerView.getInactiveDurableTopicSubscribers().length == 0 && brokerView.getDurableTopicSubscribers().length == 0;	}	}));	consumer = consumerMQSession.createDurableSubscriber(destination, "myTopic");	consumer.close();	assertTrue("Should be one consumer on the Topic.", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
number of inactive consumers 

========================= activemq sample_2862 =========================

private void makeSSLConnection(SSLContext context, String enabledSuites[], TransportConnector connector) throws Exception, UnknownHostException, SocketException {	SSLSocket sslSocket = (SSLSocket) context.getSocketFactory().createSocket("localhost", connector.getUri().getPort());	if (enabledSuites != null) {	sslSocket.setEnabledCipherSuites(enabledSuites);	}	sslSocket.setSoTimeout(5000);	SSLSession session = sslSocket.getSession();	sslSocket.startHandshake();	
cyphersuite 

private void makeSSLConnection(SSLContext context, String enabledSuites[], TransportConnector connector) throws Exception, UnknownHostException, SocketException {	SSLSocket sslSocket = (SSLSocket) context.getSocketFactory().createSocket("localhost", connector.getUri().getPort());	if (enabledSuites != null) {	sslSocket.setEnabledCipherSuites(enabledSuites);	}	sslSocket.setSoTimeout(5000);	SSLSession session = sslSocket.getSession();	sslSocket.startHandshake();	
peer port 

private void makeSSLConnection(SSLContext context, String enabledSuites[], TransportConnector connector) throws Exception, UnknownHostException, SocketException {	SSLSocket sslSocket = (SSLSocket) context.getSocketFactory().createSocket("localhost", connector.getUri().getPort());	if (enabledSuites != null) {	sslSocket.setEnabledCipherSuites(enabledSuites);	}	sslSocket.setSoTimeout(5000);	SSLSession session = sslSocket.getSession();	sslSocket.startHandshake();	
peer cert 

========================= activemq sample_2531 =========================

public void sendWireFormat() throws IOException {	try {	WireFormatInfo info = wireFormat.getPreferedWireFormatInfo();	if (LOG.isDebugEnabled()) {	
sending 

public void negociate(WireFormatInfo info) {	if (LOG.isDebugEnabled()) {	
received wireformat 

public void negociate(WireFormatInfo info) {	if (LOG.isDebugEnabled()) {	}	try {	wireInfoSentDownLatch.await();	if (LOG.isDebugEnabled()) {	
before negotiation 

onException(new IOException("Remote wire format magic is invalid"));	} else if (info.getVersion() < minimumVersion) {	onException(new IOException("Remote wire format (" + info.getVersion() + ") is lower the minimum version required (" + minimumVersion + ")"));	}	wireFormat.renegotiateWireFormat(info);	Socket socket = next.narrow(Socket.class);	if (socket != null) {	socket.setTcpNoDelay(wireFormat.isTcpNoDelayEnabled());	}	if (LOG.isDebugEnabled()) {	
after negotiation 

========================= activemq sample_104 =========================

} else if (dropTemporaryQueues && dest.isTemporary() && dest.isQueue()) {	skipMessage("dropTemporaryQueues", msgRef);	} else if (destFilter != null && matches(destName)) {	skipMessage("dropOnly", msgRef);	} else {	dropped = false;	return next.sendToDeadLetterQueue(ctx, msgRef, subscription, poisonCause);	}	if (dropped && getReportInterval() > 0) {	if ((++dropCount) % getReportInterval() == 0) {	
total of messages were discarded since their destination was the dead letter queue 

========================= activemq sample_4261 =========================

public Connection getConnection() throws JMSException {	if (checkConnection()) {	return connection;	}	synchronized (this) {	try {	connection = getConnectionFactory().createConnection();	connection.start();	return connection;	} catch (JMSException jmsEx) {	
caught exception while attempting to get a new connection 

public Session borrowSession() throws JMSException {	Session answer = null;	synchronized (sessions) {	if (sessions.isEmpty()) {	
creating a new session 

public Session borrowSession() throws JMSException {	Session answer = null;	synchronized (sessions) {	if (sessions.isEmpty()) {	answer = createSession();	} else {	
serving session from the pool 

public void returnSession(Session session) {	if (session != null && !((ActiveMQSession) session).isClosed()) {	synchronized (sessions) {	
returning session to the pool 

public void returnSession(Session session) {	if (session != null && !((ActiveMQSession) session).isClosed()) {	synchronized (sessions) {	sessions.add(session);	}	} else {	
session closed or null not returning to the pool 

========================= activemq sample_1063 =========================

outbound.setObjectProperty("BooleanObject", Boolean.valueOf(bool));	openwireProducer.send(outbound);	Message inbound = amqpConsumer.receive(2500);	propertyNames = inbound.getPropertyNames();	int propertyCount = 0;	do {	String propertyName = propertyNames.nextElement();	if (propertyName.indexOf("JMS") != 0) {	propertyCount++;	if (propertyName.equals("Boolean") || propertyName.equals("Byte") || propertyName.equals("Integer") || propertyName.equals("Short") || propertyName.equals("Float") || propertyName.equals("Double") || propertyName.equals("String") || propertyName.equals("Long") || propertyName.equals("BooleanObject")) {	
appclication property set by client is 

Message inbound = amqpConsumer.receive(2500);	propertyNames = inbound.getPropertyNames();	int propertyCount = 0;	do {	String propertyName = propertyNames.nextElement();	if (propertyName.indexOf("JMS") != 0) {	propertyCount++;	if (propertyName.equals("Boolean") || propertyName.equals("Byte") || propertyName.equals("Integer") || propertyName.equals("Short") || propertyName.equals("Float") || propertyName.equals("Double") || propertyName.equals("String") || propertyName.equals("Long") || propertyName.equals("BooleanObject")) {	if (!inbound.propertyExists(propertyName)) {	assertTrue(inbound.propertyExists(propertyName));	
positive propertyexists test failed for 

propertyNames = inbound.getPropertyNames();	int propertyCount = 0;	do {	String propertyName = propertyNames.nextElement();	if (propertyName.indexOf("JMS") != 0) {	propertyCount++;	if (propertyName.equals("Boolean") || propertyName.equals("Byte") || propertyName.equals("Integer") || propertyName.equals("Short") || propertyName.equals("Float") || propertyName.equals("Double") || propertyName.equals("String") || propertyName.equals("Long") || propertyName.equals("BooleanObject")) {	if (!inbound.propertyExists(propertyName)) {	assertTrue(inbound.propertyExists(propertyName));	} else if (inbound.propertyExists(propertyName + "1")) {	
negative propertyexists test failed for 

String propertyName = propertyNames.nextElement();	if (propertyName.indexOf("JMS") != 0) {	propertyCount++;	if (propertyName.equals("Boolean") || propertyName.equals("Byte") || propertyName.equals("Integer") || propertyName.equals("Short") || propertyName.equals("Float") || propertyName.equals("Double") || propertyName.equals("String") || propertyName.equals("Long") || propertyName.equals("BooleanObject")) {	if (!inbound.propertyExists(propertyName)) {	assertTrue(inbound.propertyExists(propertyName));	} else if (inbound.propertyExists(propertyName + "1")) {	fail("Negative propertyExists test failed for " + propertyName + "1");	}	} else {	
appclication property not set by client 

if (propertyName.equals("Boolean") || propertyName.equals("Byte") || propertyName.equals("Integer") || propertyName.equals("Short") || propertyName.equals("Float") || propertyName.equals("Double") || propertyName.equals("String") || propertyName.equals("Long") || propertyName.equals("BooleanObject")) {	if (!inbound.propertyExists(propertyName)) {	assertTrue(inbound.propertyExists(propertyName));	} else if (inbound.propertyExists(propertyName + "1")) {	fail("Negative propertyExists test failed for " + propertyName + "1");	}	} else {	fail("Appclication Property not set by client: " + propertyName);	}	} else {	
jmsproperty name is 

outbound.setObjectProperty("BooleanObject", Boolean.valueOf(bool));	amqpProducer.send(outbound);	Message inbound = openwireConsumer.receive(2500);	propertyNames = inbound.getPropertyNames();	int propertyCount = 0;	do {	String propertyName = propertyNames.nextElement();	if (propertyName.indexOf("JMS") != 0) {	propertyCount++;	if (propertyName.equals("Boolean") || propertyName.equals("Byte") || propertyName.equals("Integer") || propertyName.equals("Short") || propertyName.equals("Float") || propertyName.equals("Double") || propertyName.equals("String") || propertyName.equals("Long") || propertyName.equals("BooleanObject")) {	
appclication property set by client is 

Message inbound = openwireConsumer.receive(2500);	propertyNames = inbound.getPropertyNames();	int propertyCount = 0;	do {	String propertyName = propertyNames.nextElement();	if (propertyName.indexOf("JMS") != 0) {	propertyCount++;	if (propertyName.equals("Boolean") || propertyName.equals("Byte") || propertyName.equals("Integer") || propertyName.equals("Short") || propertyName.equals("Float") || propertyName.equals("Double") || propertyName.equals("String") || propertyName.equals("Long") || propertyName.equals("BooleanObject")) {	if (!inbound.propertyExists(propertyName)) {	assertTrue(inbound.propertyExists(propertyName));	
positive propertyexists test failed for 

propertyNames = inbound.getPropertyNames();	int propertyCount = 0;	do {	String propertyName = propertyNames.nextElement();	if (propertyName.indexOf("JMS") != 0) {	propertyCount++;	if (propertyName.equals("Boolean") || propertyName.equals("Byte") || propertyName.equals("Integer") || propertyName.equals("Short") || propertyName.equals("Float") || propertyName.equals("Double") || propertyName.equals("String") || propertyName.equals("Long") || propertyName.equals("BooleanObject")) {	if (!inbound.propertyExists(propertyName)) {	assertTrue(inbound.propertyExists(propertyName));	} else if (inbound.propertyExists(propertyName + "1")) {	
negative propertyexists test failed for 

String propertyName = propertyNames.nextElement();	if (propertyName.indexOf("JMS") != 0) {	propertyCount++;	if (propertyName.equals("Boolean") || propertyName.equals("Byte") || propertyName.equals("Integer") || propertyName.equals("Short") || propertyName.equals("Float") || propertyName.equals("Double") || propertyName.equals("String") || propertyName.equals("Long") || propertyName.equals("BooleanObject")) {	if (!inbound.propertyExists(propertyName)) {	assertTrue(inbound.propertyExists(propertyName));	} else if (inbound.propertyExists(propertyName + "1")) {	fail("Negative propertyExists test failed for " + propertyName + "1");	}	} else {	
appclication property not set by client 

if (propertyName.equals("Boolean") || propertyName.equals("Byte") || propertyName.equals("Integer") || propertyName.equals("Short") || propertyName.equals("Float") || propertyName.equals("Double") || propertyName.equals("String") || propertyName.equals("Long") || propertyName.equals("BooleanObject")) {	if (!inbound.propertyExists(propertyName)) {	assertTrue(inbound.propertyExists(propertyName));	} else if (inbound.propertyExists(propertyName + "1")) {	fail("Negative propertyExists test failed for " + propertyName + "1");	}	} else {	fail("Appclication Property not set by client: " + propertyName);	}	} else {	
jmsproperty name is 

Session openwireSession = openwire.createSession(false, Session.AUTO_ACKNOWLEDGE);	Session amqpSession = amqp.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination queue = openwireSession.createQueue(getDestinationName());	MessageProducer amqpProducer = amqpSession.createProducer(queue);	MessageConsumer openwireConsumer = openwireSession.createConsumer(queue);	ObjectMessage outgoing = amqpSession.createObjectMessage();	outgoing.setObject(UUID.randomUUID());	amqpProducer.send(outgoing);	Message received = openwireConsumer.receive(2000);	assertNotNull(received);	
read new message 

Session openwireSession = openwire.createSession(false, Session.AUTO_ACKNOWLEDGE);	Session amqpSession = amqp.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination queue = openwireSession.createQueue(getDestinationName());	MessageProducer openwireProducer = openwireSession.createProducer(queue);	MessageConsumer amqpConsumer = amqpSession.createConsumer(queue);	ObjectMessage outgoing = amqpSession.createObjectMessage();	outgoing.setObject(UUID.randomUUID());	openwireProducer.send(outgoing);	Message received = amqpConsumer.receive(2000);	assertNotNull(received);	
read new message 

Session openwireSession = openwire.createSession(false, Session.AUTO_ACKNOWLEDGE);	Session amqpSession = amqp.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination queue = openwireSession.createQueue(getDestinationName());	MessageProducer openwireProducer = openwireSession.createProducer(queue);	MessageConsumer amqpConsumer = amqpSession.createConsumer(queue);	ObjectMessage outgoing = amqpSession.createObjectMessage();	outgoing.setObject(UUID.randomUUID());	openwireProducer.send(outgoing);	Message received = amqpConsumer.receive(2000);	assertNotNull(received);	
read new message 

========================= activemq sample_1576 =========================

producerConnection.start();	Session producerSession = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = producerSession.createProducer(requestQueue);	Destination replyTo = producerSession.createTemporaryQueue();	MessageConsumer producerSessionConsumer = producerSession.createConsumer(replyTo);	final CountDownLatch countDownLatch = new CountDownLatch(1);	producerSessionConsumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	if (message instanceof TextMessage) {	
you got a message 

Connection consumerConnection = createConnection();	consumerConnection.start();	Session consumerSession = consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = consumerSession.createConsumer(requestQueue);	final MessageProducer consumerProducer = consumerSession.createProducer(null);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	consumerProducer.send(message.getJMSReplyTo(), message);	} catch (JMSException e) {	
error sending a response on the temp queue 

========================= activemq sample_2835 =========================

private BrokerService lookupBroker(final BrokerRegistry registry, final String brokerName, int waitForStart) {	BrokerService broker = null;	synchronized(registry.getRegistryMutext()) {	broker = registry.lookup(brokerName);	if (broker == null || waitForStart > 0) {	final long expiry = System.currentTimeMillis() + waitForStart;	while ((broker == null || !broker.isStarted()) && expiry > System.currentTimeMillis()) {	long timeout = Math.max(0, expiry - System.currentTimeMillis());	if (broker == null) {	try {	
waiting for broker named to enter registry 

while ((broker == null || !broker.isStarted()) && expiry > System.currentTimeMillis()) {	long timeout = Math.max(0, expiry - System.currentTimeMillis());	if (broker == null) {	try {	registry.getRegistryMutext().wait(timeout);	broker = registry.lookup(brokerName);	} catch (InterruptedException ignored) {	}	}	if (broker != null && !broker.isStarted()) {	
waiting for broker named to start 

private TransportServer bind(URI location, boolean dispose) throws IOException {	String host = extractHost(location);	
binding to broker 

public static void stopped(String host) {	SERVERS.remove(host);	TransportConnector connector = CONNECTORS.remove(host);	if (connector != null) {	
shutting down vm connectors for broker 

========================= activemq sample_4148 =========================

public void run() {	if (maxTimeSinceLastAck < 0) {	
no limit set slowconsumer strategy has nothing to do 

private void updateSlowConsumersList(List<Subscription> subscribers) {	for (Subscription subscriber : subscribers) {	if (isIgnoreNetworkSubscriptions() && subscriber.getConsumerInfo().isNetworkSubscription()) {	if (slowConsumers.remove(subscriber) != null) {	
network sub is no longer slow 

private void updateSlowConsumersList(List<Subscription> subscribers) {	for (Subscription subscriber : subscribers) {	if (isIgnoreNetworkSubscriptions() && subscriber.getConsumerInfo().isNetworkSubscription()) {	if (slowConsumers.remove(subscriber) != null) {	}	continue;	}	if (isIgnoreIdleConsumers() && subscriber.getDispatchedQueueSize() == 0) {	if (slowConsumers.remove(subscriber) != null) {	
idle sub is no longer slow 

}	if (isIgnoreIdleConsumers() && subscriber.getDispatchedQueueSize() == 0) {	if (slowConsumers.remove(subscriber) != null) {	}	continue;	}	long lastAckTime = subscriber.getTimeOfLastMessageAck();	long timeDelta = System.currentTimeMillis() - lastAckTime;	if (timeDelta > maxTimeSinceLastAck) {	if (!slowConsumers.containsKey(subscriber)) {	
sub is now slow 

if (timeDelta > maxTimeSinceLastAck) {	if (!slowConsumers.containsKey(subscriber)) {	SlowConsumerEntry entry = new SlowConsumerEntry(subscriber.getContext());	entry.mark();	slowConsumers.put(subscriber, entry);	} else if (getMaxSlowCount() > 0) {	slowConsumers.get(subscriber).slow();	}	} else {	if (slowConsumers.remove(subscriber) != null) {	
sub is no longer slow 

========================= activemq sample_4095 =========================

public void testCompositeSendReceiveAfterRestart() throws Exception {	destination = new ActiveMQQueue("StoreOrderTest,SecondStoreOrderTest");	enqueueOneMessage();	
restart broker 

public void validateUnorderedTxCommit() throws Exception {	Executor executor = Executors.newCachedThreadPool();	CountDownLatch readyForCommit = new CountDownLatch(2);	CountDownLatch firstDone = new CountDownLatch(1);	TransactedSend first = new TransactedSend(readyForCommit, firstDone, true);	TransactedSend second = new TransactedSend(readyForCommit, firstDone, false);	executor.execute(first);	executor.execute(second);	assertTrue("both started", readyForCommit.await(20, TimeUnit.SECONDS));	
commit out of order 

CountDownLatch readyForCommit = new CountDownLatch(2);	CountDownLatch firstDone = new CountDownLatch(1);	TransactedSend first = new TransactedSend(readyForCommit, firstDone, true);	TransactedSend second = new TransactedSend(readyForCommit, firstDone, false);	executor.execute(first);	executor.execute(second);	assertTrue("both started", readyForCommit.await(20, TimeUnit.SECONDS));	second.commit();	enqueueOneMessage();	first.commit();	
send commit done 

TransactedSend second = new TransactedSend(readyForCommit, firstDone, false);	executor.execute(first);	executor.execute(second);	assertTrue("both started", readyForCommit.await(20, TimeUnit.SECONDS));	second.commit();	enqueueOneMessage();	first.commit();	dumpMessages();	String received1, received2, received3 = null;	if (true) {	
receive and rollback 

Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	received1 = receive(session);	received2 = receive(session);	received3 = receive(session);	assertEquals("second", received1);	assertEquals("middle", received2);	assertEquals("first", received3);	session.rollback();	session.close();	}	
restart broker 

assertEquals("second", received1);	assertEquals("middle", received2);	assertEquals("first", received3);	session.rollback();	session.close();	}	stopBroker();	broker = createRestartedBroker();	initConnection();	if (true) {	
receive and rollback after restart 

Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	received1 = receive(session);	received2 = receive(session);	received3 = receive(session);	assertEquals("second", received1);	assertEquals("middle", received2);	assertEquals("first", received3);	session.rollback();	session.close();	}	
receive and ack each message 

private String receive(Session session) throws Exception {	MessageConsumer consumer = session.createConsumer(destination);	String result = null;	TextMessage message = (TextMessage) consumer.receive(5000);	if (message != null) {	
got message 

========================= activemq sample_3750 =========================

TopicPublisher producer = session.createPublisher(topic);	connection.start();	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	long tStamp = System.currentTimeMillis();	BytesMessage message = session2.createBytesMessage();	for (int i = 1; i <= MSG_COUNT; i++) {	message.setStringProperty("JMS_ID", "TEST");	message.setIntProperty("Type", i);	producer.publish(message);	if (i%100 == 0) {	
sent m ms 

public void testInvalidPendingQueue() throws Exception {	activeateSubscribers();	assertNotNull(consumer1);	assertNotNull(consumer2);	produceMessages();	
sent messages to a single subscriber 

public void testInvalidPendingQueue() throws Exception {	activeateSubscribers();	assertNotNull(consumer1);	assertNotNull(consumer2);	produceMessages();	Thread.sleep(2000);	
closing durable subscriber connections 

public void testInvalidPendingQueue() throws Exception {	activeateSubscribers();	assertNotNull(consumer1);	assertNotNull(consumer2);	produceMessages();	Thread.sleep(2000);	conn1.close();	conn2.close();	
closed durable subscriber connections 

public void testInvalidPendingQueue() throws Exception {	activeateSubscribers();	assertNotNull(consumer1);	assertNotNull(consumer2);	produceMessages();	Thread.sleep(2000);	conn1.close();	conn2.close();	Thread.sleep(2000);	
re starting durable subscriber connections 

public void testInvalidPendingQueue() throws Exception {	activeateSubscribers();	assertNotNull(consumer1);	assertNotNull(consumer2);	produceMessages();	Thread.sleep(2000);	conn1.close();	conn2.close();	Thread.sleep(2000);	activeateSubscribers();	
started up durable subscriber connections now view activemq console to see pending queue size on the other subscriber 

========================= activemq sample_2842 =========================

public void testRepeatedSetClientIDCalls() throws Exception {	
running testrepeatedsetclientidcalls 

public void testRepeatedSetClientIDCalls() throws Exception {	ConnectionFactory cf = createPooledConnectionFactory();	Connection conn = cf.createConnection();	conn.setClientID("newID");	try {	conn.setClientID("newID");	conn.start();	conn.close();	} catch (IllegalStateException ise) {	
repeated calls to activemqconnection setclientid caused 

} finally {	((PooledConnectionFactory) cf).stop();	}	cf = createPooledConnectionFactory();	conn = cf.createConnection();	conn.setClientID("newID1");	try {	conn.setClientID("newID2");	fail("calling ActiveMQConnection.setClientID() twice with different clientID must raise an IllegalStateException");	} catch (IllegalStateException ise) {	
correctly received 

conn.close();	((PooledConnectionFactory) cf).stop();	}	cf = createPooledConnectionFactory();	conn = cf.createConnection();	try {	conn.start();	conn.setClientID("newID3");	fail("Calling setClientID() after start() mut raise a JMSException.");	} catch (IllegalStateException ise) {	
correctly received 

conn = cf.createConnection();	try {	conn.start();	conn.setClientID("newID3");	fail("Calling setClientID() after start() mut raise a JMSException.");	} catch (IllegalStateException ise) {	} finally {	conn.close();	((PooledConnectionFactory) cf).stop();	}	
test finished 

protected ConnectionFactory createPooledConnectionFactory() {	PooledConnectionFactory cf = new PooledConnectionFactory();	cf.setConnectionFactory(new ActiveMQConnectionFactory( "vm: cf.setMaxConnections(1);	
connectionfactory initialized 

public void testAllSessionsAvailableOnConstrainedPool() throws Exception {	PooledConnectionFactory cf = new PooledConnectionFactory();	cf.setConnectionFactory(new ActiveMQConnectionFactory( "vm: cf.setMaxConnections(5);	cf.setMaximumActiveSessionPerConnection(2);	cf.setBlockIfSessionPoolIsFull(false);	LinkedList<Connection> connections = new LinkedList<>();	HashSet<Session> sessions = new HashSet();	for (int i=0; i<10; i++) {	Connection conn = cf.createConnection();	
connection 

Connection conn = cf.createConnection();	conn.start();	connections.add(conn);	sessions.add(conn.createSession(false, Session.AUTO_ACKNOWLEDGE));	}	assertEquals(sessions.size(), 10);	assertEquals(connections.size(), 10);	Connection connectionToClose = connections.getLast();	connectionToClose.close();	Connection conn = cf.createConnection();	
connection 

connectionToClose.close();	Connection conn = cf.createConnection();	conn.start();	connections.add(conn);	try {	sessions.add(conn.createSession(false, Session.AUTO_ACKNOWLEDGE));	} catch (JMSException expected) {	conn.close();	}	conn = cf.createConnection();	
connection 

========================= activemq sample_1297 =========================

public void start() throws Exception {	if (group == null) {	throw new IOException("You must specify a group to discover");	}	String type = getType();	if (!type.endsWith(".")) {	
the type should end with to be a valid rendezvous type 

if (group == null) {	throw new IOException("You must specify a group to discover");	}	String type = getType();	if (!type.endsWith(".")) {	type += ".";	}	try {	getJmdns();	if (listener != null) {	
discovering service of type 

jmdns.unregisterService(si);	}	final JmDNS closeTarget = jmdns;	Thread thread = new Thread() {	public void run() {	try {	if (JmDNSFactory.onClose(getLocalAddress())) {	closeTarget.close();	};	} catch (IOException e) {	
error closing jmdns this exception will be ignored 

public void addService(JmDNS jmDNS, String type, String name) {	
addservice with type name 

public void removeService(JmDNS jmDNS, String type, String name) {	
removeservice with type name 

protected ServiceInfo createServiceInfo(String name, Map map) {	int port = MapHelper.getInt(map, "port", 0);	String type = getType();	
registering service type name details 

========================= activemq sample_95 =========================

public void testDLQBrowsing() throws Exception {	super.topic = false;	deliveryMode = DeliveryMode.PERSISTENT;	durableSubscriber = false;	messageCount = 1;	connection.start();	ActiveMQConnection amqConnection = (ActiveMQConnection) connection;	rollbackCount = amqConnection.getRedeliveryPolicy().getMaximumRedeliveries() + 1;	
will redeliver messages times 

messageCount = 1;	connection.start();	ActiveMQConnection amqConnection = (ActiveMQConnection) connection;	rollbackCount = amqConnection.getRedeliveryPolicy().getMaximumRedeliveries() + 1;	sendMessages();	for (int i = 0; i < rollbackCount; i++) {	makeConsumer();	Message message = consumer.receive(5000);	assertNotNull("No message received: ", message);	session.rollback();	
rolled back times 

protected void browseDlq() throws Exception {	Enumeration<?> messages = dlqBrowser.getEnumeration();	while (messages.hasMoreElements()) {	
browsing 

========================= activemq sample_2454 =========================

session.close();	session = null;	t = connectionFactory.createConnection();	connection.close();	connection = t;	connection.setClientID(clientID);	session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	topic = session.createTopic(topicName);	subscriber = session.createDurableSubscriber(topic, subscriberName);	connection.start();	
started connection now about to try receive the textmessage 

connection.close();	connection = t;	connection.setClientID(clientID);	session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	topic = session.createTopic(topicName);	subscriber = session.createDurableSubscriber(topic, subscriberName);	connection.start();	long time = System.currentTimeMillis();	Message message = subscriber.receive(15000L);	long elapsed = System.currentTimeMillis() - time;	
waited for millis 

========================= activemq sample_3615 =========================

public void testReadCounter() throws Exception {	
connecting to 

public void testReadCounter() throws Exception {	byte[] payload = new byte[50 * 1024 * 1024];	ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(connectionUri + "?useInactivityMonitor=false");	final ActiveMQConnection connection = (ActiveMQConnection) factory.createConnection();	connection.start();	
connected to 

========================= activemq sample_2907 =========================

Locker locker = jdbcPersistenceAdapter.getLocker();	if (locker != null) {	try {	if (!locker.keepAlive()) {	hasLock = false;	}	} catch (SuppressReplyException ignoreWhileHandlingInProgress) {	} catch (IOException ignored) {	}	if (!hasLock) {	
lock keepalive failed no longer lock owner with 

========================= activemq sample_935 =========================

public void onWebSocketBinary(byte[] bytes, int offset, int length) {	if (!transportStartedAtLeastOnce()) {	
waiting for mqttsocket to be properly started 

public void onWebSocketBinary(byte[] bytes, int offset, int length) {	if (!transportStartedAtLeastOnce()) {	try {	socketTransportStarted.await();	} catch (InterruptedException e) {	
while waiting for mqttsocket to be properly started we got interrupted should be okay but you could see race conditions 

public void onWebSocketClose(int arg0, String arg1) {	try {	if (protocolLock.tryLock() || protocolLock.tryLock(ORDERLY_CLOSE_TIMEOUT, TimeUnit.SECONDS)) {	
mqtt websocket closed code message 

public void onWebSocketClose(int arg0, String arg1) {	try {	if (protocolLock.tryLock() || protocolLock.tryLock(ORDERLY_CLOSE_TIMEOUT, TimeUnit.SECONDS)) {	if (!receivedDisconnect.get()) {	getProtocolConverter().onTransportError();	}	getProtocolConverter().onMQTTCommand(new DISCONNECT().encode());	}	} catch (Exception e) {	
failed to close mqtt websocket cleanly 

========================= activemq sample_1151 =========================

public void testStompOnVirtualTopics() throws Exception {	
running stomp producer 

}	consumer.start();	consumerWorker.awaitStartCompleted();	Thread.sleep(500);	stompConnection.sendFrame("CONNECT\n" + "login:system\n" + "passcode:manager\n\n" + Stomp.NULL);	StompFrame frame = stompConnection.receive();	assertTrue(frame.toString().startsWith("CONNECTED"));	for (int i = 0; i < NUM_MSGS - 1; i++) {	stompConnection.send("/topic/VirtualTopic.FOO", "Hello World {" + (i + 1) + "} " + payload.toString());	}	
sending last packet with receipt header 

HashMap<String, Object> headers = new HashMap<String, Object>();	headers.put("receipt", "1234");	stompConnection.appendHeaders(headers);	String msg = "SEND\n" + "destination:/topic/VirtualTopic.FOO\n" + "receipt: msg-1\n" + "\n\n" + "Hello World {" + (NUM_MSGS - 1) + "}" + Stomp.NULL;	stompConnection.sendFrame(msg);	msg = stompConnection.receiveFrame();	assertTrue(msg.contains("RECEIPT"));	stompConnection.disconnect();	TimeUnit.MILLISECONDS.sleep(100);	stompConnection.close();	
stomp producer finished waiting for consumer to join 

headers.put("receipt", "1234");	stompConnection.appendHeaders(headers);	String msg = "SEND\n" + "destination:/topic/VirtualTopic.FOO\n" + "receipt: msg-1\n" + "\n\n" + "Hello World {" + (NUM_MSGS - 1) + "}" + Stomp.NULL;	stompConnection.sendFrame(msg);	msg = stompConnection.receiveFrame();	assertTrue(msg.contains("RECEIPT"));	stompConnection.disconnect();	TimeUnit.MILLISECONDS.sleep(100);	stompConnection.close();	consumer.join(45000);	
test finished 

public void run() {	
running stomp consumer 

assertTrue(frame.toString().startsWith("CONNECTED"));	HashMap<String, String> headers = new HashMap<String, String>();	headers.put("receipt", "sub-1");	stompConnection.subscribe("/queue/Consumer.A.VirtualTopic.FOO", "auto", headers);	String receipt = stompConnection.receiveFrame();	assertTrue("Should have read a receipt for subscribe", receipt.contains("RECEIPT"));	assertTrue("Receipt contains receipt-id", receipt.indexOf(Stomp.Headers.Response.RECEIPT_ID) >= 0);	latch.countDown();	for (counter = 0; counter < StompVirtualTopicTest.NUM_MSGS; counter++) {	frame = stompConnection.receive(15000);	
received msg with content 

for (counter = 0; counter < StompVirtualTopicTest.NUM_MSGS; counter++) {	frame = stompConnection.receive(15000);	if (!received.add(frame.getBody())) {	dups.add(frame.getBody());	}	}	try {	frame = stompConnection.receive(3000);	assertNull(frame);	} catch (Exception e) {	
correctly received while trying to consume an additional msg this is expected as the queue should be empty now 

}	try {	frame = stompConnection.receive(3000);	assertNull(frame);	} catch (Exception e) {	}	long queueSize = reportQueueStatistics();	if (queueSize != 0) {	parent.setFail("QueueSize not 0 after test has finished.");	}	
stomp consumer received of messages check queuesize in jmx and try to browse the queue 

frame = stompConnection.receive(3000);	assertNull(frame);	} catch (Exception e) {	}	long queueSize = reportQueueStatistics();	if (queueSize != 0) {	parent.setFail("QueueSize not 0 after test has finished.");	}	if (!dups.isEmpty()) {	for (String msg : dups) {	
received duplicate message 

long queueSize = reportQueueStatistics();	if (queueSize != 0) {	parent.setFail("QueueSize not 0 after test has finished.");	}	if (!dups.isEmpty()) {	for (String msg : dups) {	}	parent.setFail("Received " + StompVirtualTopicTest.NUM_MSGS + " messages but " + dups.size() + " were dups.");	}	} catch (Exception ex) {	
after consuming msgs 

reportQueueStatistics();	} catch (Exception e) {	}	parent.setFail("Stomp Consumer received " + counter + " of " + StompVirtualTopicTest.NUM_MSGS + " messages. Check QueueSize in JMX and try to browse the queue.");	} finally {	try {	stompConnection.disconnect();	TimeUnit.MILLISECONDS.sleep(100);	stompConnection.close();	} catch (Exception e) {	
unexpected exception on sleep 

}	parent.setFail("Stomp Consumer received " + counter + " of " + StompVirtualTopicTest.NUM_MSGS + " messages. Check QueueSize in JMX and try to browse the queue.");	} finally {	try {	stompConnection.disconnect();	TimeUnit.MILLISECONDS.sleep(100);	stompConnection.close();	} catch (Exception e) {	}	}	
test finished 

private long reportQueueStatistics() throws Exception {	ObjectName queueViewMBeanName = new ObjectName("org.apache.activemq:destinationType=Queue" + ",destinationName=Consumer.A.VirtualTopic.FOO" + ",type=Broker,brokerName=localhost");	QueueViewMBean queue = (QueueViewMBean) brokerService.getManagementContext().newProxyInstance(queueViewMBeanName, QueueViewMBean.class, true);	
consumer a virtualtopic foo inflight enqueuecount dequeuecount dispatchcount 

========================= activemq sample_1444 =========================

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	connection = createConnection();	initRedeliveryDelay = ((ActiveMQConnection)connection).getRedeliveryPolicy().getInitialRedeliveryDelay();	if (durable) {	connection.setClientID(getClass().getName());	}	
created connection 

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	connection = createConnection();	initRedeliveryDelay = ((ActiveMQConnection)connection).getRedeliveryPolicy().getInitialRedeliveryDelay();	if (durable) {	connection.setClientID(getClass().getName());	}	session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	consumeSession = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	
created session 

protected void setUp() throws Exception {	super.setUp();	connectionFactory = createConnectionFactory();	connection = createConnection();	initRedeliveryDelay = ((ActiveMQConnection)connection).getRedeliveryPolicy().getInitialRedeliveryDelay();	if (durable) {	connection.setClientID(getClass().getName());	}	session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	consumeSession = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	
created consumesession 

super.setUp();	connectionFactory = createConnectionFactory();	connection = createConnection();	initRedeliveryDelay = ((ActiveMQConnection)connection).getRedeliveryPolicy().getInitialRedeliveryDelay();	if (durable) {	connection.setClientID(getClass().getName());	}	session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	consumeSession = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	producer = session.createProducer(null);	
created producer 

session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	consumeSession = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	producer = session.createProducer(null);	if (topic) {	consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	} else {	consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	}	
created consumer destination of type 

session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	consumeSession = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	producer = session.createProducer(null);	if (topic) {	consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	} else {	consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	}	
created producer destination of type 

producer = session.createProducer(null);	if (topic) {	consumerDestination = session.createTopic(getConsumerSubject());	producerDestination = session.createTopic(getProducerSubject());	} else {	consumerDestination = session.createQueue(getConsumerSubject());	producerDestination = session.createQueue(getProducerSubject());	}	consumer = createConsumer();	connection.start();	
created connection 

public void testRecover() throws Exception {	String text = "TEST";	Message sendMessage = session.createTextMessage(text);	if (verbose) {	
about to send a message with text 

protected MessageConsumer createConsumer() throws JMSException {	if (durable) {	
creating durable consumer 

========================= activemq sample_3479 =========================

public void run() {	MessageConsumer consumer = null;	try {	consumer = sess.createConsumer(dest);	while (received < messageCount) {	Message msg = consumer.receive(3000);	if (msg != null) {	
received test message 

public void run() {	MessageProducer producer = null;	try {	producer = sess.createProducer(dest);	for (sentCount = 0; sentCount < messageCount; sentCount++) {	producer.send(createMessage(sentCount));	
sent test message 

========================= activemq sample_2546 =========================

};	fastWaitThread.start();	slowWaitThread.start();	createConsumer("broker1", FAST_SHARED_QUEUE, fastConsumerLatch);	MessageConsumer slowConsumer = createConsumer("broker1", SLOW_SHARED_QUEUE, slowConsumerLatch);	MessageIdList messageIdList = brokers.get("broker1").consumers .get(slowConsumer);	messageIdList.setProcessingDelay(SLOW_CONSUMER_DELAY_MILLIS);	fastWaitThread.join();	slowWaitThread.join();	assertTrue("no exceptions on the wait threads:" + exceptions, exceptions.isEmpty());	
fast consumer duration ms 

};	fastWaitThread.start();	slowWaitThread.start();	createConsumer("broker1", FAST_SHARED_QUEUE, fastConsumerLatch);	MessageConsumer slowConsumer = createConsumer("broker1", SLOW_SHARED_QUEUE, slowConsumerLatch);	MessageIdList messageIdList = brokers.get("broker1").consumers .get(slowConsumer);	messageIdList.setProcessingDelay(SLOW_CONSUMER_DELAY_MILLIS);	fastWaitThread.join();	slowWaitThread.join();	assertTrue("no exceptions on the wait threads:" + exceptions, exceptions.isEmpty());	
slow consumer duration ms 

createConsumer("broker1", fastDestination, fastConsumerLatch);	MessageConsumer slowConsumer = createConsumer("broker1", slowDestination, slowConsumerLatch);	MessageIdList messageIdList = brokers.get("broker1").consumers .get(slowConsumer);	messageIdList.setProcessingDelay(SLOW_CONSUMER_DELAY_MILLIS);	persistentDelivery = false;	sendMessages("broker0", fastDestination, NUM_MESSAGES);	sendMessages("broker0", slowDestination, NUM_MESSAGES);	fastWaitThread.join(TimeUnit.SECONDS.toMillis(60));	slowWaitThread.join(TimeUnit.SECONDS.toMillis(60));	assertTrue("no exceptions on the wait threads:" + exceptions, exceptions.isEmpty());	
fast consumer duration ms 

createConsumer("broker1", fastDestination, fastConsumerLatch);	MessageConsumer slowConsumer = createConsumer("broker1", slowDestination, slowConsumerLatch);	MessageIdList messageIdList = brokers.get("broker1").consumers .get(slowConsumer);	messageIdList.setProcessingDelay(SLOW_CONSUMER_DELAY_MILLIS);	persistentDelivery = false;	sendMessages("broker0", fastDestination, NUM_MESSAGES);	sendMessages("broker0", slowDestination, NUM_MESSAGES);	fastWaitThread.join(TimeUnit.SECONDS.toMillis(60));	slowWaitThread.join(TimeUnit.SECONDS.toMillis(60));	assertTrue("no exceptions on the wait threads:" + exceptions, exceptions.isEmpty());	
slow consumer duration ms 

createConsumer("broker0", fastDestination, fastConsumerLatch);	MessageConsumer slowConsumer = createConsumer("broker0", slowDestination, slowConsumerLatch);	MessageIdList messageIdList = brokers.get("broker0").consumers .get(slowConsumer);	messageIdList.setProcessingDelay(SLOW_CONSUMER_DELAY_MILLIS);	persistentDelivery = false;	sendMessages("broker1", fastDestination, NUM_MESSAGES);	sendMessages("broker1", slowDestination, NUM_MESSAGES);	fastWaitThread.join(TimeUnit.SECONDS.toMillis(60));	slowWaitThread.join(TimeUnit.SECONDS.toMillis(60));	assertTrue("no exceptions on the wait threads:" + exceptions, exceptions.isEmpty());	
fast consumer duration ms 

createConsumer("broker0", fastDestination, fastConsumerLatch);	MessageConsumer slowConsumer = createConsumer("broker0", slowDestination, slowConsumerLatch);	MessageIdList messageIdList = brokers.get("broker0").consumers .get(slowConsumer);	messageIdList.setProcessingDelay(SLOW_CONSUMER_DELAY_MILLIS);	persistentDelivery = false;	sendMessages("broker1", fastDestination, NUM_MESSAGES);	sendMessages("broker1", slowDestination, NUM_MESSAGES);	fastWaitThread.join(TimeUnit.SECONDS.toMillis(60));	slowWaitThread.join(TimeUnit.SECONDS.toMillis(60));	assertTrue("no exceptions on the wait threads:" + exceptions, exceptions.isEmpty());	
slow consumer duration ms 

public void serviceFailed(DiscoveryEvent devent) throws IOException {	
dummysimplediscoveryagent servicefailed invoked with event 

========================= activemq sample_3707 =========================

ActiveMQConnection producerConnection = (ActiveMQConnection) factory.createConnection();	producerConnection.setUseAsyncSend(true);	producerConnection.start();	Session producerSession = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = producerSession.createProducer(queue);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	for (int i = 1; i <= messageToSend; i++) {	String msgStr = provideMessageText(i, 8192);	producer.send(producerSession.createTextMessage(msgStr));	if ((i % 1000) == 0) {	
p c 

Session producerSession = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = producerSession.createProducer(queue);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	for (int i = 1; i <= messageToSend; i++) {	String msgStr = provideMessageText(i, 8192);	producer.send(producerSession.createTextMessage(msgStr));	if ((i % 1000) == 0) {	}	}	producerConnection.close();	
mem usage after producer done 

Connection connection = factory.createConnection();	connection.start();	Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);	QueueBrowser browser = session.createBrowser(queue);	Enumeration<?> enumeration = browser.getEnumeration();	int browsed = 0;	while (enumeration.hasMoreElements()) {	TextMessage m = (TextMessage) enumeration.nextElement();	browsed++;	if ((browsed % 1000) == 0) {	
b 

int browsed = 0;	while (enumeration.hasMoreElements()) {	TextMessage m = (TextMessage) enumeration.nextElement();	browsed++;	if ((browsed % 1000) == 0) {	}	}	browser.close();	session.close();	connection.close();	
mem usage after browser closed 

========================= activemq sample_2815 =========================

public void testSendRateWithActivatingConsumers() throws Exception {	final Destination destination = createDestination();	final ConnectionFactory factory = createConnectionFactory();	startInactiveConsumers(factory, destination);	Connection connection = factory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = createMessageProducer(session, destination);	double[] inactiveConsumerStats = produceMessages(destination, 500, 10, session, producer, null);	
with inactive consumers ave max multiplier 

final Object addConsumerSignal = new Object();	Executors.newCachedThreadPool(new ThreadFactory() {	public Thread newThread(Runnable r) {	return new Thread(r, "ActivateConsumer" + this);	}	}).execute(new Runnable() {	public void run() {	try {	MessageConsumer consumer = null;	for (int i = 0; i < consumersToActivate; i++) {	
waiting for add signal from producer 

}).execute(new Runnable() {	public void run() {	try {	MessageConsumer consumer = null;	for (int i = 0; i < consumersToActivate; i++) {	synchronized (addConsumerSignal) {	addConsumerSignal.wait(30 * 60 * 1000);	}	TimedMessageListener listener = new TimedMessageListener();	consumer = createDurableSubscriber(factory.createConnection(), destination, "consumer" + (i + 1));	
created consumer 

for (int i = 0; i < consumersToActivate; i++) {	synchronized (addConsumerSignal) {	addConsumerSignal.wait(30 * 60 * 1000);	}	TimedMessageListener listener = new TimedMessageListener();	consumer = createDurableSubscriber(factory.createConnection(), destination, "consumer" + (i + 1));	consumer.setMessageListener(listener);	consumers.put(consumer, listener);	}	} catch (Exception e) {	
failed to start consumer 

TimedMessageListener listener = new TimedMessageListener();	consumer = createDurableSubscriber(factory.createConnection(), destination, "consumer" + (i + 1));	consumer.setMessageListener(listener);	consumers.put(consumer, listener);	}	} catch (Exception e) {	}	}	});	double[] statsWithActive = produceMessages(destination, 500, 10, session, producer, addConsumerSignal);	
with concurrent activate ave max multiplier 

}	});	double[] statsWithActive = produceMessages(destination, 500, 10, session, producer, addConsumerSignal);	while (consumers.size() < consumersToActivate) {	TimeUnit.SECONDS.sleep(2);	}	long timeToFirstAccumulator = 0;	for (TimedMessageListener listener : consumers.values()) {	long time = listener.getFirstReceipt();	timeToFirstAccumulator += time;	
time to first 

while (consumers.size() < consumersToActivate) {	TimeUnit.SECONDS.sleep(2);	}	long timeToFirstAccumulator = 0;	for (TimedMessageListener listener : consumers.values()) {	long time = listener.getFirstReceipt();	timeToFirstAccumulator += time;	}	LOG.info("Ave time to first message =" + timeToFirstAccumulator / consumers.size());	for (TimedMessageListener listener : consumers.values()) {	
ave batch receipt time max receipt 

ConnectionFactory factory = createConnectionFactory();	startInactiveConsumers(factory, destination);	Connection connection = factory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	final int toSend = 100;	final int numIterations = 5;	double[] noConsumerStats = produceMessages(destination, toSend, numIterations, session, producer, null);	startConsumers(factory, destination);	
activated consumer 

startInactiveConsumers(factory, destination);	Connection connection = factory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	final int toSend = 100;	final int numIterations = 5;	double[] noConsumerStats = produceMessages(destination, toSend, numIterations, session, producer, null);	startConsumers(factory, destination);	double[] withConsumerStats = produceMessages(destination, toSend, numIterations, session, producer, null);	
with consumer with noconsumer multiplier 

final int toSend = 100;	final int numIterations = 5;	double[] noConsumerStats = produceMessages(destination, toSend, numIterations, session, producer, null);	startConsumers(factory, destination);	double[] withConsumerStats = produceMessages(destination, toSend, numIterations, session, producer, null);	final int reasonableMultiplier = 15;	assertTrue("max X times as slow with consumer: " + withConsumerStats[1] + ", with no Consumer: " + noConsumerStats[1] + ", multiplier: " + (withConsumerStats[1] / noConsumerStats[1]), withConsumerStats[1] < noConsumerStats[1] * reasonableMultiplier);	final int toReceive = toSend * numIterations * consumerCount * 2;	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
count 

for (int j = 0; j < toSend; j++) {	long singleSendstart = System.currentTimeMillis();	TextMessage msg = createTextMessage(session, "" + j);	int priority = ((int) count % 10);	producer.send(msg, DeliveryMode.PERSISTENT, priority, 0);	max = Math.max(max, (System.currentTimeMillis() - singleSendstart));	if (++count % 500 == 0) {	if (addConsumerSignal != null) {	synchronized (addConsumerSignal) {	addConsumerSignal.notifyAll();	
signalled add consumer 

max = Math.max(max, (System.currentTimeMillis() - singleSendstart));	if (++count % 500 == 0) {	if (addConsumerSignal != null) {	synchronized (addConsumerSignal) {	addConsumerSignal.notifyAll();	}	}	}	;	if (count % 5000 == 0) {	
sent singlesendmax 

}	}	}	;	if (count % 5000 == 0) {	}	}	long duration = System.currentTimeMillis() - start;	batchMax = Math.max(batchMax, duration);	sum += duration;	
iteration sent time batchmax singlesendmax 

}	}	;	if (count % 5000 == 0) {	}	}	long duration = System.currentTimeMillis() - start;	batchMax = Math.max(batchMax, duration);	sum += duration;	}	
sent batchmax singlesendmax 

}	if (!messageLists.containsKey(priority)) {	MessageIdList perPriorityList = new MessageIdList();	perPriorityList.setParent(allMessagesList);	messageLists.put(priority, perPriorityList);	}	messageLists.get(priority).onMessage(message);	if (count.incrementAndGet() == 1) {	firstReceipt = duration;	firstReceiptLatch.countDown();	
first receipt in ms 

if (!messageLists.containsKey(priority)) {	MessageIdList perPriorityList = new MessageIdList();	perPriorityList.setParent(allMessagesList);	messageLists.put(priority, perPriorityList);	}	messageLists.get(priority).onMessage(message);	if (count.incrementAndGet() == 1) {	firstReceipt = duration;	firstReceiptLatch.countDown();	} else if (count.get() % batchSize == 0) {	
consumed in ms priority 

========================= activemq sample_3642 =========================

public static void main(String[] args) {	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));	BrokerService brokerService = null;	Connection connection = null;	
start 

public static void main(String[] args) {	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));	BrokerService brokerService = null;	Connection connection = null;	try {	brokerService = new BrokerService();	brokerService.setBrokerName("TestMQ");	brokerService.setUseJmx(true);	
broker is starting 

brokerService.setUseJmx(true);	brokerService.start();	ConnectionFactory fac = new ActiveMQConnectionFactory("vm: connection = fac.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination queue = session.createQueue("TEST.QUEUE");	MessageProducer producer = session.createProducer(queue);	for (int i = 0; i < 1000;i++) {	Message msg = session.createTextMessage("test"+i);	producer.send(msg);	}	
active threads after start 

}	System.out.println("Press return to stop........");	String key = br.readLine();	}	catch (Exception e) {	e.printStackTrace();	}	finally {	try {	br.close();	
broker is stopping 

}	catch (Exception e) {	e.printStackTrace();	}	finally {	try {	br.close();	connection.close();	brokerService.stop();	sleep(8);	
active threads after stop 

try {	br.close();	connection.close();	brokerService.stop();	sleep(8);	}	catch (Exception e) {	e.printStackTrace();	}	}	
waiting for list theads is greater then 

sleep(8);	}	catch (Exception e) {	e.printStackTrace();	}	}	int numTh = ThreadExplorer.active();	while (numTh > 2) {	sleep(3);	numTh = ThreadExplorer.active();	
still active threads 

private static void sleep(int second) {	try {	
waiting for s 

========================= activemq sample_2950 =========================

connection1.start();	Session session = connection1.createSession(false, Session.AUTO_ACKNOWLEDGE);	for (int i=0; i<numConsumers; i++) {	session.createConsumer(new ActiveMQQueue("Consumer." + i + ".VirtualTopic.TEST"));	}	Connection connection2 = connectionFactory.createConnection();	connection2.start();	Session producerSession = connection2.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = producerSession.createProducer(new ActiveMQTopic("VirtualTopic.TEST"));	long start = System.currentTimeMillis();	
starting producer 

session.createConsumer(new ActiveMQQueue("Consumer." + i + ".VirtualTopic.TEST"));	}	Connection connection2 = connectionFactory.createConnection();	connection2.start();	Session producerSession = connection2.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = producerSession.createProducer(new ActiveMQTopic("VirtualTopic.TEST"));	long start = System.currentTimeMillis();	for (int i = 0; i < total; i++) {	producer.send(producerSession.createTextMessage(payload));	}	
done producer duration 

}	Connection connection2 = connectionFactory.createConnection();	connection2.start();	Session producerSession = connection2.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = producerSession.createProducer(new ActiveMQTopic("VirtualTopic.TEST"));	long start = System.currentTimeMillis();	for (int i = 0; i < total; i++) {	producer.send(producerSession.createTextMessage(payload));	}	Destination destination  = brokerService.getDestination(new ActiveMQQueue("Consumer.0.VirtualTopic.TEST"));	
dest size 

MessageProducer producer = producerSession.createProducer(new ActiveMQTopic("VirtualTopic.TEST"));	long start = System.currentTimeMillis();	for (int i = 0; i < total; i++) {	producer.send(producerSession.createTextMessage(payload));	}	Destination destination  = brokerService.getDestination(new ActiveMQQueue("Consumer.0.VirtualTopic.TEST"));	assertTrue("did not get all", (destination.getDestinationStatistics().getEnqueues().getCount() < total));	assertTrue("got all", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	Destination dest  = brokerService.getDestination(new ActiveMQQueue("Consumer.1.VirtualTopic.TEST"));	
dest size 

========================= activemq sample_2403 =========================

public void setUp() throws Exception {	brokerService = new BrokerService();	brokerService.setPersistent(false);	brokerService.setPlugins(new BrokerPlugin[] { new BrokerPluginSupport() {	public void removeConnection(ConnectionContext context, ConnectionInfo info, Throwable error) throws Exception {	
remove connection called for connection with error 

ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(unstealableConnectionURI);	Connection connection1 = factory.createConnection();	connection1.setClientID(clientID);	connection1.start();	try {	Connection connection2 = factory.createConnection();	connection2.setClientID(clientID);	connection2.start();	fail("Should not have been able to steal the link.");	} catch (InvalidClientIDException e) {	
caught expected error on trying to steal link 

ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(unstealableConnectionURI);	Connection connection1 = factory.createConnection();	connection1.setClientID(clientID);	connection1.start();	try {	Connection connection2 = factory.createConnection();	connection2.setClientID(clientID);	connection2.start();	fail("Should not have been able to steal the link.");	} catch (InvalidClientIDException e) {	
error 

final String clientID = "ThisIsAClientId";	ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(stealableConnectionURI);	Connection connection1 = factory.createConnection();	connection1.setClientID(clientID);	connection1.start();	try {	Connection connection2 = factory.createConnection();	connection2.setClientID(clientID);	connection2.start();	} catch (InvalidClientIDException e) {	
should not have failed while stealing the link 

final String clientID = "ThisIsAClientId";	ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(stealableConnectionURI);	Connection connection1 = factory.createConnection();	connection1.setClientID(clientID);	connection1.start();	try {	Connection connection2 = factory.createConnection();	connection2.setClientID(clientID);	connection2.start();	} catch (InvalidClientIDException e) {	
error details 

Connection connection1 = factory.createConnection();	connection1.setClientID(clientID);	connection1.start();	try {	Connection connection2 = factory.createConnection();	connection2.setClientID(clientID);	connection2.start();	} catch (InvalidClientIDException e) {	fail("Shouldn't have failed when stealing the link");	} catch (Throwable error) {	
unexpected exception 

} catch (InvalidClientIDException e) {	fail("Shouldn't have failed when stealing the link");	} catch (Throwable error) {	fail("Unexcpected exception causes test failure");	}	assertTrue(Wait.waitFor(new Condition() {	public boolean isSatisified() throws Exception {	return removeException.get() != null;	}	}, 5000, 100));	
removeexception 

========================= activemq sample_3838 =========================

protected void assertMessagesArrived(ConsumerBean messageList1, ConsumerBean messageList2) {	messageList1.assertMessagesArrived(total/2);	messageList2.assertMessagesArrived(total/2);	messageList1.flushMessages();	messageList2.flushMessages();	
validate no other messages on queues 

messageList1.flushMessages();	messageList2.flushMessages();	try {	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination1 = getConsumer1Dsetination();	Destination destination2 = getConsumer2Dsetination();	MessageConsumer c1 = session.createConsumer(destination1, null);	MessageConsumer c2 = session.createConsumer(destination2, null);	c1.setMessageListener(messageList1);	c2.setMessageListener(messageList2);	
send one simple message that should go to both consumers 

========================= activemq sample_2395 =========================

durable.setMessageListener(this);	final Session session = connectionFactory.createConnection().createSession(false, Session.AUTO_ACKNOWLEDGE);	final MessageProducer producer = session.createProducer(createDestination());	final Thread producingThread = new Thread("Producing Thread") {	public void run() {	try {	for (long i = 0; i < numMessagesToSend; i++) {	producer.send(session.createTextMessage("test"));	long count = produced.incrementAndGet();	if (count % 10000 == 0) {	
produced messages 

};	producingThread.start();	ArrayList<ObjectName> subON = new ArrayList<>();	final ArrayList<DurableSubscriptionViewMBean> subViews = new ArrayList<>();	subON.addAll(Arrays.asList(broker.getAdminView().getInactiveDurableTopicSubscribers()));	subON.addAll(Arrays.asList(broker.getAdminView().getDurableTopicSubscribers()));	assertTrue("have a sub", !subON.isEmpty());	for (ObjectName subName : subON) {	subViews.add((DurableSubscriptionViewMBean) broker.getManagementContext().newProxyInstance(subName, DurableSubscriptionViewMBean.class, true));	}	
wait for producer to stop 

final ArrayList<DurableSubscriptionViewMBean> subViews = new ArrayList<>();	subON.addAll(Arrays.asList(broker.getAdminView().getInactiveDurableTopicSubscribers()));	subON.addAll(Arrays.asList(broker.getAdminView().getDurableTopicSubscribers()));	assertTrue("have a sub", !subON.isEmpty());	for (ObjectName subName : subON) {	subViews.add((DurableSubscriptionViewMBean) broker.getManagementContext().newProxyInstance(subName, DurableSubscriptionViewMBean.class, true));	}	assertTrue("producer thread is done", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	for (DurableSubscriptionViewMBean sub : subViews) {	
name 

final ArrayList<DurableSubscriptionViewMBean> subViews = new ArrayList<>();	subON.addAll(Arrays.asList(broker.getAdminView().getInactiveDurableTopicSubscribers()));	subON.addAll(Arrays.asList(broker.getAdminView().getDurableTopicSubscribers()));	assertTrue("have a sub", !subON.isEmpty());	for (ObjectName subName : subON) {	subViews.add((DurableSubscriptionViewMBean) broker.getManagementContext().newProxyInstance(subName, DurableSubscriptionViewMBean.class, true));	}	assertTrue("producer thread is done", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	for (DurableSubscriptionViewMBean sub : subViews) {	
cursor size 

final ArrayList<DurableSubscriptionViewMBean> subViews = new ArrayList<>();	subON.addAll(Arrays.asList(broker.getAdminView().getInactiveDurableTopicSubscribers()));	subON.addAll(Arrays.asList(broker.getAdminView().getDurableTopicSubscribers()));	assertTrue("have a sub", !subON.isEmpty());	for (ObjectName subName : subON) {	subViews.add((DurableSubscriptionViewMBean) broker.getManagementContext().newProxyInstance(subName, DurableSubscriptionViewMBean.class, true));	}	assertTrue("producer thread is done", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	for (DurableSubscriptionViewMBean sub : subViews) {	
mem usage 

final ArrayList<DurableSubscriptionViewMBean> subViews = new ArrayList<>();	subON.addAll(Arrays.asList(broker.getAdminView().getInactiveDurableTopicSubscribers()));	subON.addAll(Arrays.asList(broker.getAdminView().getDurableTopicSubscribers()));	assertTrue("have a sub", !subON.isEmpty());	for (ObjectName subName : subON) {	subViews.add((DurableSubscriptionViewMBean) broker.getManagementContext().newProxyInstance(subName, DurableSubscriptionViewMBean.class, true));	}	assertTrue("producer thread is done", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	for (DurableSubscriptionViewMBean sub : subViews) {	
mem usage 

subViews.add((DurableSubscriptionViewMBean) broker.getManagementContext().newProxyInstance(subName, DurableSubscriptionViewMBean.class, true));	}	assertTrue("producer thread is done", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	for (DurableSubscriptionViewMBean sub : subViews) {	}	return !producingThread.isAlive();	}	}, 10 * 60 * 1000));	for (DurableSubscriptionViewMBean sub : subViews) {	
name 

subViews.add((DurableSubscriptionViewMBean) broker.getManagementContext().newProxyInstance(subName, DurableSubscriptionViewMBean.class, true));	}	assertTrue("producer thread is done", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	for (DurableSubscriptionViewMBean sub : subViews) {	}	return !producingThread.isAlive();	}	}, 10 * 60 * 1000));	for (DurableSubscriptionViewMBean sub : subViews) {	
cursor size 

subViews.add((DurableSubscriptionViewMBean) broker.getManagementContext().newProxyInstance(subName, DurableSubscriptionViewMBean.class, true));	}	assertTrue("producer thread is done", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	for (DurableSubscriptionViewMBean sub : subViews) {	}	return !producingThread.isAlive();	}	}, 10 * 60 * 1000));	for (DurableSubscriptionViewMBean sub : subViews) {	
mem usage 

subViews.add((DurableSubscriptionViewMBean) broker.getManagementContext().newProxyInstance(subName, DurableSubscriptionViewMBean.class, true));	}	assertTrue("producer thread is done", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	for (DurableSubscriptionViewMBean sub : subViews) {	}	return !producingThread.isAlive();	}	}, 10 * 60 * 1000));	for (DurableSubscriptionViewMBean sub : subViews) {	
mem usage 

public void onMessage(Message message) {	long count = consumed.incrementAndGet();	if (count % 10000 == 0) {	
tconsumed messages 

========================= activemq sample_3584 =========================

public void connectionClosed(ConnectionEvent event) {	connections.remove(event.getSource());	try {	((ManagedConnection)event.getSource()).cleanup();	} catch (ResourceException e) {	
error occured during the cleanup of a managed connection 

public void connectionErrorOccurred(ConnectionEvent event) {	
managed connection experiened an error 

public void connectionErrorOccurred(ConnectionEvent event) {	try {	((ManagedConnection)event.getSource()).cleanup();	} catch (ResourceException e) {	
error occured during the cleanup of a managed connection 

public void connectionErrorOccurred(ConnectionEvent event) {	try {	((ManagedConnection)event.getSource()).cleanup();	} catch (ResourceException e) {	}	try {	((ManagedConnection)event.getSource()).destroy();	} catch (ResourceException e) {	
error occured during the destruction of a managed connection 

========================= activemq sample_827 =========================

public void testCRLF() throws Exception {	for (TransportConnector connector : brokerService.getTransportConnectors()) {	
try 

public void testCRLF() throws Exception {	for (TransportConnector connector : brokerService.getTransportConnectors()) {	int port = connector.getConnectUri().getPort();	StompConnection stompConnection = new StompConnection();	stompConnection.open(createSocket(port));	String frame = "CONNECT\r\n\r\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	frame = stompConnection.receiveFrame();	
response from 

public void testCRLF11() throws Exception {	for (TransportConnector connector : brokerService.getTransportConnectors()) {	
try 

public void testCRLF11() throws Exception {	for (TransportConnector connector : brokerService.getTransportConnectors()) {	int port = connector.getConnectUri().getPort();	StompConnection stompConnection = new StompConnection();	stompConnection.open(createSocket(port));	String frame = "CONNECT\r\naccept-version:1.1\r\n\r\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	frame = stompConnection.receiveFrame();	
response from 

========================= activemq sample_1413 =========================

Thread.sleep(60 * 1000);	} catch (InterruptedException e) {	exit("ProcessTest.testProcess failed.", e);	}	server.done = true;	try {	server.join(60*1000);	} catch (Exception ignored) {}	processLock.writeLock().lock();	assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());	
done 

private void restartBroker() throws Exception {	
broker restart waiting for components 

private void restartBroker() throws Exception {	processLock.writeLock().lock();	try {	destroyBroker();	startBroker(false);	restartCount++;	
broker restarted count 

private void createNewClient() throws JMSException {	ClientType type = ClientType.randomClientType();	Client client;	synchronized (server.sendMutex) {	client = new Client(++clientRover, type, CLIENT_LIFETIME, CLIENT_ONLINE, CLIENT_OFFLINE);	clients.add(client);	}	client.start();	
created 

onlineCount.incrementAndGet();	try {	process(online.next());	} finally {	onlineCount.decrementAndGet();	processLock.readLock().unlock();	}	}	if (!ALLOW_SUBSCRIPTION_ABANDONMENT || random(1) > 0) unsubscribe();	else {	
client abandon the subscription 

}	}	if (!ALLOW_SUBSCRIPTION_ABANDONMENT || random(1) > 0) unsubscribe();	else {	houseKeeper.abandonedSubscriptions.add(conClientId);	}	} catch (Throwable e) {	exit(toString() + " failed.", e);	}	clientManager.removeClient(this);	
done 

private void process(long millis) throws JMSException {	long end = System.currentTimeMillis() + 200;	long hardEnd = end + 20000;	boolean inTransaction = false;	int transCount = 0;	Connection con = openConnection();	Session sess = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);	consumer = (ActiveMQMessageConsumer) sess.createDurableSubscriber(topic, SUBSCRIPTION_NAME, selector, false);	
online 

boolean inTransaction = false;	int transCount = 0;	Connection con = openConnection();	Session sess = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);	consumer = (ActiveMQMessageConsumer) sess.createDurableSubscriber(topic, SUBSCRIPTION_NAME, selector, false);	try {	do {	long max = end - System.currentTimeMillis();	if (max <= 0) {	if (!inTransaction) {	
done after no work 

inTransaction = true;	transCount++;	if (1 == transCount) {	LOG.info("In Trans[id=" + message.getIntProperty("TRANS") + "] first ID=" + message.getIntProperty("ID"));	}	}	} while (true);	} finally {	sess.close();	con.close();	
offline 

private void unsubscribe() throws JMSException {	processLock.readLock().lock();	
unsubscribe 

private void sweep() throws Exception {	
housekeeper sweeping 

private void sweep() throws Exception {	int closed = 0;	ArrayList<String> sweeped = new ArrayList<String>();	try {	for (String clientId : abandonedSubscriptions) {	
sweeping out subscription of 

private void sweep() throws Exception {	int closed = 0;	ArrayList<String> sweeped = new ArrayList<String>();	try {	for (String clientId : abandonedSubscriptions) {	broker.getAdminView().destroyDurableSubscriber(clientId, Client.SUBSCRIPTION_NAME);	sweeped.add(clientId);	closed++;	}	} catch (Exception ignored) {	
ex on destroy sub 

try {	for (String clientId : abandonedSubscriptions) {	broker.getAdminView().destroyDurableSubscriber(clientId, Client.SUBSCRIPTION_NAME);	sweeped.add(clientId);	closed++;	}	} catch (Exception ignored) {	} finally {	abandonedSubscriptions.removeAll(sweeped);	}	
housekeeper sweeped out subscriptions 

========================= activemq sample_3711 =========================

public void testRemovedDurableSubDeletesFromIndex() throws Exception {	if (! (broker.getPersistenceAdapter() instanceof KahaDBPersistenceAdapter)) {	return;	}	final int numMessages = 2750;	KahaDBPersistenceAdapter kahaDBPersistenceAdapter = (KahaDBPersistenceAdapter)broker.getPersistenceAdapter();	PageFile pageFile = kahaDBPersistenceAdapter.getStore().getPageFile();	
pagecount f filesize 

public void testRemovedDurableSubDeletesFromIndex() throws Exception {	if (! (broker.getPersistenceAdapter() instanceof KahaDBPersistenceAdapter)) {	return;	}	final int numMessages = 2750;	KahaDBPersistenceAdapter kahaDBPersistenceAdapter = (KahaDBPersistenceAdapter)broker.getPersistenceAdapter();	PageFile pageFile = kahaDBPersistenceAdapter.getStore().getPageFile();	long lastDiff = 0;	for (int repeats=0; repeats<2; repeats++) {	
iteration count f 

Message message = session.createMessage();	message.setStringProperty("filter", "true");	producer.send(topic, message);	}	con.close();	Connection con2 = createConnection("cliId1" + "-" + repeats);	Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);	session2.unsubscribe("SubsId");	session2.close();	con2.close();	
pagecount f diff filesize 

public void testOrderOnActivateDeactivate() throws Exception {	for (int i=0;i<10;i++) {	
iteration 

++runCount;	int i=0;	for (; i < messageCount/2; i++) {	Message message = consumer.receiveNoWait();	if (message == null) {	break;	}	long producerSequenceId = new MessageId(message.getJMSMessageID()).getProducerSequenceId();	assertEquals(id + " expected order: runCount: " + runCount  + " id: " + message.getJMSMessageID(), ++nextId, producerSequenceId);	}	
peeked 

Runnable producer = new Runnable() {	final String payLoad = new String(new byte[600]);	public void run() {	try {	Connection con = createConnection();	final Session sendSession = con.createSession(true, Session.SESSION_TRANSACTED);	MessageProducer producer = sendSession.createProducer(topic);	for (int i = 0; i < messageCount; i++) {	producer.send(sendSession.createTextMessage(payLoad));	}	
about to commit 

final String payLoad = new String(new byte[600]);	public void run() {	try {	Connection con = createConnection();	final Session sendSession = con.createSession(true, Session.SESSION_TRANSACTED);	MessageProducer producer = sendSession.createProducer(topic);	for (int i = 0; i < messageCount; i++) {	producer.send(sendSession.createTextMessage(payLoad));	}	sendSession.commit();	
committed 

session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(null);	int filtered = 0;	for (int i = 0; i < 10; i++) {	boolean filter = (i %2 == 0);	if (filter) filtered++;	Message message = session.createMessage();	message.setStringProperty("filter", filter ? "true" : "false");	producer.send(topic, message);	}	
sent 

con = createConnection();	session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(null);	int sent = 0;	for (int i = 0; i < 10; i++) {	Message message = session.createMessage();	message.setStringProperty("filter", "true");	producer.send(topic, message);	sent++;	}	
sent 

con.close();	con = createConnection("cli1");	session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);	DurableSubscriptionOfflineTestListener listener = new DurableSubscriptionOfflineTestListener();	consumer.setMessageListener(listener);	Thread.sleep(3 * 1000);	session.close();	con.close();	assertEquals(sent, listener.count);	
pull 

con = createConnection();	session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	producer = session.createProducer(null);	sent = 0;	for (int i = 0; i < 2; i++) {	Message message = session.createMessage();	message.setStringProperty("filter", i==1 ? "true" : "false");	producer.send(topic, message);	sent++;	}	
sent 

sent = 0;	for (int i = 0; i < 2; i++) {	Message message = session.createMessage();	message.setStringProperty("filter", i==1 ? "true" : "false");	producer.send(topic, message);	sent++;	}	Thread.sleep(1 * 1000);	session.close();	con.close();	
again should get new ones 

producer.send(topic, message);	sent++;	for (int i = sent; i < 10; i++) {	message = session.createMessage();	message.setStringProperty("filter", "false");	message.setIntProperty("ID", i);	producer.send(topic, message);	sent++;	}	con.close();	
sent 

session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	producer = session.createProducer(null);	for (int i = sent; i < 30; i++) {	message = session.createMessage();	message.setStringProperty("filter", "true");	message.setIntProperty("ID", i);	producer.send(topic, message);	sent++;	}	con.close();	
sent 

========================= activemq sample_3654 =========================

public void activate(SystemUsage memoryManager, ConnectionContext context, ConsumerInfo info, RegionBroker regionBroker) throws Exception {	if (!active.get()) {	this.context = context;	this.info = info;	
activating 

public void onUsageChanged(Usage usage, int oldPercentUsage, int newPercentUsage) {	if (oldPercentUsage > newPercentUsage && oldPercentUsage >= 90) {	try {	dispatchPending();	} catch (IOException e) {	
problem calling dispatchmatched 

========================= activemq sample_3984 =========================

public void testInactivityMonitor() throws Exception {	Thread t1 = new Thread() {	public void run() {	try {	connection = createConnection();	connection.getOutputStream().write('A');	connection.getOutputStream().flush();	} catch (Exception ex) {	
unexpected exception on connect disconnect 

========================= activemq sample_1540 =========================

protected void reloadConfiguration() throws Exception {	if( zk_client==null )  {	
connecting to zookeeper 

protected void reloadConfiguration() throws Exception {	if( zk_client==null )  {	try {	zkConnect();	
connected to zookeeper 

protected void reloadConfiguration() throws Exception {	if( zk_client==null )  {	try {	zkConnect();	} catch (Exception e) {	
connection to zookeeper failed 

try {	reloadConfiguration();	} catch (Exception e) {	}	monitorWakeup();	}	}, stat);	configAcquired.countDown();	reloadConfigOnPoll = false;	} catch (Exception e) {	
could load partitioning configuration 

}	}, stat);	configAcquired.countDown();	reloadConfigOnPoll = false;	} catch (Exception e) {	reloadConfigOnPoll = true;	}	try {	config = Partitioning.MAPPER.readValue(data, Partitioning.class);	} catch (Exception e) {	
invalid partitioning configuration 

========================= activemq sample_1405 =========================

protected BrokerService createBroker(String uri) throws Exception {	
loading broker configuration from the classpath with uri 

========================= activemq sample_2679 =========================

protected Transport createTransport(URI location, WireFormat wf) throws UnknownHostException, IOException {	URI localLocation = null;	String path = location.getPath();	if (path != null && path.length() > 0) {	int localPortIndex = path.indexOf(':');	try {	Integer.parseInt(path.substring(localPortIndex + 1, path.length()));	String localString = location.getScheme() + ":/" + path;	localLocation = new URI(localString);	} catch (Exception e) {	
path isn t a valid local location for ssltransport to use 

========================= activemq sample_132 =========================

public void close() {	if (_stateChangeDispatcher != null) {	_stateChangeDispatcher.end();	try {	_stateChangeDispatcher.join(1000);	} catch(Exception e) {	
ignored exception 

if (_zk != null) {	try {	changeState(State.NONE);	_zk.close();	Thread th = getSendThread();	if (th != null) {	th.join(1000);	}	_zk = null;	} catch(Exception e) {	
ignored exception 

protected void tryConnect() {	synchronized (_lock) {	try {	connect();	} catch (Throwable e) {	
error while restarting 

public void process(WatchedEvent event) {	if (event.getState() != null) {	
event 

if (event.getState() != null) {	synchronized (_lock) {	switch(event.getState()) {	case SyncConnected: changeState(State.CONNECTED);	break;	case Disconnected: if(_state != State.NONE) {	changeState(State.RECONNECTING);	}	break;	case Expired: _zk = null;	
expiration detected trying to restart 

switch(event.getState()) {	case SyncConnected: changeState(State.CONNECTED);	break;	case Disconnected: if(_state != State.NONE) {	changeState(State.RECONNECTING);	}	break;	case Expired: _zk = null;	tryConnect();	break;	
unprocessed event state 

public void run() {	Map<Object, Boolean> history = new IdentityHashMap<Object, Boolean>();	
starting statechangedispatcher 

isConnectedEvent = _events.take();	} catch (InterruptedException e) {	continue;	}	if (!_running.get() || isConnectedEvent == null) {	continue;	}	Map<Object, Boolean> newHistory = callListeners(history, isConnectedEvent);	history = newHistory;	}	
statechangedispatcher terminated 

for (LifecycleListener listener : _listeners) {	Boolean previousEvent = history.get(listener);	if (previousEvent == null || previousEvent != connectedEvent) {	try {	if (connectedEvent) {	listener.onConnected();	} else {	listener.onDisconnected();	}	} catch (Throwable e) {	
exception while executing listener ignored 

public void run() {	
entering recovery mode 

public void run() {	synchronized(_lock) {	try {	int count = 0;	while (_state == ZKClient.State.NONE) {	try {	count++;	
recovery mode trying to reconnect to zookeeper 

public void run() {	synchronized(_lock) {	try {	int count = 0;	while (_state == ZKClient.State.NONE) {	try {	count++;	ZKClient.this.connect();	} catch (Throwable e) {	
recovery mode reconnect attempt failed waiting for 

} catch (Throwable e) {	try {	_lock.wait(_reconnectTimeout.getDurationInMilliseconds());	} catch(InterruptedException e1) {	throw new RuntimeException("Recovery mode: wait interrupted... bailing out", e1);	}	}	}	} finally {	_expiredSessionRecovery = null;	
exiting recovery mode 

paths.add(path);	path = PathUtils.getParentPath(path);	path = PathUtils.removeTrailingSlash(path);	}	Collections.reverse(paths);	for(String p : paths) {	try {	getZk().create(p, null, getNodeACLs(p), CreateMode.PERSISTENT);	} catch(KeeperException.NodeExistsException e) {	if (LOG.isDebugEnabled()) {	
parent already exists 

========================= activemq sample_1281 =========================

public void startBroker() {	
lets wait millis before creating the broker 

public void startBroker() {	try {	Thread.sleep(delayBeforeStartingBroker);	} catch (InterruptedException e) {	e.printStackTrace();	}	
now starting the broker 

try {	Thread.sleep(delayBeforeStartingBroker);	} catch (InterruptedException e) {	e.printStackTrace();	}	try {	broker = new BrokerService();	broker.setPersistent(false);	broker.addConnector("tcp: broker.start();	} catch (Exception e) {	
caught 

========================= activemq sample_3746 =========================

public void testBrokers() throws Exception {	buildUrlList();	for (int i = 0; i < numBrokers; i++) {	createBroker(i);	}	startAllBrokers();	waitForBridgeFormation(numBrokers - 1);	verifyPeerBrokerInfos(numBrokers - 1);	final List<ConsumerState> consumerStates = startAllGWConsumers(numBrokers);	startAllGWFanoutConsumers(numBrokers);	
waiting for percolation of consumers 

buildUrlList();	for (int i = 0; i < numBrokers; i++) {	createBroker(i);	}	startAllBrokers();	waitForBridgeFormation(numBrokers - 1);	verifyPeerBrokerInfos(numBrokers - 1);	final List<ConsumerState> consumerStates = startAllGWConsumers(numBrokers);	startAllGWFanoutConsumers(numBrokers);	TimeUnit.SECONDS.sleep(5);	
produce mesages 

verifyPeerBrokerInfos(numBrokers - 1);	final List<ConsumerState> consumerStates = startAllGWConsumers(numBrokers);	startAllGWFanoutConsumers(numBrokers);	TimeUnit.SECONDS.sleep(5);	long startTime = System.currentTimeMillis();	produce(numMessages);	assertTrue("Got all sent", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	for (ConsumerState tally : consumerStates) {	final int expected = numMessages * (tally.destination.isComposite() ? tally.destination.getCompositeDestinations().length : 1);	
tally for dest 

long startTime = System.currentTimeMillis();	produce(numMessages);	assertTrue("Got all sent", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	for (ConsumerState tally : consumerStates) {	final int expected = numMessages * (tally.destination.isComposite() ? tally.destination.getCompositeDestinations().length : 1);	if (tally.accumulator.get() != expected) {	LOG.info("Tally for: " + tally.brokerName + ", dest: " + tally.destination + " - " + tally.accumulator.get() + " != " + expected + ", " + tally.expected);	return false;	}	
got tally on 

final int expected = numMessages * (tally.destination.isComposite() ? tally.destination.getCompositeDestinations().length : 1);	if (tally.accumulator.get() != expected) {	LOG.info("Tally for: " + tally.brokerName + ", dest: " + tally.destination + " - " + tally.accumulator.get() + " != " + expected + ", " + tally.expected);	return false;	}	}	return true;	}	}, 1000 * 60 * 1000l));	assertTrue("No exceptions:" + exceptions, exceptions.isEmpty());	
done 

if (tally.accumulator.get() != expected) {	LOG.info("Tally for: " + tally.brokerName + ", dest: " + tally.destination + " - " + tally.accumulator.get() + " != " + expected + ", " + tally.expected);	return false;	}	}	return true;	}	}, 1000 * 60 * 1000l));	assertTrue("No exceptions:" + exceptions, exceptions.isEmpty());	long duration = System.currentTimeMillis() - startTime;	
duration 

QueueConnection queueConnection = connectionFactory.createQueueConnection();	queueConnection.start();	final QueueSession queueSession = queueConnection.createQueueSession(true, Session.SESSION_TRANSACTED);	final MessageProducer producer = queueSession.createProducer(compositeQ);	queueSession.createReceiver(new ActiveMQQueue("IN")).setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	producer.send(message);	queueSession.commit();	} catch (Exception e) {	
failed to fanout to gw 

e.printStackTrace();	}	try {	consumerState.accumulator.incrementAndGet();	try {	consumerState.expected.remove(((ActiveMQMessage) message).getProperty("NUM"));	} catch (IOException e) {	e.printStackTrace();	}	} catch (Exception e) {	
failed to commit slow receipt of 

public void run() {	try {	ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("failover:(tcp: connectionFactory.setWatchTopicAdvisories(false);	QueueConnection queueConnection = connectionFactory.createQueueConnection();	queueConnection.start();	QueueSession queueSession = queueConnection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = queueSession.createProducer(null);	int val = 0;	while ((val = toSend.decrementAndGet()) >= 0) {	ActiveMQQueue compositeQ = new ActiveMQQueue("IN");	
send to dest 

private void verifyPeerBrokerInfo(BrokerItem brokerItem, final int max) throws Exception {	final BrokerService broker = brokerItem.broker;	final RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
verify infos len 

private void verifyPeerBrokerInfo(BrokerItem brokerItem, final int max) throws Exception {	final BrokerService broker = brokerItem.broker;	final RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return max == regionBroker.getPeerBrokerInfos().length;	}	});	
verify infos len 

});	List<String> missing = new ArrayList<String>();	for (int i = 0; i < max; i++) {	missing.add("B" + i);	}	if (max != regionBroker.getPeerBrokerInfos().length) {	for (BrokerInfo info : regionBroker.getPeerBrokerInfos()) {	LOG.info(info.getBrokerName());	missing.remove(info.getBrokerName());	}	
broker infos off 

========================= activemq sample_2911 =========================

private MessageConsumer consumeVerifyOrder(Session session, final int num, final int base) throws Exception {	MessageConsumer messageConsumer = session.createConsumer(dest);	for (int i=0; i<num; ) {	Message message = messageConsumer.receive(4000);	if (message != null) {	assertEquals(i + base, message.getIntProperty("Order"));	i++;	
received order Order 

========================= activemq sample_3603 =========================

public void onMessage(Message message)  {	try {	
listener received 

========================= activemq sample_759 =========================

public void testAbortAlreadyClosedConsumers() throws Exception {	Connection conn = createConnectionFactory().createConnection();	conn.setExceptionListener(this);	connections.add(conn);	Session sess = conn.createSession(false, Session.CLIENT_ACKNOWLEDGE);	final MessageConsumer consumer = sess.createConsumer(destination);	conn.start();	startProducers(destination, 20);	TimeUnit.SECONDS.sleep(1);	
closing consumer 

public void testAbortAlreadyClosedConnection() throws Exception {	Connection conn = createConnectionFactory().createConnection();	conn.setExceptionListener(this);	Session sess = conn.createSession(false, Session.CLIENT_ACKNOWLEDGE);	sess.createConsumer(destination);	conn.start();	startProducers(destination, 20);	TimeUnit.SECONDS.sleep(1);	
closing connection 

========================= activemq sample_2442 =========================

public void onWebSocketText(String data) {	if (data == null) {	return;	}	if (data.equals("\n")) {	
new incoming heartbeat read 

public void onWebSocketText(String data) {	if (data == null) {	return;	}	if (data.equals("\n")) {	} else {	
new incoming stomp frame read 

public void onWebSocketClose(int statusCode, String reason) {	
stomp ws connection closed code message 

========================= activemq sample_1147 =========================

public void testDurableSubscriptionsAreRecovered() throws Exception {	MqttClient connection = createClient(getTestName());	final String[] topics = { "TopicA/", "TopicB/", "TopicC/" };	for (int i = 0; i < topics.length; i++) {	
subscribing to topic 

========================= activemq sample_889 =========================

public void testBrowsingExpiration() throws JMSException, InterruptedException {	sendTestMessages();	Connection browserConnection = factory.createConnection();	browserConnection.start();	int browsed = browse(queue, browserConnection);	assertEquals(MESSAGES_TO_SEND, browsed);	long begin = System.nanoTime();	while (browsed != 0) {	Thread.sleep(100);	browsed = browse(queue, browserConnection);	
ms found 

sendTestMessages();	Connection browserConnection = factory.createConnection();	browserConnection.start();	int browsed = browse(queue, browserConnection);	assertEquals(MESSAGES_TO_SEND, browsed);	long begin = System.nanoTime();	while (browsed != 0) {	Thread.sleep(100);	browsed = browse(queue, browserConnection);	}	
Finished 

private int browse(ActiveMQQueue queue, Connection connection) throws JMSException {	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	QueueBrowser browser = session.createBrowser(queue);	Enumeration<?> enumeration = browser.getEnumeration();	int browsed = 0;	while (enumeration.hasMoreElements()) {	TextMessage m = (TextMessage) enumeration.nextElement();	browsed++;	
b 

protected void sendTestMessages() throws JMSException {	Connection prodConnection = factory.createConnection();	prodConnection.start();	Session prodSession = prodConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = prodSession.createProducer(queue);	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	producer.setTimeToLive(TTL);	for (int i = 1; i <= MESSAGES_TO_SEND; i++) {	String msgStr = "Message: " + i;	producer.send(prodSession.createTextMessage(msgStr));	
p c 

========================= activemq sample_2291 =========================

byte[] payload = new byte[65535];	Arrays.fill(payload, (byte) 255);	final CountDownLatch done = new CountDownLatch(1);	final AtomicInteger counter = new AtomicInteger();	Thread purge = new Thread(new Runnable() {	public void run() {	try {	while (!done.await(5, TimeUnit.SECONDS)) {	if (queueView.getBlockedSends() > 0 && queueView.getQueueSize() > 0) {	long queueSize = queueView.getQueueSize();	
queue send blocked at messages 

while (!done.await(5, TimeUnit.SECONDS)) {	if (queueView.getBlockedSends() > 0 && queueView.getQueueSize() > 0) {	long queueSize = queueView.getQueueSize();	MessageConsumer consumer = session.createConsumer(queue);	for (int i = 0; i < queueSize; i++) {	Message message = consumer.receive(60000);	if (message != null) {	counter.incrementAndGet();	message.acknowledge();	} else {	
got null message when none as expected 

}	} catch (Exception ex) {	}	}	});	purge.start();	for (int i = 0; i < MSG_COUNT; i++) {	BytesMessage message = session.createBytesMessage();	message.writeBytes(payload);	producer.send(message);	
sent message 

purge.join(60000);	if (purge.isAlive()) {	fail("Consumer thread should have read initial batch and completed.");	}	assertTrue(Wait.waitFor(new Condition() {	public boolean isSatisified() throws Exception {	return queueView.getDequeueCount() == counter.get();	}	}));	long remainingQueued = queueView.getQueueSize();	
remaining messages to consume 

}	}));	long remainingQueued = queueView.getQueueSize();	assertEquals(remainingQueued, MSG_COUNT - counter.get());	MessageConsumer consumer = session.createConsumer(queue);	for (int i = counter.get(); i < MSG_COUNT; i++) {	Message message = consumer.receive(5000);	assertNotNull("Should not get null message", consumer);	counter.incrementAndGet();	message.acknowledge();	
read message 

========================= activemq sample_2784 =========================

public void testRemoveQueueAndProduceAfterNewConsumerAdded() throws Exception {	MessageConsumer firstConsumer = registerConsumer();	produceMessage();	Message message = firstConsumer.receive(5000);	
received message 

Message message = firstConsumer.receive(5000);	assertEquals(1, numberOfMessages());	firstConsumer.close();	session.commit();	Thread.sleep(1000);	removeQueue();	Thread.sleep(1000);	MessageConsumer secondConsumer = registerConsumer();	produceMessage();	message = secondConsumer.receive(5000);	
received message 

public void testRemoveQueueAndProduceBeforeNewConsumerAdded() throws Exception {	MessageConsumer firstConsumer = registerConsumer();	produceMessage();	Message message = firstConsumer.receive(5000);	
received message 

Message message = firstConsumer.receive(5000);	assertEquals(1, numberOfMessages());	firstConsumer.close();	session.commit();	Thread.sleep(1000);	removeQueue();	Thread.sleep(1000);	produceMessage();	MessageConsumer secondConsumer = registerConsumer();	message = secondConsumer.receive(5000);	
received message 

private void removeQueue() throws Exception {	
removing destination myqueue 

private void produceMessage() throws JMSException {	TextMessage textMessage = session.createTextMessage();	textMessage.setText("Sending message: " + count++);	
sending message 

========================= activemq sample_3678 =========================

public void startSampler(CountDownLatch completionLatch, ClientRunBasis clientRunBasis, long clientRunDuration) {	Validate.notNull(clientRunBasis);	Validate.notNull(completionLatch);	if (clientRunBasis == ClientRunBasis.time) {	duration = (duration == null) ? clientRunDuration : this.duration;	rampUpTime = (rampUpTime == null) ? (duration / 100 * rampUpPercent) : this.rampUpTime;	rampDownTime = (rampDownTime == null) ? (duration / 100 * rampDownPercent) : this.rampDownTime;	Validate.isTrue(duration >= (rampUpTime + rampDownTime), "Ramp times (up: " + rampDownTime + ", down: " + rampDownTime + ") exceed the sampler duration (" + duration + ")");	
sampling duration ms ramp up ms ramp down ms 

Validate.notNull(completionLatch);	if (clientRunBasis == ClientRunBasis.time) {	duration = (duration == null) ? clientRunDuration : this.duration;	rampUpTime = (rampUpTime == null) ? (duration / 100 * rampUpPercent) : this.rampUpTime;	rampDownTime = (rampDownTime == null) ? (duration / 100 * rampDownPercent) : this.rampDownTime;	Validate.isTrue(duration >= (rampUpTime + rampDownTime), "Ramp times (up: " + rampDownTime + ", down: " + rampDownTime + ") exceed the sampler duration (" + duration + ")");	Thread notifier = new Thread(new RampDownNotifier(this));	notifier.setName("RampDownNotifier[" + this.getClass().getSimpleName() + "]");	notifier.start();	} else {	
performance test running on count basis ignoring duration and ramp times 

public void run() {	try {	
ramp up start 

if (perfEventListener != null) {	perfEventListener.onRampUpStart(this);	}	if (rampUpTime > 0) {	try {	Thread.sleep(rampUpTime);	} catch (InterruptedException e) {	e.printStackTrace();	}	}	
sampler start 

Thread.sleep(rampUpTime);	} catch (InterruptedException e) {	e.printStackTrace();	}	}	onSamplerStart();	if (perfEventListener != null) {	perfEventListener.onSamplerStart(this);	}	sample();	
sampler end 

if (perfEventListener != null) {	perfEventListener.onSamplerEnd(this);	}	if (rampDownTime > 0) {	try {	Thread.sleep(rampDownTime);	} catch (InterruptedException e) {	e.printStackTrace();	}	}	
ramp down end 

========================= activemq sample_1215 =========================

Session sesHub = conHub.createSession(false, Session.AUTO_ACKNOWLEDGE);	Session sesSpoke = conSpoke.createSession(false, Session.AUTO_ACKNOWLEDGE);	ActiveMQTopic topic = new ActiveMQTopic("TEST.FOO");	String consumerName = "consumerName";	MessageConsumer remoteConsumer = sesSpoke.createDurableSubscriber(topic, consumerName);	remoteConsumer.setMessageListener(new MessageListener() {	public void onMessage(Message msg) {	try {	TextMessage textMsg = (TextMessage) msg;	receivedMsgs++;	
received messages 

socketProxy.goOn();	} else {	socketProxy.reopen();	}	} else {	sleep(500);	}	Message test = sesHub.createTextMessage("test-" + i);	localProducer.send(test);	}	
waiting for messages to flow 

========================= activemq sample_3697 =========================

connection.start();	fail("Expected exception.");	} catch (JMSException e) {	e.printStackTrace();	}	}	}	};	thread.start();	TimeUnit.SECONDS.sleep(10);	
trying genuine connection 

e.printStackTrace();	}	}	}	};	thread.start();	TimeUnit.SECONDS.sleep(10);	ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("failover:(tcp: Connection goodConnection = factory.createConnection("user", "password");	goodConnection.start();	goodConnection.close();	
giving up on dos 

protected BrokerService createBroker(String uri) throws Exception {	
loading broker configuration from the classpath with uri 

========================= activemq sample_2655 =========================

public String doTestProducerConsumer(int index) throws Exception {	String message = null;	assertEquals("Should not be any consumers", 0, brokerService.getAdminView().getTopicSubscribers().length);	StompConnection producer = stompConnect();	StompConnection consumer = stompConnect();	subscribe(consumer, Integer.toString(index));	sendMessage(producer, index);	try {	StompFrame frame = consumer.receive();	
consumer got frame 

public String doTestProducerDurableConsumer(int index) throws Exception {	String message = null;	assertEquals("Should not be any consumers", 0, brokerService.getAdminView().getTopicSubscribers().length);	StompConnection producer = stompConnect();	StompConnection consumer = stompConnect("test");	subscribe(consumer, Integer.toString(index), true);	sendMessage(producer, index);	try {	StompFrame frame = consumer.receive();	
consumer got frame 

========================= activemq sample_1429 =========================

protected void consumeMessage(Message message, List<Message> messageList) {	super.consumeMessage(message, messageList);	if (message instanceof TextMessage) {	TextMessage textMessage = TextMessage.class.cast(message);	try {	
received text message with text 

protected void consumeMessage(Message message, List<Message> messageList) {	super.consumeMessage(message, messageList);	if (message instanceof TextMessage) {	TextMessage textMessage = TextMessage.class.cast(message);	try {	} catch( javax.jms.JMSException jmsE) {	
received an exception while trying to retrieve the text message 

protected void consumeMessage(Message message, List<Message> messageList) {	super.consumeMessage(message, messageList);	if (message instanceof TextMessage) {	TextMessage textMessage = TextMessage.class.cast(message);	try {	} catch( javax.jms.JMSException jmsE) {	throw new RuntimeException(jmsE);	}	} else {	
received a non text message 

========================= activemq sample_1096 =========================

protected void setUp() throws Exception {	groupId = "network-load-test-"+System.currentTimeMillis();	brokers = new BrokerService[BROKER_COUNT];	for (int i = 0; i < brokers.length; i++) {	
starting broker 

protected void setUp() throws Exception {	groupId = "network-load-test-"+System.currentTimeMillis();	brokers = new BrokerService[BROKER_COUNT];	for (int i = 0; i < brokers.length; i++) {	brokers[i] = createBroker(i);	brokers[i].start();	}	Thread.sleep(BROKER_COUNT*BROKER_COUNT*50);	forwardingClients = new ForwardingClient[BROKER_COUNT-1];	for (int i = 0; i < forwardingClients.length; i++) {	
starting fowarding client 

protected void tearDown() throws Exception {	for (int i = 0; i < forwardingClients.length; i++) {	
stoping fowarding client 

protected void tearDown() throws Exception {	for (int i = 0; i < forwardingClients.length; i++) {	forwardingClients[i].close();	}	for (int i = 0; i < brokers.length; i++) {	
stoping broker 

public void testRequestReply() throws Exception {	final int to = 0;	int from = brokers.length-1;	
staring final consumer 

ActiveMQTextMessage last = lastMessageReceived.get();	if( last!=null ) {	if( last.getMessageId().getProducerSequenceId() > m.getMessageId().getProducerSequenceId() ) {	System.out.println("Received an out of order message. Got "+m.getMessageId()+", expected something after "+last.getMessageId());	}	}	lastMessageReceived.set(m);	receivedMessages.incrementAndGet();	}	});	
staring initial producer 

long start = System.currentTimeMillis();	producedMessages.set(0);	receivedMessages.set(0);	for (int j = 0; j < forwardingClients.length; j++) {	forwardingClients[j].forwardCounter.set(0);	}	Thread.sleep(SAMPLE_DURATION);	long end = System.currentTimeMillis();	long r = receivedMessages.get();	long p = producedMessages.get();	
published msgs at msgs sec consumed msgs at msgs sec 

for (int j = 0; j < forwardingClients.length; j++) {	if( j!= 0 ) {	fwdingmsg.append(", ");	}	fwdingmsg.append(forwardingClients[j].forwardCounter.get());	}	LOG.info(fwdingmsg.toString());	assertTrue("Recieved some messages since last sample", r>0);	assertTrue("Produced some messages since last sample", p>0);	}	
sample done 

========================= activemq sample_2710 =========================

public void testgetNextTimeDayOfWeek() throws MessageFormatException {	Calendar current = Calendar.getInstance();	current.set(2010, Calendar.NOVEMBER, 15, 9, 15, 30);	
start 

public void testgetNextTimeDayOfWeek() throws MessageFormatException {	Calendar current = Calendar.getInstance();	current.set(2010, Calendar.NOVEMBER, 15, 9, 15, 30);	String test = "* * * * 5";	long next = CronParser.getNextScheduledTime(test, current.getTimeInMillis());	Calendar result = Calendar.getInstance();	result.setTimeInMillis(next);	
next 

public void testgetNextTimeDayOfWeekVariant() throws MessageFormatException {	Calendar current = Calendar.getInstance();	current.set(2011, Calendar.MARCH, 7, 9, 15, 30);	
start 

public void testgetNextTimeDayOfWeekVariant() throws MessageFormatException {	Calendar current = Calendar.getInstance();	current.set(2011, Calendar.MARCH, 7, 9, 15, 30);	String test = "50 20 * * 5";	long next = CronParser.getNextScheduledTime(test, current.getTimeInMillis());	Calendar result = Calendar.getInstance();	result.setTimeInMillis(next);	
next 

result.setTimeInMillis(next);	assertEquals(0,result.get(Calendar.SECOND));	assertEquals(50,result.get(Calendar.MINUTE));	assertEquals(20,result.get(Calendar.HOUR_OF_DAY));	assertEquals(11,result.get(Calendar.DAY_OF_MONTH));	assertEquals(Calendar.FRIDAY,result.get(Calendar.DAY_OF_WEEK));	assertEquals(Calendar.MARCH,result.get(Calendar.MONTH));	assertEquals(2011,result.get(Calendar.YEAR));	current = Calendar.getInstance();	current.set(2011, Calendar.MARCH, 11, 22, 0, 30);	
update 

assertEquals(20,result.get(Calendar.HOUR_OF_DAY));	assertEquals(11,result.get(Calendar.DAY_OF_MONTH));	assertEquals(Calendar.FRIDAY,result.get(Calendar.DAY_OF_WEEK));	assertEquals(Calendar.MARCH,result.get(Calendar.MONTH));	assertEquals(2011,result.get(Calendar.YEAR));	current = Calendar.getInstance();	current.set(2011, Calendar.MARCH, 11, 22, 0, 30);	next = CronParser.getNextScheduledTime(test, current.getTimeInMillis());	result = Calendar.getInstance();	result.setTimeInMillis(next);	
next 

public void testgetNextTimeMonthVariant() throws MessageFormatException {	Calendar current = Calendar.getInstance();	current.set(2011, Calendar.MARCH, 7, 9, 15, 30);	
start 

public void testgetNextTimeMonthVariant() throws MessageFormatException {	Calendar current = Calendar.getInstance();	current.set(2011, Calendar.MARCH, 7, 9, 15, 30);	String test = "0 20 * 4,5 0";	long next = CronParser.getNextScheduledTime(test, current.getTimeInMillis());	Calendar result = Calendar.getInstance();	result.setTimeInMillis(next);	
next 

result.setTimeInMillis(next);	assertEquals(0,result.get(Calendar.SECOND));	assertEquals(0,result.get(Calendar.MINUTE));	assertEquals(20,result.get(Calendar.HOUR_OF_DAY));	assertEquals(Calendar.APRIL,result.get(Calendar.MONTH));	assertEquals(3,result.get(Calendar.DAY_OF_MONTH));	assertEquals(Calendar.SUNDAY,result.get(Calendar.DAY_OF_WEEK));	assertEquals(2011,result.get(Calendar.YEAR));	current = Calendar.getInstance();	current.set(2011, Calendar.APRIL, 30, 22, 0, 30);	
update 

assertEquals(20,result.get(Calendar.HOUR_OF_DAY));	assertEquals(Calendar.APRIL,result.get(Calendar.MONTH));	assertEquals(3,result.get(Calendar.DAY_OF_MONTH));	assertEquals(Calendar.SUNDAY,result.get(Calendar.DAY_OF_WEEK));	assertEquals(2011,result.get(Calendar.YEAR));	current = Calendar.getInstance();	current.set(2011, Calendar.APRIL, 30, 22, 0, 30);	next = CronParser.getNextScheduledTime(test, current.getTimeInMillis());	result = Calendar.getInstance();	result.setTimeInMillis(next);	
next 

result.setTimeInMillis(next);	assertEquals(0,result.get(Calendar.SECOND));	assertEquals(0,result.get(Calendar.MINUTE));	assertEquals(20,result.get(Calendar.HOUR_OF_DAY));	assertEquals(1,result.get(Calendar.DAY_OF_MONTH));	assertEquals(Calendar.SUNDAY,result.get(Calendar.DAY_OF_WEEK));	assertEquals(Calendar.MAY,result.get(Calendar.MONTH));	assertEquals(2011,result.get(Calendar.YEAR));	current = Calendar.getInstance();	current.set(2011, Calendar.MAY, 30, 22, 0, 30);	
update 

assertEquals(20,result.get(Calendar.HOUR_OF_DAY));	assertEquals(1,result.get(Calendar.DAY_OF_MONTH));	assertEquals(Calendar.SUNDAY,result.get(Calendar.DAY_OF_WEEK));	assertEquals(Calendar.MAY,result.get(Calendar.MONTH));	assertEquals(2011,result.get(Calendar.YEAR));	current = Calendar.getInstance();	current.set(2011, Calendar.MAY, 30, 22, 0, 30);	next = CronParser.getNextScheduledTime(test, current.getTimeInMillis());	result = Calendar.getInstance();	result.setTimeInMillis(next);	
next 

public void testgetNextTimeMonth() throws MessageFormatException {	Calendar current = Calendar.getInstance();	current.set(2010, Calendar.NOVEMBER, 15, 9, 15, 30);	
start 

public void testgetNextTimeMonth() throws MessageFormatException {	Calendar current = Calendar.getInstance();	current.set(2010, Calendar.NOVEMBER, 15, 9, 15, 30);	String test = "* * * 12 *";	long next = CronParser.getNextScheduledTime(test, current.getTimeInMillis());	Calendar result = Calendar.getInstance();	result.setTimeInMillis(next);	
next 

public void testgetStartNextMonth() throws MessageFormatException {	Calendar current = Calendar.getInstance();	current.set(2010, Calendar.DECEMBER, 15, 9, 15, 30);	
start 

public void testgetStartNextMonth() throws MessageFormatException {	Calendar current = Calendar.getInstance();	current.set(2010, Calendar.DECEMBER, 15, 9, 15, 30);	String test = "* * 1 * *";	long next = CronParser.getNextScheduledTime(test, current.getTimeInMillis());	Calendar result = Calendar.getInstance();	result.setTimeInMillis(next);	
next 

public void testgetNextStartCurrMonth() throws MessageFormatException {	Calendar current = Calendar.getInstance();	current.set(2010, Calendar.DECEMBER, 15, 9, 15, 30);	
start 

public void testgetNextStartCurrMonth() throws MessageFormatException {	Calendar current = Calendar.getInstance();	current.set(2010, Calendar.DECEMBER, 15, 9, 15, 30);	String test = "* * 1 12 *";	long next = CronParser.getNextScheduledTime(test, current.getTimeInMillis());	Calendar result = Calendar.getInstance();	result.setTimeInMillis(next);	
next 

public void testgetNextTimeDays() throws MessageFormatException {	Calendar current = Calendar.getInstance();	current.set(2010, Calendar.NOVEMBER, 15, 9, 15, 30);	
start 

public void testgetNextTimeDays() throws MessageFormatException {	Calendar current = Calendar.getInstance();	current.set(2010, Calendar.NOVEMBER, 15, 9, 15, 30);	String test = "* * 16 * *";	long next = CronParser.getNextScheduledTime(test, current.getTimeInMillis());	Calendar result = Calendar.getInstance();	result.setTimeInMillis(next);	
next 

public void testgetNextTimeMinutes() throws MessageFormatException {	String test = "30 * * * *";	long current = 20*60*1000;	Calendar calender = Calendar.getInstance();	calender.setTimeInMillis(current);	int startHours = calender.get(Calendar.HOUR_OF_DAY);	int startMinutes = calender.get(Calendar.MINUTE);	
start 

public void testgetNextTimeMinutes() throws MessageFormatException {	String test = "30 * * * *";	long current = 20*60*1000;	Calendar calender = Calendar.getInstance();	calender.setTimeInMillis(current);	int startHours = calender.get(Calendar.HOUR_OF_DAY);	int startMinutes = calender.get(Calendar.MINUTE);	long next = CronParser.getNextScheduledTime(test, current);	calender.setTimeInMillis(next);	
next 

========================= activemq sample_1 =========================

pMap.setDefaultEntry(policy);	broker.setDestinationPolicy(pMap);	broker.setPlugins(new BrokerPlugin[] {new BrokerPluginSupport() {	public void send(ProducerBrokerExchange producerExchange, final Message messageSend) throws Exception {	if (messageSend.isInTransaction() && messageSend.getProperty("NUM") != null) {	final Integer num = (Integer) messageSend.getProperty("NUM");	if (true) {	TransactionBroker transactionBroker = (TransactionBroker)broker.getBroker().getAdaptor(TransactionBroker.class);	transactionBroker.getTransaction(producerExchange.getConnectionContext(), messageSend.getTransactionId(), false).addSynchronization( new Synchronization() {	public void afterCommit() throws Exception {	
aftercommit num tx 

broker.setDestinationPolicy(pMap);	broker.setPlugins(new BrokerPlugin[] {new BrokerPluginSupport() {	public void send(ProducerBrokerExchange producerExchange, final Message messageSend) throws Exception {	if (messageSend.isInTransaction() && messageSend.getProperty("NUM") != null) {	final Integer num = (Integer) messageSend.getProperty("NUM");	if (true) {	TransactionBroker transactionBroker = (TransactionBroker)broker.getBroker().getAdaptor(TransactionBroker.class);	transactionBroker.getTransaction(producerExchange.getConnectionContext(), messageSend.getTransactionId(), false).addSynchronization( new Synchronization() {	public void afterCommit() throws Exception {	if (num == 5) {	
pausing on latch in aftercommit for 

broker.setPlugins(new BrokerPlugin[] {new BrokerPluginSupport() {	public void send(ProducerBrokerExchange producerExchange, final Message messageSend) throws Exception {	if (messageSend.isInTransaction() && messageSend.getProperty("NUM") != null) {	final Integer num = (Integer) messageSend.getProperty("NUM");	if (true) {	TransactionBroker transactionBroker = (TransactionBroker)broker.getBroker().getAdaptor(TransactionBroker.class);	transactionBroker.getTransaction(producerExchange.getConnectionContext(), messageSend.getTransactionId(), false).addSynchronization( new Synchronization() {	public void afterCommit() throws Exception {	if (num == 5) {	slowSendResume.await(20, TimeUnit.SECONDS);	
resuming on latch aftercommit for 

public void send(ProducerBrokerExchange producerExchange, final Message messageSend) throws Exception {	if (messageSend.isInTransaction() && messageSend.getProperty("NUM") != null) {	final Integer num = (Integer) messageSend.getProperty("NUM");	if (true) {	TransactionBroker transactionBroker = (TransactionBroker)broker.getBroker().getAdaptor(TransactionBroker.class);	transactionBroker.getTransaction(producerExchange.getConnectionContext(), messageSend.getTransactionId(), false).addSynchronization( new Synchronization() {	public void afterCommit() throws Exception {	if (num == 5) {	slowSendResume.await(20, TimeUnit.SECONDS);	} else if (messageCount + 1 == num) {	
releasing latch 

final Integer num = (Integer) messageSend.getProperty("NUM");	if (true) {	TransactionBroker transactionBroker = (TransactionBroker)broker.getBroker().getAdaptor(TransactionBroker.class);	transactionBroker.getTransaction(producerExchange.getConnectionContext(), messageSend.getTransactionId(), false).addSynchronization( new Synchronization() {	public void afterCommit() throws Exception {	if (num == 5) {	slowSendResume.await(20, TimeUnit.SECONDS);	} else if (messageCount + 1 == num) {	slowSendResume.countDown();	TimeUnit.SECONDS.sleep(5);	
resuming aftercommit for 

} catch (Exception fail) {	exceptions.add(fail);	}	}	});	}	final DestinationViewMBean queueViewMBean = (DestinationViewMBean) broker.getManagementContext().newProxyInstance(broker.getAdminView().getQueues()[0], DestinationViewMBean.class, false);	TimeUnit.SECONDS.sleep(3);	if (false) assertTrue("all " + messageCount + " on the q", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
enqueuecount 

}	});	}	final DestinationViewMBean queueViewMBean = (DestinationViewMBean) broker.getManagementContext().newProxyInstance(broker.getAdminView().getQueues()[0], DestinationViewMBean.class, false);	TimeUnit.SECONDS.sleep(3);	if (false) assertTrue("all " + messageCount + " on the q", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return messageCount == queueViewMBean.getEnqueueCount();	}	}));	
big send to blow available destination usage before slow send resumes 

private Session send(int id, int messageSize, boolean transacted) throws Exception {	Connection connection = factory.createConnection();	connection.start();	Session session = connection.createSession(transacted, transacted ? Session.SESSION_TRANSACTED : Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	BytesMessage bytesMessage = session.createBytesMessage();	bytesMessage.writeBytes(new byte[messageSize]);	bytesMessage.setIntProperty("NUM", id);	producer.send(bytesMessage);	
sent session tx 

========================= activemq sample_2897 =========================

Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setTimeToLive(0);	connection.start();	for (int i = 0; i < count; i++) {	int id = i + 1;	TextMessage message = session.createTextMessage("Message " + id);	message.setIntProperty("MsgNumber", id);	producer.send(message);	if (id % 500 == 0) {	
sent ith 

========================= activemq sample_2878 =========================

protected void assertBinding(Binding binding) throws NamingException {	Object object = binding.getObject();	assertTrue("Should have got a child context but got: " + object, object instanceof Context);	Context childContext = (Context) object;	NamingEnumeration<Binding> iter = childContext.listBindings("");	while (iter.hasMore()) {	Binding destinationBinding = iter.next();	
found destination 

========================= activemq sample_3013 =========================

public void commit(boolean onePhase) throws XAException, IOException {	if (LOG.isDebugEnabled()) {	
commit synccount 

public void commit(boolean onePhase) throws XAException, IOException {	if (LOG.isDebugEnabled()) {	}	try {	prePrepare();	} catch (XAException e) {	throw e;	} catch (Throwable e) {	
commit failed 

xae.errorCode = XAException.XA_RBOTHER;	xae.initCause(e);	throw xae;	}	setState(Transaction.FINISHED_STATE);	context.getTransactions().remove(xid);	try {	transactionStore.commit(getTransactionId(), false, preCommitTask, postCommitTask);	this.waitPostCommitDone(postCommitTask);	} catch (Throwable t) {	
store commit failed 

public void rollback() throws XAException, IOException {	if (LOG.isDebugEnabled()) {	
rollback synccount 

public void rollback() throws XAException, IOException {	if (LOG.isDebugEnabled()) {	}	setState(Transaction.FINISHED_STATE);	context.getTransactions().remove(xid);	transactionStore.rollback(getTransactionId());	try {	fireAfterRollback();	} catch (Throwable e) {	
post rollback failed 

========================= activemq sample_3855 =========================

final String brokerConfig =  "namespace-prefix";	System.setProperty("data", IOHelper.getDefaultDataDirectory());	System.setProperty("broker-name", brokerConfig);	startBroker(brokerConfig);	assertTrue("broker alive", brokerService.isStarted());	assertEquals("nameMatch", brokerConfig, brokerService.getBrokerName());	ObjectName objectName = new ObjectName(brokerService.getBrokerObjectName().toString() + RuntimeConfigurationBroker.objectNamePropsAppendage);	RuntimeConfigurationViewMBean runtimeConfigurationView = (RuntimeConfigurationViewMBean) brokerService.getManagementContext().newProxyInstance(objectName, RuntimeConfigurationViewMBean.class, false);	HashMap<String, String> props = new HashMap<String, String>();	IntrospectionSupport.getProperties(runtimeConfigurationView, props, null);	
mbean attributes before 

========================= activemq sample_4369 =========================

assertEquals("should have only one inactiveSubscriber subscribed", 1, broker.getAdminView().getInactiveDurableTopicSubscribers().length);	assertEquals("should be no subscribers subscribed", 0, broker.getAdminView().getDurableTopicSubscribers().length);	final KahaDBPersistenceAdapter pa = (KahaDBPersistenceAdapter) broker.getPersistenceAdapter();	assertTrue("should be less than 3 journal file left but was: " + persistenceAdapter.getStore().getJournal().getFileMap().size(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return pa.getStore().getJournal().getFileMap().size() <= 3;	}	}, TimeUnit.MINUTES.toMillis(3)));	this.houseKeeper.shutdown();	assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());	
done 

private void printDebugClientInfo(ObjectName[] subscribers, ObjectName[] inactiveSubscribers, final KahaDBPersistenceAdapter pa) throws IOException {	LOG.info("====>>> START DEBUG Subscriber INFO");	
number of subscribers subscribed as seen through jmx is 

private void printDebugClientInfo(ObjectName[] subscribers, ObjectName[] inactiveSubscribers, final KahaDBPersistenceAdapter pa) throws IOException {	LOG.info("====>>> START DEBUG Subscriber INFO");	for (int i = 0; i < subscribers.length; i++) {	
subscribers subscribed as seen throngh jmx 

private void printDebugClientInfo(ObjectName[] subscribers, ObjectName[] inactiveSubscribers, final KahaDBPersistenceAdapter pa) throws IOException {	LOG.info("====>>> START DEBUG Subscriber INFO");	for (int i = 0; i < subscribers.length; i++) {	}	
number of inactivesubscribers subscribed as seen through jmx is 

private void printDebugClientInfo(ObjectName[] subscribers, ObjectName[] inactiveSubscribers, final KahaDBPersistenceAdapter pa) throws IOException {	LOG.info("====>>> START DEBUG Subscriber INFO");	for (int i = 0; i < subscribers.length; i++) {	}	for (int i = 0; i < inactiveSubscribers.length; i++) {	
subscribers subscribed as seen throngh jmx 

private void printDebugClientInfo(ObjectName[] subscribers, ObjectName[] inactiveSubscribers, final KahaDBPersistenceAdapter pa) throws IOException {	LOG.info("====>>> START DEBUG Subscriber INFO");	for (int i = 0; i < subscribers.length; i++) {	}	for (int i = 0; i < inactiveSubscribers.length; i++) {	}	
clientmanager clients size is 

private void printDebugClientInfo(ObjectName[] subscribers, ObjectName[] inactiveSubscribers, final KahaDBPersistenceAdapter pa) throws IOException {	LOG.info("====>>> START DEBUG Subscriber INFO");	for (int i = 0; i < subscribers.length; i++) {	}	for (int i = 0; i < inactiveSubscribers.length; i++) {	}	for (int i = 0; i < clientManager.clients.size(); i++) {	
clients is 

private void printDebugClientInfo(ObjectName[] subscribers, ObjectName[] inactiveSubscribers, final KahaDBPersistenceAdapter pa) throws IOException {	LOG.info("====>>> START DEBUG Subscriber INFO");	for (int i = 0; i < subscribers.length; i++) {	}	for (int i = 0; i < inactiveSubscribers.length; i++) {	}	for (int i = 0; i < clientManager.clients.size(); i++) {	}	
housekeep subscriptions size is 

private void printDebugClientInfo(ObjectName[] subscribers, ObjectName[] inactiveSubscribers, final KahaDBPersistenceAdapter pa) throws IOException {	LOG.info("====>>> START DEBUG Subscriber INFO");	for (int i = 0; i < subscribers.length; i++) {	}	for (int i = 0; i < inactiveSubscribers.length; i++) {	}	for (int i = 0; i < clientManager.clients.size(); i++) {	}	for (int i = 0; i < houseKeeper.abandonedSubscriptions.size(); i++) {	
housekeep is 

private void printDebugClientInfo(ObjectName[] subscribers, ObjectName[] inactiveSubscribers, final KahaDBPersistenceAdapter pa) throws IOException {	LOG.info("====>>> START DEBUG Subscriber INFO");	for (int i = 0; i < subscribers.length; i++) {	}	for (int i = 0; i < inactiveSubscribers.length; i++) {	}	for (int i = 0; i < clientManager.clients.size(); i++) {	}	for (int i = 0; i < houseKeeper.abandonedSubscriptions.size(); i++) {	}	
number of journal files left 

private void createNewClient() throws JMSException {	ClientType type = ClientType.randomClientType();	Client client;	synchronized (server.sendMutex) {	client = new Client(++clientRover, type);	clients.add(client);	}	client.start();	
created 

try {	process(online);	} finally {	processLock.readLock().unlock();	}	}	if (!ALLOW_SUBSCRIPTION_ABANDONMENT) {	unsubscribe();	ALLOW_SUBSCRIPTION_ABANDONMENT = true;	} else {	
client abandon the subscription 

unsubscribe();	ALLOW_SUBSCRIPTION_ABANDONMENT = true;	} else {	houseKeeper.abandonedSubscriptions.add(conClientId);	ALLOW_SUBSCRIPTION_ABANDONMENT = false;	}	} catch (Throwable e) {	exit(toString() + " failed.", e);	}	clientManager.removeClient(this);	
done 

private void process(long processingTime) throws JMSException {	long end = System.currentTimeMillis() + processingTime;	long hardEnd = end + 20000;	boolean inTransaction = false;	int transCount = 0;	
online 

inTransaction = false;	transCount = 0;	} else {	inTransaction = true;	transCount++;	}	} while (true);	} finally {	sess.close();	con.close();	
offline 

private void sweep() throws Exception {	
housekeeper sweeping 

private void sweep() throws Exception {	int closed = 0;	ArrayList<String> sweeped = new ArrayList<String>();	try {	for (String clientId : abandonedSubscriptions) {	
sweeping out subscription of 

private void sweep() throws Exception {	int closed = 0;	ArrayList<String> sweeped = new ArrayList<String>();	try {	for (String clientId : abandonedSubscriptions) {	broker.getAdminView().destroyDurableSubscriber(clientId, Client.SUBSCRIPTION_NAME);	sweeped.add(clientId);	closed++;	}	} catch (Exception ignored) {	
ex on destroy sub 

try {	for (String clientId : abandonedSubscriptions) {	broker.getAdminView().destroyDurableSubscriber(clientId, Client.SUBSCRIPTION_NAME);	sweeped.add(clientId);	closed++;	}	} catch (Exception ignored) {	} finally {	abandonedSubscriptions.removeAll(sweeped);	}	
housekeeper sweeped out subscriptions 

========================= activemq sample_3639 =========================

private void assertNoUnhandeledExceptions() {	for( Entry<Thread, Throwable> e: unhandeledExceptions.entrySet()) {	
thread had unexpected 

Destination dest = createDestination("TEST.FOO", false);	sendMessages("Broker0", dest, 1);	for (int i=0; i< BROKER_COUNT; i++) {	MessageConsumer messageConsumer = createConsumer("Broker" + i, dest, "DoNotConsume = 'true'");	for (int J = 0; J < BROKER_COUNT; J++) {	assertExactConsumersConnect("Broker" + J, dest, CONSUMER_COUNT, TIMEOUT);	}	assertNoUnhandeledExceptions();	assertExactMessageCount("Broker" + i, dest, 1, TIMEOUT);	messageConsumer.close();	
check for no consumers 

Destination dest = createDestination("TEST.FOO", false);	sendMessages("Broker0", dest, 1);	for (int i=0; i< BROKER_COUNT; i++) {	MessageConsumer messageConsumer = createConsumer("Broker" + i, dest, "DoNotConsume = 'true'");	for (int J = 0; J < BROKER_COUNT; J++) {	assertExactConsumersConnect("Broker" + J, dest, CONSUMER_COUNT, TIMEOUT);	}	assertNoUnhandeledExceptions();	assertExactMessageCount("Broker" + i, dest, 1, TIMEOUT);	messageConsumer.close();	
check for no consumers 

for (int J = 0; J < BROKER_COUNT; J++) {	assertExactConsumersConnect("Broker" + J, dest, CONSUMER_COUNT, TIMEOUT);	}	assertNoUnhandeledExceptions();	assertExactMessageCount("Broker" + i, dest, 1, TIMEOUT);	messageConsumer.close();	for (int J = 0; J < BROKER_COUNT; J++) {	assertExactConsumersConnect("Broker" + J, dest, 0, TIMEOUT);	}	}	
consume from origin 

protected void assertExactMessageCount(final String brokerName, Destination destination, final int count, long timeout) throws Exception {	ManagementContext context = brokers.get(brokerName).broker.getManagementContext();	final QueueViewMBean queueViewMBean = (QueueViewMBean) context.newProxyInstance(brokers.get(brokerName).broker.getAdminView().getQueues()[0], QueueViewMBean.class, false);	assertTrue("Excepected queue depth: " + count + " on: " + brokerName, Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	long currentCount = queueViewMBean.getQueueSize();	
on current queue size for 

protected void assertExactMessageCount(final String brokerName, Destination destination, final int count, long timeout) throws Exception {	ManagementContext context = brokers.get(brokerName).broker.getManagementContext();	final QueueViewMBean queueViewMBean = (QueueViewMBean) context.newProxyInstance(brokers.get(brokerName).broker.getAdminView().getQueues()[0], QueueViewMBean.class, false);	assertTrue("Excepected queue depth: " + count + " on: " + brokerName, Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	long currentCount = queueViewMBean.getQueueSize();	if (count != currentCount) {	
sub ids 

protected void assertExactConsumersConnect(final String brokerName, Destination destination, final int count, long timeout) throws Exception {	final ManagementContext context = brokers.get(brokerName).broker.getManagementContext();	assertTrue("Excepected consumers count: " + count + " on: " + brokerName, Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	try {	QueueViewMBean queueViewMBean = (QueueViewMBean) context.newProxyInstance(brokers.get(brokerName).broker.getAdminView().getQueues()[0], QueueViewMBean.class, false);	long currentCount = queueViewMBean.getConsumerCount();	
on current consumer count for 

protected void assertExactConsumersConnect(final String brokerName, Destination destination, final int count, long timeout) throws Exception {	final ManagementContext context = brokers.get(brokerName).broker.getManagementContext();	assertTrue("Excepected consumers count: " + count + " on: " + brokerName, Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	try {	QueueViewMBean queueViewMBean = (QueueViewMBean) context.newProxyInstance(brokers.get(brokerName).broker.getAdminView().getQueues()[0], QueueViewMBean.class, false);	long currentCount = queueViewMBean.getConsumerCount();	if (count != currentCount) {	
sub ids 

final ManagementContext context = brokers.get(brokerName).broker.getManagementContext();	assertTrue("Excepected consumers count: " + count + " on: " + brokerName, Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	try {	QueueViewMBean queueViewMBean = (QueueViewMBean) context.newProxyInstance(brokers.get(brokerName).broker.getAdminView().getQueues()[0], QueueViewMBean.class, false);	long currentCount = queueViewMBean.getConsumerCount();	if (count != currentCount) {	}	return currentCount == count;	} catch (Exception e) {	
unexpected 

========================= activemq sample_2881 =========================

TransportConnector tcp = broker.addConnector("tcp: String group = "GR-" +  System.currentTimeMillis();	URI discoveryUri = new URI("multicast: tcp.setDiscoveryUri(discoveryUri);	broker.start();	broker.waitUntilStarted();	Vector<String> existingNames = new Vector<String>();	Thread[] threads = getThreads();	for (Thread t : threads) {	existingNames.add(t.getName());	}	final int idleThreadCount = threads.length;	
broker started thread count 

for (int i=0; i<10;i++) {	ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("discovery:(multicast: LOG.info("Connecting.");	Connection connection = factory.createConnection();	connection.setClientID("test");	connection.close();	}	Thread.sleep(2000);	threads = getThreads();	for (Thread t : threads) {	if (!existingNames.contains(t.getName())) {	
remaining thread 

public void testInitialConnectDelayWithNoBroker() throws Exception {	long initialReconnectDelay = 4000;	long startT = System.currentTimeMillis();	String groupId = "WillNotMatch" + startT;	try {	String urlStr = "discovery:(multicast: ")?useExponentialBackOff=false&maxReconnectAttempts=2&reconnectDelay=" + initialReconnectDelay;	ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(urlStr);	
connecting 

========================= activemq sample_2497 =========================

BTreeIndex<Long, String> test = new BTreeIndex<Long, String>(pf, id);	test.setKeyMarshaller(LongMarshaller.INSTANCE);	test.setValueMarshaller(StringMarshaller.INSTANCE);	test.load(tx);	tx.commit();	final int count = 5000;	final int reps = 2;	final long[] diffs = new long[reps];	long keyVal = 0;	final String payload = new String(new byte[50]);	
pf diff pc f 

test.put(tx, keyVal++, payload);	tx.commit();	}	tx = pf.tx();	for (long k = keyVal - count; k < keyVal; k++) {	test.remove(tx, k);	}	test.clear(tx);	tx.commit();	diffs[i] = pf.getPageCount() - pf.getFreePageCount();	
pf diff pc f 

pf.load();	tx = pf.tx();	long id = tx.allocate().getPageId();	ListIndex<String, String> test = new ListIndex<String, String>(pf, id);	test.setKeyMarshaller(StringMarshaller.INSTANCE);	test.setValueMarshaller(StringMarshaller.INSTANCE);	test.load(tx);	tx.commit();	int expectedListEntries = 0;	int nextSequenceId = 0;	
loading up the listindex with entires and sparsely populating the sequences 

sequenceSet.concat(String.valueOf(nextSequenceId++));	test.put(tx, String.valueOf(j), sequenceSet);	}	sequenceSet = test.get(tx, String.valueOf(j));	for (int ix = 0; ix < NUM_ITERATIONS - 1; ix++) {	test.put(tx, String.valueOf(j), String.valueOf(j));	}	}	}	exerciseAnotherIndex(tx);	
checking if index has the expected number of entries 

for (int ix = 0; ix < NUM_ITERATIONS - 1; ix++) {	test.put(tx, String.valueOf(j), String.valueOf(j));	}	}	}	exerciseAnotherIndex(tx);	for (int i = 0; i < NUM_ITERATIONS; ++i) {	assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));	}	
index has the expected number of entries 

}	}	}	exerciseAnotherIndex(tx);	for (int i = 0; i < NUM_ITERATIONS; ++i) {	assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));	}	assertEquals(expectedListEntries, test.size());	for (int i = 0; i < NUM_ITERATIONS; ++i) {	
size of listindex before removal of entry is 

}	exerciseAnotherIndex(tx);	for (int i = 0; i < NUM_ITERATIONS; ++i) {	assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));	}	assertEquals(expectedListEntries, test.size());	for (int i = 0; i < NUM_ITERATIONS; ++i) {	assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));	assertNotNull("List contents of Key["+i+"] should not be null", test.remove(tx, String.valueOf(i)));	
size of listindex after removal of entry is 

========================= activemq sample_1741 =========================

if (setter == null) {	return false;	}	if (value == null || value.getClass() == setter.getParameterTypes()[0]) {	setter.invoke(target, value);	} else {	setter.invoke(target, convert(value, setter.getParameterTypes()[0]));	}	return true;	} catch (Exception e) {	
could not set property s on s 

========================= activemq sample_1311 =========================

public synchronized void purge() throws Exception {	final long originalMessageCount = destination.getDestinationStatistics().getMessages().getCount();	((Queue)destination).purge();	
purge of messages 

========================= activemq sample_3906 =========================

public void testCreateTemporaryQueueThenCreateAQueueFromItsName() throws Exception {	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue tempQueue = session.createTemporaryQueue();	String name = tempQueue.getQueueName();	
created queue named 

public void testCreateTemporaryTopicThenCreateATopicFromItsName() throws Exception {	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Topic tempTopic = session.createTemporaryTopic();	String name = tempTopic.getTopicName();	
created topic named 

========================= activemq sample_2614 =========================

public synchronized void onMessageAvailable(MessageConsumer consumer) {	
message for consumer continuation 

public synchronized void onMessageAvailable(MessageConsumer consumer) {	if (continuation != null) {	try {	Message message = consumer.receive(10);	
message is 

public synchronized void onMessageAvailable(MessageConsumer consumer) {	if (continuation != null) {	try {	Message message = consumer.receive(10);	if (message != null) {	if (!continuation.isResumed()) {	
resuming suspended continuation 

public synchronized void onMessageAvailable(MessageConsumer consumer) {	if (continuation != null) {	try {	Message message = consumer.receive(10);	if (message != null) {	if (!continuation.isResumed()) {	continuation.setAttribute("undelivered_message", new UndeliveredAjaxMessage(message, consumer));	continuation.resume();	} else {	
message available but continuation is already resumed buffer for next time 

Message message = consumer.receive(10);	if (message != null) {	if (!continuation.isResumed()) {	continuation.setAttribute("undelivered_message", new UndeliveredAjaxMessage(message, consumer));	continuation.resume();	} else {	bufferMessageForDelivery(message, consumer);	}	}	} catch (Exception e) {	
error receiving message this exception is ignored 

continuation.resume();	} else {	bufferMessageForDelivery(message, consumer);	}	}	} catch (Exception e) {	}	} else if (System.currentTimeMillis() - lastAccess > 2 * this.maximumReadTimeout) {	new Thread() {	public void run() {	
closing consumers on client 

new Thread() {	public void run() {	client.closeConsumers();	}	}.start();	} else {	try {	Message message = consumer.receive(10);	bufferMessageForDelivery(message, consumer);	} catch (Exception e) {	
error receiving message this exception is ignored 

========================= activemq sample_1038 =========================

protected <T> T fromDto(Object dto, T instance) {	Properties properties = new Properties();	IntrospectionSupport.getProperties(dto, properties, null);	plugin.placeHolderUtil.filter(properties);	
applying props to 

========================= activemq sample_4390 =========================

public void testConsume() throws Exception {	int port = getPort();	producer.send(session.createTextMessage("test"));	
message sent 

public void testSubscribeFirst() throws Exception {	int port = getPort();	HttpClient httpClient = new HttpClient();	httpClient.start();	final StringBuffer buf = new StringBuffer();	final CountDownLatch latch = asyncRequest(httpClient, "http: producer.send(session.createTextMessage("test"));	
message sent 

public void testSelector() throws Exception {	int port = getPort();	TextMessage msg1 = session.createTextMessage("test1");	msg1.setIntProperty("test", 1);	producer.send(msg1);	
message sent 

public void testSelector() throws Exception {	int port = getPort();	TextMessage msg1 = session.createTextMessage("test1");	msg1.setIntProperty("test", 1);	producer.send(msg1);	TextMessage msg2 = session.createTextMessage("test2");	msg2.setIntProperty("test", 2);	producer.send(msg2);	
message sent 

public void testCorrelation() throws Exception {	int port = getPort();	HttpClient httpClient = new HttpClient();	httpClient.start();	for (int i = 0; i < 200; i++) {	String correlId = "RESTY" + RandomStringUtils.randomNumeric(10);	TextMessage message = session.createTextMessage(correlId);	message.setStringProperty("correlationId", correlId);	message.setJMSCorrelationID(correlId);	
sending 

HttpClient httpClient = new HttpClient();	httpClient.start();	for (int i = 0; i < 200; i++) {	String correlId = "RESTY" + RandomStringUtils.randomNumeric(10);	TextMessage message = session.createTextMessage(correlId);	message.setStringProperty("correlationId", correlId);	message.setJMSCorrelationID(correlId);	producer.send(message);	final StringBuffer buf = new StringBuffer();	final CountDownLatch latch = asyncRequest(httpClient, "http: latch.await();	
received 

public void testDisconnect() throws Exception {	int port = getPort();	producer.send(session.createTextMessage("test"));	HttpClient httpClient = new HttpClient();	httpClient.start();	final StringBuffer buf = new StringBuffer();	final CountDownLatch latch = asyncRequest(httpClient, "http: latch.await();	
received 

========================= activemq sample_919 =========================

protected BrokerService createBroker(String uri) throws Exception {	
loading broker configuration from the classpath with uri 

========================= activemq sample_2751 =========================

brokerService.setSchedulerSupport(false);	Broker broker = new ErrorBroker("hi") {	public BrokerService getBrokerService() {	return brokerService;	}	};	try {	underTest.installPlugin(broker);	fail("expect exception on no scheduler support");	} catch (Exception expected) {	
expected 

try {	underTest.installPlugin(broker);	fail("expect exception on no scheduler support");	} catch (Exception expected) {	}	brokerService.setSchedulerSupport(true);	try {	underTest.installPlugin(broker);	fail("expect exception on small initial delay");	} catch (Exception expected) {	
expected 

fail("expect exception on small initial delay");	} catch (Exception expected) {	}	defaultEntry.setInitialRedeliveryDelay(5000);	defaultEntry.setRedeliveryDelay(500);	brokerService.setSchedulerSupport(true);	try {	underTest.installPlugin(broker);	fail("expect exception on small redelivery delay");	} catch (Exception expected) {	
expected 

========================= activemq sample_2301 =========================

private void doSend(AmqpMessage message, AsyncResult request, AmqpTransactionId txId) throws Exception {	
producer sending message 

}	int sentSoFar = 0;	while (true) {	int sent = getEndpoint().send(encodeBuffer, sentSoFar, encodedSize - sentSoFar);	if (sent > 0) {	sentSoFar += sent;	if ((encodedSize - sentSoFar) == 0) {	break;	}	} else {	
failed to send any data from current message 

public void processDeliveryUpdates(AmqpConnection connection) throws IOException {	List<Delivery> toRemove = new ArrayList<>();	for (Delivery delivery : pending) {	DeliveryState state = delivery.getRemoteState();	if (state == null) {	continue;	}	doDeliveryUpdateInspection(delivery);	Outcome outcome = null;	if (state instanceof TransactionalState) {	
state of delivery is transactional retrieving outcome 

if (state == null) {	continue;	}	doDeliveryUpdateInspection(delivery);	Outcome outcome = null;	if (state instanceof TransactionalState) {	outcome = ((TransactionalState) state).getOutcome();	} else if (state instanceof Outcome) {	outcome = (Outcome) state;	} else {	
message send updated with unsupported state 

if (state instanceof TransactionalState) {	outcome = ((TransactionalState) state).getOutcome();	} else if (state instanceof Outcome) {	outcome = (Outcome) state;	} else {	outcome = null;	}	AsyncResult request = (AsyncResult) delivery.getContext();	Exception deliveryError = null;	if (outcome instanceof Accepted) {	
outcome of delivery was accepted 

} else {	outcome = null;	}	AsyncResult request = (AsyncResult) delivery.getContext();	Exception deliveryError = null;	if (outcome instanceof Accepted) {	if (request != null && !request.isComplete()) {	request.onSuccess();	}	} else if (outcome instanceof Rejected) {	
outcome of delivery was rejected 

if (request != null && !request.isComplete()) {	request.onSuccess();	}	} else if (outcome instanceof Rejected) {	ErrorCondition remoteError = ((Rejected) outcome).getError();	if (remoteError == null) {	remoteError = getEndpoint().getRemoteCondition();	}	deliveryError = AmqpSupport.convertToException(remoteError);	} else if (outcome instanceof Released) {	
outcome of delivery was released 

}	} else if (outcome instanceof Rejected) {	ErrorCondition remoteError = ((Rejected) outcome).getError();	if (remoteError == null) {	remoteError = getEndpoint().getRemoteCondition();	}	deliveryError = AmqpSupport.convertToException(remoteError);	} else if (outcome instanceof Released) {	deliveryError = new IOException("Delivery failed: released by receiver");	} else if (outcome instanceof Modified) {	
outcome of delivery was modified 

========================= activemq sample_1653 =========================

now = end - now;	now = now < BROKER_RESTART ? now : BROKER_RESTART;	Thread.sleep(now);	restartBroker();	}	} catch (Throwable e) {	exit("ProcessTest.testProcess failed.", e);	}	processLock.writeLock().lock();	assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());	
done 

private void restartBroker() throws Exception {	
broker restart waiting for components 

private void restartBroker() throws Exception {	processLock.writeLock().lock();	try {	destroyBroker();	startBroker(false);	restartCount++;	
broker restarted count 

private void createNewClient() throws JMSException {	ClientType type = ClientType.randomClientType();	Client client;	synchronized (server.sendMutex) {	client = new Client(++clientRover, type, CLIENT_LIFETIME, CLIENT_ONLINE, CLIENT_OFFLINE);	clients.add(client);	}	client.start();	
created 

else sleep = true;	processLock.readLock().lock();	try {	process(online.next());	} finally {	processLock.readLock().unlock();	}	}	if (!ALLOW_SUBSCRIPTION_ABANDONMENT || random(1) > 0) unsubscribe();	else {	
client abandon the subscription 

}	}	if (!ALLOW_SUBSCRIPTION_ABANDONMENT || random(1) > 0) unsubscribe();	else {	houseKeeper.abandonedSubscriptions.add(conClientId);	}	} catch (Throwable e) {	exit(toString() + " failed.", e);	}	clientManager.removeClient(this);	
done 

private void process(long millis) throws JMSException {	long end = System.currentTimeMillis() + millis;	long hardEnd = end + 20000;	boolean inTransaction = false;	int transCount = 0;	
online 

inTransaction = false;	transCount = 0;	} else {	inTransaction = true;	transCount++;	}	} while (true);	} finally {	sess.close();	con.close();	
offline 

private void sweep() throws Exception {	
housekeeper sweeping 

private void sweep() throws Exception {	int closed = 0;	ArrayList<String> sweeped = new ArrayList<String>();	try {	for (String clientId : abandonedSubscriptions) {	
sweeping out subscription of 

private void sweep() throws Exception {	int closed = 0;	ArrayList<String> sweeped = new ArrayList<String>();	try {	for (String clientId : abandonedSubscriptions) {	broker.getAdminView().destroyDurableSubscriber(clientId, Client.SUBSCRIPTION_NAME);	sweeped.add(clientId);	closed++;	}	} catch (Exception ignored) {	
ex on destroy sub 

try {	for (String clientId : abandonedSubscriptions) {	broker.getAdminView().destroyDurableSubscriber(clientId, Client.SUBSCRIPTION_NAME);	sweeped.add(clientId);	closed++;	}	} catch (Exception ignored) {	} finally {	abandonedSubscriptions.removeAll(sweeped);	}	
housekeeper sweeped out subscriptions 

========================= activemq sample_3681 =========================

ArrayList<Consumer> fixedConsumers = new ArrayList<Consumer>(100);	for (int i = 0; i < 200; ++i) {	fixedConsumers.add(new Consumer());	}	final int fixedDelayConsumers = 300;	final int fixedDelayCycles = 25;	final CountDownLatch fixedDelayCycleLatch = new CountDownLatch(fixedDelayCycles);	cycleDoneLatch = fixedDelayCycleLatch;	CyclicBarrier barrier = new CyclicBarrier(fixedDelayConsumers, new Runnable() {	public void run() {	
fixed delay consumers cycle completed 

ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, j, destination);	testObj.addConsumer(connectionContext, consumerInfo);	}	for (int j = 1; j <= 500; j++) {	ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, j, destination);	testObj.removeConsumer(connectionContext, consumerInfo);	}	}	long finish = System.currentTimeMillis();	long totalTime = finish - start;	
total test time seconds 

========================= activemq sample_2839 =========================

private void fireEvent(final int oldPercentUsage, final int newPercentUsage) {	if (debug) {	
usage change from of available memory to of available memory 

Runnable listenerNotifier = new Runnable() {	public void run() {	for (UsageListener listener : listeners) {	listener.onUsageChanged(Usage.this, oldPercentUsage, newPercentUsage);	}	}	};	if (started.get()) {	getExecutor().execute(listenerNotifier);	} else {	
not notifying memory usage change to listeners on shutdown 

========================= activemq sample_221 =========================

public void testFailedSSLConnectionAttemptsDoesNotBreakTransport() throws Exception {	for (int i = 0; i < MAX_CONNECTIONS; ++i) {	try {	createFailingConnection();	fail("Should not be able to connect.");	} catch (Exception ex) {	
connection failed as expected 

createFailingConnection();	fail("Should not be able to connect.");	} catch (Exception ex) {	}	}	for (int i = 0; i < MAX_CONNECTIONS; ++i) {	try {	createNonSslConnection().start();;	fail("Should not be able to connect.");	} catch (Exception ex) {	
connection failed as expected 

for (int i = 0; i < MAX_CONNECTIONS; ++i) {	try {	createNonSslConnection().start();;	fail("Should not be able to connect.");	} catch (Exception ex) {	}	}	for (int i = 0; i < MAX_CONNECTIONS; ++i) {	try {	createGoodConnection();	
connection created as expected 

========================= activemq sample_1595 =========================

handleSocket(sc.socket());	}	}	}	} catch (SocketTimeoutException ste) {	} catch (Exception e) {	e.printStackTrace();	if (!isStopping()) {	onAcceptError(e);	} else if (!isStopped()) {	
run 

}	}	}	i.remove();	}	}	} catch (IOException ex) {	if (!isStopping()) {	onAcceptError(ex);	} else if (!isStopped()) {	
run 

} else {	handleSocket(socket);	}	}	}	} catch (SocketTimeoutException ste) {	} catch (Exception e) {	if (!isStopping()) {	onAcceptError(e);	} else if (!isStopped()) {	
run 

try {	while (!isStopped() && !isStopping()) {	Socket sock = socketQueue.poll(1, TimeUnit.SECONDS);	if (sock != null) {	try {	handleSocket(sock);	} catch (Throwable thrown) {	if (!isStopping()) {	onAcceptError(new Exception(thrown));	} else if (!isStopped()) {	
unexpected error thrown during accept handling 

if (!isStopping()) {	onAcceptError(new Exception(thrown));	} else if (!isStopped()) {	onAcceptError(new Exception(thrown));	}	}	}	}	} catch (InterruptedException e) {	if (!isStopped() || !isStopping()) {	
socketqueue interrupted stopping 

========================= activemq sample_108 =========================

startBrokers();	openConnections();	Thread.sleep(1000);	log.info("\n\n==============================================\nsend hello1\n");	debugTransportFilter.closeOnResponse = true;	producer.send(remoteSession.createTextMessage("hello1"));	Message msg = consumer.receive(30000);	assertNotNull("expected hello1", msg);	assertEquals("hello1", ((TextMessage) msg).getText());	Thread.sleep(1000);	
send 

Message msg = consumer.receive(30000);	assertNotNull("expected hello1", msg);	assertEquals("hello1", ((TextMessage) msg).getText());	Thread.sleep(1000);	producer.send(remoteSession.createTextMessage("hello2"));	msg = consumer.receive(30000);	assertNotNull("expected hello2", msg);	assertEquals("hello2", ((TextMessage) msg).getText());	closeLocalConnection();	Thread.sleep(1000);	
send 

public void oneway(Object command) throws IOException {	if (closeOnResponse && command instanceof Response) {	closeOnResponse = false;	
closing connection before response is sent 

public void oneway(Object command) throws IOException {	if (closeOnResponse && command instanceof Response) {	closeOnResponse = false;	try {	((NIOTransport) next).stop();	} catch (Exception ex) {	
couldn t stop niotransport 

========================= activemq sample_2706 =========================

protected MemoryMessageStore asMemoryMessageStore(Object value) {	if (value instanceof MemoryMessageStore) {	return (MemoryMessageStore) value;	}	if (value instanceof ProxyMessageStore) {	MessageStore delegate = ((ProxyMessageStore) value).getDelegate();	if (delegate instanceof MemoryMessageStore) {	return (MemoryMessageStore) delegate;	}	}	
expected an instance of memorymessagestore but was 

========================= activemq sample_4282 =========================

count = extractProducerCountFromMessage(message, count);	fireProducerEvent(new ProducerStartedEvent(this, destination, (ProducerInfo)command, count));	} else if (command instanceof RemoveInfo) {	RemoveInfo removeInfo = (RemoveInfo)command;	if (removeInfo.isProducerRemove()) {	count = producerCount.decrementAndGet();	count = extractProducerCountFromMessage(message, count);	fireProducerEvent(new ProducerStoppedEvent(this, destination, (ProducerId)removeInfo.getObjectId(), count));	}	} else {	
unknown command 

} else if (command instanceof RemoveInfo) {	RemoveInfo removeInfo = (RemoveInfo)command;	if (removeInfo.isProducerRemove()) {	count = producerCount.decrementAndGet();	count = extractProducerCountFromMessage(message, count);	fireProducerEvent(new ProducerStoppedEvent(this, destination, (ProducerId)removeInfo.getObjectId(), count));	}	} else {	}	} else {	
unknown message type message ignored 

protected int extractProducerCountFromMessage(Message message, int count) {	try {	Object value = message.getObjectProperty("producerCount");	if (value instanceof Number) {	Number n = (Number)value;	return n.intValue();	}	
no producercount header available on the message 

protected int extractProducerCountFromMessage(Message message, int count) {	try {	Object value = message.getObjectProperty("producerCount");	if (value instanceof Number) {	Number n = (Number)value;	return n.intValue();	}	} catch (Exception e) {	
failed to extract producercount from message reason 

========================= activemq sample_695 =========================

protected void messageSent() throws Exception {	verifyExpectedBroker(inflightMessageCount);	if (++inflightMessageCount == failureCount) {	
stopping db 

protected void messageSent() throws Exception {	verifyExpectedBroker(inflightMessageCount);	if (++inflightMessageCount == failureCount) {	final EmbeddedDataSource ds = ((SyncCreateDataSource)getExistingDataSource()).getDelegate();	ds.setShutdownDatabase("shutdown");	
db stopped 

protected void messageSent() throws Exception {	verifyExpectedBroker(inflightMessageCount);	if (++inflightMessageCount == failureCount) {	final EmbeddedDataSource ds = ((SyncCreateDataSource)getExistingDataSource()).getDelegate();	ds.setShutdownDatabase("shutdown");	Thread dbRestartThread = new Thread("db-re-start-thread") {	public void run() {	delayTillRestartRequired();	ds.setShutdownDatabase("false");	
db restarted 

protected void delayTillRestartRequired() {	
waiting for master broker to stop 

protected void consumeMessage(Message message, List<Message> messageList) {	try {	receiveSession.commit();	super.consumeMessage(message, messageList);	} catch (JMSException e) {	
failed to commit message receipt 

java.sql.Connection dbConnection = null;	try {	ActiveMQMessage mqMessage = (ActiveMQMessage) message;	MessageId id = mqMessage.getMessageId();	dbConnection = sharedDs.getConnection();	PreparedStatement s = dbConnection.prepareStatement(findStatement);	s.setString(1, id.getProducerId().toString());	s.setLong(2, id.getProducerSequenceId());	ResultSet rs = s.executeQuery();	if (!rs.next()) {	
on transactionrolledbackexception we know that the ack commit got there b c message is gone so we count it 

ActiveMQMessage mqMessage = (ActiveMQMessage) message;	MessageId id = mqMessage.getMessageId();	dbConnection = sharedDs.getConnection();	PreparedStatement s = dbConnection.prepareStatement(findStatement);	s.setString(1, id.getProducerId().toString());	s.setLong(2, id.getProducerSequenceId());	ResultSet rs = s.executeQuery();	if (!rs.next()) {	super.consumeMessage(message, messageList);	} else {	
on transactionrolledbackexception we know that the ack commit was lost so we expect a replay of 

========================= activemq sample_2424 =========================

protected ObjectName assertRegisteredObjectName(String name) throws MalformedObjectNameException, NullPointerException {	ObjectName objectName = new ObjectName(name);	
looking for 

protected ObjectName assertRegisteredObjectName(String name) throws MalformedObjectNameException, NullPointerException {	ObjectName objectName = new ObjectName(name);	try {	if (mbeanServer.isRegistered(objectName)) {	
bean registered 

protected ObjectName assertRegisteredObjectName(String name) throws MalformedObjectNameException, NullPointerException {	ObjectName objectName = new ObjectName(name);	try {	if (mbeanServer.isRegistered(objectName)) {	} else {	
couldn t find mbean 

public void testPendingTopicStat() throws Exception {	Connection consumerCon = createConnection("cliId1");	Session consumerSession = consumerCon.createSession(true, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer1 = consumerSession.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);	assertNotNull(consumer1);	DurableSubscriptionViewMBean subscriber1 = null;	ObjectName query = new ObjectName(domain + ":type=Broker,brokerName=" + getName(true) + ",destinationType=Topic,destinationName=" + topic.getTopicName() + ",endpoint=Consumer,clientId=cliId1,consumerId=*");	java.util.Set<ObjectName>set = mbeanServer.queryNames(query,null);	ObjectName subscriberObjName1 = set.iterator().next();	subscriber1 = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, subscriberObjName1, DurableSubscriptionViewMBean.class, true);	
beginning pending queue size count 

public void testPendingTopicStat() throws Exception {	Connection consumerCon = createConnection("cliId1");	Session consumerSession = consumerCon.createSession(true, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer1 = consumerSession.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);	assertNotNull(consumer1);	DurableSubscriptionViewMBean subscriber1 = null;	ObjectName query = new ObjectName(domain + ":type=Broker,brokerName=" + getName(true) + ",destinationType=Topic,destinationName=" + topic.getTopicName() + ",endpoint=Consumer,clientId=cliId1,consumerId=*");	java.util.Set<ObjectName>set = mbeanServer.queryNames(query,null);	ObjectName subscriberObjName1 = set.iterator().next();	subscriber1 = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, subscriberObjName1, DurableSubscriptionViewMBean.class, true);	
prefetch limit 

subscriber1 = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, subscriberObjName1, DurableSubscriptionViewMBean.class, true);	assertEquals("no pending", 0, subscriber1.getPendingQueueSize());	assertEquals("Prefetch Limit ", 10, subscriber1.getPrefetchSize());	Connection producerCon = createConnection("x");	Session producerSessions = producerCon.createSession(true, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = producerSessions.createProducer(topic);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	int i = 0;	for (; i < numMessages; i++) {	if (i == 15) {	
killing consumer at 

if (i == 15) {	consumerSession.close();	consumerCon.close();	}	TextMessage message = producerSessions.createTextMessage(createMessageText(i));	message.setJMSExpiration(0);	message.setStringProperty("filter", "true");	producer.send(topic, message);	producerSessions.commit();	}	
sent messages in total 

consumerSession.close();	consumerCon.close();	}	TextMessage message = producerSessions.createTextMessage(createMessageText(i));	message.setJMSExpiration(0);	message.setStringProperty("filter", "true");	producer.send(topic, message);	producerSessions.commit();	}	producerCon.close();	
pending queue size count 

consumerCon.close();	}	TextMessage message = producerSessions.createTextMessage(createMessageText(i));	message.setJMSExpiration(0);	message.setStringProperty("filter", "true");	producer.send(topic, message);	producerSessions.commit();	}	producerCon.close();	assertEquals("pending as expected", 20, subscriber1.getPendingQueueSize());	
re connect client and consume messages 

Connection con2 = createConnection("cliId1");	session2 = con2.createSession(true, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer2 = session2.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);	final Listener listener = new Listener();	consumer2.setMessageListener(listener);	assertTrue("received all sent", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return numMessages == listener.count;	}	}));	
received 

session2 = con2.createSession(true, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer2 = session2.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);	final Listener listener = new Listener();	consumer2.setMessageListener(listener);	assertTrue("received all sent", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return numMessages == listener.count;	}	}));	int pq = subscriber1.getPendingQueueSize();	
pending queue size count 

consumer2.setMessageListener(listener);	assertTrue("received all sent", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return numMessages == listener.count;	}	}));	int pq = subscriber1.getPendingQueueSize();	assertEquals("Pending queue after consumed", 0, pq);	session2.close();	con2.close();	
final pending queue size count after consumer close 

========================= activemq sample_3720 =========================

protected void setUp() throws Exception {	if (broker == null) {	broker = createBroker(bindAddress);	}	factory = createConnectionFactory(bindAddress);	managementConnection = factory.createConnection();	managementSession = managementConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination startDestination = createDestination(managementSession, getClass()+".start");	Destination endDestination = createDestination(managementSession, getClass()+".end");	
running with clients sending batches of messages 

========================= activemq sample_2998 =========================

public SubQueueSelectorCacheBroker(Broker next, final File persistFile) {	super(next);	this.persistFile = persistFile;	
using persisted selector cache from 

private void enableJmx() {	BrokerService broker = getBrokerService();	if (broker.isUseJmx()) {	VirtualDestinationSelectorCacheView view = new VirtualDestinationSelectorCacheView(this);	try {	objectName = BrokerMBeanSupport.createVirtualDestinationSelectorCacheName(broker.getBrokerObjectName(), "plugin", "virtualDestinationCache");	
virtualdestinationcacheselector mbean name 

private void enableJmx() {	BrokerService broker = getBrokerService();	if (broker.isUseJmx()) {	VirtualDestinationSelectorCacheView view = new VirtualDestinationSelectorCacheView(this);	try {	objectName = BrokerMBeanSupport.createVirtualDestinationSelectorCacheName(broker.getBrokerObjectName(), "plugin", "virtualDestinationCache");	AnnotatedMBean.registerMBean(broker.getManagementContext(), view, objectName);	} catch (Exception e) {	
jmx is enabled but when installing the virtualdestinationselectorcache couldn t install the jmx mbeans continuing without installing the mbeans 

private void unregisterMBeans() {	BrokerService broker = getBrokerService();	if (broker.isUseJmx() && this.objectName != null) {	try {	broker.getManagementContext().unregisterMBean(objectName);	} catch (JMException e) {	
trying uninstall virtualdestinationselectorcache couldn t uninstall mbeans continuting 

public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {	if (!AdvisorySupport.isAdvisoryTopic(info.getDestination()) && !info.getDestination().isTemporary()) {	String destinationName = info.getDestination().getQualifiedName();	
caching consumer selector on 

Set<String> selectors = subSelectorCache.get(destinationName);	if (selectors == null) {	selectors = Collections.synchronizedSet(new HashSet<String>());	} else if (singleSelectorPerDestination && !MATCH_EVERYTHING.equals(selector)) {	boolean containsMatchEverything = selectors.contains(MATCH_EVERYTHING);	selectors.clear();	if (containsMatchEverything) {	selectors.add(MATCH_EVERYTHING);	}	}	
adding new selector into cache 

if (selectors == null) {	selectors = Collections.synchronizedSet(new HashSet<String>());	} else if (singleSelectorPerDestination && !MATCH_EVERYTHING.equals(selector)) {	boolean containsMatchEverything = selectors.contains(MATCH_EVERYTHING);	selectors.clear();	if (containsMatchEverything) {	selectors.add(MATCH_EVERYTHING);	}	}	selectors.add(selector);	
current selectors in cache 

public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {	if (!AdvisorySupport.isAdvisoryTopic(info.getDestination()) && !info.getDestination().isTemporary()) {	if (singleSelectorPerDestination) {	String destinationName = info.getDestination().getQualifiedName();	Set<String> selectors = subSelectorCache.get(destinationName);	if (info.getSelector() == null && selectors.size() > 1) {	boolean removed = selectors.remove(MATCH_EVERYTHING);	
a non selector consumer has dropped removing the catchall matching pattern true successful 

private void readCache() {	if (persistFile != null && persistFile.exists()) {	try {	try (FileInputStream fis = new FileInputStream(persistFile);) {	ObjectInputStream in = new ObjectInputStream(fis);	try {	subSelectorCache = (ConcurrentHashMap<String, Set<String>>) in.readObject();	} catch (ClassNotFoundException ex) {	
invalid selector cache data found please remove file 

try (FileInputStream fis = new FileInputStream(persistFile);) {	ObjectInputStream in = new ObjectInputStream(fis);	try {	subSelectorCache = (ConcurrentHashMap<String, Set<String>>) in.readObject();	} catch (ClassNotFoundException ex) {	} finally {	in.close();	}	}	} catch (IOException ex) {	
unable to read persisted selector cache it will be ignored 

private void persistCache() {	
persisting selector cache 

FileOutputStream fos = new FileOutputStream(persistFile);	try {	ObjectOutputStream out = new ObjectOutputStream(fos);	try {	out.writeObject(subSelectorCache);	} finally {	out.flush();	out.close();	}	} catch (IOException ex) {	
unable to persist selector cache 

out.writeObject(subSelectorCache);	} finally {	out.flush();	out.close();	}	} catch (IOException ex) {	} finally {	fos.close();	}	} catch (IOException ex) {	
unable to access file 

========================= activemq sample_4266 =========================

public void testStompUnloadLoad() throws Exception {	final List<StompConnection> taskConnections = new ArrayList<>();	for (int i = 0; i < TASK_COUNT; ++i) {	executor.execute(new Runnable() {	public void run() {	
receive thread connecting to broker 

final List<StompConnection> taskConnections = new ArrayList<>();	for (int i = 0; i < TASK_COUNT; ++i) {	executor.execute(new Runnable() {	public void run() {	int numReceived = 0;	StompConnection connection = new StompConnection();	try {	stompConnect(connection);	connection.connect("system", "manager");	} catch (Exception e) {	
caught exception while connecting 

headers.put("activemq.prefetchSize", "1");	connection.subscribe("/topic/" + getTopicName(), "auto", headers);	ready.await();	TimeUnit.SECONDS.sleep(3);	started.countDown();	while (receiveCount.get() != TASK_COUNT * MSG_COUNT) {	StompFrame frame = connection.receive(TimeUnit.SECONDS.toMillis(60));	assertNotNull(frame);	numReceived++;	if (LOG.isDebugEnabled() && (numReceived % 50) == 0 || numReceived == MSG_COUNT) {	
receiver thread got message message id 

while (receiveCount.get() != TASK_COUNT * MSG_COUNT) {	StompFrame frame = connection.receive(TimeUnit.SECONDS.toMillis(60));	assertNotNull(frame);	numReceived++;	if (LOG.isDebugEnabled() && (numReceived % 50) == 0 || numReceived == MSG_COUNT) {	}	receiveCount.incrementAndGet();	}	} catch (Exception e) {	if (numReceived != MSG_COUNT) {	
receive task caught exception after receipt of messages 

});	}	ready.countDown();	assertTrue("Timed out waiting for receivers to start.", started.await(5, TimeUnit.MINUTES));	String frame;	TimeUnit.SECONDS.sleep(5);	for( int ix = 0; ix < MSG_COUNT; ix++) {	frame = "SEND\n" + "destination:/topic/" + getTopicName() + "\nid:" + ix + "\ncontent-length:5" + " \n\n" + "\u0001\u0002\u0000\u0004\u0005" + Stomp.NULL;	stompConnection.sendFrame(frame);	}	
all message have been sent awaiting receipt 

TimeUnit.SECONDS.sleep(5);	for( int ix = 0; ix < MSG_COUNT; ix++) {	frame = "SEND\n" + "destination:/topic/" + getTopicName() + "\nid:" + ix + "\ncontent-length:5" + " \n\n" + "\u0001\u0002\u0000\u0004\u0005" + Stomp.NULL;	stompConnection.sendFrame(frame);	}	assertTrue("Should get [" + TASK_COUNT * MSG_COUNT + "] message but was: " + receiveCount.get(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return receiveCount.get() == TASK_COUNT * MSG_COUNT;	}	}, TimeUnit.MINUTES.toMillis(10)));	
test completed and all messages received shutting down 

========================= activemq sample_1434 =========================

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue("test");	MessageProducer producer = session.createProducer(queue);	for (int i = 0; i < 10; i++) {	producer.send(session.createTextMessage("Hello" + i));	}	final RegionBroker regionBroker = (RegionBroker) BrokerRegistry.getInstance().findFirst().getRegionBroker();	MessageConsumer consumer = session.createConsumer(queue);	assertTrue("prefetch full", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
inflight count 

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue("test");	MessageProducer producer = session.createProducer(queue);	for (int i = 0; i < 10; i++) {	producer.send(session.createTextMessage("Hello" + i));	}	final RegionBroker regionBroker = (RegionBroker) BrokerRegistry.getInstance().findFirst().getRegionBroker();	MessageConsumer consumer = session.createConsumer(queue);	assertTrue("prefetch full", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
inflight count 

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue("test");	MessageProducer producer = session.createProducer(queue);	for (int i = 0; i < 10; i++) {	producer.send(session.createTextMessage("Hello" + i));	}	final RegionBroker regionBroker = (RegionBroker) BrokerRegistry.getInstance().findFirst().getRegionBroker();	MessageConsumer consumer = session.createConsumer(queue);	assertTrue("prefetch full", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
inflight count 

javax.jms.Message msg = consumer.receive(4000);	assertNotNull(msg);	assertTrue("most are acked but 3 remain", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return 3 == regionBroker.getDestinationStatistics().getInflight().getCount();	}	}));	}	assertTrue("After delay the scheduled ack should ack all inflight.", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
inflight count 

========================= activemq sample_2648 =========================

destinationView = getProxyToTopic(getTestName());	} else {	destinationView = getProxyToQueue(getTestName());	}	assertEquals(MSG_COUNT, destinationView.getEnqueueCount());	assertEquals(0, destinationView.getDispatchCount());	receiver.drain(MSG_COUNT);	for (int i = 0; i < MSG_COUNT; ++i) {	AmqpMessage message = receiver.receive(5, TimeUnit.SECONDS);	assertNotNull("Failed to read message: " + (i + 1), message);	
read message 

========================= activemq sample_1571 =========================

public void testProcess() throws Exception {	MsgProducer msgProducer = new MsgProducer();	msgProducer.start();	DurableSubscriber subscribers[] = new DurableSubscriber[10];	for (int i = 0; i < subscribers.length; i++) {	subscribers[i] = new DurableSubscriber(i);	subscribers[i].process();	}	msgProducer.join();	for (int j = 0; j < subscribers.length; j++) {	
unsubscribing subscriber 

for (int j = 0; j < subscribers.length; j++) {	subscribers[j].unsubscribe();	}	TimeUnit.MINUTES.sleep(2);	final KahaDBPersistenceAdapter pa = (KahaDBPersistenceAdapter) broker.getPersistenceAdapter();	assertTrue("less than two journal file should be left, was: " + pa.getStore().getJournal().getFileMap().size(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return pa.getStore().getJournal().getFileMap().size() <= 2;	}	}, TimeUnit.MINUTES.toMillis(2)));	
done 

private void process() throws JMSException {	long end = System.currentTimeMillis() + 20000;	int transCount = 0;	
online 

}	Message message = consumer.receive(max);	if (message == null) {	continue;	}	LOG.info("Received Trans[id=" + message.getIntProperty("TRANS") + ", count=" + transCount + "] in " + this + ".");	} while (true);	} finally {	sess.close();	con.close();	
offline 

========================= activemq sample_3632 =========================

public void repeat() throws Exception {	for (int i=0; i<10; i++) {	
iteration 

MessageConsumer messageConsumer = consumerSession.createConsumer(QUEUE_NAME);	while (true) {	TextMessage textMsg = (TextMessage) messageConsumer.receive(1000);	if (textMsg == null) {	textMsg = (TextMessage) messageConsumer.receive(4000);	}	if (textMsg == null) {	return receivedMessageCount;	}	receivedMessageCount++;	
receivedmessagecount message has messageid 

while (true) {	TextMessage textMsg = (TextMessage) messageConsumer.receive(1000);	if (textMsg == null) {	textMsg = (TextMessage) messageConsumer.receive(4000);	}	if (textMsg == null) {	return receivedMessageCount;	}	receivedMessageCount++;	if (textMsg.getJMSMessageID().endsWith("1") && receivedMessageCount == 1) {	
waiting for restart 

}	} finally {	consumerConnection.close();	}	}	};	Runnable consumerBrokerResetTask = new Runnable() {	public void run() {	try {	stopConsumerBroker.await();	
stopping consumer broker 

consumerConnection.close();	}	}	};	Runnable consumerBrokerResetTask = new Runnable() {	public void run() {	try {	stopConsumerBroker.await();	consumerBroker.stop();	consumerBroker.waitUntilStopped();	
starting consumer broker 

}	}	};	Runnable consumerBrokerResetTask = new Runnable() {	public void run() {	try {	stopConsumerBroker.await();	consumerBroker.stop();	consumerBroker.waitUntilStopped();	consumerBroker = createConsumerBroker(false);	
consumer broker started 

Runnable consumerBrokerResetTask = new Runnable() {	public void run() {	try {	stopConsumerBroker.await();	consumerBroker.stop();	consumerBroker.waitUntilStopped();	consumerBroker = createConsumerBroker(false);	consumerBrokerRestarted.countDown();	assertTrue("message forwarded on time", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
producerbroker totalmessagecount 

consumerBroker.waitUntilStopped();	consumerBroker = createConsumerBroker(false);	consumerBrokerRestarted.countDown();	assertTrue("message forwarded on time", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return producerBroker.getAdminView().getTotalMessageCount() == 0;	}	}));	consumerRestartedAndMessageForwarded.countDown();	} catch (Exception e) {	
exception when stopping starting the consumerbroker 

}	}	};	ExecutorService executor = Executors.newFixedThreadPool(2);	executor.execute(consumerBrokerResetTask);	Future<Integer> numberOfConsumedMessage = executor.submit(consumeMessageTask);	produceMessages();	int totalMessagesConsumed = numberOfConsumedMessage.get();	StringBuffer contents = new StringBuffer();	boolean messageInStore = isMessageInJDBCStore(localDataSource, contents);	
number of messages received 

public void setUp() throws Exception {	
running with enablecursoraudit set to 

public void send(ProducerBrokerExchange producerExchange, org.apache.activemq.command.Message messageSend) throws Exception {	super.send(producerExchange, messageSend);	
stopping broker on send 

========================= activemq sample_2920 =========================

protected Transport createProducer() throws Exception {	
producer using uri 

========================= activemq sample_2473 =========================

public ServerSocketTstFactory() {	super();	
creating a new serversockettstfactory 

========================= activemq sample_2536 =========================

protected void generateFile() throws Exception {	
creating dot file at 

========================= activemq sample_4118 =========================

storeUsage.setTotal(1024*1024*10);	filtered.setUsage(storeUsage);	filtered.setPersistenceAdapter(kahaStore);	filtered.setPerDestination(true);	List<FilteredKahaDBPersistenceAdapter> stores = new ArrayList<>();	stores.add(filtered);	persistenceAdapter.setFilteredPersistenceAdapters(stores);	createBroker(persistenceAdapter).start();	produceMessages(queueA, 20);	produceMessages(queueB, 0);	
store global u 

filtered.setPerDestination(true);	List<FilteredKahaDBPersistenceAdapter> stores = new ArrayList<>();	stores.add(filtered);	persistenceAdapter.setFilteredPersistenceAdapters(stores);	createBroker(persistenceAdapter).start();	produceMessages(queueA, 20);	produceMessages(queueB, 0);	assertTrue("some usage", broker.getSystemUsage().getStoreUsage().getUsage() > 0);	BaseDestination baseDestinationA = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(queueA);	BaseDestination baseDestinationB = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(queueB);	
store a u 

createBroker(persistenceAdapter).start();	produceMessages(queueA, 20);	produceMessages(queueB, 0);	assertTrue("some usage", broker.getSystemUsage().getStoreUsage().getUsage() > 0);	BaseDestination baseDestinationA = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(queueA);	BaseDestination baseDestinationB = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(queueB);	assertTrue(baseDestinationA.getSystemUsage().getStoreUsage().getUsage() > 0);	produceMessages(queueB, 40);	assertTrue(baseDestinationB.getSystemUsage().getStoreUsage().getUsage() > 0);	assertTrue(baseDestinationB.getSystemUsage().getStoreUsage().getUsage() > baseDestinationA.getSystemUsage().getStoreUsage().getUsage());	
store b u 

createBroker(persistenceAdapter).start();	produceMessages(queueA, 20);	produceMessages(queueB, 0);	assertTrue("some usage", broker.getSystemUsage().getStoreUsage().getUsage() > 0);	BaseDestination baseDestinationA = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(queueA);	BaseDestination baseDestinationB = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(queueB);	assertTrue(baseDestinationA.getSystemUsage().getStoreUsage().getUsage() > 0);	produceMessages(queueB, 40);	assertTrue(baseDestinationB.getSystemUsage().getStoreUsage().getUsage() > 0);	assertTrue(baseDestinationB.getSystemUsage().getStoreUsage().getUsage() > baseDestinationA.getSystemUsage().getStoreUsage().getUsage());	
store global u 

produceMessages(queueB, 0);	assertTrue("some usage", broker.getSystemUsage().getStoreUsage().getUsage() > 0);	BaseDestination baseDestinationA = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(queueA);	BaseDestination baseDestinationB = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(queueB);	assertTrue(baseDestinationA.getSystemUsage().getStoreUsage().getUsage() > 0);	produceMessages(queueB, 40);	assertTrue(baseDestinationB.getSystemUsage().getStoreUsage().getUsage() > 0);	assertTrue(baseDestinationB.getSystemUsage().getStoreUsage().getUsage() > baseDestinationA.getSystemUsage().getStoreUsage().getUsage());	consume(queueA);	consume(queueB);	
store global u 

produceMessages(queueB, 0);	assertTrue("some usage", broker.getSystemUsage().getStoreUsage().getUsage() > 0);	BaseDestination baseDestinationA = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(queueA);	BaseDestination baseDestinationB = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(queueB);	assertTrue(baseDestinationA.getSystemUsage().getStoreUsage().getUsage() > 0);	produceMessages(queueB, 40);	assertTrue(baseDestinationB.getSystemUsage().getStoreUsage().getUsage() > 0);	assertTrue(baseDestinationB.getSystemUsage().getStoreUsage().getUsage() > baseDestinationA.getSystemUsage().getStoreUsage().getUsage());	consume(queueA);	consume(queueB);	
store a u 

produceMessages(queueB, 0);	assertTrue("some usage", broker.getSystemUsage().getStoreUsage().getUsage() > 0);	BaseDestination baseDestinationA = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(queueA);	BaseDestination baseDestinationB = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(queueB);	assertTrue(baseDestinationA.getSystemUsage().getStoreUsage().getUsage() > 0);	produceMessages(queueB, 40);	assertTrue(baseDestinationB.getSystemUsage().getStoreUsage().getUsage() > 0);	assertTrue(baseDestinationB.getSystemUsage().getStoreUsage().getUsage() > baseDestinationA.getSystemUsage().getStoreUsage().getUsage());	consume(queueA);	consume(queueB);	
store b u 

filtered.setUsage(storeUsage);	filtered.setDestination(queueA);	filtered.setPersistenceAdapter(kahaStore);	List<FilteredKahaDBPersistenceAdapter> stores = new ArrayList<>();	stores.add(filtered);	persistenceAdapter.setFilteredPersistenceAdapters(stores);	BrokerService brokerService = createBroker(persistenceAdapter);	brokerService.getSystemUsage().getStoreUsage().setTotal(1024*1024);	brokerService.start();	produceMessages(queueA, 20);	
store global u 

filtered.setPersistenceAdapter(kahaStore);	List<FilteredKahaDBPersistenceAdapter> stores = new ArrayList<>();	stores.add(filtered);	persistenceAdapter.setFilteredPersistenceAdapters(stores);	BrokerService brokerService = createBroker(persistenceAdapter);	brokerService.getSystemUsage().getStoreUsage().setTotal(1024*1024);	brokerService.start();	produceMessages(queueA, 20);	assertTrue("some usage", broker.getSystemUsage().getStoreUsage().getUsage() > 0);	BaseDestination baseDestinationA = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(queueA);	
store a u 

assertTrue("some messages got to dest", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	BaseDestination baseDestinationA = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(queueA);	return baseDestinationA != null && baseDestinationA.getDestinationStatistics().getMessages().getCount() > 4l;	}	}));	BaseDestination baseDestinationA = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(queueA);	long enqueues = 0l;	do {	enqueues = baseDestinationA.getDestinationStatistics().getEnqueues().getCount();	
dest enqueues 

return baseDestinationA != null && baseDestinationA.getDestinationStatistics().getMessages().getCount() > 4l;	}	}));	BaseDestination baseDestinationA = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(queueA);	long enqueues = 0l;	do {	enqueues = baseDestinationA.getDestinationStatistics().getEnqueues().getCount();	TimeUnit.MILLISECONDS.sleep(500);	} while (enqueues != baseDestinationA.getDestinationStatistics().getEnqueues().getCount());	assertFalse("expect producer to block", done.get());	
store global u 

}	}));	BaseDestination baseDestinationA = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(queueA);	long enqueues = 0l;	do {	enqueues = baseDestinationA.getDestinationStatistics().getEnqueues().getCount();	TimeUnit.MILLISECONDS.sleep(500);	} while (enqueues != baseDestinationA.getDestinationStatistics().getEnqueues().getCount());	assertFalse("expect producer to block", done.get());	assertTrue("some usage", broker.getSystemUsage().getStoreUsage().getUsage() > 0);	
store a u 

========================= activemq sample_3777 =========================

producer.send(newMsg);	}	}	msg.acknowledge();	} catch (JMSException e) {	e.printStackTrace();	throw new RuntimeException(e);	} finally {	final int onMsgCounter = ON_MSG_COUNTER.getAndIncrement();	if (onMsgCounter % 1000 == 0) {	
message received 

========================= activemq sample_2865 =========================

}	if (activationSpec.isUseRAManagedTransactionEnabled()) {	endpoint = createEndpoint(null);	return new ServerSessionImpl(this, session, activeMQAsfEndpointWorker.workManager, endpoint, true, batchSize);	} else {	endpoint = createEndpoint(new LocalAndXATransaction(session.getTransactionContext()));	return new ServerSessionImpl(this, session, activeMQAsfEndpointWorker.workManager, endpoint, false, batchSize);	}	} catch (UnavailableException e) {	if (LOG.isDebugEnabled()) {	
could not create an endpoint 

public ServerSession getServerSession() throws JMSException {	if (LOG.isDebugEnabled()) {	
serversession requested 

throw new JMSException("Endpoint factory did not allow creation of any endpoints.");	}	ss = getExistingServerSession(true);	} else {	activeSessions.add(ss);	}	} finally {	sessionLock.unlock();	}	if (LOG.isDebugEnabled()) {	
created a new session 

private ServerSessionImpl getExistingServerSession(boolean force) {	ServerSessionImpl ss = null;	if (idleSessions.size() > 0) {	ss = idleSessions.remove(idleSessions.size() - 1);	}	if (ss != null) {	activeSessions.add(ss);	if (LOG.isDebugEnabled()) {	
using idle session 

ServerSessionImpl ss = null;	if (!activeSessions.isEmpty()) {	if (activeSessions.size() > 1) {	ss = activeSessions.remove(0);	activeSessions.add(ss);	} else {	ss = activeSessions.get(0);	}	}	if (LOG.isDebugEnabled()) {	
reusing an active session 

public void returnToPool(ServerSessionImpl ss) {	sessionLock.lock();	activeSessions.remove(ss);	try {	if ( ss.isStale() ) {	if ( LOG.isDebugEnabled() ) {	
discarding stale serversession to be returned to pool 

public void returnToPool(ServerSessionImpl ss) {	sessionLock.lock();	activeSessions.remove(ss);	try {	if ( ss.isStale() ) {	if ( LOG.isDebugEnabled() ) {	}	ss.close();	} else {	if (LOG.isDebugEnabled()) {	
serversession returned to pool 

try {	ActiveMQSession session = (ActiveMQSession)ss.getSession();	List<MessageDispatch> l = session.getUnconsumedMessages();	if (!l.isEmpty()) {	ActiveMQConnection connection = activeMQAsfEndpointWorker.getConnection();	if (connection != null) {	for (Iterator<MessageDispatch> i = l.iterator(); i.hasNext();) {	MessageDispatch md = i.next();	if (connection.hasDispatcher(md.getConsumerId())) {	dispatchToSession(md);	
on remove of redispatch of 

ActiveMQSession session = (ActiveMQSession)ss.getSession();	List<MessageDispatch> l = session.getUnconsumedMessages();	if (!l.isEmpty()) {	ActiveMQConnection connection = activeMQAsfEndpointWorker.getConnection();	if (connection != null) {	for (Iterator<MessageDispatch> i = l.iterator(); i.hasNext();) {	MessageDispatch md = i.next();	if (connection.hasDispatcher(md.getConsumerId())) {	dispatchToSession(md);	} else {	
on remove not redispatching dispatcher no longer present on 

ActiveMQConnection connection = activeMQAsfEndpointWorker.getConnection();	if (connection != null) {	for (Iterator<MessageDispatch> i = l.iterator(); i.hasNext();) {	MessageDispatch md = i.next();	if (connection.hasDispatcher(md.getConsumerId())) {	dispatchToSession(md);	} else {	}	}	} else {	
on remove of not redispatching while disconnected 

MessageDispatch md = i.next();	if (connection.hasDispatcher(md.getConsumerId())) {	dispatchToSession(md);	} else {	}	}	} else {	}	}	} catch (Throwable t) {	
error redispatching unconsumed messages from stale server session 

sessionLock.lock();	try {	for (ServerSessionImpl ss : activeSessions) {	try {	ActiveMQSession session = (ActiveMQSession) ss.getSession();	if (!session.isClosed()) {	session.close();	}	} catch (JMSException ignored) {	if (LOG.isDebugEnabled()) {	
failed to close active running server session reason 

========================= activemq sample_857 =========================

}	NetworkBridgeView view = new NetworkBridgeView(bridge);	view.setCreateByDuplex(createdByDuplex);	try {	ObjectName objectName = createNetworkBridgeObjectName(bridge);	AnnotatedMBean.registerMBean(brokerService.getManagementContext(), view, objectName);	bridge.setMbeanObjectName(objectName);	MBeanBridgeDestination mBeanBridgeDestination = new MBeanBridgeDestination(brokerService,networkBridgeConfiguration,bridge,view);	destinationObjectNameMap.put(bridge,mBeanBridgeDestination);	mBeanBridgeDestination.start();	
registered as 

NetworkBridgeView view = new NetworkBridgeView(bridge);	view.setCreateByDuplex(createdByDuplex);	try {	ObjectName objectName = createNetworkBridgeObjectName(bridge);	AnnotatedMBean.registerMBean(brokerService.getManagementContext(), view, objectName);	bridge.setMbeanObjectName(objectName);	MBeanBridgeDestination mBeanBridgeDestination = new MBeanBridgeDestination(brokerService,networkBridgeConfiguration,bridge,view);	destinationObjectNameMap.put(bridge,mBeanBridgeDestination);	mBeanBridgeDestination.start();	} catch (Throwable e) {	
network bridge could not be registered in jmx 

try {	ObjectName objectName = bridge.getMbeanObjectName();	if (objectName != null) {	brokerService.getManagementContext().unregisterMBean(objectName);	}	MBeanBridgeDestination mBeanBridgeDestination = destinationObjectNameMap.remove(bridge);	if (mBeanBridgeDestination != null){	mBeanBridgeDestination.stop();	}	} catch (Throwable e) {	
network bridge could not be unregistered in jmx 

========================= activemq sample_4231 =========================

public void sendToActiveMQ(Command command, ResponseHandler handler) {	if (command instanceof ActiveMQMessage) {	ActiveMQMessage msg = (ActiveMQMessage) command;	try {	if (!getPublishDollarTopics() && findSubscriptionStrategy().isControlTopic(msg.getDestination())) {	if (handler != null) {	try {	handler.onResponse(this, new Response());	} catch (IOException e) {	
failed to send command 

if (!getPublishDollarTopics() && findSubscriptionStrategy().isControlTopic(msg.getDestination())) {	if (handler != null) {	try {	handler.onResponse(this, new Response());	} catch (IOException e) {	}	}	return;	}	} catch (IOException e) {	
failed to send command 

public void onMQTTCommand(MQTTFrame frame) throws IOException, JMSException {	switch (frame.messageType()) {	
received a ping from client 

public void onMQTTCommand(MQTTFrame frame) throws IOException, JMSException {	switch (frame.messageType()) {	checkConnected();	sendToMQTT(PING_RESP_FRAME);	
sent ping response to 

public void onMQTTCommand(MQTTFrame frame) throws IOException, JMSException {	switch (frame.messageType()) {	checkConnected();	sendToMQTT(PING_RESP_FRAME);	break;	case CONNECT.TYPE: CONNECT connect = new CONNECT().decode(frame);	onMQTTConnect(connect);	
mqtt client connected version 

public void onMQTTCommand(MQTTFrame frame) throws IOException, JMSException {	switch (frame.messageType()) {	checkConnected();	sendToMQTT(PING_RESP_FRAME);	break;	case CONNECT.TYPE: CONNECT connect = new CONNECT().decode(frame);	onMQTTConnect(connect);	break;	
mqtt client disconnecting 

try {	findSubscriptionStrategy().onUnSubscribe(topic.toString());	} catch (IOException e) {	throw new MQTTProtocolException("Failed to process unsubscribe request", true, e);	}	}	UNSUBACK ack = new UNSUBACK();	ack.messageId(command.messageId());	sendToMQTT(ack.encode());	} else {	
no topics defined for subscription 

MessageAck ack = sub.createMessageAck(md);	PUBLISH publish = sub.createPublish((ActiveMQMessage) md.getMessage());	switch (publish.qos()) {	case AT_LEAST_ONCE: case EXACTLY_ONCE: publish.dup(publish.dup() ? true : md.getMessage().isRedelivered());	case AT_MOST_ONCE: }	if (ack != null && sub.expectAck(publish)) {	synchronized (consumerAcks) {	consumerAcks.put(publish.messageId(), ack);	}	}	
mqtt snd publish message client connection 

getMQTTTransport().sendToMQTT(publish.encode());	if (ack != null && !sub.expectAck(publish)) {	getMQTTTransport().sendToActiveMQ(ack);	}	}	} else if (command.getDataStructureType() == ConnectionError.DATA_STRUCTURE_TYPE) {	Throwable exception = ((ConnectionError) command).getException();	handleException(exception, null);	} else if (command.isBrokerInfo()) {	} else {	
do not know how to process activemq command 

ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();	while ((read = inflater.inflate(data)) != 0) {	bytesOut.write(data, 0, read);	}	byteSequence = bytesOut.toByteSequence();	bytesOut.close();	}	result.payload(new Buffer(byteSequence.data, byteSequence.offset, byteSequence.length));	}	}	
activemq mqtt mqtt msgid client connection activemq msgid 

publish.topicName(connect.willTopic());	publish.qos(connect.willQos());	publish.messageId(packetIdGenerator.getNextSequenceId(getClientId()));	publish.payload(connect.willMessage());	publish.retain(connect.willRetain());	ActiveMQMessage message = convertMessage(publish);	message.setProducerId(producerId);	message.onSend();	sendToActiveMQ(message, null);	} catch (Exception e) {	
failed to publish will message 

private void stopTransport() {	try {	getMQTTTransport().stop();	} catch (Throwable e) {	
failed to stop mqtt transport 

public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {	if (response.isException()) {	Throwable error = ((ExceptionResponse) response).getException();	
failed to send mqtt publish 

public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {	if (response.isException()) {	Throwable error = ((ExceptionResponse) response).getException();	
error trace 

public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {	if (response.isException()) {	Throwable error = ((ExceptionResponse) response).getException();	}	switch (command.qos()) {	case AT_LEAST_ONCE: PUBACK ack = new PUBACK();	ack.messageId(command.messageId());	
mqtt snd puback message client connection 

switch (command.qos()) {	case AT_LEAST_ONCE: PUBACK ack = new PUBACK();	ack.messageId(command.messageId());	converter.getMQTTTransport().sendToMQTT(ack.encode());	break;	case EXACTLY_ONCE: PUBREC req = new PUBREC();	req.messageId(command.messageId());	synchronized (publisherRecs) {	publisherRecs.put(command.messageId(), req);	}	
mqtt snd pubrec message client connection 

protected MQTTSubscriptionStrategy findSubscriptionStrategy() throws IOException {	if (subsciptionStrategy == null) {	synchronized (STRATAGY_FINDER) {	if (subsciptionStrategy != null) {	return subsciptionStrategy;	}	MQTTSubscriptionStrategy strategy = null;	if (subscriptionStrategyName != null && !subscriptionStrategyName.isEmpty()) {	try {	strategy = (MQTTSubscriptionStrategy) STRATAGY_FINDER.newInstance(subscriptionStrategyName);	
mqtt using subscription strategy 

========================= activemq sample_912 =========================

public void testQueueSendThenAddConsumer() throws Exception {	ProgressPrinter printer = new ProgressPrinter(produceCount, 20);	ActiveMQDestination destination = new ActiveMQQueue("TEST");	connection.setUseCompression(false);	connection.getPrefetchPolicy().setAll(10);	connection.start();	Session session = connection.createSession(false, Session.DUPS_OK_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	
sending messages that are k large for a total of megs of data 

MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	long start = System.currentTimeMillis();	for (int i = 0; i < produceCount; i++) {	printer.increment();	BytesMessage msg = session.createBytesMessage();	msg.writeBytes(new byte[messageSize]);	producer.send(msg);	}	long end1 = System.currentTimeMillis();	
produced messages sec 

}	long end1 = System.currentTimeMillis();	printer = new ProgressPrinter(produceCount, 10);	start = System.currentTimeMillis();	MessageConsumer consumer = session.createConsumer(destination);	for (int i = 0; i < produceCount; i++) {	printer.increment();	assertNotNull("Getting message: " + i, consumer.receive(20000));	}	end1 = System.currentTimeMillis();	
consumed messages sec 

========================= activemq sample_2465 =========================

public static Collection<Object[]> getTestParameters() {	String osName = System.getProperty("os.name");	
running on 

public DurableSubscriptionOffline1Test(PersistenceAdapterChoice adapter, Boolean usePrioritySupport) {	this.defaultPersistenceAdapter = adapter;	this.usePrioritySupport = usePrioritySupport.booleanValue();	
created with adapter useprioritysupport 

session.close();	con.close();	con = createConnection();	session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);	DurableSubscriptionOfflineTestListener listener = new DurableSubscriptionOfflineTestListener();	consumer.setMessageListener(listener);	Thread.sleep(3 * 1000);	session.close();	con.close();	
consumed 

========================= activemq sample_3624 =========================

public void runTest() throws Exception {	produceSingleMessage();	org.apache.log4j.Logger log4jLogger = org.apache.log4j.Logger.getLogger("org.apache.activemq.util.ServiceSupport");	final AtomicBoolean failed = new AtomicBoolean(false);	Appender appender = new DefaultTestAppender() {	public void doAppend(LoggingEvent event) {	if (event.getThrowableInformation() != null) {	if (event.getThrowableInformation().getThrowable() instanceof InterruptedException) {	InterruptedException ie = (InterruptedException)event.getThrowableInformation().getThrowable();	if (ie.getMessage().startsWith("Could not stop service:")) {	
received an interrupted exception 

private void initializeConsumer() throws JMSException {	
initializing the consumer messagor that will just not do anything 

private void startConsumer() throws Exception {	
starting the consumer 

private void startConsumer() throws Exception {	consumer = sessionWithListener.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	
received a message 

}	});	thread = new Thread(new Runnable() {	private Session session;	public void run() {	try {	destination = session.createQueue("EMPTY.QUEUE");	MessageConsumer consumer = session.createConsumer(destination);	for (int cnt = 0; cnt < 2; cnt++) {	Message message = consumer.receive(50000);	
received message 

thread = new Thread(new Runnable() {	private Session session;	public void run() {	try {	destination = session.createQueue("EMPTY.QUEUE");	MessageConsumer consumer = session.createConsumer(destination);	for (int cnt = 0; cnt < 2; cnt++) {	Message message = consumer.receive(50000);	}	} catch (JMSException e) {	
received an exception while processing messages 

destination = session.createQueue("EMPTY.QUEUE");	MessageConsumer consumer = session.createConsumer(destination);	for (int cnt = 0; cnt < 2; cnt++) {	Message message = consumer.receive(50000);	}	} catch (JMSException e) {	} finally {	try {	session.close();	} catch (JMSException e) {	
received an exception while closing session 

private void stopConsumer() throws JMSException {	
stopping the consumer 

private void stopConsumer() throws JMSException {	try {	thread.join();	} catch (InterruptedException e) {	
received an exception while waiting for thread to complete 

========================= activemq sample_2873 =========================

public void testModifyLockFile() throws Exception {	assertTrue(master.isStarted());	final File lockFile = new File(kahaDataDir, "lock");	assertTrue("lock file exists via modification time", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
lock file last mod at 

========================= activemq sample_3761 =========================

protected void handleStart() throws Exception {	if (localURI == null) {	throw new IllegalStateException("You must configure the 'localURI' property");	}	
network connector started 

protected void handleStop(ServiceStopper stopper) throws Exception {	
network connector stopped 

protected void registerNetworkBridgeMBean(NetworkBridge bridge) {	if (!getBrokerService().isUseJmx()) {	return;	}	NetworkBridgeViewMBean view = new NetworkBridgeView(bridge);	try {	ObjectName objectName = createNetworkBridgeObjectName(bridge);	AnnotatedMBean.registerMBean(getBrokerService().getManagementContext(), view, objectName);	} catch (Throwable e) {	
network bridge could not be registered in jmx 

protected void unregisterNetworkBridgeMBean(NetworkBridge bridge) {	if (!getBrokerService().isUseJmx()) {	return;	}	try {	ObjectName objectName = createNetworkBridgeObjectName(bridge);	getBrokerService().getManagementContext().unregisterMBean(objectName);	} catch (Throwable e) {	
network bridge could not be unregistered in jmx 

========================= activemq sample_4227 =========================

return new InboundConnectionProxy();	}	if (manager == null) {	throw new JMSException("No JCA ConnectionManager configured! Either enable UseInboundSessionEnabled or get your JCA container to configure one.");	}	return (Connection)manager.allocateConnection(factory, connectionRequestInfo);	} catch (ResourceException e) {	if (e.getCause() instanceof JMSException) {	throw (JMSException)e.getCause();	}	
connection could not be created 

========================= activemq sample_841 =========================

protected void assertMessagesReceivedAreValid(List<Message> receivedMessages) throws JMSException {	super.assertMessagesReceivedAreValid(receivedMessages);	for (Message message : receivedMessages) {	String userID = message.getStringProperty("JMSXUserID");	
received message with userid 

protected void assertMessagesReceivedAreValid2(List<Message> receivedMessages) throws JMSException {	super.assertMessagesReceivedAreValid(receivedMessages);	for (Message message : receivedMessages) {	String userID = (String) message.getObjectProperty("JMSXUserID");	
received message with userid 

public void testSpoofedJMSXUserIdIsIgnored() throws Exception {	for (int i = 0; i < data.length; i++) {	Message message = createMessage(i);	configureMessage(message);	message.setStringProperty("JMSXUserID", "spoofedId");	if (verbose) {	
about to send a message with text 

public void testSpoofedJMSXUserIdIsIgnored() throws Exception {	for (int i = 0; i < data.length; i++) {	Message message = createMessage(i);	configureMessage(message);	message.setStringProperty("JMSXUserID", "spoofedId");	if (verbose) {	}	sendMessage(i, message);	}	assertMessagesAreReceived();	
messages s received closing down connections 

public void testSpoofedJMSXUserIdIsIgnoredAsObjectProperty() throws Exception {	for (int i = 0; i < data.length; i++) {	Message message = createMessage(i);	configureMessage(message);	message.setStringProperty("JMSXUserID", "spoofedId");	if (verbose) {	
about to send a message with text 

public void testSpoofedJMSXUserIdIsIgnoredAsObjectProperty() throws Exception {	for (int i = 0; i < data.length; i++) {	Message message = createMessage(i);	configureMessage(message);	message.setStringProperty("JMSXUserID", "spoofedId");	if (verbose) {	}	sendMessage(i, message);	}	assertMessagesAreReceived2();	
messages s received closing down connections 

========================= activemq sample_2609 =========================

protected boolean configuredOk() throws IOException {	boolean configured = false;	if (ignoreAllWireFormatInfo) {	configured = true;	} else if (localWireFormatInfo != null && remoteWireFormatInfo != null) {	if (!ignoreRemoteWireFormat) {	if (LOG.isDebugEnabled()) {	
using min of local and remote 

if (!ignoreRemoteWireFormat) {	if (LOG.isDebugEnabled()) {	}	long readCheckTime = Math.min(localWireFormatInfo.getMaxInactivityDuration(), remoteWireFormatInfo.getMaxInactivityDuration());	long writeCheckTime = writeCheckValueFromReadCheck(readCheckTime);	setReadCheckTime(readCheckTime);	setInitialDelayTime(Math.min(localWireFormatInfo.getMaxInactivityDurationInitalDelay(), remoteWireFormatInfo.getMaxInactivityDurationInitalDelay()));	setWriteCheckTime(writeCheckTime);	} else {	if (LOG.isDebugEnabled()) {	
using local 

========================= activemq sample_142 =========================

MessageConsumer testConsumer = sess.createDurableSubscriber((Topic) testJmsDest, "durable2");	MessageProducer producer = sess.createProducer(createDestination("testing.durable.>"));	producer.send(sess.createTextMessage("hello!"));	org.apache.activemq.broker.region.Topic wildcardDest = (org.apache.activemq.broker.region.Topic) getDestination(brokerService, ActiveMQDestination.transform(wildcardJmsDest));	org.apache.activemq.broker.region.Topic testDest = (org.apache.activemq.broker.region.Topic) getDestination(brokerService, ActiveMQDestination.transform(testJmsDest));	wildcardConsumer.close();	testConsumer.close();	conn.close();	assertEquals(1, wildcardDest.getDurableTopicSubs().size());	assertEquals(2, testDest.getDurableTopicSubs().size());	
stopping broker 

========================= activemq sample_3673 =========================

final int maxConsumers = 2;	broker = createBroker(true);	broker.setPlugins(new BrokerPlugin[] {	new BrokerPluginSupport() {	int consumerCount;	public Subscription addConsumer(ConnectionContext context, final ConsumerInfo info) throws Exception {	if (++consumerCount == maxConsumers) {	context.setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
stopping broker on consumer 

cf.setWatchTopicAdvisories(false);	final ActiveMQConnection connection = (ActiveMQConnection) cf.createConnection();	connection.start();	final Session consumerSession = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	final Queue destination = consumerSession.createQueue(QUEUE_NAME + "?jms.consumer.prefetch=" + prefetch);	final Vector<TestConsumer> testConsumers = new Vector<TestConsumer>();	TestConsumer testConsumer = new TestConsumer(consumerSession, destination, connection);	testConsumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	
onmessage 

}	}	});	testConsumers.add(testConsumer);	produceMessage(consumerSession, destination, maxConsumers * prefetch);	assertTrue("add messages are delivered", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	int totalDelivered = 0;	for (TestConsumer testConsumer : testConsumers) {	long delivered = testConsumer.deliveredSize();	
delivered 

long delivered = testConsumer.deliveredSize();	totalDelivered += delivered;	}	return totalDelivered == maxConsumers * prefetch;	}	}));	final CountDownLatch shutdownConsumerAdded = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	
add last consumer 

}	}));	final CountDownLatch shutdownConsumerAdded = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	TestConsumer testConsumer = new TestConsumer(consumerSession, destination, connection);	testConsumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	
onmessage 

testConsumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	} catch (JMSException e) {	e.printStackTrace();	}	}	});	testConsumers.add(testConsumer);	shutdownConsumerAdded.countDown();	
done add last consumer 

});	broker.waitUntilStopped();	broker = createBroker(false, this.url);	broker.start();	assertTrue("consumer added through failover", shutdownConsumerAdded.await(30, TimeUnit.SECONDS));	assertTrue("after restart all messages are re dispatched", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	int totalDelivered = 0;	for (TestConsumer testConsumer : testConsumers) {	long delivered = testConsumer.deliveredSize();	
delivered 

long delivered = testConsumer.deliveredSize();	totalDelivered += delivered;	}	return totalDelivered == maxConsumers * prefetch;	}	}));	assertTrue("after restart each got prefetch amount", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	for (TestConsumer testConsumer : testConsumers) {	long delivered = testConsumer.deliveredSize();	
delivered 

final int maxConsumers = 4;	broker = createBroker(true);	broker.setPlugins(new BrokerPlugin[] {	new BrokerPluginSupport() {	int consumerCount;	public Subscription addConsumer(ConnectionContext context, final ConsumerInfo info) throws Exception {	if (++consumerCount == maxConsumers + (watchTopicAdvisories ? 1:0)) {	context.setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	
stopping broker on consumer 

final Vector<TestConsumer> testConsumers = new Vector<TestConsumer>();	for (int i=0; i<maxConsumers -1; i++) {	testConsumers.add(new TestConsumer(consumerSession, destination, connection));	}	produceMessage(consumerSession, destination, maxConsumers * prefetch);	assertTrue("add messages are dispatched", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	int totalUnconsumed = 0;	for (TestConsumer testConsumer : testConsumers) {	long unconsumed = testConsumer.unconsumedSize();	
unconsumed 

long unconsumed = testConsumer.unconsumedSize();	totalUnconsumed += unconsumed;	}	return totalUnconsumed == (maxConsumers-1) * prefetch;	}	}));	final CountDownLatch shutdownConsumerAdded = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	
add last consumer 

}	return totalUnconsumed == (maxConsumers-1) * prefetch;	}	}));	final CountDownLatch shutdownConsumerAdded = new CountDownLatch(1);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	testConsumers.add(new TestConsumer(consumerSession, destination, connection));	shutdownConsumerAdded.countDown();	
done add last consumer 

e.printStackTrace();	}	}	});	broker.waitUntilStopped();	assertTrue("add messages dispatched and unconsumed are cleaned up", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	int totalUnconsumed = 0;	for (TestConsumer testConsumer : testConsumers) {	long unconsumed = testConsumer.unconsumedSize();	
unconsumed 

}	}));	broker = createBroker(false, this.url);	broker.start();	assertTrue("consumer added through failover", shutdownConsumerAdded.await(30, TimeUnit.SECONDS));	assertTrue("after start all messages are re dispatched", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	int totalUnconsumed = 0;	for (TestConsumer testConsumer : testConsumers) {	long unconsumed = testConsumer.unconsumedSize();	
after restart unconsumed 

========================= activemq sample_2577 =========================

TimeUnit.SECONDS.sleep(5);	assertEquals(0, queueView.getInFlightCount());	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
dequeued count 

TimeUnit.SECONDS.sleep(5);	assertEquals(0, queueView.getInFlightCount());	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
dispatch count 

TimeUnit.SECONDS.sleep(5);	assertEquals(0, queueView.getInFlightCount());	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
enqueue count 

TimeUnit.SECONDS.sleep(5);	assertEquals(0, queueView.getInFlightCount());	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
expired count 

TimeUnit.SECONDS.sleep(5);	assertEquals(0, queueView.getInFlightCount());	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
inflight count 

assertEquals(0, queueView.getInFlightCount());	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	session.commit();	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
dequeued count 

assertEquals(0, queueView.getInFlightCount());	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	session.commit();	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
dispatch count 

assertEquals(0, queueView.getInFlightCount());	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	session.commit();	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
enqueue count 

assertEquals(0, queueView.getInFlightCount());	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	session.commit();	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
expired count 

assertEquals(0, queueView.getInFlightCount());	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	session.commit();	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
inflight count 

} else {	producer.send(session.createTextMessage());	}	}	TimeUnit.SECONDS.sleep(5);	final QueueViewMBean queueView = getProxyToQueueViewMBean();	assertEquals(200, queueView.getInFlightCount());	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	
acking message 

}	}));	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
dequeued count 

}	}));	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
dispatch count 

}	}));	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
enqueue count 

}	}));	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
expired count 

}	}));	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
inflight count 

}	}	TimeUnit.SECONDS.sleep(5);	final QueueViewMBean queueView = getProxyToQueueViewMBean();	assertEquals(200, queueView.getInFlightCount());	final AtomicInteger msgCount = new AtomicInteger();	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	if (msgCount.incrementAndGet() == 100) {	
acking message 

});	TimeUnit.SECONDS.sleep(5);	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	
acking message 

}	});	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
dequeued count 

}	});	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
dispatch count 

}	});	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
enqueue count 

}	});	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
expired count 

}	});	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
inflight count 

}	}));	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
dequeued count 

}	}));	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
dispatch count 

}	}));	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
enqueue count 

}	}));	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
expired count 

}	}));	for (int i = 0; i < 200; i++) {	producer.send(session.createTextMessage());	}	assertTrue("Inflight count should reach zero, currently: " + queueView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return queueView.getInFlightCount() == 0;	}	}));	
inflight count 

}	received.acknowledge();	};	assertEquals("got messages", messageCount + 1, messages.size());	ArrayList<Message> dlqMessages = new ArrayList<Message>();	while ((received = dlqConsumer.receive(1000)) != null) {	dlqMessages.add(received);	};	assertEquals("got dlq messages", data.length - 1, dlqMessages.size());	final QueueViewMBean queueView = getProxyToQueueViewMBean();	
dequeued count 

}	received.acknowledge();	};	assertEquals("got messages", messageCount + 1, messages.size());	ArrayList<Message> dlqMessages = new ArrayList<Message>();	while ((received = dlqConsumer.receive(1000)) != null) {	dlqMessages.add(received);	};	assertEquals("got dlq messages", data.length - 1, dlqMessages.size());	final QueueViewMBean queueView = getProxyToQueueViewMBean();	
dispatch count 

}	received.acknowledge();	};	assertEquals("got messages", messageCount + 1, messages.size());	ArrayList<Message> dlqMessages = new ArrayList<Message>();	while ((received = dlqConsumer.receive(1000)) != null) {	dlqMessages.add(received);	};	assertEquals("got dlq messages", data.length - 1, dlqMessages.size());	final QueueViewMBean queueView = getProxyToQueueViewMBean();	
enqueue count 

}	received.acknowledge();	};	assertEquals("got messages", messageCount + 1, messages.size());	ArrayList<Message> dlqMessages = new ArrayList<Message>();	while ((received = dlqConsumer.receive(1000)) != null) {	dlqMessages.add(received);	};	assertEquals("got dlq messages", data.length - 1, dlqMessages.size());	final QueueViewMBean queueView = getProxyToQueueViewMBean();	
expired count 

}	received.acknowledge();	};	assertEquals("got messages", messageCount + 1, messages.size());	ArrayList<Message> dlqMessages = new ArrayList<Message>();	while ((received = dlqConsumer.receive(1000)) != null) {	dlqMessages.add(received);	};	assertEquals("got dlq messages", data.length - 1, dlqMessages.size());	final QueueViewMBean queueView = getProxyToQueueViewMBean();	
inflight count 

========================= activemq sample_2824 =========================

public void setUp() throws Exception {	
starting 

public void tearDown() throws Exception {	if (broker != null) {	broker.stop();	broker.waitUntilStopped();	}	
finishing 

public void doTestRedelivery(String brokerUrl, boolean interleaveProducer) throws Exception {	
entering dotestredelivery interleaveproducer is 

{	AtomicInteger received = new AtomicInteger();	Map<String, Boolean> rolledback = new ConcurrentHashMap<String, Boolean>();	while (received.get() < nbMessages) {	Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(destinationName);	MessageConsumer consumer = session.createConsumer(destination);	TextMessage msg = (TextMessage) consumer.receive(6000000);	if (msg != null) {	if (msg != null && rolledback.put(msg.getText(), Boolean.TRUE) != null) {	
received message 

Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(destinationName);	MessageConsumer consumer = session.createConsumer(destination);	TextMessage msg = (TextMessage) consumer.receive(6000000);	if (msg != null) {	if (msg != null && rolledback.put(msg.getText(), Boolean.TRUE) != null) {	assertTrue(msg.getJMSRedelivered());	assertEquals(2, msg.getLongProperty("JMSXDeliveryCount"));	session.commit();	} else {	
rollback message id 

{	AtomicInteger received = new AtomicInteger();	Map<String, Boolean> rolledback = new ConcurrentHashMap<String, Boolean>();	Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(destinationName);	MessageConsumer consumer = session.createConsumer(destination);	while (received.get() < nbMessages) {	TextMessage msg = (TextMessage) consumer.receive(6000000);	if (msg != null) {	if (msg != null && rolledback.put(msg.getText(), Boolean.TRUE) != null) {	
received message 

Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(destinationName);	MessageConsumer consumer = session.createConsumer(destination);	while (received.get() < nbMessages) {	TextMessage msg = (TextMessage) consumer.receive(6000000);	if (msg != null) {	if (msg != null && rolledback.put(msg.getText(), Boolean.TRUE) != null) {	assertTrue(msg.getJMSRedelivered());	session.commit();	} else {	
rollback message id 

{	AtomicInteger received = new AtomicInteger();	Map<String, Boolean> rolledback = new ConcurrentHashMap<String, Boolean>();	Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(destinationName);	while (received.get() < nbMessages) {	MessageConsumer consumer = session.createConsumer(destination);	TextMessage msg = (TextMessage) consumer.receive(6000000);	if (msg != null) {	if (msg != null && rolledback.put(msg.getText(), Boolean.TRUE) != null) {	
received message 

Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(destinationName);	while (received.get() < nbMessages) {	MessageConsumer consumer = session.createConsumer(destination);	TextMessage msg = (TextMessage) consumer.receive(6000000);	if (msg != null) {	if (msg != null && rolledback.put(msg.getText(), Boolean.TRUE) != null) {	assertTrue(msg.getJMSRedelivered());	session.commit();	} else {	
rollback message id 

populateDestination(numMessages, destinationName, connection);	{	AtomicInteger received = new AtomicInteger();	final int maxRetries = new RedeliveryPolicy().getMaximumRedeliveries();	while (received.get() < maxRetries) {	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Destination destination = session.createQueue(destinationName);	MessageConsumer consumer = session.createConsumer(destination);	TextMessage msg = (TextMessage) consumer.receive(1000);	if (msg != null) {	
received message 

populateDestination(numMessages, destinationName, connection);	{	AtomicInteger received = new AtomicInteger();	final int maxRetries = new RedeliveryPolicy().getMaximumRedeliveries();	while (received.get() < maxRetries) {	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Destination destination = session.createQueue(destinationName);	MessageConsumer consumer = session.createConsumer(destination);	TextMessage msg = (TextMessage) consumer.receive(1000);	if (msg != null) {	
received message 

AtomicInteger received = new AtomicInteger();	final int maxRetries = new RedeliveryPolicy().getMaximumRedeliveries();	while (received.get() < maxRetries) {	connection = connectionFactory.createConnection();	connection.start();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Destination destination = session.createQueue(destinationName);	MessageConsumer consumer = session.createConsumer(destination);	TextMessage msg = (TextMessage) consumer.receive(2000);	if (msg != null) {	
received message 

========================= activemq sample_3736 =========================

public void testRemoveSubscriber() throws Exception {	stompConnect();	Connection connection = cf.createConnection("system", "manager");	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(new ActiveMQQueue(getQueueName()));	Message message = session.createTextMessage("Testas");	for (int idx = 0; idx < 2000; ++idx) {	producer.send(message);	
sending 

connection.close();	String connectFrame = "CONNECT\n" + "login:system\n" + "passcode:manager\n\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	stompConnection.receiveFrame();	String frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:client\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	int messagesCount = 0;	int count = 0;	while (count < 2) {	String receiveFrame = stompConnection.receiveFrame();	
received 

Thread.sleep(1000);	stompConnect();	connectFrame = "CONNECT\n" + "login:system\n" + "passcode:manager\n\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	stompConnection.receiveFrame();	frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:client\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	try {	while (count != 2000) {	String receiveFrame = stompConnection.receiveFrame();	
received 

String ackmessage = "ACK\n" + HEADER_MESSAGE_ID + ":" + messageId.trim() + "\n\n" + Stomp.NULL;	stompConnection.sendFrame(ackmessage);	++messagesCount;	++count;	}	} catch (IOException ex) {	ex.printStackTrace();	}	stompConnection.sendFrame("DISCONNECT\n\n");	stompConnection.close();	
total messages received 

========================= activemq sample_1422 =========================

public Transport compositeConfigure(Transport transport, WireFormat format, Map options) {	IntrospectionSupport.setProperties(transport, options);	final UdpTransport udpTransport = (UdpTransport)transport;	transport = new CommandJoiner(transport, asOpenWireFormat(format));	if (udpTransport.isTrace()) {	try {	transport = TransportLoggerSupport.createTransportLogger(transport);	} catch (Throwable e) {	
could not create transportlogger reason 

========================= activemq sample_67 =========================

setDirectory(getDefaultDataDirectory());	}	IOHelper.mkdirs(getDirectory());	try {	if (isPurgeStoreOnStartup()) {	getJournal().start();	getJournal().delete();	getJournal().close();	journal = null;	getPageFile().delete();	
persistence store purged 

ByteSequence sequence = toByteSequence(command);	Location location;	checkpointLock.readLock().lock();	try {	long start = System.currentTimeMillis();	location = onJournalStoreComplete == null ? journal.write(sequence, sync) : journal.write(sequence, onJournalStoreComplete);	long start2 = System.currentTimeMillis();	process(command, location);	long end = System.currentTimeMillis();	if (LOG_SLOW_ACCESS_TIME > 0 && end - start > LOG_SLOW_ACCESS_TIME) {	
slow kahadb access journal append took ms index update took ms 

checkpointLock.readLock().unlock();	}	if (after != null) {	after.run();	}	if (checkpointThread != null && !checkpointThread.isAlive()) {	startCheckpoint();	}	return location;	} catch (IOException ioe) {	
kahadb failed to store to journal 

protected void startCheckpoint() {	if (checkpointInterval == 0 && cleanupInterval == 0) {	
periodic checkpoint cleanup disabled will ocurr on clean shutdown restart 

protected void startCheckpoint() {	if (checkpointInterval == 0 && cleanupInterval == 0) {	return;	}	synchronized (checkpointThreadLock) {	boolean start = false;	if (checkpointThread == null) {	start = true;	} else if (!checkpointThread.isAlive()) {	start = true;	
kahadb recovering checkpoint thread after death 

checkpointCleanup(true);	lastCleanup = now;	lastCheckpoint = now;	} else if( checkpointInterval > 0 && (now - lastCheckpoint >= checkpointInterval )) {	checkpointCleanup(false);	lastCheckpoint = now;	}	}	} catch (InterruptedException e) {	} catch (IOException ioe) {	
checkpoint failed 

start = System.currentTimeMillis();	if (!opened.get()) {	return;	}	} finally {	this.indexLock.writeLock().unlock();	}	checkpointUpdate(cleanup);	long end = System.currentTimeMillis();	if (LOG_SLOW_ACCESS_TIME > 0 && end - start > LOG_SLOW_ACCESS_TIME) {	
slow kahadb access cleanup took 

========================= activemq sample_1770 =========================

ArrayList<CountDownFuture> pending_starts = new ArrayList<CountDownFuture>();	for(String dir: new String[]{"leveldb-node1", "leveldb-node2", "leveldb-node3"}) {	ElectingLevelDBStore store = createStoreNode();	store.setDirectory(new File(data_dir(), dir));	stores.add(store);	pending_starts.add(asyncStart(store));	}	CountDownFuture f = waitFor(30 * 1000, pending_starts.toArray(new CountDownFuture[pending_starts.size()]));	assertTrue(f!=null);	pending_starts.remove(f);	
making sure the other stores don t start 

}	}	assertNotNull(master);	HashSet<ElectingLevelDBStore> slaves = new HashSet<ElectingLevelDBStore>(stores);	slaves.remove(master);	ArrayList<String> expected_list = new ArrayList<String>();	MessageStore ms = master.createQueueMessageStore(new ActiveMQQueue("TEST"));	final int TOTAL = 500;	for (int i = 0; i < TOTAL; i++) {	if (i % ((int) (TOTAL * 0.10)) == 0) {	
done 

assertNotNull(master);	HashSet<ElectingLevelDBStore> slaves = new HashSet<ElectingLevelDBStore>(stores);	slaves.remove(master);	ArrayList<String> expected_list = new ArrayList<String>();	MessageStore ms = master.createQueueMessageStore(new ActiveMQQueue("TEST"));	final int TOTAL = 500;	for (int i = 0; i < TOTAL; i++) {	if (i % ((int) (TOTAL * 0.10)) == 0) {	}	if( i == 250 ) {	
checking master state 

HashSet<ElectingLevelDBStore> slaves = new HashSet<ElectingLevelDBStore>(stores);	slaves.remove(master);	ArrayList<String> expected_list = new ArrayList<String>();	MessageStore ms = master.createQueueMessageStore(new ActiveMQQueue("TEST"));	final int TOTAL = 500;	for (int i = 0; i < TOTAL; i++) {	if (i % ((int) (TOTAL * 0.10)) == 0) {	}	if( i == 250 ) {	assertEquals(expected_list, getMessages(ms));	
killing master 

slaves.remove(master);	ArrayList<String> expected_list = new ArrayList<String>();	MessageStore ms = master.createQueueMessageStore(new ActiveMQQueue("TEST"));	final int TOTAL = 500;	for (int i = 0; i < TOTAL; i++) {	if (i % ((int) (TOTAL * 0.10)) == 0) {	}	if( i == 250 ) {	assertEquals(expected_list, getMessages(ms));	master.stop();	
waiting for slave takeover 

}	}	assertNotNull(master);	slaves.remove(master);	ms = master.createQueueMessageStore(new ActiveMQQueue("TEST"));	}	String msgid = "m:" + i;	addMessage(ms, msgid);	expected_list.add(msgid);	}	
checking master state 

ms = master.createQueueMessageStore(new ActiveMQQueue("TEST"));	}	String msgid = "m:" + i;	addMessage(ms, msgid);	expected_list.add(msgid);	}	ArrayList<String> messagesInStore = getMessages(ms);	int index=0;	for (String id: expected_list) {	if (!id.equals(messagesInStore.get(index))) {	
mismatch for expected got 

ArrayList<CountDownFuture> pending_starts = new ArrayList<CountDownFuture>();	for (String dir : new String[]{"leveldb-node1", "leveldb-node2", "leveldb-node3"}) {	ElectingLevelDBStore store = createStoreNode();	store.setDirectory(new File(data_dir(), dir));	stores.add(store);	pending_starts.add(asyncStart(store));	}	CountDownFuture f = waitFor(30 * 1000, pending_starts.toArray(new CountDownFuture[pending_starts.size()]));	assertTrue(f != null);	pending_starts.remove(f);	
making sure the other stores don t start 

stores.add(store);	pending_starts.add(asyncStart(store));	}	CountDownFuture f = waitFor(30 * 1000, pending_starts.toArray(new CountDownFuture[pending_starts.size()]));	assertTrue(f != null);	pending_starts.remove(f);	Thread.sleep(5000);	for (CountDownFuture start : pending_starts) {	assertFalse(start.completed());	}	
shutting down zookeeper 

public void testAMQ5082() throws Throwable {	final ArrayList<ElectingLevelDBStore> stores = new ArrayList<ElectingLevelDBStore>();	
launching stores 

public void testAMQ5082() throws Throwable {	final ArrayList<ElectingLevelDBStore> stores = new ArrayList<ElectingLevelDBStore>();	for (String dir : new String[]{"leveldb-node1", "leveldb-node2", "leveldb-node3"}) {	ElectingLevelDBStore store = createStoreNode();	store.setDirectory(new File(data_dir(), dir));	stores.add(store);	asyncStart(store);	}	
waiting for stores to start 

public void testAMQ5082() throws Throwable {	final ArrayList<ElectingLevelDBStore> stores = new ArrayList<ElectingLevelDBStore>();	for (String dir : new String[]{"leveldb-node1", "leveldb-node2", "leveldb-node3"}) {	ElectingLevelDBStore store = createStoreNode();	store.setDirectory(new File(data_dir(), dir));	stores.add(store);	asyncStart(store);	}	Thread.sleep(30 * 1000);	
checking for a single master 

}	Thread.sleep(30 * 1000);	ElectingLevelDBStore master = null;	for (ElectingLevelDBStore store: stores) {	if (store.isMaster()) {	assertNull(master);	master = store;	}	}	assertNotNull(master);	
imposing i o wait on zookeeper connections waiting to confirm that quorum is not lost 

Thread.sleep(30 * 1000);	ElectingLevelDBStore master = null;	for (ElectingLevelDBStore store: stores) {	if (store.isMaster()) {	assertNull(master);	master = store;	}	}	assertNotNull(master);	this.connector.testHandle.setIOWaitMillis(1 * 1000, 30 * 1000);	
confirming that the quorum has not been lost 

master = store;	}	}	assertNotNull(master);	this.connector.testHandle.setIOWaitMillis(1 * 1000, 30 * 1000);	for (ElectingLevelDBStore store: stores) {	if (store.isMaster()) {	assertTrue(master == store);	}	}	
imposing i o wait on zookeeper connections waiting for quorum to be lost 

}	}	assertNotNull(master);	this.connector.testHandle.setIOWaitMillis(1 * 1000, 30 * 1000);	for (ElectingLevelDBStore store: stores) {	if (store.isMaster()) {	assertTrue(master == store);	}	}	this.connector.testHandle.setIOWaitMillis(11 * 1000, 30 * 1000);	
confirming that the quorum has been lost 

for (ElectingLevelDBStore store: stores) {	if (store.isMaster()) {	assertTrue(master == store);	}	}	this.connector.testHandle.setIOWaitMillis(11 * 1000, 30 * 1000);	for (ElectingLevelDBStore store: stores) {	assertFalse(store.isMaster());	}	master = null;	
lifting i o wait on zookeeper connections waiting for quorum to be re established 

if (store.isMaster()) {	assertTrue(master == store);	}	}	this.connector.testHandle.setIOWaitMillis(11 * 1000, 30 * 1000);	for (ElectingLevelDBStore store: stores) {	assertFalse(store.isMaster());	}	master = null;	this.connector.testHandle.setIOWaitMillis(0, 30 * 1000);	
checking for a single master 

========================= activemq sample_1265 =========================

public NetworkedSyncTest(String name) {	super(name);	
testcase started 

protected void setUp() throws Exception {	
setup called 

protected void setUp() throws Exception {	ClassPathXmlApplicationContext context1 = null;	BrokerFactoryBean brokerFactory = new BrokerFactoryBean(new ClassPathResource(config));	assertNotNull(brokerFactory);	try {	Thread.currentThread().setContextClassLoader( NetworkedSyncTest.class.getClassLoader());	context1 = new ClassPathXmlApplicationContext(config);	broker1 = (BrokerService) context1.getBean("broker1");	if (!broker1.isStarted()) {	
broker not yet started kicking it off now 

ClassPathXmlApplicationContext context1 = null;	BrokerFactoryBean brokerFactory = new BrokerFactoryBean(new ClassPathResource(config));	assertNotNull(brokerFactory);	try {	Thread.currentThread().setContextClassLoader( NetworkedSyncTest.class.getClassLoader());	context1 = new ClassPathXmlApplicationContext(config);	broker1 = (BrokerService) context1.getBean("broker1");	if (!broker1.isStarted()) {	broker1.start();	} else {	
broker already started not kicking it off a second time 

try {	Thread.currentThread().setContextClassLoader( NetworkedSyncTest.class.getClassLoader());	context1 = new ClassPathXmlApplicationContext(config);	broker1 = (BrokerService) context1.getBean("broker1");	if (!broker1.isStarted()) {	broker1.start();	} else {	broker1.waitUntilStopped();	}	} catch (Exception e) {	
error 

broker1.waitUntilStopped();	}	} catch (Exception e) {	throw e;	}	try {	Thread.currentThread().setContextClassLoader( NetworkedSyncTest.class.getClassLoader());	context1 = new ClassPathXmlApplicationContext(config);	broker2 = (BrokerService) context1.getBean("broker2");	if (!broker2.isStarted()) {	
broker not yet started kicking it off now 

} catch (Exception e) {	throw e;	}	try {	Thread.currentThread().setContextClassLoader( NetworkedSyncTest.class.getClassLoader());	context1 = new ClassPathXmlApplicationContext(config);	broker2 = (BrokerService) context1.getBean("broker2");	if (!broker2.isStarted()) {	broker2.start();	} else {	
broker already started not kicking it off a second time 

try {	Thread.currentThread().setContextClassLoader( NetworkedSyncTest.class.getClassLoader());	context1 = new ClassPathXmlApplicationContext(config);	broker2 = (BrokerService) context1.getBean("broker2");	if (!broker2.isStarted()) {	broker2.start();	} else {	broker2.waitUntilStopped();	}	} catch (Exception e) {	
error 

} else {	broker2.waitUntilStopped();	}	} catch (Exception e) {	throw e;	}	connector = broker1.addNetworkConnector(networkConnectorURL);	connector.setBrokerName(broker1.getBrokerName());	connector.setDuplex(true);	connector.start();	
network connector created 

protected void tearDown() throws Exception {	
teardown called 

protected void tearDown() throws Exception {	if (broker1 != null && broker1.isStarted()) {	
still running stopping it now 

protected void tearDown() throws Exception {	if (broker1 != null && broker1.isStarted()) {	broker1.stop();	} else {	
not running nothing to shutdown 

protected void tearDown() throws Exception {	if (broker1 != null && broker1.isStarted()) {	broker1.stop();	} else {	}	if (broker2 != null && broker2.isStarted()) {	
still running stopping it now 

protected void tearDown() throws Exception {	if (broker1 != null && broker1.isStarted()) {	broker1.stop();	} else {	}	if (broker2 != null && broker2.isStarted()) {	broker2.stop();	} else {	
not running nothing to shutdown 

public void testMessageExchange() throws Exception {	
testmessageexchange called 

}	} catch (Exception ex) {	LOG.error(ex.toString());	return;	} finally {	try {	if (producer != null) producer.close();	if (session != null) session.close();	if (connection != null) connection.close();	} catch (Exception e) {	
problem closing down jms objects 

session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createTopic("TEST.FOO");	consumer = session.createDurableSubscriber((Topic) destination,"tmielke");	long counter = 0;	for (int i = 0; i < NetworkedSyncTest.MESSAGE_COUNT; i++) {	Message message2 = consumer.receive();	if (message2 instanceof TextMessage) {	TextMessage textMessage = (TextMessage) message2;	textMessage.getText();	} else {	
received message of unsupported type expecting textmessage 

Message message2 = consumer.receive();	if (message2 instanceof TextMessage) {	TextMessage textMessage = (TextMessage) message2;	textMessage.getText();	} else {	}	counter++;	if ((counter % 1000) == 0) LOG.info("received " + counter + " messages");	}	} catch (Exception e) {	
error in consumer 

if ((counter % 1000) == 0) LOG.info("received " + counter + " messages");	}	} catch (Exception e) {	return;	} finally {	try {	if (consumer != null) consumer.close();	if (session != null) session.close();	if (connection != null) connection.close();	} catch (Exception ex) {	
error closing down jms objects 

========================= activemq sample_3521 =========================

public void testAnonymousUserConnect() throws Exception {	MQTT mqtt = createMQTTConnection();	mqtt.setCleanSession(true);	mqtt.setUserName((String)null);	mqtt.setPassword((String)null);	final BlockingConnection connection = mqtt.blockingConnection();	connection.connect();	
connected as anonymous client 

public void testBadUserNameOrPasswordGetsConnAckWithErrorCode() throws Exception {	MQTT mqttPub = createMQTTConnection("pub", true);	mqttPub.setUserName("foo");	mqttPub.setPassword("bar");	final AtomicBoolean failed = new AtomicBoolean();	mqttPub.setTracer(new Tracer() {	public void onReceive(MQTTFrame frame) {	
client received 

} catch (ProtocolException e) {	failed.set(true);	fail("Error decoding publish " + e.getMessage());	} catch (Throwable err) {	failed.set(true);	throw err;	}	}	}	public void onSend(MQTTFrame frame) {	
client sent 

public void testInvalidClientIdGetCorrectErrorCode() throws Exception {	MQTT mqttPub = createMQTTConnection("invalid", true);	final AtomicInteger errorCode = new AtomicInteger();	mqttPub.setTracer(new Tracer() {	public void onReceive(MQTTFrame frame) {	
client received 

connAck.decode(frame);	LOG.info("{}", connAck);	errorCode.set(connAck.code().ordinal());	assertEquals(CONNACK.Code.CONNECTION_REFUSED_IDENTIFIER_REJECTED, connAck.code());	} catch (ProtocolException e) {	fail("Error decoding publish " + e.getMessage());	}	}	}	public void onSend(MQTTFrame frame) {	
client sent 

public void testBadCredentialExceptionGetsCorrectErrorCode() throws Exception {	MQTT mqttPub = createMQTTConnection("bad-credential", true);	mqttPub.setUserName("admin");	mqttPub.setPassword("admin");	final AtomicInteger errorCode = new AtomicInteger();	mqttPub.setTracer(new Tracer() {	public void onReceive(MQTTFrame frame) {	
client received 

connAck.decode(frame);	LOG.info("{}", connAck);	errorCode.set(connAck.code().ordinal());	assertEquals(CONNACK.Code.CONNECTION_REFUSED_BAD_USERNAME_OR_PASSWORD, connAck.code());	} catch (ProtocolException e) {	fail("Error decoding publish " + e.getMessage());	}	}	}	public void onSend(MQTTFrame frame) {	
client sent 

protected void createPlugins(List<BrokerPlugin> plugins) throws Exception {	BrokerPlugin failOnSpecificConditionsPlugin = new BrokerPlugin() {	public Broker installPlugin(Broker broker) throws Exception {	return new BrokerFilter(broker) {	public void addConnection(ConnectionContext context, ConnectionInfo info) throws Exception {	String clientId = info.getClientId();	if (clientId != null && !clientId.isEmpty()) {	if (clientId.equalsIgnoreCase("invalid")) {	
client id was invalid 

protected void createPlugins(List<BrokerPlugin> plugins) throws Exception {	BrokerPlugin failOnSpecificConditionsPlugin = new BrokerPlugin() {	public Broker installPlugin(Broker broker) throws Exception {	return new BrokerFilter(broker) {	public void addConnection(ConnectionContext context, ConnectionInfo info) throws Exception {	String clientId = info.getClientId();	if (clientId != null && !clientId.isEmpty()) {	if (clientId.equalsIgnoreCase("invalid")) {	throw new InvalidClientIDException("Bad client Id");	} else if (clientId.equalsIgnoreCase("bad-credential")) {	
user name was invalid 

========================= activemq sample_882 =========================

public void addMessage(final ConnectionContext context, final Message message) throws IOException {	final MessageId id = message.getMessageId();	final boolean debug = LOG.isDebugEnabled();	message.incrementReferenceCount();	final RecordLocation location = peristenceAdapter.writeCommand(message, message.isResponseRequired());	if (!context.isInTransaction()) {	if (debug) {	
journalled message add for at 

final MessageId id = message.getMessageId();	final boolean debug = LOG.isDebugEnabled();	message.incrementReferenceCount();	final RecordLocation location = peristenceAdapter.writeCommand(message, message.isResponseRequired());	if (!context.isInTransaction()) {	if (debug) {	}	addMessage(context, message, location);	} else {	if (debug) {	
journalled transacted message add for at 

} else {	if (debug) {	}	synchronized (this) {	inFlightTxLocations.add(location);	}	transactionStore.addMessage(this, message, location);	context.getTransaction().addSynchronization(new Synchronization() {	public void afterCommit() throws Exception {	if (debug) {	
transacted message add commit for at 

public void afterCommit() throws Exception {	if (debug) {	}	synchronized (JournalMessageStore.this) {	inFlightTxLocations.remove(location);	addMessage(context, message, location);	}	}	public void afterRollback() throws Exception {	if (debug) {	
transacted message add rollback for at 

public void replayAddMessage(ConnectionContext context, Message message) {	try {	Message t = longTermStore.getMessage(message.getMessageId());	if (t == null) {	longTermStore.addMessage(context, message);	}	} catch (Throwable e) {	
could not replay add for message message may have already been added reason 

public void removeMessage(ConnectionContext context, final MessageAck ack) throws IOException {	final boolean debug = LOG.isDebugEnabled();	JournalQueueAck remove = new JournalQueueAck();	remove.setDestination(destination);	remove.setMessageAck(ack);	final RecordLocation location = peristenceAdapter.writeCommand(remove, ack.isResponseRequired());	if (!context.isInTransaction()) {	if (debug) {	
journalled message remove for at 

JournalQueueAck remove = new JournalQueueAck();	remove.setDestination(destination);	remove.setMessageAck(ack);	final RecordLocation location = peristenceAdapter.writeCommand(remove, ack.isResponseRequired());	if (!context.isInTransaction()) {	if (debug) {	}	removeMessage(ack, location);	} else {	if (debug) {	
journalled transacted message remove for at 

} else {	if (debug) {	}	synchronized (this) {	inFlightTxLocations.add(location);	}	transactionStore.removeMessage(this, ack, location);	context.getTransaction().addSynchronization(new Synchronization() {	public void afterCommit() throws Exception {	if (debug) {	
transacted message remove commit for at 

public void afterCommit() throws Exception {	if (debug) {	}	synchronized (JournalMessageStore.this) {	inFlightTxLocations.remove(location);	removeMessage(ack, location);	}	}	public void afterRollback() throws Exception {	if (debug) {	
transacted message remove rollback for at 

public void replayRemoveMessage(ConnectionContext context, MessageAck messageAck) {	try {	Message t = longTermStore.getMessage(messageAck.getLastMessageId());	if (t != null) {	longTermStore.removeMessage(context, messageAck);	}	} catch (Throwable e) {	
could not replay acknowledge for message message may have already been acknowledged reason 

int size = 0;	PersistenceAdapter persitanceAdapter = transactionTemplate.getPersistenceAdapter();	ConnectionContext context = transactionTemplate.getContext();	synchronized (JournalMessageStore.this) {	Iterator<Message> iterator = cpAddedMessageIds.values().iterator();	while (iterator.hasNext()) {	Message message = iterator.next();	try {	longTermStore.addMessage(context, message);	} catch (Throwable e) {	
message could not be added to long term store 

}	}	persitanceAdapter.commitTransaction(context);	persitanceAdapter.beginTransaction(context);	Iterator<MessageAck> iterator = cpRemovedMessageLocations.iterator();	while (iterator.hasNext()) {	try {	MessageAck ack = iterator.next();	longTermStore.removeMessage(transactionTemplate.getContext(), ack);	} catch (Throwable e) {	
message could not be removed from long term store 

========================= activemq sample_928 =========================

public void testDuplicateMessage() throws Exception {	
testing for duplicate messages 

public void testDuplicateMessage() throws Exception {	ExecutorService producers = Executors.newFixedThreadPool(NUM_PRODUCERS);	ExecutorService consumers = Executors.newFixedThreadPool(NUM_CONSUMERS);	createOpenwireClients(producers, consumers);	
all producers and consumers got started awaiting their termination 

public void testDuplicateMessage() throws Exception {	ExecutorService producers = Executors.newFixedThreadPool(NUM_PRODUCERS);	ExecutorService consumers = Executors.newFixedThreadPool(NUM_CONSUMERS);	createOpenwireClients(producers, consumers);	producersFinished.await(100, TimeUnit.MINUTES);	
all producers have terminated remaining to send sent 

public void testDuplicateMessage() throws Exception {	ExecutorService producers = Executors.newFixedThreadPool(NUM_PRODUCERS);	ExecutorService consumers = Executors.newFixedThreadPool(NUM_CONSUMERS);	createOpenwireClients(producers, consumers);	producersFinished.await(100, TimeUnit.MINUTES);	consumersFinished.await(100, TimeUnit.MINUTES);	
all consumers have terminated 

protected void createOpenwireClients(ExecutorService producers, ExecutorService consumers) {	for (int i = 0; i < NUM_CONSUMERS; i++) {	
creating consumer for destination 

consumers.submit(consumer);	synchronized(consumer.init) {	try {	consumer.init.wait();	} catch (InterruptedException e) {	LOG.error(e.toString(), e);	}	}	}	for (int i = 0; i < NUM_PRODUCERS; i++) {	
creating producer for destination 

stringBuilder.append("Message: ");	stringBuilder.append(counter);	for (int j = 0; j < (msgSize / 10); j++) {	stringBuilder.append("XXXXXXXXXX");	}	String text = stringBuilder.toString();	TextMessage message = session.createTextMessage(text);	while (totalMessagesToSend.decrementAndGet() >= 0) {	producer.send(message);	totalMessagesSent.incrementAndGet();	
sent message 

} finally {	try {	if (connection != null) {	connection.close();	}	} catch (Exception ignored) {	} finally {	producersFinished.countDown();	}	}	
closing producer for 

consumer = session.createConsumer(destination);	synchronized (init) {	init.notifyAll();	}	long counter = 0;	while (totalReceived.get() < NUM_MSGS) {	Message message2 = consumer.receive(5000);	if (message2 instanceof TextMessage) {	TextMessage textMessage = (TextMessage) message2;	String text = textMessage.getText();	
received 

synchronized (init) {	init.notifyAll();	}	long counter = 0;	while (totalReceived.get() < NUM_MSGS) {	Message message2 = consumer.receive(5000);	if (message2 instanceof TextMessage) {	TextMessage textMessage = (TextMessage) message2;	String text = textMessage.getText();	} else if (totalReceived.get() < NUM_MSGS) {	
received message of unsupported type expecting textmessage count 

break;	}	if (message2 != null) {	counter++;	totalReceived.incrementAndGet();	if ((counter % 10000) == 0) log.info("received " + counter + " messages");	Thread.sleep(CONSUMER_SLEEP);	}	}	} catch (Exception e) {	
error in consumer 

========================= activemq sample_2760 =========================

String brokerStamp = (String)messageDispatch.getMessage().getProperty(getStampProperty());	if (brokerStamp == null) {	brokerStamp = getBrokerName();	} else {	brokerStamp += "," + getBrokerName();	}	messageDispatch.getMessage().setProperty(getStampProperty(), brokerStamp);	messageDispatch.getMessage().setMarshalledProperties(null);	}	} catch (IOException ioe) {	
setting broker property failed 

========================= activemq sample_3872 =========================

protected void restartBroker(boolean whackIndex, boolean forceRecoverIndex) throws Exception {	if (broker != null) {	broker.stop();	broker.waitUntilStopped();	}	if (whackIndex) {	File indexToDelete = new File(brokerDataDir, "db.data");	
whacking index 

if (delete) {	IOHelper.deleteChildren(broker.getPersistenceAdapter().getDirectory());	IOHelper.delete(broker.getPersistenceAdapter().getDirectory());	}	broker.setPersistent(true);	broker.setUseJmx(true);	broker.addConnector("tcp: configurePersistence(broker, forceRecoverIndex);	connectionUri = "vm: cf = new ActiveMQConnectionFactory(connectionUri);	broker.start();	brokerDataDir = broker.getPersistenceAdapter().getDirectory();	
starting broker 

private void corruptBatchCheckSumSplash(int id) throws Exception{	Collection<DataFile> files = ((KahaDBPersistenceAdapter) broker.getPersistenceAdapter()).getStore().getJournal().getFileMap().values();	DataFile dataFile = (DataFile) files.toArray()[0];	RecoverableRandomAccessFile randomAccessFile = dataFile.openRandomAccessFile();	ArrayList<Integer> batchPositions = findBatch(randomAccessFile, Integer.MAX_VALUE);	
batch positions 

private void corruptBatchCheckSumSplash(int id) throws Exception{	Collection<DataFile> files = ((KahaDBPersistenceAdapter) broker.getPersistenceAdapter()).getStore().getJournal().getFileMap().values();	DataFile dataFile = (DataFile) files.toArray()[0];	RecoverableRandomAccessFile randomAccessFile = dataFile.openRandomAccessFile();	ArrayList<Integer> batchPositions = findBatch(randomAccessFile, Integer.MAX_VALUE);	int pos = batchPositions.get(1);	
corrupting checksum and size to push it past eof of batch record at 

Collection<DataFile> files = ((KahaDBPersistenceAdapter) broker.getPersistenceAdapter()).getStore().getJournal().getFileMap().values();	DataFile dataFile = (DataFile) files.toArray()[0];	RecoverableRandomAccessFile randomAccessFile = dataFile.openRandomAccessFile();	ArrayList<Integer> batchPositions = findBatch(randomAccessFile, Integer.MAX_VALUE);	int pos = batchPositions.get(1);	randomAccessFile.seek(pos + Journal.BATCH_CONTROL_RECORD_HEADER.length + 4);	randomAccessFile.writeLong(0l);	randomAccessFile.seek(pos + Journal.BATCH_CONTROL_RECORD_SIZE);	int size = randomAccessFile.readInt();	byte type = randomAccessFile.readByte();	
read size type 

RecoverableRandomAccessFile randomAccessFile = dataFile.openRandomAccessFile();	ArrayList<Integer> batchPositions = findBatch(randomAccessFile, Integer.MAX_VALUE);	int pos = batchPositions.get(1);	randomAccessFile.seek(pos + Journal.BATCH_CONTROL_RECORD_HEADER.length + 4);	randomAccessFile.writeLong(0l);	randomAccessFile.seek(pos + Journal.BATCH_CONTROL_RECORD_SIZE);	int size = randomAccessFile.readInt();	byte type = randomAccessFile.readByte();	randomAccessFile.seek(pos + Journal.BATCH_CONTROL_RECORD_SIZE);	size -= 1;	
rewrite incorrect location size as 

private void corruptBatchEndEof(int id) throws Exception{	Collection<DataFile> files = ((KahaDBPersistenceAdapter) broker.getPersistenceAdapter()).getStore().getJournal().getFileMap().values();	DataFile dataFile = (DataFile) files.toArray()[id];	RecoverableRandomAccessFile randomAccessFile = dataFile.openRandomAccessFile();	ArrayList<Integer> batchPositions = findBatch(randomAccessFile, Integer.MAX_VALUE);	int pos = batchPositions.get(batchPositions.size() - 3);	
corrupting checksum and size to push it past eof of batch record at 

========================= activemq sample_1727 =========================

closing.set(false);	}	}	}	} finally {	try {	if (executor != null) {	ThreadPoolUtils.shutdown(executor);	}	} catch (Throwable e) {	
error shutting down thread pool this exception will be ignored 

exception = er.getException();	}	} catch (Exception e) {	exception = e;	}	if(exception!=null) {	if ( exception instanceof JMSException) {	onComplete.onException((JMSException) exception);	} else {	if (isClosed()||closing.get()) {	
received an exception but connection is closing 

if(exception!=null) {	if ( exception instanceof JMSException) {	onComplete.onException((JMSException) exception);	} else {	if (isClosed()||closing.get()) {	}	JMSException jmsEx = null;	try {	jmsEx = JMSExceptionSupport.create(exception);	} catch(Throwable e) {	
caught an exception trying to create a jmsexception for 

throw new ConnectionClosedException();	} else {	try {	Response response = (Response)(timeout > 0 ? this.transport.request(command, timeout) : this.transport.request(command));	if (response.isException()) {	ExceptionResponse er = (ExceptionResponse)response;	if (er.getException() instanceof JMSException) {	throw (JMSException)er.getException();	} else {	if (isClosed()||closing.get()) {	
received an exception but connection is closing 

ExceptionResponse er = (ExceptionResponse)response;	if (er.getException() instanceof JMSException) {	throw (JMSException)er.getException();	} else {	if (isClosed()||closing.get()) {	}	JMSException jmsEx = null;	try {	jmsEx = JMSExceptionSupport.create(er.getException());	} catch(Throwable e) {	
caught an exception trying to create a jmsexception for 

msg = msg.copy();	msg.setReadOnlyBody(true);	msg.setReadOnlyProperties(true);	msg.setRedeliveryCounter(md.getRedeliveryCounter());	msg.setConnection(ActiveMQConnection.this);	msg.setMemoryUsage(null);	md.setMessage(msg);	}	dispatcher.dispatch(md);	} else {	
no dispatcher for in 

public void onClientInternalException(final Throwable error) {	if ( !closed.get() && !closing.get() ) {	if ( this.clientInternalExceptionListener != null ) {	executor.execute(new Runnable() {	public void run() {	ActiveMQConnection.this.clientInternalExceptionListener.onException(error);	}	});	} else {	
async client internal exception occurred with no exception listener registered 

if (!(error instanceof JMSException)) {	error = JMSExceptionSupport.create(error);	}	final JMSException e = (JMSException)error;	executor.execute(new Runnable() {	public void run() {	ActiveMQConnection.this.exceptionListener.onException(e);	}	});	} else {	
async exception with no exception listener 

onAsyncException(error);	if (!closed.get() && !closing.get()) {	executor.execute(new Runnable() {	public void run() {	transportFailed(error);	ServiceSupport.dispose(ActiveMQConnection.this.transport);	brokerInfoReceived.countDown();	try {	doCleanup(true);	} catch (JMSException e) {	
exception during connection cleanup 

transportInterruptionProcessingComplete.set(1);	for (Iterator<ActiveMQSession> i = this.sessions.iterator(); i.hasNext();) {	ActiveMQSession s = i.next();	s.clearMessagesInProgress(transportInterruptionProcessingComplete);	}	for (ActiveMQConnectionConsumer connectionConsumer : this.connectionConsumers) {	connectionConsumer.clearMessagesInProgress(transportInterruptionProcessingComplete);	}	if (transportInterruptionProcessingComplete.decrementAndGet() > 0) {	if (LOG.isDebugEnabled()) {	
transport interrupted processing required dispatchers 

protected void waitForTransportInterruptionProcessingToComplete() throws InterruptedException {	if (!closed.get() && !transportFailed.get() && transportInterruptionProcessingComplete.get()>0) {	
dispatch with outstanding dispatch interruption processing count 

private void signalInterruptionProcessingComplete() {	if (LOG.isDebugEnabled()) {	
transportinterruptionprocessingcomplete for 

private void signalInterruptionProcessingComplete() {	if (LOG.isDebugEnabled()) {	}	FailoverTransport failoverTransport = transport.narrow(FailoverTransport.class);	if (failoverTransport != null) {	failoverTransport.connectionInterruptProcessingComplete(this.getConnectionInfo().getConnectionId());	if (LOG.isDebugEnabled()) {	
notified failover transport of interruption completion for 

private void signalInterruptionProcessingNeeded() {	FailoverTransport failoverTransport = transport.narrow(FailoverTransport.class);	if (failoverTransport != null) {	failoverTransport.getStateTracker().transportInterrupted(this.getConnectionInfo().getConnectionId());	if (LOG.isDebugEnabled()) {	
notified failover transport of pending interruption processing for 

========================= activemq sample_705 =========================

checkClosed();	final ClientFuture request = new ClientFuture();	session.getScheduler().execute(new Runnable() {	public void run() {	checkClosed();	long timeoutMills = unit.toMillis(timeout);	try {	LOG.trace("Pull on Receiver {} with timeout = {}", getSubscriptionName(), timeoutMills);	if (timeoutMills < 0) {	if (getEndpoint().getCredit() == 0) {	
receiver granting additional credit for pull 

long timeoutMills = unit.toMillis(timeout);	try {	LOG.trace("Pull on Receiver {} with timeout = {}", getSubscriptionName(), timeoutMills);	if (timeoutMills < 0) {	if (getEndpoint().getCredit() == 0) {	getEndpoint().flow(1);	}	pullRequest = request;	} else if (timeoutMills == 0) {	if (getEndpoint().getCredit() == 0){	
receiver granting additional credit for pull 

getEndpoint().flow(1);	}	pullRequest = request;	} else if (timeoutMills == 0) {	if (getEndpoint().getCredit() == 0){	getEndpoint().flow(1);	}	stop(request);	} else if (timeoutMills > 0) {	if (getEndpoint().getCredit() == 0) {	
receiver granting additional credit for pull 

public void processDeliveryUpdates(AmqpConnection connection) throws IOException {	Delivery incoming = null;	do {	incoming = getEndpoint().current();	if (incoming != null) {	if(incoming.isReadable() && !incoming.isPartial()) {	
has incoming message s 

incoming = getEndpoint().current();	if (incoming != null) {	if(incoming.isReadable() && !incoming.isPartial()) {	try {	processDelivery(incoming);	} catch (Exception e) {	throw IOExceptionSupport.create(e);	}	getEndpoint().advance();	} else {	
has a partial incoming message s deferring 

private void processDelivery(Delivery incoming) throws Exception {	doDeliveryInspection(incoming);	Message message = null;	try {	message = decodeIncomingMessage(incoming);	} catch (Exception e) {	
error on transform 

request.onSuccess();	} else {	stopRequest = request;	}	} else {	stopRequest = request;	receiver.drain(0);	if (getDrainTimeout() > 0) {	final ScheduledFuture<?> future = getSession().getScheduler().schedule(new Runnable() {	public void run() {	
consumer drain request timed out 

private void stopOnSchedule(long timeout, final AsyncResult request) {	
receiver scheduling stop 

private void stopOnSchedule(long timeout, final AsyncResult request) {	final ScheduledFuture<?> future = getSession().getScheduler().schedule(new Runnable() {	public void run() {	
receiver running scheduled stop 

========================= activemq sample_1662 =========================

message = message.copy();	}	message.setDestination(destination.getActiveMQDestination());	message.setMemoryUsage(null);	super.send(context, message);	}	};	}	}	catch (Exception e) {	
failed to lookup the mirror destination for 

public void remove(Destination destination) {	if (brokerService == null) {	throw new IllegalArgumentException("No brokerService injected!");	}	ActiveMQDestination topic = getMirrorTopic(destination.getActiveMQDestination());	if (topic != null) {	try {	brokerService.removeDestination(topic);	} catch (Exception e) {	
failed to remove mirror destination for 

========================= activemq sample_4030 =========================

public void execute() throws MojoExecutionException {	if (skip) {	
skipped execution of activemq broker 

public void execute() throws MojoExecutionException {	if (skip) {	return;	}	addActiveMQSystemProperties();	
loading broker configuri 

public void execute() throws MojoExecutionException {	if (skip) {	return;	}	addActiveMQSystemProperties();	if (this.xBeanFileResolver.isXBeanFile(configUri)) {	
configuri before transformation 

public void execute() throws MojoExecutionException {	if (skip) {	return;	}	addActiveMQSystemProperties();	if (this.xBeanFileResolver.isXBeanFile(configUri)) {	configUri = this.xBeanFileResolver.toUrlCompliantAbsolutePath(configUri);	
configuri after transformation 

public void execute() throws MojoExecutionException {	if (skip) {	return;	}	addActiveMQSystemProperties();	if (this.xBeanFileResolver.isXBeanFile(configUri)) {	configUri = this.xBeanFileResolver.toUrlCompliantAbsolutePath(configUri);	}	this.useBrokerManager().start(fork, configUri);	this.registerTransportConnectorUris();	
started the activemq broker 

========================= activemq sample_1232 =========================

assertTrue("Should have no durables.", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return brokerService.getAdminView().getDurableTopicSubscribers().length == 0;	}	}));	assertTrue("Should have an inactive sub.", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return brokerService.getAdminView().getInactiveDurableTopicSubscribers().length == 1;	}	}));	
testing that updated selector subscription does get any messages 

========================= activemq sample_3599 =========================

protected void doStop(ServiceStopper stopper) throws Exception {	for (InMemoryJobScheduler scheduler : schedulers.values()) {	try {	scheduler.stop();	} catch (Exception e) {	
failed to stop scheduler 

protected void doStart() throws Exception {	for (InMemoryJobScheduler scheduler : schedulers.values()) {	try {	scheduler.start();	} catch (Exception e) {	
failed to start scheduler 

public JobScheduler getJobScheduler(String name) throws Exception {	this.lock.lock();	try {	InMemoryJobScheduler result = this.schedulers.get(name);	if (result == null) {	
creating new in memory scheduler 

public boolean removeJobScheduler(String name) throws Exception {	boolean result = false;	this.lock.lock();	try {	InMemoryJobScheduler scheduler = this.schedulers.remove(name);	result = scheduler != null;	if (result) {	
removing in memory job scheduler 

========================= activemq sample_3960 =========================

if (buildBackup) {	buildBackups();	if (priorityBackup && !connectedToPriority) {	try {	doDelay();	if (reconnectTask == null) {	return true;	}	reconnectTask.wakeup();	} catch (InterruptedException e) {	
reconnect task has been interrupted 

}	}	} else {	buildBackup = true;	try {	if (reconnectTask == null) {	return true;	}	reconnectTask.wakeup();	} catch (InterruptedException e) {	
reconnect task has been interrupted 

public final void handleTransportFailure(Transport failed, IOException e) throws InterruptedException {	if (shuttingDown) {	return;	}	if (LOG.isTraceEnabled()) {	
handletransportfailure 

if (transport != null) {	disposeTransport(transport);	}	}	synchronized (reconnectMutex) {	if (transport != null && connectedTransport.get() == null) {	boolean reconnectOk = false;	if (canReconnect()) {	reconnectOk = true;	}	
transport failed attempting to automatically reconnect not 

public final void handleConnectionControl(ConnectionControl control) {	String reconnectStr = control.getReconnectTo();	if (LOG.isTraceEnabled()) {	
received connectioncontrol 

String reconnectStr = control.getReconnectTo();	if (LOG.isTraceEnabled()) {	}	if (reconnectStr != null) {	reconnectStr = reconnectStr.trim();	if (reconnectStr.length() > 0) {	try {	URI uri = new URI(reconnectStr);	if (isReconnectSupported()) {	reconnect(uri);	
reconnected to 

}	if (reconnectStr != null) {	reconnectStr = reconnectStr.trim();	if (reconnectStr.length() > 0) {	try {	URI uri = new URI(reconnectStr);	if (isReconnectSupported()) {	reconnect(uri);	}	} catch (Exception e) {	
failed to handle connectioncontrol reconnect to 

newTransports = newTransports.trim();	if (newTransports.length() > 0 && isUpdateURIsSupported()) {	List<URI> list = new ArrayList<URI>();	StringTokenizer tokenizer = new StringTokenizer(newTransports, ",");	while (tokenizer.hasMoreTokens()) {	String str = tokenizer.nextToken();	try {	URI uri = new URI(str);	list.add(uri);	} catch (Exception e) {	
failed to parse broker address 

try {	URI uri = new URI(str);	list.add(uri);	} catch (Exception e) {	}	}	if (list.isEmpty() == false) {	try {	updateURIs(rebalance, list.toArray(new URI[list.size()]));	} catch (IOException e) {	
failed to update transport uri s from 

public void start() throws Exception {	synchronized (reconnectMutex) {	
started 

public void stop() throws Exception {	Transport transportToStop = null;	List<Transport> backupsToStop = new ArrayList<Transport>(backups.size());	try {	synchronized (reconnectMutex) {	if (LOG.isDebugEnabled()) {	
stopped 

Transport transport = backup.getTransport();	if (transport != null) {	transport.setTransportListener(disposedListener);	backupsToStop.add(transport);	}	}	backups.clear();	}	for (Transport transport : backupsToStop) {	try {	
stopped backup 

public void setPriorityURIs(String priorityURIs) {	StringTokenizer tokenizer = new StringTokenizer(priorityURIs, ",");	while (tokenizer.hasMoreTokens()) {	String str = tokenizer.nextToken();	try {	URI uri = new URI(str);	priorityList.add(uri);	} catch (Exception e) {	
failed to parse broker address 

}	return;	}	}	for (int i = 0; !disposed; i++) {	try {	Transport transport = connectedTransport.get();	long start = System.currentTimeMillis();	boolean timedout = false;	while (transport == null && !disposed && connectionFailure == null && !Thread.currentThread().isInterrupted() && willReconnect()) {	
waiting for transport to reconnect 

}	for (int i = 0; !disposed; i++) {	try {	Transport transport = connectedTransport.get();	long start = System.currentTimeMillis();	boolean timedout = false;	while (transport == null && !disposed && connectionFailure == null && !Thread.currentThread().isInterrupted() && willReconnect()) {	long end = System.currentTimeMillis();	if (command.isMessage() && timeout > 0 && (end - start > timeout)) {	timedout = true;	
failover timed out after ms 

while (transport == null && !disposed && connectionFailure == null && !Thread.currentThread().isInterrupted() && willReconnect()) {	long end = System.currentTimeMillis();	if (command.isMessage() && timeout > 0 && (end - start > timeout)) {	timedout = true;	break;	}	try {	reconnectMutex.wait(100);	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	
interupted 

error = new IOException("Reconnect attempts of " + maxReconnectAttempts + " exceeded");	} else {	error = new IOException("Unexpected failure.");	}	break;	}	Tracked tracked = null;	try {	tracked = stateTracker.track(command);	} catch (IOException ioe) {	
cannot track the command 

if (command.isShutdownInfo()) {	shuttingDown = true;	}	} catch (IOException e) {	if (tracked == null && canReconnect()) {	if (command.isResponseRequired()) {	requestMap.remove(Integer.valueOf(command.getCommandId()));	}	throw e;	} else {	
send oneway attempt failed for command 

if (command.isResponseRequired()) {	requestMap.remove(Integer.valueOf(command.getCommandId()));	}	throw e;	} else {	handleTransportFailure(e);	}	}	return;	} catch (IOException e) {	
send oneway attempt failed for command 

public void add(boolean rebalance, String u) {	try {	URI newURI = new URI(u);	if (contains(newURI) == false) {	uris.add(newURI);	reconnect(rebalance);	}	} catch (Exception e) {	
failed to parse uri 

public void reconnect(boolean rebalance) {	synchronized (reconnectMutex) {	if (started) {	if (rebalance) {	doRebalance = true;	}	
waking up reconnect task 

if (started) {	if (rebalance) {	doRebalance = true;	}	try {	reconnectTask.wakeup();	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	}	} else {	
reconnect was triggered but transport is not started yet wait for start to connect the transport 

for (int i = 0; i < l.size(); i++) {	int p = ((int) (Math.random() * 100)) % l.size();	URI t = l.get(p);	l.set(p, l.get(i));	l.set(i, t);	}	}	if (removed) {	l.add(failedConnectTransportURI);	}	
urllist connectionlist from 

t.start();	ConnectionControl cc = new ConnectionControl();	cc.setFaultTolerant(true);	t.oneway(cc);	stateTracker.restore(t);	Map<Integer, Command> tmpMap = null;	synchronized (requestMap) {	tmpMap = new LinkedHashMap<Integer, Command>(requestMap);	}	for (Command command : tmpMap.values()) {	
restore requestmap replay 

in = new BufferedReader(getURLStream(fileURL));	while (true) {	String line = in.readLine();	if (line == null) {	break;	}	buffer.append(line);	}	newUris = buffer.toString();	} catch (IOException ioe) {	
failed to read updateurisurl 

private void doDelay() {	if (reconnectDelay > 0) {	synchronized (sleepMutex) {	
waiting ms before attempting connection 

InetAddress firstAddr = null;	InetAddress secondAddr = null;	try {	firstAddr = InetAddress.getByName(first.getHost());	secondAddr = InetAddress.getByName(second.getHost());	if (firstAddr.equals(secondAddr)) {	result = true;	}	} catch(IOException e) {	if (firstAddr == null) {	
failed to lookup inetaddress for uri 

InetAddress secondAddr = null;	try {	firstAddr = InetAddress.getByName(first.getHost());	secondAddr = InetAddress.getByName(second.getHost());	if (firstAddr.equals(secondAddr)) {	result = true;	}	} catch(IOException e) {	if (firstAddr == null) {	} else {	
failed to lookup inetaddress for uri 

========================= activemq sample_139 =========================

}	} catch (BrokenBarrierException e) {	} catch (InterruptedException e) {	}	}	}.start();	}	barrier.await();	boolean b = doneCountDownLatch.await(30, TimeUnit.SECONDS);	long end = System.currentTimeMillis();	
iterations 

}	} catch (BrokenBarrierException e) {	} catch (InterruptedException e) {	}	}	}.start();	}	barrier.await();	boolean b = doneCountDownLatch.await(30, TimeUnit.SECONDS);	long end = System.currentTimeMillis();	
counter 

}	} catch (BrokenBarrierException e) {	} catch (InterruptedException e) {	}	}	}.start();	}	barrier.await();	boolean b = doneCountDownLatch.await(30, TimeUnit.SECONDS);	long end = System.currentTimeMillis();	
dequeues s 

}	} catch (BrokenBarrierException e) {	} catch (InterruptedException e) {	}	}	}.start();	}	barrier.await();	boolean b = doneCountDownLatch.await(30, TimeUnit.SECONDS);	long end = System.currentTimeMillis();	
duration 

========================= activemq sample_26 =========================

private void assertNoUnhandledExceptions() {	for( Entry<Thread, Throwable> e: unhandledExceptions.entrySet()) {	
thread had unexpected 

waitForBridgeFormation(brokers.get("Broker1").broker, 1, 0);	waitForBridgeFormation(brokers.get("Broker1").broker, 1, 1);	Destination dest = createDestination("TEST.FOO", false);	for (int i = 0; i < BROKER_COUNT; i++) {	consumerMap.put("Consumer:" + i + ":0", createConsumer("Broker" + i, dest));	}	assertExactConsumersConnect("Broker0", 3, 1, TIMEOUT);	assertExactConsumersConnect("Broker2", 3, 1, TIMEOUT);	assertExactConsumersConnect("Broker1", 3, 1, TIMEOUT);	assertNoUnhandledExceptions();	
complete the mesh 

consumerMap.put("Consumer:" + i + ":0", createConsumer("Broker" + i, dest));	}	assertExactConsumersConnect("Broker0", 3, 1, TIMEOUT);	assertExactConsumersConnect("Broker2", 3, 1, TIMEOUT);	assertExactConsumersConnect("Broker1", 3, 1, TIMEOUT);	assertNoUnhandledExceptions();	NetworkConnector nc = bridge("Broker0", "Broker2");	nc.setBrokerName("Broker0");	nc.start();	if (!DUPLEX) {	
complete the mesh 

nc.start();	}	for (int i = 0; i < BROKER_COUNT; i++) {	assertExactConsumersConnect("Broker" + i, 3, 1, TIMEOUT);	}	consumerMap.get("Consumer:" + 2 + ":0").close();	TimeUnit.SECONDS.sleep(1);	consumerMap.get("Consumer:" + 1 + ":0").close();	TimeUnit.SECONDS.sleep(1);	consumerMap.get("Consumer:" + 0 + ":0").close();	
check for no consumers 

waitForBridgeFormation(brokers.get("Broker1").broker, 1, 0);	waitForBridgeFormation(brokers.get("Broker1").broker, 1, 1);	Destination dest = createDestination("TEST.FOO", false);	for (int i = 0; i < BROKER_COUNT; i++) {	consumerMap.put("Consumer:" + i + ":0", createConsumer("Broker" + i, dest));	}	assertExactConsumersConnect("Broker0", 2, 1, TIMEOUT);	assertExactConsumersConnect("Broker2", 2, 1, TIMEOUT);	assertExactConsumersConnect("Broker1", 3, 1, TIMEOUT);	assertNoUnhandledExceptions();	
complete the mesh 

consumerMap.put("Consumer:" + i + ":0", createConsumer("Broker" + i, dest));	}	assertExactConsumersConnect("Broker0", 2, 1, TIMEOUT);	assertExactConsumersConnect("Broker2", 2, 1, TIMEOUT);	assertExactConsumersConnect("Broker1", 3, 1, TIMEOUT);	assertNoUnhandledExceptions();	NetworkConnector nc = bridge("Broker0", "Broker2");	nc.setBrokerName("Broker0");	nc.start();	if (!DUPLEX) {	
complete the mesh 

if (!DUPLEX) {	nc = bridge("Broker2", "Broker0");	nc.setBrokerName("Broker2");	nc.start();	}	consumerMap.get("Consumer:" + 2 + ":0").close();	TimeUnit.SECONDS.sleep(1);	consumerMap.get("Consumer:" + 1 + ":0").close();	TimeUnit.SECONDS.sleep(1);	consumerMap.get("Consumer:" + 0 + ":0").close();	
check for no consumers 

waitForBridgeFormation(brokers.get("Broker1").broker, 1, 0);	waitForBridgeFormation(brokers.get("Broker1").broker, 1, 1);	Destination dest = createDestination("TEST.FOO", false);	for (int i = 0; i < BROKER_COUNT; i++) {	for (int j=0; j< CONSUMER_COUNT; j++) consumerMap.put("Consumer:" + i + ":" + j, createConsumer("Broker" + i, dest));	}	for (int i = 0; i < BROKER_COUNT; i++) {	assertExactConsumersConnect("Broker" + i, CONSUMER_COUNT + (BROKER_COUNT -1), 1, TIMEOUT);	}	assertNoUnhandledExceptions();	
complete the mesh 

}	for (int i = 0; i < BROKER_COUNT; i++) {	assertExactConsumersConnect("Broker" + i, CONSUMER_COUNT + (BROKER_COUNT -1), 1, TIMEOUT);	}	assertNoUnhandledExceptions();	NetworkConnector nc = bridge("Broker0", "Broker2");	nc.setBrokerName("Broker0");	nc.start();	waitForBridgeFormation(brokers.get("Broker0").broker, 1, 1);	if (!DUPLEX) {	
complete the mesh 

for (int i = 0; i < BROKER_COUNT; i++) {	assertExactConsumersConnect("Broker" + i, CONSUMER_COUNT + (BROKER_COUNT -1), 1, TIMEOUT);	}	for (int i=0; i<CONSUMER_COUNT; i++) {	consumerMap.get("Consumer:" + 2 + ":" + i).close();	TimeUnit.SECONDS.sleep(1);	consumerMap.get("Consumer:" + 1 + ":" + i).close();	TimeUnit.SECONDS.sleep(1);	consumerMap.get("Consumer:" + 0 + ":" + i).close();	}	
check for no consumers 

protected void assertExactConsumersConnect(final String brokerName, final int count, final int numChecks, long timeout) throws Exception {	final ManagementContext context = brokers.get(brokerName).broker.getManagementContext();	final AtomicInteger stability = new AtomicInteger(0);	assertTrue("Expected consumers count: " + count + " on: " + brokerName, Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	try {	QueueViewMBean queueViewMBean = (QueueViewMBean) context.newProxyInstance(brokers.get(brokerName).broker.getAdminView().getQueues()[0], QueueViewMBean.class, false);	long currentCount = queueViewMBean.getConsumerCount();	
on current consumer count for 

final AtomicInteger stability = new AtomicInteger(0);	assertTrue("Expected consumers count: " + count + " on: " + brokerName, Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	try {	QueueViewMBean queueViewMBean = (QueueViewMBean) context.newProxyInstance(brokers.get(brokerName).broker.getAdminView().getQueues()[0], QueueViewMBean.class, false);	long currentCount = queueViewMBean.getConsumerCount();	LinkedList<String> consumerIds = new LinkedList<String>();	for (ObjectName objectName : queueViewMBean.getSubscriptions()) {	consumerIds.add(objectName.getKeyProperty("consumerId"));	}	
sub ids 

========================= activemq sample_3649 =========================

public void run() {	final int innerId = threadId.incrementAndGet();	try {	ExceptionListener listener = new NioQueueSubscriptionTestListener(innerId, exceptions, LOG);	ActiveMQConnection connection = (ActiveMQConnection) factory.createConnection();	connection.setExceptionListener(listener);	connection.start();	assertNotNull(connection.getBrokerName());	connections.add(connection);	} catch (Exception e) {	
exception in run on thread 

connections.add(connection);	} catch (Exception e) {	exceptions.put(Thread.currentThread(), e);	}	}	});	}	executor.shutdown();	executor.awaitTermination(30, TimeUnit.SECONDS);	if (!exceptions.isEmpty()) {	
exceptions like 

exceptions.put(Thread.currentThread(), e);	}	}	});	}	executor.shutdown();	executor.awaitTermination(30, TimeUnit.SECONDS);	if (!exceptions.isEmpty()) {	fail("unexpected exceptions in worker threads: " + exceptions.values().iterator().next());	}	
created connections 

public void onException(JMSException exception) {	
exception in onexception on thread 

========================= activemq sample_2408 =========================

MessageConsumer clientA = createConsumer("BrokerA", dest);	MessageConsumer clientB = createConsumer("BrokerB", dest);	sendMessages("BrokerA", dest, 5000);	sendMessages("BrokerB", dest, 1000);	final MessageIdList msgsA = getConsumerMessages("BrokerA", clientA);	final MessageIdList msgsB = getConsumerMessages("BrokerB", clientB);	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return msgsA.getMessageCount() + msgsB.getMessageCount() == 6000;	}});	
a got 

MessageConsumer clientA = createConsumer("BrokerA", dest);	MessageConsumer clientB = createConsumer("BrokerB", dest);	sendMessages("BrokerA", dest, 5000);	sendMessages("BrokerB", dest, 1000);	final MessageIdList msgsA = getConsumerMessages("BrokerA", clientA);	final MessageIdList msgsB = getConsumerMessages("BrokerB", clientB);	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return msgsA.getMessageCount() + msgsB.getMessageCount() == 6000;	}});	
b got 

========================= activemq sample_3560 =========================

protected BrokerService createBroker(String uri) throws Exception {	
loading broker configuration from the classpath with uri 

========================= activemq sample_2664 =========================

}	this.storedSchedulers = new BTreeIndex<String, JobSchedulerImpl>(store.getPageFile(), in.readLong());	this.storedSchedulers.setKeyMarshaller(StringMarshaller.INSTANCE);	this.storedSchedulers.setValueMarshaller(new JobSchedulerMarshaller(this.store));	this.journalRC = new BTreeIndex<Integer, Integer>(store.getPageFile(), in.readLong());	this.journalRC.setKeyMarshaller(IntegerMarshaller.INSTANCE);	this.journalRC.setValueMarshaller(IntegerMarshaller.INSTANCE);	this.removeLocationTracker = new BTreeIndex<Integer, List<Integer>>(store.getPageFile(), in.readLong());	this.removeLocationTracker.setKeyMarshaller(IntegerMarshaller.INSTANCE);	this.removeLocationTracker.setValueMarshaller(new IntegerListMarshaller());	
scheduler store version loaded 

========================= activemq sample_1766 =========================

}	});	}});	try {	Executors.newSingleThreadExecutor().submit(commandFuture);	response = commandFuture.get(timeout, TimeUnit.MILLISECONDS);	} catch (Exception e) {	e.printStackTrace(System.err);	response = "SHELL COMMAND TIMED OUT: ";	}	
execute response 

========================= activemq sample_4358 =========================

publisher = session.createProducer(destination);	assertNotNull(publisher);	MapMessage msg = session.createMapMessage();	assertNotNull(msg);	msg.setString("key1", "value1");	int loop;	for (loop = 0; loop < MESSAGE_COUNT; loop++) {	msg.setInt("key2", loop);	publisher.send(msg, DELIVERY_MODE, DELIVERY_PRIORITY, Message.DEFAULT_TIME_TO_LIVE);	if (loop % 500 == 0) {	
sent messages 

========================= activemq sample_3537 =========================

protected void setUp() throws Exception {	deliveryMode = DeliveryMode.NON_PERSISTENT;	super.setUp();	consumerDestination2 = consumeSession.createTopic("FOO.BAR.HUMBUG2");	
created consumer destination of type 

protected void setUp() throws Exception {	deliveryMode = DeliveryMode.NON_PERSISTENT;	super.setUp();	consumerDestination2 = consumeSession.createTopic("FOO.BAR.HUMBUG2");	if (durable) {	
creating durable consumer 

public void testSendReceive() throws Exception {	super.testSendReceive();	messages.clear();	consumer2.setMessageListener(this);	assertMessagesAreReceived();	
messages s received closing down connections 

========================= activemq sample_3472 =========================

public static void main(String[] args) {	String queueName = null;	Context jndiContext = null;	QueueConnectionFactory queueConnectionFactory = null;	QueueConnection queueConnection = null;	QueueSession queueSession = null;	Queue queue = null;	QueueReceiver queueReceiver = null;	TextMessage message = null;	if (args.length != 1) {	
usage java simplequeuereceiver queue name 

QueueConnectionFactory queueConnectionFactory = null;	QueueConnection queueConnection = null;	QueueSession queueSession = null;	Queue queue = null;	QueueReceiver queueReceiver = null;	TextMessage message = null;	if (args.length != 1) {	System.exit(1);	}	queueName = args[0];	
queue name is 

Queue queue = null;	QueueReceiver queueReceiver = null;	TextMessage message = null;	if (args.length != 1) {	System.exit(1);	}	queueName = args[0];	try {	jndiContext = new InitialContext();	} catch (NamingException e) {	
could not create jndi api context 

queueName = args[0];	try {	jndiContext = new InitialContext();	} catch (NamingException e) {	System.exit(1);	}	try {	queueConnectionFactory = (QueueConnectionFactory)jndiContext.lookup("QueueConnectionFactory");	queue = (Queue)jndiContext.lookup(queueName);	} catch (NamingException e) {	
jndi api lookup failed 

try {	queueConnection = queueConnectionFactory.createQueueConnection();	queueSession = queueConnection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);	queueReceiver = queueSession.createReceiver(queue);	queueConnection.start();	while (true) {	Message m = queueReceiver.receive(1);	if (m != null) {	if (m instanceof TextMessage) {	message = (TextMessage)m;	
reading message 

Message m = queueReceiver.receive(1);	if (m != null) {	if (m instanceof TextMessage) {	message = (TextMessage)m;	} else {	break;	}	}	}	} catch (JMSException e) {	
exception occurred 

========================= activemq sample_2263 =========================

public void abortConsumer(ObjectName consumerToAbort) {	Subscription sub = broker.getSubscriber(consumerToAbort);	if (sub != null) {	
aborting consumer via jmx 

public void abortConsumer(ObjectName consumerToAbort) {	Subscription sub = broker.getSubscriber(consumerToAbort);	if (sub != null) {	strategy.abortConsumer(sub, false);	} else {	
cannot resolve subscription matching name 

public void abortConnection(ObjectName consumerToAbort) {	Subscription sub = broker.getSubscriber(consumerToAbort);	if (sub != null) {	
aborting consumer connection via jmx 

public void abortConnection(ObjectName consumerToAbort) {	Subscription sub = broker.getSubscriber(consumerToAbort);	if (sub != null) {	strategy.abortConsumer(sub, true);	} else {	
cannot resolve subscription matching name 

private ObjectName toObjectName(String objectName) {	ObjectName result = null;	try {	result = new ObjectName(objectName);	} catch (Exception e) {	
cannot create subscription objectname to abort from string 

========================= activemq sample_3956 =========================

BrokerService broker;	broker = createBroker(new FileSystemResource(CONF_ROOT + "journaledjdbc-example.xml"));	try {	assertEquals("Broker Config Error (brokerName)", "brokerJournaledJDBCConfigTest", broker.getBrokerName());	PersistenceAdapter adapter = broker.getPersistenceAdapter();	assertTrue("Should have created a journal persistence adapter", adapter instanceof JournalPersistenceAdapter);	assertTrue("Should have created a derby directory at " + derbyFile.getAbsolutePath(), derbyFile.exists());	assertTrue("Should have created a journal directory at " + journalFile.getAbsolutePath(), journalFile.exists());	broker.getPersistenceAdapter();	assertTrue(broker.getSystemUsage().getStoreUsage().getStore() instanceof JournalPersistenceAdapter);	
Success 

public void testBrokerConfig() throws Exception {	ActiveMQTopic dest;	BrokerService broker;	File journalFile = new File(JOURNAL_ROOT);	recursiveDelete(journalFile);	broker = createBroker("org/apache/activemq/config/example.xml");	
Success 

recursiveDelete(journalFile);	broker = createBroker("org/apache/activemq/config/example.xml");	try {	assertEquals("Broker Config Error (brokerName)", "brokerConfigTest", broker.getBrokerName());	assertEquals("Broker Config Error (populateJMSXUserID)", false, broker.isPopulateJMSXUserID());	assertEquals("Broker Config Error (useLoggingForShutdownErrors)", true, broker.isUseLoggingForShutdownErrors());	assertEquals("Broker Config Error (useJmx)", true, broker.isUseJmx());	assertEquals("Broker Config Error (persistent)", false, broker.isPersistent());	assertEquals("Broker Config Error (useShutdownHook)", false, broker.isUseShutdownHook());	assertEquals("Broker Config Error (deleteAllMessagesOnStartup)", true, broker.isDeleteAllMessagesOnStartup());	
Success 

recursiveDelete(journalFile);	broker = createBroker("org/apache/activemq/config/example.xml");	try {	assertEquals("Broker Config Error (brokerName)", "brokerConfigTest", broker.getBrokerName());	assertEquals("Broker Config Error (populateJMSXUserID)", false, broker.isPopulateJMSXUserID());	assertEquals("Broker Config Error (useLoggingForShutdownErrors)", true, broker.isUseLoggingForShutdownErrors());	assertEquals("Broker Config Error (useJmx)", true, broker.isUseJmx());	assertEquals("Broker Config Error (persistent)", false, broker.isPersistent());	assertEquals("Broker Config Error (useShutdownHook)", false, broker.isUseShutdownHook());	assertEquals("Broker Config Error (deleteAllMessagesOnStartup)", true, broker.isDeleteAllMessagesOnStartup());	
should have a specific vm connector vm log info Success 

assertEquals("Broker Config Error (persistent)", false, broker.isPersistent());	assertEquals("Broker Config Error (useShutdownHook)", false, broker.isUseShutdownHook());	assertEquals("Broker Config Error (deleteAllMessagesOnStartup)", true, broker.isDeleteAllMessagesOnStartup());	List<TransportConnector> connectors = broker.getTransportConnectors();	assertTrue("Should have created at least 3 connectors", connectors.size() >= 3);	assertTrue("1st connector should be TcpTransportServer", connectors.get(0).getServer() instanceof TcpTransportServer);	assertTrue("2nd connector should be TcpTransportServer", connectors.get(1).getServer() instanceof TcpTransportServer);	assertTrue("3rd connector should be TcpTransportServer", connectors.get(2).getServer() instanceof TcpTransportServer);	List<NetworkConnector> networkConnectors = broker.getNetworkConnectors();	assertEquals("Should have a single network connector", 1, networkConnectors.size());	
Success 

assertTrue("2nd connector should be TcpTransportServer", connectors.get(1).getServer() instanceof TcpTransportServer);	assertTrue("3rd connector should be TcpTransportServer", connectors.get(2).getServer() instanceof TcpTransportServer);	List<NetworkConnector> networkConnectors = broker.getNetworkConnectors();	assertEquals("Should have a single network connector", 1, networkConnectors.size());	dest = new ActiveMQTopic("Topic.SimpleDispatch");	assertTrue("Should have a simple dispatch policy for " + dest.getTopicName(), broker.getDestinationPolicy().getEntryFor(dest).getDispatchPolicy() instanceof SimpleDispatchPolicy);	dest = new ActiveMQTopic("Topic.RoundRobinDispatch");	assertTrue("Should have a round robin dispatch policy for " + dest.getTopicName(), broker.getDestinationPolicy().getEntryFor(dest).getDispatchPolicy() instanceof RoundRobinDispatchPolicy);	dest = new ActiveMQTopic("Topic.StrictOrderDispatch");	assertTrue("Should have a strict order dispatch policy for " + dest.getTopicName(), broker.getDestinationPolicy().getEntryFor(dest).getDispatchPolicy() instanceof StrictOrderDispatchPolicy);	
Success 

dest = new ActiveMQTopic("Topic.LastImageSubs");	subsPolicy = broker.getDestinationPolicy().getEntryFor(dest).getSubscriptionRecoveryPolicy();	assertTrue("Should have a last image subscription recovery policy for " + dest.getTopicName(), subsPolicy instanceof LastImageSubscriptionRecoveryPolicy);	dest = new ActiveMQTopic("Topic.NoSubs");	subsPolicy = broker.getDestinationPolicy().getEntryFor(dest).getSubscriptionRecoveryPolicy();	assertTrue("Should have no subscription recovery policy for " + dest.getTopicName(), subsPolicy instanceof NoSubscriptionRecoveryPolicy);	dest = new ActiveMQTopic("Topic.TimedSubs");	subsPolicy = broker.getDestinationPolicy().getEntryFor(dest).getSubscriptionRecoveryPolicy();	assertTrue("Should have a timed subscription recovery policy for " + dest.getTopicName(), subsPolicy instanceof TimedSubscriptionRecoveryPolicy);	assertEquals("TimedSubsPolicy Config Error (recoverDuration)", 25000, ((TimedSubscriptionRecoveryPolicy) subsPolicy).getRecoverDuration());	
Success 

assertEquals("TimedSubsPolicy Config Error (recoverDuration)", 25000, ((TimedSubscriptionRecoveryPolicy) subsPolicy).getRecoverDuration());	SystemUsage systemUsage = broker.getSystemUsage();	assertTrue("Should have a SystemUsage", systemUsage != null);	assertEquals("SystemUsage Config Error (MemoryUsage.limit)", 1024 * 1024 * 10, systemUsage.getMemoryUsage().getLimit());	assertEquals("SystemUsage Config Error (MemoryUsage.percentUsageMinDelta)", 20, systemUsage.getMemoryUsage().getPercentUsageMinDelta());	assertEquals("SystemUsage Config Error (TempUsage.limit)", 1024 * 1024 * 100, systemUsage.getTempUsage().getLimit());	assertEquals("SystemUsage Config Error (StoreUsage.limit)", 1024 * 1024 * 1024, systemUsage.getStoreUsage().getLimit());	assertEquals("SystemUsage Config Error (StoreUsage.name)", "foo", systemUsage.getStoreUsage().getName());	assertNotNull(systemUsage.getStoreUsage().getStore());	assertTrue(systemUsage.getStoreUsage().getStore() instanceof MemoryPersistenceAdapter);	
Success 

public void testJournalConfig() throws Exception {	File journalFile = new File(JOURNAL_ROOT + "testJournalConfig/journal");	recursiveDelete(journalFile);	BrokerService broker;	broker = createBroker(new FileSystemResource(CONF_ROOT + "journal-example.xml"));	try {	assertEquals("Broker Config Error (brokerName)", "brokerJournalConfigTest", broker.getBrokerName());	PersistenceAdapter adapter = broker.getPersistenceAdapter();	assertTrue("Should have created a journal persistence adapter", adapter instanceof JournalPersistenceAdapter);	assertTrue("Should have created a journal directory at " + journalFile.getAbsolutePath(), journalFile.exists());	
Success 

File derbyFile = new File(DERBY_ROOT + "testMemoryConfig");	recursiveDelete(derbyFile);	BrokerService broker;	broker = createBroker(new FileSystemResource(CONF_ROOT + "memory-example.xml"));	try {	assertEquals("Broker Config Error (brokerName)", "brokerMemoryConfigTest", broker.getBrokerName());	PersistenceAdapter adapter = broker.getPersistenceAdapter();	assertTrue("Should have created a memory persistence adapter", adapter instanceof MemoryPersistenceAdapter);	assertTrue("Should have not created a derby directory at " + derbyFile.getAbsolutePath(), !derbyFile.exists());	assertTrue("Should have not created a journal directory at " + journalFile.getAbsolutePath(), !journalFile.exists());	
Success 

} catch (JMSException expected) {	}	try {	for (int i = 0; i < (MAX_CONSUMERS + 1); i++) {	MessageConsumer consumer = session.createConsumer(topic);	assertNotNull(consumer);	}	fail("Should have caught an exception");	} catch (JMSException e) {	}	
Success 

========================= activemq sample_2644 =========================

protected byte[] createLargeByteBuffer(int size) {	byte[] buffer = new byte[size];	for (int i=0; i<size; i++) {	buffer[i] = (char) 'X';	}	buffer[size-1] = 0;	
created byte buffer of size starting with content 

========================= activemq sample_1438 =========================

session.close();	QueueViewMBean queueView = getProxyToQueue(getTestName());	assertEquals(1000, queueView.getQueueSize());	int counter = 0;	session = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageConsumer messageConsumer = session.createConsumer(queue);	do {	TextMessage message = (TextMessage) messageConsumer.receive(1000);	if (message != null) {	counter++;	
message n with content has been recieved 

QueueViewMBean queueView = getProxyToQueue(getTestName());	assertEquals(1000, queueView.getQueueSize());	int counter = 0;	session = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageConsumer messageConsumer = session.createConsumer(queue);	do {	TextMessage message = (TextMessage) messageConsumer.receive(1000);	if (message != null) {	counter++;	session.commit();	
transaction has been committed 

session.close();	QueueViewMBean queueView = getProxyToQueue(getTestName());	assertEquals(1000, queueView.getQueueSize());	int counter = 0;	session = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageConsumer messageConsumer = session.createConsumer(queue);	do {	TextMessage message = (TextMessage) messageConsumer.receive(1000);	if (message != null) {	counter++;	
message n with content has been recieved 

assertEquals(1000, queueView.getQueueSize());	int counter = 0;	session = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageConsumer messageConsumer = session.createConsumer(queue);	do {	TextMessage message = (TextMessage) messageConsumer.receive(1000);	if (message != null) {	counter++;	}	} while (counter < MSG_COUNT);	
transaction has been committed 

public void testQueueTXRollbackAndCommit() throws Exception {	final int MSG_COUNT = 3;	connection = createConnection();	connection.start();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Queue destination = session.createQueue(getDestinationName());	MessageProducer producer = session.createProducer(destination);	MessageConsumer consumer = session.createConsumer(destination);	for (int i = 1; i <= MSG_COUNT; i++) {	
sending message to rollback 

MessageProducer producer = session.createProducer(destination);	MessageConsumer consumer = session.createConsumer(destination);	for (int i = 1; i <= MSG_COUNT; i++) {	TextMessage message = session.createTextMessage("Rolled back Message: " + i);	message.setIntProperty("MessageSequence", i);	producer.send(message);	}	session.rollback();	assertEquals(0, getProxyToQueue(getDestinationName()).getQueueSize());	for (int i = 1; i <= MSG_COUNT; i++) {	
sending message to commit 

for (int i = 1; i <= MSG_COUNT; i++) {	TextMessage message = session.createTextMessage("Commit Message: " + i);	message.setIntProperty("MessageSequence", i);	producer.send(message);	}	session.commit();	assertEquals(MSG_COUNT, getProxyToQueue(getDestinationName()).getQueueSize());	SubscriptionViewMBean subscription = getProxyToQueueSubscriber(getDestinationName());	assertNotNull(subscription);	for (int i = 1; i <= MSG_COUNT; i++) {	
trying to receive message 

final AtomicInteger counter = new AtomicInteger();	connection = createConnection();	connection.start();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	Queue destination = session.createQueue(getDestinationName());	MessageProducer producer = session.createProducer(destination);	MessageConsumer consumer = session.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	
received message 

consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	} catch (JMSException e) {	}	counter.incrementAndGet();	}	});	int msgIndex = 0;	for (int i = 1; i <= MSG_COUNT; i++) {	
sending message to rollback 

}	counter.incrementAndGet();	}	});	int msgIndex = 0;	for (int i = 1; i <= MSG_COUNT; i++) {	TextMessage message = session.createTextMessage("Rolled back Message: " + msgIndex);	message.setIntProperty("MessageSequence", msgIndex);	producer.send(message);	}	
rollback of sent message here 

});	int msgIndex = 0;	for (int i = 1; i <= MSG_COUNT; i++) {	TextMessage message = session.createTextMessage("Rolled back Message: " + msgIndex);	message.setIntProperty("MessageSequence", msgIndex);	producer.send(message);	}	session.rollback();	assertEquals(0, getProxyToQueue(getDestinationName()).getQueueSize());	for (int i = 1; i <= MSG_COUNT; i++) {	
sending message to commit 

message.setIntProperty("MessageSequence", msgIndex);	producer.send(message);	}	session.rollback();	assertEquals(0, getProxyToQueue(getDestinationName()).getQueueSize());	for (int i = 1; i <= MSG_COUNT; i++) {	TextMessage message = session.createTextMessage("Commit Message: " + msgIndex);	message.setIntProperty("MessageSequence", msgIndex);	producer.send(message);	}	
commit of sent message here 

}	session.commit();	assertEquals(MSG_COUNT, getProxyToQueue(getDestinationName()).getQueueSize());	SubscriptionViewMBean subscription = getProxyToQueueSubscriber(getDestinationName());	assertNotNull(subscription);	assertTrue("Should read all " + MSG_COUNT + " messages.", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return counter.get() == MSG_COUNT;	}	}));	
commit of first received batch here 

assertEquals(MSG_COUNT, getProxyToQueue(getDestinationName()).getQueueSize());	SubscriptionViewMBean subscription = getProxyToQueueSubscriber(getDestinationName());	assertNotNull(subscription);	assertTrue("Should read all " + MSG_COUNT + " messages.", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return counter.get() == MSG_COUNT;	}	}));	session.commit();	for (int i = 1; i <= MSG_COUNT; i++) {	
sending message to commit 

public boolean isSatisified() throws Exception {	return counter.get() == MSG_COUNT;	}	}));	session.commit();	for (int i = 1; i <= MSG_COUNT; i++) {	TextMessage message = session.createTextMessage("Commit Message: " + msgIndex);	message.setIntProperty("MessageSequence", msgIndex);	producer.send(message);	}	
commit of next sent message batch here 

return counter.get() == MSG_COUNT;	}	}));	session.commit();	for (int i = 1; i <= MSG_COUNT; i++) {	TextMessage message = session.createTextMessage("Commit Message: " + msgIndex);	message.setIntProperty("MessageSequence", msgIndex);	producer.send(message);	}	session.commit();	
waiting for next three messages to arrive 

}));	session.commit();	for (int i = 1; i <= MSG_COUNT; i++) {	TextMessage message = session.createTextMessage("Commit Message: " + msgIndex);	message.setIntProperty("MessageSequence", msgIndex);	producer.send(message);	}	session.commit();	assertTrue("Should read all " + MSG_COUNT + " messages.", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
read messages so far 

========================= activemq sample_1592 =========================

public void testGroupedMessagesDeliveredToOnlyOneConsumer() throws Exception {	ActiveMQDestination destination = new ActiveMQQueue("TEST");	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer1 = session.createConsumer(destination);	MessageProducer producer = session.createProducer(destination);	for (int i = 0; i < 4; i++) {	TextMessage message = session.createTextMessage("message " + i);	message.setStringProperty("JMSXGroupID", "TEST-GROUP");	message.setIntProperty("JMSXGroupSeq", i + 1);	
sending message 

public void testAddingConsumer() throws Exception {	ActiveMQDestination destination = new ActiveMQQueue("TEST");	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	TextMessage message = session.createTextMessage("message");	message.setStringProperty("JMSXGroupID", "TEST-GROUP");	
sending message 

public void testClosingMessageGroup() throws Exception {	ActiveMQDestination destination = new ActiveMQQueue("TEST");	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer1 = session.createConsumer(destination);	MessageProducer producer = session.createProducer(destination);	for (int i = 0; i < 4; i++) {	TextMessage message = session.createTextMessage("message " + i);	message.setStringProperty("JMSXGroupID", "TEST-GROUP");	
sending message 

}	Connection connection1 = factory.createConnection(userName, password);	connection1.start();	Session session2 = connection1.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer2 = session2.createConsumer(destination);	Message m = consumer2.receive(100);	assertNull("consumer 2 has some messages", m);	TextMessage message = session.createTextMessage("message " + 5);	message.setStringProperty("JMSXGroupID", "TEST-GROUP");	message.setIntProperty("JMSXGroupSeq", -1);	
sending message 

MessageConsumer consumer2 = session2.createConsumer(destination);	Message m = consumer2.receive(100);	assertNull("consumer 2 has some messages", m);	TextMessage message = session.createTextMessage("message " + 5);	message.setStringProperty("JMSXGroupID", "TEST-GROUP");	message.setIntProperty("JMSXGroupSeq", -1);	producer.send(message);	for (int i = 0; i < 4; i++) {	message = session.createTextMessage("message " + i);	message.setStringProperty("JMSXGroupID", "TEST-GROUP");	
sending message 

========================= activemq sample_2351 =========================

public void setUp() throws Exception {	gotError.set(false);	broker = createBroker();	broker.start();	broker.waitUntilStarted();	appender = new DefaultTestAppender() {	public void doAppend(org.apache.log4j.spi.LoggingEvent event) {	if (event.getLevel().toInt() > Level.INFO_INT) {	
got error from log 

public void testConcurrentDlqOk() throws Exception {	final Destination dest = new ActiveMQQueue("DD");	final ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory(broker.getTransportConnectorByScheme("tcp").getPublishableConnectString());	amq.setWatchTopicAdvisories(false);	broker.setIoExceptionHandler(new DefaultIOExceptionHandler() {	public void handle(IOException exception) {	
handle ioexception from store 

session = connection.createSession(true, Session.SESSION_TRANSACTED);	consumer = session.createConsumer(dest);	while (consumed.get() > 0 && !gotError.get()) {	Message message = consumer.receive(4000);	if (message != null) {	consumed.decrementAndGet();	session.rollback();	}	}	} catch (Exception e) {	
error on consumption 

connection.close();	}	} catch (Exception ignored) {}	}	}	});	}	executorService.shutdown();	boolean allComplete = executorService.awaitTermination(60, TimeUnit.SECONDS);	executorService.shutdownNow();	
total messages 

connection.close();	}	} catch (Exception ignored) {}	}	}	});	}	executorService.shutdown();	boolean allComplete = executorService.awaitTermination(60, TimeUnit.SECONDS);	executorService.shutdownNow();	
total enqueues 

connection.close();	}	} catch (Exception ignored) {}	}	}	});	}	executorService.shutdown();	boolean allComplete = executorService.awaitTermination(60, TimeUnit.SECONDS);	executorService.shutdownNow();	
total deueues 

});	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(dest);	long counter = 0;	TextMessage message = session.createTextMessage();	for (int i = 0; i < numMessages; i++) {	producer.send(message);	counter++;	if ((counter % 50) == 0) {	
sent messages 

========================= activemq sample_3813 =========================

public void testSendReceive() throws Exception {	super.testSendReceive();	messages.clear();	Destination consumerDestination = consumeSession.createQueue("FOO.BAR.HUMBUG2");	
created consumer destination of type 

public void testSendReceive() throws Exception {	super.testSendReceive();	messages.clear();	Destination consumerDestination = consumeSession.createQueue("FOO.BAR.HUMBUG2");	MessageConsumer consumer = null;	if (durable) {	
creating durable consumer 

messages.clear();	Destination consumerDestination = consumeSession.createQueue("FOO.BAR.HUMBUG2");	MessageConsumer consumer = null;	if (durable) {	consumer = consumeSession.createDurableSubscriber((Topic) consumerDestination, getName());	} else {	consumer = consumeSession.createConsumer(consumerDestination);	}	consumer.setMessageListener(this);	assertMessagesAreReceived();	
messages s received closing down connections 

public void testDuplicate() throws Exception {	ActiveMQDestination queue = (ActiveMQDestination)session.createQueue("TEST,TEST");	for (int i = 0; i < data.length; i++) {	Message message = createMessage(i);	configureMessage(message);	if (verbose) {	
about to send a message with text 

========================= activemq sample_2701 =========================

public Destination addDestination(ConnectionContext context, ActiveMQDestination destination, boolean createIfTemporary) throws Exception {	destinationsLock.writeLock().lock();	try {	Destination dest = destinations.get(destination);	if (dest == null) {	if (destination.isTemporary() == false || createIfTemporary) {	validateMaxDestinations(destination);	
adding destination 

List<Subscription> rc = new ArrayList<Subscription>();	for (Iterator<Subscription> iter = subscriptions.values().iterator(); iter.hasNext();) {	Subscription sub = iter.next();	if (sub.matches(dest.getActiveMQDestination())) {	try {	ConnectionContext originalContext = sub.getContext() != null ? sub.getContext() : context;	dest.addSubscription(originalContext, sub);	rc.add(sub);	} catch (SecurityException e) {	if (sub.isWildcard()) {	
subscription denied for to destination 

if (timeout == 0) {	for (Iterator<Subscription> iter = subscriptions.values().iterator(); iter.hasNext();) {	Subscription sub = iter.next();	if (sub.matches(destination) ) {	throw new JMSException("Destination still has an active subscription: " + destination);	}	}	}	if (timeout > 0) {	}	
removing destination 

dest.removeSubscription(context, sub, 0l);	}	}	destinationMap.remove(destination, dest);	dispose(context, dest);	DestinationInterceptor destinationInterceptor = broker.getDestinationInterceptor();	if (destinationInterceptor != null) {	destinationInterceptor.remove(dest);	}	} else {	
cannot remove a destination that doesn t exist 

public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {	
adding consumer for destination 

synchronized (consumerChangeMutexMap) {	addGuard = consumerChangeMutexMap.get(info.getConsumerId());	if (addGuard == null) {	addGuard = new Object();	consumerChangeMutexMap.put(info.getConsumerId(), addGuard);	}	}	synchronized (addGuard) {	Subscription o = subscriptions.get(info.getConsumerId());	if (o != null) {	
a duplicate subscription was detected clients may be misbehaving later warnings you may see about subscription removal are a consequence of this 

} finally {	destinationsLock.readLock().unlock();	}	List<Destination> removeList = new ArrayList<Destination>();	for (Destination dest : addList) {	try {	dest.addSubscription(context, sub);	removeList.add(dest);	} catch (SecurityException e){	if (sub.isWildcard()) {	
subscription denied for to destination 

try {	dest.addSubscription(context, sub);	removeList.add(dest);	} catch (SecurityException e){	if (sub.isWildcard()) {	} else {	for (Destination remove : removeList) {	try {	remove.removeSubscription(context, sub, info.getLastDeliveredSequenceId());	} catch (Exception ex) {	
error unsubscribing from 

public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {	
removing consumer for destination 

public void acknowledge(ConsumerBrokerExchange consumerExchange, MessageAck ack) throws Exception {	Subscription sub = consumerExchange.getSubscription();	if (sub == null) {	sub = subscriptions.get(ack.getConsumerId());	if (sub == null) {	if (!consumerExchange.getConnectionContext().isInRecoveryMode()) {	
ack for non existent subscription ack 

public void acknowledge(ConsumerBrokerExchange consumerExchange, MessageAck ack) throws Exception {	Subscription sub = consumerExchange.getSubscription();	if (sub == null) {	sub = subscriptions.get(ack.getConsumerId());	if (sub == null) {	if (!consumerExchange.getConnectionContext().isInRecoveryMode()) {	throw new IllegalArgumentException("The subscription does not exist: " + ack.getConsumerId());	} else {	
ack for non existent subscription in recovery ack 

public void processConsumerControl(ConsumerBrokerExchange consumerExchange, ConsumerControl control) {	Subscription sub = subscriptions.get(control.getConsumerId());	if (sub != null && sub instanceof AbstractSubscription) {	((AbstractSubscription) sub).setPrefetchSize(control.getPrefetch());	if (broker.getDestinationPolicy() != null) {	PolicyEntry entry = broker.getDestinationPolicy().getEntryFor(control.getDestination());	if (entry != null) {	entry.configurePrefetch(sub);	}	}	
setting prefetch on subscription resulting value 

((AbstractSubscription) sub).setPrefetchSize(control.getPrefetch());	if (broker.getDestinationPolicy() != null) {	PolicyEntry entry = broker.getDestinationPolicy().getEntryFor(control.getDestination());	if (entry != null) {	entry.configurePrefetch(sub);	}	}	try {	lookup(consumerExchange.getConnectionContext(), control.getDestination(),false).wakeup();	} catch (Exception e) {	
failed to deliver post consumercontrol dispatch wakeup to destination 

========================= activemq sample_4006 =========================

factory.setObjectMessageSerializationDefered(true);	factory.setCopyMessageOnSend(false);	Connection connection = factory.createConnection();	Session session = (ActiveMQSession)connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createConsumer(destination);	connection.start();	consumerStarted.countDown();	ActiveMQObjectMessage message = (ActiveMQObjectMessage)consumer.receive(30000);	if ( message != null ) {	MyObject object = (MyObject)message.getObject();	
got message 

factory.setObjectMessageSerializationDefered(true);	factory.setCopyMessageOnSend(false);	Connection connection = factory.createConnection();	Session session = (ActiveMQSession)connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createConsumer(destination);	connection.start();	consumerStarted.countDown();	ActiveMQObjectMessage message = (ActiveMQObjectMessage)consumer.receive(30000);	if ( message != null ) {	MyObject object = (MyObject)message.getObject();	
got message 

ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(broker.getTransportConnectors().get(0).getConnectUri());	factory.setOptimizedMessageDispatch(true);	Connection connection = factory.createConnection();	Session session = (ActiveMQSession)connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createConsumer(destination);	connection.start();	consumerStarted.countDown();	ActiveMQObjectMessage message = (ActiveMQObjectMessage)consumer.receive(30000);	if ( message != null ) {	MyObject object = (MyObject)message.getObject();	
got message 

factory.setObjectMessageSerializationDefered(true);	factory.setCopyMessageOnSend(false);	Connection connection = factory.createConnection();	Session session = (ActiveMQSession)connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createConsumer(destination);	connection.start();	consumerStarted.countDown();	ActiveMQObjectMessage message = (ActiveMQObjectMessage)consumer.receive(30000);	if ( message != null ) {	MyObject object = (MyObject)message.getObject();	
got message 

========================= activemq sample_3669 =========================

public void testConnectingToUnavailableServer() throws Exception {	try {	transport.asyncRequest(new ActiveMQMessage(), null);	fail("This should never succeed");	} catch (IOException e) {	
caught expected exception 

========================= activemq sample_2582 =========================

public ServerSession getServerSession() throws JMSException {	synchronized (this) {	if (serverSessionInUse) {	
asked for session while in use not serialised delivery 

public void start() throws JMSException {	new Thread() {	public void run() {	session.run();	
waiting on pool 

public void start() throws JMSException {	new Thread() {	public void run() {	session.run();	synchronized (pool) {	try {	
about to call session commit 

public void start() throws JMSException {	new Thread() {	public void run() {	session.run();	synchronized (pool) {	try {	session.commit();	
commit completed 

public void start() throws JMSException {	new Thread() {	public void run() {	session.run();	synchronized (pool) {	try {	session.commit();	} catch (JMSException e) {	
in start 

public void onMessage(Message message) {	try {	String text = ((TextMessage) message).getText();	
got message 

public void onMessage(Message message) {	try {	String text = ((TextMessage) message).getText();	if (text.equals("Msg3")) {	success.set(true);	completed.set(true);	} else if (text.equals("Msg2")) {	TimeUnit.SECONDS.sleep(4);	}	} catch (JMSException e) {	
in onmessage 

try {	String text = ((TextMessage) message).getText();	if (text.equals("Msg3")) {	success.set(true);	completed.set(true);	} else if (text.equals("Msg2")) {	TimeUnit.SECONDS.sleep(4);	}	} catch (JMSException e) {	} catch (InterruptedException e) {	
in onmessage 

========================= activemq sample_2994 =========================

assertEquals("mapField.a", "foo", map.get("a"));	assertEquals("mapField.b", new Integer(23), map.get("b"));	assertEquals("mapField.c", new Long(45), map.get("c"));	value = map.get("d");	assertTrue("mapField.d should be a Map", value instanceof Map);	map = (Map)value;	assertEquals("mapField.d.x", "abc", map.get("x"));	value = map.get("y");	assertTrue("mapField.d.y is a List", value instanceof List);	List list = (List)value;	
mapfield d y 

assertEquals("mapField.b", new Integer(23), map.get("b"));	assertEquals("mapField.c", new Long(45), map.get("c"));	value = map.get("d");	assertTrue("mapField.d should be a Map", value instanceof Map);	map = (Map)value;	assertEquals("mapField.d.x", "abc", map.get("x"));	value = map.get("y");	assertTrue("mapField.d.y is a List", value instanceof List);	List list = (List)value;	assertEquals("listField.size", 3, list.size());	
found map 

assertEquals("mapField.c", new Long(45), map.get("c"));	value = map.get("d");	assertTrue("mapField.d should be a Map", value instanceof Map);	map = (Map)value;	assertEquals("mapField.d.x", "abc", map.get("x"));	value = map.get("y");	assertTrue("mapField.d.y is a List", value instanceof List);	List list = (List)value;	assertEquals("listField.size", 3, list.size());	list = (List)message.getObjectProperty("listField");	
listfield 

========================= activemq sample_2613 =========================

public void reopen() {	
reopen 

public void reopen() {	try {	open();	} catch (Exception e) {	
exception on reopen url 

private void closeConnection(Bridge c) {	try {	c.close();	} catch (Exception e) {	
exception on close of 

private void halfCloseConnection(Bridge c) {	try {	c.halfClose();	} catch (Exception e) {	
exception on half close of 

public void run() {	byte[] buf = new byte[1024];	try {	InputStream in = src.getInputStream();	OutputStream out = destination.getOutputStream();	while (true) {	int len = in.read(buf);	if (len == -1) {	
read eof from 

OutputStream out = destination.getOutputStream();	while (true) {	int len = in.read(buf);	if (len == -1) {	break;	}	pause.get().await();	out.write(buf, 0, len);	}	} catch (Exception e) {	
read write failed reason 

public void run() {	try {	while(!socket.isClosed()) {	pause.get().await();	try {	Socket source = socket.accept();	pause.get().await();	if (receiveBufferSize > 0) {	source.setReceiveBufferSize(receiveBufferSize);	}	
accepted receivebuffersize 

if (receiveBufferSize > 0) {	source.setReceiveBufferSize(receiveBufferSize);	}	synchronized(connections) {	connections.add(new Bridge(source, target));	}	} catch (SocketTimeoutException expected) {	}	}	} catch (Exception e) {	
acceptor finished for reason 

========================= activemq sample_3844 =========================

connection.setAlwaysSyncSend(true);	connection.start();	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageProducer producer = session.createProducer(session.createQueue("QAT"));	try {	for (int i = 0; i < 10; i++) {	producer.send(session.createTextMessage("Hello A"));	}	session.commit();	} catch (JMSException expectedSendFail) {	
got expected 

}	public void onException(JMSException e) {	session.getTransactionContext().setRollbackOnly(true);	batchSent.countDown();	}	});	if (i==0) {	session.getTransactionContext().addSynchronization(new Synchronization() {	public void beforeEnd() throws Exception {	if (!batchSent.await(10, TimeUnit.SECONDS)) {	
timedout waiting for aync send requests 

========================= activemq sample_2756 =========================

public void testCreateDurableSubsciber() throws Exception {	String clientId = "10";	brokerService.getAdminView().addTopic("testTopic");	boolean createSubscriberSecurityException = false;	String subscriberName = "testSubscriber";	try {	brokerService.getAdminView().createDurableSubscriber(clientId, subscriberName, "testTopic", null);	
successfully created durable subscriber via adminview 

brokerService.getAdminView().createDurableSubscriber(clientId, subscriberName, "testTopic", null);	} catch (java.lang.SecurityException se1) {	if (se1.getMessage().equals("User is not authenticated.")) {	createSubscriberSecurityException = true;	}	}	assertFalse(createSubscriberSecurityException);	boolean destroySubscriberSecurityException = false;	try {	brokerService.getAdminView().destroyDurableSubscriber(clientId, subscriberName);	
successfully destroyed durable subscriber via adminview 

brokerService.getAdminView().destroyDurableSubscriber(clientId, subscriberName);	} catch (java.lang.SecurityException se2) {	if (se2.getMessage().equals("User is not authenticated.")) {	destroySubscriberSecurityException = true;	}	}	assertFalse(destroySubscriberSecurityException);	boolean subscriberAlreadyDeleted = false;	try {	brokerService.getAdminView().destroyDurableSubscriber(clientId, subscriberName);	
successfully destroyed durable subscriber via adminview 

========================= activemq sample_2306 =========================

public void testRedelivery() throws Exception {	ConnectionFactory connectionFactory = new ActiveMQConnectionFactory( brokerService.getTransportConnectors().get(0).getConnectUri().toString() + "?jms.prefetchPolicy.queuePrefetch=100");	Connection connection = connectionFactory.createConnection();	connection.start();	Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	Queue queue = session.createQueue("queue.test");	MessageProducer producer = session.createProducer(queue);	for (int i = 0; i < MESSAGE_COUNT; i++) {	
sending message 

if (!(message instanceof TextMessage)) {	throw new RuntimeException();	}	try {	TextMessage textMessage = (TextMessage) message;	String text = textMessage.getText();	int messageDeliveryCount = message.getIntProperty(JMSX_DELIVERY_COUNT);	if (messageDeliveryCount > 1) {	messageRedelivered.set(true);	}	
count down latch delivery count received message with id with text 

========================= activemq sample_764 =========================

protected Message createMessage(int priority) throws Exception {	final String text = "priority " + priority;	Message msg = sess.createTextMessage(text);	
sending 

lowPri.join();	highPri.join();	final int closeFrequency = MSG_NUM/4;	sub = sess.createDurableSubscriber(topic, subName);	for (int i = 0; i < MSG_NUM * 2; i++) {	Message msg = sub.receive(15000);	LOG.debug("received i=" + i + ", " + (msg!=null? msg.getJMSMessageID() : null));	assertNotNull("Message " + i + " was null", msg);	assertEquals("Message " + i + " has wrong priority", i < MSG_NUM ? HIGH_PRI : LOW_PRI, msg.getJMSPriority());	if (i>0 && i%closeFrequency==0) {	
closing durable sub on 

conn.start();	sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	ActiveMQTopic topic = (ActiveMQTopic)sess.createTopic("TEST");	final String subName = "priorityDisconnect";	TopicSubscriber sub = sess.createDurableSubscriber(topic, subName);	sub.close();	final int numToProduce = 2000;	final int[] dups = new int[numToProduce*2];	ProducerThread producerThread = new ProducerThread(topic, numToProduce, LOW_PRI+1);	producerThread.run();	
low priority messages sent 

Message msg = sub.receive(15000);	LOG.info("received i=" + i + ", " + (msg!=null? msg.getJMSMessageID() + ", priority:" + msg.getJMSPriority() : null));	assertNotNull("Message " + i + " was null", msg);	assertEquals("Message " + i + " has wrong priority", LOW_PRI+1, msg.getJMSPriority());	assertTrue("not duplicate ", dups[i] == 0);	dups[i] = 1;	if (i % batchSize == 0) {	producerThread.setMessagePriority(HIGH_PRI);	producerThread.setMessageCount(1);	producerThread.run();	
high priority message sent should be able to receive immediately 

assertTrue("not duplicate ", dups[i] == 0);	dups[i] = 1;	if (i % batchSize == 0) {	producerThread.setMessagePriority(HIGH_PRI);	producerThread.setMessageCount(1);	producerThread.run();	if (i % batchSize*2 == 0) {	producerThread.setMessagePriority(HIGH_PRI -1);	producerThread.setMessageCount(1);	producerThread.run();	
high priority message sent should be able to receive immediately 

if (i % batchSize*2 == 0) {	producerThread.setMessagePriority(HIGH_PRI -1);	producerThread.setMessageCount(1);	producerThread.run();	}	if (i % batchSize*4 == 0) {	producerThread.setMessagePriority(LOW_PRI);	producerThread.setMessageCount(1);	producerThread.run();	lowLowCount++;	
low low priority message sent should not be able to receive immediately 

producerThread.run();	}	if (i % batchSize*4 == 0) {	producerThread.setMessagePriority(LOW_PRI);	producerThread.setMessageCount(1);	producerThread.run();	lowLowCount++;	}	msg = sub.receive(15000);	assertNotNull("Message was null", msg);	
received hi 

TopicSubscriber sub = sess.createDurableSubscriber(topic, subName);	sub.close();	ProducerThread producerThread = new ProducerThread(topic, 1, HIGH_PRI);	producerThread.run();	producerThread.setMessagePriority(HIGH_PRI -1);	producerThread.setMessageCount(1);	producerThread.run();	producerThread.setMessagePriority(LOW_PRI);	producerThread.setMessageCount(1);	producerThread.run();	
ordered priority messages sent 

producerThread.run();	producerThread.setMessagePriority(HIGH_PRI -1);	producerThread.setMessageCount(1);	producerThread.run();	producerThread.setMessagePriority(LOW_PRI);	producerThread.setMessageCount(1);	producerThread.run();	sub = sess.createDurableSubscriber(topic, subName);	Message msg = sub.receive(15000);	assertNotNull("Message was null", msg);	
received priority 

producerThread.run();	sub = sess.createDurableSubscriber(topic, subName);	Message msg = sub.receive(15000);	assertNotNull("Message was null", msg);	assertEquals("Message has wrong priority", HIGH_PRI, msg.getJMSPriority());	producerThread.setMessagePriority(LOW_PRI+1);	producerThread.setMessageCount(1);	producerThread.run();	msg = sub.receive(15000);	assertNotNull("Message was null", msg);	
received priority 

assertNotNull("Message was null", msg);	assertEquals("Message has wrong priority", HIGH_PRI, msg.getJMSPriority());	producerThread.setMessagePriority(LOW_PRI+1);	producerThread.setMessageCount(1);	producerThread.run();	msg = sub.receive(15000);	assertNotNull("Message was null", msg);	assertEquals("high priority", HIGH_PRI -1, msg.getJMSPriority());	msg = sub.receive(15000);	assertNotNull("Message was null", msg);	
received hi 

producerThread.setMessageCount(1);	producerThread.run();	msg = sub.receive(15000);	assertNotNull("Message was null", msg);	assertEquals("high priority", HIGH_PRI -1, msg.getJMSPriority());	msg = sub.receive(15000);	assertNotNull("Message was null", msg);	assertEquals("high priority", LOW_PRI +1, msg.getJMSPriority());	msg = sub.receive(15000);	assertNotNull("Message was null", msg);	
received hi 

public boolean isSatisified() throws Exception {	
enqueues dequeues 

producer.send(message, Message.DEFAULT_DELIVERY_MODE, message.getJMSPriority(), Message.DEFAULT_TIME_TO_LIVE);	}	assertTrue("Got all", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return numMessages == received.get();	}	}));	final DestinationStatistics destinationStatistics = ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics();	assertTrue("Nothing else Like dlq involved", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
enqueues dequeues 

}	producer.send(message, Message.DEFAULT_DELIVERY_MODE, message.getJMSPriority(), Message.DEFAULT_TIME_TO_LIVE);	}	assertTrue("Got all", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return numMessages == received.get();	}	}));	assertTrue("Nothing else Like dlq involved", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
enqueues dequeues 

========================= activemq sample_3794 =========================

private void createDurableSubscription() throws JMSException {	final Connection connection = connectionFactory.createConnection();	connection.setClientID(CLIENT_ID);	final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	final Topic topic = session.createTopic(TOPIC_NAME);	connection.start();	session.createDurableSubscriber(topic, SUBSCRIPTION_NAME, null, false);	
created durable subscription 

private void unsubscribeDurableSubscription() throws JMSException {	final Connection connection = connectionFactory.createConnection();	connection.setClientID(CLIENT_ID);	final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	session.unsubscribe(SUBSCRIPTION_NAME);	
unsubscribed durable subscription 

========================= activemq sample_2886 =========================

public void testForConnectionLeak() throws Exception {	Integer expectedConnectionCount = 0;	for (int i=0; i < ITERATIONS; i++) {	try {	if (i % 2 == 0) {	
iteration adding bad connection 

public void testForConnectionLeak() throws Exception {	Integer expectedConnectionCount = 0;	for (int i=0; i < ITERATIONS; i++) {	try {	if (i % 2 == 0) {	Connection connection = connectionFactory.createConnection(USER, WRONG_PASSWORD);	connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	fail("createSession should fail");	} else {	
iteration adding good connection 

Connection connection = connectionFactory.createConnection(USER, WRONG_PASSWORD);	connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	fail("createSession should fail");	} else {	Connection connection = connectionFactory.createConnection(USER, GOOD_USER_PASSWORD);	connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	expectedConnectionCount++;	}	} catch (JMSSecurityException e) {	}	
iteration connections 

========================= activemq sample_2605 =========================

public void gc() throws Exception {	brokerService.getBroker().gc();	try {	brokerService.getPersistenceAdapter().checkpoint(true);	} catch (IOException e) {	
failed to checkpoint persistence adapter on gc request 

public Map<String, String> getTransportConnectors() {	Map<String, String> answer = new HashMap<String, String>();	try {	for (TransportConnector connector : brokerService.getTransportConnectors()) {	answer.put(connector.getName(), connector.getConnectUri().toString());	}	} catch (Exception e) {	
failed to read uri to build transport connectors map 

========================= activemq sample_3917 =========================

public void testMod() throws Exception {	BrokerService brokerService = new BrokerService();	brokerService.setDestinations(new ActiveMQDestination[] {new ActiveMQQueue("ORIGINAL")});	startBroker(brokerService);	assertTrue("broker alive", brokerService.isStarted());	printDestinations();	assertTrue("contains original", containsDestination(new ActiveMQQueue("ORIGINAL")));	
adding destinations 

printDestinations();	assertTrue("contains original", containsDestination(new ActiveMQQueue("ORIGINAL")));	javaConfigBroker.setDestinations(new ActiveMQDestination[] {	new ActiveMQTopic("BEFORE"), new ActiveMQQueue("ORIGINAL"), new ActiveMQQueue("AFTER")});	printDestinations();	assertTrue("contains destinations", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return containsDestination(new ActiveMQQueue("ORIGINAL")) && containsDestination(new ActiveMQTopic("BEFORE")) && containsDestination(new ActiveMQQueue("AFTER"));	}	}, TimeUnit.MILLISECONDS.convert(SLEEP, TimeUnit.SECONDS)));	
removing destinations 

protected void printDestinations() throws Exception {	ActiveMQDestination[] destinations = brokerService.getRegionBroker().getDestinations();	for (ActiveMQDestination destination : destinations) {	
broker destination 

========================= activemq sample_4381 =========================

protected byte doSubscribe(ConsumerInfo consumerInfo, final String topicName, final QoS qoS) throws MQTTProtocolException {	MQTTSubscription mqttSubscription = new MQTTSubscription(protocol, topicName, qoS, consumerInfo);	subscriptionsByConsumerId.put(consumerInfo.getConsumerId(), mqttSubscription);	mqttSubscriptionByTopic.put(topicName, mqttSubscription);	final byte[] qos = {-1};	protocol.sendToActiveMQ(consumerInfo, new ResponseHandler() {	public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {	if (response.isException()) {	final Throwable throwable = ((ExceptionResponse) response).getException();	
error subscribing to 

RemoveSubscriptionInfo rsi = new RemoveSubscriptionInfo();	rsi.setConnectionId(protocol.getConnectionId());	rsi.setSubscriptionName(sub.getSubcriptionName());	rsi.setClientId(sub.getClientId());	protocol.sendToActiveMQ(rsi, new ResponseHandler() {	public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {	}	});	}	} catch (Throwable e) {	
could not delete the mqtt durable subs 

protected void restoreDurableSubs(List<SubscriptionInfo> subs) {	try {	for (SubscriptionInfo sub : subs) {	String name = sub.getSubcriptionName();	String[] split = name.split(":", 2);	QoS qoS = QoS.valueOf(split[0]);	onSubscribe(new Topic(split[1], qoS));	restoredDurableSubs.add(MQTTProtocolSupport.convertMQTTToActiveMQ(split[1]));	}	} catch (IOException e) {	
could not restore the mqtt durable subs 

RegionBroker regionBroker;	try {	regionBroker = (RegionBroker) brokerService.getBroker().getAdaptor(RegionBroker.class);	} catch (Exception e) {	throw new MQTTProtocolException("Error recovering durable subscriptions: " + e.getMessage(), false, e);	}	final TopicRegion topicRegion = (TopicRegion) regionBroker.getTopicRegion();	List<DurableTopicSubscription> subscriptions = topicRegion.lookupSubscriptions(clientId);	if (subscriptions != null) {	for (DurableTopicSubscription subscription : subscriptions) {	
recovered durable sub on connect 

========================= activemq sample_908 =========================

protected void runTask(List<String> tokens) throws Exception {	
connecting to url as user 

protected void runTask(List<String> tokens) throws Exception {	
consuming 

protected void runTask(List<String> tokens) throws Exception {	
sleeping between receives ms 

protected void runTask(List<String> tokens) throws Exception {	
running parallel threads 

========================= activemq sample_1496 =========================

message.writeBytes(new byte[1024 *1024]);	producer.send(message);	}	Thread.sleep(1000);	String objectNameStr = broker.getBrokerObjectName().toString();	objectNameStr += ",service=Health";	ObjectName brokerName = assertRegisteredObjectName(objectNameStr);	HealthViewMBean health =  MBeanServerInvocationHandler.newProxyInstance(mbeanServer, brokerName, HealthViewMBean.class, true);	List<HealthStatus> list = health.healthList();	for (HealthStatus status : list) {	
health status 

protected ObjectName assertRegisteredObjectName(String name) throws MalformedObjectNameException, NullPointerException {	ObjectName objectName = new ObjectName(name);	if (mbeanServer.isRegistered(objectName)) {	
bean registered 

========================= activemq sample_2310 =========================

for (int i=0; i<iterations; i++) {	PList candidate = lists[i%numLists];	Thread.currentThread().setName("ALRF:"+candidate.getName());	synchronized (plistLocks(candidate)) {	Object last = candidate.addLast(String.valueOf(i), payload);	getFirst(candidate);	assertTrue(candidate.remove(last));	}	}	} catch (Exception error) {	
unexpcted ex 

}	};	executor.execute(new A());	executor.execute(new A());	executor.execute(new A());	executor.execute(new B());	executor.execute(new B());	executor.execute(new B());	executor.shutdown();	boolean finishedInTime = executor.awaitTermination(5, TimeUnit.MINUTES);	
tested completion finished in time YES NO 

public void testConcurrentAddRemoveWithPreload() throws Exception {	File directory = store.getDirectory();	store.stop();	IOHelper.mkdirs(directory);	IOHelper.deleteChildren(directory);	store = createConcurrentAddRemoveWithPreloadPListStore();	store.setDirectory(directory);	store.start();	final int iterations = 500;	final int numLists = 10;	
create 

IOHelper.mkdirs(directory);	IOHelper.deleteChildren(directory);	store = createConcurrentAddRemoveWithPreloadPListStore();	store.setDirectory(directory);	store.start();	final int iterations = 500;	final int numLists = 10;	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.CREATE, iterations).run();	}	
delete 

store.setDirectory(directory);	store.start();	final int iterations = 500;	final int numLists = 10;	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.CREATE, iterations).run();	}	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.DELETE, iterations).run();	}	
fill 

final int numLists = 10;	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.CREATE, iterations).run();	}	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.DELETE, iterations).run();	}	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.ADD, iterations).run();	}	
remove 

}	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.DELETE, iterations).run();	}	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.ADD, iterations).run();	}	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.REMOVE, iterations).run();	}	
check empty 

}	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.ADD, iterations).run();	}	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.REMOVE, iterations).run();	}	for (int i=0; i<numLists;i++) {	assertEquals("empty " + i, 0, store.getPList("List-" + i).size());	}	
delete again 

}	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.REMOVE, iterations).run();	}	for (int i=0; i<numLists;i++) {	assertEquals("empty " + i, 0, store.getPList("List-" + i).size());	}	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.DELETE, iterations).run();	}	
fill again 

}	for (int i=0; i<numLists;i++) {	assertEquals("empty " + i, 0, store.getPList("List-" + i).size());	}	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.DELETE, iterations).run();	}	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.ADD, iterations).run();	}	
parallel add and remove 

new Job(i, PListTestSupport.TaskType.DELETE, iterations).run();	}	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.ADD, iterations).run();	}	executor = Executors.newFixedThreadPool(numLists*2);	for (int i=0; i<numLists*2; i++) {	executor.execute(new Job(i, i>=numLists ? PListTestSupport.TaskType.ADD : PListTestSupport.TaskType.REMOVE, iterations));	}	executor.shutdown();	
wait for parallel work to complete 

public void do_testConcurrentAddIterateRemove(boolean enablePageCache) throws Exception {	File directory = store.getDirectory();	store.stop();	IOHelper.mkdirs(directory);	IOHelper.deleteChildren(directory);	store = createConcurrentAddIterateRemovePListStore(enablePageCache);	store.setDirectory(directory);	store.start();	final int iterations = 500;	final int numLists = 10;	
create 

IOHelper.mkdirs(directory);	IOHelper.deleteChildren(directory);	store = createConcurrentAddIterateRemovePListStore(enablePageCache);	store.setDirectory(directory);	store.start();	final int iterations = 500;	final int numLists = 10;	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.CREATE, iterations).run();	}	
fill 

store.setDirectory(directory);	store.start();	final int iterations = 500;	final int numLists = 10;	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.CREATE, iterations).run();	}	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.ADD, iterations).run();	}	
parallel add and remove 

executor.execute(new Job(i, PListTestSupport.TaskType.ADD, iterations*2));	}	for (int k=0;k<numConsumer; k++) {	executor.execute(new Job(i, TaskType.ITERATE_REMOVE, iterations/4));	}	}	for (int i=numLists; i<numLists*10; i++) {	executor.execute(new Job(i, PListTestSupport.TaskType.ADD, iterations));	}	executor.shutdown();	
wait for parallel work to complete 

public void testConcurrentAddIterate() throws Exception {	File directory = store.getDirectory();	store.stop();	IOHelper.mkdirs(directory);	IOHelper.deleteChildren(directory);	store = createConcurrentAddIteratePListStore();	store.setDirectory(directory);	store.start();	final int iterations = 250;	final int numLists = 10;	
create 

IOHelper.mkdirs(directory);	IOHelper.deleteChildren(directory);	store = createConcurrentAddIteratePListStore();	store.setDirectory(directory);	store.start();	final int iterations = 250;	final int numLists = 10;	for (int i=0; i<numLists;i++) {	new Job(i, PListTestSupport.TaskType.CREATE, iterations).run();	}	
parallel add and iterate 

final int numConsumer = 100;	for (int i=0; i<numLists; i++) {	for (int j=0; j<numProducer; j++) {	executor.execute(new Job(i, PListTestSupport.TaskType.ADD, iterations));	}	for (int k=0;k<numConsumer; k++) {	executor.execute(new Job(i, TaskType.ITERATE, iterations*2));	}	}	executor.shutdown();	
wait for parallel work to complete 

public void run() {	final String threadName = Thread.currentThread().getName();	try {	PList plist = null;	switch (task) {	case CREATE: Thread.currentThread().setName("C:"+id);	plist = store.getPList(String.valueOf(id));	
job create 

synchronized (plistLocks(plist)) {	if (exceptions.isEmpty()) {	String key = "PL>" + id + idSeed + "-" + j;	entries.put(key, plist.addLast(key, payload));	} else {	break;	}	}	}	if (exceptions.isEmpty()) {	
job add done 

case REMOVE: Thread.currentThread().setName("R:"+id);	plist = store.getPList(String.valueOf(id));	synchronized (plistLocks(plist)) {	for (int j = iterations -1; j >= 0; j--) {	String key = "PL>" + id + idSeed + "-" + j;	Object position = entries.remove(key);	if( position!=null ) {	plist.remove(position);	}	if (j > 0 && j % (iterations / 2) == 0) {	
job done remove 

synchronized (plistLocks(plist)) {	Iterator<PListEntry> removeIterator = plist.iterator();	while (removeIterator.hasNext()) {	removeIterator.next();	removeIterator.remove();	if (removeCount++ > iterations) {	break;	}	}	}	
job done remove 

removeIterator.next();	removeIterator.remove();	if (removeCount++ > iterations) {	break;	}	}	}	break;	default: }	} catch (Exception e) {	
job caught exception 

========================= activemq sample_3852 =========================

protected void doTest() throws Exception {	messageCount = 200;	connection.start();	final QueueViewMBean dlqView = getProxyToDLQ();	ActiveMQConnection amqConnection = (ActiveMQConnection) connection;	rollbackCount = amqConnection.getRedeliveryPolicy().getMaximumRedeliveries() + 1;	
will redeliver messages times 

public boolean isSatisified() throws Exception {	return dlqView.getQueueSize() == messageCount;	}	}));	connection.stop();	assertEquals("DLQ should be full now.", messageCount, dlqView.getQueueSize());	String moveTo;	if (topic) {	moveTo = "topic: } else {	moveTo = "queue: }	
moving messages from activemq dlq to 

protected void makeConsumer() throws JMSException {	Destination destination = getDestination();	
consuming from 

protected void makeDlqConsumer() throws JMSException {	dlqDestination = createDlqDestination();	
consuming from dead letter on 

protected void sendMessages() throws JMSException {	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	producer = session.createProducer(getDestination());	producer.setDeliveryMode(deliveryMode);	
sending messages to 

public void onMessage(Message message) {	try {	int expectedMessageId = rollbacks.get() / deliveryCount;	
expecting messageid 

public void onMessage(Message message) {	try {	int expectedMessageId = rollbacks.get() / deliveryCount;	rollbacks.incrementAndGet();	session.rollback();	} catch (Throwable e) {	
unexpected exception 

========================= activemq sample_2890 =========================

message.setMemoryUsage(this.getSystemUsage().getMemoryUsage());	}	}	message.incrementReferenceCount();	batchList.addMessageLast(message);	clearIterator(true);	recovered = true;	} else if (!cached) {	if (duplicateFromStoreExcepted(message)) {	if (LOG.isTraceEnabled()) {	
store replayed pending message due to concurrentstoreanddispatchqueues seq 

}	message.incrementReferenceCount();	batchList.addMessageLast(message);	clearIterator(true);	recovered = true;	} else if (!cached) {	if (duplicateFromStoreExcepted(message)) {	if (LOG.isTraceEnabled()) {	}	} else {	
cursor got duplicate from store seq 

clearIterator(true);	recovered = true;	} else if (!cached) {	if (duplicateFromStoreExcepted(message)) {	if (LOG.isTraceEnabled()) {	}	} else {	duplicate(message);	}	} else {	
cursor got duplicate send seq 

public final synchronized void reset() {	if (batchList.isEmpty()) {	try {	fillBatch();	} catch (Exception e) {	
failed to fill batch 

public final synchronized boolean hasNext() {	if (batchList.isEmpty()) {	try {	fillBatch();	} catch (Exception e) {	
failed to fill batch 

} else {	dealWithDuplicates();	return false;	}	}	} else {	disableCache = true;	}	if (disableCache && isCacheEnabled()) {	if (LOG.isTraceEnabled()) {	
disabling cache on add 

protected boolean enableCacheNow() {	boolean result = false;	if (canEnableCash()) {	setCacheEnabled(true);	result = true;	if (LOG.isTraceEnabled()) {	
enabling cache on empty store 

Future future = (Future) futureOrLong;	if (future.isCancelled()) {	continue;	}	try {	future.get(5, TimeUnit.SECONDS);	setLastCachedId(ASYNC_ADD, lastPending);	} catch (CancellationException ok) {	continue;	} catch (TimeoutException potentialDeadlock) {	
timed out waiting for async add 

if (future.isCancelled()) {	continue;	}	try {	future.get(5, TimeUnit.SECONDS);	setLastCachedId(ASYNC_ADD, lastPending);	} catch (CancellationException ok) {	continue;	} catch (TimeoutException potentialDeadlock) {	} catch (Exception worstCaseWeReplay) {	
exception waiting for async add 

protected final synchronized void fillBatch() {	if (LOG.isTraceEnabled()) {	
fillbatch 

if (batchResetNeeded) {	resetSize();	setMaxBatchSize(Math.min(regionDestination.getMaxPageSize(), size));	resetBatch();	this.batchResetNeeded = false;	}	if (this.batchList.isEmpty() && this.size >0) {	try {	doFillBatch();	} catch (Exception e) {	
failed to fill batch 

========================= activemq sample_4047 =========================

connection.start();	final long sendCount = 2000;	final Thread producingThread = new Thread("Producing Thread") {	public void run() {	try {	int i = 0;	long tStamp = System.currentTimeMillis();	while (i++ < sendCount) {	producer.send(session.createTextMessage("test"));	if (i%100 == 0) {	
sent m ms 

connection.start();	final long sendCount = 2000;	final Thread producingThread = new Thread("Producing Thread") {	public void run() {	try {	int i = 0;	long tStamp = System.currentTimeMillis();	while (i++ < sendCount) {	producer.send(session.createTextMessage("test"));	if (i%100 == 0) {	
sent m ms 

producer = session.createProducer(destination);	final int ttl = 4000;	producer.setTimeToLive(ttl);	final long sendCount = 10;	final CountDownLatch receivedOneCondition = new CountDownLatch(1);	final CountDownLatch waitCondition = new CountDownLatch(1);	MessageConsumer consumer = session.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	
got my message 

producer.setTimeToLive(ttl);	final long sendCount = 10;	final CountDownLatch receivedOneCondition = new CountDownLatch(1);	final CountDownLatch waitCondition = new CountDownLatch(1);	MessageConsumer consumer = session.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	receivedOneCondition.countDown();	waitCondition.await(6, TimeUnit.MINUTES);	
acking message 

});	connection.start();	final Thread producingThread = new Thread("Producing Thread") {	public void run() {	try {	int i = 0;	long tStamp = System.currentTimeMillis();	while (i++ < sendCount) {	producer.send(session.createTextMessage("test"));	if (i%100 == 0) {	
sent m ms 

assertEquals("inflight reduced to duck", 0, view.getInFlightCount());	assertEquals("size didn't get back to 0 ", 0, view.getQueueSize());	assertEquals("dequeues didn't match sent/expired ", sendCount, view.getDequeueCount());	consumer.close();	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return 0 == view.getInFlightCount();	}	});	assertEquals("inflight goes to zero on close", 0, view.getInFlightCount());	
done 

producer.setTimeToLive(ttl);	final long sendCount = 1500;	final CountDownLatch receivedOneCondition = new CountDownLatch(1);	final CountDownLatch waitCondition = new CountDownLatch(1);	final AtomicLong received = new AtomicLong();	MessageConsumer consumer = session.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	if(LOG.isDebugEnabled()) {	
got my message 

MessageConsumer consumer = session.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	if(LOG.isDebugEnabled()) {	}	receivedOneCondition.countDown();	received.incrementAndGet();	waitCondition.await(5, TimeUnit.MINUTES);	if(LOG.isDebugEnabled()) {	
acking message 

});	connection.start();	final Thread producingThread = new Thread("Producing Thread") {	public void run() {	try {	int i = 0;	long tStamp = System.currentTimeMillis();	while (i++ < sendCount) {	producer.send(session.createTextMessage("test"));	if (i%100 == 0) {	
sent m ms 

});	LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount() + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount() + ", size= " + view.getQueueSize());	assertEquals("inflight didn't reduce to duck", 0, view.getInFlightCount());	assertEquals("size doesn't get back to 0 ", 0, view.getQueueSize());	assertEquals("dequeues don't match sent/expired ", sendCount, view.getDequeueCount());	producer.setTimeToLive(0);	long tStamp = System.currentTimeMillis();	for (int i=0; i<sendCount; i++) {	producer.send(session.createTextMessage("test-" + i));	if (i%100 == 0) {	
sent m ms 

return received.get() >= sendCount;	}	});	consumer.close();	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return 0 == view.getInFlightCount();	}	});	assertEquals("inflight did not go to zero on close", 0, view.getInFlightCount());	
done 

producer = session.createProducer(destination);	final int ttl = 1000;	producer.setTimeToLive(ttl);	final long sendCount = 10;	TopicSubscriber sub = session.createDurableSubscriber(destination, "mySub");	sub.close();	for (int i=0; i < sendCount; i++) {	producer.send(session.createTextMessage("test"));	}	DestinationViewMBean view = createView((ActiveMQTopic)destination);	
messages sent 

LOG.info("expired=" + view.getExpiredCount() + " " +  view.getEnqueueCount());	assertEquals(10, view.getExpiredCount());	assertEquals(10, view.getEnqueueCount());	final AtomicLong received = new AtomicLong();	sub = session.createDurableSubscriber(destination, "mySub");	sub.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	received.incrementAndGet();	}	});	
waiting for messages to arrive 

========================= activemq sample_3628 =========================

if (type == LastPartialCommand.DATA_STRUCTURE_TYPE) {	try {	byte[] fullData = out.toByteArray();	out.reset();	DataInputStream dataIn = new DataInputStream(new ByteArrayInputStream(fullData));	Command completeCommand = (Command)wireFormat.unmarshal(dataIn);	LastPartialCommand lastCommand = (LastPartialCommand)command;	lastCommand.configure(completeCommand);	getTransportListener().onCommand(completeCommand);	} catch (IOException e) {	
failed to unmarshal partial command 

========================= activemq sample_47 =========================

protected void registerMBean(ObjectName name) {	if (name != null) {	try {	AnnotatedMBean.registerMBean(managementContext, mbean, name);	} catch (Throwable e) {	
failed to register mbean 

protected void registerMBean(ObjectName name) {	if (name != null) {	try {	AnnotatedMBean.registerMBean(managementContext, mbean, name);	} catch (Throwable e) {	
failure reason 

protected void unregisterMBean(ObjectName name) {	if (name != null) {	try {	managementContext.unregisterMBean(name);	} catch (Throwable e) {	
failed to unregister mbean 

protected void unregisterMBean(ObjectName name) {	if (name != null) {	try {	managementContext.unregisterMBean(name);	} catch (Throwable e) {	
failure reason 

========================= activemq sample_3940 =========================

public void testStaysUp() throws Exception {	int bridgeIdentity = getBridgeId();	
bridges 

========================= activemq sample_2717 =========================

private void stopDerby() {	
stopping db 

========================= activemq sample_2347 =========================

ByteSequence tcpContent = tcpMessage.getContent();	ByteSequence httpContent = httpMessage.getContent();	assertNotNull(tcpContent);	assertNotNull(httpContent);	assertTrue(tcpMessage.isCompressed());	assertTrue(httpMessage.isCompressed());	int tcpCompressedSize = tcpContent.getLength();	int httpCompressedSize = httpContent.getLength();	assertEquals(tcpContent.getLength(), httpContent.getLength());	assertEquals(tcpMessage.getText(), httpMessage.getText());	
received message on tcp 

ByteSequence tcpContent = tcpMessage.getContent();	ByteSequence httpContent = httpMessage.getContent();	assertNotNull(tcpContent);	assertNotNull(httpContent);	assertTrue(tcpMessage.isCompressed());	assertTrue(httpMessage.isCompressed());	int tcpCompressedSize = tcpContent.getLength();	int httpCompressedSize = httpContent.getLength();	assertEquals(tcpContent.getLength(), httpContent.getLength());	assertEquals(tcpMessage.getText(), httpMessage.getText());	
received message on http 

ByteSequence tcpContent = tcpMessage.getContent();	ByteSequence httpContent = httpMessage.getContent();	assertNotNull(tcpContent);	assertNotNull(httpContent);	assertTrue(tcpMessage.isCompressed());	assertTrue(httpMessage.isCompressed());	int tcpCompressedSize = tcpContent.getLength();	int httpCompressedSize = httpContent.getLength();	assertEquals(tcpContent.getLength(), httpContent.getLength());	assertEquals(tcpMessage.readUTF(), httpMessage.readUTF());	
received message on tcp 

ByteSequence tcpContent = tcpMessage.getContent();	ByteSequence httpContent = httpMessage.getContent();	assertNotNull(tcpContent);	assertNotNull(httpContent);	assertTrue(tcpMessage.isCompressed());	assertTrue(httpMessage.isCompressed());	int tcpCompressedSize = tcpContent.getLength();	int httpCompressedSize = httpContent.getLength();	assertEquals(tcpContent.getLength(), httpContent.getLength());	assertEquals(tcpMessage.readUTF(), httpMessage.readUTF());	
received message on http 

ByteSequence tcpContent = tcpMessage.getContent();	ByteSequence httpContent = httpMessage.getContent();	assertNotNull(tcpContent);	assertNotNull(httpContent);	assertTrue(tcpMessage.isCompressed());	assertTrue(httpMessage.isCompressed());	int tcpCompressedSize = tcpContent.getLength();	int httpCompressedSize = httpContent.getLength();	assertEquals(tcpContent.getLength(), httpContent.getLength());	assertEquals(tcpMessage.readString(), httpMessage.readString());	
received message on tcp 

ByteSequence tcpContent = tcpMessage.getContent();	ByteSequence httpContent = httpMessage.getContent();	assertNotNull(tcpContent);	assertNotNull(httpContent);	assertTrue(tcpMessage.isCompressed());	assertTrue(httpMessage.isCompressed());	int tcpCompressedSize = tcpContent.getLength();	int httpCompressedSize = httpContent.getLength();	assertEquals(tcpContent.getLength(), httpContent.getLength());	assertEquals(tcpMessage.readString(), httpMessage.readString());	
received message on http 

ByteSequence tcpContent = tcpMessage.getContent();	ByteSequence httpContent = httpMessage.getContent();	assertNotNull(tcpContent);	assertNotNull(httpContent);	assertTrue(tcpMessage.isCompressed());	assertTrue(httpMessage.isCompressed());	int tcpCompressedSize = tcpContent.getLength();	int httpCompressedSize = httpContent.getLength();	assertEquals(tcpContent.getLength(), httpContent.getLength());	assertEquals(tcpMessage.getString("content"), httpMessage.getString("content"));	
received message on tcp 

ByteSequence tcpContent = tcpMessage.getContent();	ByteSequence httpContent = httpMessage.getContent();	assertNotNull(tcpContent);	assertNotNull(httpContent);	assertTrue(tcpMessage.isCompressed());	assertTrue(httpMessage.isCompressed());	int tcpCompressedSize = tcpContent.getLength();	int httpCompressedSize = httpContent.getLength();	assertEquals(tcpContent.getLength(), httpContent.getLength());	assertEquals(tcpMessage.getString("content"), httpMessage.getString("content"));	
received message on http 

========================= activemq sample_1091 =========================

public DedicatedTaskRunner(final Task task, String name, int priority, boolean daemon) {	this.task = task;	thread = new Thread(name) {	public void run() {	try {	runTask();	} finally {	
run task done 

public void shutdown(long timeout) throws InterruptedException {	
shutdown timeout task 

========================= activemq sample_725 =========================

public void addSubscription(ConnectionContext context, Subscription sub) throws Exception {	if (!context.isFaultTolerant() && (!context.isNetworkConnection() && !tempDest .getConnectionId().equals( sub.getConsumerInfo().getConsumerId() .getConnectionId()))) {	tempDest.setConnectionId(sub.getConsumerInfo().getConsumerId().getConnectionId());	if (LOG.isDebugEnabled()) {	
changed ownership of to 

========================= activemq sample_4010 =========================

Session session = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(deliveryMode);	for (int idx = 0; idx < MESSAGES_COUNT; ++idx) {	Message message = session.createTextMessage(new String(buf) + idx);	producer.send(message);	messagesSent.incrementAndGet();	producerHasSentTenMessages.countDown();	Thread.sleep(10);	if (idx != 0 && idx%100 == 0) {	
sent message 

Session session = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(deliveryMode);	for (int idx = 0; idx < MESSAGES_COUNT; ++idx) {	Message message = session.createTextMessage(new String(buf) + idx);	producer.send(message);	messagesSent.incrementAndGet();	producerHasSentTenMessages.countDown();	Thread.sleep(10);	if (idx != 0 && idx%100 == 0) {	
temp store usage 

}	}	};	producingThread.start();	assertTrue("producer has sent 10 in a reasonable time", producerHasSentTenMessages.await(30, TimeUnit.SECONDS));	int count = 0;	Message m = null;	while ((m = consumer.receive(messageReceiveTimeout)) != null) {	count++;	if (count != 0 && count%10 == 0) {	
recieved message 

int count = 0;	Message m = null;	while ((m = consumer.receive(messageReceiveTimeout)) != null) {	count++;	if (count != 0 && count%10 == 0) {	}	messagesConsumed.incrementAndGet();	try {	Thread.sleep(100);	} catch (Exception e) {	
error sleeping 

while ((m = consumer.receive(messageReceiveTimeout)) != null) {	count++;	if (count != 0 && count%10 == 0) {	}	messagesConsumed.incrementAndGet();	try {	Thread.sleep(100);	} catch (Exception e) {	}	}	
connection timeout retrying count 

}	messagesConsumed.incrementAndGet();	try {	Thread.sleep(100);	} catch (Exception e) {	}	}	while ((m = consumer.receive(messageReceiveTimeout)) != null) {	count++;	if (count != 0 && count%100 == 0) {	
recieved message 

}	}	while ((m = consumer.receive(messageReceiveTimeout)) != null) {	count++;	if (count != 0 && count%100 == 0) {	}	messagesConsumed.incrementAndGet();	try {	Thread.sleep(100);	} catch (Exception e) {	
error sleeping 

while ((m = consumer.receive(messageReceiveTimeout)) != null) {	count++;	if (count != 0 && count%100 == 0) {	}	messagesConsumed.incrementAndGet();	try {	Thread.sleep(100);	} catch (Exception e) {	}	}	
consumer session closing consumed count 

}	messagesConsumed.incrementAndGet();	try {	Thread.sleep(100);	} catch (Exception e) {	}	}	consumerSession.close();	producingThread.join();	final long tempUsageBySubscription = broker.getSystemUsage().getTempUsage().getUsage();	
orig usage currentusage 

try {	Thread.sleep(100);	} catch (Exception e) {	}	}	consumerSession.close();	producingThread.join();	final long tempUsageBySubscription = broker.getSystemUsage().getTempUsage().getUsage();	producerConnection.close();	consumerConnection.close();	
subscrition usage endusage 

Thread.sleep(100);	} catch (Exception e) {	}	}	consumerSession.close();	producingThread.join();	final long tempUsageBySubscription = broker.getSystemUsage().getTempUsage().getUsage();	producerConnection.close();	consumerConnection.close();	((PListStoreImpl)broker.getTempDataStore()).run();	
subscrition usage endusage 

producerConnection.start();	Session session = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	try {	while (true) {	Message message = session.createTextMessage(new String(buf) + messagesSent.toString());	producer.send(message);	messagesSent.incrementAndGet();	if (messagesSent.get() % 100 == 0) {	
sent message 

producerConnection.start();	Session session = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	try {	while (true) {	Message message = session.createTextMessage(new String(buf) + messagesSent.toString());	producer.send(message);	messagesSent.incrementAndGet();	if (messagesSent.get() % 100 == 0) {	
temp store usage 

producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	try {	while (true) {	Message message = session.createTextMessage(new String(buf) + messagesSent.toString());	producer.send(message);	messagesSent.incrementAndGet();	if (messagesSent.get() % 100 == 0) {	}	}	} catch (ResourceAllocationException ex) {	
got resource exception after sent 

}	} catch (ResourceAllocationException ex) {	}	Connection consumerConnection = factory.createConnection();	consumerConnection.start();	Session consumerSession = consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = consumerSession.createConsumer(destination);	while (consumer.receive(messageReceiveTimeout) != null) {	messagesConsumed.incrementAndGet();	if (messagesConsumed.get() % 1000 == 0) {	
received message 

}	} catch (ResourceAllocationException ex) {	}	Connection consumerConnection = factory.createConnection();	consumerConnection.start();	Session consumerSession = consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = consumerSession.createConsumer(destination);	while (consumer.receive(messageReceiveTimeout) != null) {	messagesConsumed.incrementAndGet();	if (messagesConsumed.get() % 1000 == 0) {	
temp store usage 

========================= activemq sample_2828 =========================

final Destination dest = sess.createQueue(this.getClass().getName());	final ProducerThread producer = new ProducerThread(sess, dest);	producer.start();	assertTrue("some messages sent", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	BaseDestination baseDestination = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(dest);	return baseDestination != null && baseDestination.getDestinationStatistics().getEnqueues().getCount() > 0;	}	}));	BaseDestination baseDestination = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(dest);	
sent u 

public boolean isSatisified() throws Exception {	BaseDestination baseDestination = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(dest);	return baseDestination != null && baseDestination.getDestinationStatistics().getEnqueues().getCount() > 0;	}	}));	BaseDestination baseDestination = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(dest);	int sent = 0;	do {	sent = producer.getSentCount();	TimeUnit.SECONDS.sleep(1);	
sent 

BaseDestination baseDestination = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(dest);	return baseDestination != null && baseDestination.getDestinationStatistics().getEnqueues().getCount() > 0;	}	}));	BaseDestination baseDestination = (BaseDestination) broker.getRegionBroker().getDestinationMap().get(dest);	int sent = 0;	do {	sent = producer.getSentCount();	TimeUnit.SECONDS.sleep(1);	} while (sent !=  producer.getSentCount());	
increasing limit enqueues 

========================= activemq sample_2982 =========================

consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	received.add(message);	}	});	sendMessages();	session.commit();	connection.start();	assertTrue("Pre-Rollback expects to receive: " + MSG_COUNT + " messages.", Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception {	
consumer has received messages 

public boolean isSatisified() throws Exception {	return received.size() == MSG_COUNT;	}	}	));	beforeRollback.addAll(received);	received.clear();	session.rollback();	assertTrue("Post-Rollback expects to receive: " + MSG_COUNT + " messages.", Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception {	
consumer has received messages since rollback 

consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	received.add(message);	}	});	sendMessages();	session.commit();	connection.start();	assertTrue("Pre-Rollback expects to receive: " + MSG_COUNT + " messages.", Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception {	
consumer has received messages 

public boolean isSatisified() throws Exception {	return received.size() == MSG_COUNT;	}	}	));	beforeRollback.addAll(received);	received.clear();	session.rollback();	assertTrue("Post-Rollback expects to receive: " + MSG_COUNT + " messages.", Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception {	
consumer has received messages since rollback 

MessageConsumer consumer = session.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	received.add(message);	}	});	sendMessages();	connection.start();	assertTrue("Pre-Rollback expects to receive: " + MSG_COUNT + " messages.", Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception {	
consumer has received messages 

return received.size() == MSG_COUNT;	}	}	));	beforeRollback.addAll(received);	received.clear();	session.rollback();	sendMessages();	assertTrue("Post-Rollback expects to receive: " + MSG_COUNT + " messages.", Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception {	
consumer has received messages since rollback 

MessageConsumer consumer = session.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	received.add(message);	}	});	sendMessages();	connection.start();	assertTrue("Pre-Rollback expects to receive: " + MSG_COUNT + " messages.", Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception {	
consumer has received messages 

final MessageConsumer consumer = session.createConsumer(destination);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	received.add(message);	}	});	sendMessages();	connection.start();	assertTrue("Pre-Rollback expects to receive: " + MSG_COUNT + " messages.", Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception {	
consumer has received messages 

}	}	));	received.clear();	consumer.setMessageListener(new MessageListener() {	int count = 0;	public void onMessage(Message message) {	if (++count > 10) {	try {	session.rollback();	
rolling back session 

));	received.clear();	consumer.setMessageListener(new MessageListener() {	int count = 0;	public void onMessage(Message message) {	if (++count > 10) {	try {	session.rollback();	count = 0;	} catch (JMSException e) {	
caught an unexcepted exception 

try {	session.rollback();	count = 0;	} catch (JMSException e) {	}	} else {	received.add(message);	try {	session.commit();	} catch (JMSException e) {	
caught an unexcepted exception 

try {	session.commit();	} catch (JMSException e) {	}	}	}	});	session.rollback();	assertTrue("Post-Rollback expects to receive: " + MSG_COUNT + " messages.", Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception {	
consumer has received messages since rollback 

});	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	received.add(message);	}	});	sendMessages();	connection.start();	assertTrue("Pre-Rollback expects to receive: " + MSG_COUNT + " messages.", Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception {	
consumer has received messages 

return received.size() == MSG_COUNT;	}	}	));	session.rollback();	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	session.rollback();	} catch (JMSException e) {	
caught an unexcepted exception 

consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	session.rollback();	} catch (JMSException e) {	}	}	});	assertTrue("Post-Rollback expects to DLQ: " + MSG_COUNT + " messages.", Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception {	
consumer has received messages in dlq 

========================= activemq sample_3690 =========================

context = new ClassPathXmlApplicationContext(config);	consumer = (SpringConsumer) context.getBean("consumer");	assertTrue("Found a valid consumer", consumer != null);	consumer.start();	producer = (SpringProducer) context.getBean("producer");	assertTrue("Found a valid producer", producer != null);	consumer.flushMessages();	producer.start();	consumer.waitForMessagesToArrive(producer.getMessageCount());	List messages = consumer.flushMessages();	
consumer has received messages 

assertTrue("Found a valid consumer", consumer != null);	consumer.start();	producer = (SpringProducer) context.getBean("producer");	assertTrue("Found a valid producer", producer != null);	consumer.flushMessages();	producer.start();	consumer.waitForMessagesToArrive(producer.getMessageCount());	List messages = consumer.flushMessages();	for (Iterator iter = messages.iterator(); iter.hasNext();) {	Object message = iter.next();	
received 

========================= activemq sample_2296 =========================

protected BlockingQueueTransport getTransportChannel(HttpServletRequest request, HttpServletResponse response) throws IOException {	String clientID = request.getHeader("clientID");	if (clientID == null) {	response.sendError(HttpServletResponse.SC_BAD_REQUEST, "No clientID header specified");	
no clientid header specified 

protected BlockingQueueTransport getTransportChannel(HttpServletRequest request, HttpServletResponse response) throws IOException {	String clientID = request.getHeader("clientID");	if (clientID == null) {	response.sendError(HttpServletResponse.SC_BAD_REQUEST, "No clientID header specified");	return null;	}	BlockingQueueTransport answer = clients.get(clientID);	if (answer == null) {	
the clientid header specified is invalid client sesion has not yet been established for it 

protected BlockingQueueTransport createTransportChannel(HttpServletRequest request, HttpServletResponse response) throws IOException {	final String clientID = request.getHeader("clientID");	if (clientID == null) {	response.sendError(HttpServletResponse.SC_BAD_REQUEST, "No clientID header specified");	
no clientid header specified 

protected BlockingQueueTransport createTransportChannel(HttpServletRequest request, HttpServletResponse response) throws IOException {	final String clientID = request.getHeader("clientID");	if (clientID == null) {	response.sendError(HttpServletResponse.SC_BAD_REQUEST, "No clientID header specified");	return null;	}	BlockingQueueTransport answer = createTransportChannel();	if (clients.putIfAbsent(clientID, answer) != null) {	response.sendError(HttpServletResponse.SC_BAD_REQUEST, "A session for clientID '" + clientID + "' has already been established");	
a session for clientid has already been established 

}	listener.onAccept(transport);	while (!transport.isConnected() && !transport.isDisposed()) {	try {	Thread.sleep(100);	} catch (InterruptedException ignore) {	}	}	if (transport.isDisposed()) {	response.sendError(HttpServletResponse.SC_BAD_REQUEST, "The session for clientID '" + clientID + "' was prematurely disposed");	
the session for clientid was prematurely disposed 

========================= activemq sample_1140 =========================

public void start(BootstrapContext bootstrapContext) throws ResourceAdapterInternalException {	this.bootstrapContext = bootstrapContext;	if (brokerXmlConfig != null && brokerXmlConfig.trim().length() > 0) {	brokerStartThread = new Thread("Starting ActiveMQ Broker") {	public void run () {	try {	
original thread context classloader 

public void start(BootstrapContext bootstrapContext) throws ResourceAdapterInternalException {	this.bootstrapContext = bootstrapContext;	if (brokerXmlConfig != null && brokerXmlConfig.trim().length() > 0) {	brokerStartThread = new Thread("Starting ActiveMQ Broker") {	public void run () {	try {	Thread.currentThread().setContextClassLoader(getClass().getClassLoader());	
current from getclass thread context classloader 

public void run () {	try {	Thread.currentThread().setContextClassLoader(getClass().getClassLoader());	synchronized( ActiveMQResourceAdapter.this ) {	broker = BrokerFactory.createBroker(new URI(brokerXmlConfig));	}	broker.start();	if (getServerUrl() == null) {	setServerUrl("vm: }	} catch (Throwable e) {	
could not start up embeded activemq broker 

public void run () {	try {	Thread.currentThread().setContextClassLoader(getClass().getClassLoader());	synchronized( ActiveMQResourceAdapter.this ) {	broker = BrokerFactory.createBroker(new URI(brokerXmlConfig));	}	broker.start();	if (getServerUrl() == null) {	setServerUrl("vm: }	} catch (Throwable e) {	
reason for 

if (cf == null) {	cf = createConnectionFactory(getInfo(), activationSpec);	}	String userName = defaultValue(activationSpec.getUserName(), getInfo().getUserName());	String password = defaultValue(activationSpec.getPassword(), getInfo().getPassword());	String clientId = activationSpec.getClientId();	if (clientId != null) {	cf.setClientID(clientId);	} else {	if (activationSpec.isDurableSubscription()) {	
no clientid specified for durable subscription 

return new XAResource[]{	new TransactionContext() {	public boolean isSameRM(XAResource xaresource) throws XAException {	ActiveMQConnection original = null;	try {	original = setConnection(newConnection());	boolean result = super.isSameRM(xaresource);	LOG.trace("{}.recover({})={}", getConnection(), xaresource, result);	return result;	} catch (JMSException e) {	
issamerm failed 

return super.getResourceManagerId();	} finally {	closeConnection(original);	}	}	public void commit(Xid xid, boolean onePhase) throws XAException {	ActiveMQConnection original = null;	try {	setConnection(newConnection());	super.commit(xid, onePhase);	
commit 

} finally {	closeConnection(original);	}	}	public void commit(Xid xid, boolean onePhase) throws XAException {	ActiveMQConnection original = null;	try {	setConnection(newConnection());	super.commit(xid, onePhase);	} catch (JMSException e) {	
commit failed 

throwXAException(e);	} finally {	closeConnection(original);	}	}	public void rollback(Xid xid) throws XAException {	ActiveMQConnection original = null;	try {	original = setConnection(newConnection());	super.rollback(xid);	
rollback 

} finally {	closeConnection(original);	}	}	public void rollback(Xid xid) throws XAException {	ActiveMQConnection original = null;	try {	original = setConnection(newConnection());	super.rollback(xid);	} catch (JMSException e) {	
rollback failed 

}	}	public Xid[] recover(int flags) throws XAException {	Xid[] result = new Xid[]{};	ActiveMQConnection original = null;	try {	original = setConnection(newConnection());	result = super.recover(flags);	LOG.trace("{}.recover({})={}", getConnection(), flags, result);	} catch (JMSException e) {	
recover failed 

} finally {	closeConnection(original);	}	return result;	}	public void forget(Xid xid) throws XAException {	ActiveMQConnection original = null;	try {	original = setConnection(newConnection());	super.forget(xid);	
forget 

closeConnection(original);	}	return result;	}	public void forget(Xid xid) throws XAException {	ActiveMQConnection original = null;	try {	original = setConnection(newConnection());	super.forget(xid);	} catch (JMSException e) {	
forget failed 

========================= activemq sample_861 =========================

Session session = conn.createSession(true, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue("queue.a.b");	MessageProducer producer = session.createProducer(queue);	for (int i = 0; i < 100000; i++) {	BytesMessage bm = session.createBytesMessage();	bm.writeBytes(new byte[1024]);	producer.send(bm);	if ((i + 1) % 100 == 0) {	session.commit();	int memoryUsagePercent = broker.getSystemUsage().getMemoryUsage().getPercentUsage();	
messages have been sent broker memory usage 

========================= activemq sample_2783 =========================

QueueViewMBean queueView = getProxyToQueue(getDestinationName());	assertEquals(MSG_COUNT, queueView.getQueueSize());	connection = createConnection();	Session session = connection.createSession(false, ActiveMQSession.INDIVIDUAL_ACKNOWLEDGE);	Queue queue = session.createQueue(getDestinationName());	MessageConsumer consumer = session.createConsumer(queue);	connection.start();	done = new CountDownLatch(MSG_COUNT);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	
received message 

done.countDown();	}	});	done.await(15, TimeUnit.SECONDS);	consumer.close();	assertEquals(MSG_COUNT, queueView.getQueueSize());	consumer = session.createConsumer(queue);	done = new CountDownLatch(MSG_COUNT);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	
received message 

QueueViewMBean queueView = getProxyToQueue(getDestinationName());	assertEquals(MSG_COUNT, queueView.getQueueSize());	connection = createConnection();	Session session = connection.createSession(false, ActiveMQSession.INDIVIDUAL_ACKNOWLEDGE);	Queue queue = session.createQueue(getDestinationName());	MessageConsumer consumer = session.createConsumer(queue);	connection.start();	for (int i = 0; i < MSG_COUNT; ++i) {	Message message = consumer.receive(1000);	assertNotNull(message);	
received message 

for (int i = 0; i < MSG_COUNT; ++i) {	Message message = consumer.receive(1000);	assertNotNull(message);	}	consumer.close();	assertEquals(MSG_COUNT, queueView.getQueueSize());	consumer = session.createConsumer(queue);	for (int i = 0; i < MSG_COUNT; ++i) {	Message message = consumer.receive(1000);	assertNotNull(message);	
received message 

========================= activemq sample_2853 =========================

public void start() throws JMSException {	for (int i = 0; i < messageCount; i++) {	final String text = "Text for message: " + i;	template.send(destination, new MessageCreator() {	public Message createMessage(Session session) throws JMSException {	
sending message 

========================= activemq sample_3741 =========================

connectionA = connection1;	connectionB = connection2;	serverA = connector;	} else {	connectionA = connection2;	connectionB = connection1;	serverA = remoteConnector;	}	assertNotNull(receiveMessage(connectionA));	assertNoMessagesLeft(connectionB);	
disconnecting active server 

connectionB = connection2;	serverA = connector;	} else {	connectionA = connection2;	connectionB = connection1;	serverA = remoteConnector;	}	assertNotNull(receiveMessage(connectionA));	assertNoMessagesLeft(connectionB);	serverA.stop();	
sending request that should failover 

========================= activemq sample_2500 =========================

protected Destination createDlqDestination() {	String queueName = "Test.DLQ." + getClass().getName() + "." + getName();	
using queue name 

========================= activemq sample_2445 =========================

public void testDBCommitException() throws Exception {	org.apache.log4j.Logger serviceLogger = org.apache.log4j.Logger.getLogger(TransportConnection.class.getName() + ".Service");	serviceLogger.setLevel (Level.TRACE);	broker = this.createBroker(false);	broker.deleteAllMessages();	broker.start();	broker.waitUntilStarted();	try {	
broker started 

org.apache.log4j.Logger serviceLogger = org.apache.log4j.Logger.getLogger(TransportConnection.class.getName() + ".Service");	serviceLogger.setLevel (Level.TRACE);	broker = this.createBroker(false);	broker.deleteAllMessages();	broker.start();	broker.waitUntilStarted();	try {	String failoverTransportURL = "failover:(" + transportUrl + ")?timeout=5000";	sendMessage(MY_TEST_Q, failoverTransportURL);	ArrayList<Long> dbSeq = dbMessageCount(checkOnStoreConnection);	
after send db contains message seq 

broker.deleteAllMessages();	broker.start();	broker.waitUntilStarted();	try {	String failoverTransportURL = "failover:(" + transportUrl + ")?timeout=5000";	sendMessage(MY_TEST_Q, failoverTransportURL);	ArrayList<Long> dbSeq = dbMessageCount(checkOnStoreConnection);	List<TextMessage> consumedMessages = consumeMessages(MY_TEST_Q, failoverTransportURL);	assertEquals("number of consumed messages", 3, consumedMessages.size());	dbSeq = dbMessageCount(checkOnStoreConnection);	
after consume db contains message seq 

public List<TextMessage> consumeMessages(String queue, String transportURL) throws JMSException {	Connection connection = null;	
consumemessages called 

try {	ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory( transportURL);	connection = factory.createConnection();	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(queue);	ArrayList<TextMessage> consumedMessages = new ArrayList<TextMessage>();	MessageConsumer messageConsumer = session.createConsumer(destination);	while(true){	TextMessage textMessage= (TextMessage) messageConsumer.receive(4000);	
consumed messages 

public void sendMessage(String queue, String transportURL) throws Exception {	Connection connection = null;	try {	ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory( transportURL);	connection = factory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(queue);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	TextMessage m = session.createTextMessage("1");	
send message to broker 

Connection connection = null;	try {	ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory( transportURL);	connection = factory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(queue);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	TextMessage m = session.createTextMessage("1");	producer.send(m);	
send message to broker 

connection = factory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(queue);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	TextMessage m = session.createTextMessage("1");	producer.send(m);	m.setText("2");	producer.send(m);	ArrayList<Long> dbSeq = dbMessageCount(checkOnStoreConnection);	
after send db contains message seq 

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(queue);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	TextMessage m = session.createTextMessage("1");	producer.send(m);	m.setText("2");	producer.send(m);	ArrayList<Long> dbSeq = dbMessageCount(checkOnStoreConnection);	assertEquals("number of messages in DB after send 2",2,dbSeq.size());	
send message to broker 

MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	TextMessage m = session.createTextMessage("1");	producer.send(m);	m.setText("2");	producer.send(m);	ArrayList<Long> dbSeq = dbMessageCount(checkOnStoreConnection);	assertEquals("number of messages in DB after send 2",2,dbSeq.size());	m.setText("3");	producer.send(m);	
finished sending messages to broker 

public void executeBatch() throws SQLException {	super.executeBatch();	count++;	
executebatchoverride count executeBatch 

========================= activemq sample_2916 =========================

connection = null;	if ( topic ) {	broker.getAdminView().removeTopic(((ActiveMQDestination)dest).getPhysicalName());	} else {	broker.getAdminView().removeQueue(((ActiveMQDestination)dest).getPhysicalName());	}	ActiveMQDestination dests[] = broker.getRegionBroker().getDestinations();	int matchingDestinations = 0;	for (ActiveMQDestination destination: dests) {	String name = destination.getPhysicalName();	
found destination 

========================= activemq sample_3604 =========================

node = new IndirectMessageReference(node.getMessage());	getSubscriptionStatistics().getEnqueues().increment();	synchronized (matchedListMutex) {	if (discarding) return;	if (!isFull() && matched.isEmpty()) {	dispatch(node);	setSlowConsumer(false);	} else {	if (info.getPrefetchSize() > 1 && matched.size() > info.getPrefetchSize()) {	if (!isSlowConsumer()) {	
has twice its prefetch limit pending without an ack it appears to be slow 

for (Destination dest: destinations) {	dest.slowConsumer(getContext(), this);	}	}	}	if (maximumPendingMessages != 0) {	boolean warnedAboutWait = false;	while (active) {	while (matched.isFull()) {	if (getContext().getStopping().get()) {	
stopped waiting for space in pendingmessage cursor for 

}	if (maximumPendingMessages != 0) {	boolean warnedAboutWait = false;	while (active) {	while (matched.isFull()) {	if (getContext().getStopping().get()) {	getSubscriptionStatistics().getEnqueues().decrement();	return;	}	if (!warnedAboutWait) {	
pending message cursor is full temp usag or memory usage limit reached blocking message add pending the release of resources 

}	int messagesToEvict = 0;	if (oldMessages != null){	messagesToEvict = oldMessages.length;	for (int i = 0; i < messagesToEvict; i++) {	MessageReference oldMessage = oldMessages[i];	discard(oldMessage);	}	}	if (messagesToEvict == 0) {	
no messages to evict returned for from eviction strategy out of candidates 

private boolean isDuplicate(MessageReference node) {	boolean duplicate = false;	if (enableAudit && audit != null) {	duplicate = audit.isDuplicate(node);	if (LOG.isDebugEnabled()) {	if (duplicate) {	
ignoring duplicate add 

private void discard(MessageReference message) {	discarding = true;	try {	message.decrementReferenceCount();	matched.remove(message);	discarded++;	if (destination != null) {	destination.getDestinationStatistics().getDequeues().increment();	}	
discarding message 

public void destroy() {	this.active=false;	synchronized (matchedListMutex) {	try {	matched.destroy();	} catch (Exception e) {	
failed to destroy cursor 

public void setPrefetchSize(int newSize) {	info.setPrefetchSize(newSize);	try {	dispatchMatched();	} catch(Exception e) {	
caught exception on dispatch after prefetch size change 

========================= activemq sample_3983 =========================

public void testSendReceive() throws Exception {	messages.clear();	TextMessage message = session.createTextMessage();	for (int i = 0; i < data.length; i++) {	message.setText(data[i]);	message.setStringProperty("stringProperty", data[i]);	message.setIntProperty("intProperty", i);	if (verbose) {	
about to send a message with text 

========================= activemq sample_3829 =========================

public void onMessage(Message message) {	try {	Thread.sleep(2000L);	if (message instanceof TextMessage) {	
dest 

if (message instanceof TextMessage) {	lastJMSDestination = message.getJMSDestination().toString();	Enumeration propertyNames = message.getPropertyNames();	while (propertyNames.hasMoreElements()) {	Object object = propertyNames.nextElement();	}	}	messageReceivedToken.countDown();	}	catch (JMSException e) {	
error while listening to a message 

Enumeration propertyNames = message.getPropertyNames();	while (propertyNames.hasMoreElements()) {	Object object = propertyNames.nextElement();	}	}	messageReceivedToken.countDown();	}	catch (JMSException e) {	}	catch (InterruptedException e) {	
interrupted while listening to a message 

========================= activemq sample_2384 =========================

inactiveDuration=60000l;	useDuplexNetworkBridge = true;	bridgeBrokers(SPOKE, HUB);	final BrokerItem hub = brokers.get(HUB);	hub.broker.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	int sleepCount = 2;	public void removeConnection(ConnectionContext context, ConnectionInfo info, Throwable error) throws Exception {	try {	while(--sleepCount >= 0) {	
sleeping for a bit in close impl to simulate load where reconnect fails due to a pending close 

});	startAllBrokers();	waitForBridgeFormation();	for (int i=0; i< 3;  i++) {	socketProxy.halfClose();	sleep(10000);	}	boolean allGood = Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception {	long numConnections = hub.broker.getTransportConnectors().get(0).getConnections().size();	
num connetions 

long numConnections = hub.broker.getTransportConnectors().get(0).getConnections().size();	return numConnections == 1;	}});	if (!allGood) {	dumpAllThreads("ExtraHubConnection");	}	assertTrue("should be only one transport connection for the single duplex network connector", allGood);	allGood = Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception {	long numVmConnections = VMTransportFactory.SERVERS.get(HUB).getConnectionCount();	
num vm connetions 

========================= activemq sample_3595 =========================

String trustStore = defaultValue(activationSpec == null ? null : activationSpec.getTrustStore(), getTrustStore());	String trustStorePassword = defaultValue(activationSpec == null ? null : activationSpec.getTrustStorePassword(), getTrustStorePassword());	String keyStore = defaultValue(activationSpec == null ? null : activationSpec.getKeyStore(), getKeyStore());	String keyStorePassword = defaultValue(activationSpec == null ? null : activationSpec.getKeyStorePassword(), getKeyStorePassword());	String keyStoreKeyPassword = defaultValue(activationSpec == null ? null : activationSpec.getKeyStoreKeyPassword(), getKeyStoreKeyPassword());	ActiveMQSslConnectionFactory sslFactory = (ActiveMQSslConnectionFactory) factory;	if (trustStore != null) {	try {	sslFactory.setTrustStore(trustStore);	} catch (Exception e) {	
unable to set truststore 

} catch (Exception e) {	}	}	if (trustStorePassword != null) {	sslFactory.setTrustStorePassword(trustStorePassword);	}	if (keyStore != null) {	try {	sslFactory.setKeyStore(keyStore);	} catch (Exception e) {	
unable to set keystore 

========================= activemq sample_836 =========================

this.name = name;	URI uri = new URI("failover: ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(uri);	connection = (ActiveMQConnection) factory.createConnection();	connection.addTransportListener(new TransportListener() {	public void onCommand(Object command) {	}	public void onException(IOException error) {	setError(error);	}	public void transportInterupted() {	
worker was interrupted 

connection.addTransportListener(new TransportListener() {	public void onCommand(Object command) {	}	public void onException(IOException error) {	setError(error);	}	public void transportInterupted() {	interruptedCount.incrementAndGet();	}	public void transportResumed() {	
worker was resummed 

public void testReconnects() throws Exception {	for (int k = 1; k < 10; k++) {	
test run 

public void testReconnects() throws Exception {	for (int k = 1; k < 10; k++) {	for (int i = 0; i < WORKER_COUNT; i++) {	int c = 0;	for (int j = 0; j < 30; j++) {	c = workers[i].iterations.getAndSet(0);	if (c != 0) {	break;	}	workers[i].assertNoErrors();	
test run waiting for worker to finish an iteration 

c = workers[i].iterations.getAndSet(0);	if (c != 0) {	break;	}	workers[i].assertNoErrors();	Thread.sleep(1000);	}	assertTrue("Test run " + k + ": Worker " + i + " never completed an interation.", c != 0);	workers[i].assertNoErrors();	}	
simulating transport error to cause reconnect 

Thread.sleep(1000);	}	assertTrue("Test run " + k + ": Worker " + i + " never completed an interation.", c != 0);	workers[i].assertNoErrors();	}	for (int i = 0; i < WORKER_COUNT; i++) {	workers[i].failConnection();	}	assertTrue("Timed out waiting for all connections to be interrupted.", Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception {	
test run waiting for connections to get interrupted at 

for (int i = 0; i < WORKER_COUNT; i++) {	workers[i].failConnection();	}	assertTrue("Timed out waiting for all connections to be interrupted.", Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception {	return interruptedCount.get() == WORKER_COUNT;	}	}, TimeUnit.SECONDS.toMillis(60)));	assertTrue("Timed out waiting for all connections to be resumed.", Wait.waitFor(new Wait.Condition(){	public boolean isSatisified() throws Exception {	
test run waiting for connections to get resumed at 

========================= activemq sample_2557 =========================

e.printStackTrace(System.out);	}	restartBroker();	assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());	final KahaDBPersistenceAdapter pa = (KahaDBPersistenceAdapter) broker.getPersistenceAdapter();	assertTrue("only less than two journal files should be left: " + pa.getStore().getJournal().getFileMap().size(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return pa.getStore().getJournal().getFileMap().size() <= 2;	}	}, TimeUnit.MINUTES.toMillis(3)) );	
done 

private void restartBroker() throws Exception {	
broker restart waiting for components 

private void restartBroker() throws Exception {	processLock.writeLock().lock();	try {	destroyBroker();	startBroker(false);	restartCount++;	
broker restarted count 

public void send() throws JMSException {	
sending 

public void send() throws JMSException {	Connection con = cf.createConnection();	Session sess = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer prod = sess.createProducer(null);	Message message = sess.createMessage();	message.setIntProperty("ID", ++messageRover);	message.setBooleanProperty("COMMIT", true);	prod.send(topic, message);	msgCount++;	
message sent 

private void process(long duration) throws JMSException {	
online 

private void process(long duration) throws JMSException {	Connection con = openConnection();	Session sess = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = sess.createDurableSubscriber(topic, SUBSCRIPTION_NAME);	long end = System.currentTimeMillis() + duration;	try {	while (end > System.currentTimeMillis()) {	Message message = consumer.receive(100);	if (message != null) {	
received message 

try {	while (end > System.currentTimeMillis()) {	Message message = consumer.receive(100);	if (message != null) {	msgCount++;	}	}	} finally {	sess.close();	con.close();	
offline 

private void subscribe() throws JMSException {	Connection con = openConnection();	Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	session.createDurableSubscriber(topic, SUBSCRIPTION_NAME);	
subscribed 

private void unsubscribe() throws JMSException {	Connection con = openConnection();	Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	session.unsubscribe(SUBSCRIPTION_NAME);	
unsubscribed 

========================= activemq sample_3716 =========================

public void testResumeNotDispatching() throws Exception {	sendMessage();	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(name.getMethodName());	QueueViewMBean queueView = getProxyToQueue(name.getMethodName());	
pausing queue 

public void testResumeNotDispatching() throws Exception {	sendMessage();	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(name.getMethodName());	QueueViewMBean queueView = getProxyToQueue(name.getMethodName());	queueView.pause();	MessageConsumer consumer = session.createConsumer(destination);	assertNull(consumer.receive(100));	
resuming queue 

========================= activemq sample_2941 =========================

}	} else if (destination instanceof ActiveMQTopic) {	ActiveMQTopic topic = (ActiveMQTopic) destination;	if (event.isAddOperation()) {	addTopic(topic);	} else {	removeTopic(topic);	}	}	} catch (Exception e) {	
caught 

========================= activemq sample_1394 =========================

public void tearDown() throws Exception {	try {	stopBroker();	} catch(Exception e) {	
error on broker stop 

========================= activemq sample_1101 =========================

delivered = receiver.receive(10, TimeUnit.SECONDS);	} catch (Throwable ex) {	fail("Should read the message");	}	long receivedTime = System.currentTimeMillis();	assertNotNull(delivered);	Long msgDeliveryTime = (Long) delivered.getMessageAnnotation("x-opt-delivery-delay");	assertNotNull(msgDeliveryTime);	assertEquals(DELAY, msgDeliveryTime.longValue());	long totalDelay = receivedTime - sendTime;	
sent at received at 

Destination destination = null;	if (topic) {	destination = session.createTopic(destinationName);	} else {	destination = session.createQueue(destinationName);	}	MessageConsumer consumer = session.createConsumer(destination);	for (int i = 1; i <= count; i++) {	Message received = consumer.receive(timeout);	assertNotNull(received);	
read next message 

========================= activemq sample_1551 =========================

connection1.start();	Session session = connection1.createSession(false, Session.AUTO_ACKNOWLEDGE);	for (int i=0; i<numConsumers; i++) {	session.createConsumer(new ActiveMQQueue("Consumer." + i + ".VirtualTopic.TEST"));	}	Connection connection2 = connectionFactory.createConnection();	connection2.start();	Session producerSession = connection2.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = producerSession.createProducer(new ActiveMQTopic("VirtualTopic.TEST"));	long start = System.currentTimeMillis();	
starting producer 

session.createConsumer(new ActiveMQQueue("Consumer." + i + ".VirtualTopic.TEST"));	}	Connection connection2 = connectionFactory.createConnection();	connection2.start();	Session producerSession = connection2.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = producerSession.createProducer(new ActiveMQTopic("VirtualTopic.TEST"));	long start = System.currentTimeMillis();	for (int i = 0; i < total; i++) {	producer.send(producerSession.createTextMessage("message: " + i));	}	
done producer duration 

========================= activemq sample_2392 =========================

public static Collection<PersistenceAdapterChoice[]> getTestParameters() {	String osName = System.getProperty("os.name");	
running on 

public DurableSubscriptionOffline3Test(PersistenceAdapterChoice persistenceAdapterChoice) {	this.defaultPersistenceAdapter = persistenceAdapterChoice;	
running with persistenceadapterchoice 

session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(null);	int filtered = 0;	for (int i = 0; i < 10; i++) {	boolean filter = (int) (Math.random() * 2) >= 1;	if (filter) filtered++;	Message message = session.createMessage();	message.setStringProperty("filter", filter ? "true" : "false");	producer.send(topic, message);	}	
sent 

DurableSubscriptionOfflineTestListener listener = new DurableSubscriptionOfflineTestListener();	consumer.setMessageListener(listener);	MessageProducer producer = session.createProducer(null);	int sent = 0;	for (int i = 0; i < 10; i++) {	sent++;	Message message = session.createMessage();	message.setStringProperty("filter", "false");	producer.send(topic, message);	}	
sent 

createBroker(false /*deleteAllMessages*/);	con = createConnection();	session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	producer = session.createProducer(null);	for (int i = 0; i < 10; i++) {	sent++;	Message message = session.createMessage();	message.setStringProperty("filter", "false");	producer.send(topic, message);	}	
after restart sent 

========================= activemq sample_3700 =========================

System.setProperty("activemq.store.dir", root + "_broker_" + i);	connections[i] = createConnection("broker-" + i);	connections[i].setClientID("ClusterTest" + i);	connections[i].start();	Session session = connections[i].createSession(false, Session.AUTO_ACKNOWLEDGE);	producers[i] = session.createProducer(destination);	producers[i].setDeliveryMode(deliveryMode);	MessageConsumer consumer = createMessageConsumer(session, destination);	consumer.setMessageListener(this);	}	
sleeping to ensure cluster is fully connected 

for (int x = 0; x < producers.length; x++) {	producers[x].send(textMessage);	}	}	synchronized (receivedMessageCount) {	if (receivedMessageCount.get() < expectedReceiveCount()) {	receivedMessageCount.wait(20000);	}	}	Thread.sleep(2000);	
got 

========================= activemq sample_2541 =========================

public void run() {	ActiveMQConnectionFactory connectionFactory = null;	ActiveMQConnection connection = null;	ActiveMQSession session = null;	Destination destination = null;	try {	
started testproducer for destination 

} else {	destination = session.createQueue(this.destinationName);	}	ActiveMQMessageProducer producer = (ActiveMQMessageProducer) session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	for (int i = 0; i < numberMessages; i++) {	TextMessage message = session.createTextMessage("I am a message :: " + String.valueOf(i));	try {	producer.send(message);	} catch (Exception deeperException) {	
producer for destination caught 

producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	for (int i = 0; i < numberMessages; i++) {	TextMessage message = session.createTextMessage("I am a message :: " + String.valueOf(i));	try {	producer.send(message);	} catch (Exception deeperException) {	}	latch.countDown();	Thread.sleep(1000);	}	
finished testproducer for destination 

for (int i = 0; i < numberMessages; i++) {	TextMessage message = session.createTextMessage("I am a message :: " + String.valueOf(i));	try {	producer.send(message);	} catch (Exception deeperException) {	}	latch.countDown();	Thread.sleep(1000);	}	} catch (Exception e) {	
terminating testproducer caught 

latch.countDown();	Thread.sleep(1000);	}	} catch (Exception e) {	} finally {	try {	if (connection != null) {	connection.close();	}	} catch (Exception e) {	
closing connection session caught 

public void run() {	try {	
started testconsumer for destination 

if (isTopic) {	destination = session.createTopic(destinationName);	} else {	destination = session.createQueue(destinationName);	}	consumer = session.createConsumer(destination);	consumer.setMessageListener(this);	while (!bStop) {	Thread.sleep(100);	}	
finished testconsumer for destination name remaining messages 

destination = session.createTopic(destinationName);	} else {	destination = session.createQueue(destinationName);	}	consumer = session.createConsumer(destination);	consumer.setMessageListener(this);	while (!bStop) {	Thread.sleep(100);	}	} catch (Exception e) {	
consumer caught 

while (!bStop) {	Thread.sleep(100);	}	} catch (Exception e) {	} finally {	try {	if (connection != null) {	connection.close();	}	} catch (Exception e) {	
closing connection session caught 

public synchronized void onException(JMSException ex) {	ex.printStackTrace();	
consumer for destination jms exception occured shutting down client 

public synchronized void onMessage(Message message) {	receivedMessageCounter++;	latch.countDown();	
consumer for destination latch countdown number messages received 

public synchronized void onMessage(Message message) {	receivedMessageCounter++;	latch.countDown();	try {	
consumer for destination received message id 

public synchronized void onMessage(Message message) {	receivedMessageCounter++;	latch.countDown();	try {	if (!bFakeFail) {	
consumer on destination committing jms session for message 

public synchronized void onMessage(Message message) {	receivedMessageCounter++;	latch.countDown();	try {	if (!bFakeFail) {	session.commit();	} else {	
consumer on destination rolling back jms session for message 

public synchronized void onMessage(Message message) {	receivedMessageCounter++;	latch.countDown();	try {	if (!bFakeFail) {	session.commit();	} else {	session.rollback();	}	} catch (JMSException ex) {	
error reading jms message from destination 

========================= activemq sample_2404 =========================

public void run() {	if (camelContext != null) {	try {	camelContext.stop();	} catch (final Exception e) {	
unable to stop camelcontext 

public void run() {	if (camelContext != null) {	try {	camelContext.stop();	} catch (final Exception e) {	}	} else {	
unable to stop camelcontext no camelcontext was set 

========================= activemq sample_1382 =========================

producerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	consumerSession = connection.createSession(true, 0);	producer = producerSession.createProducer(queue);	consumer = consumerSession.createConsumer(queue);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message m) {	try {	TextMessage tm = (TextMessage)m;	receivedText = tm.getText();	latch.countDown();	
consumer received message 

consumerSession = connection.createSession(true, 0);	producer = producerSession.createProducer(queue);	consumer = consumerSession.createConsumer(queue);	consumer.setMessageListener(new MessageListener() {	public void onMessage(Message m) {	try {	TextMessage tm = (TextMessage)m;	receivedText = tm.getText();	latch.countDown();	consumerSession.commit();	
committed transaction 

consumer.setMessageListener(new MessageListener() {	public void onMessage(Message m) {	try {	TextMessage tm = (TextMessage)m;	receivedText = tm.getText();	latch.countDown();	consumerSession.commit();	} catch (JMSException e) {	try {	consumerSession.rollback();	
rolled back transaction 

e.printStackTrace();	}	}	});	connection.start();	TextMessage tm = null;	try {	tm = producerSession.createTextMessage();	tm.setText("Hello, " + new Date());	producer.send(tm);	
producer sent message 

});	connection.start();	TextMessage tm = null;	try {	tm = producerSession.createTextMessage();	tm.setText("Hello, " + new Date());	producer.send(tm);	} catch (JMSException e) {	e.printStackTrace();	}	
waiting for latch 

========================= activemq sample_3645 =========================

} catch (RuntimeException t) {	throwable = t;	throw t;	} catch (Throwable t) {	throwable = t;	throw IOExceptionSupport.create("Persistence task failed: " + t, t);	} finally {	if (throwable == null) {	persistenceAdapter.commitTransaction(context);	} else {	
having to rollback caught an exception 

========================= activemq sample_4180 =========================

assertEquals(msg1.getJMSMessageID(), msg2.getJMSMessageID());	assertTrue(msg1.getJMSCorrelationID().equals(msg2.getJMSCorrelationID()));	assertTrue(msg1.getJMSDestination().equals(msg2.getJMSDestination()));	assertTrue(msg1.getJMSReplyTo().equals(msg2.getJMSReplyTo()));	assertTrue(msg1.getJMSDeliveryMode() == msg2.getJMSDeliveryMode());	assertTrue(msg1.getJMSRedelivered() == msg2.getJMSRedelivered());	assertTrue(msg1.getJMSType().equals(msg2.getJMSType()));	assertTrue(msg1.getJMSExpiration() == msg2.getJMSExpiration());	assertTrue(msg1.getJMSPriority() == msg2.getJMSPriority());	assertTrue(msg1.getJMSTimestamp() == msg2.getJMSTimestamp());	
message is 

public void testSetNullPropertyName() throws JMSException {	Message msg = new ActiveMQMessage();	try {	msg.setStringProperty(null, "Cheese");	fail("Should have thrown exception");	} catch (IllegalArgumentException e) {	
worked caught 

public void testSetEmptyPropertyName() throws JMSException {	Message msg = new ActiveMQMessage();	try {	msg.setStringProperty("", "Cheese");	fail("Should have thrown exception");	} catch (IllegalArgumentException e) {	
worked caught 

========================= activemq sample_3491 =========================

public void testIndividualDeadLetterAndTimeStampPlugin() {	
starting test 

List<Future<ProducerTask>> tasks = new ArrayList<Future<ProducerTask>>();	for (int index = 0; index < 1; index++) {	ProducerTask p = new ProducerTask(connectionUri, original, NUM_MSGS);	Future<ProducerTask> future = executor.submit(p, p);	tasks.add(future);	}	ForwardingConsumerThread f1 = new ForwardingConsumerThread(original, rerouted, NUM_MSGS);	f1.start();	ConsumerThread c1 = new ConsumerThread(connectionUri, rerouted, NUM_MSGS);	c1.start();	
waiting on consumers and producers to exit 

Future<ProducerTask> future = executor.submit(p, p);	tasks.add(future);	}	ForwardingConsumerThread f1 = new ForwardingConsumerThread(original, rerouted, NUM_MSGS);	f1.start();	ConsumerThread c1 = new ConsumerThread(connectionUri, rerouted, NUM_MSGS);	c1.start();	try {	for (Future<ProducerTask> future : tasks) {	ProducerTask e = future.get();	
completed 

}	ForwardingConsumerThread f1 = new ForwardingConsumerThread(original, rerouted, NUM_MSGS);	f1.start();	ConsumerThread c1 = new ConsumerThread(connectionUri, rerouted, NUM_MSGS);	c1.start();	try {	for (Future<ProducerTask> future : tasks) {	ProducerTask e = future.get();	}	executor.shutdown();	
producing threads complete waiting on acks 

ConsumerThread c1 = new ConsumerThread(connectionUri, rerouted, NUM_MSGS);	c1.start();	try {	for (Future<ProducerTask> future : tasks) {	ProducerTask e = future.get();	}	executor.shutdown();	f1.join(TimeUnit.MINUTES.toMillis(2));	c1.join(TimeUnit.MINUTES.toMillis(2));	} catch (ExecutionException e) {	
caught unexpected exception 

try {	for (Future<ProducerTask> future : tasks) {	ProducerTask e = future.get();	}	executor.shutdown();	f1.join(TimeUnit.MINUTES.toMillis(2));	c1.join(TimeUnit.MINUTES.toMillis(2));	} catch (ExecutionException e) {	throw new RuntimeException(e);	} catch (InterruptedException ie) {	
caught unexpected exception 

f1.join(TimeUnit.MINUTES.toMillis(2));	c1.join(TimeUnit.MINUTES.toMillis(2));	} catch (ExecutionException e) {	throw new RuntimeException(e);	} catch (InterruptedException ie) {	throw new RuntimeException(ie);	}	assertFalse(f1.isFailed());	assertFalse(c1.isFailed());	long estimatedTime = System.nanoTime() - startTime;	
testcase duration seconds 

f1.join(TimeUnit.MINUTES.toMillis(2));	c1.join(TimeUnit.MINUTES.toMillis(2));	} catch (ExecutionException e) {	throw new RuntimeException(e);	} catch (InterruptedException ie) {	throw new RuntimeException(ie);	}	assertFalse(f1.isFailed());	assertFalse(c1.isFailed());	long estimatedTime = System.nanoTime() - startTime;	
consumers and producers exited all msgs received as expected 

public void run() {	Connection connection = null;	try {	String destName = "";	try {	destName = dest.getQueueName();	} catch (JMSException e) {	
caught unexpected exception 

ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(uri);	connection = connectionFactory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(dest);	connection.start();	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	String msg = "Test Message";	for (int i = 0; i < count; i++) {	producer.send(session.createTextMessage(msg + dest.getQueueName() + " " + i));	}	
sent msgs 

connection = connectionFactory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(dest);	connection.start();	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	String msg = "Test Message";	for (int i = 0; i < count; i++) {	producer.send(session.createTextMessage(msg + dest.getQueueName() + " " + i));	}	} catch (Exception e) {	
caught unexpected exception 

producer.setDeliveryMode(DeliveryMode.PERSISTENT);	String msg = "Test Message";	for (int i = 0; i < count; i++) {	producer.send(session.createTextMessage(msg + dest.getQueueName() + " " + i));	}	} catch (Exception e) {	} finally {	try {	connection.close();	} catch (Throwable e) {	
caught unexpected exception 

while (count < blockSize) {	Message msg1 = consumer.receive(10000);	if (msg1 != null) {	if (msg1 instanceof ActiveMQTextMessage) {	if (count % 100 == 0) {	LOG.info("Consuming -> " + ((ActiveMQTextMessage) msg1).getDestination() + " count=" + count);	}	producer.send(msg1);	count++;	} else {	
skipping unknown msg type 

LOG.info("Consuming -> " + ((ActiveMQTextMessage) msg1).getDestination() + " count=" + count);	}	producer.send(msg1);	count++;	} else {	}	} else {	break;	}	}	
completed segment of 

count++;	} else {	}	} else {	break;	}	}	connection.close();	}	} catch (Exception e) {	
caught unexpected exception 

} else {	}	} else {	break;	}	}	connection.close();	}	} catch (Exception e) {	} finally {	
is stopping 

int count = 0;	while (count < blockSize) {	Object msg1 = consumer.receive(10000);	if (msg1 != null) {	if (msg1 instanceof ActiveMQTextMessage) {	if (count % 100 == 0) {	LOG.info("Consuming -> " + ((ActiveMQTextMessage) msg1).getDestination() + " count=" + count);	}	count++;	} else {	
skipping unknown msg type 

LOG.info("Consuming -> " + ((ActiveMQTextMessage) msg1).getDestination() + " count=" + count);	}	count++;	} else {	}	} else {	failed = true;	break;	}	}	
completed segment of 

} else {	}	} else {	failed = true;	break;	}	}	connection.close();	}	} catch (Exception e) {	
caught unexpected exception 

}	} else {	failed = true;	break;	}	}	connection.close();	}	} catch (Exception e) {	} finally {	
is stopping 

========================= activemq sample_2795 =========================

for (int i = 0; i < NUM_MESSAGES; i++) {	Connection connection = connectionFactory.createConnection();	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(QUEUE);	MessageProducer producer = session.createProducer(destination);	String msgTo = "hello";	TextMessage message = session.createTextMessage(msgTo);	producer.send(message);	connection.close();	
sent messages using 

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue(QUEUE);	MessageConsumer consumer = session.createConsumer(destination);	for (int i = 0; i < totalMessagesExpected; ++i) {	Message msg = consumer.receive(5000);	if (msg == null) {	return;	}	numReceived++;	if (numReceived % 20 == 0) {	
received messages 

}	} catch (Exception e) {	throw new RuntimeException(e);	}	}	});	thread.start();	ExecutorService threads = Executors.newFixedThreadPool(2);	final CyclicBarrier barrier = new CyclicBarrier(2, new Runnable() {	public void run() {	
starting threads to send messages 

========================= activemq sample_1290 =========================

public void testAddRemoveAddIndexSize() throws Exception {	brokerService = new BrokerService();	brokerService.setUseJmx(false);	SystemUsage usage = brokerService.getSystemUsage();	usage.getMemoryUsage().setLimit(1024*150);	String body = new String(new byte[1024]);	Destination destination = new Queue(brokerService, new ActiveMQQueue("Q"), null, new DestinationStatistics(), null);	brokerService.start();	underTest = new FilePendingMessageCursor(brokerService.getBroker(), "test", false);	underTest.setSystemUsage(usage);	
start 

brokerService = new BrokerService();	brokerService.setUseJmx(false);	SystemUsage usage = brokerService.getSystemUsage();	usage.getMemoryUsage().setLimit(1024*150);	String body = new String(new byte[1024]);	Destination destination = new Queue(brokerService, new ActiveMQQueue("Q"), null, new DestinationStatistics(), null);	brokerService.start();	underTest = new FilePendingMessageCursor(brokerService.getBroker(), "test", false);	underTest.setSystemUsage(usage);	final PageFile pageFile =  ((PListImpl)underTest.getDiskList()).getPageFile();	
page count 

brokerService = new BrokerService();	brokerService.setUseJmx(false);	SystemUsage usage = brokerService.getSystemUsage();	usage.getMemoryUsage().setLimit(1024*150);	String body = new String(new byte[1024]);	Destination destination = new Queue(brokerService, new ActiveMQQueue("Q"), null, new DestinationStatistics(), null);	brokerService.start();	underTest = new FilePendingMessageCursor(brokerService.getBroker(), "test", false);	underTest.setSystemUsage(usage);	final PageFile pageFile =  ((PListImpl)underTest.getDiskList()).getPageFile();	
free count 

brokerService = new BrokerService();	brokerService.setUseJmx(false);	SystemUsage usage = brokerService.getSystemUsage();	usage.getMemoryUsage().setLimit(1024*150);	String body = new String(new byte[1024]);	Destination destination = new Queue(brokerService, new ActiveMQQueue("Q"), null, new DestinationStatistics(), null);	brokerService.start();	underTest = new FilePendingMessageCursor(brokerService.getBroker(), "test", false);	underTest.setSystemUsage(usage);	final PageFile pageFile =  ((PListImpl)underTest.getDiskList()).getPageFile();	
content size 

assertFalse("cursor is not full " + usage.getTempUsage(), underTest.isFull());	underTest.reset();	long receivedCount = 0;	while(underTest.hasNext()) {	MessageReference ref = underTest.next();	underTest.remove();	ref.decrementReferenceCount();	assertEquals("id is correct", receivedCount++, ref.getMessageId().getProducerSequenceId());	}	assertEquals("got all messages back", receivedCount, numMessages);	
page count 

assertFalse("cursor is not full " + usage.getTempUsage(), underTest.isFull());	underTest.reset();	long receivedCount = 0;	while(underTest.hasNext()) {	MessageReference ref = underTest.next();	underTest.remove();	ref.decrementReferenceCount();	assertEquals("id is correct", receivedCount++, ref.getMessageId().getProducerSequenceId());	}	assertEquals("got all messages back", receivedCount, numMessages);	
free count 

assertFalse("cursor is not full " + usage.getTempUsage(), underTest.isFull());	underTest.reset();	long receivedCount = 0;	while(underTest.hasNext()) {	MessageReference ref = underTest.next();	underTest.remove();	ref.decrementReferenceCount();	assertEquals("id is correct", receivedCount++, ref.getMessageId().getProducerSequenceId());	}	assertEquals("got all messages back", receivedCount, numMessages);	
content size 

long receivedCount = 0;	while(underTest.hasNext()) {	MessageReference ref = underTest.next();	underTest.remove();	ref.decrementReferenceCount();	assertEquals("id is correct", receivedCount++, ref.getMessageId().getProducerSequenceId());	}	assertEquals("got all messages back", receivedCount, numMessages);	}	assertEquals("expected page usage", initialPageCount, pageFile.getPageCount() - pageFile.getFreePageCount() );	
Destroy 

while(underTest.hasNext()) {	MessageReference ref = underTest.next();	underTest.remove();	ref.decrementReferenceCount();	assertEquals("id is correct", receivedCount++, ref.getMessageId().getProducerSequenceId());	}	assertEquals("got all messages back", receivedCount, numMessages);	}	assertEquals("expected page usage", initialPageCount, pageFile.getPageCount() - pageFile.getFreePageCount() );	underTest.destroy();	
page count 

while(underTest.hasNext()) {	MessageReference ref = underTest.next();	underTest.remove();	ref.decrementReferenceCount();	assertEquals("id is correct", receivedCount++, ref.getMessageId().getProducerSequenceId());	}	assertEquals("got all messages back", receivedCount, numMessages);	}	assertEquals("expected page usage", initialPageCount, pageFile.getPageCount() - pageFile.getFreePageCount() );	underTest.destroy();	
free count 

while(underTest.hasNext()) {	MessageReference ref = underTest.next();	underTest.remove();	ref.decrementReferenceCount();	assertEquals("id is correct", receivedCount++, ref.getMessageId().getProducerSequenceId());	}	assertEquals("got all messages back", receivedCount, numMessages);	}	assertEquals("expected page usage", initialPageCount, pageFile.getPageCount() - pageFile.getFreePageCount() );	underTest.destroy();	
content size 

========================= activemq sample_3757 =========================

public boolean isSendToDeadLetterQueue(Message message) {	boolean result = false;	if (message != null) {	result = true;	if (enableAudit && messageAudit.isDuplicate(message)) {	result = false;	
not adding duplicate to dlq dest 

========================= activemq sample_4092 =========================

final Queue queue = (Queue) ctx.lookup("queueName");	QueueSession session = conn.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);	QueueReceiver receiver = session.createReceiver(queue, selectors);	System.out.println("Message Selector: " + receiver.getMessageSelector());	receiver.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	if (message instanceof TextMessage) {	TextMessage txtMsg = (TextMessage) message;	String msg = txtMsg.getText();	
queue message received 

TopicConnection conn = factory.createTopicConnection();	final Topic topic = (Topic) ctx.lookup("topicName");	TopicSession session = conn.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);	TopicSubscriber receiver = session.createSubscriber(topic, selectors, false);	receiver.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	try {	if (message instanceof TextMessage) {	TextMessage txtMsg = (TextMessage) message;	String msg = txtMsg.getText();	
topic message received 

========================= activemq sample_2845 =========================

public void onServiceAdd(DiscoveryEvent event) {	String url = event.getServiceName();	if (url != null) {	try {	URI uri = new URI(url);	
adding new broker connection url 

public void onServiceAdd(DiscoveryEvent event) {	String url = event.getServiceName();	if (url != null) {	try {	URI uri = new URI(url);	uri = URISupport.applyParameters(uri, parameters, DISCOVERED_OPTION_PREFIX);	serviceURIs.put(event.getServiceName(), uri);	next.add(false,new URI[] {uri});	} catch (URISyntaxException e) {	
could not connect to remote uri due to bad uri syntax 

public void transportResumed() {	if( discoveryAgent instanceof Suspendable ) {	try {	((Suspendable)discoveryAgent).suspend();	} catch (Exception e) {	
exception suspending discoveragent 

public void transportInterupted() {	if( discoveryAgent instanceof Suspendable ) {	try {	((Suspendable)discoveryAgent).resume();	} catch (Exception e) {	
exception resuming discoveragent 

========================= activemq sample_92 =========================

public void testTempQueueIssue() throws JMSException, InterruptedException {	ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory( "vm: final PooledConnectionFactory cf = new PooledConnectionFactory();	cf.setConnectionFactory(factory);	Connection connection = cf.createConnection();	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	
first connection was 

con.start();	Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	TemporaryQueue tempQueue = session.createTemporaryQueue();	TextMessage msg = session.createTextMessage("Request");	msg.setJMSReplyTo(tempQueue);	MessageProducer producer = session.createProducer(session.createQueue(serviceQueue));	producer.send(msg);	Thread.sleep(3000);	MessageConsumer consumer = session.createConsumer(tempQueue);	Message replyMsg = consumer.receive();	
reply message 

public void receiveAndRespondWithMessageIdAsCorrelationId(ConnectionFactory connectionFactory, String queueName) throws JMSException {	Connection con = connectionFactory.createConnection();	Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createConsumer(session.createQueue(queueName));	final javax.jms.Message inMessage = consumer.receive();	String requestMessageId = inMessage.getJMSMessageID();	
received message 

public void receiveAndRespondWithMessageIdAsCorrelationId(ConnectionFactory connectionFactory, String queueName) throws JMSException {	Connection con = connectionFactory.createConnection();	Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer consumer = session.createConsumer(session.createQueue(queueName));	final javax.jms.Message inMessage = consumer.receive();	String requestMessageId = inMessage.getJMSMessageID();	final TextMessage replyMessage = session.createTextMessage("Result");	replyMessage.setJMSCorrelationID(inMessage.getJMSMessageID());	final MessageProducer producer = session.createProducer(inMessage.getJMSReplyTo());	
sending reply to 

========================= activemq sample_1291 =========================

public void getMessage() throws Exception {	final QueueViewMBean queueView = getProxyToQueueViewMBean();	final CompositeData messages[] = queueView.browse();	messageID = (String) messages[0].get("JMSMessageID");	assertNotNull(messageID);	assertNotNull(queueView.getMessage(messageID));	
attempting to remove message id 

========================= activemq sample_2844 =========================

Thread.sleep(1000);	int browsed = browseMessages("BrokerB", dest);	Thread.sleep(1000);	MessageConsumer clientA = createConsumer("BrokerA", dest);	MessageIdList msgsA = getConsumerMessages("BrokerA", clientA);	msgsA.waitForMessagesToArrive(MESSAGE_COUNT);	Thread.sleep(1000);	MessageConsumer clientB = createConsumer("BrokerB", dest);	MessageIdList msgsB = getConsumerMessages("BrokerB", clientB);	msgsB.waitForMessagesToArrive(MESSAGE_COUNT);	
a b 

try {	QueueBrowser browser = createBrowser(broker, dest);	int count  = browseMessages(browser, broker);	if (consume) {	if (count != 0) {	MessageConsumer consumer = createSyncConsumer(broker, dest);	totalCount += count;	for (int i = 0; i < count; i++) {	ActiveMQTextMessage message = (ActiveMQTextMessage)consumer.receive(1000);	if (message == null) break;	
consumer 

MessageConsumer consumer = createSyncConsumer(broker, dest);	totalCount += count;	for (int i = 0; i < count; i++) {	ActiveMQTextMessage message = (ActiveMQTextMessage)consumer.receive(1000);	if (message == null) break;	}	}	} else {	totalCount = count;	}	
browser browsed 

for (int i = 0; i < count; i++) {	ActiveMQTextMessage message = (ActiveMQTextMessage)consumer.receive(1000);	if (message == null) break;	}	}	} else {	totalCount = count;	}	Thread.sleep(1000);	} catch (Exception e) {	
exception browsing 

} catch (Exception e) {	} finally {	try {	if (browser != null) {	browser.close();	}	if (consumer != null) {	consumer.close();	}	} catch (Exception e) {	
exception closing browser 

waitForBridgeFormation(broker, 1, 1);	waitForBridgeFormation(broker, 1, 2);	waitForBridgeFormation(broker, 1, 3);	waitForBridgeFormation(broker, 1, 4);	}	Destination composite = createDestination("PROD.FUSESOURCE.3.A,PROD.FUSESOURCE.3.B", false);	final Browser browser1 = new Browser("broker-3A", composite, MESSAGE_COUNT);	browser1.start();	final Browser browser2 = new Browser("broker-3B", composite, MESSAGE_COUNT);	browser2.start();	
sending messages to broker 

waitForBridgeFormation(broker, 1, 2);	waitForBridgeFormation(broker, 1, 3);	waitForBridgeFormation(broker, 1, 4);	}	Destination composite = createDestination("PROD.FUSESOURCE.3.A,PROD.FUSESOURCE.3.B", false);	final Browser browser1 = new Browser("broker-3A", composite, MESSAGE_COUNT);	browser1.start();	final Browser browser2 = new Browser("broker-3B", composite, MESSAGE_COUNT);	browser2.start();	sendMessages("broker-1A", composite, MESSAGE_COUNT);	
message sent to broker 

return browser1.getTotalCount() == MESSAGE_COUNT;	}	});	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return browser2.getTotalCount() == MESSAGE_COUNT;	}	});	browser1.join();	browser2.join();	
broker browsed 

return browser1.getTotalCount() == MESSAGE_COUNT;	}	});	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return browser2.getTotalCount() == MESSAGE_COUNT;	}	});	browser1.join();	browser2.join();	
broker browsed 

protected int browseMessages(QueueBrowser browser, String name) throws Exception {	Enumeration<?> msgs = browser.getEnumeration();	int browsedMessage = 0;	while (msgs.hasMoreElements()) {	browsedMessage++;	ActiveMQTextMessage message = (ActiveMQTextMessage)msgs.nextElement();	
browsed 

========================= activemq sample_3613 =========================

protected void configureServices() {	if ((msServices == null) || (msServices.length < 2)) {	
masterslave requires at least uris 

========================= activemq sample_93 =========================

return (MQTTPacketIdGenerator) service;	}	}	}	result = new MQTTPacketIdGenerator();	broker.addService(result);	if (broker.isStarted()) {	try {	result.start();	} catch (Exception e) {	
couldn t start mqttpacketidgenerator 

========================= activemq sample_899 =========================

msg.setObject("byte", byteValue);	msg.setObject("bytes", bytesValue);	msg.setObject("char", charValue);	msg.setObject("double", doubleValue);	msg.setObject("float", floatValue);	msg.setObject("int", intValue);	msg.setObject("long", longValue);	msg.setObject("short", shortValue);	msg.setObject("string", stringValue);	} catch (MessageFormatException mfe) {	
caught 

========================= activemq sample_3490 =========================

audit = new ActiveMQMessageAudit(maxAuditDepth,maxProducersToAudit);	TransactionContext c = null;	try {	c = getTransactionContext();	getAdapter().doMessageIdScan(c, auditRecoveryDepth, new JDBCMessageIdScanListener() {	public void messageId(MessageId id) {	audit.isDuplicate(id);	}	});	} catch (Exception e) {	
failed to reload store message audit for jdbc persistence adapter 

public void initSequenceIdGenerator() {	TransactionContext c = null;	try {	c = getTransactionContext();	getAdapter().doMessageIdScan(c, auditRecoveryDepth, new JDBCMessageIdScanListener() {	public void messageId(MessageId id) {	audit.isDuplicate(id);	}	});	} catch (Exception e) {	
failed to reload store message audit for jdbc persistence adapter 

public void removeQueueMessageStore(ActiveMQQueue destination) {	if (destination.isQueue() && getBrokerService().shouldRecordVirtualDestination(destination)) {	try {	removeConsumerDestination(destination);	} catch (IOException ioe) {	
failed to remove consumer destination 

try {	long seq =  getAdapter().doGetLastMessageStoreSequenceId(c);	sequenceGenerator.setLastSequenceId(seq);	long brokerSeq = 0;	if (seq != 0) {	byte[] msg = getAdapter().doGetMessageById(c, seq);	if (msg != null) {	Message last = (Message)wireFormat.unmarshal(new ByteSequence(msg));	brokerSeq = last.getMessageId().getBrokerSequenceId();	} else {	
broker sequence id wasn t recovered properly possible duplicates 

public void init() throws Exception {	getAdapter().setUseExternalMessageReferences(isUseExternalMessageReferences());	if (isCreateTablesOnStartup()) {	TransactionContext transactionContext = getTransactionContext();	transactionContext.getExclusiveConnection();	transactionContext.begin();	try {	try {	getAdapter().doCreateTables(transactionContext);	} catch (SQLException e) {	
cannot create tables due to 

public void cleanup() {	TransactionContext c = null;	try {	
cleaning up old messages 

public void cleanup() {	TransactionContext c = null;	try {	c = getTransactionContext();	c.getExclusiveConnection();	getAdapter().doDeleteOldMessages(c);	} catch (IOException e) {	
old message cleanup failed due to 

public void cleanup() {	TransactionContext c = null;	try {	c = getTransactionContext();	c.getExclusiveConnection();	getAdapter().doDeleteOldMessages(c);	} catch (IOException e) {	} catch (SQLException e) {	
old message cleanup failed due to 

} catch (IOException e) {	} catch (SQLException e) {	JDBCPersistenceAdapter.log("Failure Details: ", e);	} finally {	if (c != null) {	try {	c.close();	} catch (Throwable e) {	}	}	
cleanup done 

public void setLockDataSource(DataSource dataSource) {	this.lockDataSource = dataSource;	
using a separate datasource for locking 

protected JDBCAdapter createAdapter() throws IOException {	adapter = (JDBCAdapter) loadAdapter(adapterFactoryFinder, "adapter");	if (adapter == null) {	adapter = new DefaultJDBCAdapter();	
using default jdbc adapter 

private Object loadAdapter(FactoryFinder finder, String kind) throws IOException {	Object adapter = null;	TransactionContext c = getTransactionContext();	try {	try {	String dirverName = c.getConnection().getMetaData().getDriverName();	dirverName = dirverName.replaceAll("[^a-zA-Z0-9\\-]", "_").toLowerCase(Locale.ENGLISH);	try {	adapter = finder.newInstance(dirverName);	
database driver override recognized for adapter 

private Object loadAdapter(FactoryFinder finder, String kind) throws IOException {	Object adapter = null;	TransactionContext c = getTransactionContext();	try {	try {	String dirverName = c.getConnection().getMetaData().getDriverName();	dirverName = dirverName.replaceAll("[^a-zA-Z0-9\\-]", "_").toLowerCase(Locale.ENGLISH);	try {	adapter = finder.newInstance(dirverName);	} catch (Throwable e) {	
database driver override not found for will use default implementation 

TransactionContext c = getTransactionContext();	try {	try {	String dirverName = c.getConnection().getMetaData().getDriverName();	dirverName = dirverName.replaceAll("[^a-zA-Z0-9\\-]", "_").toLowerCase(Locale.ENGLISH);	try {	adapter = finder.newInstance(dirverName);	} catch (Throwable e) {	}	} catch (SQLException e) {	
jdbc error occurred while trying to detect database type for overrides will use default implementations 

public void deleteAllMessages() throws IOException {	TransactionContext c = getTransactionContext();	c.getExclusiveConnection();	try {	getAdapter().doDropTables(c);	getAdapter().setUseExternalMessageReferences(isUseExternalMessageReferences());	getAdapter().doCreateTables(c);	
persistence store purged 

public Locker createDefaultLocker() throws IOException {	Locker locker = (Locker) loadAdapter(lockFactoryFinder, "lock");	if (locker == null) {	locker = new DefaultDatabaseLocker();	
using default jdbc locker 

public void checkpoint(boolean sync) throws IOException {	Connection connection = null;	try {	connection = getDataSource().getConnection();	if (!connection.isValid(10)) {	throw new IOException("isValid(10) failed for: " + connection);	}	} catch (SQLException e) {	
could not get jdbc connection for checkpoint 

========================= activemq sample_933 =========================

private synchronized MessageInterceptorFilter getFilter() {	if (filter == null) {	try {	MutableBrokerFilter mutableBrokerFilter = (MutableBrokerFilter) brokerService.getBroker().getAdaptor(MutableBrokerFilter.class);	Broker next = mutableBrokerFilter.getNext();	filter = new MessageInterceptorFilter(next);	mutableBrokerFilter.setNext(filter);	} catch (Exception e) {	
failed to create messageinterceptorfilter 

========================= activemq sample_3886 =========================

public void testBlockedTxProducerConnectionTimeoutConnectionCanClose() throws Exception {	final ActiveMQConnection cx = (ActiveMQConnection)createConnection();	final ActiveMQDestination queue = createDestination("noPfc");	cx.setSendTimeout(4000);	cx.setCloseTimeout(1000);	final AtomicInteger exceptionCount = new AtomicInteger(0);	Runnable r = new Runnable() {	public void run() {	int count=0;	try {	
sender thread starting 

public void run() {	int count=0;	try {	Session session = cx.createSession(true, Session.SESSION_TRANSACTED);	MessageProducer producer = session.createProducer(queue);	BytesMessage message = session.createBytesMessage();	message.writeBytes(new byte[8*1024]);	for(; count<100; count++){	producer.send(message);	}	
done sending 

Session session = cx.createSession(true, Session.SESSION_TRANSACTED);	MessageProducer producer = session.createProducer(queue);	BytesMessage message = session.createBytesMessage();	message.writeBytes(new byte[8*1024]);	for(; count<100; count++){	producer.send(message);	}	} catch (JMSException e) {	if (e.getCause() instanceof RequestTimedOutIOException) {	exceptionCount.incrementAndGet();	
got expected send time out on message 

========================= activemq sample_2794 =========================

public void testStompConnectLeak() throws Exception {	brokerService.addConnector("stomp: brokerService.start();	StompConnection connection = new StompConnection();	for (int x = 0; x < 500; x++) {	try {	connection.open("localhost", brokerService.getTransportConnectors().get(0).getConnectUri().getPort());	connection.connect("system", "manager");	connection.disconnect();	} catch (Exception ex) {	
unexpected exception on connect disconnect 

final CountDownLatch doneConnect = new CountDownLatch(1);	final int listenPort = brokerService.getTransportConnectors().get(0).getConnectUri().getPort();	Thread t1 = new Thread() {	StompConnection connection = new StompConnection();	public void run() {	try {	connection.open("localhost", listenPort);	connection.connect("system", "manager");	doneConnect.countDown();	} catch (Exception ex) {	
unexpected exception on connect disconnect 

public boolean isSatisified() throws Exception {	return 1 == brokerService.getTransportConnectors().get(0).connectionCount();	}	}, TimeUnit.SECONDS.toMillis(15), TimeUnit.MILLISECONDS.toMillis(200)));	assertTrue("connected on time", doneConnect.await(5, TimeUnit.SECONDS));	brokerService.stop();	ServerSocket socket = ServerSocketFactory.getDefault().createServerSocket();	socket.setReuseAddress(true);	InetAddress address = InetAddress.getLocalHost();	socket.bind(new InetSocketAddress(address, listenPort));	
bound address 

public void testInactivityMonitor() throws Exception {	brokerService.addConnector("stomp: brokerService.start();	Thread t1 = new Thread() {	StompConnection connection = new StompConnection();	public void run() {	try {	connection.open("localhost",  brokerService.getTransportConnectors().get(0).getConnectUri().getPort());	connection.connect("system", "manager");	} catch (Exception ex) {	
unexpected exception on connect disconnect 

========================= activemq sample_1442 =========================

public void testRebalance() throws Exception {	createBroker(new ClassPathResource("org/apache/activemq/usecases/rebalance-broker1.xml"));	createBroker(new ClassPathResource("org/apache/activemq/usecases/rebalance-broker2.xml"));	startAllBrokers();	brokers.get("b1").broker.waitUntilStarted();	
starting connection 

Queue theQueue = session.createQueue(QUEUE_NAME);	MessageProducer producer = session.createProducer(theQueue);	MessageConsumer consumer = session.createConsumer(theQueue);	Message message = session.createTextMessage("Test message");	producer.send(message);	Message msg = consumer.receive(2000);	assertNotNull(msg);	createBroker(new ClassPathResource("org/apache/activemq/usecases/rebalance-broker3.xml"));	brokers.get("b3").broker.waitUntilStarted();	Thread.sleep(3000);	
stopping broker 

assertNotNull(msg);	createBroker(new ClassPathResource("org/apache/activemq/usecases/rebalance-broker3.xml"));	brokers.get("b3").broker.waitUntilStarted();	Thread.sleep(3000);	brokers.get("b1").broker.stop();	brokers.get("b1").broker.waitUntilStopped();	Thread.sleep(3000);	producer.send(message);	msg = consumer.receive(2000);	assertNotNull(msg);	
stopping broker 

========================= activemq sample_3701 =========================

public long keepAlive() throws IOException {	long rescheduleAt = 0l;	
performing connection keep alive processing 

public long keepAlive() throws IOException {	long rescheduleAt = 0l;	if (protonConnection.getLocalState() != EndpointState.CLOSED) {	long now = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());	long deadline = protonTransport.tick(now);	pumpProtonToSocket();	if (protonTransport.isClosed()) {	
transport closed after inactivity check 

long deadline = protonTransport.tick(now);	pumpProtonToSocket();	if (protonTransport.isClosed()) {	throw new InactivityIOException("Channel was inactive for too long");	} else {	if(deadline != 0) {	rescheduleAt = Math.max(deadline - now, 1);	}	}	}	
connection keep alive processing done next update in milliseconds 

public void onAMQPData(Object command) throws Exception {	Buffer frame;	if (command.getClass() == AmqpHeader.class) {	AmqpHeader header = (AmqpHeader) command;	if (amqpWireFormat.isHeaderValid(header, authenticator != null)) {	
connection from an amqp client initiated 

public void onAMQPData(Object command) throws Exception {	Buffer frame;	if (command.getClass() == AmqpHeader.class) {	AmqpHeader header = (AmqpHeader) command;	if (amqpWireFormat.isHeaderValid(header, authenticator != null)) {	} else {	
connection attempt from non amqp client 

case 0: authenticator = null;	break;	case 3: authenticator = new AmqpAuthenticator(amqpTransport, protonTransport.sasl(), brokerService);	break;	default: }	frame = header.getBuffer();	} else {	frame = (Buffer) command;	}	if (protonTransport.isClosed()) {	
ignoring incoming amqp data transport is closed 

case 3: authenticator = new AmqpAuthenticator(amqpTransport, protonTransport.sasl(), brokerService);	break;	default: }	frame = header.getBuffer();	} else {	frame = (Buffer) command;	}	if (protonTransport.isClosed()) {	return;	}	
server received from client bytes 

private void processProtonEvents() throws Exception {	try {	Event event = null;	while ((event = eventCollector.peek()) != null) {	if (amqpTransport.isTrace()) {	
server processing event 

Map<Symbol, Object> infoMap = new HashMap<> ();	infoMap.put(INVALID_FIELD, CONTAINER_ID);	condition.setInfo(infoMap);	protonConnection.setCondition(condition);	} else {	protonConnection.setCondition(new ErrorCondition(AmqpError.ILLEGAL_STATE, exception.getMessage()));	}	protonConnection.close();	} else {	if (amqpTransport.isUseInactivityMonitor() && amqpWireFormat.getIdleTimeout() > 0) {	
connection requesting idle timeout of mills 

if (response.isException()) {	Throwable exception = ((ExceptionResponse) response).getException();	handleException(exception);	}	}	} else if (command.isMessageDispatch()) {	MessageDispatch dispatch = (MessageDispatch) command;	AmqpSender sender = subscriptionsByConsumerId.get(dispatch.getConsumerId());	if (sender != null) {	if (dispatch.getMessage() != null) {	
dispatching messageid to consumer 

Throwable exception = ((ExceptionResponse) response).getException();	handleException(exception);	}	}	} else if (command.isMessageDispatch()) {	MessageDispatch dispatch = (MessageDispatch) command;	AmqpSender sender = subscriptionsByConsumerId.get(dispatch.getConsumerId());	if (sender != null) {	if (dispatch.getMessage() != null) {	} else {	
dispatching end of browse command to consumer 

}	} else if (command.isMessageDispatch()) {	MessageDispatch dispatch = (MessageDispatch) command;	AmqpSender sender = subscriptionsByConsumerId.get(dispatch.getConsumerId());	if (sender != null) {	if (dispatch.getMessage() != null) {	} else {	}	sender.onMessageDispatch(dispatch);	if (dispatch.getMessage() != null) {	
finished dispatch of messageid to consumer 

Throwable exception = ((ConnectionError) command).getException();	handleException(exception);	} else if (command.isConsumerControl()) {	ConsumerControl control = (ConsumerControl) command;	AmqpSender sender = subscriptionsByConsumerId.get(control.getConsumerId());	if (sender != null) {	sender.onConsumerControl(control);	}	} else if (command.isBrokerInfo()) {	} else {	
do not know how to process activemq command 

public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {	if (response.isException()) {	Throwable exception = ((ExceptionResponse) response).getException();	
error during temp destination removeal 

private void configureInactivityMonitor() {	AmqpInactivityMonitor monitor = amqpTransport.getInactivityMonitor();	if (monitor == null) {	return;	}	long now = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());	long nextIdleCheck = protonTransport.tick(now);	if (nextIdleCheck != 0) {	long delay = Math.max(nextIdleCheck - now, 1);	
connection keep alive processing starts in 

AmqpInactivityMonitor monitor = amqpTransport.getInactivityMonitor();	if (monitor == null) {	return;	}	long now = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());	long nextIdleCheck = protonTransport.tick(now);	if (nextIdleCheck != 0) {	long delay = Math.max(nextIdleCheck - now, 1);	monitor.startKeepAliveTask(delay);	} else {	
connection does not require keep alive processing 

========================= activemq sample_1696 =========================

public void processSaslExchange(ConnectionInfo connectionInfo) {	if (sasl.getRemoteMechanisms().length > 0) {	SaslMechanism mechanism = getSaslMechanism(sasl.getRemoteMechanisms());	if (mechanism != null) {	
sasl handshake started 

if (mechanism != null) {	mechanism.processSaslStep(sasl);	if (!mechanism.isFailed()) {	connectionInfo.setUserName(mechanism.getUsername());	connectionInfo.setPassword(mechanism.getPassword());	if (tryAuthenticate(connectionInfo, transport.getPeerCertificates())) {	sasl.done(Sasl.SaslOutcome.PN_SASL_OK);	} else {	sasl.done(Sasl.SaslOutcome.PN_SASL_AUTH);	}	
sasl handshake complete 

mechanism.processSaslStep(sasl);	if (!mechanism.isFailed()) {	connectionInfo.setUserName(mechanism.getUsername());	connectionInfo.setPassword(mechanism.getPassword());	if (tryAuthenticate(connectionInfo, transport.getPeerCertificates())) {	sasl.done(Sasl.SaslOutcome.PN_SASL_OK);	} else {	sasl.done(Sasl.SaslOutcome.PN_SASL_AUTH);	}	} else {	
sasl handshake failed 

private AuthenticationBroker getAuthenticator() {	if (authenticator == null) {	try {	authenticator = (AuthenticationBroker) brokerService.getBroker().getAdaptor(AuthenticationBroker.class);	} catch (Exception e) {	
failed to lookup authenticationbroker from broker will use a default noop version 

========================= activemq sample_1679 =========================

public void testSendRateWithActivatingConsumers() throws Exception {	final Destination destination = createDestination();	final ConnectionFactory factory = createConnectionFactory();	Connection connection = factory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = createMessageProducer(session, destination);	double[] noConsumerStats = produceMessages(destination, NUM_MESSAGES, ITERATIONS, session, producer, null);	
with no consumers ave max multiplier 

final Object addConsumerSignal = new Object();	Executors.newCachedThreadPool(new ThreadFactory() {	public Thread newThread(Runnable r) {	return new Thread(r, "ActivateConsumer" + this);	}	}).execute(new Runnable() {	public void run() {	try {	MessageConsumer consumer = null;	for (int i = 0; i < consumersToActivate; i++) {	
waiting for add signal from producer 

}).execute(new Runnable() {	public void run() {	try {	MessageConsumer consumer = null;	for (int i = 0; i < consumersToActivate; i++) {	synchronized (addConsumerSignal) {	addConsumerSignal.wait(30 * 60 * 1000);	}	TimedMessageListener listener = new TimedMessageListener();	consumer = createConsumer(factory.createConnection(), destination);	
created consumer 

for (int i = 0; i < consumersToActivate; i++) {	synchronized (addConsumerSignal) {	addConsumerSignal.wait(30 * 60 * 1000);	}	TimedMessageListener listener = new TimedMessageListener();	consumer = createConsumer(factory.createConnection(), destination);	consumer.setMessageListener(listener);	consumers.put(consumer, listener);	}	} catch (Exception e) {	
failed to start consumer 

consumer = createConsumer(factory.createConnection(), destination);	consumer.setMessageListener(listener);	consumers.put(consumer, listener);	}	} catch (Exception e) {	}	}	});	double[] statsWithActive = produceMessages(destination, NUM_MESSAGES, ITERATIONS, session, producer, addConsumerSignal);	expectedQueueDeliveries += NUM_MESSAGES * ITERATIONS;	
with concurrent activate ave max multiplier 

expectedQueueDeliveries += NUM_MESSAGES * ITERATIONS;	assertTrue(Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return consumers.size() == consumersToActivate;	}	}));	long timeToFirstAccumulator = 0;	for (TimedMessageListener listener : consumers.values()) {	long time = listener.getFirstReceipt();	timeToFirstAccumulator += time;	
time to first 

return consumers.size() == consumersToActivate;	}	}));	long timeToFirstAccumulator = 0;	for (TimedMessageListener listener : consumers.values()) {	long time = listener.getFirstReceipt();	timeToFirstAccumulator += time;	}	LOG.info("Ave time to first message =" + timeToFirstAccumulator/consumers.size());	for (TimedMessageListener listener : consumers.values()) {	
ave batch receipt time max receipt 

Destination destination = createDestination();	ConnectionFactory factory = createConnectionFactory();	Connection connection = factory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	final int toSend = 100;	final int numIterations = 5;	double[] noConsumerStats = produceMessages(destination, toSend, numIterations, session, producer, null);	startConsumers(factory, destination);	
activated consumer 

ConnectionFactory factory = createConnectionFactory();	Connection connection = factory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	final int toSend = 100;	final int numIterations = 5;	double[] noConsumerStats = produceMessages(destination, toSend, numIterations, session, producer, null);	startConsumers(factory, destination);	double[] withConsumerStats = produceMessages(destination, toSend, numIterations, session, producer, null);	
with consumer with noconsumer multiplier 

final int toSend = 100;	final int numIterations = 5;	double[] noConsumerStats = produceMessages(destination, toSend, numIterations, session, producer, null);	startConsumers(factory, destination);	double[] withConsumerStats = produceMessages(destination, toSend, numIterations, session, producer, null);	final int reasonableMultiplier = 15;	assertTrue("max X times as slow with consumer: " + withConsumerStats[1] + ", with no Consumer: " + noConsumerStats[1] + ", multiplier: " + (withConsumerStats[1]/noConsumerStats[1]), withConsumerStats[1] < noConsumerStats[1] * reasonableMultiplier);	final int toReceive = toSend * numIterations * consumerCount * 2;	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
count 

for (int j=0; j < toSend; j++) {	long singleSendstart = System.currentTimeMillis();	TextMessage msg = createTextMessage(session, "" + j);	int priority = ((int)count%10);	producer.send(msg, DeliveryMode.PERSISTENT, priority, 0);	max = Math.max(max, (System.currentTimeMillis() - singleSendstart));	if (++count % 500 == 0) {	if (addConsumerSignal != null) {	synchronized (addConsumerSignal) {	addConsumerSignal.notifyAll();	
signalled add consumer 

max = Math.max(max, (System.currentTimeMillis() - singleSendstart));	if (++count % 500 == 0) {	if (addConsumerSignal != null) {	synchronized (addConsumerSignal) {	addConsumerSignal.notifyAll();	}	}	}	;	if (count % 5000 == 0) {	
sent singlesendmax 

}	}	}	;	if (count % 5000 == 0) {	}	}	long duration = System.currentTimeMillis() - start;	batchMax = Math.max(batchMax, duration);	sum += duration;	
iteration sent time batchmax singlesendmax 

}	}	;	if (count % 5000 == 0) {	}	}	long duration = System.currentTimeMillis() - start;	batchMax = Math.max(batchMax, duration);	sum += duration;	}	
sent batchmax singlesendmax 

try {	priority = message.getJMSPriority();	} catch (JMSException ignored) {}	if (!messageLists.containsKey(priority)) {	messageLists.put(priority, new MessageIdList());	}	messageLists.get(priority).onMessage(message);	if (count.incrementAndGet() == 1) {	firstReceipt = duration;	firstReceiptLatch.countDown();	
first receipt in ms 

priority = message.getJMSPriority();	} catch (JMSException ignored) {}	if (!messageLists.containsKey(priority)) {	messageLists.put(priority, new MessageIdList());	}	messageLists.get(priority).onMessage(message);	if (count.incrementAndGet() == 1) {	firstReceipt = duration;	firstReceiptLatch.countDown();	} else if (count.get() % batchSize == 0) {	
consumed in ms priority 

========================= activemq sample_3644 =========================

public void assertBeanMarshalls(Object original) throws IOException {	super.assertBeanMarshalls(original);	String xml = getXStreamWireFormat().marshalText(original);	
as xml is 

========================= activemq sample_1100 =========================

public void testMaxFrameSizeApplied() throws Exception {	
test starting for transport with mfs and mafs 

========================= activemq sample_1550 =========================

protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {	try {	String action = request.getParameter("action");	String clientId = request.getParameter("clientId");	if (action != null && clientId != null && action.equals("unsubscribe")) {	
unsubscribing client 

clients.remove(clientId);	return;	}	WebClient client = getWebClient(request);	String text = getPostedMessageBody(request);	Destination destination = getDestination(client, request);	if (destination == null) {	throw new NoDestinationSuppliedException();	}	if (LOG.isDebugEnabled()) {	
sending message to with text 

long deadline = getReadDeadline(request);	long timeout = deadline - System.currentTimeMillis();	synchronized (consumer) {	Listener listener = (Listener) consumer.getAvailableListener();	if (listener == null) {	listener = new Listener(consumer);	consumer.setAvailableListener(listener);	}	}	if (LOG.isDebugEnabled()) {	
receiving message s from with timeout 

response.setStatus(HttpServletResponse.SC_NO_CONTENT);	} else {	messages = 1;	response.setStatus(HttpServletResponse.SC_OK);	setResponseHeaders(response, message);	writeMessageResponse(writer, message);	writer.flush();	}	} finally {	if (LOG.isDebugEnabled()) {	
received message s 

public WebClient getWebClient(HttpServletRequest request) {	String clientId = request.getParameter("clientId");	if (clientId != null) {	synchronized (this) {	
getting local client 

public WebClient getWebClient(HttpServletRequest request) {	String clientId = request.getParameter("clientId");	if (clientId != null) {	synchronized (this) {	WebClient client = clients.get(clientId);	if (client == null) {	
creating new client 

protected void closeConsumerOnOneShot(HttpServletRequest request, WebClient client, Destination dest) {	if (asBoolean(request.getParameter(oneShotParameter), false)) {	try {	client.closeConsumer(dest);	} catch (JMSException jms_exc) {	
jms exception on closing consumer after request with one shot mode 

========================= activemq sample_1045 =========================

public void doTwoClientsReceiveOneClientDisconnects() throws Exception {	applyRateLimitNetworkFilter(0.8 * MESSAGE_COUNT);	bridgeBrokers(broker1, broker2);	bridgeBrokers(broker2, broker1);	startAllBrokers();	Destination dest = createDestination("TEST.FOO", false);	MessageConsumer client1 = createConsumer(broker1, dest);	MessageConsumer client2 = createConsumer(broker2, dest);	Thread.sleep(500);	sendMessages("BrokerA", dest, MESSAGE_COUNT);	
let each client receive of the messages total 

bridgeBrokers(broker2, broker1);	startAllBrokers();	Destination dest = createDestination("TEST.FOO", false);	MessageConsumer client1 = createConsumer(broker1, dest);	MessageConsumer client2 = createConsumer(broker2, dest);	Thread.sleep(500);	sendMessages("BrokerA", dest, MESSAGE_COUNT);	msgsClient1 += receiveExactMessages(client1, (int)(MESSAGE_COUNT * 0.20));	msgsClient2 += receiveExactMessages(client2, (int)(MESSAGE_COUNT * 0.20));	client1.close();	
let the second client receive the rest of the messages 

Destination dest = createDestination("TEST.FOO", false);	MessageConsumer client1 = createConsumer(broker1, dest);	MessageConsumer client2 = createConsumer(broker2, dest);	Thread.sleep(500);	sendMessages("BrokerA", dest, MESSAGE_COUNT);	msgsClient1 += receiveExactMessages(client1, (int)(MESSAGE_COUNT * 0.20));	msgsClient2 += receiveExactMessages(client2, (int)(MESSAGE_COUNT * 0.20));	LOG.info("msgsClient1=" + msgsClient1);	LOG.info("msgsClient2=" + msgsClient2);	Thread.sleep(1000);	
disconnect the first client 

MessageConsumer client1 = createConsumer(broker1, dest);	MessageConsumer client2 = createConsumer(broker2, dest);	Thread.sleep(500);	sendMessages("BrokerA", dest, MESSAGE_COUNT);	msgsClient1 += receiveExactMessages(client1, (int)(MESSAGE_COUNT * 0.20));	msgsClient2 += receiveExactMessages(client2, (int)(MESSAGE_COUNT * 0.20));	LOG.info("msgsClient1=" + msgsClient1);	LOG.info("msgsClient2=" + msgsClient2);	Thread.sleep(1000);	client1.close();	
let the second client receive more of the total messages 

bridgeBrokers(broker1, broker2);	bridgeBrokers(broker2, broker1);	startAllBrokers();	Destination dest = createDestination("TEST.FOO", false);	MessageConsumer client1 = createConsumer(broker1, dest);	MessageConsumer client2 = createConsumer(broker2, dest);	Thread.sleep(500);	sendMessages("BrokerA", dest, MESSAGE_COUNT);	msgsClient1 += receiveExactMessages(client1, (int)(MESSAGE_COUNT * 0.20));	msgsClient2 += receiveExactMessages(client2, (int)(MESSAGE_COUNT * 0.20));	
disconnect both clients 

startAllBrokers();	Destination dest = createDestination("TEST.FOO", false);	MessageConsumer client1 = createConsumer(broker1, dest);	MessageConsumer client2 = createConsumer(broker2, dest);	Thread.sleep(500);	sendMessages("BrokerA", dest, MESSAGE_COUNT);	msgsClient1 += receiveExactMessages(client1, (int)(MESSAGE_COUNT * 0.20));	msgsClient2 += receiveExactMessages(client2, (int)(MESSAGE_COUNT * 0.20));	client1.close();	client2.close();	
serially create another two clients for each broker and consume in turn 

brokerService.setDeleteAllMessagesOnStartup(true);	brokerService.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	public void send(final ProducerBrokerExchange producerExchange, org.apache.activemq.command.Message messageSend) throws Exception {	super.send(producerExchange, messageSend);	if (first.compareAndSet(false, true)) {	producerExchange.getConnectionContext().setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	
waiting for recepit 

brokerService.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	public void send(final ProducerBrokerExchange producerExchange, org.apache.activemq.command.Message messageSend) throws Exception {	super.send(producerExchange, messageSend);	if (first.compareAndSet(false, true)) {	producerExchange.getConnectionContext().setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	assertTrue("message received on time", gotMessageLatch.await(60, TimeUnit.SECONDS));	
stopping connection post send and receive and multiple producers 

startAllBrokers();	waitForBridgeFormation();	Destination dest = createDestination("TEST.FOO", false);	MessageConsumer client2 = createConsumer(broker2, dest);	sendMessages("BrokerA", dest, 1);	assertEquals("Client got message", 1, receiveExactMessages(client2, 1));	client2.close();	gotMessageLatch.countDown();	assertEquals("messages message still there", 1, brokers.get(broker1).broker.getAdminView().getTotalMessageCount());	client2 = createConsumer(broker2, dest);	
let the second client receive the rest of the messages 

brokerService.setDeleteAllMessagesOnStartup(true);	brokerService.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	public void send(final ProducerBrokerExchange producerExchange, org.apache.activemq.command.Message messageSend) throws Exception {	super.send(producerExchange, messageSend);	if (first.compareAndSet(false, true)) {	producerExchange.getConnectionContext().setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	
waiting for recepit 

brokerService.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	public void send(final ProducerBrokerExchange producerExchange, org.apache.activemq.command.Message messageSend) throws Exception {	super.send(producerExchange, messageSend);	if (first.compareAndSet(false, true)) {	producerExchange.getConnectionContext().setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	assertTrue("message received on time", gotMessageLatch.await(60, TimeUnit.SECONDS));	
stopping connection post send and receive and multiple producers 

startAllBrokers();	waitForBridgeFormation();	Destination dest = createDestination("TEST.FOO", false);	MessageConsumer client2 = createConsumer(broker2, dest);	sendMessages("BrokerA", dest, 1);	assertEquals("Client got message", 1, receiveExactMessages(client2, 1));	client2.close();	gotMessageLatch.countDown();	assertEquals("messages message still there", 1, brokers.get(broker1).broker.getAdminView().getTotalMessageCount());	client2 = createConsumer(broker2, dest);	
let the second client receive the rest of the messages 

((KahaDBPersistenceAdapter)brokerService.getPersistenceAdapter()).setConcurrentStoreAndDispatchQueues(false);	brokerService.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	public void send(final ProducerBrokerExchange producerExchange, org.apache.activemq.command.Message messageSend) throws Exception {	super.send(producerExchange, messageSend);	if (first.compareAndSet(false, true)) {	producerExchange.getConnectionContext().setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	
waiting for recepit 

brokerService.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	public void send(final ProducerBrokerExchange producerExchange, org.apache.activemq.command.Message messageSend) throws Exception {	super.send(producerExchange, messageSend);	if (first.compareAndSet(false, true)) {	producerExchange.getConnectionContext().setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	assertTrue("message received on time", gotMessageLatch.await(60, TimeUnit.SECONDS));	
stopping connection post send and receive and multiple producers 

brokerService.setDeleteAllMessagesOnStartup(true);	brokerService.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	public void send(final ProducerBrokerExchange producerExchange, org.apache.activemq.command.Message messageSend) throws Exception {	super.send(producerExchange, messageSend);	if (first.compareAndSet(false, true)) {	producerExchange.getConnectionContext().setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	
waiting for recepit 

brokerService.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	public void send(final ProducerBrokerExchange producerExchange, org.apache.activemq.command.Message messageSend) throws Exception {	super.send(producerExchange, messageSend);	if (first.compareAndSet(false, true)) {	producerExchange.getConnectionContext().setDontSendReponse(true);	Executors.newSingleThreadExecutor().execute(new Runnable() {	public void run() {	try {	assertTrue("message received on time", gotMessageLatch.await(60, TimeUnit.SECONDS));	
stopping connection post send and receive by local queue over bridge 

protected int receiveExactMessages(MessageConsumer consumer, int msgCount) throws Exception {	Message msg;	int i;	for (i = 0; i < msgCount; i++) {	msg = consumer.receive(4000);	if (msg == null) {	
consumer failed to receive exactly messages actual messages received is 

========================= activemq sample_3582 =========================

bridge.setConsumerTopic(replyToConsumerTopic);	bridge.setProducerTopic(replyToProducerTopic);	bridge.setProducerConnection((TopicConnection)replyToProducerConnection);	bridge.setConsumerConnection((TopicConnection)replyToConsumerConnection);	bridge.setDoHandleReplyTo(false);	if (bridge.getJmsMessageConvertor() == null) {	bridge.setJmsMessageConvertor(getInboundMessageConvertor());	}	bridge.setJmsConnector(this);	bridge.start();	
created replyto bridge for 

bridge.setProducerTopic(replyToProducerTopic);	bridge.setProducerConnection((TopicConnection)replyToProducerConnection);	bridge.setConsumerConnection((TopicConnection)replyToConsumerConnection);	bridge.setDoHandleReplyTo(false);	if (bridge.getJmsMessageConvertor() == null) {	bridge.setJmsMessageConvertor(getInboundMessageConvertor());	}	bridge.setJmsConnector(this);	bridge.start();	} catch (Exception e) {	
failed to create replyto bridge for topic 

bridge.setConsumerTopic(replyToConsumerTopic);	bridge.setProducerTopic(replyToProducerTopic);	bridge.setProducerConnection((TopicConnection)replyToProducerConnection);	bridge.setConsumerConnection((TopicConnection)replyToConsumerConnection);	bridge.setDoHandleReplyTo(false);	if (bridge.getJmsMessageConvertor() == null) {	bridge.setJmsMessageConvertor(getOutboundMessageConvertor());	}	bridge.setJmsConnector(this);	bridge.start();	
created replyto bridge for 

bridge.setProducerTopic(replyToProducerTopic);	bridge.setProducerConnection((TopicConnection)replyToProducerConnection);	bridge.setConsumerConnection((TopicConnection)replyToConsumerConnection);	bridge.setDoHandleReplyTo(false);	if (bridge.getJmsMessageConvertor() == null) {	bridge.setJmsMessageConvertor(getOutboundMessageConvertor());	}	bridge.setJmsConnector(this);	bridge.start();	} catch (Exception e) {	
failed to create replyto bridge for topic 

========================= activemq sample_4247 =========================

slave = new BrokerService();	slave.setUseJmx(false);	slave.setDataDirectory(KAHADB_DIRECTORY);	slave.setBrokerName("BROKER");	slaveConnectionUri = slave.addConnector(SLAVE_BIND_ADDRESS).getPublishableConnectString();	new Thread(new Runnable() {	public void run() {	try {	slaveThreadStarted.countDown();	slave.start();	
slave has started 

public void testFailover() throws Exception {	ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(brokerUri);	Connection connection = factory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	ActiveMQResourceAdapter adapter = new ActiveMQResourceAdapter();	adapter.setServerUrl(brokerUri);	adapter.start(new StubBootstrapContext());	final CountDownLatch messageDelivered = new CountDownLatch(1);	final StubMessageEndpoint endpoint = new StubMessageEndpoint() {	public void onMessage(Message message) {	
received message 

return true;	}	};	adapter.endpointActivation(messageEndpointFactory, activationSpec);	try {	Thread.sleep(2000);	} catch (InterruptedException e) {	}	MessageProducer producer = session.createProducer(new ActiveMQQueue("TEST"));	slaveThreadStarted.await(10, TimeUnit.SECONDS);	
stopping master to force failover 

========================= activemq sample_821 =========================

protected BrokerService createBroker(String uri) throws Exception {	
loading broker configuration from the classpath with uri 

========================= activemq sample_2669 =========================

public void testVirtualTopicDisconnect(String messageSelector, int total , int expected) throws Exception {	if (connection == null) {	connection = createConnection();	}	connection.start();	final ConsumerBean messageList = new ConsumerBean();	Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	Destination producerDestination = getProducerDestination();	Destination destination = getConsumerDsetination();	
sending to 

public void testVirtualTopicDisconnect(String messageSelector, int total , int expected) throws Exception {	if (connection == null) {	connection = createConnection();	}	connection.start();	final ConsumerBean messageList = new ConsumerBean();	Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	Destination producerDestination = getProducerDestination();	Destination destination = getConsumerDsetination();	
consuming from 

protected void assertMessagesArrived(ConsumerBean messageList, int expected, long timeout) {	messageList.assertMessagesArrived(expected,timeout);	messageList.flushMessages();	
validate no other messages on queues 

protected void assertMessagesArrived(ConsumerBean messageList, int expected, long timeout) {	messageList.assertMessagesArrived(expected,timeout);	messageList.flushMessages();	try {	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination1 = getConsumerDsetination();	MessageConsumer c1 = session.createConsumer(destination1, null);	c1.setMessageListener(messageList);	
send one simple message that should go to both consumers 

========================= activemq sample_2393 =========================

String uriString = "failover: broker1.getTransportConnectors().get(0).getConnectUri().getPort() + ",tcp: broker2.getTransportConnectors().get(0).getConnectUri().getPort() + ")?randomize=false&initialReconnectDelay=15000";	ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(uriString);	Connection connection = connectionFactory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue destination = session.createQueue("foo");	MessageProducer producer = session.createProducer(destination);	long start = (new Date()).getTime();	producer.send(session.createTextMessage("TEST"));	long end = (new Date()).getTime();	assertTrue((end - start) < 2000);	
stopping the 

Connection connection = connectionFactory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue destination = session.createQueue("foo");	MessageProducer producer = session.createProducer(destination);	long start = (new Date()).getTime();	producer.send(session.createTextMessage("TEST"));	long end = (new Date()).getTime();	assertTrue((end - start) < 2000);	start = (new Date()).getTime();	broker1.stop();	
attempting to send failover should kick in 

Queue destination = session.createQueue("foo");	MessageProducer producer = session.createProducer(destination);	long start = (new Date()).getTime();	producer.send(session.createTextMessage("TEST"));	long end = (new Date()).getTime();	assertTrue((end - start) < 2000);	start = (new Date()).getTime();	broker1.stop();	producer.send(session.createTextMessage("TEST"));	end = (new Date()).getTime();	
failover took ms 

public void testNoSuspendedCallbackOnNoReconnect() throws Exception {	String uriString = "failover: broker1.getTransportConnectors().get(0).getConnectUri().getPort() + ",tcp: broker2.getTransportConnectors().get(0).getConnectUri().getPort() + ")?randomize=false&maxReconnectAttempts=0";	ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(uriString);	final AtomicInteger calls = new AtomicInteger(0);	connectionFactory.setTransportListener(new TransportListener() {	public void onCommand(Object command) {	}	public void onException(IOException error) {	
on exception 

String uriString = "failover: broker1.getTransportConnectors().get(0).getConnectUri().getPort() + ",tcp: broker2.getTransportConnectors().get(0).getConnectUri().getPort() + ")?randomize=false&maxReconnectAttempts=0";	ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(uriString);	final AtomicInteger calls = new AtomicInteger(0);	connectionFactory.setTransportListener(new TransportListener() {	public void onCommand(Object command) {	}	public void onException(IOException error) {	calls.set(0x01 | calls.intValue());	}	public void transportInterupted() {	
on transportinterupted 

connectionFactory.setTransportListener(new TransportListener() {	public void onCommand(Object command) {	}	public void onException(IOException error) {	calls.set(0x01 | calls.intValue());	}	public void transportInterupted() {	calls.set(0x02 | calls.intValue());	}	public void transportResumed() {	
on transportresumed 

calls.set(0x04 | calls.intValue());	}	});	Connection connection = connectionFactory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue destination = session.createQueue("foo");	MessageProducer producer = session.createProducer(destination);	final Message message = session.createTextMessage("TEST");	producer.send(message);	calls.set(0);	
stopping the 

}	});	Connection connection = connectionFactory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue destination = session.createQueue("foo");	MessageProducer producer = session.createProducer(destination);	final Message message = session.createTextMessage("TEST");	producer.send(message);	calls.set(0);	broker1.stop();	
attempting to send failover should throw on disconnect 

========================= activemq sample_2556 =========================

public void testSize() throws Exception {	int messages = 1000;	CountDownLatch redeliveryConsumerLatch = new CountDownLatch((messages*3));	openConsumer(redeliveryConsumerLatch);	assertEquals(0, broker.getAdminView().getStorePercentUsage());	for (int i = 0; i < messages; i++) {	sendMessage(false);	}	final BrokerView brokerView = broker.getAdminView();	broker.getSystemUsage().getStoreUsage().isFull();	
store percent usage 

assertTrue("some store in use", storePercentUsage > minPercentUsageForStore);	assertTrue("redelivery consumer got all it needs", redeliveryConsumerLatch.await(60, TimeUnit.SECONDS));	closeConsumer();	final CountDownLatch received = new CountDownLatch(messages);	consumerConnection = (ActiveMQConnection) createConnection();	Session dlqSession = consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer dlqConsumer = dlqSession.createConsumer(new ActiveMQQueue("ActiveMQ.DLQ"));	dlqConsumer.setMessageListener(new MessageListener() {	public void onMessage(Message message) {	if (received.getCount() % 500 == 0) {	
remaining on dlq 

if (received.getCount() % 500 == 0) {	}	received.countDown();	}	});	consumerConnection.start();	assertTrue("Not all messages reached the DLQ", received.await(60, TimeUnit.SECONDS));	assertTrue("Store usage exceeds expected usage", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	broker.getSystemUsage().getStoreUsage().isFull();	
store precent usage 

private void startBroker(boolean deleteMessages) throws Exception {	broker = new BrokerService();	broker.setAdvisorySupport(false);	broker.setBrokerName("testStoreSize");	if (deleteMessages) {	broker.setDeleteAllMessagesOnStartup(true);	}	
starting broker with persistenceadapterchoice 

========================= activemq sample_2805 =========================

int msgCount;	int msgCommittedCount;	public void onMessage(Message m) {	try {	msgCount++;	TextMessage tm = (TextMessage)m;	receivedText = tm.getText();	if (tm.getJMSRedelivered()) {	msgRedelivered.add(receivedText);	}	
consumer received message redelivered 

try {	msgCount++;	TextMessage tm = (TextMessage)m;	receivedText = tm.getText();	if (tm.getJMSRedelivered()) {	msgRedelivered.add(receivedText);	}	if (msgCount == 3) {	msgRolledBack.add(receivedText);	consumerSession.rollback();	
msg rolled back 

if (tm.getJMSRedelivered()) {	msgRedelivered.add(receivedText);	}	if (msgCount == 3) {	msgRolledBack.add(receivedText);	consumerSession.rollback();	} else {	msgCommittedCount++;	msgCommitted.add(receivedText);	consumerSession.commit();	
msg committed transaction 

msgCommittedCount++;	msgCommitted.add(receivedText);	consumerSession.commit();	}	if (msgCommittedCount == numMessages) {	latch.countDown();	}	} catch (JMSException e) {	try {	consumerSession.rollback();	
rolled back transaction 

}	});	connection.start();	TextMessage tm = null;	try {	for (int i = 1; i <= numMessages; i++) {	tm = producerSession.createTextMessage();	tm.setText("Hello " + i);	msgSent.add(tm.getText());	producer.send(tm);	
producer sent message 

try {	for (int i = 1; i <= numMessages; i++) {	tm = producerSession.createTextMessage();	tm.setText("Hello " + i);	msgSent.add(tm.getText());	producer.send(tm);	}	} catch (JMSException e) {	e.printStackTrace();	}	
waiting for latch 

protected void tearDown() throws Exception {	if (connection != null) {	
closing the connection 

========================= activemq sample_3717 =========================

}	} catch (Exception e) {	publishException.set(e);	}	}	}, "PublishingThread");	pubThread.start();	while (System.currentTimeMillis() - lastLoop.get() < 2000) {	Thread.sleep(100);	}	
publisher deadlock detected 

}	}	}, "PublishingThread");	pubThread.start();	while (System.currentTimeMillis() - lastLoop.get() < 2000) {	Thread.sleep(100);	}	Thread closeThread = new Thread(new Runnable() {	public void run() {	try {	
attempting close 

========================= activemq sample_2940 =========================

public void onMessageCreated(Message message, Session session, Exchange exchange, Throwable cause) {	if (exchange.getIn() instanceof JmsMessage) {	JmsMessage msg = exchange.getIn(JmsMessage.class);	Message jms = msg.getJmsMessage();	if (jms != null && jms instanceof ActiveMQMessage && message instanceof ActiveMQMessage) {	ActiveMQMessage amq = (ActiveMQMessage) jms;	if (amq.getOriginalDestination() == null) {	ActiveMQDestination from = amq.getDestination();	if (from != null) {	
setting originaldestination on 

========================= activemq sample_1395 =========================

protected void configureMetadata() {	if (brokerService != null) {	metadata.openwireVersion = brokerService.getStoreOpenWireVersion();	wireFormat.setVersion(metadata.openwireVersion);	if (LOG.isDebugEnabled()) {	
store openwire version configured as 

public void doStart() throws Exception {	configureMetadata();	super.doStart();	if (brokerService != null) {	if (metadata.openwireVersion != brokerService.getStoreOpenWireVersion()) {	
existing store uses a different openwire version than the version configured reverting to the version used by this store some newer broker features may not work as expected 

public void doStop(ServiceStopper stopper) throws Exception {	
stopping async queue tasks 

synchronized (this.asyncQueueMaps) {	for (Map<AsyncJobKey, StoreTask> m : asyncQueueMaps) {	synchronized (m) {	for (StoreTask task : m.values()) {	task.cancel();	}	}	}	this.asyncQueueMaps.clear();	}	
stopping async topic tasks 

this.globalTopicSemaphore.drainPermits();	}	if (this.queueExecutor != null) {	ThreadPoolUtils.shutdownNow(queueExecutor);	queueExecutor = null;	}	if (this.topicExecutor != null) {	ThreadPoolUtils.shutdownNow(topicExecutor);	topicExecutor = null;	}	
stopped kahadb 

synchronized (asyncTaskMap) {	task = (StoreQueueTask) asyncTaskMap.get(key);	}	if (task != null) {	if (ack.isInTransaction() || !task.cancel()) {	try {	task.future.get();	} catch (InterruptedException e) {	throw new InterruptedIOException(e.toString());	} catch (Exception ignored) {	
removeasync cannot cancel waiting for add resulted in ex 

public void updateMessage(Message message) throws IOException {	if (LOG.isTraceEnabled()) {	
updating with deliverycount 

iterator.remove();	Long sequence = sd.messageIdIndex.get(tx, id);	if (sequence != null) {	if (sd.orderIndex.alreadyDispatched(sequence)) {	listener.recoverMessage(loadMessage(sd.orderIndex.get(tx, sequence).location));	counter++;	if (counter >= maxReturned) {	break;	}	} else {	
rolledback ack message with seq will be picked up in future batch 

if (sequence != null) {	if (sd.orderIndex.alreadyDispatched(sequence)) {	listener.recoverMessage(loadMessage(sd.orderIndex.get(tx, sequence).location));	counter++;	if (counter >= maxReturned) {	break;	}	} else {	}	} else {	
failed to locate rolled back ack message in 

indexLock.writeLock().lock();	try {	pageFile.tx().execute(new Transaction.Closure<Exception>() {	public void execute(Transaction tx) throws Exception {	StoredDestination sd = getExistingStoredDestination(dest, tx);	if (sd != null) {	sd.orderIndex.resetCursorPosition();}	}	});	} catch (Exception e) {	
failed to reset batching 

protected void lockAsyncJobQueue() {	try {	if (!this.localDestinationSemaphore.tryAcquire(this.maxAsyncJobs, 60, TimeUnit.SECONDS)) {	throw new TimeoutException(this +" timeout waiting for localDestSem:" + this.localDestinationSemaphore);	}	} catch (Exception e) {	
failed to lock async jobs for 

protected void acquireLocalAsyncLock() {	try {	this.localDestinationSemaphore.acquire();	} catch (InterruptedException e) {	
failed to aquire async lock for 

}	return false;	}	public void aquireLocks() {	if (this.locked.compareAndSet(false, true)) {	try {	globalQueueSemaphore.acquire();	store.acquireLocalAsyncLock();	message.incrementReferenceCount();	} catch (InterruptedException e) {	
failed to aquire lock 

if (isDone()) {	fireListener();	}	}	private void fireListener() {	Runnable listener = listenerRef.getAndSet(null);	if (listener != null) {	try {	listener.run();	} catch (Exception ignored) {	
unexpected exception from future listener callback 

public void aquireLocks() {	if (this.locked.compareAndSet(false, true)) {	try {	globalTopicSemaphore.acquire();	store.acquireLocalAsyncLock();	message.incrementReferenceCount();	} catch (InterruptedException e) {	
failed to aquire lock 

========================= activemq sample_1815 =========================

protected void doStart() throws Exception {	
listening for connections at 

========================= activemq sample_134 =========================

public void onException(JMSException e) {	
onexception FromHere 

========================= activemq sample_3594 =========================

public void testDurableSubMessageLoss() throws Exception{	BrokerService brokerService = new BrokerService();	connectionUri = brokerService.addConnector(brokerUrl).getPublishableConnectString();	brokerService.setPersistent(false);	brokerService.setUseJmx(false);	brokerService.setKeepDurableSubsActive(true);	brokerService.setAdvisorySupport(false);	brokerService.start();	
broker started 

public void testDurableSubMessageLoss() throws Exception{	BrokerService brokerService = new BrokerService();	connectionUri = brokerService.addConnector(brokerUrl).getPublishableConnectString();	brokerService.setPersistent(false);	brokerService.setUseJmx(false);	brokerService.setKeepDurableSubsActive(true);	brokerService.setAdvisorySupport(false);	brokerService.start();	try {	for (int i = 0; i < numTests; ++i) {	
test started 

connectionUri = brokerService.addConnector(brokerUrl).getPublishableConnectString();	brokerService.setPersistent(false);	brokerService.setUseJmx(false);	brokerService.setKeepDurableSubsActive(true);	brokerService.setAdvisorySupport(false);	brokerService.start();	try {	for (int i = 0; i < numTests; ++i) {	test();	}	
tests are done 

brokerService.setUseJmx(false);	brokerService.setKeepDurableSubsActive(true);	brokerService.setAdvisorySupport(false);	brokerService.start();	try {	for (int i = 0; i < numTests; ++i) {	test();	}	} catch (Exception e) {	e.printStackTrace();	
tests failed 

brokerService.start();	try {	for (int i = 0; i < numTests; ++i) {	test();	}	} catch (Exception e) {	e.printStackTrace();	} finally {	threadPool.shutdown();	brokerService.stop();	
broker stopped 

connection = factory.createConnection();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Topic topic = session.createTopic(topicName);	MessageProducer producer = session.createProducer(topic);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	producer.setPriority(Message.DEFAULT_PRIORITY);	producer.setTimeToLive(Message.DEFAULT_TIME_TO_LIVE);	for (int seq = 1; seq <= numMsgs; ++seq) {	TextMessage msg = session.createTextMessage(String.valueOf(seq));	producer.send(msg);	
pub sent msg 

Topic topic = session.createTopic(topicName);	MessageProducer producer = session.createProducer(topic);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	producer.setPriority(Message.DEFAULT_PRIORITY);	producer.setTimeToLive(Message.DEFAULT_TIME_TO_LIVE);	for (int seq = 1; seq <= numMsgs; ++seq) {	TextMessage msg = session.createTextMessage(String.valueOf(seq));	producer.send(msg);	Thread.sleep(1L);	}	
pub is done 

Topic topic;	TopicSubscriber consumer;	public Boolean call() throws Exception {	factory = new ActiveMQConnectionFactory(connectionUri);	factory.setWatchTopicAdvisories(false);	try {	connect();	for (int seqExpected = 1; seqExpected <= numMsgs; ++seqExpected) {	TextMessage msg = (TextMessage) consumer.receive(3000L);	if (msg == null) {	
expected actual timed out 

factory = new ActiveMQConnectionFactory(connectionUri);	factory.setWatchTopicAdvisories(false);	try {	connect();	for (int seqExpected = 1; seqExpected <= numMsgs; ++seqExpected) {	TextMessage msg = (TextMessage) consumer.receive(3000L);	if (msg == null) {	return Boolean.FALSE;	}	int seq = Integer.parseInt(msg.getText());	
sub received msg 

factory.setWatchTopicAdvisories(false);	try {	connect();	for (int seqExpected = 1; seqExpected <= numMsgs; ++seqExpected) {	TextMessage msg = (TextMessage) consumer.receive(3000L);	if (msg == null) {	return Boolean.FALSE;	}	int seq = Integer.parseInt(msg.getText());	if (seqExpected != seq) {	
expected actual 

if (msg == null) {	return Boolean.FALSE;	}	int seq = Integer.parseInt(msg.getText());	if (seqExpected != seq) {	return Boolean.FALSE;	}	if (seq % numMsgsTriggeringReconnection == 0) {	close(false);	connect();	
sub reconnected 

}	int seq = Integer.parseInt(msg.getText());	if (seqExpected != seq) {	return Boolean.FALSE;	}	if (seq % numMsgsTriggeringReconnection == 0) {	close(false);	connect();	}	}	
sub is done 

========================= activemq sample_2852 =========================

public void testMultipleTcpURLsWithInactivityTimeoutAndMaxReconnectDelayAndFailoverProperty() throws Exception {	factory.setTcpHostAndPorts(Arrays.asList(new String[] {"tcp: factory.setMaxInactivityDuration(40000L);	factory.setMaxReconnectDelay(30000L);	factory.setFailoverProperties("useExponentialBackOff=false");	assertCreatedURL("failover:(tcp: }	protected void assertCreatedURL(String expectedURL) throws Exception {	String url = factory.getBrokerURL();	
generated url 

========================= activemq sample_3740 =========================

public void tearDown() throws Exception {	if (brokerService != null) {	try {	brokerService.stop();	brokerService.waitUntilStopped();	brokerService = null;	} catch (Exception ex) {	
suppress error on shutdown 

========================= activemq sample_1287 =========================

broker.setDeleteAllMessagesOnStartup(delete);	broker.setPersistent(true);	broker.setUseJmx(false);	broker.addConnector("tcp: PolicyMap map = new PolicyMap();	PolicyEntry entry = new PolicyEntry();	entry.setUseCache(false);	map.setDefaultEntry(entry);	broker.setDestinationPolicy(map);	configurePersistence(broker, delete);	broker.start();	
starting broker 

private int getFileCount(File dir){	if (dir.isDirectory()) {	String[] children = dir.list();	
children 

========================= activemq sample_2917 =========================

MessageIdList msgsA = getConsumerMessages("BrokerA", clientA);	MessageIdList msgsB = getConsumerMessages("BrokerB", clientB);	MessageIdList msgsC = getConsumerMessages("BrokerC", clientC);	msgsA.waitForMessagesToArrive(1);	msgsB.waitForMessagesToArrive(1);	msgsC.waitForMessagesToArrive(1);	Thread.sleep(2000);	assertEquals(1, msgsA.getMessageCount());	assertEquals(1, msgsB.getMessageCount());	assertEquals(1, msgsC.getMessageCount());	
restarting brokera 

assertEquals(1, msgsC.getMessageCount());	BrokerItem brokerItem = brokers.remove("BrokerA");	if (brokerItem != null) {	brokerItem.destroy();	}	BrokerService restartedBroker = createAndConfigureBroker(new URI("broker:(tcp: bridgeAndConfigureBrokers("BrokerA", "BrokerB", dynamicOnly, networkTTL, conduitSubs);	bridgeAndConfigureBrokers("BrokerA", "BrokerC", dynamicOnly, networkTTL, conduitSubs);	restartedBroker.start();	waitForBridgeFormation();	clientA = createConsumer("BrokerA", createDestination("Consumer.A.TEST.FOO", false));	
recreated clienta 

restartedBroker.start();	waitForBridgeFormation();	clientA = createConsumer("BrokerA", createDestination("Consumer.A.TEST.FOO", false));	Thread.sleep(2000);	sendMessages("BrokerA", dest, 10);	msgsA = getConsumerMessages("BrokerA", clientA);	msgsA.waitForMessagesToArrive(10);	msgsB.waitForMessagesToArrive(11);	msgsC.waitForMessagesToArrive(11);	Thread.sleep(2000);	
messagesa 

Thread.sleep(2000);	sendMessages("BrokerA", dest, 10);	msgsA = getConsumerMessages("BrokerA", clientA);	msgsA.waitForMessagesToArrive(10);	msgsB.waitForMessagesToArrive(11);	msgsC.waitForMessagesToArrive(11);	Thread.sleep(2000);	assertEquals(10, msgsA.getMessageCount());	assertEquals(11, msgsB.getMessageCount());	assertEquals(11, msgsC.getMessageCount());	
restarting brokera again 

assertEquals(11, msgsC.getMessageCount());	brokerItem = brokers.remove("BrokerA");	if (brokerItem != null) {	brokerItem.destroy();	}	restartedBroker = createAndConfigureBroker(new URI("broker:(tcp: bridgeAndConfigureBrokers("BrokerA", "BrokerB", dynamicOnly, networkTTL, conduitSubs);	bridgeAndConfigureBrokers("BrokerA", "BrokerC", dynamicOnly, networkTTL, conduitSubs);	restartedBroker.start();	waitForBridgeFormation();	clientA = createConsumer("BrokerA", createDestination("Consumer.A.TEST.FOO", false));	
recreated clienta again 

brokerItem.destroy();	}	restartedBroker = createAndConfigureBroker(new URI("broker:(tcp: bridgeAndConfigureBrokers("BrokerA", "BrokerB", dynamicOnly, networkTTL, conduitSubs);	bridgeAndConfigureBrokers("BrokerA", "BrokerC", dynamicOnly, networkTTL, conduitSubs);	restartedBroker.start();	waitForBridgeFormation();	clientA = createConsumer("BrokerA", createDestination("Consumer.A.TEST.FOO", false));	Thread.sleep(2000);	msgsA = getConsumerMessages("BrokerA", clientA);	Thread.sleep(5000);	
extra messagesa 

========================= activemq sample_3605 =========================

public void doIO(SelectionKey k) throws InterruptedException {	final int millis = this.testHandle.getIOWaitMillis();	if (millis > 0) {	
imposing a millisecond wait on servercxn 

========================= activemq sample_1268 =========================

protected void createJournal() throws IOException {	File journalDir = new File(getDataDirectoryFile(), "journal").getCanonicalFile();	if (failIfJournalIsLocked) {	journal = new JournalImpl(journalDir, journalLogFiles, journalLogFileSize, getJournalArchiveDirectory());	} else {	while (true) {	try {	journal = new JournalImpl(journalDir, journalLogFiles, journalLogFileSize, getJournalArchiveDirectory());	break;	} catch (JournalLockedException e) {	
journal is locked waiting seconds for the journal to be unlocked 

========================= activemq sample_925 =========================

message.setCorrelationId("correlation");	message.setContent(new ByteSequence(new byte[1024], 0, 1024));	message.setTimestamp(System.currentTimeMillis());	message.setDestination(new ActiveMQQueue("TEST"));	int p = 1000000;	long start = System.currentTimeMillis();	for (int i = 0; i < p; i++) {	marshalAndUnmarshall(message, wireFormat);	}	long end = System.currentTimeMillis();	
marshaled unmarshaled msgs at msgs sec 

========================= activemq sample_3486 =========================

protected void setUp() throws Exception {	
start 

protected void tearDown() throws Exception {	try {	super.tearDown();	} catch (Throwable e) {	e.printStackTrace(System.out);	} finally {	
end 

========================= activemq sample_2278 =========================

public void init() {	if (!initDone.get()) {	synchronized(this) {	if (!initDone.get()) {	if (dedicatedTaskRunner || "true".equalsIgnoreCase(System.getProperty("org.apache.activemq.UseDedicatedTaskRunner"))) {	executorRef.set(null);	} else {	executorRef.compareAndSet(null, createDefaultExecutor());	}	
initialized taskrunnerfactory using executorservice 

public void execute(Runnable runnable, String name) {	init();	
execute runnable 

private void doExecuteNewThread(Runnable runnable, String name) {	String threadName = name + "-" + id.incrementAndGet();	Thread thread = new Thread(runnable, threadName);	thread.setDaemon(daemon);	
created and running thread 

public Thread newThread(Runnable runnable) {	String threadName = name + "-" + id.incrementAndGet();	Thread thread = new Thread(runnable, threadName);	thread.setDaemon(daemon);	thread.setPriority(priority);	if (threadClassLoader != null) {	thread.setContextClassLoader(threadClassLoader);	}	thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {	public void uncaughtException(final Thread t, final Throwable e) {	
error in thread 

Thread thread = new Thread(runnable, threadName);	thread.setDaemon(daemon);	thread.setPriority(priority);	if (threadClassLoader != null) {	thread.setContextClassLoader(threadClassLoader);	}	thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {	public void uncaughtException(final Thread t, final Throwable e) {	}	});	
created thread 

========================= activemq sample_724 =========================

public void testBrokerConfiguredCorrectly() throws Exception {	assertEquals("testbroker", brokerService.getBrokerName());	Topic topic = (Topic)broker.addDestination(context, new ActiveMQTopic("FOO.BAR"),true);	DispatchPolicy dispatchPolicy = topic.getDispatchPolicy();	assertTrue("dispatchPolicy should be RoundRobinDispatchPolicy: " + dispatchPolicy, dispatchPolicy instanceof RoundRobinDispatchPolicy);	SubscriptionRecoveryPolicy subscriptionRecoveryPolicy = topic.getSubscriptionRecoveryPolicy();	subscriptionRecoveryPolicy = ((RetainedMessageSubscriptionRecoveryPolicy)subscriptionRecoveryPolicy).getWrapped();	assertTrue("subscriptionRecoveryPolicy should be LastImageSubscriptionRecoveryPolicy: " + subscriptionRecoveryPolicy, subscriptionRecoveryPolicy instanceof LastImageSubscriptionRecoveryPolicy);	
destination 

public void testBrokerConfiguredCorrectly() throws Exception {	assertEquals("testbroker", brokerService.getBrokerName());	Topic topic = (Topic)broker.addDestination(context, new ActiveMQTopic("FOO.BAR"),true);	DispatchPolicy dispatchPolicy = topic.getDispatchPolicy();	assertTrue("dispatchPolicy should be RoundRobinDispatchPolicy: " + dispatchPolicy, dispatchPolicy instanceof RoundRobinDispatchPolicy);	SubscriptionRecoveryPolicy subscriptionRecoveryPolicy = topic.getSubscriptionRecoveryPolicy();	subscriptionRecoveryPolicy = ((RetainedMessageSubscriptionRecoveryPolicy)subscriptionRecoveryPolicy).getWrapped();	assertTrue("subscriptionRecoveryPolicy should be LastImageSubscriptionRecoveryPolicy: " + subscriptionRecoveryPolicy, subscriptionRecoveryPolicy instanceof LastImageSubscriptionRecoveryPolicy);	
dispatchpolicy 

public void testBrokerConfiguredCorrectly() throws Exception {	assertEquals("testbroker", brokerService.getBrokerName());	Topic topic = (Topic)broker.addDestination(context, new ActiveMQTopic("FOO.BAR"),true);	DispatchPolicy dispatchPolicy = topic.getDispatchPolicy();	assertTrue("dispatchPolicy should be RoundRobinDispatchPolicy: " + dispatchPolicy, dispatchPolicy instanceof RoundRobinDispatchPolicy);	SubscriptionRecoveryPolicy subscriptionRecoveryPolicy = topic.getSubscriptionRecoveryPolicy();	subscriptionRecoveryPolicy = ((RetainedMessageSubscriptionRecoveryPolicy)subscriptionRecoveryPolicy).getWrapped();	assertTrue("subscriptionRecoveryPolicy should be LastImageSubscriptionRecoveryPolicy: " + subscriptionRecoveryPolicy, subscriptionRecoveryPolicy instanceof LastImageSubscriptionRecoveryPolicy);	
subscriptionrecoverypolicy 

subscriptionRecoveryPolicy = ((RetainedMessageSubscriptionRecoveryPolicy)subscriptionRecoveryPolicy).getWrapped();	assertTrue("subscriptionRecoveryPolicy should be LastImageSubscriptionRecoveryPolicy: " + subscriptionRecoveryPolicy, subscriptionRecoveryPolicy instanceof LastImageSubscriptionRecoveryPolicy);	topic = (Topic)broker.addDestination(context, new ActiveMQTopic("ORDERS.BOOKS"),true);	dispatchPolicy = topic.getDispatchPolicy();	assertTrue("dispatchPolicy should be StrictOrderDispatchPolicy: " + dispatchPolicy, dispatchPolicy instanceof StrictOrderDispatchPolicy);	subscriptionRecoveryPolicy = topic.getSubscriptionRecoveryPolicy();	subscriptionRecoveryPolicy = ((RetainedMessageSubscriptionRecoveryPolicy)subscriptionRecoveryPolicy).getWrapped();	assertTrue("subscriptionRecoveryPolicy should be TimedSubscriptionRecoveryPolicy: " + subscriptionRecoveryPolicy, subscriptionRecoveryPolicy instanceof TimedSubscriptionRecoveryPolicy);	TimedSubscriptionRecoveryPolicy timedSubscriptionPolicy = (TimedSubscriptionRecoveryPolicy)subscriptionRecoveryPolicy;	assertEquals("getRecoverDuration()", 60000, timedSubscriptionPolicy.getRecoverDuration());	
destination 

subscriptionRecoveryPolicy = ((RetainedMessageSubscriptionRecoveryPolicy)subscriptionRecoveryPolicy).getWrapped();	assertTrue("subscriptionRecoveryPolicy should be LastImageSubscriptionRecoveryPolicy: " + subscriptionRecoveryPolicy, subscriptionRecoveryPolicy instanceof LastImageSubscriptionRecoveryPolicy);	topic = (Topic)broker.addDestination(context, new ActiveMQTopic("ORDERS.BOOKS"),true);	dispatchPolicy = topic.getDispatchPolicy();	assertTrue("dispatchPolicy should be StrictOrderDispatchPolicy: " + dispatchPolicy, dispatchPolicy instanceof StrictOrderDispatchPolicy);	subscriptionRecoveryPolicy = topic.getSubscriptionRecoveryPolicy();	subscriptionRecoveryPolicy = ((RetainedMessageSubscriptionRecoveryPolicy)subscriptionRecoveryPolicy).getWrapped();	assertTrue("subscriptionRecoveryPolicy should be TimedSubscriptionRecoveryPolicy: " + subscriptionRecoveryPolicy, subscriptionRecoveryPolicy instanceof TimedSubscriptionRecoveryPolicy);	TimedSubscriptionRecoveryPolicy timedSubscriptionPolicy = (TimedSubscriptionRecoveryPolicy)subscriptionRecoveryPolicy;	assertEquals("getRecoverDuration()", 60000, timedSubscriptionPolicy.getRecoverDuration());	
dispatchpolicy 

subscriptionRecoveryPolicy = ((RetainedMessageSubscriptionRecoveryPolicy)subscriptionRecoveryPolicy).getWrapped();	assertTrue("subscriptionRecoveryPolicy should be LastImageSubscriptionRecoveryPolicy: " + subscriptionRecoveryPolicy, subscriptionRecoveryPolicy instanceof LastImageSubscriptionRecoveryPolicy);	topic = (Topic)broker.addDestination(context, new ActiveMQTopic("ORDERS.BOOKS"),true);	dispatchPolicy = topic.getDispatchPolicy();	assertTrue("dispatchPolicy should be StrictOrderDispatchPolicy: " + dispatchPolicy, dispatchPolicy instanceof StrictOrderDispatchPolicy);	subscriptionRecoveryPolicy = topic.getSubscriptionRecoveryPolicy();	subscriptionRecoveryPolicy = ((RetainedMessageSubscriptionRecoveryPolicy)subscriptionRecoveryPolicy).getWrapped();	assertTrue("subscriptionRecoveryPolicy should be TimedSubscriptionRecoveryPolicy: " + subscriptionRecoveryPolicy, subscriptionRecoveryPolicy instanceof TimedSubscriptionRecoveryPolicy);	TimedSubscriptionRecoveryPolicy timedSubscriptionPolicy = (TimedSubscriptionRecoveryPolicy)subscriptionRecoveryPolicy;	assertEquals("getRecoverDuration()", 60000, timedSubscriptionPolicy.getRecoverDuration());	
subscriptionrecoverypolicy 

protected BrokerService createBroker() throws Exception {	String uri = "org/apache/activemq/xbean/activemq-policy.xml";	
loading broker configuration from the classpath with uri 

========================= activemq sample_2595 =========================

storeUsage.setPercentLimit(tempFreePercent / 2);	broker.setSchedulePeriodForDiskUsageCheck(2000);	startBroker();	long originalDisk = broker.getSystemUsage().getStoreUsage().getLimit();	long originalTmp = broker.getSystemUsage().getTempUsage().getLimit();	writeTestFile(5 * 1024 * 1024);	Thread.sleep(5000);	assertEquals(originalDisk, broker.getSystemUsage().getStoreUsage().getLimit());	assertEquals(originalTmp, broker.getSystemUsage().getTempUsage().getLimit());	}	
not running b c there is less that disk space freeprecent 

========================= activemq sample_2983 =========================

public void testCreateLotsOfTemporaryQueues() throws Exception {	
creating temporary queue s 

public void testCreateLotsOfTemporaryQueues() throws Exception {	Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);	for (int i = 0; i < numberToCreate; i++) {	if (i % 1000 == 0) {	
attempt 

public void testCreateLotsOfTemporaryQueues() throws Exception {	Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);	for (int i = 0; i < numberToCreate; i++) {	if (i % 1000 == 0) {	}	TemporaryQueue temporaryQueue = session.createTemporaryQueue();	temporaryQueue.delete();	Thread.sleep(sleep);	}	
created temporary queue s 

========================= activemq sample_3691 =========================

private void register() {	try {	AnnotatedMBean.registerMBean(this.managementContext, this, this.name);	} catch (Exception e) {	
could not register mbean for transportloggerview with name reason 

public void unregister() {	TransportLoggerView.transportLoggerViews.remove(this);	try {	this.managementContext.unregisterMBean(this.name);	} catch (Exception e) {	
could not unregister mbean for transportloggerview with name reason 

========================= activemq sample_4154 =========================

CONTENTS[i] = 'a';	}	output.write(inputHeader.getBuffer());	output.writeInt(MESSAGE_SIZE + 4);	output.write(CONTENTS);	output.close();	try {	codec.parse(output.toBuffer().toByteBuffer());	fail("Should have failed to read the large frame.");	} catch (Exception ex) {	
caught expected error 

========================= activemq sample_1585 =========================

public void testShutdownWithoutTransportRestart() throws Exception {	Mockery context = new Mockery() {{	setImposteriser(ClassImposteriser.INSTANCE);	}};	Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {	public void uncaughtException(Thread t, Throwable e) {	
unexpected exception on thread 

}});	LeaseLockerIOExceptionHandler underTest = new LeaseLockerIOExceptionHandler();	underTest.setBrokerService(brokerService);	try {	underTest.handle(new IOException());	fail("except suppress reply ex");	} catch (SuppressReplyException expected) {	}	assertTrue("broker stopped state triggered", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
broker state 

========================= activemq sample_3804 =========================

ActiveMQConnection consumerConnection = (ActiveMQConnection) createConnection();	RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy();	redeliveryPolicy.setInitialRedeliveryDelay(0);	redeliveryPolicy.setMaximumRedeliveries(0);	consumerConnection.setRedeliveryPolicy(redeliveryPolicy);	consumerConnection.start();	Session consumerSession = consumerConnection.createSession(true, Session.SESSION_TRANSACTED);	MessageConsumer consumer = consumerSession.createConsumer(destination);	Message message = consumer.receive(1000);	assertNotNull("got message", message);	
got 

Session consumerSession = consumerConnection.createSession(true, Session.SESSION_TRANSACTED);	MessageConsumer consumer = consumerSession.createConsumer(destination);	Message message = consumer.receive(1000);	assertNotNull("got message", message);	consumerSession.rollback();	for (int i = 0; i < maxBrokerRedeliveriesToValidate; i++) {	Message shouldBeNull = consumer.receive(500);	assertNull("did not get message early: " + shouldBeNull, shouldBeNull);	TimeUnit.SECONDS.sleep(4);	Message brokerRedeliveryMessage = consumer.receive(1500);	
got 

========================= activemq sample_2346 =========================

public void testNoDupsOnSlowConsumerReconnect() throws Exception {	JmsConsumerDup consumer = new JmsConsumerDup();	consumer.done.set(true);	consumer.run();	consumer.done.set(false);	
serial production then consumption 

MessageConsumer consumer;	factory = new ActiveMQConnectionFactory(url);	try {	connection = factory.createConnection("MyUsername", "MyPassword");	connection.setClientID(clntId);	connection.start();	session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	topic = session.createTopic(queueName);	consumer = session.createDurableSubscriber(topic, subscriptionName, selector, false);	consumer.setMessageListener(this);	
waiting for messages 

topic = session.createTopic(queueName);	consumer = session.createDurableSubscriber(topic, subscriptionName, selector, false);	consumer.setMessageListener(this);	while (!done.get()) {	TimeUnit.SECONDS.sleep(5);	if (count == TO_RECEIVE || !exceptions.isEmpty()) {	done.set(true);	}	}	} catch (Exception e) {	
caught 

if (count == TO_RECEIVE || !exceptions.isEmpty()) {	done.set(true);	}	}	} catch (Exception e) {	exceptions.add(e);	throw new RuntimeException(e);	} finally {	if (connection != null) {	try {	
consumer done closing connection 

public void onMessage(Message message) {	++count;	try {	Thread.sleep(0L);	} catch (InterruptedException e) {	}	;	try {	TextMessage m = (TextMessage) message;	if (count%100 == 0) {	
rcvd msg sent recv expr mid 

} catch (InterruptedException e) {	}	;	try {	TextMessage m = (TextMessage) message;	if (count%100 == 0) {	}	int i = m.getIntProperty("SeqNo");	if (i < MAX_MESSAGES) {	if (dupChecker[i] == 1) {	
duplicate message received at count id 

}	int i = m.getIntProperty("SeqNo");	if (i < MAX_MESSAGES) {	if (dupChecker[i] == 1) {	exceptions.add(new RuntimeException("Got Duplicate at: " + m.getJMSMessageID()));	} else {	dupChecker[i] = 1;	}	}	} catch (JMSException e) {	
caught 

int priority = 0;	if (priorityModulator <= 10) {	priority = msgSeqNo % priorityModulator;	} else {	priority = (msgSeqNo >= priorityModulator) ? 9 : 0;	}	message.setText(xmlMessage + msgSeqNo + "-" + priority);	message.setJMSPriority(priority);	message.setIntProperty("SeqNo", msgSeqNo);	if (i > 0 && i%100 == 0) {	
sending message 

msgSeqNo++;	}	try {	Thread.sleep(1000L);	} catch (InterruptedException e) {	e.printStackTrace();	exceptions.add(e);	}	}	} catch (JMSException e) {	
caught 

========================= activemq sample_3629 =========================

amqpSession.close();	amqpConnection.close();	ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(openwireConnectionURI);	Connection openwireConn = factory.createConnection();	openwireConn.start();	Session session = openwireConn.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue jmsDest = session.createQueue(TEST_QUEUE);	MessageConsumer c = session.createConsumer(jmsDest);	Message message = c.receive(2000);	assertNotNull("Should have received a message", message);	
recieved message 

========================= activemq sample_1614 =========================

if (!exceptions.isEmpty()) {	Exception e = (Exception)exceptions.remove();	e.printStackTrace();	fail("Caught exception: " + e);	}	assertEquals("number of messages received", expectedCount, commands.size());	assertEquals("Should have no buffered commands", 0, transport.getBufferedCommandCount());	} else {	assertTrue("Should have received an exception!", exceptions.size() > 0);	Exception e = (Exception)exceptions.remove();	
caught expected response 

========================= activemq sample_2468 =========================

public BrokerService lookup(String brokerName) {	BrokerService result = null;	synchronized (mutex) {	result = brokers.get(brokerName);	if (result == null && brokerName != null && brokerName.equals(BrokerService.DEFAULT_BROKER_NAME)) {	result = findFirst();	if (result != null) {	
broker localhost not started so using instead 

========================= activemq sample_4103 =========================

public void verifyInflightAttribute() throws Exception {	String result = executeQuery("");	
result 

public void verifyInflightAttribute() throws Exception {	String result = executeQuery("");	assertFalse("Output valid", result.contains("Inflight"));	result = executeQuery("queues");	
result 

========================= activemq sample_1478 =========================

e.printStackTrace();	}	throw new RuntimeException("Horrible exception");	}});	ObjectName queueViewMBeanName = assertRegisteredObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Queue,destinationName=" + getDestinationString());	QueueViewMBean queue = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, queueViewMBeanName, QueueViewMBean.class, true);	ObjectName dlqQueueViewMBeanName = assertRegisteredObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Queue,destinationName=" + SharedDeadLetterStrategy.DEFAULT_DEAD_LETTER_QUEUE_NAME );	QueueViewMBean dlq = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, dlqQueueViewMBeanName, QueueViewMBean.class, true);	assertTrue("messages on dlq", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
dlq size qsize 

ObjectName dlqQueueViewMBeanName = assertRegisteredObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Queue,destinationName=" + SharedDeadLetterStrategy.DEFAULT_DEAD_LETTER_QUEUE_NAME );	QueueViewMBean dlq = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, dlqQueueViewMBeanName, QueueViewMBean.class, true);	assertTrue("messages on dlq", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return MESSAGE_COUNT == dlq.getQueueSize();	}	}));	dlq.retryMessages();	assertTrue("messages on dlq after retry", Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
dlq size qsize 

connection = connectionFactory.createConnection();	useConnection(connection);	ObjectName queueViewMBeanName = assertRegisteredObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Queue,destinationName=" + getDestinationString());	QueueViewMBean queue = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, queueViewMBeanName, QueueViewMBean.class, true);	String newDestination = getSecondDestinationString();	long queueSize = queue.getQueueSize();	assertTrue(queueSize > 0);	queue.copyMatchingMessagesTo("counter > 2", newDestination);	queueViewMBeanName = assertRegisteredObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Queue,destinationName=" + newDestination);	queue = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, queueViewMBeanName, QueueViewMBean.class, true);	
queue now has message s 

public void testCopyPurgeCopyBack() throws Exception {	connection = connectionFactory.createConnection();	final int numMessages = 100;	useConnection(connection, numMessages);	ObjectName queueViewMBeanName = assertRegisteredObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Queue,destinationName=" + getDestinationString());	QueueViewMBean queueT = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, queueViewMBeanName, QueueViewMBean.class, true);	String newDestination = getSecondDestinationString();	long queueSize = queueT.getQueueSize();	assertTrue(queueSize > 0);	int c = queueT.copyMatchingMessagesTo(null, newDestination);	
copied 

final int numMessages = 100;	useConnection(connection, numMessages);	ObjectName queueViewMBeanName = assertRegisteredObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Queue,destinationName=" + getDestinationString());	QueueViewMBean queueT = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, queueViewMBeanName, QueueViewMBean.class, true);	String newDestination = getSecondDestinationString();	long queueSize = queueT.getQueueSize();	assertTrue(queueSize > 0);	int c = queueT.copyMatchingMessagesTo(null, newDestination);	queueViewMBeanName = assertRegisteredObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Queue,destinationName=" + newDestination);	QueueViewMBean queueD = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, queueViewMBeanName, QueueViewMBean.class, true);	
queue now has message s 

useConnection(connection, numMessages);	ObjectName queueViewMBeanName = assertRegisteredObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Queue,destinationName=" + getDestinationString());	QueueViewMBean queueT = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, queueViewMBeanName, QueueViewMBean.class, true);	String newDestination = getSecondDestinationString();	long queueSize = queueT.getQueueSize();	assertTrue(queueSize > 0);	int c = queueT.copyMatchingMessagesTo(null, newDestination);	queueViewMBeanName = assertRegisteredObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Queue,destinationName=" + newDestination);	QueueViewMBean queueD = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, queueViewMBeanName, QueueViewMBean.class, true);	assertEquals("Expected messages in a queue: " + queueD.getQueueSize(), numMessages, queueD.getQueueSize());	
queue now has message s 

String newDestination = getSecondDestinationString();	long queueSize = queueT.getQueueSize();	assertTrue(queueSize > 0);	int c = queueT.copyMatchingMessagesTo(null, newDestination);	queueViewMBeanName = assertRegisteredObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Queue,destinationName=" + newDestination);	QueueViewMBean queueD = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, queueViewMBeanName, QueueViewMBean.class, true);	assertEquals("Expected messages in a queue: " + queueD.getQueueSize(), numMessages, queueD.getQueueSize());	assertEquals("Expected messages in a queue: " + queueT.getQueueSize(), numMessages, queueT.getQueueSize());	queueT.purge();	queueD.copyMatchingMessagesTo(null, getDestinationString());	
queue now has message s 

long queueSize = queueT.getQueueSize();	assertTrue(queueSize > 0);	int c = queueT.copyMatchingMessagesTo(null, newDestination);	queueViewMBeanName = assertRegisteredObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Queue,destinationName=" + newDestination);	QueueViewMBean queueD = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, queueViewMBeanName, QueueViewMBean.class, true);	assertEquals("Expected messages in a queue: " + queueD.getQueueSize(), numMessages, queueD.getQueueSize());	assertEquals("Expected messages in a queue: " + queueT.getQueueSize(), numMessages, queueT.getQueueSize());	queueT.purge();	queueD.copyMatchingMessagesTo(null, getDestinationString());	assertEquals("Expected messages in a queue: " + queueD.getQueueSize(), numMessages, queueD.getQueueSize());	
queue now has message s 

echo("Create QueueView MBean...");	BrokerViewMBean broker = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, brokerName, BrokerViewMBean.class, true);	broker.addTopic(getDestinationString());	assertEquals("Durable subscriber count", 0, broker.getDurableTopicSubscribers().length);	String topicName = getDestinationString();	String selector = null;	ObjectName name1 = broker.createDurableSubscriber(clientID, "subscriber1", topicName, selector);	broker.createDurableSubscriber(clientID, "subscriber2", topicName, selector);	assertEquals("Durable subscriber count", 2, broker.getInactiveDurableTopicSubscribers().length);	assertNotNull("Should have created an mbean name for the durable subscriber!", name1);	
created durable subscriber with name 

public void testDestinationOptionsAreVisible() throws Exception {	ObjectName queueViewMBeanName = assertRegisteredObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Queue,destinationName=" + QUEUE_WITH_OPTIONS );	QueueViewMBean queue = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, queueViewMBeanName, QueueViewMBean.class, true);	assertEquals("name match", QUEUE_WITH_OPTIONS, queue.getName());	String options = queue.getOptions();	
got options 

connection.setClientID("MBeanTest");	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination queue = session.createQueue(getDestinationString() + ".Queue");	MessageConsumer queueConsumer = session.createConsumer(queue);	MessageProducer producer = session.createProducer(queue);	ObjectName brokerName = assertRegisteredObjectName(domain + ":type=Broker,brokerName=localhost");	BrokerViewMBean broker = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, brokerName, BrokerViewMBean.class, true);	Thread.sleep(100);	assertTrue(broker.getQueueSubscribers().length == 1);	ObjectName subscriptionName = broker.getQueueSubscribers()[0];	
looking for subscription 

MessageConsumer queueConsumer = session.createConsumer(queue);	MessageProducer producer = session.createProducer(queue);	ObjectName brokerName = assertRegisteredObjectName(domain + ":type=Broker,brokerName=localhost");	BrokerViewMBean broker = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, brokerName, BrokerViewMBean.class, true);	Thread.sleep(100);	assertTrue(broker.getQueueSubscribers().length == 1);	ObjectName subscriptionName = broker.getQueueSubscribers()[0];	SubscriptionViewMBean subscriberView = MBeanServerInvocationHandler.newProxyInstance( mbeanServer, subscriptionName, SubscriptionViewMBean.class, true);	assertNotNull(subscriberView);	ObjectName connectionName = subscriberView.getConnection();	
looking for connection 

public void testAddRemoveConnectorBrokerView() throws Exception {	ObjectName brokerName = assertRegisteredObjectName(domain + ":type=Broker,brokerName=localhost");	BrokerViewMBean brokerView = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, brokerName, BrokerViewMBean.class, true);	Map<String, String> connectors = brokerView.getTransportConnectors();	
connectors 

assertEquals("one connector", 1, connectors.size());	ConnectorViewMBean connector = getProxyToConnectionView("tcp");	assertNotNull(connector);	String name = connectors.keySet().iterator().next().toString();	brokerView.removeConnector(name);	connectors = brokerView.getTransportConnectors();	assertEquals("empty", 0, connectors.size());	name = brokerView.addConnector("tcp: connector = getProxyToConnectionView("tcp");	assertNotNull(connector);	connectors = brokerView.getTransportConnectors();	
connectors 

========================= activemq sample_2311 =========================

public Broker installPlugin(Broker broker) throws Exception {	
installing javaruntimeconfiguration plugin 

========================= activemq sample_4400 =========================

final AtomicBoolean keepGoing = new AtomicBoolean(true);	Thread thread = new Thread("Filler") {	public void run() {	while (keepGoing.get()) {	try {	producer.send(session.createTextMessage("Test message"));	if (gotResourceException.get()) {	Thread.sleep(200);	}	} catch (Exception e) {	
caught excepted exception 

final Queue queueA = session.createQueue(name.getMethodName());	final MessageProducer producer = session.createProducer(queueA);	final AtomicBoolean keepGoing = new AtomicBoolean(true);	final AtomicInteger exceptionCount = new AtomicInteger(0);	Thread thread = new Thread("Filler") {	public void run() {	while (keepGoing.get()) {	try {	producer.send(session.createTextMessage("Test message"));	} catch (JMSException jmsEx) {	
client caught error 

protected Connection createConnection(boolean async, boolean exceptionListener) throws JMSException {	connection = super.createConnection();	JmsConnection jmsConnection = (JmsConnection) connection;	jmsConnection.setForceAsyncSend(async);	if (exceptionListener) {	connection.setExceptionListener(new ExceptionListener() {	public void onException(JMSException jmsEx) {	
client caught error 

========================= activemq sample_1602 =========================

protected void dumpMessages() throws Exception {	WireFormat wireFormat = new OpenWireFormat();	java.sql.Connection conn = ((JDBCPersistenceAdapter) broker.getPersistenceAdapter()).getDataSource().getConnection();	PreparedStatement statement = conn.prepareStatement("SELECT ID, MSG FROM ACTIVEMQ_MSGS");	ResultSet result = statement.executeQuery();	while(result.next()) {	long id = result.getLong(1);	Message message = (Message)wireFormat.unmarshal(new ByteSequence(result.getBytes(2)));	
id message seqid msg 

========================= activemq sample_3795 =========================

}	}	if (msg.isPersistent()) {	Destination dest = (Destination) msg.getRegionDestination();	TopicStorePrefetch tsp = topics.get(dest);	if (tsp != null) {	tsp.addMessageLast(node);	if (prioritizedMessages && immediatePriorityDispatch && tsp.isPaging()) {	if (msg.getPriority() > tsp.getLastRecoveredPriority()) {	tsp.recoverMessage(node.getMessage(), true);	
cached high priority message current paged batch priority cache size 

public synchronized boolean hasNext() {	boolean result = true;	if (result) {	try {	currentCursor = getNextCursor();	} catch (Exception e) {	
failed to get current cursor 

========================= activemq sample_4050 =========================

protected void startBroker() throws Exception {	broker = new BrokerService();	broker.setDeleteAllMessagesOnStartup(true);	broker.setPersistent(true);	broker.setUseJmx(false);	broker.setAdvisorySupport(false);	broker.setDataDirectory(dataDir.getRoot().getAbsolutePath());	adapter = (KahaDBPersistenceAdapter) broker.getPersistenceAdapter();	broker.start();	
starting broker 

========================= activemq sample_1747 =========================

public void run() {	long now = System.currentTimeMillis();	if ((now - startTime) >= connectAttemptTimeout && connectCheckerTask != null && !ASYNC_TASKS.isShutdown()) {	
no connection attempt made in time for throwing inactivityioexception 

long now = System.currentTimeMillis();	if ((now - startTime) >= connectAttemptTimeout && connectCheckerTask != null && !ASYNC_TASKS.isShutdown()) {	try {	ASYNC_TASKS.execute(new Runnable() {	public void run() {	onException(new InactivityIOException( "Channel was inactive (no connection attempt made) for too (>" + (connectAttemptTimeout) + ") long: " + next.getRemoteAddress()));	}	});	} catch (RejectedExecutionException ex) {	if (!ASYNC_TASKS.isShutdown()) {	
async connection timeout task was rejected from the executor 

public void run() {	long now = System.currentTimeMillis();	long elapsed = (now - lastRunTime);	if (lastRunTime != 0) {	
ms elapsed since last read check 

public void run() {	long now = System.currentTimeMillis();	long elapsed = (now - lastRunTime);	if (lastRunTime != 0) {	}	if (!allowReadCheck(elapsed)) {	
aborting read check not enough time elapsed since last read check 

public void run() {	long now = System.currentTimeMillis();	if (lastRunTime != 0) {	
ms elapsed since last write check 

public void run() {	
running 

public void run() {	
running 

public synchronized void startConnectCheckTask(long connectionTimeout) {	if (connectionTimeout <= 0) {	return;	}	
starting connection check task for 

public synchronized void stopConnectCheckTask() {	if (connectCheckerTask != null) {	
stopping connection check task for 

========================= activemq sample_50 =========================

connection.start();	final CountDownLatch done = new CountDownLatch(1);	final AtomicBoolean ok = new AtomicBoolean(true);	final AtomicBoolean first = new AtomicBoolean(true);	VMTransport t = ((ActiveMQConnection)connection).getTransport().narrow(VMTransport.class);	t.setTransportListener(new TransportListener() {	public void onCommand(Object command) {	if (first.compareAndSet(true, false)) {	try {	ok.set(done.await(35, TimeUnit.SECONDS));	
done waiting 

connections.add(connection);	((ActiveMQConnection)connection).setWatchTopicAdvisories(false);	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	for (int i=0; i<2500; i++) {	TemporaryQueue queue = session.createTemporaryQueue();	MessageConsumer consumer = session.createConsumer(queue);	consumer.close();	queue.delete();	}	
done with work 

========================= activemq sample_3003 =========================

public Destination[] createDestinations(int destCount) throws JMSException {	final String destName = getClient().getDestName();	ArrayList<Destination> destinations = new ArrayList<>();	if (destName.contains(DESTINATION_SEPARATOR)) {	if (getClient().isDestComposite() && (destCount == 1)) {	String[] simpleNames = mapToSimpleNames(destName.split(DESTINATION_SEPARATOR));	String joinedSimpleNames = join(simpleNames, DESTINATION_SEPARATOR);	byte destinationType = getDestinationType(destName);	destinations.add(createCompositeDestination(destinationType, joinedSimpleNames, 1));	} else {	
user requested multiple destinations splitting 

protected Destination createCompositeDestination(byte destinationType, String destName, int destCount) throws JMSException {	String simpleName = getSimpleName(destName);	String compDestName = "";	for (int i = 0; i < destCount; i++) {	if (i > 0) {	compDestName += ",";	}	compDestName += withDestinationSuffix(simpleName, i, destCount);	}	
creating composite destination 

protected Destination createDestination(String destName) throws JMSException {	String simpleName = getSimpleName(destName);	byte destinationType = getDestinationType(destName);	if (destinationType == ActiveMQDestination.QUEUE_TYPE) {	
creating queue 

protected Destination createDestination(String destName) throws JMSException {	String simpleName = getSimpleName(destName);	byte destinationType = getDestinationType(destName);	if (destinationType == ActiveMQDestination.QUEUE_TYPE) {	return getSession().createQueue(simpleName);	} else if (destinationType == ActiveMQDestination.TOPIC_TYPE) {	
creating topic 

protected Destination createTemporaryDestination(String destName) throws JMSException {	byte destinationType = getDestinationType(destName);	if (destinationType == ActiveMQDestination.TEMP_QUEUE_TYPE) {	
creating temporary queue requested name ignored 

protected Destination createTemporaryDestination(String destName) throws JMSException {	byte destinationType = getDestinationType(destName);	if (destinationType == ActiveMQDestination.TEMP_QUEUE_TYPE) {	TemporaryQueue temporaryQueue = getSession().createTemporaryQueue();	
temporary queue created 

protected Destination createTemporaryDestination(String destName) throws JMSException {	byte destinationType = getDestinationType(destName);	if (destinationType == ActiveMQDestination.TEMP_QUEUE_TYPE) {	TemporaryQueue temporaryQueue = getSession().createTemporaryQueue();	return temporaryQueue;	} else if (destinationType == ActiveMQDestination.TEMP_TOPIC_TYPE) {	
creating temporary topic requested name ignored 

protected Destination createTemporaryDestination(String destName) throws JMSException {	byte destinationType = getDestinationType(destName);	if (destinationType == ActiveMQDestination.TEMP_QUEUE_TYPE) {	TemporaryQueue temporaryQueue = getSession().createTemporaryQueue();	return temporaryQueue;	} else if (destinationType == ActiveMQDestination.TEMP_TOPIC_TYPE) {	TemporaryTopic temporaryTopic = getSession().createTemporaryTopic();	
temporary topic created 

public boolean commitTxIfNecessary() throws JMSException {	internalTxCounter++;	if (getClient().isSessTransacted()) {	if ((internalTxCounter % getClient().getCommitAfterXMsgs()) == 0) {	
committing transaction 

========================= activemq sample_1194 =========================

assertEquals("mapField.a", "foo", map.get("a"));	assertEquals("mapField.b", Integer.valueOf(23), map.get("b"));	assertEquals("mapField.c", Long.valueOf(45), map.get("c"));	value = map.get("d");	assertTrue("mapField.d should be a Map", value instanceof Map);	map = (Map)value;	assertEquals("mapField.d.x", "abc", map.get("x"));	value = map.get("y");	assertTrue("mapField.d.y is a List", value instanceof List);	List list = (List)value;	
mapfield d y 

assertEquals("mapField.b", Integer.valueOf(23), map.get("b"));	assertEquals("mapField.c", Long.valueOf(45), map.get("c"));	value = map.get("d");	assertTrue("mapField.d should be a Map", value instanceof Map);	map = (Map)value;	assertEquals("mapField.d.x", "abc", map.get("x"));	value = map.get("y");	assertTrue("mapField.d.y is a List", value instanceof List);	List list = (List)value;	assertEquals("listField.size", 3, list.size());	
found map 

assertEquals("mapField.c", Long.valueOf(45), map.get("c"));	value = map.get("d");	assertTrue("mapField.d should be a Map", value instanceof Map);	map = (Map)value;	assertEquals("mapField.d.x", "abc", map.get("x"));	value = map.get("y");	assertTrue("mapField.d.y is a List", value instanceof List);	List list = (List)value;	assertEquals("listField.size", 3, list.size());	list = (List)mapMessage.getObject("listField");	
listfield 

========================= activemq sample_2612 =========================

private boolean match(String s, Set<ObjectName> registeredMbeans) {	String encodedName = JMXSupport.encodeObjectNamePart(s);	for (ObjectName name : registeredMbeans) {	
checking for match with 

========================= activemq sample_2307 =========================

public void testDestiationSourceHasInitialDestinations() throws Exception {	Thread.sleep(1000);	DestinationSource destinationSource = connection.getDestinationSource();	Set<ActiveMQQueue> queues = destinationSource.getQueues();	Set<ActiveMQTopic> topics = destinationSource.getTopics();	
queues 

public void testDestiationSourceHasInitialDestinations() throws Exception {	Thread.sleep(1000);	DestinationSource destinationSource = connection.getDestinationSource();	Set<ActiveMQQueue> queues = destinationSource.getQueues();	Set<ActiveMQTopic> topics = destinationSource.getTopics();	
topics 

public void testConsumerForcesNotificationOfNewDestination() throws Exception {	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	ActiveMQQueue newQueue = new ActiveMQQueue("Test.Cheese");	session.createConsumer(newQueue);	Thread.sleep(3000);	assertThat(newQueue, isIn(newDestinations));	
new destinations are 

public void testProducerForcesNotificationOfNewDestination() throws Exception {	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	ActiveMQQueue newQueue = new ActiveMQQueue("Test.Beer");	MessageProducer producer = session.createProducer(newQueue);	TextMessage message = session.createTextMessage("<hello>world</hello>");	producer.send(message);	Thread.sleep(3000);	assertThat(newQueue, isIn(newDestinations));	
new destinations are 

public void onDestinationEvent(DestinationEvent event) {	ActiveMQDestination destination = event.getDestination();	if (event.isAddOperation()) {	
added 

public void onDestinationEvent(DestinationEvent event) {	ActiveMQDestination destination = event.getDestination();	if (event.isAddOperation()) {	newDestinations.add(destination);	}	else {	
removed 

========================= activemq sample_3516 =========================

public void testDurableSubWithNoLocalChange() throws Exception {	TopicConnection connection = factory.createTopicConnection();	connection.setClientID(getClientId());	connection.start();	TopicSession session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);	Topic topic = session.createTopic(getDestinationName());	TopicPublisher publisher = session.createPublisher(topic);	LOG.debug("Create DurableSubscriber with noLocal = true");	TopicSubscriber subscriber = session.createSubscriber(topic);	TopicSubscriber durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, true);	
sending messages to topic 

connection.start();	TopicSession session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);	Topic topic = session.createTopic(getDestinationName());	TopicPublisher publisher = session.createPublisher(topic);	LOG.debug("Create DurableSubscriber with noLocal = true");	TopicSubscriber subscriber = session.createSubscriber(topic);	TopicSubscriber durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, true);	for (int i = 0; i < MSG_COUNT; i++) {	publisher.publish(session.createMessage());	}	
attempting to receive messages from non durable subscriber 

TopicSubscriber subscriber = session.createSubscriber(topic);	TopicSubscriber durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, true);	for (int i = 0; i < MSG_COUNT; i++) {	publisher.publish(session.createMessage());	}	for (int i = 0; i < MSG_COUNT; i++) {	assertNotNull(subscriber.receive(500));	}	LOG.info("Attempting to receive messages from (noLocal=true) subscriber");	assertNull(durableSub.receive(500));	
sending messages to topic 

assertNull(durableSub.receive(500));	for (int i = 0; i < MSG_COUNT; i++) {	publisher.publish(session.createMessage());	}	LOG.debug("Close DurableSubscriber with noLocal=true");	durableSub.close();	LOG.debug("Create DurableSubscriber with noLocal=false");	durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, false);	LOG.info("Attempting to receive messages from reconnected (noLocal=false) subscription");	assertNull(durableSub.receive(500));	
sending messages to topic 

public void testInvertedDurableSubWithNoLocalChange() throws Exception {	TopicConnection connection = factory.createTopicConnection();	connection.setClientID(getClientId());	connection.start();	TopicSession session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);	Topic topic = session.createTopic(getDestinationName());	TopicPublisher publisher = session.createPublisher(topic);	LOG.debug("Create DurableSubscriber with noLocal = true");	TopicSubscriber subscriber = session.createSubscriber(topic);	TopicSubscriber durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, false);	
sending messages to topic 

connection.start();	TopicSession session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);	Topic topic = session.createTopic(getDestinationName());	TopicPublisher publisher = session.createPublisher(topic);	LOG.debug("Create DurableSubscriber with noLocal = true");	TopicSubscriber subscriber = session.createSubscriber(topic);	TopicSubscriber durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, false);	for (int i = 0; i < MSG_COUNT; i++) {	publisher.publish(session.createMessage());	}	
attempting to receive messages from non durable subscriber 

for (int i = 0; i < MSG_COUNT; i++) {	publisher.publish(session.createMessage());	}	for (int i = 0; i < MSG_COUNT; i++) {	assertNotNull(subscriber.receive(500));	}	LOG.info("Attempting to receive messages from (noLocal=false) durable subscriber");	for (int i = 0; i < MSG_COUNT; i++) {	assertNotNull(durableSub.receive(500));	}	
sending messages to topic 

}	for (int i = 0; i < MSG_COUNT; i++) {	publisher.publish(session.createMessage());	}	LOG.debug("Close DurableSubscriber with noLocal=true");	durableSub.close();	LOG.debug("Create DurableSubscriber with noLocal=false");	durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, true);	LOG.info("Attempting to receive messages from reconnected (noLocal=true) subscription");	assertNull(durableSub.receive(500));	
sending messages to topic 

public void testDurableSubWithNoLocalChangeAfterRestart() throws Exception {	TopicConnection connection = factory.createTopicConnection();	connection.setClientID(getClientId());	connection.start();	TopicSession session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);	Topic topic = session.createTopic(getDestinationName());	TopicPublisher publisher = session.createPublisher(topic);	LOG.debug("Create DurableSubscriber with noLocal = true");	TopicSubscriber subscriber = session.createSubscriber(topic);	TopicSubscriber durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, true);	
sending messages to topic 

connection.start();	TopicSession session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);	Topic topic = session.createTopic(getDestinationName());	TopicPublisher publisher = session.createPublisher(topic);	LOG.debug("Create DurableSubscriber with noLocal = true");	TopicSubscriber subscriber = session.createSubscriber(topic);	TopicSubscriber durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, true);	for (int i = 0; i < MSG_COUNT; i++) {	publisher.publish(session.createMessage());	}	
attempting to receive messages from non durable subscriber 

TopicSubscriber subscriber = session.createSubscriber(topic);	TopicSubscriber durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, true);	for (int i = 0; i < MSG_COUNT; i++) {	publisher.publish(session.createMessage());	}	for (int i = 0; i < MSG_COUNT; i++) {	assertNotNull(subscriber.receive(500));	}	LOG.info("Attempting to receive messages from (noLocal=true) subscriber");	assertNull(durableSub.receive(500));	
sending messages to topic 

connection = factory.createTopicConnection();	connection.setClientID(getClientId());	connection.start();	session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);	topic = session.createTopic(getDestinationName());	publisher = session.createPublisher(topic);	LOG.debug("Create DurableSubscriber with noLocal=false");	durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, false);	LOG.info("Attempting to receive messages from reconnected (noLocal=false) subscription");	assertNull(durableSub.receive(500));	
sending messages to topic 

public void testInvertedDurableSubWithNoLocalChangeAfterRestart() throws Exception {	TopicConnection connection = factory.createTopicConnection();	connection.setClientID(getClientId());	connection.start();	TopicSession session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);	Topic topic = session.createTopic(getDestinationName());	TopicPublisher publisher = session.createPublisher(topic);	LOG.debug("Create DurableSubscriber with noLocal = true");	TopicSubscriber subscriber = session.createSubscriber(topic);	TopicSubscriber durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, false);	
sending messages to topic 

connection.start();	TopicSession session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);	Topic topic = session.createTopic(getDestinationName());	TopicPublisher publisher = session.createPublisher(topic);	LOG.debug("Create DurableSubscriber with noLocal = true");	TopicSubscriber subscriber = session.createSubscriber(topic);	TopicSubscriber durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, false);	for (int i = 0; i < MSG_COUNT; i++) {	publisher.publish(session.createMessage());	}	
attempting to receive messages from non durable subscriber 

for (int i = 0; i < MSG_COUNT; i++) {	publisher.publish(session.createMessage());	}	for (int i = 0; i < MSG_COUNT; i++) {	assertNotNull(subscriber.receive(500));	}	LOG.info("Attempting to receive messages from (noLocal=false) durable subscriber");	for (int i = 0; i < MSG_COUNT; i++) {	assertNotNull(durableSub.receive(500));	}	
sending messages to topic 

connection = factory.createTopicConnection();	connection.setClientID(getClientId());	connection.start();	session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);	topic = session.createTopic(getDestinationName());	publisher = session.createPublisher(topic);	LOG.debug("Create DurableSubscriber with noLocal=true");	durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, true);	LOG.info("Attempting to receive messages from (noLocal=true) subscriber");	assertNull(durableSub.receive(500));	
sending messages to topic 

========================= activemq sample_3668 =========================

private int tryToFetchMissingMessages() throws JMSException {	Connection connection = cf.createConnection();	connection.start();	Session session = connection.createSession(true, 0);	MessageConsumer consumer = session.createConsumer(session .createQueue(QUEUE_NAME));	int count = 0;	while (true) {	Message message = consumer.receive(500);	if (message == null) break;	
found message 

bs.setPersistent(true);	bs.setUseJmx(true);	bs.addConnector(tcpUri);	bs.start();	restartDone = true;	}	assertEquals(i, message.getIntProperty(PROPERTY_MSG_NUMBER));	try {	session.commit();	} catch (TransactionRolledBackException expectedOnOccasion) {	
got rollback 

========================= activemq sample_2583 =========================

if (method.getName().equals(setterName)) {	method.invoke(this, value);	found = true;	break;	}	}	if (!found) {	throw new NoSuchMethodError("No setter found for field: " + attribute);	}	} catch(Throwable ex) {	
could not set field to value make sure the field exists and is public or has a setter 

========================= activemq sample_2995 =========================

public void preStart() throws Exception {	init();	if (useLock) {	if (getLocker() == null) {	
no locker configured 

protected void keepLockAlive() {	boolean stop = false;	try {	Locker locker = getLocker();	if (locker != null) {	if (!locker.keepAlive()) {	stop = true;	}	}	} catch (SuppressReplyException e) {	
locker keepalive resulted in 

boolean stop = false;	try {	Locker locker = getLocker();	if (locker != null) {	if (!locker.keepAlive()) {	stop = true;	}	}	} catch (SuppressReplyException e) {	} catch (IOException e) {	
locker keepalive resulted in 

protected void stopBroker() {	
no longer able to keep the exclusive lock so giving up being a master 

protected void stopBroker() {	try {	if( brokerService.isRestartAllowed() ) {	brokerService.requestRestart();	}	brokerService.stop();	} catch (Exception e) {	
failure occurred while stopping broker 

========================= activemq sample_3957 =========================

File derbyFile = new File(DERBY_ROOT + "testJDBCConfig recursiveDelete(derbyFile);	BrokerService broker;	broker = createBroker(new FileSystemResource(CONF_ROOT + "jdbc-example.xml"));	try {	assertEquals("Broker Config Error (brokerName)", "brokerJdbcConfigTest", broker.getBrokerName());	PersistenceAdapter adapter = broker.getPersistenceAdapter();	assertTrue("Should have created a jdbc persistence adapter", adapter instanceof JDBCPersistenceAdapter);	assertEquals("JDBC Adapter Config Error (cleanupPeriod)", 60000, ((JDBCPersistenceAdapter) adapter).getCleanupPeriod());	assertTrue("Should have created an EmbeddedDataSource", ((JDBCPersistenceAdapter) adapter).getDataSource() instanceof EmbeddedDataSource);	assertTrue("Should have created a DefaultWireFormat", ((JDBCPersistenceAdapter) adapter).getWireFormat() instanceof ObjectStreamWireFormat);	
Success 

========================= activemq sample_2645 =========================

public void testConnect() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "host:localhost\n" + "request-id:1\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

public void testConnectedNeverEncoded() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "host:localhost\n" + "request-id:1\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

public void testConnectedNeverEncoded() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "host:localhost\n" + "request-id:1\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	assertTrue(f.startsWith("CONNECTED"));	assertTrue(f.indexOf("response-id:1") >= 0);	assertTrue(f.indexOf("version:1.1") >= 0);	assertTrue(f.indexOf("session:") >= 0);	int sessionHeader = f.indexOf("session:");	f = f.substring(sessionHeader + "session:".length());	
session header follows 

public void testConnectWithVersionOptions() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.0,1.1\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

public void testConnectWithValidFallback() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.0,10.1\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

public void testConnectWithInvalidFallback() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:9.0,10.1\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

public void testHeartbeats() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "heart-beat:0,1000\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame().trim();	
broker sent 

public void testHeartbeatsDropsIdleConnection() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "heart-beat:1000,0\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	assertTrue(f.startsWith("CONNECTED"));	assertTrue(f.indexOf("version:1.1") >= 0);	assertTrue(f.indexOf("heart-beat:") >= 0);	assertTrue(f.indexOf("session:") >= 0);	
broker sent 

String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "heart-beat:1000,0\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	assertTrue(f.startsWith("CONNECTED"));	assertTrue(f.indexOf("version:1.1") >= 0);	assertTrue(f.indexOf("heart-beat:") >= 0);	assertTrue(f.indexOf("session:") >= 0);	long startTime = System.currentTimeMillis();	try {	f = stompConnection.receiveFrame();	
broker sent 

public void testHeartbeatsKeepsConnectionOpen() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "heart-beat:2000,0\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	assertTrue(f.startsWith("CONNECTED"));	assertTrue(f.indexOf("version:1.1") >= 0);	assertTrue(f.indexOf("heart-beat:") >= 0);	assertTrue(f.indexOf("session:") >= 0);	
broker sent 

assertTrue(f.startsWith("CONNECTED"));	assertTrue(f.indexOf("version:1.1") >= 0);	assertTrue(f.indexOf("heart-beat:") >= 0);	assertTrue(f.indexOf("session:") >= 0);	String message = "SEND\n" + "destination:/queue/" + getQueueName() + "\n\n" + "Hello World" + Stomp.NULL;	stompConnection.sendFrame(message);	ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();	service.scheduleAtFixedRate(new Runnable() {	public void run() {	try {	
sending next keepalive 

public void testSendAfterMissingHeartbeat() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "heart-beat:1000,0\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	assertTrue(f.startsWith("CONNECTED"));	assertTrue(f.indexOf("version:1.1") >= 0);	assertTrue(f.indexOf("heart-beat:") >= 0);	assertTrue(f.indexOf("session:") >= 0);	
broker sent 

public void testRejectInvalidHeartbeats1() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "heart-beat:0\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

public void testRejectInvalidHeartbeats2() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "heart-beat:T,0\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

public void testRejectInvalidHeartbeats3() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "heart-beat:100,10,50\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

public void testSubscribeAndUnsubscribe() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

stompConnection.sendFrame(frame);	StompFrame stompFrame = stompConnection.receive();	assertTrue(stompFrame.getAction().equals("MESSAGE"));	frame = "UNSUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "receipt:1\n" + "id:12345\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	stompFrame = stompConnection.receive();	assertTrue(stompFrame.getAction().equals("RECEIPT"));	stompConnection.sendFrame(message);	try {	frame = stompConnection.receiveFrame(2000);	
received frame 

public void testSubscribeWithNoId() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

public void testUnsubscribeWithNoId() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

public void testAckMessageWithId() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

public void testAckMessageWithNoId() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

public void testAckMessageWithNoId() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	assertTrue(f.startsWith("CONNECTED"));	String message = "SEND\n" + "destination:/queue/" + getQueueName() + "\n\n" + "Hello World" + Stomp.NULL;	stompConnection.sendFrame(message);	String subscribe = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "activemq.prefetchSize=1" + "\n" + "id:12345\n" + "ack:client\n\n" + Stomp.NULL;	stompConnection.sendFrame(subscribe);	StompFrame received = stompConnection.receive();	
received frame 

assertTrue(f.startsWith("CONNECTED"));	String message = "SEND\n" + "destination:/queue/" + getQueueName() + "\n\n" + "Hello World" + Stomp.NULL;	stompConnection.sendFrame(message);	String subscribe = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "activemq.prefetchSize=1" + "\n" + "id:12345\n" + "ack:client\n\n" + Stomp.NULL;	stompConnection.sendFrame(subscribe);	StompFrame received = stompConnection.receive();	assertTrue("Expected MESSAGE but got: " + received.getAction(), received.getAction().equals("MESSAGE"));	String ack = "ACK\n" + "message-id:" + received.getHeaders().get("message-id") + "\n\n" + Stomp.NULL;	stompConnection.sendFrame(ack);	StompFrame error = stompConnection.receive();	
received frame 

public void testSubscribeWithWildcardSubscription() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

public void testQueueBrowerSubscription() throws Exception {	final int MSG_COUNT = 10;	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

assertEquals("0", repsonse.getHeaders().get(Stomp.Headers.Response.RECEIPT_ID));	}	String subscribe = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "id:12345\n" + "browser:true\n\n" + Stomp.NULL;	stompConnection.sendFrame(subscribe);	for(int i = 0; i < MSG_COUNT; ++i) {	StompFrame message = stompConnection.receive();	assertEquals(Stomp.Responses.MESSAGE, message.getAction());	assertEquals("12345", message.getHeaders().get(Stomp.Headers.Message.SUBSCRIPTION));	}	StompFrame browseDone = stompConnection.receive();	
browse done 

public void testNackMessage() throws Exception {	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

public void testHeaderValuesAreNotWSTrimmed() throws Exception {	stompConnection.setVersion(Stomp.V1_1);	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "host:localhost\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String f = stompConnection.receiveFrame();	
broker sent 

public void testDurableSubAndUnSubOnTwoTopics() throws Exception {	stompConnection.setVersion(Stomp.V1_1);	String domain = "org.apache.activemq";	ObjectName brokerName = new ObjectName(domain + ":type=Broker,brokerName=localhost");	BrokerViewMBean view = (BrokerViewMBean)brokerService.getManagementContext().newProxyInstance(brokerName, BrokerViewMBean.class, true);	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "host:localhost\n" + "client-id:test\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String frame = stompConnection.receiveFrame();	
broker sent 

ObjectName brokerName = new ObjectName(domain + ":type=Broker,brokerName=localhost");	BrokerViewMBean view = (BrokerViewMBean)brokerService.getManagementContext().newProxyInstance(brokerName, BrokerViewMBean.class, true);	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "host:localhost\n" + "client-id:test\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	assertEquals(view.getDurableTopicSubscribers().length, 0);	frame = "SUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "1" + "\n" + "ack:auto\n" + "receipt:1\n" + "id:durablesub-1\n" + "activemq.subscriptionName:test1\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	StompFrame receipt = stompConnection.receive();	
broker sent 

assertEquals(view.getDurableTopicSubscribers().length, 0);	frame = "SUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "1" + "\n" + "ack:auto\n" + "receipt:1\n" + "id:durablesub-1\n" + "activemq.subscriptionName:test1\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	StompFrame receipt = stompConnection.receive();	assertTrue(receipt.getAction().startsWith("RECEIPT"));	assertEquals("1", receipt.getHeaders().get("receipt-id"));	assertEquals(view.getDurableTopicSubscribers().length, 1);	frame = "SUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "2" + "\n" + "ack:auto\n" + "receipt:2\n" + "id:durablesub-2\n" + "activemq.subscriptionName:test2\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	receipt = stompConnection.receive();	
broker sent 

frame = "DISCONNECT\nclient-id:test\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return getProxyToBroker().getCurrentConnectionsCount() == 0;	}	}, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(25));	stompConnect();	stompConnection.sendFrame(connectFrame);	frame = stompConnection.receiveFrame();	
broker sent 

}, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(25));	stompConnect();	stompConnection.sendFrame(connectFrame);	frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	assertEquals(view.getDurableTopicSubscribers().length, 0);	assertEquals(view.getInactiveDurableTopicSubscribers().length, 2);	frame = "UNSUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "1\n" + "id:durablesub-1\n" + "receipt:3\n" + "activemq.subscriptionName:test1\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	receipt = stompConnection.receive();	
broker sent 

assertEquals(view.getInactiveDurableTopicSubscribers().length, 2);	frame = "UNSUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "1\n" + "id:durablesub-1\n" + "receipt:3\n" + "activemq.subscriptionName:test1\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	receipt = stompConnection.receive();	assertTrue(receipt.getAction().startsWith("RECEIPT"));	assertEquals("3", receipt.getHeaders().get("receipt-id"));	assertEquals(view.getInactiveDurableTopicSubscribers().length, 1);	frame = "UNSUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "2\n" + "id:durablesub-2\n" + "receipt:4\n" + "activemq.subscriptionName:test2\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	receipt = stompConnection.receive();	
broker sent 

public void testDurableSubAndUnSubFlow() throws Exception {	stompConnection.setVersion(Stomp.V1_1);	String domain = "org.apache.activemq";	ObjectName brokerName = new ObjectName(domain + ":type=Broker,brokerName=localhost");	BrokerViewMBean view = (BrokerViewMBean)brokerService.getManagementContext().newProxyInstance(brokerName, BrokerViewMBean.class, true);	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "host:localhost\n" + "client-id:test\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String frame = stompConnection.receiveFrame();	
broker sent 

ObjectName brokerName = new ObjectName(domain + ":type=Broker,brokerName=localhost");	BrokerViewMBean view = (BrokerViewMBean)brokerService.getManagementContext().newProxyInstance(brokerName, BrokerViewMBean.class, true);	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "host:localhost\n" + "client-id:test\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	assertEquals(view.getDurableTopicSubscribers().length, 0);	frame = "SUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "1" + "\n" + "ack:auto\n" + "receipt:1\n" + "id:durablesub-1\n" + "activemq.subscriptionName:test1\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	StompFrame receipt = stompConnection.receive();	
broker sent 

assertEquals(view.getDurableTopicSubscribers().length, 0);	frame = "SUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "1" + "\n" + "ack:auto\n" + "receipt:1\n" + "id:durablesub-1\n" + "activemq.subscriptionName:test1\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	StompFrame receipt = stompConnection.receive();	assertTrue(receipt.getAction().startsWith("RECEIPT"));	assertEquals("1", receipt.getHeaders().get("receipt-id"));	assertEquals(view.getDurableTopicSubscribers().length, 1);	frame = "UNSUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "1\n" + "id:durablesub-1\n" + "receipt:3\n" + "activemq.subscriptionName:test1\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	receipt = stompConnection.receive();	
broker sent 

frame = "UNSUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "1\n" + "id:durablesub-1\n" + "receipt:3\n" + "activemq.subscriptionName:test1\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	receipt = stompConnection.receive();	assertTrue(receipt.getAction().startsWith("ERROR"));	assertEquals("3", receipt.getHeaders().get("receipt-id"));	assertEquals(view.getInactiveDurableTopicSubscribers().length, 0);	assertEquals(view.getDurableTopicSubscribers().length, 1);	frame = "UNSUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "1\n" + "id:durablesub-1\n" + "receipt:4\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	receipt = stompConnection.receive();	
broker sent 

frame = "UNSUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "1\n" + "id:durablesub-1\n" + "receipt:4\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	receipt = stompConnection.receive();	assertTrue(receipt.getAction().startsWith("RECEIPT"));	assertEquals("4", receipt.getHeaders().get("receipt-id"));	assertEquals(view.getInactiveDurableTopicSubscribers().length, 1);	assertEquals(view.getDurableTopicSubscribers().length, 0);	frame = "UNSUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "1\n" + "id:durablesub-1\n" + "receipt:5\n" + "activemq.subscriptionName:test1\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	receipt = stompConnection.receive();	
broker sent 

public void testMultipleDurableSubsWithOfflineMessages() throws Exception {	stompConnection.setVersion(Stomp.V1_1);	final BrokerViewMBean view = getProxyToBroker();	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "host:localhost\n" + "client-id:test\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String frame = stompConnection.receiveFrame();	
broker sent 

stompConnection.setVersion(Stomp.V1_1);	final BrokerViewMBean view = getProxyToBroker();	String connectFrame = "STOMP\n" + "login:system\n" + "passcode:manager\n" + "accept-version:1.1\n" + "host:localhost\n" + "client-id:test\n" + "\n" + Stomp.NULL;	stompConnection.sendFrame(connectFrame);	String frame = stompConnection.receiveFrame();	assertTrue(frame.startsWith("CONNECTED"));	assertEquals(view.getDurableTopicSubscribers().length, 0);	frame = "SUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "1" + "\n" + "ack:auto\n" + "receipt:1\n" + "id:durablesub-1\n" + "activemq.subscriptionName:test1\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	StompFrame receipt = stompConnection.receive();	
broker sent 

assertEquals(view.getDurableTopicSubscribers().length, 0);	frame = "SUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "1" + "\n" + "ack:auto\n" + "receipt:1\n" + "id:durablesub-1\n" + "activemq.subscriptionName:test1\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	StompFrame receipt = stompConnection.receive();	assertTrue(receipt.getAction().startsWith("RECEIPT"));	assertEquals("1", receipt.getHeaders().get("receipt-id"));	assertEquals(view.getDurableTopicSubscribers().length, 1);	frame = "SUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "2" + "\n" + "ack:auto\n" + "receipt:2\n" + "id:durablesub-2\n" + "activemq.subscriptionName:test2\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	receipt = stompConnection.receive();	
broker sent 

frame = "DISCONNECT\nclient-id:test\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	assertTrue(Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return view.getCurrentConnectionsCount() == 1;	}	}, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(25)));	stompConnect();	stompConnection.sendFrame(connectFrame);	frame = stompConnection.receiveFrame();	
broker sent 

stompConnection.sendFrame(frame);	receipt = stompConnection.receive();	assertEquals("10", receipt.getHeaders().get(Stomp.Headers.Response.RECEIPT_ID));	frame = "SEND\n" + "destination:/topic/" + getQueueName() + "2\n" + "receipt:11\n" + "\n" + "Hello World 2" + Stomp.NULL;	stompConnection.sendFrame(frame);	receipt = stompConnection.receive();	assertEquals("11", receipt.getHeaders().get(Stomp.Headers.Response.RECEIPT_ID));	frame = "SUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "1" + "\n" + "ack:auto\n" + "receipt:3\n" + "id:durablesub-1\n" + "activemq.subscriptionName:test1\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	receipt = stompConnection.receive();	
broker sent 

assertEquals("3", receipt.getHeaders().get("receipt-id"));	assertEquals(view.getDurableTopicSubscribers().length, 1);	StompFrame message = stompConnection.receive();	assertEquals(Stomp.Responses.MESSAGE, message.getAction());	assertEquals("durablesub-1", message.getHeaders().get(Stomp.Headers.Message.SUBSCRIPTION));	assertEquals(view.getDurableTopicSubscribers().length, 1);	assertEquals(view.getInactiveDurableTopicSubscribers().length, 1);	frame = "SUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "2" + "\n" + "ack:auto\n" + "receipt:4\n" + "id:durablesub-2\n" + "activemq.subscriptionName:test2\n\n" + Stomp.NULL;	stompConnection.sendFrame(frame);	receipt = stompConnection.receive();	
broker sent 

========================= activemq sample_1439 =========================

exceptions.add(e);	}	}	});	}	executorService.shutdown();	executorService.awaitTermination(30, TimeUnit.MINUTES);	assertTrue("Producers done in time", executorService.isTerminated());	assertTrue("No exceptions: " + exceptions, exceptions.isEmpty());	double duration = System.currentTimeMillis() - start;	
duration ms 

exceptions.add(e);	}	}	});	}	executorService.shutdown();	executorService.awaitTermination(30, TimeUnit.MINUTES);	assertTrue("Producers done in time", executorService.isTerminated());	assertTrue("No exceptions: " + exceptions, exceptions.isEmpty());	double duration = System.currentTimeMillis() - start;	
rate m s 

private void consumeMessages(AtomicLong count) throws Exception {	JmsConnection connection = (JmsConnection) factory.createConnection();	connection.start();	Session session = connection.createSession(false, ActiveMQSession.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue(getDestinationName());	MessageConsumer consumer = session.createConsumer(queue);	long v;	while ((v = count.decrementAndGet()) > 0) {	if ((count.get() % 10000) == 0) {	
received message 

connection.start();	Session session = connection.createSession(false, ActiveMQSession.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue(getDestinationName());	MessageConsumer consumer = session.createConsumer(queue);	long v;	while ((v = count.decrementAndGet()) > 0) {	if ((count.get() % 10000) == 0) {	}	assertNotNull("got message " + v, consumer.receive(15000));	}	
received message 

connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue(getDestinationName());	MessageProducer producer = session.createProducer(queue);	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);	while (count.getAndDecrement() > 0) {	BytesMessage message = session.createBytesMessage();	message.writeBytes(payload);	producer.send(message);	if ((count.get() % 10000) == 0) {	
sent message 

========================= activemq sample_1593 =========================

private void testPurgeLargeQueue(boolean prioritizedMessages) throws Exception {	applyBrokerSpoolingPolicy(prioritizedMessages);	createProducerAndSendMessages(NUM_TO_SEND);	QueueViewMBean proxy = getProxyToQueueViewMBean();	
purging 

applyBrokerSpoolingPolicy(prioritizedMessages);	createProducerAndSendMessages(NUM_TO_SEND);	QueueViewMBean proxy = getProxyToQueueViewMBean();	org.apache.log4j.Logger log4jLogger = org.apache.log4j.Logger.getLogger(org.apache.activemq.broker.jmx.QueueView.class);	final AtomicBoolean gotPurgeLogMessage = new AtomicBoolean(false);	Appender appender = new DefaultTestAppender() {	public void doAppend(LoggingEvent event) {	if (event.getMessage() instanceof String) {	String message = (String) event.getMessage();	if (message.contains("purge of " + NUM_TO_SEND +" messages")) {	
received a log message 

public void testRepeatedExpiryProcessingOfLargeQueue() throws Exception {	applyBrokerSpoolingPolicy(false);	final int expiryPeriod = 500;	applyExpiryDuration(expiryPeriod);	createProducerAndSendMessages(NUM_TO_SEND);	QueueViewMBean proxy = getProxyToQueueViewMBean();	
waiting for expiry to kick in a bunch of times to verify it does not blow mem 

private void testConcurrentPurgeAndSend(boolean prioritizedMessages) throws Exception {	applyBrokerSpoolingPolicy(false);	createProducerAndSendMessages(NUM_TO_SEND / 2);	final QueueViewMBean proxy = getProxyToQueueViewMBean();	createConsumer();	final long start = System.currentTimeMillis();	ExecutorService service = Executors.newFixedThreadPool(1);	try {	
purging 

final long start = System.currentTimeMillis();	ExecutorService service = Executors.newFixedThreadPool(1);	try {	service.submit(new Runnable() {	public void run() {	try {	proxy.purge();	} catch (Exception e) {	fail(e.getMessage());	}	
purge done ms 

private void testPurgeLargeQueueWithConsumer(boolean prioritizedMessages) throws Exception {	applyBrokerSpoolingPolicy(prioritizedMessages);	createProducerAndSendMessages(NUM_TO_SEND);	QueueViewMBean proxy = getProxyToQueueViewMBean();	createConsumer();	long start = System.currentTimeMillis();	
purging 

private void testPurgeLargeQueueWithConsumer(boolean prioritizedMessages) throws Exception {	applyBrokerSpoolingPolicy(prioritizedMessages);	createProducerAndSendMessages(NUM_TO_SEND);	QueueViewMBean proxy = getProxyToQueueViewMBean();	createConsumer();	long start = System.currentTimeMillis();	proxy.purge();	
purge done ms 

private void createProducerAndSendMessages(int numToSend) throws Exception {	session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);	queue = session.createQueue("test1");	MessageProducer producer = session.createProducer(queue);	for (int i = 0; i < numToSend; i++) {	TextMessage message = session.createTextMessage(MESSAGE_TEXT + i);	if (i  != 0 && i % 10000 == 0) {	
sent 

========================= activemq sample_2350 =========================

try {	broker = createBroker(withJMX);	broker.start();	broker.waitUntilStarted();	dataSource.stopDB();	TimeUnit.SECONDS.sleep(3);	checkTransportConnectorStopped();	dataSource.restartDB();	Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	
checking connector to start 

try {	checkTransportConnectorStarted();	return true;	} catch (Throwable t) {	LOG.debug(t.toString());	}	return false;	}	});	} finally {	
broker is stopping 

private void checkTransportConnectorStopped() {	try {	factory.createConnection();	fail("Transport connector should be stopped");	} catch (Exception ex) {	
checktransportconnectorstopped threw 

private void checkTransportConnectorStarted() {	try {	Connection conn = factory.createConnection();	conn.close();	} catch (Exception ex) {	
checktransportconnectorstarted threw 

public void restartDB() throws Exception {	EmbeddedDataSource newDatasource = (EmbeddedDataSource) DataSourceServiceSupport.createDataSource(broker.getDataDirectoryFile().getCanonicalPath());	newDatasource.getConnection();	
db restarted now 

public void stopDB() {	
db is being shutdown 

========================= activemq sample_3812 =========================

public void testNegativeTotalMessageCount() throws Exception {	
running test testnegativetotalmessagecount 

public void testNegativeTotalMessageCount() throws Exception {	sendMessage();	restartBroker();	receiveMessage();	long totalMessageCount = getTotalMessageCount();	if (totalMessageCount < 0 ) {	
unexpected negative totalmessagecount 

public void testNegativeTotalMessageCount() throws Exception {	sendMessage();	restartBroker();	receiveMessage();	long totalMessageCount = getTotalMessageCount();	if (totalMessageCount < 0 ) {	} else {	
totalmessagecount 

public void testNegativeTotalMessageCount() throws Exception {	sendMessage();	restartBroker();	receiveMessage();	long totalMessageCount = getTotalMessageCount();	if (totalMessageCount < 0 ) {	} else {	}	assertTrue("Non negative TotalMessageCount " + totalMessageCount, totalMessageCount > -1);	
test testnegativetotalmessagecount completed 

private void sendMessage() throws JMSException {	Connection conn = connectionFactory.createConnection();	try {	conn.start();	Session session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination queue = session.createQueue(TESTQUEUE);	TextMessage msg = session.createTextMessage("This is a message.");	MessageProducer producer = session.createProducer(queue);	producer.send(queue, msg);	
message sent to 

private Message receiveMessage() throws JMSException {	Connection conn = connectionFactory.createConnection();	Message msg = null;	try {	conn.start();	Session session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination queue = session.createQueue(TESTQUEUE);	MessageConsumer consumer = session.createConsumer(queue);	msg = consumer.receive(TimeUnit.SECONDS.toMillis(10));	if (msg != null) {	
message received from 

private boolean startBroker(boolean deleteMessagesOnStartup) throws Exception {	brokerService = new BrokerService();	brokerService.setPersistent(true);	brokerService.setDeleteAllMessagesOnStartup(deleteMessagesOnStartup);	brokerService.setUseJmx(true);	connectionUri = brokerService.addConnector(BROKER_ADDRESS).getPublishableConnectString();	brokerService.start();	connectionFactory = new ActiveMQConnectionFactory(connectionUri);	
broker started 

private long getTotalMessageCount() throws Exception {	ObjectName brokerViewMBeanName = new ObjectName("org.apache.activemq:type=Broker,brokerName=localhost");	BrokerViewMBean brokerMBean = (BrokerViewMBean) brokerService.getManagementContext().newProxyInstance(brokerViewMBeanName, BrokerViewMBean.class, true);	
broker totalmessagecount 

========================= activemq sample_2700 =========================

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue(destinationName);	sendMessages(messagesToSend);	QueueBrowser browser = session.createBrowser(queue);	Enumeration enumeration = browser.getEnumeration();	int received = 0;	while (enumeration.hasMoreElements()) {	Message m = (Message) enumeration.nextElement();	assertNotNull(m);	if (LOG.isDebugEnabled()) {	
browsed message 

========================= activemq sample_2777 =========================

public static Option configure(String... features) {	MavenUrlReference karafUrl = maven().groupId("org.apache.karaf").artifactId("apache-karaf") .type("tar.gz").versionAsInProject();	UrlReference camelUrl = maven().groupId("org.apache.camel.karaf") .artifactId("apache-camel").type("xml").classifier("features").versionAsInProject();	UrlReference activeMQUrl = maven().groupId("org.apache.activemq"). artifactId("activemq-karaf").versionAsInProject().type("xml").classifier("features").versionAsInProject();	
apache karaf target paxexam unpack etc config properties karaf startlevel bundle 50 

========================= activemq sample_4359 =========================

ActiveMQPrefetchPolicy policy = new ActiveMQPrefetchPolicy();	policy.setQueuePrefetch(100);	consumerFactory.setPrefetchPolicy(policy);	producerFactory = createConnectionFactory(producerBindAddress);	Connection con = consumerFactory.createConnection();	Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);	producers = new PerfProducer[numberofProducers*numberOfDestinations];	consumers = new PerfConsumer[numberOfConsumers*numberOfDestinations];	for (int k =0; k < numberOfDestinations;k++) {	Destination destination = createDestination(session, destinationName+":"+k);	
testing against destination 

========================= activemq sample_3536 =========================

Thread.sleep(1000);	consumeSession2 = connection2.createSession(false, Session.AUTO_ACKNOWLEDGE);	consumerDestination2 = session2.createTopic(getConsumerSubject() + "2");	consumer2 = consumeSession2.createDurableSubscriber((Topic)consumerDestination2, getName());	Thread.sleep(1000);	consumer2.close();	TextMessage message = session2.createTextMessage("test");	message.setStringProperty("test", "test");	message.setJMSType("test");	producer2.send(producerDestination2, message);	
creating durable consumer 

========================= activemq sample_3473 =========================

exceptions.add(e);	}	}	});	}	executorService.shutdown();	executorService.awaitTermination(30, TimeUnit.MINUTES);	assertTrue("Producers done in time", executorService.isTerminated());	assertTrue("No exceptions: " + exceptions, exceptions.isEmpty());	restartBroker(500);	
attempting consume of messages 

========================= activemq sample_2798 =========================

public void load() throws IOException {	if (opened.compareAndSet(false, true)) {	getJournal().start();	try {	loadPageFile();	} catch (UnknownStoreVersionException ex) {	
can t start until store update is performed 

public void load() throws IOException {	if (opened.compareAndSet(false, true)) {	getJournal().start();	try {	loadPageFile();	} catch (UnknownStoreVersionException ex) {	upgradeFromLegacy();	getJournal().start();	loadPageFile();	
update from legacy scheduler store completed successfully 

public void load() throws IOException {	if (opened.compareAndSet(false, true)) {	getJournal().start();	try {	loadPageFile();	} catch (UnknownStoreVersionException ex) {	upgradeFromLegacy();	getJournal().start();	loadPageFile();	} catch (Throwable t) {	
index corrupted recovering the index through journal replay cause 

public void load() throws IOException {	if (opened.compareAndSet(false, true)) {	getJournal().start();	try {	loadPageFile();	} catch (UnknownStoreVersionException ex) {	upgradeFromLegacy();	getJournal().start();	loadPageFile();	} catch (Throwable t) {	
index load failure 

} else {	pageFile.delete();	}	metaData = new JobSchedulerKahaDBMetaData(this);	pageFile = null;	loadPageFile();	}	startCheckpoint();	recover();	}	
started 

if (pageFile != null) {	pageFile.unload();	pageFile = null;	}	if (this.journal != null) {	journal.close();	journal = null;	}	metaData = new JobSchedulerKahaDBMetaData(this);	}	
stopped 

page = tx.load(0, metaDataMarshaller);	metaData = page.get();	metaData.setPage(page);	}	metaData.load(tx);	metaData.loadScheduler(tx, schedulers);	for (JobSchedulerImpl js : schedulers.values()) {	try {	js.start();	} catch (Exception e) {	
failed to load 

private void upgradeFromLegacy() throws IOException {	journal.close();	journal = null;	try {	pageFile.unload();	pageFile = null;	} catch (Exception ignore) {}	File storeDir = getDirectory().getAbsoluteFile();	File storeArchiveDir = getLegacyStoreArchiveDirectory();	
attempting to move old store files from to 

protected void checkpointUpdate(Transaction tx, boolean cleanup) throws IOException {	
job scheduler store checkpoint started 

protected void checkpointUpdate(Transaction tx, boolean cleanup) throws IOException {	Location lastUpdate = metaData.getLastUpdateLocation();	metaData.setState(KahaDBMetaData.OPEN_STATE);	tx.store(metaData.getPage(), metaDataMarshaller, true);	pageFile.flush();	if (cleanup) {	final TreeSet<Integer> completeFileSet = new TreeSet<Integer>(journal.getFileMap().keySet());	final TreeSet<Integer> gcCandidateSet = new TreeSet<Integer>(completeFileSet);	
last update full gc candidates set 

if (cleanup) {	final TreeSet<Integer> completeFileSet = new TreeSet<Integer>(journal.getFileMap().keySet());	final TreeSet<Integer> gcCandidateSet = new TreeSet<Integer>(completeFileSet);	if (lastUpdate != null) {	gcCandidateSet.remove(lastUpdate.getDataFileId());	}	this.metaData.getJournalRC().visit(tx, new BTreeVisitor<Integer, Integer>() {	public void visit(List<Integer> keys, List<Integer> values) {	for (Integer key : keys) {	if (gcCandidateSet.remove(key)) {	
removed referenced file from gc set 

public void visit(List<Integer> keys, List<Integer> values) {	for (Integer key : keys) {	if (gcCandidateSet.remove(key)) {	}	}	}	public boolean isInterestedInKeysBetween(Integer first, Integer second) {	return true;	}	});	
gc candidates after reference check 

});	if (!gcCandidateSet.isEmpty()) {	Iterator<Entry<Integer, List<Integer>>> removals = metaData.getRemoveLocationTracker().iterator(tx);	List<Integer> orphans = new ArrayList<Integer>();	while (removals.hasNext()) {	boolean orphanedRemove = true;	Entry<Integer, List<Integer>> entry = removals.next();	if (gcCandidateSet.contains(entry.getKey())) {	for (Integer addLocation : entry.getValue()) {	if (completeFileSet.contains(addLocation)) {	
a remove in log has an add still in existance in 

if (gcCandidateSet.contains(entry.getKey())) {	for (Integer addLocation : entry.getValue()) {	if (completeFileSet.contains(addLocation)) {	orphanedRemove = false;	break;	}	}	if (!orphanedRemove) {	gcCandidateSet.remove(entry.getKey());	} else {	
all removes in log are orphaned file can be gc d 

gcCandidateSet.remove(entry.getKey());	} else {	orphans.add(entry.getKey());	}	}	}	for (Integer orphan : orphans) {	metaData.getRemoveLocationTracker().remove(tx, orphan);	}	}	
gc candidates after removals check 

orphans.add(entry.getKey());	}	}	}	for (Integer orphan : orphans) {	metaData.getRemoveLocationTracker().remove(tx, orphan);	}	}	if (!gcCandidateSet.isEmpty()) {	if (LOG.isDebugEnabled()) {	
cleanup removing the data files 

for (Integer orphan : orphans) {	metaData.getRemoveLocationTracker().remove(tx, orphan);	}	}	if (!gcCandidateSet.isEmpty()) {	if (LOG.isDebugEnabled()) {	}	journal.removeDataFiles(gcCandidateSet);	}	}	
job scheduler store checkpoint complete 

});	processLocation(location);	} finally {	indexLock.writeLock().unlock();	}	}	public void visit(final KahaDestroySchedulerCommand command) {	try {	removeJobScheduler(command.getScheduler());	} catch (Exception e) {	
failed to remove scheduler 

private void recover() throws IllegalStateException, IOException {	this.indexLock.writeLock().lock();	try {	long start = System.currentTimeMillis();	Location lastIndoubtPosition = getRecoveryPosition();	Location recoveryPosition = lastIndoubtPosition;	if (recoveryPosition != null) {	int redoCounter = 0;	
recovering from the scheduled job journal 

if (recoveryPosition != null) {	int redoCounter = 0;	while (recoveryPosition != null) {	try {	JournalCommand<?> message = load(recoveryPosition);	metaData.setLastUpdateLocation(recoveryPosition);	doRecover(message, recoveryPosition, lastIndoubtPosition);	redoCounter++;	} catch (IOException failedRecovery) {	if (isIgnoreMissingJournalfiles()) {	
failed to recover data at position 

redoCounter++;	} catch (IOException failedRecovery) {	if (isIgnoreMissingJournalfiles()) {	journal.corruptRecoveryLocation(recoveryPosition);	} else {	throw new IOException("Failed to recover data at position:" + recoveryPosition, failedRecovery);	}	}	recoveryPosition = journal.getNextLocation(recoveryPosition);	if (LOG.isInfoEnabled() && redoCounter % 100000 == 0) {	
entries recovered 

journal.corruptRecoveryLocation(recoveryPosition);	} else {	throw new IOException("Failed to recover data at position:" + recoveryPosition, failedRecovery);	}	}	recoveryPosition = journal.getNextLocation(recoveryPosition);	if (LOG.isInfoEnabled() && redoCounter % 100000 == 0) {	}	}	long end = System.currentTimeMillis();	
recovery replayed operations from the journal in seconds 

long start = System.currentTimeMillis();	final Location lastAppendLocation = journal.getLastAppendLocation();	long undoCounter = 0;	for (Iterator<Map.Entry<String, JobSchedulerImpl>> i = metaData.getJobSchedulers().iterator(tx); i.hasNext();) {	Map.Entry<String, JobSchedulerImpl> entry = i.next();	JobSchedulerImpl scheduler = entry.getValue();	List<JobLocation> jobs = scheduler.getAllScheduledJobs(tx);	for (JobLocation job : jobs) {	if (job.getLocation().compareTo(lastAppendLocation) >= 0) {	if (scheduler.removeJobAtTime(tx, job.getJobId(), job.getNextTime())) {	
removed job past last appened in the journal 

for (JobLocation job : jobs) {	if (job.getLocation().compareTo(lastAppendLocation) >= 0) {	if (scheduler.removeJobAtTime(tx, job.getJobId(), job.getNextTime())) {	undoCounter++;	}	}	}	}	if (undoCounter > 0) {	long end = System.currentTimeMillis();	
rolled back messages from the index in seconds 

List<JobLocation> jobs = scheduler.getAllScheduledJobs(tx);	for (JobLocation job : jobs) {	missingJournalFiles.add(job.getLocation().getDataFileId());	if (job.getLastUpdate() != null) {	missingJournalFiles.add(job.getLastUpdate().getDataFileId());	}	}	}	missingJournalFiles.removeAll(journal.getFileMap().keySet());	if (!missingJournalFiles.isEmpty()) {	
some journal files are missing 

HashSet<Location> corruptedLocations = new HashSet<Location>();	if (isCheckForCorruptJournalFiles()) {	Collection<DataFile> dataFiles = journal.getFileMap().values();	for (DataFile dataFile : dataFiles) {	int id = dataFile.getDataFileId();	for (long offset : dataFile.getCorruptedBlocks()) {	corruptedLocations.add(new Location(id, (int) offset));	}	}	if (!corruptedLocations.isEmpty()) {	
found some corrupted data blocks in the journal 

}	if (!missingJournalFiles.isEmpty() || !corruptedLocations.isEmpty()) {	if (!isIgnoreMissingJournalfiles()) {	throw new IOException("Detected missing/corrupt journal files.");	}	undoCounter = removeJobsInMissingOrCorruptJounralFiles(tx, missingJournalFiles, corruptedLocations);	removeJournalRCForMissingFiles(tx, missingJournalFiles);	}	if (undoCounter > 0) {	long end = System.currentTimeMillis();	
detected missing corrupt journal files dropped jobs from the index in seconds 

========================= activemq sample_1767 =========================

protected void configureBroker(BrokerService broker) throws Exception {	broker.setDestinationPolicy(policyMap);	broker.setDeleteAllMessagesOnStartup(true);	broker.setUseJmx(false);	connectionUri = broker.addConnector("tcp: broker.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	public int prepareTransaction(ConnectionContext context, TransactionId xid) throws Exception {	getNext().prepareTransaction(context, xid);	
brokerplugin preparetransaction will throw an exception 

broker.setDestinationPolicy(policyMap);	broker.setDeleteAllMessagesOnStartup(true);	broker.setUseJmx(false);	connectionUri = broker.addConnector("tcp: broker.setPlugins(new BrokerPlugin[]{	new BrokerPluginSupport() {	public int prepareTransaction(ConnectionContext context, TransactionId xid) throws Exception {	getNext().prepareTransaction(context, xid);	throw new XAException(simulatedExceptionMessage);	}	public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {	
brokerplugin committransaction 

xaConnection.start();	XASession session = xaConnection.createXASession();	XAResource resource = session.getXAResource();	Xid tid = createXid();	resource.start(tid, XAResource.TMNOFLAGS);	MessageProducer producer = session.createProducer(session.createQueue(this.getClass().getName()));	Message message = session.createTextMessage("Sample Message");	producer.send(message);	resource.end(tid, XAResource.TMSUCCESS);	try {	
calling xa prepare expecting an exception 

Xid tid = createXid();	resource.start(tid, XAResource.TMNOFLAGS);	MessageProducer producer = session.createProducer(session.createQueue(this.getClass().getName()));	Message message = session.createTextMessage("Sample Message");	producer.send(message);	resource.end(tid, XAResource.TMSUCCESS);	try {	int ret = resource.prepare(tid);	if (XAResource.XA_OK == ret) resource.commit(tid, false);	} catch (XAException xae) {	
received excpected xaexception 

Xid tid = createXid();	resource.start(tid, XAResource.TMNOFLAGS);	MessageProducer producer = session.createProducer(session.createQueue(this.getClass().getName()));	Message message = session.createTextMessage("Sample Message");	producer.send(message);	resource.end(tid, XAResource.TMSUCCESS);	try {	int ret = resource.prepare(tid);	if (XAResource.XA_OK == ret) resource.commit(tid, false);	} catch (XAException xae) {	
rolling back transaction 

} catch (XAException xae) {	assertEquals(simulatedExceptionMessage, xae.getMessage());	resource.rollback(tid);	}	assertTransactionGoneFromBroker(tid);	assertTransactionGoneFromConnection(broker.getBrokerName(), xaConnection.getClientID(), xaConnection.getConnectionInfo().getConnectionId(), tid);	assertTransactionGoneFromFailoverState(xaConnection, tid);	producer.close();	session.close();	xaConnection.close();	
testxapreparefailure finished 

========================= activemq sample_2848 =========================

public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {	if (messageId != null) {	QueueViewMBean queueView = getQueueView();	if (queueView != null) {	
copy to 

public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {	if (messageId != null) {	QueueViewMBean queueView = getQueueView();	if (queueView != null) {	queueView.copyMessageTo(messageId, destination);	} else {	
no queue named 

========================= activemq sample_1337 =========================

byte[] data = new byte[remaining];	readBuffer.get(data);	DataInputStream dataIn = new DataInputStream(new ByteArrayInputStream(data));	answer = (Command)wireFormat.unmarshal(dataIn);	break;	}	}	if (answer != null) {	answer.setFrom(from);	if (LOG.isDebugEnabled()) {	
channel received from about to process 

protected void sendWriteBuffer(int commandId, SocketAddress address, ByteBuffer writeBuffer, boolean redelivery) throws IOException {	ReplayBuffer bufferCache = getReplayBuffer();	if (bufferCache != null && !redelivery) {	bufferCache.addBuffer(commandId, writeBuffer);	}	writeBuffer.flip();	if (LOG.isDebugEnabled()) {	String text = redelivery ? "REDELIVERING" : "sending";	
channel datagram to 

public void sendBuffer(int commandId, Object buffer) throws IOException {	if (buffer != null) {	ByteBuffer writeBuffer = (ByteBuffer)buffer;	sendWriteBuffer(commandId, getReplayAddress(), writeBuffer, true);	} else {	if (LOG.isWarnEnabled()) {	
request for buffer is no longer present 

========================= activemq sample_70 =========================

protected void setUp() throws Exception {	sendFactory = createSenderConnectionFactory();	receiveFactory = createReceiverConnectionFactory();	
waiting for brokers initialize 

protected void setUp() throws Exception {	sendFactory = createSenderConnectionFactory();	receiveFactory = createReceiverConnectionFactory();	Thread.sleep(5000);	
brokers should be initialized by now starting test 

========================= activemq sample_3561 =========================

public void testSendThenFailoverThenSend() throws Exception {	ProducerTemplate requester = senderContext.createProducerTemplate();	
sending request 

public void testSendThenFailoverThenSend() throws Exception {	ProducerTemplate requester = senderContext.createProducerTemplate();	String response = (String) requester.requestBody(fromEndpoint, "This is a request");	assertNotNull(response != null);	
got response 

public void testSendThenFailoverThenSend() throws Exception {	ProducerTemplate requester = senderContext.createProducerTemplate();	String response = (String) requester.requestBody(fromEndpoint, "This is a request");	assertNotNull(response != null);	TimeUnit.SECONDS.sleep(20);	
restarting broker a now 

public void testSendThenFailoverThenSend() throws Exception {	ProducerTemplate requester = senderContext.createProducerTemplate();	String response = (String) requester.requestBody(fromEndpoint, "This is a request");	assertNotNull(response != null);	TimeUnit.SECONDS.sleep(20);	shutdownBrokerA();	createBrokerA();	
sending request 

public void testSendThenFailoverThenSend() throws Exception {	ProducerTemplate requester = senderContext.createProducerTemplate();	String response = (String) requester.requestBody(fromEndpoint, "This is a request");	assertNotNull(response != null);	TimeUnit.SECONDS.sleep(20);	shutdownBrokerA();	createBrokerA();	response = (String) requester.requestBody(fromEndpoint, "This is a request");	assertNotNull(response != null);	
got response 

========================= activemq sample_1360 =========================

public void preallocationLatency() throws Exception {	TimeStatisticImpl sparse = executeTest(Journal.PreallocationStrategy.SPARSE_FILE.name());	TimeStatisticImpl chunked_zeros = executeTest(Journal.PreallocationStrategy.CHUNKED_ZEROS.name());	TimeStatisticImpl kernel = executeTest(Journal.PreallocationStrategy.OS_KERNEL_COPY.name());	
sparse 

public void preallocationLatency() throws Exception {	TimeStatisticImpl sparse = executeTest(Journal.PreallocationStrategy.SPARSE_FILE.name());	TimeStatisticImpl chunked_zeros = executeTest(Journal.PreallocationStrategy.CHUNKED_ZEROS.name());	TimeStatisticImpl kernel = executeTest(Journal.PreallocationStrategy.OS_KERNEL_COPY.name());	
chunked 

public void preallocationLatency() throws Exception {	TimeStatisticImpl sparse = executeTest(Journal.PreallocationStrategy.SPARSE_FILE.name());	TimeStatisticImpl chunked_zeros = executeTest(Journal.PreallocationStrategy.CHUNKED_ZEROS.name());	TimeStatisticImpl kernel = executeTest(Journal.PreallocationStrategy.OS_KERNEL_COPY.name());	
kernel 

}	}));	final Journal journal = store.getJournal();	ByteSequence byteSequence = new ByteSequence(new byte[16*1024]);	TimeStatisticImpl timeStatistic = new TimeStatisticImpl("append", "duration");	for (int i=0;i<5000; i++) {	final long start = System.currentTimeMillis();	journal.write(byteSequence, true);	timeStatistic.addTime(System.currentTimeMillis() - start);	}	
current journal datafile id 

========================= activemq sample_1730 =========================

FilteredKahaDBPersistenceAdapter filteredAdapter = (FilteredKahaDBPersistenceAdapter) matchingPersistenceAdapter;	if (filteredAdapter.getUsage() != null && filteredAdapter.getPersistenceAdapter() instanceof KahaDBPersistenceAdapter) {	StoreUsage storeUsage = filteredAdapter.getUsage();	storeUsage.setStore(filteredAdapter.getPersistenceAdapter());	storeUsage.setParent(multiKahaDBPersistenceAdapter.getBrokerService().getSystemUsage().getStoreUsage());	((BaseDestination) indexListener).getSystemUsage().setStoreUsage(storeUsage);	}	}	}	} catch (Exception ignored) {	
failed to set mkahadb destination store usage 

private void txStoreCleanup() {	Set<Integer> knownDataFileIds = new TreeSet<Integer>(journal.getFileMap().keySet());	for (Tx tx : inflightTransactions.values()) {	knownDataFileIds.remove(tx.getPreparedLocationId());	}	try {	journal.removeDataFiles(knownDataFileIds);	} catch (Exception e) {	
failed to remove tx journal datafiles 

private void recoverPendingLocalTransactions() throws IOException {	Location location = journal.getNextLocation(null);	while (location != null) {	process(load(location));	location = journal.getNextLocation(location);	}	recoveredPendingCommit.addAll(inflightTransactions.keySet());	
pending local transactions 

public synchronized void recover(final TransactionRecoveryListener listener) throws IOException {	for (final PersistenceAdapter adapter : multiKahaDBPersistenceAdapter.adapters) {	adapter.createTransactionStore().recover(new TransactionRecoveryListener() {	public void recover(XATransactionId xid, Message[] addedMessages, MessageAck[] acks) {	try {	getTx(xid).trackStore(adapter.createTransactionStore());	} catch (IOException e) {	
failed to access transaction store for prepared xa tid 

listener.recover(xid, addedMessages, acks);	}	});	}	try {	Broker broker = multiKahaDBPersistenceAdapter.getBrokerService().getBroker();	for (TransactionId txid : broker.getPreparedTransactions(null)) {	if (multiKahaDBPersistenceAdapter.isLocalXid(txid)) {	try {	if (recoveredPendingCommit.contains(txid)) {	
delivering pending commit outcome for tid 

});	}	try {	Broker broker = multiKahaDBPersistenceAdapter.getBrokerService().getBroker();	for (TransactionId txid : broker.getPreparedTransactions(null)) {	if (multiKahaDBPersistenceAdapter.isLocalXid(txid)) {	try {	if (recoveredPendingCommit.contains(txid)) {	broker.commitTransaction(null, txid, false);	} else {	
delivering rollback outcome to store for tid 

for (TransactionId txid : broker.getPreparedTransactions(null)) {	if (multiKahaDBPersistenceAdapter.isLocalXid(txid)) {	try {	if (recoveredPendingCommit.contains(txid)) {	broker.commitTransaction(null, txid, false);	} else {	broker.forgetTransaction(null, txid);	}	persistCompletion(txid);	} catch (Exception ex) {	
failed to deliver pending outcome for tid 

broker.commitTransaction(null, txid, false);	} else {	broker.forgetTransaction(null, txid);	}	persistCompletion(txid);	} catch (Exception ex) {	}	}	}	} catch (Exception e) {	
failed to resolve pending local transactions 

========================= activemq sample_1819 =========================

public void setUp() throws Exception {	
starting up 

public void setUp() throws Exception {	String path = null;	URL resource = JaasDualAuthenticationNetworkBridgeTest.class.getClassLoader().getResource("login-JaasDualAuthenticationNetworkBridge.config");	if (resource != null) {	path = resource.getFile();	System.setProperty("java.security.auth.login.config", path);	}	
path to login config 

if (resource != null) {	path = resource.getFile();	System.setProperty("java.security.auth.login.config", path);	}	try {	ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(CONFIG_FILE);	broker1 = (BrokerService)context.getBean("broker1");	broker2 = (BrokerService)context.getBean("broker2");	}	catch(Exception e) {	
error 

public void tearDown() throws Exception {	
shutting down 

public void tearDown() throws Exception {	if (broker1 != null && broker1.isStarted()) {	
broker still running stopping it now 

public void tearDown() throws Exception {	if (broker1 != null && broker1.isStarted()) {	broker1.stop();	}	else {	
not running nothing to shutdown 

public void tearDown() throws Exception {	if (broker1 != null && broker1.isStarted()) {	broker1.stop();	}	else {	}	if (broker2 != null && broker2.isStarted()) {	
broker still running stopping it now 

public void tearDown() throws Exception {	if (broker1 != null && broker1.isStarted()) {	broker1.stop();	}	else {	}	if (broker2 != null && broker2.isStarted()) {	broker2.stop();	}	else {	
not running nothing to shutdown 

public void testNetworkBridgeUsingJaasDualAuthenticationPlugin() throws Exception {	
testnetworkbridgeusingjaasdualauthenticationplugin called 

List<NetworkConnector> ncs = broker1.getNetworkConnectors();	Assert.assertNotNull("Network Connector not found.", ncs);	Assert.assertFalse("Network Connector not found.", ncs.isEmpty());	NetworkConnector nc =(NetworkConnector)ncs.get(0);	Collection<NetworkBridge> bridges = nc.activeBridges();	Assert.assertFalse("Network bridge not established to broker 2", bridges.isEmpty());	Assert.assertTrue("Network bridge not established to broker 2", bridges.size() == 1);	for (NetworkBridge nb : bridges) {	Assert.assertTrue(nb.getRemoteBrokerId() != null);	}	
network bridge is correctly established 

========================= activemq sample_2673 =========================

public void testVirtualTopicRouting() throws Exception {	if (connection == null) {	connection = createConnection();	}	connection.start();	
validate no other messages on queues 

if (connection == null) {	connection = createConnection();	}	connection.start();	try {	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	ActiveMQDestination destination1 = getConsumer1Destination();	ActiveMQDestination destination2 = getConsumer2Destination();	MessageConsumer c1 = session.createConsumer(destination1, null);	MessageConsumer c2 = session.createConsumer(destination2, null);	
send one simple message that should go to both consumers 

========================= activemq sample_2389 =========================

private void doStartBroker(boolean delete) throws Exception {	doCreateBroker(delete);	
starting broker 

public void checkPermission(Permission perm, Object context) {}	public void checkWrite(String file) {	if (file.contains(DEFAULT_ARCHIVE_DIRECTORY) && atomicInteger.incrementAndGet() > 4) {	throw new SecurityException("No Perms to write to archive times:" + atomicInteger.get());	}	}	});	startBroker();	int sent = produceMessagesToConsumeMultipleDataFiles(50);	int numFilesAfterSend = getNumberOfJournalFiles();	
num journal files 

}	});	int received = tryConsume(destination, sent);	assertEquals("all message received", sent, received);	assertTrue("broker got shutdown on page in error", gotShutdown.await(10, TimeUnit.SECONDS));	System.setSecurityManager(null);	int numFilesAfterRestart = 0;	try {	doStartBroker(false);	numFilesAfterRestart = getNumberOfJournalFiles();	
num journal files before gc 

int received = tryConsume(destination, sent);	assertEquals("all message received", sent, received);	assertTrue("broker got shutdown on page in error", gotShutdown.await(10, TimeUnit.SECONDS));	System.setSecurityManager(null);	int numFilesAfterRestart = 0;	try {	doStartBroker(false);	numFilesAfterRestart = getNumberOfJournalFiles();	((KahaDBPersistenceAdapter) broker.getPersistenceAdapter()).getStore().checkpoint(true);	} catch (Exception error) {	
failed to restart 

System.setSecurityManager(null);	int numFilesAfterRestart = 0;	try {	doStartBroker(false);	numFilesAfterRestart = getNumberOfJournalFiles();	((KahaDBPersistenceAdapter) broker.getPersistenceAdapter()).getStore().checkpoint(true);	} catch (Exception error) {	fail("Failed to restart after failure to archive");	}	int numFilesAfterGC = getNumberOfJournalFiles();	
num journal files after restart nd gc 

========================= activemq sample_1726 =========================

public Broker installPlugin(Broker broker) throws Exception {	CamelRoutesBroker answer = new CamelRoutesBroker(broker);	answer.setCheckPeriod(getCheckPeriod());	answer.setRoutesFile(getRoutesFile());	
installing camelroutesbroker 

========================= activemq sample_1376 =========================

public static void result() {	synchronized(trackers) {	for (Entry<String, Tracker> t: trackers.entrySet()) {	
tracker entry points 

public static void result() {	synchronized(trackers) {	for (Entry<String, Tracker> t: trackers.entrySet()) {	for (Trace trace : t.getValue().values()) {	
count 

public static void result() {	synchronized(trackers) {	for (Entry<String, Tracker> t: trackers.entrySet()) {	for (Trace trace : t.getValue().values()) {	}	
tracker done 

========================= activemq sample_4174 =========================

public void addSubscription(ConnectionContext context, Subscription sub) throws Exception {	if (!context.isFaultTolerant() && (!context.isNetworkConnection() && !tempDest .getConnectionId().equals( sub.getConsumerInfo().getConsumerId() .getConnectionId()))) {	tempDest.setConnectionId(sub.getConsumerInfo().getConsumerId().getConnectionId());	
changed ownership of to 

public void dispose(ConnectionContext context) throws IOException {	if (this.destinationStatistics.getMessages().getCount() > 0) {	
on dispose purge of pending messages 

public void dispose(ConnectionContext context) throws IOException {	if (this.destinationStatistics.getMessages().getCount() > 0) {	}	try {	purge();	} catch (Exception e) {	
caught an exception purging queue 

========================= activemq sample_4031 =========================

public void testLotsOfClients() throws Exception {	final int CLIENTS = Integer.getInteger("PahoMQTTTest.CLIENTS", 100);	
using clients 

asyncError.set(e);	} finally {	disconnectDoneLatch.countDown();	}	}	}.start();	}	connectedDoneLatch.await();	assertNull("Async error: " + asyncError.get(), asyncError.get());	sendBarrier.countDown();	
all clients connected waiting to receive sent messages 

}.start();	}	connectedDoneLatch.await();	assertNull("Async error: " + asyncError.get(), asyncError.get());	sendBarrier.countDown();	within(30, TimeUnit.SECONDS, new Task() {	public void run() throws Exception {	assertTrue(receiveCounter.get() == CLIENTS * 10);	}	});	
all messages received 

public void testCleanSession() throws Exception {	String topic = "test";	final DefaultListener listener = new DefaultListener();	
connecting durable subscriber 

public void testCleanSession() throws Exception {	String topic = "test";	final DefaultListener listener = new DefaultListener();	MqttClient client = createClient(false, "receive", listener);	
subscribing durable subscriber 

public void testCleanSession() throws Exception {	String topic = "test";	final DefaultListener listener = new DefaultListener();	MqttClient client = createClient(false, "receive", listener);	client.subscribe(topic, 1);	assertTrue(client.getPendingDeliveryTokens().length == 0);	disconnect(client);	
disconnected durable subscriber 

public void testCleanSession() throws Exception {	String topic = "test";	final DefaultListener listener = new DefaultListener();	MqttClient client = createClient(false, "receive", listener);	client.subscribe(topic, 1);	assertTrue(client.getPendingDeliveryTokens().length == 0);	disconnect(client);	MqttClient client2 = createClient(true, "publish", listener);	
publish message with qos 

String topic = "test";	final DefaultListener listener = new DefaultListener();	MqttClient client = createClient(false, "receive", listener);	client.subscribe(topic, 1);	assertTrue(client.getPendingDeliveryTokens().length == 0);	disconnect(client);	MqttClient client2 = createClient(true, "publish", listener);	String expectedResult = "QOS 1 message";	client2.publish(topic, expectedResult.getBytes(StandardCharsets.UTF_8), 1, false);	waitForDelivery(client2);	
publish message with qos 

client.subscribe(topic, 1);	assertTrue(client.getPendingDeliveryTokens().length == 0);	disconnect(client);	MqttClient client2 = createClient(true, "publish", listener);	String expectedResult = "QOS 1 message";	client2.publish(topic, expectedResult.getBytes(StandardCharsets.UTF_8), 1, false);	waitForDelivery(client2);	expectedResult = "QOS 0 message";	client2.publish(topic, expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);	waitForDelivery(client2);	
reconnecting durable subscriber 

assertTrue(client.getPendingDeliveryTokens().length == 0);	disconnect(client);	MqttClient client2 = createClient(true, "publish", listener);	String expectedResult = "QOS 1 message";	client2.publish(topic, expectedResult.getBytes(StandardCharsets.UTF_8), 1, false);	waitForDelivery(client2);	expectedResult = "QOS 0 message";	client2.publish(topic, expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);	waitForDelivery(client2);	MqttClient client3 = createClient(false, "receive", listener);	
subscribing durable subscriber 

waitForDelivery(client2);	MqttClient client3 = createClient(false, "receive", listener);	client3.subscribe(topic, 1);	assertTrue(Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return listener.received.get() == 2;	}	}, TimeUnit.SECONDS.toMillis(15), TimeUnit.MILLISECONDS.toMillis(100)));	assertEquals(2, listener.received.get());	disconnect(client3);	
disconnected durable subscriber 

MqttClient client3 = createClient(false, "receive", listener);	client3.subscribe(topic, 1);	assertTrue(Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return listener.received.get() == 2;	}	}, TimeUnit.SECONDS.toMillis(15), TimeUnit.MILLISECONDS.toMillis(100)));	assertEquals(2, listener.received.get());	disconnect(client3);	assertTrue(listener.received.compareAndSet(2, 0));	
reconnecting durable subscriber 

client3.subscribe(topic, 1);	assertTrue(Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return listener.received.get() == 2;	}	}, TimeUnit.SECONDS.toMillis(15), TimeUnit.MILLISECONDS.toMillis(100)));	assertEquals(2, listener.received.get());	disconnect(client3);	assertTrue(listener.received.compareAndSet(2, 0));	MqttClient client4 = createClient(false, "receive", listener);	
subscribing durable subscriber 

protected void testClientIdSpecialChars(int mqttVersion) throws Exception {	
test mqtt version 

public void messageArrived(String topic, MqttMessage message) throws Exception {	
received 

========================= activemq sample_883 =========================

public void acknowledge(ConnectionContext context, String clientId, String subscriptionName, MessageId messageId, MessageAck ack) throws IOException {	if (ack != null && ack.isUnmatchedAck()) {	if (LOG.isTraceEnabled()) {	
ignoring unmatched selector ack for cleanup will get to this message after subsequent acks 

}	TransactionContext c = persistenceAdapter.getTransactionContext(context);	try {	long[] res = getCachedStoreSequenceId(c, destination, messageId);	if (this.isPrioritizedMessages()) {	adapter.doSetLastAckWithPriority(c, destination, context != null ? context.getXid() : null, clientId, subscriptionName, res[0], res[1]);	} else {	adapter.doSetLastAck(c, destination, context != null ? context.getXid() : null, clientId, subscriptionName, res[0], res[1]);	}	if (LOG.isTraceEnabled()) {	
ack seq priority mid 

public synchronized void recoverNextMessages(final String clientId, final String subscriptionName, final int maxReturned, final MessageRecoveryListener listener) throws Exception {	TransactionContext c = persistenceAdapter.getTransactionContext();	String key = getSubscriptionKey(clientId, subscriptionName);	if (!subscriberLastRecoveredMap.containsKey(key)) {	subscriberLastRecoveredMap.put(key, new LastRecovered());	}	final LastRecovered lastRecovered = subscriberLastRecoveredMap.get(key);	LastRecoveredAwareListener recoveredAwareListener = new LastRecoveredAwareListener(listener, maxReturned);	try {	if (LOG.isTraceEnabled()) {	
existing last recovered 

entry.exhausted();	}	}	}	} else {	LastRecoveredEntry last = lastRecovered.defaultPriority();	recoveredAwareListener.setLastRecovered(last);	adapter.doRecoverNextMessages(c, destination, clientId, subscriptionName, last.recovered, 0, maxReturned, recoveredAwareListener);	}	if (LOG.isTraceEnabled()) {	
last recovered 

public void resetBatching(String clientId, String subscriptionName) {	String key = getSubscriptionKey(clientId, subscriptionName);	if (!pendingCompletion.contains(key))  {	subscriberLastRecoveredMap.remove(key);	} else {	
skip resetbatch during pending completion for 

public void pendingCompletion(String clientId, String subscriptionName, long sequenceId, byte priority) {	final String key = getSubscriptionKey(clientId, subscriptionName);	LastRecovered recovered = new LastRecovered();	recovered.perPriority[isPrioritizedMessages() ? priority : javax.jms.Message.DEFAULT_PRIORITY].recovered = sequenceId;	subscriberLastRecoveredMap.put(key, recovered);	pendingCompletion.add(key);	
pending completion last 

public void complete(String clientId, String subscriptionName) {	pendingCompletion.remove(getSubscriptionKey(clientId, subscriptionName));	
completion for 

TransactionContext c = persistenceAdapter.getTransactionContext();	try {	result = adapter.doGetDurableSubscriberMessageCount(c, destination, clientId, subscriberName, isPrioritizedMessages());	} catch (SQLException e) {	JDBCPersistenceAdapter.log("JDBC Failure: ", e);	throw IOExceptionSupport.create("Failed to get Message Count: " + clientId + ". Reason: " + e, e);	} finally {	c.close();	}	if (LOG.isTraceEnabled()) {	
messagecount 

========================= activemq sample_929 =========================

private Class<?> load(String className, ClassLoader... cl) throws ClassNotFoundException {	final Class<?> clazz = loadSimpleType(className);	if (clazz != null) {	
loaded class as simple type 

private Class<?> load(String className, ClassLoader... cl) throws ClassNotFoundException {	final Class<?> clazz = loadSimpleType(className);	if (clazz != null) {	return clazz;	}	for (ClassLoader loader : cl) {	
attempting to load class using classloader 

private Class<?> load(String className, ClassLoader... cl) throws ClassNotFoundException {	final Class<?> clazz = loadSimpleType(className);	if (clazz != null) {	return clazz;	}	for (ClassLoader loader : cl) {	try {	Class<?> answer = Class.forName(className, false, loader);	if (LOG.isTraceEnabled()) {	
loaded class using classloader 

if (clazz != null) {	return clazz;	}	for (ClassLoader loader : cl) {	try {	Class<?> answer = Class.forName(className, false, loader);	if (LOG.isTraceEnabled()) {	}	return answer;	} catch (ClassNotFoundException e) {	
class not found using classloader 

========================= activemq sample_180 =========================

public void execute(ActiveMQDestination destination, MessageListener listener) throws Exception {	
initial query is creating messages 

========================= activemq sample_2624 =========================

receiveCounter++;	DataInputStream dataIn = new DataInputStream(new ByteArrayInputStream(datagram.getData(), 0, datagram.getLength()));	from = headerMarshaller.createEndpoint(datagram, dataIn);	answer = (Command)wireFormat.unmarshal(dataIn);	break;	}	}	if (answer != null) {	answer.setFrom(from);	if (LOG.isDebugEnabled()) {	
channel about to process 

protected void sendWriteBuffer(int commandId, SocketAddress address, byte[] data, boolean redelivery) throws IOException {	ReplayBuffer bufferCache = getReplayBuffer();	if (bufferCache != null && !redelivery) {	bufferCache.addBuffer(commandId, data);	}	if (LOG.isDebugEnabled()) {	String text = redelivery ? "REDELIVERING" : "sending";	
channel datagram to 

public void sendBuffer(int commandId, Object buffer) throws IOException {	if (buffer != null) {	byte[] data = (byte[])buffer;	sendWriteBuffer(commandId, replayAddress, data, true);	} else {	if (LOG.isWarnEnabled()) {	
request for buffer is no longer present 

========================= activemq sample_66 =========================

SlaveLevelDBStore slave1 = createSlave(master, directories.get(1));	SlaveLevelDBStore slave2 = createSlave(master, directories.get(2));	asyncStart(slave2);	masterStart.await();	if (j == 0) {	stores.add(master);	stores.add(slave1);	stores.add(slave2);	}	MessageStore ms = master.createQueueMessageStore(new ActiveMQQueue("TEST"));	
checking 

SlaveLevelDBStore slave2 = createSlave(master, directories.get(2));	asyncStart(slave2);	masterStart.await();	if (j == 0) {	stores.add(master);	stores.add(slave1);	stores.add(slave2);	}	MessageStore ms = master.createQueueMessageStore(new ActiveMQQueue("TEST"));	assertEquals(expected_list, getMessages(ms));	
adding messages 

if (j == 0) {	stores.add(master);	stores.add(slave1);	stores.add(slave2);	}	MessageStore ms = master.createQueueMessageStore(new ActiveMQQueue("TEST"));	assertEquals(expected_list, getMessages(ms));	final int TOTAL = 500;	for (int i = 0; i < TOTAL; i++) {	if (i % ((int) (TOTAL * 0.10)) == 0) {	
done 

}	MessageStore ms = master.createQueueMessageStore(new ActiveMQQueue("TEST"));	assertEquals(expected_list, getMessages(ms));	final int TOTAL = 500;	for (int i = 0; i < TOTAL; i++) {	if (i % ((int) (TOTAL * 0.10)) == 0) {	}	if (i == 250) {	slave1.start();	slave2.stop();	
checking 

}	if (i == 250) {	slave1.start();	slave2.stop();	assertEquals(expected_list, getMessages(ms));	}	String msgid = "m:" + j + ":" + i;	addMessage(ms, msgid, playload);	expected_list.add(msgid);	}	
checking 

if (i == 250) {	slave1.start();	slave2.stop();	assertEquals(expected_list, getMessages(ms));	}	String msgid = "m:" + j + ":" + i;	addMessage(ms, msgid, playload);	expected_list.add(msgid);	}	assertEquals(expected_list, getMessages(ms));	
stopping master 

slave2.stop();	assertEquals(expected_list, getMessages(ms));	}	String msgid = "m:" + j + ":" + i;	addMessage(ms, msgid, playload);	expected_list.add(msgid);	}	assertEquals(expected_list, getMessages(ms));	master.stop();	Thread.sleep(3*1000);	
stopping slave 

return transport;	}	};	stores.add(node2);	configureSlave(node2, node1, node2Dir);	SlaveLevelDBStore node3 = createSlave(node1, node3Dir);	stores.add(node3);	asyncStart(node2);	asyncStart(node3);	masterStart.await();	
adding messages 

MessageStore ms = node1.createQueueMessageStore(new ActiveMQQueue("TEST"));	final int TOTAL = 10;	for (int i = 0; i < TOTAL; i++) {	if (i == 8) {	node3.stop();	}	String msgid = "m:" + ":" + i;	addMessage(ms, msgid, playload);	expected_list.add(msgid);	}	
checking state 

final int TOTAL = 10;	for (int i = 0; i < TOTAL; i++) {	if (i == 8) {	node3.stop();	}	String msgid = "m:" + ":" + i;	addMessage(ms, msgid, playload);	expected_list.add(msgid);	}	assertEquals(expected_list, getMessages(ms));	
stopping 

for (int i = 0; i < TOTAL; i++) {	if (i == 8) {	node3.stop();	}	String msgid = "m:" + ":" + i;	addMessage(ms, msgid, playload);	expected_list.add(msgid);	}	assertEquals(expected_list, getMessages(ms));	node1.stop();	
stopping slave 

========================= activemq sample_1264 =========================

StringBuilder sb = new StringBuilder();	for (char ch : hostName.toCharArray()) {	if (ch < 127) {	sb.append(ch);	} else {	changed = true;	}	}	if (changed) {	String newHost = sb.toString();	
sanitized hostname from to 

========================= activemq sample_1634 =========================

public void onMessage(Message msg) {	try {	
consumed message count 

for (int i = 0; i < NUM_MESSAGE_TO_SEND; i++) {	jmsTemplate.send(queueName, new MessageCreator() {	public Message createMessage(Session session) throws JMSException {	final BytesMessage message = session.createBytesMessage();	message.writeBytes(bytes);	message.setIntProperty("count", count.incrementAndGet());	message.setStringProperty("producer", "pooled");	return message;	}	});	
pooledproducer sent message 

public Message createMessage(Session session) throws JMSException {	final BytesMessage message = session.createBytesMessage();	message.writeBytes(bytes);	message.setIntProperty("count", count.incrementAndGet());	message.setStringProperty("producer", "pooled");	return message;	}	});	}	} catch (final Throwable e) {	
producer is exiting 

for (int i = 0; i < NUM_MESSAGE_TO_SEND; i++) {	jmsTemplate.send(queueName, new MessageCreator() {	public Message createMessage(Session session) throws JMSException {	final BytesMessage message = session.createBytesMessage();	message.writeBytes(bytes);	message.setIntProperty("count", count.incrementAndGet());	message.setStringProperty("producer", "non-pooled");	return message;	}	});	
non pooledproducer sent message 

public Message createMessage(Session session) throws JMSException {	final BytesMessage message = session.createBytesMessage();	message.writeBytes(bytes);	message.setIntProperty("count", count.incrementAndGet());	message.setStringProperty("producer", "non-pooled");	return message;	}	});	}	} catch (final Throwable e) {	
producer is exiting 

========================= activemq sample_753 =========================

}	String filter = roleSearchMatchingFormat.format(new String[] {	doRFC2254Encoding(dn), doRFC2254Encoding(username) });	SearchControls constraints = new SearchControls();	if (roleSearchSubtreeBool) {	constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);	} else {	constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);	}	if (log.isDebugEnabled()) {	
get user roles 

}	String filter = roleSearchMatchingFormat.format(new String[] {	doRFC2254Encoding(dn), doRFC2254Encoding(username) });	SearchControls constraints = new SearchControls();	if (roleSearchSubtreeBool) {	constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);	} else {	constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);	}	if (log.isDebugEnabled()) {	
looking for the user roles in ldap with 

}	String filter = roleSearchMatchingFormat.format(new String[] {	doRFC2254Encoding(dn), doRFC2254Encoding(username) });	SearchControls constraints = new SearchControls();	if (roleSearchSubtreeBool) {	constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);	} else {	constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);	}	if (log.isDebugEnabled()) {	
base dn 

}	String filter = roleSearchMatchingFormat.format(new String[] {	doRFC2254Encoding(dn), doRFC2254Encoding(username) });	SearchControls constraints = new SearchControls();	if (roleSearchSubtreeBool) {	constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);	} else {	constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);	}	if (log.isDebugEnabled()) {	
filter 

protected boolean bindUser(DirContext context, String dn, String password) throws NamingException {	boolean isValid = false;	if (log.isDebugEnabled()) {	
binding the user 

protected boolean bindUser(DirContext context, String dn, String password) throws NamingException {	boolean isValid = false;	if (log.isDebugEnabled()) {	}	context.addToEnvironment(Context.SECURITY_PRINCIPAL, dn);	context.addToEnvironment(Context.SECURITY_CREDENTIALS, password);	try {	context.getAttributes("", null);	isValid = true;	if (log.isDebugEnabled()) {	
user successfully bound 

========================= activemq sample_817 =========================

private void doTestRequestResponse() throws Exception {	MessageProducer requestProducer = requestorSession.createProducer(requestDestination);	MessageConsumer replyConsumer = requestorSession.createConsumer(replyDestination);	TextMessage requestMessage = requestorSession.createTextMessage("SomeRequest");	requestMessage.setJMSReplyTo(replyDestination);	requestProducer.send(requestMessage);	
sent request to destination 

private void doTestRequestResponse() throws Exception {	MessageProducer requestProducer = requestorSession.createProducer(requestDestination);	MessageConsumer replyConsumer = requestorSession.createConsumer(replyDestination);	TextMessage requestMessage = requestorSession.createTextMessage("SomeRequest");	requestMessage.setJMSReplyTo(replyDestination);	requestProducer.send(requestMessage);	Message msg = replyConsumer.receive(10000);	if (msg instanceof TextMessage) {	TextMessage replyMessage = (TextMessage)msg;	
received reply 

protected void syncConsumeLoop(MessageConsumer requestConsumer) {	try {	Message message = requestConsumer.receive(5000);	if (message != null) {	onMessage(message);	} else {	
no message received 

public void onMessage(Message message) {	try {	TextMessage requestMessage = (TextMessage)message;	
received request 

public void onMessage(Message message) {	try {	TextMessage requestMessage = (TextMessage)message;	LOG.info(requestMessage.toString());	Destination replyDestination = requestMessage.getJMSReplyTo();	if (replyDestination instanceof Topic) {	
reply destination is 

public void onMessage(Message message) {	try {	TextMessage requestMessage = (TextMessage)message;	LOG.info(requestMessage.toString());	Destination replyDestination = requestMessage.getJMSReplyTo();	if (replyDestination instanceof Topic) {	} else {	
reply destination is 

} else {	}	TextMessage replyMessage = responderSession.createTextMessage("response for: " + requestMessage.getText());	replyMessage.setJMSCorrelationID(requestMessage.getJMSMessageID());	if (dynamicallyCreateProducer) {	responseProducer = responderSession.createProducer(replyDestination);	responseProducer.send(replyMessage);	} else {	responseProducer.send(replyDestination, replyMessage);	}	
sent reply 

protected void onException(JMSException e) {	
caught 

========================= activemq sample_1589 =========================

AmqpConnection connection = trackConnection(client.connect());	AmqpSession session = connection.createSession();	AmqpSender sender = session.createSender(address);	AmqpReceiver receiver = session.createReceiver(address);	AmqpMessage message = new AmqpMessage();	message.setMessageId("msg" + 1);	message.setMessageAnnotation("serialNo", 1);	message.setText("Test-Message");	sender.send(message);	sender.close();	
attempting to read message with receiver 

AmqpConnection connection = trackConnection(client.connect());	AmqpSession session = connection.createSession();	AmqpSender sender = session.createSender("queue: for (int i = 0; i < MSG_COUNT; i++) {	AmqpMessage message = new AmqpMessage();	message.setMessageId("msg" + i);	message.setMessageAnnotation("serialNo", i);	message.setText("Test-Message");	sender.send(message);	}	sender.close();	
attempting to read first two messages with receiver 

sender.close();	AmqpReceiver receiver1 = session.createReceiver("queue: receiver1.flow(2);	AmqpMessage message1 = receiver1.receive(10, TimeUnit.SECONDS);	AmqpMessage message2 = receiver1.receive(10, TimeUnit.SECONDS);	assertNotNull("Should have read message 1", message1);	assertNotNull("Should have read message 2", message2);	assertEquals("msg0", message1.getMessageId());	assertEquals("msg1", message2.getMessageId());	message1.accept();	message2.accept();	
attempting to read next two messages with receiver 

message2.accept();	AmqpReceiver receiver2 = session.createReceiver("queue: receiver2.flow(2);	AmqpMessage message3 = receiver2.receive(10, TimeUnit.SECONDS);	AmqpMessage message4 = receiver2.receive(10, TimeUnit.SECONDS);	assertNotNull("Should have read message 3", message3);	assertNotNull("Should have read message 4", message4);	assertEquals("msg2", message3.getMessageId());	assertEquals("msg3", message4.getMessageId());	message3.accept();	message4.accept();	
attempting to read remaining messages with receiver 

receiver1.flow(1);	AmqpMessage message3 = receiver1.receive(10, TimeUnit.SECONDS);	receiver2.flow(1);	AmqpMessage message4 = receiver2.receive(10, TimeUnit.SECONDS);	assertNotNull("Should have read message 3", message3);	assertNotNull("Should have read message 4", message4);	assertEquals("msg2", message3.getMessageId());	assertEquals("msg3", message4.getMessageId());	message3.accept();	message4.accept();	
attempting to read remaining messages with both receivers 

AmqpMessage message3 = receiver1.receive(10, TimeUnit.SECONDS);	receiver2.flow(1);	AmqpMessage message4 = receiver2.receive(10, TimeUnit.SECONDS);	assertNotNull("Should have read message 3", message3);	assertNotNull("Should have read message 4", message4);	assertEquals("msg2", message3.getMessageId());	assertEquals("msg3", message4.getMessageId());	message3.accept();	message4.accept();	int splitCredit = (MSG_COUNT - 4) / 2;	
receiver granting creadit for its block of messages 

assertNotNull("Should have read message 4", message4);	assertEquals("msg2", message3.getMessageId());	assertEquals("msg3", message4.getMessageId());	message3.accept();	message4.accept();	int splitCredit = (MSG_COUNT - 4) / 2;	receiver1.flow(splitCredit);	for (int i = 0; i < splitCredit; i++) {	AmqpMessage message = receiver1.receive(10, TimeUnit.SECONDS);	assertNotNull("Receiver #1 should have read a message", message);	
receiver read message 

assertEquals("msg3", message4.getMessageId());	message3.accept();	message4.accept();	int splitCredit = (MSG_COUNT - 4) / 2;	receiver1.flow(splitCredit);	for (int i = 0; i < splitCredit; i++) {	AmqpMessage message = receiver1.receive(10, TimeUnit.SECONDS);	assertNotNull("Receiver #1 should have read a message", message);	message.accept();	}	
receiver granting creadit for its block of messages 

receiver1.flow(splitCredit);	for (int i = 0; i < splitCredit; i++) {	AmqpMessage message = receiver1.receive(10, TimeUnit.SECONDS);	assertNotNull("Receiver #1 should have read a message", message);	message.accept();	}	receiver2.flow(splitCredit);	for (int i = 0; i < splitCredit; i++) {	AmqpMessage message = receiver2.receive(10, TimeUnit.SECONDS);	assertNotNull("Receiver #2 should have read message[" + i + "]", message);	
receiver read message 

final LinkedList<Throwable> errors = new LinkedList<>();	final CountDownLatch receiverReady = new CountDownLatch(1);	ExecutorService executorService = Executors.newCachedThreadPool();	final String address;	if (Queue.class.equals(destType)) {	address = "queue: } else {	address = "topic: }	executorService.submit(new Runnable() {	public void run() {	try {	
starting consumer connection 

AmqpSession session = connection.createSession();	final String address = "queue: AmqpSender sender = session.createSender(address);	AmqpReceiver receiver1 = session.createReceiver(address, null, false, true);	AmqpReceiver receiver2 = session.createReceiver(address, null, false, true);	for (int i = 0; i < MSG_COUNT; i++) {	AmqpMessage message = new AmqpMessage();	message.setMessageId("msg" + i);	sender.send(message);	}	final DestinationViewMBean destinationView = getProxyToQueue(getTestName());	
attempting to read first two messages with receiver 

final DestinationViewMBean destinationView = getProxyToQueue(getTestName());	receiver1.flow(2);	AmqpMessage message1 = receiver1.receive(10, TimeUnit.SECONDS);	AmqpMessage message2 = receiver1.receive(10, TimeUnit.SECONDS);	assertNotNull("Should have read message 1", message1);	assertNotNull("Should have read message 2", message2);	assertEquals("msg0", message1.getMessageId());	assertEquals("msg1", message2.getMessageId());	message1.accept();	message2.accept();	
attempting to read next two messages with receiver 

assertNotNull("Should have read message 4", message4);	assertEquals("msg2", message3.getMessageId());	assertEquals("msg3", message4.getMessageId());	message3.accept();	message4.accept();	assertTrue("Should be no inflight messages: " + destinationView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return destinationView.getInFlightCount() == 0;	}	}));	
attempting to read remaining messages with both receivers 

assertEquals("msg2", message3.getMessageId());	assertEquals("msg3", message4.getMessageId());	message3.accept();	message4.accept();	assertTrue("Should be no inflight messages: " + destinationView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return destinationView.getInFlightCount() == 0;	}	}));	int splitCredit = (MSG_COUNT - 4) / 2;	
receiver granting credit for its block of messages 

assertTrue("Should be no inflight messages: " + destinationView.getInFlightCount(), Wait.waitFor(new Wait.Condition() {	public boolean isSatisified() throws Exception {	return destinationView.getInFlightCount() == 0;	}	}));	int splitCredit = (MSG_COUNT - 4) / 2;	receiver1.flow(splitCredit);	for (int i = 0; i < splitCredit; i++) {	AmqpMessage message = receiver1.receive(10, TimeUnit.SECONDS);	assertNotNull("Receiver #1 should have read a message", message);	
receiver read message 

return destinationView.getInFlightCount() == 0;	}	}));	int splitCredit = (MSG_COUNT - 4) / 2;	receiver1.flow(splitCredit);	for (int i = 0; i < splitCredit; i++) {	AmqpMessage message = receiver1.receive(10, TimeUnit.SECONDS);	assertNotNull("Receiver #1 should have read a message", message);	message.accept();	}	
receiver granting credit for its block of messages 

receiver1.flow(splitCredit);	for (int i = 0; i < splitCredit; i++) {	AmqpMessage message = receiver1.receive(10, TimeUnit.SECONDS);	assertNotNull("Receiver #1 should have read a message", message);	message.accept();	}	receiver2.flow(splitCredit);	for (int i = 0; i < splitCredit; i++) {	AmqpMessage message = receiver2.receive(10, TimeUnit.SECONDS);	assertNotNull("Receiver #2 should have read a message[" + i + "]", message);	
receiver read message 

destinationView = getProxyToTopic(getTestName());	}	executor.execute(new Runnable() {	public void run() {	for (int i = 0; i < MSG_COUNT; i++) {	try {	AmqpMessage received = receiver.receive(5, TimeUnit.SECONDS);	received.accept();	done.countDown();	} catch (Exception ex) {	
caught error 

========================= activemq sample_1566 =========================

protected void dumpMessages() throws Exception {	WireFormat wireFormat = new OpenWireFormat();	java.sql.Connection conn = ((JDBCPersistenceAdapter) broker.getPersistenceAdapter()).getDataSource().getConnection();	PreparedStatement statement = conn.prepareStatement("SELECT ID, MSG FROM ACTIVEMQ_MSGS");	ResultSet result = statement.executeQuery();	
messages left in broker after test 

protected void dumpMessages() throws Exception {	WireFormat wireFormat = new OpenWireFormat();	java.sql.Connection conn = ((JDBCPersistenceAdapter) broker.getPersistenceAdapter()).getDataSource().getConnection();	PreparedStatement statement = conn.prepareStatement("SELECT ID, MSG FROM ACTIVEMQ_MSGS");	ResultSet result = statement.executeQuery();	while(result.next()) {	long id = result.getLong(1);	org.apache.activemq.command.Message message = (org.apache.activemq.command.Message)wireFormat.unmarshal(new ByteSequence(result.getBytes(2)));	
id message seqid msg 

protected int receiveMessages(int messagesExpected, Session session) throws Exception {	int messagesReceived = 0;	for (int i=0; i<messagesExpected; i++) {	Destination destination = session.createQueue("TEST");	MessageConsumer consumer = session.createConsumer(destination);	Message message = null;	try {	
receiving message of 

protected int receiveMessages(int messagesExpected, Session session) throws Exception {	int messagesReceived = 0;	for (int i=0; i<messagesExpected; i++) {	Destination destination = session.createQueue("TEST");	MessageConsumer consumer = session.createConsumer(destination);	Message message = null;	try {	message = consumer.receive(2000);	
received 

Destination destination = session.createQueue("TEST");	MessageConsumer consumer = session.createConsumer(destination);	Message message = null;	try {	message = consumer.receive(2000);	if (message != null) {	session.commit();	messagesReceived++;	}	} catch (Exception e) {	
caught exception 

protected void sendMessages(int messagesExpected) throws Exception {	javax.jms.Connection connection = factory.createConnection();	connection.start();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	Destination destination = session.createQueue("TEST");	MessageProducer producer = session.createProducer(destination);	producer.setDeliveryMode(DeliveryMode.PERSISTENT);	for (int i=0; i<messagesExpected; i++) {	
sending message of 

========================= activemq sample_3808 =========================

public static void visit(ThreadGroup group, int level) {	int numThreads = group.activeCount();	Thread[] threads = new Thread[numThreads * 2];	numThreads = group.enumerate(threads, false);	for (int i = 0; i < numThreads; i++) {	Thread thread = threads[i];	
thread is still running 

========================= activemq sample_2960 =========================

Connection dummyConnection = createConnection();	dummyConnection.start();	makeConsumer(Session.AUTO_ACKNOWLEDGE);	closeConsumer();	publish(30);	int counter = 1;	for (int i = 0; i < 15; i++) {	makeConsumer(Session.AUTO_ACKNOWLEDGE);	Message message = consumer.receive(RECEIVE_TIMEOUT);	assertTrue("Should have received a message!", message != null);	
received message 

makeConsumer(Session.AUTO_ACKNOWLEDGE);	closeConsumer();	publish(30);	int counter = 1;	for (int i = 0; i < 15; i++) {	makeConsumer(Session.AUTO_ACKNOWLEDGE);	Message message = consumer.receive(RECEIVE_TIMEOUT);	assertTrue("Should have received a message!", message != null);	message = consumer.receive(RECEIVE_TIMEOUT);	assertTrue("Should have received a message!", message != null);	
received message 

protected void consumeMessagesDeliveredWhileConsumerClosed() throws Exception {	makeConsumer();	closeConsumer();	publish(1);	Thread.sleep(1000);	makeConsumer();	Message message = consumer.receive(RECEIVE_TIMEOUT);	assertTrue("Should have received a message!", message != null);	closeConsumer();	
now lets create the consumer again and because we didn t ack we should get it again 

Thread.sleep(1000);	makeConsumer();	Message message = consumer.receive(RECEIVE_TIMEOUT);	assertTrue("Should have received a message!", message != null);	closeConsumer();	makeConsumer();	message = consumer.receive(RECEIVE_TIMEOUT);	assertTrue("Should have received a message!", message != null);	message.acknowledge();	closeConsumer();	
now lets create the consumer again and because we did ack we should not get it again 

closeConsumer();	makeConsumer();	message = consumer.receive(RECEIVE_TIMEOUT);	assertTrue("Should have received a message!", message != null);	message.acknowledge();	closeConsumer();	makeConsumer();	message = consumer.receive(2000);	assertTrue("Should have no more messages left!", message == null);	closeConsumer();	
lets publish one more message now 

protected void closeConsumer() throws JMSException {	
closing the consumer 

protected void makeConsumer(int ackMode) throws Exception {	String durableName = getName();	String clientID = getSubject();	
creating a durable subscriber for clientid and durable name 

========================= activemq sample_3672 =========================

protected void setUp() throws Exception {	
creating broker 

protected void setUp() throws Exception {	broker = createBroker("xbean:org/apache/activemq/memory/activemq.xml");	
Success 

protected void tearDown() throws Exception {	
closing broker 

protected void tearDown() throws Exception {	if (broker != null) {	broker.stop();	}	
broker closed 

========================= activemq sample_2599 =========================

public void testInitialWireFormatNegotiationTimeout() throws Exception {	final AtomicReference<Connection> conn = new AtomicReference<Connection>();	final CountDownLatch connStarted = new CountDownLatch(1);	Thread t = new Thread() {	public void run() {	try {	conn.set(createConnectionFactory().createConnection());	conn.get().start();	} catch (Exception ex) {	
could not create or start connection 

========================= activemq sample_2576 =========================

for (int i = 0; i < MESSAGE_COUNT; i++) {	BytesMessage m = session.createBytesMessage();	m.writeBytes(new byte[1024]);	producer.send(m);	}	Message msg = consumer.receive(5000);	assertNotNull(msg);	Message advCmsg = advisoryConsumer.receive(5000);	assertNotNull(advCmsg);	connection.close();	
connection closed destinations should now become inactive 

========================= activemq sample_2825 =========================

consumer = (SpringConsumer) context.getBean("consumer");	assertTrue("Found a valid consumer", consumer != null);	consumer.start();	Thread.sleep(1000);	consumer.flushMessages();	producer = (SpringProducer) context.getBean("producer");	assertTrue("Found a valid producer", producer != null);	producer.start();	consumer.waitForMessagesToArrive(producer.getMessageCount());	List<Message> messages = consumer.flushMessages();	
consumer has received messages 

consumer.start();	Thread.sleep(1000);	consumer.flushMessages();	producer = (SpringProducer) context.getBean("producer");	assertTrue("Found a valid producer", producer != null);	producer.start();	consumer.waitForMessagesToArrive(producer.getMessageCount());	List<Message> messages = consumer.flushMessages();	for (Iterator<Message> iter = messages.iterator(); iter.hasNext();) {	Object message = iter.next();	
received 

========================= activemq sample_3737 =========================

public void stopGenerateReport() {	writeWithIndent(0, "</test-report>");	this.getWriter().flush();	this.getWriter().close();	
test report output 

========================= activemq sample_1161 =========================

public void testProduceConsumeExpireHalf() throws Exception {	final org.apache.activemq.broker.region.Queue dlq = (org.apache.activemq.broker.region.Queue) getDestination(brokerService, new ActiveMQQueue("ActiveMQ.DLQ"));	if (DLQ_PURGE_INTERVAL > 0) {	executorService.execute(new Runnable() {	public void run() {	while (!done.get()) {	try {	Thread.sleep(DLQ_PURGE_INTERVAL);	
purge dlq current size 

executorService.execute(new Runnable() {	public void run() {	try {	while (!done.get()) {	Thread.sleep(RECEIVE_POLL_PERIOD);	for (int i = 0; i < RECEIVE_BATCH && !done.get(); i++) {	Message message = consumer.receive(1000);	if (message != null) {	counter.incrementAndGet();	if (counter.get() > 0 && counter.get() % 500 == 0) {	
received 

producersDone.countDown();	} catch (Exception e) {	e.printStackTrace();	exceptions.add(e);	}	}	});	}	producersDone.await(10, TimeUnit.MINUTES);	final DestinationStatistics view = getDestinationStatistics(brokerService, queue);	
total expired so far 

========================= activemq sample_2937 =========================

protected void sendMessage() throws JMSException {	messages.clear();	try {	for (int i = 0; i < data.length; ++i) {	producer = producerSession.createProducer(queue);	objectMessage = producerSession.createObjectMessage(data[i]);	producer.send(objectMessage);	producerSession.commit();	
sending message 

try {	for (int i = 0; i < data.length; ++i) {	producer = producerSession.createProducer(queue);	objectMessage = producerSession.createObjectMessage(data[i]);	producer.send(objectMessage);	producerSession.commit();	}	} catch (Exception e) {	if (producerSession != null) {	producerSession.rollback();	
rollback 

public synchronized void onMessage(Message m) {	try {	objectMessage = (ObjectMessage)m;	consumeMessage(objectMessage, messages);	
consumer received message 

public synchronized void onMessage(Message m) {	try {	objectMessage = (ObjectMessage)m;	consumeMessage(objectMessage, messages);	consumerSession.commit();	} catch (Exception e) {	try {	consumerSession.rollback();	
rolled back transaction 

========================= activemq sample_3625 =========================

private void sendTestMessages(int numMessages) throws JMSException {	Session session = connection.createSession(true, Session.SESSION_TRANSACTED);	MessageProducer producer = session.createProducer(queue);	final TextMessage textMessage = session.createTextMessage();	textMessage.setText("Message");	for (int i = 1; i <= numMessages; i++) {	producer.send(textMessage);	if (i % 1000 == 0) {	
sent messages 

public void run() {	try {	int i = 0;	while (consumer.receive(1000) != null) {	i++;	if (i % 1000 == 0) {	
received messages 

========================= activemq sample_2872 =========================

public void testIndexDirExists() throws Exception {	
index dir is configured as 

public void testIndexDirExists() throws Exception {	assertTrue(kahaDataDir.exists());	assertTrue(kahaIndexDir.exists());	String[] index = kahaIndexDir.list(new FilenameFilter() {	public boolean accept(File dir, String name) {	
testing filename 

public void testIndexDirExists() throws Exception {	assertTrue(kahaDataDir.exists());	assertTrue(kahaIndexDir.exists());	String[] index = kahaIndexDir.list(new FilenameFilter() {	public boolean accept(File dir, String name) {	return name.endsWith("data") || name.endsWith("redo");	}	});	String[] journal = kahaDataDir.list(new FilenameFilter() {	public boolean accept(File dir, String name) {	
testing filename 

========================= activemq sample_3760 =========================

}	}	protected Connection wrap(final Connection connection) {	((ActiveMQConnection)connection).addTransportListener(new TransportListener() {	public void onCommand(Object command) {	}	public void onException(IOException error) {	synchronized (this) {	setHasExpired(true);	if (!stopped.get()) {	
expiring connection on ioexception 

}	}	protected Connection wrap(final Connection connection) {	((ActiveMQConnection)connection).addTransportListener(new TransportListener() {	public void onCommand(Object command) {	}	public void onException(IOException error) {	synchronized (this) {	setHasExpired(true);	if (!stopped.get()) {	
expiring connection on ioexception 

========================= activemq sample_790 =========================

public static void dispose(Service service) {	try {	service.stop();	} catch (Exception e) {	
could not stop service reason 

========================= activemq sample_155 =========================

protected ClassLoader getContextClassLoader(Properties settings) {	String extDir = (String)settings.remove(KEY_EXT_DIR);	if (extDir != null) {	StringTokenizer tokens = new StringTokenizer(extDir, ";,");	List<URL> urls = new ArrayList<URL>();	while (tokens.hasMoreTokens()) {	String dir = tokens.nextToken();	try {	File f = new File(dir);	if (!f.exists()) {	
cannot find extension dir 

String extDir = (String)settings.remove(KEY_EXT_DIR);	if (extDir != null) {	StringTokenizer tokens = new StringTokenizer(extDir, ";,");	List<URL> urls = new ArrayList<URL>();	while (tokens.hasMoreTokens()) {	String dir = tokens.nextToken();	try {	File f = new File(dir);	if (!f.exists()) {	} else {	
adding extension dir 

String dir = tokens.nextToken();	try {	File f = new File(dir);	if (!f.exists()) {	} else {	urls.add(f.toURL());	File[] files = f.listFiles();	if (files != null) {	for (int j = 0; j < files.length; j++) {	if (files[j].getName().endsWith(".zip") || files[j].getName().endsWith(".jar")) {	
adding extension dir 

File[] files = f.listFiles();	if (files != null) {	for (int j = 0; j < files.length; j++) {	if (files[j].getName().endsWith(".zip") || files[j].getName().endsWith(".jar")) {	urls.add(files[j].toURL());	}	}	}	}	} catch (Exception e) {	
failed to load ext dir reason 

========================= activemq sample_1198 =========================

applyNewConfig(brokerConfig, "emptyManualUpdateConfig");	startBroker(brokerConfig);	assertTrue("broker alive", brokerService.isStarted());	assertEquals("no network connectors", 0, brokerService.getNetworkConnectors().size());	applyNewConfig(brokerConfig, "networkConnectorTest-one-nc", SLEEP);	assertEquals("no network connectors", 0, brokerService.getNetworkConnectors().size());	ObjectName objectName = new ObjectName(brokerService.getBrokerObjectName().toString() + RuntimeConfigurationBroker.objectNamePropsAppendage);	RuntimeConfigurationViewMBean runtimeConfigurationView = (RuntimeConfigurationViewMBean) brokerService.getManagementContext().newProxyInstance(objectName, RuntimeConfigurationViewMBean.class, false);	HashMap<String, String> props = new HashMap<String, String>();	IntrospectionSupport.getProperties(runtimeConfigurationView, props, null);	
mbean attributes before 

startBroker(brokerConfig);	assertTrue("broker alive", brokerService.isStarted());	assertEquals("no network connectors", 0, brokerService.getNetworkConnectors().size());	applyNewConfig(brokerConfig, "networkConnectorTest-one-nc", SLEEP);	assertEquals("no network connectors", 0, brokerService.getNetworkConnectors().size());	ObjectName objectName = new ObjectName(brokerService.getBrokerObjectName().toString() + RuntimeConfigurationBroker.objectNamePropsAppendage);	RuntimeConfigurationViewMBean runtimeConfigurationView = (RuntimeConfigurationViewMBean) brokerService.getManagementContext().newProxyInstance(objectName, RuntimeConfigurationViewMBean.class, false);	HashMap<String, String> props = new HashMap<String, String>();	IntrospectionSupport.getProperties(runtimeConfigurationView, props, null);	String result = runtimeConfigurationView.updateNow();	
result from update 

assertEquals("no network connectors", 0, brokerService.getNetworkConnectors().size());	ObjectName objectName = new ObjectName(brokerService.getBrokerObjectName().toString() + RuntimeConfigurationBroker.objectNamePropsAppendage);	RuntimeConfigurationViewMBean runtimeConfigurationView = (RuntimeConfigurationViewMBean) brokerService.getManagementContext().newProxyInstance(objectName, RuntimeConfigurationViewMBean.class, false);	HashMap<String, String> props = new HashMap<String, String>();	IntrospectionSupport.getProperties(runtimeConfigurationView, props, null);	String result = runtimeConfigurationView.updateNow();	assertTrue("got sensible result: " + result, result.contains("started"));	assertEquals("one new network connectors", 1, brokerService.getNetworkConnectors().size());	HashMap<String, String> propsAfter = new HashMap<String, String>();	IntrospectionSupport.getProperties(runtimeConfigurationView, propsAfter, null);	
mbean attributes after 

final String brokerConfig =  "mBeanTest-manual-broker";	applyNewConfig(brokerConfig, "emptyManualUpdateConfig");	startBroker(brokerConfig);	assertTrue("broker alive", brokerService.isStarted());	assertEquals("no network connectors", 0, brokerService.getNetworkConnectors().size());	applyNewConfig(brokerConfig, "parseErrorConfig", SLEEP);	ObjectName objectName = new ObjectName(brokerService.getBrokerObjectName().toString() + RuntimeConfigurationBroker.objectNamePropsAppendage);	RuntimeConfigurationViewMBean runtimeConfigurationView = (RuntimeConfigurationViewMBean) brokerService.getManagementContext().newProxyInstance(objectName, RuntimeConfigurationViewMBean.class, false);	HashMap<String, String> props = new HashMap<String, String>();	IntrospectionSupport.getProperties(runtimeConfigurationView, props, null);	
mbean attributes before 

applyNewConfig(brokerConfig, "emptyManualUpdateConfig");	startBroker(brokerConfig);	assertTrue("broker alive", brokerService.isStarted());	assertEquals("no network connectors", 0, brokerService.getNetworkConnectors().size());	applyNewConfig(brokerConfig, "parseErrorConfig", SLEEP);	ObjectName objectName = new ObjectName(brokerService.getBrokerObjectName().toString() + RuntimeConfigurationBroker.objectNamePropsAppendage);	RuntimeConfigurationViewMBean runtimeConfigurationView = (RuntimeConfigurationViewMBean) brokerService.getManagementContext().newProxyInstance(objectName, RuntimeConfigurationViewMBean.class, false);	HashMap<String, String> props = new HashMap<String, String>();	IntrospectionSupport.getProperties(runtimeConfigurationView, props, null);	String result = runtimeConfigurationView.updateNow();	
result from failed update 

assertEquals("no network connectors", 0, brokerService.getNetworkConnectors().size());	applyNewConfig(brokerConfig, "parseErrorConfig", SLEEP);	ObjectName objectName = new ObjectName(brokerService.getBrokerObjectName().toString() + RuntimeConfigurationBroker.objectNamePropsAppendage);	RuntimeConfigurationViewMBean runtimeConfigurationView = (RuntimeConfigurationViewMBean) brokerService.getManagementContext().newProxyInstance(objectName, RuntimeConfigurationViewMBean.class, false);	HashMap<String, String> props = new HashMap<String, String>();	IntrospectionSupport.getProperties(runtimeConfigurationView, props, null);	String result = runtimeConfigurationView.updateNow();	assertTrue("got sensible result: " + result, result.contains("dudElement"));	HashMap<String, String> propsAfter = new HashMap<String, String>();	IntrospectionSupport.getProperties(runtimeConfigurationView, propsAfter, null);	
mbean attributes after 

HashMap<String, String> props = new HashMap<String, String>();	IntrospectionSupport.getProperties(runtimeConfigurationView, props, null);	String result = runtimeConfigurationView.updateNow();	assertTrue("got sensible result: " + result, result.contains("dudElement"));	HashMap<String, String> propsAfter = new HashMap<String, String>();	IntrospectionSupport.getProperties(runtimeConfigurationView, propsAfter, null);	String propOfInterest = "modified";	assertEquals("modified is same", props.get(propOfInterest), propsAfter.get(propOfInterest));	applyNewConfig(brokerConfig, "networkConnectorTest-one-nc", SLEEP);	result = runtimeConfigurationView.updateNow();	
result from update 

========================= activemq sample_4375 =========================

public void startAutoFailThread() {	setAutoFail(true);	isTestSuccess = new AtomicBoolean(false);	autoFailThread = new Thread(new Runnable() {	public void run() {	try {	Thread.sleep(getMaxTestTime());	} catch (InterruptedException e) {	} finally {	if (!isTestSuccess.get()) {	
test case has exceeded the maximum allotted time to run of ms 

public void run() {	try {	Thread.sleep(getMaxTestTime());	} catch (InterruptedException e) {	} finally {	if (!isTestSuccess.get()) {	dumpAllThreads(getName());	if (System.getProperty("org.apache.activemq.AutoFailTestSupport.disableSystemExit") == null) {	System.exit(EXIT_ERROR);	} else {	
no system exit as it kills surefire forkedprocesstimeoutinseconds surefire timeout will kick in eventually see pom xml surefire plugin config 

dumpAllThreads(getName());	if (System.getProperty("org.apache.activemq.AutoFailTestSupport.disableSystemExit") == null) {	System.exit(EXIT_ERROR);	} else {	}	}	}	}	}, "AutoFailThread");	if (verbose) {	
starting auto fail thread 

if (System.getProperty("org.apache.activemq.AutoFailTestSupport.disableSystemExit") == null) {	System.exit(EXIT_ERROR);	} else {	}	}	}	}	}, "AutoFailThread");	if (verbose) {	}	
starting auto fail thread 

public void stopAutoFailThread() {	if (isAutoFail() && autoFailThread != null && autoFailThread.isAlive()) {	isTestSuccess.set(true);	if (verbose) {	
stopping auto fail thread 

public void stopAutoFailThread() {	if (isAutoFail() && autoFailThread != null && autoFailThread.isAlive()) {	isTestSuccess.set(true);	if (verbose) {	}	
stopping auto fail thread 

========================= activemq sample_3849 =========================

public void testInactiveMirroredQueueIsCleanedUp() throws Exception {	if (connection == null) {	connection = createConnection();	}	connection.start();	ConsumerBean messageList = new ConsumerBean();	messageList.setVerbose(true);	ActiveMQDestination consumeDestination = createConsumeDestination();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	
consuming from 

connection = createConnection();	}	connection.start();	ConsumerBean messageList = new ConsumerBean();	messageList.setVerbose(true);	ActiveMQDestination consumeDestination = createConsumeDestination();	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	MessageConsumer c1 = session.createConsumer(consumeDestination);	c1.setMessageListener(messageList);	ActiveMQQueue sendDestination = new ActiveMQQueue(getQueueName());	
sending to 

MessageConsumer c1 = session.createConsumer(consumeDestination);	c1.setMessageListener(messageList);	ActiveMQQueue sendDestination = new ActiveMQQueue(getQueueName());	MessageProducer producer = session.createProducer(sendDestination);	assertNotNull(producer);	final int total = 10;	for (int i = 0; i < total; i++) {	producer.send(session.createTextMessage("message: " + i));	}	messageList.assertMessagesArrived(total);	
received 

assertNotNull(producer);	final int total = 10;	for (int i = 0; i < total; i++) {	producer.send(session.createTextMessage("message: " + i));	}	messageList.assertMessagesArrived(total);	messageList.flushMessages();	MessageConsumer c2 = session.createConsumer(sendDestination);	c2.setMessageListener(messageList);	messageList.assertMessagesArrived(total);	
q received 

========================= activemq sample_2921 =========================

public void onMessage(Message message) {	if (message != null) {	TextMessage textMessage = (TextMessage) message;	try {	String response = textMessage.getText();	
received 

========================= activemq sample_786 =========================

ActiveMQQueue compositeSendTo = new ActiveMQQueue("one,two,three");	ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokerUrl);	connectionFactory.setWatchTopicAdvisories(false);	Connection connection = connectionFactory.createConnection();	connection.start();	try {	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);	session.createProducer(compositeSendTo).send(session.createTextMessage("Bing"));	for (ActiveMQDestination dest : compositeSendTo.getCompositeDestinations()) {	Message message = session.createConsumer(dest).receive(5000);	
from 

========================= activemq sample_2864 =========================

}	String message = request.getParameter(messages == 0 ? "message" : ("m" + messages));	String type = request.getParameter(messages == 0 ? "type" : ("t" + messages));	if (destinationName == null || message == null || type == null) {	break;	}	try {	Destination destination = getDestination(client, request, destinationName);	if (LOG.isDebugEnabled()) {	LOG.debug(messages + " destination=" + destinationName + " message=" + message + " type=" + type);	
is a 

}	} else if ("unlisten".equals(type)) {	Map<MessageAvailableConsumer, String> consumerIdMap = client.getIdMap();	Map<MessageAvailableConsumer, String> consumerDestinationNameMap = client.getDestinationNameMap();	MessageAvailableConsumer consumer = (MessageAvailableConsumer)client.getConsumer(destination, request.getHeader(WebClient.selectorName));	consumer.setAvailableListener(null);	consumerIdMap.remove(consumer);	consumerDestinationNameMap.remove(consumer);	client.closeConsumer(destination);	if (LOG.isDebugEnabled()) {	
unsubscribed 

consumerDestinationNameMap.remove(consumer);	client.closeConsumer(destination);	if (LOG.isDebugEnabled()) {	}	} else if ("send".equals(type)) {	TextMessage text = client.getSession().createTextMessage(message);	appendParametersToMessage(request, text);	client.send(destination, text);	messageIds += text.getJMSMessageID() + "\n";	if (LOG.isDebugEnabled()) {	
sent to 

if (LOG.isDebugEnabled()) {	}	} else if ("send".equals(type)) {	TextMessage text = client.getSession().createTextMessage(message);	appendParametersToMessage(request, text);	client.send(destination, text);	messageIds += text.getJMSMessageID() + "\n";	if (LOG.isDebugEnabled()) {	}	} else {	
unknown type 

} else if ("send".equals(type)) {	TextMessage text = client.getSession().createTextMessage(message);	appendParametersToMessage(request, text);	client.send(destination, text);	messageIds += text.getJMSMessageID() + "\n";	if (LOG.isDebugEnabled()) {	}	} else {	}	} catch (JMSException e) {	
jms 

}	} else {	if (request.getContentLength() != 0 && (request.getContentType() == null || !request.getContentType().toLowerCase().startsWith("application/x-www-form-urlencoded"))) {	try {	Destination destination = getDestination(client, request);	String body = getPostedMessageBody(request);	TextMessage message = client.getSession().createTextMessage(body);	appendParametersToMessage(request, message);	client.send(destination, message);	if (LOG.isDebugEnabled()) {	
sent to destination body 

consumer = (MessageAvailableConsumer)undelivered_message.getConsumer();	}	if (message == null) {	for (int i = 0; message == null && i < consumers.size(); i++) {	consumer = (MessageAvailableConsumer)consumers.get(i);	if (consumer.getAvailableListener() == null) {	continue;	}	message = consumer.receive(10);	if (LOG.isDebugEnabled()) {	
received from 

}	}	}	response.setContentType("text/xml");	response.setHeader("Cache-Control", "no-cache");	if (message == null && client.getListener().getUndeliveredMessages().size() == 0) {	Continuation continuation = ContinuationSupport.getContinuation(request);	continuation.addContinuationListener(new ContinuationListener() {	public void onTimeout(Continuation cont) {	if (LOG.isDebugEnabled()) {	
continuation expired 

response.setHeader("Cache-Control", "no-cache");	if (message == null && client.getListener().getUndeliveredMessages().size() == 0) {	Continuation continuation = ContinuationSupport.getContinuation(request);	continuation.addContinuationListener(new ContinuationListener() {	public void onTimeout(Continuation cont) {	if (LOG.isDebugEnabled()) {	}	}	public void onComplete(Continuation cont) {	if (LOG.isDebugEnabled()) {	
continuation completed 

PrintWriter writer = new PrintWriter(swriter);	writer.println("<ajax-response>");	writer.print("</ajax-response>");	writer.flush();	String m = swriter.toString();	response.getWriter().println(m);	return;	}	continuation.setTimeout(timeout);	continuation.suspend();	
suspending continuation 

}	StringWriter swriter = new StringWriter();	PrintWriter writer = new PrintWriter(swriter);	Map<MessageAvailableConsumer, String> consumerIdMap = client.getIdMap();	Map<MessageAvailableConsumer, String> consumerDestinationNameMap = client.getDestinationNameMap();	response.setStatus(HttpServletResponse.SC_OK);	writer.println("<ajax-response>");	if (message != null) {	String id = consumerIdMap.get(consumer);	String destinationName = consumerDestinationNameMap.get(consumer);	
sending pre existing message 

Map<MessageAvailableConsumer, String> consumerDestinationNameMap = client.getDestinationNameMap();	response.setStatus(HttpServletResponse.SC_OK);	writer.println("<ajax-response>");	if (message != null) {	String id = consumerIdMap.get(consumer);	String destinationName = consumerDestinationNameMap.get(consumer);	writeMessageResponse(writer, message, id, destinationName);	messages++;	}	LinkedList<UndeliveredAjaxMessage> undeliveredMessages = ((AjaxListener)consumer.getAvailableListener()).getUndeliveredMessages();	
send unconsumed messages 

}	LinkedList<UndeliveredAjaxMessage> undeliveredMessages = ((AjaxListener)consumer.getAvailableListener()).getUndeliveredMessages();	synchronized( undeliveredMessages ) {	for (Iterator<UndeliveredAjaxMessage> it = undeliveredMessages.iterator(); it.hasNext();) {	messages++;	UndeliveredAjaxMessage undelivered = it.next();	Message msg = undelivered.getMessage();	consumer = (MessageAvailableConsumer)undelivered.getConsumer();	String id = consumerIdMap.get(consumer);	String destinationName = consumerDestinationNameMap.get(consumer);	
sending undelivered buffered messages 

}	LinkedList<UndeliveredAjaxMessage> undeliveredMessages = ((AjaxListener)consumer.getAvailableListener()).getUndeliveredMessages();	synchronized( undeliveredMessages ) {	for (Iterator<UndeliveredAjaxMessage> it = undeliveredMessages.iterator(); it.hasNext();) {	messages++;	UndeliveredAjaxMessage undelivered = it.next();	Message msg = undelivered.getMessage();	consumer = (MessageAvailableConsumer)undelivered.getConsumer();	String id = consumerIdMap.get(consumer);	String destinationName = consumerDestinationNameMap.get(consumer);	
msg id destinationname 

continue;	}	while (messages < maximumMessages) {	message = consumer.receiveNoWait();	if (message == null) {	break;	}	messages++;	String id = consumerIdMap.get(consumer);	String destinationName = consumerDestinationNameMap.get(consumer);	
sending final available messages 

String clientId = request.getParameter( "clientId" );	if( clientId == null ) {	clientId = "defaultAjaxWebClient";	}	String sessionKey = session.getId() + '-' + clientId;	AjaxWebClient client = null;	synchronized (ajaxWebClients) {	client = ajaxWebClients.get( sessionKey );	if( client == null ) {	if (LOG.isDebugEnabled()) {	
creating new ajaxwebclient in 

public void run() {	if( LOG.isDebugEnabled() ) {	
cleaning up expired web clients 

public void run() {	if( LOG.isDebugEnabled() ) {	}	synchronized( ajaxWebClients ) {	Iterator<Map.Entry<String, AjaxWebClient>> it = ajaxWebClients.entrySet().iterator();	while ( it.hasNext() ) {	Map.Entry<String,AjaxWebClient> e = it.next();	String key = e.getKey();	AjaxWebClient val = e.getValue();	if ( LOG.isDebugEnabled() ) {	
ajaxwebclient last accessed seconds ago 

synchronized( ajaxWebClients ) {	Iterator<Map.Entry<String, AjaxWebClient>> it = ajaxWebClients.entrySet().iterator();	while ( it.hasNext() ) {	Map.Entry<String,AjaxWebClient> e = it.next();	String key = e.getKey();	AjaxWebClient val = e.getValue();	if ( LOG.isDebugEnabled() ) {	}	if( val.closeIfExpired() ) {	if ( LOG.isDebugEnabled() ) {	
removing expired ajaxwebclient 

========================= activemq sample_1065 =========================

AmqpMessage message = receiver.receive(5, TimeUnit.SECONDS);	assertNotNull(message);	message.accept();	QueueViewMBean queue = getProxyToQueue(getTestName());	ObjectName slowConsumerPolicyMBeanName = queue.getSlowConsumerStrategy();	assertNotNull(slowConsumerPolicyMBeanName);	AbortSlowConsumerStrategyViewMBean abortPolicy = (AbortSlowConsumerStrategyViewMBean) brokerService.getManagementContext().newProxyInstance(slowConsumerPolicyMBeanName, AbortSlowConsumerStrategyViewMBean.class, true);	TimeUnit.SECONDS.sleep(3);	TabularData slowOnes = abortPolicy.getSlowConsumers();	assertEquals("one slow consumers", 1, slowOnes.size());	
slow ones 

assertNotNull(message);	message.accept();	QueueViewMBean queue = getProxyToQueue(getTestName());	ObjectName slowConsumerPolicyMBeanName = queue.getSlowConsumerStrategy();	assertNotNull(slowConsumerPolicyMBeanName);	AbortSlowConsumerStrategyViewMBean abortPolicy = (AbortSlowConsumerStrategyViewMBean) brokerService.getManagementContext().newProxyInstance(slowConsumerPolicyMBeanName, AbortSlowConsumerStrategyViewMBean.class, true);	TimeUnit.SECONDS.sleep(3);	TabularData slowOnes = abortPolicy.getSlowConsumers();	assertEquals("one slow consumers", 1, slowOnes.size());	CompositeData slowOne = (CompositeData) slowOnes.values().iterator().next();	
slow one 

========================= activemq sample_1570 =========================

}	for( int i=0; i < messageToSend; i++ ) {	producer.send(session.createTextMessage(data));	}	QueueBrowser browser = session.createBrowser(queue);	Enumeration<?> enumeration = browser.getEnumeration();	int received = 0;	while (enumeration.hasMoreElements()) {	Message m = (Message) enumeration.nextElement();	received++;	
browsed message 

========================= activemq sample_3664 =========================

public void testStatistic() throws Exception {	BoundaryStatisticImpl stat = new BoundaryStatisticImpl("myBoundaryStat", "seconds", "myBoundaryStatDesc", 1000, 2000);	assertStatistic(stat, "myBoundaryStat", "seconds", "myBoundaryStatDesc");	assertEquals(1000, stat.getLowerBound());	assertEquals(2000, stat.getUpperBound());	
stat is 

========================= activemq sample_2976 =========================

public void onMessage(Message message) {	
simpleconsumer message received 

========================= activemq sample_3721 =========================

public void simpleTest() throws Exception {	thrown.expect(IOException.class);	thrown.expectMessage("enabledCipherSuites=BADSUITE");	broker = new BrokerService();	broker.setPersistent(false);	broker.setUseJmx(false);	try {	broker.addConnector( "ssl: broker.start();	broker.waitUntilStarted();	} catch (Exception e) {	
brokerservice threw 

========================= activemq sample_2833 =========================

protected void destroyBrokerCluster() throws JMSException, Exception {	for (BrokerService b : brokers.values()) {	try {	b.stop();	b.waitUntilStopped();	} catch (Exception e) {	
error while stopping broker continuing 

========================= activemq sample_2560 =========================

