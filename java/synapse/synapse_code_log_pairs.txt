public boolean startProcess() {	try {	broker = new BrokerService();	broker.setBrokerName("synapseSampleBroker");	broker.addConnector(providerURL);	broker.start();	
jmsservercontroller broker is successfully started continuing tests 

public boolean startProcess() {	try {	broker = new BrokerService();	broker.setBrokerName("synapseSampleBroker");	broker.addConnector(providerURL);	broker.start();	return true;	} catch (Exception e) {	
there was an error starting jms broker 

public boolean stopProcess() {	try {	broker.stop();	FileUtils.deleteQuietly(broker.getDataDirectoryFile());	return true;	} catch (Exception e) {	
error while shutting down the broker 

========================= synapse sample_879 =========================

public void pauseListeners() {	if ((configurationContext != null) && (configurationContext.getAxisConfiguration() != null)) {	Map<String, TransportInDescription> trpIns = configurationContext.getAxisConfiguration().getTransportsIn();	for (TransportInDescription trpIn : trpIns.values()) {	TransportListener trpLst = trpIn.getReceiver();	if (trpLst instanceof ManagementSupport) {	try {	((ManagementSupport) trpLst).pause();	} catch (AxisFault axisFault) {	
error putting transport listener for into maintenence 

public void resumeListeners() {	if ((configurationContext != null) && (configurationContext.getAxisConfiguration() != null)) {	Map<String, TransportInDescription> trpIns = configurationContext.getAxisConfiguration().getTransportsIn();	for (TransportInDescription trpIn : trpIns.values()) {	TransportListener trpLst = trpIn.getReceiver();	if (trpLst instanceof ManagementSupport) {	try {	((ManagementSupport) trpLst).resume();	} catch (AxisFault axisFault) {	
error resuming transport listener for from maintenence 

public void pauseSenders() {	if ((configurationContext != null) && (configurationContext.getAxisConfiguration() != null)) {	Map<String, TransportOutDescription> trpOuts = configurationContext.getAxisConfiguration().getTransportsOut();	for (TransportOutDescription trpOut : trpOuts.values()) {	TransportSender trpSnd = trpOut.getSender();	if (trpSnd instanceof ManagementSupport) {	try {	((ManagementSupport) trpSnd).pause();	} catch (AxisFault axisFault) {	
error pausing transport sender 

public void resumeSenders() {	if ((configurationContext != null) && (configurationContext.getAxisConfiguration() != null)) {	Map<String, TransportOutDescription> trpOuts = configurationContext.getAxisConfiguration().getTransportsOut();	for (TransportOutDescription trpOut : trpOuts.values()) {	TransportSender trpSnd = trpOut.getSender();	if (trpSnd instanceof ManagementSupport) {	try {	((ManagementSupport) trpSnd).resume();	} catch (AxisFault axisFault) {	
error resuming transport sender for from maintenence 

public int getPendingListenerThreadCount() {	int pendingThreads = 0;	Map<String, TransportInDescription> trpIns = configurationContext.getAxisConfiguration().getTransportsIn();	for (TransportInDescription trpIn : trpIns.values()) {	TransportListener trpLst = trpIn.getReceiver();	if (trpLst instanceof ManagementSupport) {	int inUse = ((ManagementSupport) trpLst).getActiveThreadCount();	int inQue = ((ManagementSupport) trpLst).getQueueSize();	if ((inUse + inQue) > 0) {	if (log.isDebugEnabled()) {	
transport listener currently using threads with requests already queued 

public int getPendingSenderThreadCount() {	int pendingThreads = 0;	Map<String, TransportOutDescription> trpOuts = configurationContext.getAxisConfiguration().getTransportsOut();	for (TransportOutDescription trpOut : trpOuts.values()) {	TransportSender trpSnd = trpOut.getSender();	if (trpSnd instanceof ManagementSupport) {	int inUse = ((ManagementSupport) trpSnd).getActiveThreadCount();	int inQue = ((ManagementSupport) trpSnd).getQueueSize();	if ((inUse + inQue) > 0) {	if (log.isDebugEnabled()) {	
transport sender currently using threads with requests already queued 

========================= synapse sample_195 =========================

MessageContext synCtx = MessageContextCreatorForAxis2.getSynapseMessageContext(mc);	StatisticsReporter.reportForComponent(synCtx, proxy.getAspectConfiguration(), ComponentType.PROXYSERVICE);	Log serviceLog = logFactory.getInstance(SynapseConstants.SERVICE_LOGGER_PREFIX + name);	((Axis2MessageContext) synCtx).setServiceLog(serviceLog);	synCtx.setProperty(SynapseConstants.PROXY_SERVICE, name);	synCtx.setTracingState(proxy.getTraceState());	try {	Mediator mandatorySeq = synCtx.getConfiguration().getMandatorySequence();	if (mandatorySeq != null) {	if (log.isDebugEnabled()) {	
start mediating the message in the pre mediate state using the mandatory sequence 

((Axis2MessageContext) synCtx).setServiceLog(serviceLog);	synCtx.setProperty(SynapseConstants.PROXY_SERVICE, name);	synCtx.setTracingState(proxy.getTraceState());	try {	Mediator mandatorySeq = synCtx.getConfiguration().getMandatorySequence();	if (mandatorySeq != null) {	if (log.isDebugEnabled()) {	}	if(!mandatorySeq.mediate(synCtx)) {	if(log.isDebugEnabled()) {	
request message for the proxy service dropped in the pre mediation state by the mandatory sequence 

========================= synapse sample_1621 =========================

public void receive(MessageContext mc) throws AxisFault {	
receiving message 

========================= synapse sample_4589 =========================

public boolean matches(String value) {	if (value == null) {	
provided character sequence for switch case condition is null switch case will not be executed 

public boolean matches(String value) {	if (value == null) {	return false;	}	Matcher matcher = regex.matcher(value);	if (matcher == null) {	
matcher for the provided character sequence and the pattern cannot be found switch case will not be executed 

========================= synapse sample_316 =========================

public void destroy() {	if (log.isDebugEnabled()) {	
un registering the synapse threading view for the thread group 

private void initMBean() {	if (log.isDebugEnabled()) {	
starting a new synapse threading view for the thread group 

private void periodicDump() {	if (periodicLogs && log.isDebugEnabled()) {	StringBuffer buffer = new StringBuffer();	buffer.append("Thread state summary for ").append(threadNamePrefix). append(" threads - Blocked: ").append(avgBlockedWorkerPercentage). append("%, Unblocked: ").append(avgUnblockedWorkerPercentage). append("%");	log.debug(buffer.toString());	}	if (alertMargin > 0) {	double blocked = getAverageBlockedThreads(1);	if (blocked > alertMargin) {	
system alert of the threads were in blocked state during last minute 

========================= synapse sample_2148 =========================

public TrustManagerFactory getTrustManagerFactoryInstance() {	try {	if (log.isDebugEnabled()) {	
creating a trustmanagerfactory instance 

========================= synapse sample_2518 =========================

} else if (obj instanceof ArrayList) {	obj = cloneArrayList((ArrayList) obj);	} else if (obj instanceof Stack && key.equals(SynapseConstants.SYNAPSE__FUNCTION__STACK)) {	obj = getClonedTemplateStack((Stack<TemplateContext>) obj);	} else if (obj instanceof StatisticsRecord) {	obj = getClonedStatisticRecord((StatisticsRecord) obj);	} else if (obj instanceof OMElement) {	obj = ((OMElement) obj).cloneOMElement();	} else {	if (log.isDebugEnabled()) {	
deep clone not happened for property class type 

if (!faultStack.isEmpty()) {	List<FaultHandler> newFaultStack = new ArrayList<FaultHandler>();	newFaultStack.addAll(faultStack);	for (FaultHandler faultHandler : newFaultStack) {	if (faultHandler != null) {	newCtx.pushFaultHandler(faultHandler);	}	}	}	if (log.isDebugEnabled()) {	
parent s fault stack child s fault stack 

} catch (Exception e) {	handleException(e.getLocalizedMessage());	}	} else if (obj instanceof SOAPEnvelope) {	SOAPEnvelope env = (SOAPEnvelope) obj;	obj = MessageHelper.cloneSOAPEnvelope(env);	} else if (obj instanceof OMElement) {	obj = ((OMElement) obj).cloneOMElement();	} else {	if (log.isDebugEnabled()) {	
array list deep clone not implemented for class type 

========================= synapse sample_253 =========================

public void connected(final NHttpClientConnection conn, final Object attachment) {	if (this.log.isDebugEnabled()) {	
http connection connected 

public void closed(final NHttpClientConnection conn) {	if (this.log.isDebugEnabled()) {	
http connection closed 

public void exception(final NHttpClientConnection conn, final IOException ex) {	
http connection 

public void exception(final NHttpClientConnection conn, final HttpException ex) {	
http connection 

public void requestReady(final NHttpClientConnection conn) {	if (this.log.isDebugEnabled()) {	
http connection request ready 

public void outputReady(final NHttpClientConnection conn, final ContentEncoder encoder) {	if (this.log.isDebugEnabled()) {	
http connection output ready 

public void outputReady(final NHttpClientConnection conn, final ContentEncoder encoder) {	if (this.log.isDebugEnabled()) {	}	this.handler.outputReady(conn, encoder);	if (this.log.isDebugEnabled()) {	
http connection content encoder 

public void responseReceived(final NHttpClientConnection conn) {	HttpResponse response = conn.getHttpResponse();	if (this.log.isDebugEnabled()) {	
http connection 

public void inputReady(final NHttpClientConnection conn, final ContentDecoder decoder) {	if (this.log.isDebugEnabled()) {	
http connection input ready 

public void inputReady(final NHttpClientConnection conn, final ContentDecoder decoder) {	if (this.log.isDebugEnabled()) {	}	this.handler.inputReady(conn, decoder);	if (this.log.isDebugEnabled()) {	
http connection content decoder 

public void timeout(final NHttpClientConnection conn) {	if (this.log.isDebugEnabled()) {	
http connection timeout 

========================= synapse sample_3759 =========================

public boolean mediate(MessageContext synCtx) {	try {	
implicit sequence mediate 

========================= synapse sample_3309 =========================

public void run() {	while (true) {	try {	selector.select();	} catch (IOException ex) {	
exception in select i o dispatcher will be shut down 

private void receive(Endpoint endpoint, DatagramChannel channel) {	try {	byte[] data = new byte[endpoint.getMaxPacketSize()];	ByteBuffer buffer = ByteBuffer.wrap(data);	SocketAddress address = channel.receive(buffer);	int length = buffer.position();	if (log.isDebugEnabled()) {	
received packet from with length 

try {	byte[] data = new byte[endpoint.getMaxPacketSize()];	ByteBuffer buffer = ByteBuffer.wrap(data);	SocketAddress address = channel.receive(buffer);	int length = buffer.position();	if (log.isDebugEnabled()) {	}	workerPool.execute(new ProcessPacketTask(endpoint, data, length));	} catch (IOException ex) {	endpoint.getMetrics().incrementFaultsReceiving();	
error receiving udp packet 

========================= synapse sample_4248 =========================

public boolean mediate(MessageContext synCtx) {	
rm mediator mediate 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	if(shouldTrace) {	trace.trace("Start : RM mediator");	}	org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext) synCtx).getAxis2MessageContext();	Object obj = msgCtx.getProperty(org.apache.synapse.Constants.MESSAGE_RECEIVED_RM_ENGAGED);	if (obj != null && ((Boolean)obj).booleanValue()) {	
rm mediator works only for the first chain 

========================= synapse sample_3077 =========================

public void testCustomMediator() {	String addUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test demonstrate the use of class mediator to extend the mediation functionality 

========================= synapse sample_2236 =========================

public void destroy() {	if (dataSourceName != null) {	return;	}	if (this.dataSource instanceof BasicDataSource) {	try {	((BasicDataSource) this.dataSource).close();	
successfully shut down db connection pool for url 

public void destroy() {	if (dataSourceName != null) {	return;	}	if (this.dataSource instanceof BasicDataSource) {	try {	((BasicDataSource) this.dataSource).close();	} catch (SQLException e) {	
error shutting down db connection pool for url 

if (dataSourceName != null) {	return;	}	if (this.dataSource instanceof BasicDataSource) {	try {	((BasicDataSource) this.dataSource).close();	} catch (SQLException e) {	}	} else if (this.dataSource instanceof PerUserPoolDataSource) {	((PerUserPoolDataSource) this.dataSource).close();	
successfully shut down db connection pool for url 

public boolean mediate(MessageContext synCtx) {	String name = (this instanceof DBLookupMediator ? "DBLookup" : "DBReport");	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start mediator 

public boolean mediate(MessageContext synCtx) {	String name = (this instanceof DBLookupMediator ? "DBLookup" : "DBReport");	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	for (Statement aStatement : statementList) {	if (aStatement != null) {	processStatement(aStatement, synCtx);	}	}	if (synLog.isTraceOrDebugEnabled()) {	
end mediator 

protected PreparedStatement getPreparedStatement(Statement stmnt, Connection con, MessageContext msgCtx) throws SQLException {	SynapseLog synLog = getLog(msgCtx);	if (synLog.isTraceOrDebugEnabled()) {	
getting a connection from datasource and preparing statement 

int numActive = basicDataSource.getNumActive();	int numIdle = basicDataSource.getNumIdle();	String connectionId = Integer.toHexString(con.hashCode());	DBPoolView dbPoolView = getDbPoolView();	if (dbPoolView != null) {	dbPoolView.setNumActive(numActive);	dbPoolView.setNumIdle(numIdle);	dbPoolView.updateConnectionUsage(connectionId);	}	if (synLog.isTraceOrDebugEnabled()) {	
db connection 

int numActive = basicDataSource.getNumActive();	int numIdle = basicDataSource.getNumIdle();	String connectionId = Integer.toHexString(con.hashCode());	DBPoolView dbPoolView = getDbPoolView();	if (dbPoolView != null) {	dbPoolView.setNumActive(numActive);	dbPoolView.setNumIdle(numIdle);	dbPoolView.updateConnectionUsage(connectionId);	}	if (synLog.isTraceOrDebugEnabled()) {	
db connection instance identifier 

int numActive = basicDataSource.getNumActive();	int numIdle = basicDataSource.getNumIdle();	String connectionId = Integer.toHexString(con.hashCode());	DBPoolView dbPoolView = getDbPoolView();	if (dbPoolView != null) {	dbPoolView.setNumActive(numActive);	dbPoolView.setNumIdle(numIdle);	dbPoolView.updateConnectionUsage(connectionId);	}	if (synLog.isTraceOrDebugEnabled()) {	
number of active connection 

int numActive = basicDataSource.getNumActive();	int numIdle = basicDataSource.getNumIdle();	String connectionId = Integer.toHexString(con.hashCode());	DBPoolView dbPoolView = getDbPoolView();	if (dbPoolView != null) {	dbPoolView.setNumActive(numActive);	dbPoolView.setNumIdle(numIdle);	dbPoolView.updateConnectionUsage(connectionId);	}	if (synLog.isTraceOrDebugEnabled()) {	
number of idle connection 

}	PreparedStatement ps = con.prepareStatement(stmnt.getRawStatement());	List<Statement.Parameter> params = stmnt.getParameters();	int column = 1;	for (Statement.Parameter param : params) {	if (param == null) {	continue;	}	String value = (param.getPropertyName() != null ? param.getPropertyName() : param.getXpath().stringValueOf(msgCtx));	if (synLog.isTraceOrDebugEnabled()) {	
setting as parameter value as jdbc type see java sql types for valid types 

}	break;	}	default: {	String msg = "Trying to set an un-supported JDBC Type : " + param.getType() + " against column : " + column + " and statement : " + stmnt.getRawStatement() + " used by a DB mediator against DataSource : " + getDSName() + " (see java.sql.Types for valid type values)";	handleException(msg, msgCtx);	}	}	}	if (synLog.isTraceOrDebugEnabled()) {	
successfully prepared statement against datasource 

dataSource = DataSourceFinder.find(dataSourceName, jndiProperties);	if (dataSource == null) {	handleException("Cannot find a DataSource " + dataSourceName + " for given JNDI" + " properties :" + jndiProperties);	}	}	MBeanRepository mBeanRepository = DatasourceMBeanRepository.getInstance();	Object mBean = mBeanRepository.getMBean(dataSourceName);	if (mBean instanceof DBPoolView) {	setDbPoolView((DBPoolView) mBean);	}	
successfully looked up datasource 

protected DataSource createCustomDataSource(DataSourceInformation dataSourceInformation) {	DataSource dataSource = DataSourceFactory.createDataSource(dataSourceInformation);	if (dataSource != null) {	
successfully created data source for 

========================= synapse sample_1949 =========================

public void release() {	if (temporaryFile != null) {	if (log.isDebugEnabled()) {	
deleting temporary file 

protected void finalize() throws Throwable {	if (temporaryFile != null) {	
cleaning up unreleased temporary file 

========================= synapse sample_4024 =========================

public boolean process(SynapseEnvironment se, SynapseMessage smc) {	if (pattern == null) {	
trying to process with empty pattern 

return true;	}	String toMatch = null;	if (property != null) {	toMatch = smc.getProperty(property).toString();	} else {	toMatch = headerType.getHeader(smc);	}	if (toMatch==null) return true;	if (pattern.matcher(toMatch).matches()) {	
regex pattern matched 

========================= synapse sample_1363 =========================

if (o != null && o instanceof Entry) {	Entry entry = (Entry) o;	if (!entry.isDynamic() || (entry.isCached() && !entry.isExpired())) {	return entry.getValue();	}	if (registry != null) {	if (entry.isCached()) {	try {	o = registry.getResource(entry, getProperties());	} catch (Exception e) {	
error while loading the resource from the remote registry previously cached value will be used check the registry accessibility 

try {	o = registry.getResource(entry, getProperties());	} catch (Exception e) {	return entry.getValue();	}	} else {	o = registry.getResource(entry, getProperties());	}	} else {	if (entry.isCached()) {	
the registry is no longer available in the synapse configuration using the previously cached value for the resource 

return entry.getValue();	}	} else {	o = registry.getResource(entry, getProperties());	}	} else {	if (entry.isCached()) {	return entry.getValue();	} else {	if (log.isDebugEnabled()) {	
will not evaluate the value of the remote entry with a key because the registry is not available 

Entry entry = new Entry(key);	entry.setType(Entry.REMOTE_ENTRY);	addEntry(key, entry);	return entry;	}	}	}	return (Entry) o;	} else {	if (log.isDebugEnabled()) {	
there is no local registry entry for key 

public synchronized void init(SynapseEnvironment se) {	if (initialized) {	
attempted to re initialize synapseconfiguration 

public synchronized void init(SynapseEnvironment se) {	if (initialized) {	return;	}	if (log.isDebugEnabled()) {	
initializing the synapse configuration using the synapseenvironment 

public synchronized void destroy() {	if (!initialized) {	
attempted to destroy uninitialized synapseconfiguration 

public synchronized void destroy() {	if (!initialized) {	return;	}	if (log.isDebugEnabled()) {	
destroying the synapse configuration 

========================= synapse sample_1733 =========================

public static TaskDescription createTaskDescription(OMElement el, OMNamespace tagetNamespace) {	if (log.isDebugEnabled()) {	
creating simplequartz task 

OMAttribute classAttr = el.getAttribute(new QName("class"));	if (classAttr != null && classAttr.getAttributeValue() != null) {	String classname = classAttr.getAttributeValue();	try {	Class.forName(classname).newInstance();	} catch (Exception e) {	handleException("Failed to load task class " + classname, e);	}	taskDescription.setTaskClass(classname);	} else {	
taskclass cannot be found task implementation may need a task class if there is no default one 

========================= synapse sample_24 =========================

public boolean mediate(MessageContext synCtx) {	
filter mediator mediate 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	try {	if (shouldTrace) {	trace.trace("Start : Filter mediator ");	}	if (test(synCtx)) {	
filter condition satisfied executing child mediators 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	try {	if (shouldTrace) {	trace.trace("Start : Filter mediator ");	}	if (test(synCtx)) {	return super.mediate(synCtx);	} else {	
filter condition failed will skip executing child mediators 

public boolean test(MessageContext synCtx) {	try {	if (xpath != null) {	
evaluating xpath expression 

public boolean test(MessageContext synCtx) {	try {	if (xpath != null) {	if (shouldTrace(synCtx.getTracingState())) {	trace.trace("XPath expression : " + xpath + " evaluates to : " + xpath.booleanValueOf(synCtx.getEnvelope()));	}	return xpath.booleanValueOf(synCtx.getEnvelope());	} else if (source != null && regex != null) {	
evaluating regular expression against source 

trace.trace("XPath expression : " + xpath + " evaluates to : " + xpath.booleanValueOf(synCtx.getEnvelope()));	}	return xpath.booleanValueOf(synCtx.getEnvelope());	} else if (source != null && regex != null) {	String sourceString = Axis2MessageContext.getStringValue(source, synCtx);	if (shouldTrace(synCtx.getTracingState())) {	trace.trace("Regular expression : " + regex.pattern() + " and Source " + sourceString + " matches : " + regex.matcher(sourceString).matches());	}	return regex.matcher(sourceString).matches();	} else {	
invalid configuration specified 

} else if (source != null && regex != null) {	String sourceString = Axis2MessageContext.getStringValue(source, synCtx);	if (shouldTrace(synCtx.getTracingState())) {	trace.trace("Regular expression : " + regex.pattern() + " and Source " + sourceString + " matches : " + regex.matcher(sourceString).matches());	}	return regex.matcher(sourceString).matches();	} else {	return false;	}	} catch (JaxenException e) {	
xpath error 

========================= synapse sample_3061 =========================

break;	}	processor.tried++;	} while (processor.tried < processor.getRequiredInitMsgsDelay().get());	}	if (!processor.isInitSeqNo().get()) {	while (true) {	if (messageStore.size() > 0) {	selectStartingSeqNo(processor, messageStore, seqNoxPath);	if (!processor.isInitSeqNo().get()) {	
resequencer failed to select starting sequence number with in given timeout 

for (int messageIndex = 0; ; messageIndex++) {	MessageContext messageContext = messageStore.get(messageIndex);	if (messageContext == null) {	errorStop = true;	break;	}	int sequenceNo;	try {	sequenceNo = Integer.parseInt(seqNoxPath.stringValueOf(messageContext));	} catch (Exception e) {	
can t find sequence number from message 

private void delay(long timePeriod) {	try {	Thread.sleep(timePeriod);	} catch (InterruptedException e) {	
interrupted while thread sleeping in resequencer 

========================= synapse sample_584 =========================

public void run() {	while (true) {	if (completed) {	break;	}	if (getLock()) {	if (log.isDebugEnabled()) {	
time and this aggregator expired at 

========================= synapse sample_4198 =========================

public void send(MessageContext synCtx) {	if (log.isDebugEnabled()) {	
failover endpoint 

public void send(MessageContext synCtx) {	if (log.isDebugEnabled()) {	}	boolean isARetry = false;	if (synCtx.getProperty(SynapseConstants.LAST_ENDPOINT) == null) {	if (log.isDebugEnabled()) {	
building the soapenvelope 

public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {	logOnChildEndpointFail(endpoint, synMessageContext);	if (!((AbstractEndpoint)endpoint).isRetryDisabled(synMessageContext)) {	if (log.isDebugEnabled()) {	
retry attempt for request with message id to 

========================= synapse sample_1660 =========================

public Map<String, Map<String, InOutStatisticsView>> determineView( List<StatisticsRecord> statisticsRecords, ComponentType type, int userIDType) {	final Map<String, Map<String, InOutStatisticsView>> statisticsMap = new HashMap<String, Map<String, InOutStatisticsView>>();	if (statisticsRecords == null) {	if (log.isDebugEnabled()) {	
statistics records cannot be found 

for (StatisticsRecord record : statisticsRecords) {	if (record != null) {	String userID;	if (IP == userIDType) {	userID = record.getClientIP();	} else {	userID = record.getClientHost();	}	if (userID == null || "".equals(userID)) {	if (log.isDebugEnabled()) {	
user id cannot be found 

}	Map<String, InOutStatisticsView> perResourceMap;	if (statisticsMap.containsKey(userID)) {	perResourceMap = statisticsMap.get(userID);	} else {	perResourceMap = new HashMap<String, InOutStatisticsView>();	statisticsMap.put(userID, perResourceMap);	}	if (perResourceMap == null) {	if (log.isDebugEnabled()) {	
there are not statistics for user id 

public Map<String, InOutStatisticsView> determineView(String id, List<StatisticsRecord> statisticsRecords, ComponentType type, int userIDType) {	if (id == null || "".equals(id)) {	handleException("Resource Id cannot be null");	}	Map<String, InOutStatisticsView> statisticsMap = new HashMap<String, InOutStatisticsView>();	if (statisticsRecords == null) {	if (log.isDebugEnabled()) {	
statistics records cannot be found 

for (StatisticsRecord record : statisticsRecords) {	if (record != null) {	String userID;	if (IP == userIDType) {	userID = record.getClientIP();	} else {	userID = record.getClientHost();	}	if (userID == null || "".equals(userID)) {	if (log.isDebugEnabled()) {	
user id cannot be found 

========================= synapse sample_642 =========================

public static void main(String[] args) throws Exception {	if (args.length != 1 && args.length != 4 && args.length != 5 && args.length != 6) {	printUsage();	}	ServerManager serverManager = ServerManager.getInstance();	serverManager.setAxis2Repolocation(args[0]);	if (args.length == 1) {	
configuring server manager using deprecated system properties please update your configuration 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	
shutting down apache synapse 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	ServerManager.getInstance().stop();	
shutdown complete 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	ServerManager.getInstance().stop();	
halting jvm 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	ServerManager.getInstance().stop();	} catch (Exception e) {	
error occurred while shutting down apache synapse 

========================= synapse sample_4209 =========================

public void testLocalRegEntriesAndSchemaValidation() {	String addUrl = "http: String trpUrl = "http: String expectedError = "Invalid custom quote request";	StockQuoteSampleClient client = getStockQuoteClient();	
running test creating soap fault messages and changing the direction of a message 

public void testLocalRegEntriesAndSchemaValidation() {	String addUrl = "http: String trpUrl = "http: String expectedError = "Invalid custom quote request";	StockQuoteSampleClient client = getStockQuoteClient();	SampleClientResult result = client.requestStandardQuote(addUrl, trpUrl, null, "IBM",null);	assertFalse("Should not get a response", result.responseReceived());	Exception resultEx = result.getException();	assertNotNull("Did not receive expected error", resultEx);	
got an error as expected 

========================= synapse sample_2277 =========================

File synapseConfigLocation = new File(configFile);	if (!synapseConfigLocation.exists()) {	String message = "Unable to load the Synapse configuration from : " + configFile + ". Specified file not found";	log.fatal(message);	throw new SynapseException(message);	}	SynapseConfiguration synCfg = null;	if (synapseConfigLocation.isFile()) {	try {	synCfg = XMLConfigurationBuilder.getConfiguration( new FileInputStream(configFile), properties);	
loaded synapse configuration from 

}	SynapseConfiguration synCfg = null;	if (synapseConfigLocation.isFile()) {	try {	synCfg = XMLConfigurationBuilder.getConfiguration( new FileInputStream(configFile), properties);	} catch (Exception e) {	handleException("Could not initialize Synapse : " + e.getMessage(), e);	}	} else if (synapseConfigLocation.isDirectory()) {	synCfg = MultiXMLConfigurationBuilder.getConfiguration(configFile, properties);	
loaded synapse configuration from the artifact repository at 

handleException("Could not initialize Synapse : " + e.getMessage(), e);	}	} else if (synapseConfigLocation.isDirectory()) {	synCfg = MultiXMLConfigurationBuilder.getConfiguration(configFile, properties);	}	assert synCfg != null;	synCfg.setPathToConfigFile(new File(configFile).getAbsolutePath());	Registry localConfigReg = synCfg.getRegistry();	if (synCfg.getLocalRegistry().isEmpty() && synCfg.getProxyServices().isEmpty() && localConfigReg != null) {	if (log.isDebugEnabled()) {	
only the registry is defined in the synapse configuration trying to fetch a configuration from the registry 

if (synCfg.getLocalRegistry().isEmpty() && synCfg.getProxyServices().isEmpty() && localConfigReg != null) {	if (log.isDebugEnabled()) {	}	OMNode remoteConfigNode = localConfigReg.lookup("synapse.xml");	if (remoteConfigNode != null) {	try {	synCfg = XMLConfigurationBuilder.getConfiguration(SynapseConfigUtils .getStreamSource(remoteConfigNode).getInputStream(), properties);	if (synCfg.getRegistry() == null) {	synCfg.setRegistry(localConfigReg);	} else {	
registry declaration has been overwritten by the registry declaration found at the remote configuration 

try {	synCfg = XMLConfigurationBuilder.getConfiguration(SynapseConfigUtils .getStreamSource(remoteConfigNode).getInputStream(), properties);	if (synCfg.getRegistry() == null) {	synCfg.setRegistry(localConfigReg);	} else {	}	} catch (XMLStreamException xse) {	throw new SynapseException("Problem loading remote synapse.xml ", xse);	}	} else if (log.isDebugEnabled()) {	
couldn t find a synapse configuration on the registry 

========================= synapse sample_1908 =========================

private boolean isHotDeploymentEnabled() {	try {	return getSynapseConfiguration().isAllowHotUpdate();	} catch (DeploymentException e) {	
error while retrieving the synapseconfiguration 

public void deploy(DeploymentFileData deploymentFileData) throws DeploymentException {	String filename = SynapseArtifactDeploymentStore.getNormalizedAbsolutePath( deploymentFileData.getAbsolutePath());	if (log.isDebugEnabled()) {	
deployment of the synapse artifact from file started 

public void deploy(DeploymentFileData deploymentFileData) throws DeploymentException {	String filename = SynapseArtifactDeploymentStore.getNormalizedAbsolutePath( deploymentFileData.getAbsolutePath());	if (log.isDebugEnabled()) {	}	if (getServerContextInformation().getServerState() != ServerState.STARTED) {	if (log.isDebugEnabled()) {	
skipped the artifact deployment since the synapse server doesn t seem to be started yet from file 

String filename = SynapseArtifactDeploymentStore.getNormalizedAbsolutePath( deploymentFileData.getAbsolutePath());	if (log.isDebugEnabled()) {	}	if (getServerContextInformation().getServerState() != ServerState.STARTED) {	if (log.isDebugEnabled()) {	}	return;	}	if (!isHotDeploymentEnabled()) {	if (log.isDebugEnabled()) {	
hot deployment has been suspended ignoring 

return;	}	if (!isHotDeploymentEnabled()) {	if (log.isDebugEnabled()) {	}	return;	}	SynapseArtifactDeploymentStore deploymentStore = getSynapseConfiguration().getArtifactDeploymentStore();	if (deploymentStore.isRestoredFile(filename)) {	if (log.isDebugEnabled()) {	
restored artifact detected with filename 

}	try {	InputStream in = FileUtils.openInputStream(new File(filename));	try {	OMElement element = OMXMLBuilderFactory.createOMBuilder(in).getDocumentElement();	Properties properties = new Properties();	properties.put(SynapseConstants.RESOLVE_ROOT, getSynapseEnvironment() .getServerContextInformation() .getServerConfigurationInformation().getResolveRoot());	String artifactName = null;	if (deploymentStore.isUpdatingArtifact(filename)) {	if (log.isDebugEnabled()) {	
updating artifact detected with filename 

properties.put(SynapseConstants.RESOLVE_ROOT, getSynapseEnvironment() .getServerContextInformation() .getServerConfigurationInformation().getResolveRoot());	String artifactName = null;	if (deploymentStore.isUpdatingArtifact(filename)) {	if (log.isDebugEnabled()) {	}	String existingArtifactName = deploymentStore.getUpdatingArtifactWithFileName(filename);	deploymentStore.removeUpdatingArtifact(filename);	try {	artifactName = updateSynapseArtifact( element, filename, existingArtifactName, properties);	} catch (SynapseArtifactDeploymentException sade) {	
update of the synapse artifact from file failed 

properties.put(SynapseConstants.RESOLVE_ROOT, getSynapseEnvironment() .getServerContextInformation() .getServerConfigurationInformation().getResolveRoot());	String artifactName = null;	if (deploymentStore.isUpdatingArtifact(filename)) {	if (log.isDebugEnabled()) {	}	String existingArtifactName = deploymentStore.getUpdatingArtifactWithFileName(filename);	deploymentStore.removeUpdatingArtifact(filename);	try {	artifactName = updateSynapseArtifact( element, filename, existingArtifactName, properties);	} catch (SynapseArtifactDeploymentException sade) {	
the updated file has been backed up into 

properties.put(SynapseConstants.RESOLVE_ROOT, getSynapseEnvironment() .getServerContextInformation() .getServerConfigurationInformation().getResolveRoot());	String artifactName = null;	if (deploymentStore.isUpdatingArtifact(filename)) {	if (log.isDebugEnabled()) {	}	String existingArtifactName = deploymentStore.getUpdatingArtifactWithFileName(filename);	deploymentStore.removeUpdatingArtifact(filename);	try {	artifactName = updateSynapseArtifact( element, filename, existingArtifactName, properties);	} catch (SynapseArtifactDeploymentException sade) {	
restoring the existing artifact into the file 

try {	artifactName = updateSynapseArtifact( element, filename, existingArtifactName, properties);	} catch (SynapseArtifactDeploymentException sade) {	restoreSynapseArtifact(existingArtifactName);	artifactName = existingArtifactName;	}	} else {	try {	artifactName = deploySynapseArtifact(element, filename, properties);	} catch (SynapseArtifactDeploymentException sade) {	
deployment of the synapse artifact from file failed 

try {	artifactName = updateSynapseArtifact( element, filename, existingArtifactName, properties);	} catch (SynapseArtifactDeploymentException sade) {	restoreSynapseArtifact(existingArtifactName);	artifactName = existingArtifactName;	}	} else {	try {	artifactName = deploySynapseArtifact(element, filename, properties);	} catch (SynapseArtifactDeploymentException sade) {	
the file has been backed up into 

}	} finally {	in.close();	}	} catch (IOException ex) {	handleDeploymentError("Deployment of synapse artifact failed. Error reading " + filename + " : " + ex.getMessage(), ex, filename);	} catch (OMException ex) {	handleDeploymentError("Deployment of synapse artifact failed. Error parsing " + filename + " : " + ex.getMessage(), ex, filename);	}	if (log.isDebugEnabled()) {	
deployment of the synapse artifact from file completed 

public void undeploy(String fileName) throws DeploymentException {	if (!isHotDeploymentEnabled()) {	if (log.isDebugEnabled()) {	
hot deployment has been suspended ignoring 

public void undeploy(String fileName) throws DeploymentException {	if (!isHotDeploymentEnabled()) {	if (log.isDebugEnabled()) {	}	return;	}	fileName = SynapseArtifactDeploymentStore.getNormalizedAbsolutePath(fileName);	if (log.isDebugEnabled()) {	
undeployment of the synapse artifact from file started 

if (log.isDebugEnabled()) {	}	return;	}	fileName = SynapseArtifactDeploymentStore.getNormalizedAbsolutePath(fileName);	if (log.isDebugEnabled()) {	}	SynapseArtifactDeploymentStore deploymentStore = getSynapseConfiguration().getArtifactDeploymentStore();	if (deploymentStore.isBackedUpArtifact(fileName)) {	if (log.isDebugEnabled()) {	
backedup artifact detected with filename 

if (deploymentStore.isBackedUpArtifact(fileName)) {	if (log.isDebugEnabled()) {	}	deploymentStore.removeBackedUpArtifact(fileName);	return;	}	if (deploymentStore.containsFileName(fileName)) {	File undeployingFile = new File(fileName);	if (undeployingFile.exists()) {	if (log.isDebugEnabled()) {	
marking artifact as updating from file 

if (!deploymentStore.isRestoredFile(fileName)) {	deploymentStore.addUpdatingArtifact( fileName, deploymentStore.getArtifactNameForFile(fileName));	deploymentStore.removeArtifactWithFileName(fileName);	}	} else {	String artifactName = deploymentStore.getArtifactNameForFile(fileName);	try {	undeploySynapseArtifact(artifactName);	deploymentStore.removeArtifactWithFileName(fileName);	} catch (SynapseArtifactDeploymentException sade) {	
unable to undeploy the artifact from file 

if (!deploymentStore.isRestoredFile(fileName)) {	deploymentStore.addUpdatingArtifact( fileName, deploymentStore.getArtifactNameForFile(fileName));	deploymentStore.removeArtifactWithFileName(fileName);	}	} else {	String artifactName = deploymentStore.getArtifactNameForFile(fileName);	try {	undeploySynapseArtifact(artifactName);	deploymentStore.removeArtifactWithFileName(fileName);	} catch (SynapseArtifactDeploymentException sade) {	
restoring the artifact into the file 

} catch (SynapseArtifactDeploymentException sade) {	restoreSynapseArtifact(artifactName);	}	}	} else {	String msg = "Artifact representing the filename " + fileName + " is not deployed on Synapse";	log.error(msg);	throw new DeploymentException(msg);	}	if (log.isDebugEnabled()) {	
undeployment of the synapse artifact from file completed 

private void handleDeploymentError(String msg, Exception e, String fileName) throws DeploymentException {	fileName = SynapseArtifactDeploymentStore.getNormalizedAbsolutePath(fileName);	log.error(msg, e);	SynapseArtifactDeploymentStore deploymentStore = getSynapseConfiguration().getArtifactDeploymentStore();	if (deploymentStore.isUpdatingArtifact(fileName)) {	backupFile(new File(fileName));	
restoring the existing artifact into the file 

========================= synapse sample_183 =========================

if (nameAtt != null) {	synapseImport.setLibName(nameAtt.getAttributeValue());	} else {	handleException("Synapse Import Target Library name is not specified");	}	if (pkgAtt != null) {	synapseImport.setLibPackage(pkgAtt.getAttributeValue());	} else {	handleException("Synapse Import Target Library package is not specified");	}	
successfully created synapse import 

========================= synapse sample_479 =========================

protected static File preparePath(VFSTestEnvironment env, String path) {	File file = new File(env.getRootDir(), path);	File dir = file.getParentFile();	if (dir.exists()) {	
deleting leftover file 

protected static File preparePath(VFSTestEnvironment env, String path) {	File file = new File(env.getRootDir(), path);	File dir = file.getParentFile();	if (dir.exists()) {	file.delete();	} else {	
creating directory 

========================= synapse sample_2298 =========================

public void handleRequest(HttpRequest request) {	
got new async http request for on port 

========================= synapse sample_3173 =========================

public InputSource resolve(SynapseConfiguration synCfg, String location) {	String key = (String)resources.get(location);	if (key == null) {	if (log.isDebugEnabled()) {	
no resource mapping is defined for location 

public InputSource resolve(SynapseConfiguration synCfg, String location) {	String key = (String)resources.get(location);	if (key == null) {	if (log.isDebugEnabled()) {	}	return null;	} else {	if (log.isDebugEnabled()) {	
resolving location to registry item 

========================= synapse sample_3489 =========================

public BinaryExtractMediator(){}	public boolean mediate(MessageContext msgCtx) {	try {	
binaryextractmediator process with offset length 

public BinaryExtractMediator(){}	public boolean mediate(MessageContext msgCtx) {	try {	SOAPBody soapBody = msgCtx.getEnvelope().getBody();	OMElement firstElement = soapBody.getFirstElement();	
first element 

public BinaryExtractMediator(){}	public boolean mediate(MessageContext msgCtx) {	try {	SOAPBody soapBody = msgCtx.getEnvelope().getBody();	OMElement firstElement = soapBody.getFirstElement();	
first element text 

public BinaryExtractMediator(){}	public boolean mediate(MessageContext msgCtx) {	try {	SOAPBody soapBody = msgCtx.getEnvelope().getBody();	OMElement firstElement = soapBody.getFirstElement();	OMText binaryNode =(OMText) firstElement.getFirstOMChild();	
first element node text 

DataHandler dataHandler =(DataHandler) binaryNode.getDataHandler();	InputStream inputStream = dataHandler.getInputStream();	byte[] searchByte = new byte[length];	inputStream.skip(offset - 1);	int readBytes = inputStream.read(searchByte,0,length);	String outString = new String(searchByte,binaryEncoding);	msgCtx.setProperty(variableName,outString);	log.debug("Set property to MsgCtx, "+variableName+" = "+outString);	inputStream.close();	} catch (IOException e) {	
excepton on mediation 

========================= synapse sample_1267 =========================

public void init(SynapseConfiguration synCfg, ServerContextInformation contextInformation) {	if (initialized) {	
attempted to re initialize synapsecallbackreceiver 

public void init(SynapseConfiguration synCfg, ServerContextInformation contextInformation) {	if (initialized) {	return;	}	if (log.isDebugEnabled()) {	
initializing synapsecallbackreceiver 

public void destroy() {	if (!initialized) {	
attempted to destroy uninitialized synapsecallbackreceiver 

public void destroy() {	if (!initialized) {	return;	}	if (log.isDebugEnabled()) {	
destroying synapsecallbackreceiver 

public void addCallback(String MsgID, AxisCallback callback) {	callbackStore.put(MsgID, callback);	if (log.isDebugEnabled()) {	
callback added total callbacks waiting for 

public void receive(MessageContext messageCtx) throws AxisFault {	String messageID = null;	if (messageCtx.getProperty(NhttpConstants.HTTP_202_RECEIVED) != null && "true".equals( messageCtx.getProperty(NhttpConstants.HTTP_202_RECEIVED))) {	if (callbackStore.containsKey(messageCtx.getMessageID())) {	callbackStore.remove(messageCtx.getMessageID());	if (log.isDebugEnabled()) {	
callback registered with message id removed from the callback store since we got an accepted notification 

if (relatesTo != null) {	messageID = relatesTo.getValue();	}	}	} else {	messageID = (String) messageCtx.getProperty(SynapseConstants.RELATES_TO_FOR_POX);	}	if (messageID != null) {	AxisCallback callback = callbackStore.remove(messageID);	if (log.isDebugEnabled()) {	
callback removed for request message id pending callbacks count 

AxisCallback callback = callbackStore.remove(messageID);	if (log.isDebugEnabled()) {	}	RelatesTo[] relates = messageCtx.getRelationships();	if (relates != null && relates.length > 1) {	removeDuplicateRelatesTo(messageCtx, relates);	}	if (callback != null) {	handleMessage(messageID, messageCtx, ((AsyncCallback) callback).getSynapseOutMsgCtx(), (AsyncCallback)callback);	} else {	
synapse received a response for the request with message id but a callback is not registered anymore to process this response 

}	RelatesTo[] relates = messageCtx.getRelationships();	if (relates != null && relates.length > 1) {	removeDuplicateRelatesTo(messageCtx, relates);	}	if (callback != null) {	handleMessage(messageID, messageCtx, ((AsyncCallback) callback).getSynapseOutMsgCtx(), (AsyncCallback)callback);	} else {	}	} else if (!messageCtx.isPropertyTrue(NhttpConstants.SC_ACCEPTED)){	
synapse received a response message without a message id 

} catch (OMException x) {	synapseOutMsgCtx.setEnvelope(response.getEnvelope());	}	Exception e = (Exception) response.getProperty(SynapseConstants.ERROR_EXCEPTION);	synapseOutMsgCtx.setProperty(SynapseConstants.SENDING_FAULT, Boolean.TRUE);	synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_CODE, response.getProperty(SynapseConstants.ERROR_CODE));	synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_MESSAGE, response.getProperty(SynapseConstants.ERROR_MESSAGE));	synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_DETAIL, response.getProperty(SynapseConstants.ERROR_DETAIL));	synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, e);	if (log.isDebugEnabled()) {	
failed request message id new to be retried request message id 

Exception e = (Exception) response.getProperty(SynapseConstants.ERROR_EXCEPTION);	synapseOutMsgCtx.setProperty(SynapseConstants.SENDING_FAULT, Boolean.TRUE);	synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_CODE, response.getProperty(SynapseConstants.ERROR_CODE));	synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_MESSAGE, response.getProperty(SynapseConstants.ERROR_MESSAGE));	synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_DETAIL, response.getProperty(SynapseConstants.ERROR_DETAIL));	synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, e);	if (log.isDebugEnabled()) {	}	int errorCode = (Integer)response.getProperty(SynapseConstants.ERROR_CODE);	if (errorCode == SynapseConstants.NHTTP_CONNECTION_TIMEOUT && callback.getTimeOutAction() == SynapseConstants.DISCARD) {	
synapse timed out for the request with message id ignoring fault handlers since the timeout action is discard 

((FaultHandler) faultStack.pop()).handleFault(synapseOutMsgCtx, null);	}	}	} else {	Stack faultStack = synapseOutMsgCtx.getFaultStack();	if (faultStack != null && !faultStack.isEmpty() && faultStack.peek() instanceof Endpoint) {	Endpoint successfulEndpoint = (Endpoint) faultStack.pop();	successfulEndpoint.onSuccess();	}	if (log.isDebugEnabled()) {	
synapse received an asynchronous response message 

Endpoint successfulEndpoint = (Endpoint) faultStack.pop();	successfulEndpoint.onSuccess();	}	if (log.isDebugEnabled()) {	log.debug("Received To: " + (response.getTo() != null ? response.getTo().getAddress() : "null"));	log.debug("SOAPAction: " + (response.getSoapAction() != null ? response.getSoapAction() : "null"));	log.debug("WSA-Action: " + (response.getWSAAction() != null ? response.getWSAAction() : "null"));	String[] cids = response.getAttachmentMap().getAllContentIDs();	if (cids != null && cids.length > 0) {	for (String cid : cids) {	
attachment 

}	if (log.isDebugEnabled()) {	log.debug("Received To: " + (response.getTo() != null ? response.getTo().getAddress() : "null"));	log.debug("SOAPAction: " + (response.getSoapAction() != null ? response.getSoapAction() : "null"));	log.debug("WSA-Action: " + (response.getWSAAction() != null ? response.getWSAAction() : "null"));	String[] cids = response.getAttachmentMap().getAllContentIDs();	if (cids != null && cids.length > 0) {	for (String cid : cids) {	}	}	
body 

dispatcher.updateSession(synapseInMessageContext);	}	StatisticsReporter.reportForAllOnResponseReceived(synapseInMessageContext);	try {	synapseOutMsgCtx.getEnvironment().injectMessage(synapseInMessageContext);	} catch (SynapseException syne) {	Stack stack = synapseInMessageContext.getFaultStack();	if (stack != null && !stack.isEmpty()) {	((FaultHandler) stack.pop()).handleFault(synapseInMessageContext, syne);	} else {	
synapse encountered an exception no error handlers found message dropped 

========================= synapse sample_1637 =========================

useFallbackBuilder = JavaUtils.isTrueExplicitly(useFallbackParameter.getValue(), useFallbackBuilder);	}	OMElement element = null;	Builder builder;	if (contentType != null) {	builder = configuration.getMessageBuilder(_contentType, useFallbackBuilder);	if (builder != null) {	try {	element = builder.processDocument(in, contentType, msgCtx);	} catch (AxisFault axisFault) {	
error building message 

}	}	if (element == null) {	if (msgCtx.isDoingREST()) {	element = BuilderUtil.createPOXBuilder(in, null).getDocumentElement();	} else {	builder = new SOAPBuilder();	try {	element = builder.processDocument(in, contentType, msgCtx);	} catch (AxisFault axisFault) {	
error building message using soap builder 

========================= synapse sample_2349 =========================

private static String getArgument(CommandLine cmd, String argName, String defaultValue) {	if (cmd == null) {	handleException("CommandLine is null");	}	if (argName == null || "".equals(argName)) {	if (log.isDebugEnabled()) {	
provided argument name is null returning null as value 

private static boolean isArgumentPresent(CommandLine cmd, String argName) {	if (cmd == null) {	handleException("CommandLine is null");	}	if (argName == null || "".equals(argName)) {	if (log.isDebugEnabled()) {	
provided argument name is null returning null as value 

========================= synapse sample_1135 =========================

public void testDbLookupReport() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test action of dbreport and dblookup mediators together 

public void testDbLookupReport() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	result = client.requestStandardQuote(addUrl, trpUrl, null, "IBM" ,null);	assertTrue("Client did not get run successfully ", result.responseReceived());	
running test introduction to the dblookup mediator 

========================= synapse sample_814 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synapseLog = getLog(synCtx);	boolean isTraceOrDebugEnabled = synapseLog.isTraceOrDebugEnabled();	if (isTraceOrDebugEnabled) {	
start respond mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synapseLog = getLog(synCtx);	boolean isTraceOrDebugEnabled = synapseLog.isTraceOrDebugEnabled();	if (isTraceOrDebugEnabled) {	if (synapseLog.isTraceTraceEnabled()) {	
message 

SynapseLog synapseLog = getLog(synCtx);	boolean isTraceOrDebugEnabled = synapseLog.isTraceOrDebugEnabled();	if (isTraceOrDebugEnabled) {	if (synapseLog.isTraceTraceEnabled()) {	}	}	synCtx.setTo(null);	synCtx.setResponse(true);	Axis2Sender.sendBack(synCtx);	if (isTraceOrDebugEnabled) {	
end respond mediator 

========================= synapse sample_547 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start mediation using sequence message is a response request 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	boolean result = super.mediate(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	boolean result = super.mediate(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	
end mediation using sequence 

========================= synapse sample_1973 =========================

public void init(DataSourceInformationRepository repository, Properties properties) {	if (initialized) {	if (log.isDebugEnabled()) {	
data source repository holder has already been initialized 

public void init(DataSourceInformationRepository repository, Properties properties) {	if (initialized) {	if (log.isDebugEnabled()) {	}	return;	}	if (log.isDebugEnabled()) {	
initializing the data source repository holder 

========================= synapse sample_2125 =========================

public void init(SynapseEnvironment se) {	if (log.isDebugEnabled()) {	
initializing child mediators 

public void destroy() {	if (log.isDebugEnabled()) {	
destroying child mediators 

========================= synapse sample_3671 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start bean mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	boolean output = false;	switch (action) {	case CREATE: if (synLog.isTraceOrDebugEnabled()) {	
creating a new bean of type with var name 

if (synLog.isTraceTraceEnabled()) {	}	}	boolean output = false;	switch (action) {	case CREATE: if (synLog.isTraceOrDebugEnabled()) {	}	output = mediateCreateBeanAction(synCtx);	break;	case REMOVE: if (synLog.isTraceOrDebugEnabled()) {	
removing the bean with var name 

switch (action) {	case CREATE: if (synLog.isTraceOrDebugEnabled()) {	}	output = mediateCreateBeanAction(synCtx);	break;	case REMOVE: if (synLog.isTraceOrDebugEnabled()) {	}	output = mediateRemoveBeanAction(synCtx);	break;	case SET_PROPERTY: if (synLog.isTraceOrDebugEnabled()) {	
setting property of the bean with var name 

break;	case REMOVE: if (synLog.isTraceOrDebugEnabled()) {	}	output = mediateRemoveBeanAction(synCtx);	break;	case SET_PROPERTY: if (synLog.isTraceOrDebugEnabled()) {	}	output = mediateSetPropertyAction(synCtx);	break;	case GET_PROPERTY: if (synLog.isTraceOrDebugEnabled()) {	
retrieving property of the bean with var name 

}	output = mediateSetPropertyAction(synCtx);	break;	case GET_PROPERTY: if (synLog.isTraceOrDebugEnabled()) {	}	output = mediateGetPropertyAction(synCtx);	break;	default: assert false;	}	if (synLog.isTraceOrDebugEnabled()) {	
end bean mediator 

========================= synapse sample_1924 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start eip sequence paramnames 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

========================= synapse sample_510 =========================

if (param != null) {	bindAddress = ((String) param.getValue()).trim();	}	param = transportIn.getParameter(TransportListener.HOST_ADDRESS);	if (param != null) {	host = ((String) param.getValue()).trim();	} else {	try {	host = InetAddress.getLocalHost().getHostName();	} catch (UnknownHostException e) {	
unable to lookup local host name using localhost 

if (defPriorityAttr != null) {	parser = new Parser(Integer.parseInt(defPriorityAttr.getAttributeValue()));	} else {	parser = new Parser();	}	try {	parser.init(conditionsElem);	} catch (EvaluatorException e) {	handleException("Invalid " + EvaluatorConstants.CONDITIONS + " configuration for priority based mediation", e);	}	
created a priority based executor from the configuration 

========================= synapse sample_1027 =========================

} catch (Exception e) {	handleException("Error while creating FIX SOAP envelope", e);	}	try {	message = new quickfix.Message(messageString.toString(), null, false);	} catch (InvalidMessage e) {	handleException("Error while creating FIX SOAP envelope", e);	return null;	}	if (log.isDebugEnabled()) {	
creating soap envelope for fix message 

========================= synapse sample_2488 =========================

public void timeout(final NHttpServerConnection conn) {	HttpRequest req = (HttpRequest) conn.getContext().getAttribute( ExecutionContext.HTTP_REQUEST);	if (req != null) {	if (log.isDebugEnabled()) {	
connection timeout for request to probably the keepalive connection was closed 

public void timeout(final NHttpServerConnection conn) {	HttpRequest req = (HttpRequest) conn.getContext().getAttribute( ExecutionContext.HTTP_REQUEST);	if (req != null) {	if (log.isDebugEnabled()) {	}	} else {	
connection timeout 

public void connected(final NHttpServerConnection conn) {	if (log.isTraceEnabled()) {	
new incoming connection 

public void closed(final NHttpServerConnection conn) {	if (log.isTraceEnabled()) {	
connection closed 

public void exception(NHttpServerConnection conn, IOException e) {	if (e instanceof ConnectionClosedException || e.getMessage().contains("Connection reset by peer") || e.getMessage().contains("forcibly closed")) {	if (log.isDebugEnabled()) {	
i o error probably the keepalive connection was closed 

public void exception(NHttpServerConnection conn, IOException e) {	if (e instanceof ConnectionClosedException || e.getMessage().contains("Connection reset by peer") || e.getMessage().contains("forcibly closed")) {	if (log.isDebugEnabled()) {	}	} else {	
i o error 

========================= synapse sample_3763 =========================

public boolean mediate(MessageContext synCtx) {	
in mediator mediate 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	try {	if (shouldTrace) {	trace.trace("Start : In mediator");	}	if (test(synCtx)) {	
current message is incoming executing child mediators 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	try {	if (shouldTrace) {	trace.trace("Start : In mediator");	}	if (test(synCtx)) {	return super.mediate(synCtx);	} else {	
current message is not incoming skipping child mediators 

========================= synapse sample_3299 =========================

Random random = new Random();	byte[] lockValue = String.valueOf(random.nextLong()).getBytes();	try {	String fullPath = fo.getName().getURI();	int pos = fullPath.indexOf("?");	if (pos != -1) {	fullPath = fullPath.substring(0, pos);	}	FileObject lockObject = fsManager.resolveFile(fullPath + ".lock");	if (lockObject.exists()) {	
there seems to be an external lock aborting the processing of the file this could possibly be due to some other party already processing this file or the file is still being uploaded 

if (lockObject.exists()) {	} else {	lockObject.createFile();	OutputStream stream = lockObject.getContent().getOutputStream();	try {	stream.write(lockValue);	stream.flush();	stream.close();	} catch (IOException e) {	lockObject.delete();	
couldn t create the lock file before processing the file 

return false;	} finally {	lockObject.close();	}	FileObject verifyingLockObject = fsManager.resolveFile( fullPath + ".lock");	if (verifyingLockObject.exists() && verifyLock(lockValue, verifyingLockObject)) {	return true;	}	}	} catch (FileSystemException fse) {	
cannot get the lock for the file before processing 

String fullPath = fo.getName().getURI();	int pos = fullPath.indexOf("?");	if (pos > -1) {	fullPath = fullPath.substring(0, pos);	}	FileObject lockObject = fsManager.resolveFile(fullPath + ".lock");	if (lockObject.exists()) {	lockObject.delete();	}	} catch (FileSystemException e) {	
couldn t release the lock for the file after processing 

private static boolean verifyLock(byte[] lockValue, FileObject lockObject) {	try {	InputStream is = lockObject.getContent().getInputStream();	byte[] val = new byte[lockValue.length];	is.read(val);	if (Arrays.equals(lockValue, val) && is.read() == -1) {	return true;	} else {	
the lock has been acquired by an another party 

private static boolean verifyLock(byte[] lockValue, FileObject lockObject) {	try {	InputStream is = lockObject.getContent().getInputStream();	byte[] val = new byte[lockValue.length];	is.read(val);	if (Arrays.equals(lockValue, val) && is.read() == -1) {	return true;	} else {	}	} catch (FileSystemException e) {	
couldn t verify the lock 

InputStream is = lockObject.getContent().getInputStream();	byte[] val = new byte[lockValue.length];	is.read(val);	if (Arrays.equals(lockValue, val) && is.read() == -1) {	return true;	} else {	}	} catch (FileSystemException e) {	return false;	} catch (IOException e) {	
couldn t verify the lock 

========================= synapse sample_2308 =========================

public static void setStaticProperty(OMElement property, Object o) {	if (property.getLocalName().toLowerCase().equals("property")) {	String propertyName = property.getAttributeValue(new QName("name"));	String mName = "set" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1);	if (property.getAttributeValue(new QName("value")) != null) {	String value = property.getAttributeValue(new QName("value"));	try {	Method method = o.getClass().getMethod(mName, String.class);	if (log.isDebugEnabled()) {	
setting property invoking method 

method.invoke(o, value);	} catch (Exception e) {	handleException("Error setting property : " + propertyName + " as a String property into class mediator : " + o.getClass() + " : " + e.getMessage(), e);	}	} else {	OMElement value = property.getFirstElement();	if (value != null) {	try {	Method method = o.getClass().getMethod(mName, OMElement.class);	if (log.isDebugEnabled()) {	
setting property invoking method 

========================= synapse sample_1877 =========================

}	EvaluatorContext evaluatorContext = new EvaluatorContext(request.getRequestLine().getUri(), headers);	int priority = parser.parse(evaluatorContext);	executor.execute(worker, priority);	}	Header expect = request.getFirstHeader(HTTP.EXPECT_DIRECTIVE);	if (expect != null && HTTP.EXPECT_CONTINUE.equalsIgnoreCase(expect.getValue())) {	HttpResponse ack = new BasicHttpResponse(request.getProtocolVersion(), HttpStatus.SC_CONTINUE, "Continue");	conn.submitResponse(ack);	if (log.isDebugEnabled()) {	
expect continue hit sending ack back to the server 

public void timeout(final NHttpServerConnection conn) {	HttpContext context = conn.getContext();	Boolean read = (Boolean) context.getAttribute(NhttpConstants.REQUEST_READ);	if (read == null || read) {	if (log.isDebugEnabled()) {	
keepalive connection was closed 

public void connected(final NHttpServerConnection conn) {	if (log.isTraceEnabled()) {	
new incoming connection 

public void connected(final NHttpServerConnection conn) {	if (log.isTraceEnabled()) {	}	metrics.connected();	conn.getContext().setAttribute(CONNECTION_CREATION_TIME, System.currentTimeMillis());	if (log.isDebugEnabled()) {	
adding a connection to the pool existing pool size 

public void responseReady(NHttpServerConnection conn) {	if (JavaUtils.isTrueExplicitly(conn.getContext().getAttribute(NhttpConstants.FORCE_CLOSING)) && !JavaUtils.isTrueExplicitly(conn.getContext().getAttribute( NhttpConstants.MESSAGE_IN_FLIGHT))) {	try {	if (log.isDebugEnabled()) {	
closing a persisted connection since it is forced 

}	conn.close();	} catch (IOException ignore) {}	return;	}	metrics.notifyReceivedMessageSize(conn.getMetrics().getReceivedBytesCount());	metrics.notifySentMessageSize(conn.getMetrics().getSentBytesCount());	conn.getMetrics().reset();	conn.getContext().removeAttribute(NhttpConstants.MESSAGE_IN_FLIGHT);	if (log.isTraceEnabled()) {	
ready to send response 

public void closed(final NHttpServerConnection conn) {	HttpContext context = conn.getContext();	shutdownConnection(conn, false, null);	context.removeAttribute(REQUEST_SINK_BUFFER);	context.removeAttribute(RESPONSE_SOURCE_BUFFER);	context.removeAttribute(CONNECTION_CREATION_TIME);	context.removeAttribute(SERVER_CONNECTION_DEBUG);	if (log.isTraceEnabled()) {	
connection closed 

public void markActiveConnectionsToBeClosed() {	
marking the closing signal on the connection pool of size 

public void exception(final NHttpServerConnection conn, final HttpException e) {	if (log.isDebugEnabled()) {	
http protocol error encountered in serverhandler 

msg = "Connection from remote address : " + httpContext.getAttribute(NhttpConstants.CLIENT_REMOTE_ADDR) + ":" + httpContext.getAttribute(NhttpConstants.CLIENT_REMOTE_PORT) + " to local address : " + inetConnection.getLocalAddress() + ":" + inetConnection.getLocalPort() + " is closed!" + (errorMsg != null ? " - On error : " + errorMsg : "");	}	if (isError) {	log.warn(msg);	} else {	log.debug(msg);	}	}	synchronized (this) {	if (activeConnections.remove(conn) && log.isDebugEnabled()) {	
removing the connection from pool of size 

========================= synapse sample_1031 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start pojocommand mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	if (synLog.isTraceOrDebugEnabled()) {	
creating a new instance of pojo class 

}	}	if (synLog.isTraceOrDebugEnabled()) {	}	Object commandObject = null;	try {	commandObject = command.newInstance();	} catch (Exception e) {	handleException("Error creating an instance of the POJO command class : " + command.getClass(), e, synCtx);	}	
instance created setting static and dynamic properties 

PropertyHelper.setInstanceProperty(name, staticSetterProperties.get(name), commandObject);	}	for (String name : contextSetterProperties.keySet()) {	PropertyHelper.setInstanceProperty(name, synCtx.getProperty(contextSetterProperties.get(name)), commandObject);	}	for (String name : messageSetterProperties.keySet()) {	SynapseXPath xpath = messageSetterProperties.get(name);	String value = xpath.stringValueOf(synCtx);	PropertyHelper.setInstanceProperty(name, value, commandObject);	}	
pojo initialized successfully invoking the execute method 

Object o = list.get(0);	if (resultValue instanceof String) {	OMAbstractFactory.getOMFactory().createOMText( ((OMNode) o).getParent(), (String) resultValue);	((OMNode) o).detach();	} else if (resultValue instanceof OMNode) {	((OMNode) o).insertSiblingAfter((OMNode) resultValue);	((OMNode) o).detach();	}	} else {	if (synLog.isTraceOrDebugEnabled()) {	
unable to set the message property back to the message specified element by the xpath can not be found 

((OMNode) o).detach();	}	} else {	if (synLog.isTraceOrDebugEnabled()) {	}	}	} catch (JaxenException e) {	handleException("Unable to set the command property " + name + " back to the message", e, synCtx);	}	}	
end pojocommand mediator 

========================= synapse sample_506 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start eip sequence paramnames 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

========================= synapse sample_1932 =========================

public Object getProperty(Property dp) {	OMNode omNode = null;	RegistryEntry re = null;	if (dp.isCached() && !dp.isExpired()) {	return dp.getValue();	} else if (!dp.isCached()) {	omNode = lookup(dp.getKey());	re = getRegistryEntry(dp.getKey());	} else if (dp.isExpired()) {	
cached object has expired for key 

OMNode omNode = null;	RegistryEntry re = null;	if (dp.isCached() && !dp.isExpired()) {	return dp.getValue();	} else if (!dp.isCached()) {	omNode = lookup(dp.getKey());	re = getRegistryEntry(dp.getKey());	} else if (dp.isExpired()) {	re = getRegistryEntry(dp.getKey());	if (re.getVersion() != Long.MIN_VALUE && re.getVersion() == dp.getVersion()) {	
expired version number is same as current version in registry 

RegistryEntry re = null;	if (dp.isCached() && !dp.isExpired()) {	return dp.getValue();	} else if (!dp.isCached()) {	omNode = lookup(dp.getKey());	re = getRegistryEntry(dp.getKey());	} else if (dp.isExpired()) {	re = getRegistryEntry(dp.getKey());	if (re.getVersion() != Long.MIN_VALUE && re.getVersion() == dp.getVersion()) {	dp.setExpiryTime( System.currentTimeMillis() + re.getCachableDuration());	
renew cache lease for another s 

========================= synapse sample_3325 =========================

public void init(ConfigurationContext cfgCtx, TransportInDescription trpInDesc) throws AxisFault {	setTransportName(TRANSPORT_NAME);	super.init(cfgCtx, trpInDesc);	loadConnectionFactoryDefinitions(trpInDesc);	if (connectionFactories.isEmpty()) {	
no jms connection factories are defined cannot listen for jms 

public void init(ConfigurationContext cfgCtx, TransportInDescription trpInDesc) throws AxisFault {	setTransportName(TRANSPORT_NAME);	super.init(cfgCtx, trpInDesc);	loadConnectionFactoryDefinitions(trpInDesc);	if (connectionFactories.isEmpty()) {	return;	}	
jms transport receiver listener initialized 

JMSConnectionFactory cf = getConnectionFactory(service);	if (cf == null) {	String msg = "Service " + service.getName() + " does not specify" + "a JMS connection factory or refers to an invalid factory. " + "This service is being marked as faulty and will not be " + "available over the JMS transport";	log.warn(msg);	BaseUtils.markServiceAsFaulty(service.getName(), msg, service.getAxisConfiguration());	return;	}	String destinationName = JMSUtils.getJNDIDestinationNameForService(service);	serviceNameToEPRMap.put(service.getName(), JMSUtils.getEPR(cf, destinationName));	String destinationType = JMSUtils.getDestinationTypeForService(service);	
starting to listen on destination of type for service 

========================= synapse sample_3775 =========================

try {	AMQPTransportHAEntry entry = blockedTasks.take();	if (entry != null) {	Map<String, String> params = connectionFactoryManager. getConnectionFactory(entry.getConnectionFactoryName()).getParameters();	int count = 1;	long retryDuration = initialReconnectDuration;	while (true) {	try {	Thread.sleep(initialReconnectDuration);	new AMQPTransportConnectionFactory(params, es);	
the reconnection attempt was successful 

long retryDuration = initialReconnectDuration;	while (true) {	try {	Thread.sleep(initialReconnectDuration);	new AMQPTransportConnectionFactory(params, es);	break;	} catch (AMQPTransportException e) {	retryDuration = (long) (retryDuration * reconnectionProgressionFactor);	if (retryDuration > maxReconnectionDuration) {	retryDuration = initialReconnectDuration;	
the retry duration exceeded the maximum reconnection duration the retry duration is set to initial reconnection duration value s 

while (true) {	try {	Thread.sleep(initialReconnectDuration);	new AMQPTransportConnectionFactory(params, es);	break;	} catch (AMQPTransportException e) {	retryDuration = (long) (retryDuration * reconnectionProgressionFactor);	if (retryDuration > maxReconnectionDuration) {	retryDuration = initialReconnectDuration;	}	
the reconnection attempt number failed next re try will be after seconds 

} catch (InterruptedException ignore) {	}	}	}	ConcurrentHashMap<String, AMQPTransportConnectionFactory> allFac = connectionFactoryManager.getAllFactories();	for (Map.Entry me : allFac.entrySet()) {	String name = (String) me.getKey();	Map<String, String> param = ((AMQPTransportConnectionFactory) me.getValue()).getParameters();	connectionFactoryManager.removeConnectionFactory(name);	connectionFactoryManager.addConnectionFactory( name, new AMQPTransportConnectionFactory(param, es));	
a new connection factory was created for 

String conFacName = entry.getConnectionFactoryName();	AMQPTransportConnectionFactory cf = connectionFactoryManager. getConnectionFactory(conFacName);	connectionMap.put( entry.getKey(), new AMQPTransportHABrokerEntry(cf.getChannel(), cf.getConnection()));	entry.getLock().release();	while (!blockedTasks.isEmpty()) {	entry = blockedTasks.take();	conFacName = entry.getConnectionFactoryName();	cf = connectionFactoryManager. getConnectionFactory(conFacName);	connectionMap.put( entry.getKey(), new AMQPTransportHABrokerEntry(cf.getChannel(), cf.getConnection()));	if (log.isDebugEnabled()) {	
the worker task with key was combined with a new connection factory 

cf = connectionFactoryManager. getConnectionFactory(conFacName);	connectionMap.put( entry.getKey(), new AMQPTransportHABrokerEntry(cf.getChannel(), cf.getConnection()));	if (log.isDebugEnabled()) {	}	entry.getLock().release();	}	}	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	} catch (AMQPTransportException e) {	
high availability handler just died it s time to reboot the system 

========================= synapse sample_2471 =========================

public void deleteAll() {	messageStore.clear();	
all messages in message store were deleted 

public void delete(String messageID) {	if(messageID != null) {	MessageContext m =messageStore.remove(messageID);	if (m != null){	
message with id removed from the messagestore 

========================= synapse sample_2021 =========================

private void registerExtensions() {	
registering mediator extensions found in the classpath java class path 

while (it.hasNext()) {	MediatorSerializer ms = (MediatorSerializer) it.next();	String name = ms.getMediatorClassName();	try {	serializerMap.put(name, ms.getClass().newInstance());	} catch (InstantiationException e) {	handleException("Error instantiating mediator serializer : " + ms);	} catch (IllegalAccessException e) {	handleException("Error instantiating mediator serializer : " + ms);	}	
added mediatorserializer to handle 

========================= synapse sample_3260 =========================

public KeyStore loadTrustStore(String CACertificateFilesPath) {	try {	if (log.isDebugEnabled()) {	
creating keystore from given ca certificates in the given directory 

========================= synapse sample_1089 =========================

private static void registerExtensions() {	Iterator it = Service.providers(MediatorFactory.class);	while (it.hasNext()) {	MediatorFactory mf = (MediatorFactory) it.next();	QName tag = mf.getTagQName();	factoryMap.put(tag, mf.getClass());	if (log.isDebugEnabled()) {	
added mediatorfactory to handle 

public Mediator getMediator(OMElement element, Properties properties) {	String localName = element.getLocalName();	QName qName;	if (element.getNamespace() != null) {	qName = new QName(element.getNamespace().getNamespaceURI(), localName);	} else {	qName = new QName(localName);	}	if (log.isDebugEnabled()) {	
getmediator 

} else {	qName = new QName(localName);	}	if (log.isDebugEnabled()) {	}	Class cls = factoryMap.get(qName);	if (cls == null && localName.indexOf('.') > -1) {	String newLocalName = localName.substring(0, localName.indexOf('.'));	qName = new QName(element.getNamespace().getNamespaceURI(), newLocalName);	if (log.isDebugEnabled()) {	
getmediator 

========================= synapse sample_1820 =========================

public static SynapseConfiguration getConfiguration(String root, Properties properties) {	
building synapse configuration from the synapse artifact repository at 

public static SynapseConfiguration getConfiguration(String root, Properties properties) {	SynapseConfiguration synapseConfig = createConfigurationFromSynapseXML(root, properties);	if (synapseConfig == null) {	synapseConfig = SynapseConfigUtils.newConfiguration();	synapseConfig.setDefaultQName(XMLConfigConstants.DEFINITIONS_ELT);	} else if (log.isDebugEnabled()) {	
found a synapse configuration in the file at the artifact repository root which gets precedence over other definitions 

public static SynapseConfiguration getConfiguration(String root, Properties properties) {	SynapseConfiguration synapseConfig = createConfigurationFromSynapseXML(root, properties);	if (synapseConfig == null) {	synapseConfig = SynapseConfigUtils.newConfiguration();	synapseConfig.setDefaultQName(XMLConfigConstants.DEFINITIONS_ELT);	} else if (log.isDebugEnabled()) {	}	if (synapseConfig.getRegistry() == null) {	createRegistry(synapseConfig, root, properties);	} else if (log.isDebugEnabled()) {	
using the registry defined in the as the registry any definitions in the will be neglected 

} catch (IOException e) {	handleException("Error while opening the file: " + synapseXML.getName(), e);	return null;	}	try {	config = XMLConfigurationBuilder.getConfiguration(is, properties);	is.close();	} catch (XMLStreamException e) {	handleException("Error while loading the Synapse configuration from the " + synapseXML.getName() + " file", e);	} catch (IOException e) {	
error while closing the input stream from file 

private static void createRegistry(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File registryDef = new File(rootDirPath, REGISTRY_FILE);	if (registryDef.exists() && registryDef.isFile()) {	if (log.isDebugEnabled()) {	
initializing synapse registry from the configuration at 

private static void createLocalEntries(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File localEntriesDir = new File(rootDirPath, LOCAL_ENTRY_DIR);	if (localEntriesDir.exists()) {	if (log.isDebugEnabled()) {	
loading local entry definitions from 

private static void createProxyServices(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File proxyServicesDir = new File(rootDirPath, PROXY_SERVICES_DIR);	if (proxyServicesDir.exists()) {	if (log.isDebugEnabled()) {	
loading proxy services from 

private static void createTasks(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File tasksDir = new File(rootDirPath, TASKS_DIR);	if (tasksDir.exists()) {	if (log.isDebugEnabled()) {	
loading tasks from 

private static void createSequences(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File sequencesDir = new File(rootDirPath, SEQUENCES_DIR);	if (sequencesDir.exists()) {	if (log.isDebugEnabled()) {	
loading sequences from 

private static void createTemplates(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File templatesDir = new File(rootDirPath, TEMPLATES_DIR);	if (templatesDir.exists()) {	if (log.isDebugEnabled()) {	
loading template from 

private static void createEndpoints(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File endpointsDir = new File(rootDirPath, ENDPOINTS_DIR);	if (endpointsDir.exists()) {	if (log.isDebugEnabled()) {	
loading endpoints from 

private static void createEventSources(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File eventsDir = new File(rootDirPath, EVENTS_DIR);	if (eventsDir.exists()) {	if (log.isDebugEnabled()) {	
loading event sources from 

private static void createExecutors(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File executorsDir = new File(rootDirPath, EXECUTORS_DIR);	if (executorsDir.exists()) {	if (log.isDebugEnabled()) {	
loading event sources from 

private static void createMessageStores(SynapseConfiguration synapseConfig , String rootDirPath, Properties properties) {	File messageStoresDir = new File(rootDirPath, MESSAGE_STORE_DIR);	if (messageStoresDir.exists() ) {	if (log.isDebugEnabled()) {	
loading message stores from 

private static void createMessageProcessors(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File messageProcessorDir = new File(rootDirPath, MESSAGE_PROCESSOR_DIR);	if (messageProcessorDir.exists()) {	if (log.isDebugEnabled()) {	
loading message processors from 

private static void createSynapseImports(SynapseConfiguration synapseConfig, String root, Properties properties) {	File synImportsDir = new File(root, SYNAPSE_IMPORTS_DIR);	if (synImportsDir.exists()) {	if (log.isDebugEnabled()) {	
loading synapse imports from 

private static void createAPIs(SynapseConfiguration synapseConfig, String rootDirPath) {	File apiDir = new File(rootDirPath, REST_API_DIR);	if (apiDir.exists()) {	if (log.isDebugEnabled()) {	
loading apis from 

is = FileUtils.openInputStream(file);	} catch (IOException e) {	handleException("Error while opening the file: " + file.getName() + " for reading", e);	return null;	}	OMElement document = OMXMLBuilderFactory.createOMBuilder(is).getDocumentElement();	document.build();	try {	is.close();	} catch (IOException e) {	
error while closing the input stream from the file 

private static void handleConfigurationError(String componentType, String msg, Exception e) {	if (SynapseConfigUtils.isFailSafeEnabled(componentType)) {	
continue in fail safe mode 

========================= synapse sample_414 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog log = getLog(synCtx);	if (log.isTraceOrDebugEnabled()) {	
start enqueue mediator 

Mediator m = synCtx.getSequence(sequenceName);	if (m != null && m instanceof SequenceMediator) {	MediatorWorker worker = new MediatorWorker(m, synCtx);	try {	executor.execute(worker, priority);	} catch (RejectedExecutionException ex) {	handleException("Unable to process message in priority executor " + executorName + " with priority " + priority + ". Thread pool exhausted.", ex, synCtx);	}	((Axis2MessageContext) synCtx).getAxis2MessageContext().getOperationContext().setProperty( org.apache.axis2.Constants.RESPONSE_WRITTEN, "SKIP");	if (log.isTraceOrDebugEnabled()) {	
end enqueue mediator 

========================= synapse sample_1965 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start drop mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	synCtx.setTo(null);	if (synCtx.isResponse()) {	StatisticsReporter.reportForAllOnOutFlowEnd(synCtx);	}	if (synLog.isTraceOrDebugEnabled()) {	
end drop mediator 

========================= synapse sample_551 =========================

public Message receive(long timeout){	Message m;	session.messageFlow(destination,Session.MESSAGE_FLOW_UNIT_MESSAGE, 1);	session.messageFlow(destination,Session.MESSAGE_FLOW_UNIT_BYTE, 0xFFFFFFFF);	try{	m = queue.poll(timeout, TimeUnit.MILLISECONDS);	}catch(Exception e){	throw new AMQPSynapseException("unable to receive message",e);	}	if (m == null) {	
message didn t arrive in time checking if one is inflight 

========================= synapse sample_4264 =========================

protected SynapseTestCase(int sampleId) {	if (log.isDebugEnabled()) {	
creating synapsetestcase for test 

public void tearDown() {	
sample is finished 

private void doCleanup() {	if (synapseController != null) {	
stopping synapse 

private void doCleanup() {	if (synapseController != null) {	synapseController.stopProcess();	}	List<ProcessController> removed = new ArrayList<ProcessController>();	for (ProcessController bsc : backendServerControllers) {	if (bsc instanceof Axis2BackEndServerController) {	
stopping server 

for (ProcessController bsc : backendServerControllers) {	if (bsc instanceof Axis2BackEndServerController) {	bsc.stopProcess();	removed.add(bsc);	}	}	for (ProcessController bsc : removed) {	backendServerControllers.remove(bsc);	}	for (ProcessController bsc : backendServerControllers) {	
stopping server 

}	for (ProcessController bsc : removed) {	backendServerControllers.remove(bsc);	}	for (ProcessController bsc : backendServerControllers) {	bsc.stopProcess();	}	try {	FileUtils.cleanDirectory(new File(System.getProperty("java.io.tmpdir")));	} catch (IOException e) {	
error while cleaning temp directory 

private OMElement loadDescriptorInfoFile() {	String sampleDescriptor = "/sample" + sampleId + ".xml";	if (log.isDebugEnabled()) {	
reading sample descriptor file from 

if (log.isDebugEnabled()) {	}	try {	InputStream in = this.getClass().getResourceAsStream(sampleDescriptor);	if (in == null) {	fail("Cannot read sample descriptor file");	}	OMXMLParserWrapper builder = OMXMLBuilderFactory.createOMBuilder(in);	return builder.getDocumentElement();	} catch (Exception e) {	
error loading test descriptor 

private List<ProcessController> initBackEndServersConfigInfo(OMElement config) {	
initializing configuration information for backend servers 

private List<ProcessController> initBackEndServersConfigInfo(OMElement config) {	List<ProcessController> controllers = new ArrayList<ProcessController>();	OMElement backendServersConfig = config.getFirstChildWithName( new QName(SampleConfigConstants.TAG_BE_SERVER_CONF));	if (backendServersConfig == null) {	
no backend servers defined 

if (backendServersConfig == null) {	return null;	}	Iterator backendServers = backendServersConfig.getChildElements();	while (backendServers.hasNext()) {	OMElement backendServer = (OMElement) backendServers.next();	ProcessController controller = SynapseTestUtils.createController(backendServer);	if (controller != null) {	controllers.add(controller);	} else {	
unrecognized backend server configuration 

private boolean configureClustering() {	try {	String ip = SynapseTestUtils.getIPAddress();	if (ip == null || ip.length() == 0) {	
could not detect an active ip address 

private boolean configureClustering() {	try {	String ip = SynapseTestUtils.getIPAddress();	if (ip == null || ip.length() == 0) {	return false;	}	
using the ip 

String beAxis2Config = FileUtils.readFileToString(new File(beAxis2Xml));	String modifiedBEAxis2 = SynapseTestUtils.replace(beAxis2Config, "${replace.me}", ip);	File tempBEAxis2 = File.createTempFile("axis2BE-", "xml");	tempBEAxis2.deleteOnExit();	FileUtils.writeStringToFile(tempBEAxis2, modifiedBEAxis2);	axis2Controller.setAxis2Xml(tempBEAxis2.getAbsolutePath());	}	}	return true;	} catch (Exception e) {	
error configuring clustering 

========================= synapse sample_802 =========================

public boolean process(SynapseEnvironment se, SynapseMessage smc) {	
process 

========================= synapse sample_4634 =========================

public boolean process(MessageContext synCtx) {	if (synCtx.isResponse()) {	return dispatchToAPI(synCtx);	}	org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext) synCtx). getAxis2MessageContext();	String protocol = msgCtx.getIncomingTransportName();	if (!Constants.TRANSPORT_HTTP.equals(protocol) && !Constants.TRANSPORT_HTTPS.equals(protocol)) {	if (log.isDebugEnabled()) {	
invalid protocol for rest api mediation 

private boolean dispatchToAPI(MessageContext synCtx) {	Collection<API> apiSet = synCtx.getEnvironment().getSynapseConfiguration().getAPIs();	API defaultAPI = null;	for (API api : apiSet) {	if ("/".equals(api.getContext())) {	defaultAPI = api;	} else if (api.canProcess(synCtx)) {	if (log.isDebugEnabled()) {	
located specific api for processing message 

========================= synapse sample_2099 =========================

if (EventingConstants.WSE_SUBSCRIBE.equals(mc.getWSAAction())) {	processSubscriptionRequest(mc, messageBuilder);	} else if (EventingConstants.WSE_UNSUBSCRIBE.equals(mc.getWSAAction())) {	processUnSubscribeRequest(mc, messageBuilder);	} else if (EventingConstants.WSE_GET_STATUS.equals(mc.getWSAAction())) {	processGetStatusRequest(mc, messageBuilder);	} else if (EventingConstants.WSE_RENEW.equals(mc.getWSAAction())) {	processReNewRequest(mc, messageBuilder);	} else {	if (log.isDebugEnabled()) {	
event received 

Event<MessageContext> event = new Event(msgCtx);	subscriptions = subscriptionManager.getMatchingSubscriptions(event);	} catch (EventException e) {	handleException("Matching subscriptions fetching error", e);	}	for (Subscription subscription : subscriptions) {	synCtx.setProperty(SynapseConstants.OUT_ONLY, "true");	try {	getEndpointFromURL(subscription.getEndpointUrl(), synCtx.getEnvironment()) .send(MessageHelper.cloneMessageContext(synCtx));	} catch (AxisFault axisFault) {	
event sending failure 

} catch (EventException e) {	handleException("Matching subscriptions fetching error", e);	}	for (Subscription subscription : subscriptions) {	synCtx.setProperty(SynapseConstants.OUT_ONLY, "true");	try {	getEndpointFromURL(subscription.getEndpointUrl(), synCtx.getEnvironment()) .send(MessageHelper.cloneMessageContext(synCtx));	} catch (AxisFault axisFault) {	}	if (log.isDebugEnabled()) {	
event push to 

private void processSubscriptionRequest(MessageContext mc, ResponseMessageBuilder messageBuilder) throws AxisFault, EventException {	SynapseSubscription subscription = SubscriptionMessageBuilder.createSubscription(mc);	if (log.isDebugEnabled()) {	
synapsesubscription request recived 

private void processSubscriptionRequest(MessageContext mc, ResponseMessageBuilder messageBuilder) throws AxisFault, EventException {	SynapseSubscription subscription = SubscriptionMessageBuilder.createSubscription(mc);	if (log.isDebugEnabled()) {	}	if (subscription.getId() != null) {	String subID = subscriptionManager.subscribe(subscription);	if (subID != null) {	if (log.isDebugEnabled()) {	
sending subscription response for synapsesubscription id 

}	if (subscription.getId() != null) {	String subID = subscriptionManager.subscribe(subscription);	if (subID != null) {	if (log.isDebugEnabled()) {	}	SOAPEnvelope soapEnvelope = messageBuilder.genSubscriptionResponse(subscription);	dispatchResponse(soapEnvelope, EventingConstants.WSE_SUbSCRIBE_RESPONSE, mc, false);	} else {	if (log.isDebugEnabled()) {	
synapsesubscription failed sending fault response 

SOAPEnvelope soapEnvelope = messageBuilder.genSubscriptionResponse(subscription);	dispatchResponse(soapEnvelope, EventingConstants.WSE_SUbSCRIBE_RESPONSE, mc, false);	} else {	if (log.isDebugEnabled()) {	}	SOAPEnvelope soapEnvelope = messageBuilder.genFaultResponse(mc, EventingConstants.WSE_FAULT_CODE_RECEIVER, "EventSourceUnableToProcess", "Unable to subscribe ", "");	dispatchResponse(soapEnvelope, EventingConstants.WSA_FAULT, mc, true);	}	} else {	if (log.isDebugEnabled()) {	
synapsesubscription failed sending fault response 

private void processUnSubscribeRequest(MessageContext mc, ResponseMessageBuilder messageBuilder) throws AxisFault, EventException {	SynapseSubscription subscription = SubscriptionMessageBuilder.createUnSubscribeMessage(mc);	if (log.isDebugEnabled()) {	
unsubscribe response recived for synapsesubscription id 

private void processUnSubscribeRequest(MessageContext mc, ResponseMessageBuilder messageBuilder) throws AxisFault, EventException {	SynapseSubscription subscription = SubscriptionMessageBuilder.createUnSubscribeMessage(mc);	if (log.isDebugEnabled()) {	}	if (subscriptionManager.unsubscribe(subscription.getId())) {	if (log.isDebugEnabled()) {	
sending unsubscribe responce for synapsesubscription id 

SynapseSubscription subscription = SubscriptionMessageBuilder.createUnSubscribeMessage(mc);	if (log.isDebugEnabled()) {	}	if (subscriptionManager.unsubscribe(subscription.getId())) {	if (log.isDebugEnabled()) {	}	SOAPEnvelope soapEnvelope = messageBuilder.genUnSubscribeResponse(subscription);	dispatchResponse(soapEnvelope, EventingConstants.WSE_UNSUBSCRIBE_RESPONSE, mc, false);	} else {	if (log.isDebugEnabled()) {	
unsubscription failed sending fault repsponse 

private void processGetStatusRequest(MessageContext mc, ResponseMessageBuilder messageBuilder) throws AxisFault, EventException {	Subscription subscription = SubscriptionMessageBuilder.createGetStatusMessage(mc);	if (log.isDebugEnabled()) {	
getstatus request recived for synapsesubscription id 

private void processGetStatusRequest(MessageContext mc, ResponseMessageBuilder messageBuilder) throws AxisFault, EventException {	Subscription subscription = SubscriptionMessageBuilder.createGetStatusMessage(mc);	if (log.isDebugEnabled()) {	}	subscription = subscriptionManager.getSubscription(subscription.getId());	if (subscription != null) {	if (log.isDebugEnabled()) {	
sending getstatus responce for synapsesubscription id 

if (log.isDebugEnabled()) {	}	subscription = subscriptionManager.getSubscription(subscription.getId());	if (subscription != null) {	if (log.isDebugEnabled()) {	}	SOAPEnvelope soapEnvelope = messageBuilder.genGetStatusResponse(subscription);	dispatchResponse(soapEnvelope, EventingConstants.WSE_GET_STATUS_RESPONSE, mc, false);	} else {	if (log.isDebugEnabled()) {	
getstatus failed sending fault response 

private void processReNewRequest(MessageContext mc, ResponseMessageBuilder messageBuilder) throws AxisFault, EventException {	SynapseSubscription subscription = SubscriptionMessageBuilder.createRenewSubscribeMessage(mc);	if (log.isDebugEnabled()) {	
renew request recived for synapsesubscription id 

private void processReNewRequest(MessageContext mc, ResponseMessageBuilder messageBuilder) throws AxisFault, EventException {	SynapseSubscription subscription = SubscriptionMessageBuilder.createRenewSubscribeMessage(mc);	if (log.isDebugEnabled()) {	}	String subID = subscription.getId();	if (subID != null) {	if (subscriptionManager.renew(subscription)) {	if (log.isDebugEnabled()) {	
sending renew response for synapsesubscription id 

}	String subID = subscription.getId();	if (subID != null) {	if (subscriptionManager.renew(subscription)) {	if (log.isDebugEnabled()) {	}	SOAPEnvelope soapEnvelope = messageBuilder.genRenewSubscriptionResponse(subscription);	dispatchResponse(soapEnvelope, EventingConstants.WSE_RENEW_RESPONSE, mc, false);	} else {	if (log.isDebugEnabled()) {	
renew failed sending fault response 

========================= synapse sample_2076 =========================

private boolean createDynamicRoute(MessageContext synCtx, ConditionalRouterMediator conditionalRouterMediator) {	String conditionRouts = (String) EIPUtils.lookupFunctionParam(synCtx, "conditions");	String[] conditionsSet = conditionRouts.split(DELIMITER_1);	if (conditionsSet.length == 0) {	
no definitions found for dynamic routing 

========================= synapse sample_2001 =========================

public void execute() throws MojoExecutionException {	File xarFile = new File(outputDirectory, xarName + ".xar");	
generating xar 

========================= synapse sample_1292 =========================

spFactory.setValidating(true);	SAXParser parser = spFactory.newSAXParser();	parser.setProperty(VALIDATION, Boolean.TRUE);	parser.setProperty(SCHEMA_VALIDATION, Boolean.TRUE);	parser.setProperty(FULL_CHECKING, Boolean.TRUE);	parser.setProperty(SCHEMA_LOCATION_NS, nsLocations.toString());	parser.setProperty(SCHEMA_LOCATION_NO_NS, getSchemaUrl());	Validator handler = new Validator();	parser.parse(baisFromSource, handler);	if (handler.isValidationError()) {	
validation failed 

========================= synapse sample_2797 =========================

protected void processStatement(Statement stmnt, MessageContext msgCtx) {	SynapseLog synLog = getLog(msgCtx);	Connection con = null;	try {	con = this.getDataSource().getConnection();	PreparedStatement ps = getPreparedStatement(stmnt, con, msgCtx);	con = ps.getConnection();	int count = ps.executeUpdate();	if (count > 0) {	if (synLog.isTraceOrDebugEnabled()) {	
inserted row s using statement 

try {	con = this.getDataSource().getConnection();	PreparedStatement ps = getPreparedStatement(stmnt, con, msgCtx);	con = ps.getConnection();	int count = ps.executeUpdate();	if (count > 0) {	if (synLog.isTraceOrDebugEnabled()) {	}	} else {	if (synLog.isTraceOrDebugEnabled()) {	
no rows were inserted for statement 

========================= synapse sample_526 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
eventsource deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	SynapseEventSource es = EventSourceFactory.createEventSource( artifactConfig, properties);	if (es != null) {	es.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
eventsource named has been built from the file 

if (log.isDebugEnabled()) {	}	try {	SynapseEventSource es = EventSourceFactory.createEventSource( artifactConfig, properties);	if (es != null) {	es.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	es.buildService(getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	
initialized the eventsource 

SynapseEventSource es = EventSourceFactory.createEventSource( artifactConfig, properties);	if (es != null) {	es.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	es.buildService(getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEventSource(es.getName(), es);	if (log.isDebugEnabled()) {	
eventsource deployment from file completed 

if (es != null) {	es.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	es.buildService(getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEventSource(es.getName(), es);	if (log.isDebugEnabled()) {	}	
eventsource named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
eventsource update from file started 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	SynapseEventSource es = EventSourceFactory.createEventSource( artifactConfig, properties);	if (es != null) {	es.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
eventsource named has been built from the file 

if (log.isDebugEnabled()) {	}	try {	SynapseEventSource es = EventSourceFactory.createEventSource( artifactConfig, properties);	if (es != null) {	es.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().removeEventSource(existingArtifactName);	if (!existingArtifactName.equals(es.getName())) {	
eventsource named has been undeployed 

SynapseEventSource es = EventSourceFactory.createEventSource( artifactConfig, properties);	if (es != null) {	es.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().removeEventSource(existingArtifactName);	if (!existingArtifactName.equals(es.getName())) {	}	es.buildService(getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	
initialized the eventsource 

if (log.isDebugEnabled()) {	}	getSynapseConfiguration().removeEventSource(existingArtifactName);	if (!existingArtifactName.equals(es.getName())) {	}	es.buildService(getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEventSource(es.getName(), es);	if (log.isDebugEnabled()) {	
eventsource update deployment from file completed 

}	getSynapseConfiguration().removeEventSource(existingArtifactName);	if (!existingArtifactName.equals(es.getName())) {	}	es.buildService(getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEventSource(es.getName(), es);	if (log.isDebugEnabled()) {	}	
eventsource named has been update deployed from file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
eventsource undeployment of the event source named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	SynapseEventSource es = getSynapseConfiguration().getEventSource(artifactName);	if (es != null) {	getSynapseConfiguration().removeEventSource(artifactName);	if (log.isDebugEnabled()) {	
eventsource undyou neeeployment of the eventsource named completed 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	SynapseEventSource es = getSynapseConfiguration().getEventSource(artifactName);	if (es != null) {	getSynapseConfiguration().removeEventSource(artifactName);	if (log.isDebugEnabled()) {	}	
eventsource named has been undeployed 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	SynapseEventSource es = getSynapseConfiguration().getEventSource(artifactName);	if (es != null) {	getSynapseConfiguration().removeEventSource(artifactName);	if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
event source has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the eventsource with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	SynapseEventSource es = getSynapseConfiguration().getEventSource(artifactName);	OMElement esElem = EventSourceSerializer.serializeEventSource(null, es);	if (es.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.EVENTS_DIR + File.separator + es.getFileName();	writeToFile(esElem, fileName);	if (log.isDebugEnabled()) {	
restoring the eventsource with name completed 

if (log.isDebugEnabled()) {	}	try {	SynapseEventSource es = getSynapseConfiguration().getEventSource(artifactName);	OMElement esElem = EventSourceSerializer.serializeEventSource(null, es);	if (es.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.EVENTS_DIR + File.separator + es.getFileName();	writeToFile(esElem, fileName);	if (log.isDebugEnabled()) {	}	
eventsource named has been restored 

========================= synapse sample_176 =========================

public void init(ServerConfigurationInformation serverConfigurationInformation, ServerContextInformation serverContextInformation) {	
initializing synapse at 

if (serverContextInformation == null) {	throw new IllegalArgumentException("ServerContextInformation cannot be null");	}	this.serverConfigurationInformation = serverConfigurationInformation;	this.serverContextInformation = serverContextInformation;	to show all MBeans (including the Axis2-MBeans) within the Synapse tree */ if (System.getProperty(JMX_AGENT_NAME) == null) {	System.setProperty(JMX_AGENT_NAME, "org.apache.synapse");	}	if (serverContextInformation.getServerContext() == null || serverConfigurationInformation.isCreateNewInstance()) {	if (log.isDebugEnabled()) {	
initializing synapse in a new server environment instance 

System.setProperty(JMX_AGENT_NAME, "org.apache.synapse");	}	if (serverContextInformation.getServerContext() == null || serverConfigurationInformation.isCreateNewInstance()) {	if (log.isDebugEnabled()) {	}	createNewInstance(serverConfigurationInformation);	} else {	Object context = serverContextInformation.getServerContext();	if (context instanceof ConfigurationContext) {	if (log.isDebugEnabled()) {	
initializing synapse in an already existing server environment instance 

handleFatal("Synapse startup initialization failed : Provided server context is" + " invalid, expected an Axis2 ConfigurationContext instance");	}	}	serverContextInformation.setServerContext(configurationContext);	Parameter serverContextParameter = new Parameter( SynapseConstants.SYNAPSE_SERVER_CTX_INFO, serverContextInformation);	Parameter serverConfigParameter = new Parameter( SynapseConstants.SYNAPSE_SERVER_CONFIG_INFO, serverConfigurationInformation);	try {	configurationContext.getAxisConfiguration().addParameter(serverContextParameter);	configurationContext.getAxisConfiguration().addParameter(serverConfigParameter);	} catch (AxisFault ignored) {	
error adding the parameter to the axis configuration 

private void initSynapseLibraries(SynapseConfiguration synapseConfig, String root) {	File synLibDir = new File(root, "repository" + File.separator +"conf" + File.separator +"synapse-libs");	if (synLibDir.exists()) {	if (log.isDebugEnabled()) {	
loading synapse libraries from 

if (log.isDebugEnabled()) {	}	Iterator synLibFile = FileUtils.iterateFiles(synLibDir, new String[]{LibDeployerConstants.SYNAPSE_LIB_FORMAT}, false);	while (synLibFile.hasNext()) {	File file = (File) synLibFile.next();	Library lib = LibDeployerUtils.createSynapseLibrary(FilenameUtils.normalize(file.getAbsolutePath()));	String libArtifactName = lib.getQName().toString();	synapseConfig.addSynapseLibrary(lib.toString(), lib);	synapseConfig.getArtifactDeploymentStore().addArtifact(file.getAbsolutePath(), libArtifactName);	if (log.isDebugEnabled()) {	
synapse library deployment for lib completed 

Library lib = LibDeployerUtils.createSynapseLibrary(FilenameUtils.normalize(file.getAbsolutePath()));	String libArtifactName = lib.getQName().toString();	synapseConfig.addSynapseLibrary(lib.toString(), lib);	synapseConfig.getArtifactDeploymentStore().addArtifact(file.getAbsolutePath(), libArtifactName);	if (log.isDebugEnabled()) {	}	SynapseImport synImport = synapseConfig.getSynapseImports().get(libArtifactName);	if (synImport != null) {	LibDeployerUtils.loadLibArtifacts(synImport, lib);	if (log.isDebugEnabled()) {	
loading synapse library into memory for import 

RMIRegistryController.getInstance().shutDown();	if (snmpAgent != null) {	snmpAgent.stop();	}	if (configurationContext != null) {	configurationContext.terminate();	}	}	initialized = false;	} catch (Exception e) {	
error stopping the based server environment 

} else {	handleFatal("Couldn't start Synapse, ConfigurationContext not found");	}	if (serverConfigurationInformation.isCreateNewInstance()) {	if (listenerManager != null) {	listenerManager.start();	} else {	handleFatal("Couldn't start Synapse, ListenerManager not found");	}	at the end of the startup process to make it more obvious */ if (jmxAdapter != null && jmxAdapter.isRunning()) {	
management using jmx available via 

}	}	Properties properties = SynapsePropertiesLoader.loadSynapseProperties();	String enabled = properties.getProperty(SNMPConstants.SNMP_ENABLED);	try {	if (enabled != null && JavaUtils.isTrueExplicitly(enabled)) {	snmpAgent = new SynapseSNMPAgent(properties);	snmpAgent.start();	}	} catch (IOException e) {	
error while initializing snmp 

public void startMaintenance() {	
putting transport listeners senders and tasks into maintenance mode 

public void startMaintenance() {	Axis2TransportHelper transportHelper = new Axis2TransportHelper(configurationContext);	transportHelper.pauseListeners();	transportHelper.pauseSenders();	SynapseTaskManager synapseTaskManager = synapseEnvironment.getTaskManager();	if (synapseTaskManager.isInitialized()) {	synapseTaskManager.pauseAll();	}	
entered maintenance mode 

public void endMaintenance() {	
resuming transport listeners senders and tasks from maintenance mode 

public void endMaintenance() {	Axis2TransportHelper transportHelper = new Axis2TransportHelper(configurationContext);	transportHelper.resumeListeners();	transportHelper.resumeSenders();	SynapseTaskManager synapseTaskManager = synapseEnvironment.getTaskManager();	if (synapseTaskManager.isInitialized()) {	synapseTaskManager.resumeAll();	}	
resumed normal operation from maintenance mode 

}	Map<String, AxisModule> moduleMap = configurationContext.getAxisConfiguration().getModules();	for (AxisModule mod : moduleMap.values()) {	if (mod.getModule() != null && !"synapse".equals(mod.getName())) {	mod.getModule().shutdown(configurationContext);	}	}	}	SynapseCallbackReceiver.getInstance().destroy();	} catch (AxisFault e) {	
error stopping the environment 

public SynapseEnvironment createSynapseEnvironment() {	try {	deploySynapseService();	deployProxyServices();	deployEventSources();	} catch (AxisFault axisFault) {	
synapse startup failed 

Properties properties = SynapsePropertiesLoader.loadSynapseProperties();	if (serverConfigurationInformation.getResolveRoot() != null) {	properties.put(SynapseConstants.RESOLVE_ROOT, serverConfigurationInformation.getResolveRoot());	}	if (serverConfigurationInformation.getSynapseHome() != null) {	properties.put(SynapseConstants.SYNAPSE_HOME, serverConfigurationInformation.getSynapseHome());	}	if (synapseXMLLocation != null) {	synapseConfiguration = SynapseConfigurationBuilder.getConfiguration( synapseXMLLocation, properties);	} else {	
system property or init parameter is not specified using default configuration 

public boolean waitUntilSafeToStop(long waitIntervalMillis, long endTime) {	boolean safeToStop = false;	boolean forcefulStop = false;	Axis2TransportHelper transportHelper = new Axis2TransportHelper(configurationContext);	while (!safeToStop && !forcefulStop) {	int pendingListenerThreads = transportHelper.getPendingListenerThreadCount();	if (pendingListenerThreads > 0) {	
waiting for listener threads to complete 

public boolean waitUntilSafeToStop(long waitIntervalMillis, long endTime) {	boolean safeToStop = false;	boolean forcefulStop = false;	Axis2TransportHelper transportHelper = new Axis2TransportHelper(configurationContext);	while (!safeToStop && !forcefulStop) {	int pendingListenerThreads = transportHelper.getPendingListenerThreadCount();	if (pendingListenerThreads > 0) {	}	int pendingSenderThreads = transportHelper.getPendingSenderThreadCount();	if (pendingSenderThreads > 0) {	
waiting for listener threads to complete 

Axis2TransportHelper transportHelper = new Axis2TransportHelper(configurationContext);	while (!safeToStop && !forcefulStop) {	int pendingListenerThreads = transportHelper.getPendingListenerThreadCount();	if (pendingListenerThreads > 0) {	}	int pendingSenderThreads = transportHelper.getPendingSenderThreadCount();	if (pendingSenderThreads > 0) {	}	int activeConnections = transportHelper.getActiveConnectionsCount();	if (activeConnections > 0) {	
waiting for active connections to be closed 

}	int pendingSenderThreads = transportHelper.getPendingSenderThreadCount();	if (pendingSenderThreads > 0) {	}	int activeConnections = transportHelper.getActiveConnectionsCount();	if (activeConnections > 0) {	}	int pendingTransportThreads = pendingListenerThreads + pendingSenderThreads;	int pendingCallbacks = SynapseCallbackReceiver.getInstance().getCallbackCount();	if (pendingCallbacks > 0) {	
waiting for callbacks replies 

}	int pendingTransportThreads = pendingListenerThreads + pendingSenderThreads;	int pendingCallbacks = SynapseCallbackReceiver.getInstance().getCallbackCount();	if (pendingCallbacks > 0) {	}	int runningTasks = 0;	SynapseTaskManager synapseTaskManager = synapseEnvironment.getTaskManager();	if (synapseTaskManager.isInitialized()) {	runningTasks = synapseTaskManager.getTaskScheduler().getRunningTaskCount();	if (runningTasks > 0) {	
waiting for tasks to complete 

}	int runningTasks = 0;	SynapseTaskManager synapseTaskManager = synapseEnvironment.getTaskManager();	if (synapseTaskManager.isInitialized()) {	runningTasks = synapseTaskManager.getTaskScheduler().getRunningTaskCount();	if (runningTasks > 0) {	}	}	safeToStop = ((pendingTransportThreads + pendingCallbacks + runningTasks) == 0);	if (safeToStop) {	
all transport threads and tasks are idle and no pending callbacks 

SynapseTaskManager synapseTaskManager = synapseEnvironment.getTaskManager();	if (synapseTaskManager.isInitialized()) {	runningTasks = synapseTaskManager.getTaskScheduler().getRunningTaskCount();	if (runningTasks > 0) {	}	}	safeToStop = ((pendingTransportThreads + pendingCallbacks + runningTasks) == 0);	if (safeToStop) {	} else {	if (System.currentTimeMillis() < endTime) {	
waiting for a maximum of another seconds until transport threads and tasks become idle active connections to get closed and callbacks to be completed 

private void deploySynapseService() throws AxisFault {	
deploying the synapse service 

private void undeploySynapseService() throws AxisFault {	
undeploying the synapse service 

private void deployProxyServices() {	boolean failSafeProxyEnabled = SynapseConfigUtils.isFailSafeEnabled( SynapseConstants.FAIL_SAFE_MODE_PROXY_SERVICES);	
deploying proxy services 

if (thisServerName == null || "".equals(thisServerName)) {	thisServerName = serverConfigurationInformation.getHostName();	if (thisServerName == null || "".equals(thisServerName)) {	thisServerName = "localhost";	}	}	for (ProxyService proxy : synapseConfiguration.getProxyServices()) {	List pinnedServers = proxy.getPinnedServers();	if (pinnedServers != null && !pinnedServers.isEmpty()) {	if (!pinnedServers.contains(thisServerName)) {	
server name not in pinned servers list not deploying proxy service 

for (ProxyService proxy : synapseConfiguration.getProxyServices()) {	List pinnedServers = proxy.getPinnedServers();	if (pinnedServers != null && !pinnedServers.isEmpty()) {	if (!pinnedServers.contains(thisServerName)) {	continue;	}	}	try {	AxisService proxyService = proxy.buildAxisService(synapseConfiguration, configurationContext.getAxisConfiguration());	if (proxyService != null) {	
deployed proxy service 

continue;	}	}	try {	AxisService proxyService = proxy.buildAxisService(synapseConfiguration, configurationContext.getAxisConfiguration());	if (proxyService != null) {	if (!proxy.isStartOnLoad()) {	proxy.stop(synapseConfiguration);	}	} else {	
the proxy service will not be available 

try {	AxisService proxyService = proxy.buildAxisService(synapseConfiguration, configurationContext.getAxisConfiguration());	if (proxyService != null) {	if (!proxy.isStartOnLoad()) {	proxy.stop(synapseConfiguration);	}	} else {	}	} catch (SynapseException e) {	if (failSafeProxyEnabled) {	
the proxy service cannot be deployed continue in proxy service fail safe mode 

private void undeployProxyServices() throws AxisFault {	
undeploying proxy services 

private void deployMediatorExtensions() {	
loading mediator extensions 

private void deployMediatorExtensions() {	AxisConfigurator configurator = configurationContext.getAxisConfiguration().getConfigurator();	if (configurator instanceof DeploymentEngine) {	((DeploymentEngine) configurator).getRepoListener().checkServices();	} else {	
unable to access the repository listener custom extensions will not get loaded now 

private void deployEventSources() throws AxisFault {	
deploying eventsources 

private void undeployEventSources() throws AxisFault {	
undeploying eventsources 

========================= synapse sample_1912 =========================

assertResponseReceived(result);	getBackendServerControllers().get(1).stopProcess();	sleep(2000);	result = client.sessionlessClient(addUrl, null, 10);	assertResponseReceived(result);	getBackendServerControllers().get(2).stopProcess();	sleep(2000);	result = client.sessionlessClient(addUrl, null, 1);	Exception resultEx = result.getException();	assertNotNull("Did not receive expected error", resultEx);	
got an error as expected 

========================= synapse sample_2282 =========================

public static Object getObject(URL url) {	try {	if (url != null && "file".equals(url.getProtocol())) {	try {	url.openStream();	} catch (IOException ignored) {	String path = url.getPath();	if (log.isDebugEnabled()) {	
can not open a connection to the url with a path 

if (url != null && "file".equals(url.getProtocol())) {	try {	url.openStream();	} catch (IOException ignored) {	String path = url.getPath();	if (log.isDebugEnabled()) {	}	String synapseHome = System.getProperty(SynapseConstants.SYNAPSE_HOME);	if (synapseHome != null) {	if (log.isDebugEnabled()) {	
trying to resolve an absolute path of the url using the synapse home 

if (log.isDebugEnabled()) {	}	if (synapseHome.endsWith("/")) {	synapseHome = synapseHome.substring(0, synapseHome.lastIndexOf("/"));	}	url = new URL(url.getProtocol() + ":" + synapseHome + "/" + path);	try {	url.openStream();	} catch (IOException e) {	if (log.isDebugEnabled()) {	
faild to resolve an absolute path of the url using the synapse home 

}	if (synapseHome.endsWith("/")) {	synapseHome = synapseHome.substring(0, synapseHome.lastIndexOf("/"));	}	url = new URL(url.getProtocol() + ":" + synapseHome + "/" + path);	try {	url.openStream();	} catch (IOException e) {	if (log.isDebugEnabled()) {	}	
io error reading from url 

XMLStreamReader parser = XMLInputFactory.newInstance(). createXMLStreamReader(urlc.getInputStream());	StAXOMBuilder builder = new StAXOMBuilder(parser);	OMElement omElem = builder.getDocumentElement();	omElem.build();	if (xmlToObject != null) {	return xmlToObject.getObjectFromOMNode(omElem);	} else {	return omElem;	}	} catch (XMLStreamException e) {	
content at url is non xml 

public static InputSource getInputSourceFormURI(URI uri) {	if (uri == null) {	if (log.isDebugEnabled()) {	
can not create a url from null 

public static URL getURLFromPath(String path) {	if (path == null || "null".equals(path)) {	if (log.isDebugEnabled()) {	
can not create a url from null 

URL url = null;	try {	url = new URL(path);	if ("file".equals(url.getProtocol())) {	try {	url.openStream();	} catch (MalformedURLException e) {	handleException("Invalid URL reference : " + path, e);	} catch (IOException ignored) {	if (log.isDebugEnabled()) {	
can not open a connection to the url with a path 

handleException("Invalid URL reference : " + path, e);	} catch (IOException ignored) {	if (log.isDebugEnabled()) {	}	String synapseHome = System.getProperty(SynapseConstants.SYNAPSE_HOME);	if (synapseHome != null) {	if (synapseHome.endsWith("/")) {	synapseHome = synapseHome.substring(0, synapseHome.lastIndexOf("/"));	}	if (log.isDebugEnabled()) {	
trying to resolve an absolute path of the url using the synapse home 

}	if (log.isDebugEnabled()) {	}	try {	url = new URL(url.getProtocol() + ":" + synapseHome + "/" + url.getPath());	url.openStream();	} catch (MalformedURLException e) {	handleException("Invalid URL reference " + url.getPath() + e);	} catch (IOException e) {	if (log.isDebugEnabled()) {	
faild to resolve an absolute path of the url using the synapse home 

if (log.isDebugEnabled()) {	}	try {	url = new URL(url.getProtocol() + ":" + synapseHome + "/" + url.getPath());	url.openStream();	} catch (MalformedURLException e) {	handleException("Invalid URL reference " + url.getPath() + e);	} catch (IOException e) {	if (log.isDebugEnabled()) {	}	
io error reading from url 

public static InputSource resolveRelativeURI(String parentLocation, String relativeLocation) {	if (relativeLocation == null) {	throw new IllegalArgumentException("Import URI cannot be null");	}	if (log.isDebugEnabled()) {	
resolving import uri against base uri 

========================= synapse sample_3647 =========================

public void connected(final NHttpClientConnection conn, final Object attachment) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection connected 

public void closed(final NHttpClientConnection conn) {	if (this.log.isDebugEnabled()) {	
http connection closed 

public void endOfInput(NHttpClientConnection conn) throws IOException {	if (this.log.isDebugEnabled()) {	
http connection closed at remote end 

public void requestReady(final NHttpClientConnection conn) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection inrequest ready 

public void outputReady(final NHttpClientConnection conn, final ContentEncoder encoder) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection output ready 

public void outputReady(final NHttpClientConnection conn, final ContentEncoder encoder) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	}	this.handler.outputReady(conn, encoder);	if (this.log.isDebugEnabled()) {	
http connection content encoder 

public void responseReceived(final NHttpClientConnection conn) throws IOException, HttpException {	HttpResponse response = conn.getHttpResponse();	if (this.log.isDebugEnabled()) {	
http connection 

public void inputReady(final NHttpClientConnection conn, final ContentDecoder decoder) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection input ready 

public void inputReady(final NHttpClientConnection conn, final ContentDecoder decoder) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	}	this.handler.inputReady(conn, decoder);	if (this.log.isDebugEnabled()) {	
http connection content decoder 

public void timeout(final NHttpClientConnection conn) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection timeout 

========================= synapse sample_2406 =========================

}	ConfigurationContext cfgCtx = messageContext.getConfigurationContext();	Object property = cfgCtx.getProperty(NhttpConstants.EPR_TO_SERVICE_NAME_MAP);	if (property != null && property instanceof Map) {	Map eprToserviceNameMap = (Map) property;	if (eprToserviceNameMap.containsKey(toAddress)) {	return cfgCtx.getAxisConfiguration().getService( eprToserviceNameMap.get(toAddress).toString());	}	}	} else {	
unable to dispatch using the custom uri the to header has not been specified 

========================= synapse sample_208 =========================

public boolean mediate(MessageContext synCtx) {	
attachment mediator ready to mediate 

========================= synapse sample_3352 =========================

try {	channel.queueDeclare(queueName, false, false, false, null);	QueueingConsumer queueingConsumer = new QueueingConsumer(channel);	channel.basicConsume(queueName, true, queueingConsumer);	QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();	AMQPTransportMessage msg = new AMQPTransportMessage(delivery);	responseMessage.put(msg.getCorrelationId(), msg);	Semaphore semaphore = responseTracker.get(msg.getCorrelationId());	semaphore.release();	} catch (IOException e) {	
i o error occurred 

channel.queueDeclare(queueName, false, false, false, null);	QueueingConsumer queueingConsumer = new QueueingConsumer(channel);	channel.basicConsume(queueName, true, queueingConsumer);	QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();	AMQPTransportMessage msg = new AMQPTransportMessage(delivery);	responseMessage.put(msg.getCorrelationId(), msg);	Semaphore semaphore = responseTracker.get(msg.getCorrelationId());	semaphore.release();	} catch (IOException e) {	} catch (InterruptedException e) {	
retrieving task was interrupted 

channel.basicConsume(queueName, true, queueingConsumer);	QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();	AMQPTransportMessage msg = new AMQPTransportMessage(delivery);	responseMessage.put(msg.getCorrelationId(), msg);	Semaphore semaphore = responseTracker.get(msg.getCorrelationId());	semaphore.release();	} catch (IOException e) {	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	} catch (ShutdownSignalException e) {	
shutdown signal was received for simple consumer task 

========================= synapse sample_1046 =========================

private void scanFileOrDirectory(final PollTableEntry entry, String fileURI) {	FileObject fileObject = null;	if (log.isDebugEnabled()) {	
scanning directory or file 

}	boolean wasError = true;	int retryCount = 0;	int maxRetryCount = entry.getMaxRetryCount();	long reconnectionTimeout = entry.getReconnectTimeout();	while(wasError) {	try {	retryCount++;	fileObject = fsManager.resolveFile(fileURI);	if(fileObject == null) {	
fileobject is null 

long reconnectionTimeout = entry.getReconnectTimeout();	while(wasError) {	try {	retryCount++;	fileObject = fsManager.resolveFile(fileURI);	if(fileObject == null) {	throw new FileSystemException("fileObject is null");	}	wasError = false;	} catch(FileSystemException e) {	
cannot resolve fileobject 

} catch (AxisFault e) {	entry.setLastPollState(PollTableEntry.FAILED);	metrics.incrementFaultsReceiving();	}	moveOrDeleteAfterProcessing(entry, fileObject);	}	} else {	int failCount = 0;	int successCount = 0;	if (log.isDebugEnabled()) {	
file name pattern 

}	moveOrDeleteAfterProcessing(entry, fileObject);	}	} else {	int failCount = 0;	int successCount = 0;	if (log.isDebugEnabled()) {	}	for (FileObject child : children) {	if (log.isDebugEnabled()) {	
matching file 

int failCount = 0;	int successCount = 0;	if (log.isDebugEnabled()) {	}	for (FileObject child : children) {	if (log.isDebugEnabled()) {	}	if ((entry.getFileNamePattern() != null) && (child.getName().getBaseName().matches(entry.getFileNamePattern()))) {	try {	if (log.isDebugEnabled()) {	
processing file 

entry.setLastPollState(PollTableEntry.FAILED);	} else {	entry.setLastPollState(PollTableEntry.WITH_ERRORS);	}	}	long now = System.currentTimeMillis();	entry.setLastPollTime(now);	entry.setNextPollTime(now + entry.getPollInterval());	} else {	if (log.isDebugEnabled()) {	
unable to access or read file or directory 

case PollTableEntry.NONE: return;	}	if (moveToDirectory != null) {	String prefix = "";	if(entry.getMoveTimestampFormat() != null) {	Date now = new Date();	prefix = entry.getMoveTimestampFormat().format(now);	}	String destName = moveToDirectory + File.separator + prefix + fileObject.getName().getBaseName();	if (log.isDebugEnabled()) {	
moving to file 

Date now = new Date();	prefix = entry.getMoveTimestampFormat().format(now);	}	String destName = moveToDirectory + File.separator + prefix + fileObject.getName().getBaseName();	if (log.isDebugEnabled()) {	}	FileObject dest = fsManager.resolveFile(destName);	try {	fileObject.moveTo(dest);	} catch (FileSystemException e) {	
error moving file to 

if (log.isDebugEnabled()) {	}	FileObject dest = fsManager.resolveFile(destName);	try {	fileObject.moveTo(dest);	} catch (FileSystemException e) {	}	} else {	try {	if (log.isDebugEnabled()) {	
deleting file 

try {	fileObject.moveTo(dest);	} catch (FileSystemException e) {	}	} else {	try {	if (log.isDebugEnabled()) {	}	fileObject.close();	if (!fileObject.delete()) {	
cannot delete file 

} catch (FileSystemException e) {	}	} else {	try {	if (log.isDebugEnabled()) {	}	fileObject.close();	if (!fileObject.delete()) {	}	} catch (FileSystemException e) {	
error deleting file 

try {	if (log.isDebugEnabled()) {	}	fileObject.close();	if (!fileObject.delete()) {	}	} catch (FileSystemException e) {	}	}	} catch (FileSystemException e) {	
error resolving directory to move after processing 

}	finally {	try {	in.close();	} catch (IOException ex) {	handleException("Error closing stream", ex);	}	}	handleIncomingMessage( msgContext, transportHeaders, null, contentType );	if (log.isDebugEnabled()) {	
processed file of content type 

}	handleIncomingMessage( msgContext, transportHeaders, null, contentType );	if (log.isDebugEnabled()) {	}	} catch (FileSystemException e) {	handleException("Error reading file content or attributes : " + file, e);	} finally {	try {	file.close();	} catch (FileSystemException warn) {	
cannot close file after processing 

protected void startListeningForService(AxisService service) {	if (service.getName().startsWith("__")) {	return;	}	Parameter param = service.getParameter(BaseConstants.TRANSPORT_POLL_INTERVAL);	long pollInterval = BaseConstants.DEFAULT_POLL_INTERVAL;	if (param != null && param.getValue() instanceof String) {	try {	pollInterval = Integer.parseInt(param.getValue().toString());	} catch (NumberFormatException e) {	
invalid poll interval for service default to sec 

========================= synapse sample_4244 =========================

public void testURLRewriteMultiple() {	
running test conditional url rewriting with multiple rules 

========================= synapse sample_822 =========================

public RevocationStatus checkRevocationStatus(X509Certificate peerCert, X509Certificate issuerCert) throws CertificateVerificationException {	if (cache != null) {	SingleResp resp = cache.getCacheValue(peerCert.getSerialNumber());	if (resp != null) {	RevocationStatus status = getRevocationStatus(resp);	
ocsp response taken from cache 

========================= synapse sample_988 =========================

public void setNameOnProcessor(SynapseEnvironment se, OMElement el, Processor p) {	OMAttribute nm = el.getAttribute(new QName("name"));	if (nm != null) {	String name = nm.getAttributeValue().trim();	p.setName(name);	se.addProcessor(p);	}	
compile with name on 

========================= synapse sample_4614 =========================

public void close() throws IOException {	
close connection 

public void shutdown() throws IOException {	
shutdown connection 

public void submitResponse(final HttpResponse response) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection 

public void consumeInput(final NHttpServiceHandler handler) {	
consume input 

public void produceOutput(final NHttpServiceHandler handler) {	
produce output 

========================= synapse sample_4301 =========================

public void completed(SessionRequest request) {	HostConnections pool = (HostConnections) request.getAttachment();	pool.pendingConnectionSucceeded();	if (log.isDebugEnabled()) {	if (request.getSession() != null && request.getSession().getLocalAddress() != null) {	
connected to remote address from local address 

========================= synapse sample_967 =========================

public static IdentityKeyStoreInformation createIdentityKeyStoreInformation(Properties properties) {	String keyStoreLocation = MiscellaneousUtil.getProperty( properties, IDENTITY_KEY_STORE, null);	if (keyStoreLocation == null || "".equals(keyStoreLocation)) {	if (log.isDebugEnabled()) {	
cannot find a keystorelocation for private key store 

public static TrustKeyStoreInformation createTrustKeyStoreInformation(Properties properties) {	String keyStoreLocation = MiscellaneousUtil.getProperty(properties, TRUST_STORE, null);	if (keyStoreLocation == null || "".equals(keyStoreLocation)) {	if (log.isDebugEnabled()) {	
cannot find a keystorelocation for trust store 

private static void parseParameter(String parameterString, KeyStoreInformation information) {	if (parameterString == null || "".equals(parameterString)) {	if (log.isDebugEnabled()) {	
no additional parameter for keystore 

private static void parseParameter(String parameterString, KeyStoreInformation information) {	if (parameterString == null || "".equals(parameterString)) {	if (log.isDebugEnabled()) {	}	return;	}	String[] parameterPairs = parameterString.split(";");	if (parameterPairs == null) {	if (log.isDebugEnabled()) {	
no additional parameter for keystore 

String[] parameterPairs = parameterString.split(";");	if (parameterPairs == null) {	if (log.isDebugEnabled()) {	}	return;	}	for (String parameterPairString : parameterPairs) {	String[] values = parameterPairString.split("=");	if (values == null || values.length != 2) {	if (log.isDebugEnabled()) {	
a parameter with no name value pair has been found 

========================= synapse sample_1103 =========================

public void setMessage(OMElement elem) {	
set message 

public void execute() {	if (log.isDebugEnabled()) {	
execute 

PayloadHelper.setXMLPayload(envelope, message.cloneOMElement());	axis2MsgCtx.setEnvelope(envelope);	} catch (AxisFault axisFault) {	handleError("Error in setting the message payload : " + message);	}	if (soapAction != null) {	axis2MsgCtx.setSoapAction(soapAction);	}	try {	if (log.isDebugEnabled()) {	
injecting message to proxy service 

if (soapAction != null) {	mc.setSoapAction(soapAction);	}	if (INJECT_TO_SEQUENCE.equalsIgnoreCase(injectTo)) {	if (sequenceName == null || sequenceName.equals("")) {	handleError("Sequence name not specified");	}	SequenceMediator seq = (SequenceMediator) synapseEnvironment.getSynapseConfiguration(). getSequence(sequenceName);	if (seq != null) {	if (log.isDebugEnabled()) {	
injecting message to sequence 

SequenceMediator seq = (SequenceMediator) synapseEnvironment.getSynapseConfiguration(). getSequence(sequenceName);	if (seq != null) {	if (log.isDebugEnabled()) {	}	synapseEnvironment.injectAsync(mc, seq);	} else {	handleError("Sequence: " + sequenceName + " not found");	}	} else {	if (log.isDebugEnabled()) {	
injecting message to main sequence 

========================= synapse sample_2040 =========================

try {	Validator validator = cachedSchema.newValidator();	validator.setErrorHandler(errorHandler);	validator.validate(validateSrc);	if (errorHandler.isValidationError()) {	if (traceOrDebugOn) {	String msg = "Validation of element returned by XPath : " + source + " failed against the given schema(s) " + schemaKeys + "with error : " + errorHandler.getSaxParseException().getMessage() + " Executing 'on-fail' sequence";	traceOrDebug(traceOn, msg);	synCtx.getServiceLog().warn(msg);	if (traceOn && trace.isTraceEnabled()) {	
failed message envelope 

========================= synapse sample_4194 =========================

public void testTransportAndFormatSwitching() {	String url2 = "https: String trustStore = FilenameUtils.normalize(System.getProperty("user.dir") + "/modules/integration/src/test/resources/trust.jks");	System.setProperty("javax.net.ssl.trustStore", trustStore);	StockQuoteSampleClient client = getStockQuoteClient();	
running test switching transports and message format from soap to rest pox 

========================= synapse sample_834 =========================

if (information.isCreateNewInstance()) {	validatePath("Axis2 repository", information.getAxis2RepoLocation());	validatePath("axis2.xml location", information.getAxis2Xml());	}	validatePath("synapse.xml location", information.getSynapseXMLLocation());	String serverName = information.getServerName();	if (serverName == null) {	try {	serverName = InetAddress.getLocalHost().getHostName();	} catch (UnknownHostException ignore) {}	
the server name was not specified defaulting to 

validatePath("Axis2 repository", information.getAxis2RepoLocation());	validatePath("axis2.xml location", information.getAxis2Xml());	}	validatePath("synapse.xml location", information.getSynapseXMLLocation());	String serverName = information.getServerName();	if (serverName == null) {	try {	serverName = InetAddress.getLocalHost().getHostName();	} catch (UnknownHostException ignore) {}	} else {	
using server name 

}	validatePath("synapse.xml location", information.getSynapseXMLLocation());	String serverName = information.getServerName();	if (serverName == null) {	try {	serverName = InetAddress.getLocalHost().getHostName();	} catch (UnknownHostException ignore) {}	} else {	}	if (log.isDebugEnabled()) {	
using server configuration as 

validatePath("synapse.xml location", information.getSynapseXMLLocation());	String serverName = information.getServerName();	if (serverName == null) {	try {	serverName = InetAddress.getLocalHost().getHostName();	} catch (UnknownHostException ignore) {}	} else {	}	if (log.isDebugEnabled()) {	}	
the timeout handler will run every s 

private static void validatePath(String msgPre, String path) {	if (path == null) {	handleFatal("The " + msgPre + " must be set as a system property or init-parameter");	} else if (!new File(path).exists()) {	handleFatal("The " + msgPre + " " + path + " doesn't exist");	} else {	
using 

========================= synapse sample_567 =========================

public void check(Certificate cert, Collection<String> unresolvedCritExts) throws CertPathValidatorException {	RevocationStatus status;	try {	status = verifier.checkRevocationStatus((X509Certificate) cert, nextIssuer());	if (log.isDebugEnabled()) {	
certificate status is 

========================= synapse sample_2386 =========================

public TimeoutHandler(Map callbacks) {	this.callbackStore = callbacks;	globalTimeout = ServerManager.getInstance().getGlobalTimeoutInterval();	
this engine will expire all callbacks after seconds irrespective of the timeout action after the specified or optional timeout 

Stack faultStack = msgContext.getFaultStack();	for (int j = 0; j < faultStack.size(); j++) {	Object o = faultStack.pop();	if (o instanceof FaultHandler) {	((FaultHandler) o).handleFault(msgContext);	}	}	}	}	} else if (currentTime > globalTimeout + callback.getTimeOutOn()) {	
expiring message id dropping message after global timeout of seconds 

========================= synapse sample_3981 =========================

public void destroy() {	try {	scheduler.deleteJob(new JobKey(name + "-sampling-job", ScheduledMessageProcessor.SCHEDULED_MESSAGE_PROCESSOR_GROUP));	} catch (SchedulerException e) {	
error while destroying the task 

========================= synapse sample_588 =========================

private static void selectPort(ConfigurationContext configCtx) {	TransportInDescription trsIn = (TransportInDescription) configCtx.getAxisConfiguration().getTransportsIn().get(new QName("http"));	if (trsIn != null) {	int port = 8080;	String strPort = System.getProperty("port");	if(strPort != null) {	try {	port = new Integer(strPort).intValue();	} catch (NumberFormatException e) {	
given port is not a valid integer port specified in the configuration is used for the server 

========================= synapse sample_3082 =========================

String jmxAgentName = System.getProperty("jmx.agent.name");	if (jmxAgentName == null || "".equals(jmxAgentName)) {	jmxAgentName = "org.apache.synapse";	}	String name;	try {	name = jmxAgentName + ":Type=Transport,ConnectorName=" + transportName + "-sender";	TransportView tBean = new TransportView(null, this);	registerMBean(mbs, tBean, name);	} catch (Exception e) {	
error registering the transport for jmx management 

if (jmxAgentName == null || "".equals(jmxAgentName)) {	jmxAgentName = "org.apache.synapse";	}	String name;	try {	name = jmxAgentName + ":Type=Transport,ConnectorName=" + transportName + "-sender";	TransportView tBean = new TransportView(null, this);	registerMBean(mbs, tBean, name);	} catch (Exception e) {	}	
sender started 

public void stop() {	if (state != BaseConstants.STARTED) return;	state = BaseConstants.STOPPED;	
sender shutdown 

public void handleIncomingMessage( MessageContext msgCtx, Map trpHeaders, String soapAction, String contentType) {	if (soapAction != null) {	msgCtx.setSoapAction(soapAction);	}	msgCtx.setProperty(MessageContext.TRANSPORT_HEADERS, trpHeaders);	try {	try {	engine.receive(msgCtx);	} catch (AxisFault e) {	if (log.isDebugEnabled()) {	
error receiving message 

public MessageContext createResponseMessageContext(MessageContext outMsgCtx) {	MessageContext responseMsgCtx = null;	try {	responseMsgCtx = outMsgCtx.getOperationContext(). getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);	} catch (AxisFault af) {	
error getting in message context from the operation context 

public void pause() throws AxisFault {	if (state != BaseConstants.STARTED) return;	state = BaseConstants.PAUSED;	
sender paused 

public void resume() throws AxisFault {	if (state != BaseConstants.PAUSED) return;	state = BaseConstants.STARTED;	
sender resumed 

public void maintenenceShutdown(long millis) throws AxisFault {	if (state != BaseConstants.STARTED) return;	long start = System.currentTimeMillis();	stop();	state = BaseConstants.STOPPED;	
sender shutdown in s 

try {	ObjectName name = new ObjectName(objectName);	Set set = mbs.queryNames(name, null);	if (set != null && set.isEmpty()) {	mbs.registerMBean(mbeanInstance, name);	} else {	mbs.unregisterMBean(name);	mbs.registerMBean(mbeanInstance, name);	}	} catch (Exception e) {	
error registering a mbean with objectname for jmx management 

========================= synapse sample_4317 =========================

public void destroy() {	try {	scheduler.deleteJob(new JobKey(name + "-forward job", ScheduledMessageProcessor.SCHEDULED_MESSAGE_PROCESSOR_GROUP));	scheduler.shutdown(true);	} catch (SchedulerException e) {	
error while destroying the task 

========================= synapse sample_2017 =========================

public void acknowledgeMessage(MessageContext msgContext) throws AxisFault {	if (log.isDebugEnabled()) {	
acking one way request 

public void awaitResponse() throws InterruptedException, AxisFault {	if (log.isDebugEnabled()) {	
returning thread but keeping socket open awaiting response 

public void signalResponseReady() {	if (log.isDebugEnabled()) {	
signal response available 

========================= synapse sample_2447 =========================

public void restart() throws Exception {	try {	
re starting synapse 

========================= synapse sample_619 =========================

public KeyStore loadTrustStore(String CACertificateFilesPath) {	try {	if (log.isDebugEnabled()) {	
creating keystore from given ca certificates in the given directory 

========================= synapse sample_2502 =========================

public boolean mediate(MessageContext synCtx) {	
log mediator mediate 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	if (shouldTrace) {	
start log mediator 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	if (shouldTrace) {	}	String logMessage = getLogMessage(synCtx);	log.info(logMessage);	if (shouldTrace) {	trace.trace(logMessage);	
end log mediator 

========================= synapse sample_3313 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start enrich mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

try {	sourceNodeList = source.evaluate(synCtx, synLog);	if (sourceNodeList == null) {	handleException("Failed to get the source for Enriching : ", synCtx);	} else {	target.insert(synCtx, sourceNodeList, synLog);	}	} catch (JaxenException e) {	handleException("Failed to get the source for Enriching", e, synCtx);	}	
end enrich mediator 

========================= synapse sample_530 =========================

String optionType = option.getOptionType();	return !("repo".equalsIgnoreCase(optionType) || "conf" .equalsIgnoreCase(optionType));	}	});	if ((invalidOptionsList.size() > 0) || (args.length > 4)) {	printUsage();	}	Map optionsMap = optionsParser.getAllOptions();	CommandLineOption repoOption = (CommandLineOption) optionsMap .get("repo");	CommandLineOption confOption = (CommandLineOption) optionsMap .get("conf");	
simpleaxisserver starting 

if (confOption != null) {	confLocation = confOption.getOptionValue();	System.out .println("[SimpleAxisServer] Using the Axis2 Configuration File : " + new File(confLocation).getAbsolutePath());	}	try {	configctx = ConfigurationContextFactory .createConfigurationContextFromFileSystem(repoLocation, confLocation);	configurePort(configctx);	listenerManager = new ListenerManager();	listenerManager.init(configctx);	listenerManager.start();	
simpleaxisserver started 

confLocation = confOption.getOptionValue();	System.out .println("[SimpleAxisServer] Using the Axis2 Configuration File : " + new File(confLocation).getAbsolutePath());	}	try {	configctx = ConfigurationContextFactory .createConfigurationContextFromFileSystem(repoLocation, confLocation);	configurePort(configctx);	listenerManager = new ListenerManager();	listenerManager.init(configctx);	listenerManager.start();	} catch (Throwable t) {	
simpleaxisserver shutting down error starting simpleaxisserver 

private void configurePort(ConfigurationContext configCtx) {	TransportInDescription trsIn = (TransportInDescription) configCtx.getAxisConfiguration().getTransportsIn().get("http");	if (trsIn != null) {	String port = System.getProperty("http_port");	if (port != null) {	try {	new Integer(port);	trsIn.getParameter("port").setValue(port);	} catch (NumberFormatException e) {	
given port is not a valid integer using for port 

}	}	TransportInDescription httpsTrsIn = (TransportInDescription) configCtx.getAxisConfiguration().getTransportsIn().get("https");	if (httpsTrsIn != null) {	String port = System.getProperty("https_port");	if (port != null) {	try {	new Integer(port);	httpsTrsIn.getParameter("port").setValue(port);	} catch (NumberFormatException e) {	
given port is not a valid integer using for port 

========================= synapse sample_3893 =========================

public void streamMessageContents() throws AxisFault {	if (log.isDebugEnabled()) {	
start streaming outgoing http request message id 

public void streamMessageContents() throws AxisFault {	if (log.isDebugEnabled()) {	if (log.isTraceEnabled()) {	
message request message id request message payload 

if (chunked) {	messageFormatter.writeTo(msgContext, format, out, false);	} else {	writeMessageFromTempData(out);	}	}	} catch (Exception e) {	Throwable t = e.getCause();	if (t != null && t.getCause() != null && t.getCause() instanceof ClosedChannelException) {	if (log.isDebugEnabled()) {	
ignore closed channel exception as the sessionrequestcallback handles this exception 

}	} catch (Exception e) {	Throwable t = e.getCause();	if (t != null && t.getCause() != null && t.getCause() instanceof ClosedChannelException) {	if (log.isDebugEnabled()) {	}	} else {	Integer errorCode = msgContext == null ? null : (Integer) msgContext.getProperty(NhttpConstants.ERROR_CODE);	if (errorCode == null || errorCode == NhttpConstants.SEND_ABORT) {	if (log.isDebugEnabled()) {	
remote server aborted request being sent and responded 

========================= synapse sample_1007 =========================

public void testMTOMOptimization() {	String ep = "http: String currentLocation = System.getProperty("user.dir") + File.separator;	String filename = FilenameUtils.normalize( currentLocation + "repository/conf/sample/resources/mtom/asf-logo.gif");	MTOMSwASampleClient client = getMTOMSwASampleClient();	
running test mtom optimization and request response correlation 

public void testSWAOptimization() {	String ep = "http: String currentLocation = System.getProperty("user.dir") + File.separator;	String filename = FilenameUtils.normalize( currentLocation + "repository/conf/sample/resources/mtom/asf-logo.gif");	MTOMSwASampleClient client = getMTOMSwASampleClient();	
running test swa optimization and request response correlation 

========================= synapse sample_863 =========================

public boolean mediate(SynapseMessage synapseMessageContext) {	try {	
sla mediator 

public void setSynapseEnvironment(SynapseEnvironment se) {	this.se = se;	if(se!=null){	
environment not null in sla 

========================= synapse sample_4655 =========================

public static List<DataSourceInformation> createDataSourceInformationList( Properties dsProperties) {	final List<DataSourceInformation> dataSourceInformations = new ArrayList<DataSourceInformation>();	if (dsProperties == null) {	if (log.isDebugEnabled()) {	
datasource properties cannot be found 

public static List<DataSourceInformation> createDataSourceInformationList( Properties dsProperties) {	final List<DataSourceInformation> dataSourceInformations = new ArrayList<DataSourceInformation>();	if (dsProperties == null) {	if (log.isDebugEnabled()) {	}	return dataSourceInformations;	}	String dataSources = MiscellaneousUtil.getProperty(dsProperties, DataSourceConstants.PROP_SYNAPSE_PREFIX_DS, null);	if (dataSources == null || "".equals(dataSources)) {	if (log.isDebugEnabled()) {	
no datasources defined for initialization 

}	String dataSources = MiscellaneousUtil.getProperty(dsProperties, DataSourceConstants.PROP_SYNAPSE_PREFIX_DS, null);	if (dataSources == null || "".equals(dataSources)) {	if (log.isDebugEnabled()) {	}	return dataSourceInformations;	}	String[] dataSourcesNames = dataSources.split(",");	if (dataSourcesNames == null || dataSourcesNames.length == 0) {	if (log.isDebugEnabled()) {	
no datasource definitions found for initialization 

========================= synapse sample_2129 =========================

public boolean mediate(MessageContext synCtx) {	try {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start xquery mediator 

public boolean mediate(MessageContext synCtx) {	try {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	try {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	
performing xquery using query resource with key 

public boolean mediate(MessageContext synCtx) {	try {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	performQuery(synCtx, synLog);	
end xquery mediator 

private void bindVariable(XQDynamicContext xqDynamicContext, MediatorVariable variable, SynapseLog synLog) throws XQException {	if (variable != null) {	QName name = variable.getName();	int type = variable.getType();	Object value = variable.getValue();	if (value != null && type != -1) {	if (synLog.isTraceOrDebugEnabled()) {	
binding a variable to the dynamiccontext with a name and a value 

========================= synapse sample_2579 =========================

public void send(MessageContext synCtx) {	if (log.isDebugEnabled()) {	
failover endpoint 

public void send(MessageContext synCtx) {	if (log.isDebugEnabled()) {	}	boolean isARetry = false;	if (synCtx.getProperty(SynapseConstants.LAST_ENDPOINT) == null) {	if (log.isDebugEnabled()) {	
building the soapenvelope 

public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {	logOnChildEndpointFail(endpoint, synMessageContext);	if (!((AbstractEndpoint)endpoint).isRetryDisabled(synMessageContext)) {	if (log.isDebugEnabled()) {	
retry attempt for request with message id to 

========================= synapse sample_232 =========================

else if (AMQPConstants.AMQP_DELIVERY_MODE.equals(name)) {	Object o = headerMap.get(AMQPConstants.AMQP_DELIVERY_MODE);	if (o instanceof Short) {	deliveryProps.setDeliveryMode(((Short) o).shortValue());	}else if (o instanceof Integer) {	deliveryProps.setDeliveryMode(((Integer) o).shortValue());	}else if (o instanceof String) {	try {	deliveryProps.setDeliveryMode(Short.parseShort((String) o));	} catch (NumberFormatException nfe) {	
invalid delivery mode ignored 

if (o instanceof Short) {	deliveryProps.setDeliveryMode(((Short) o).shortValue());	}else if (o instanceof Integer) {	deliveryProps.setDeliveryMode(((Integer) o).shortValue());	}else if (o instanceof String) {	try {	deliveryProps.setDeliveryMode(Short.parseShort((String) o));	} catch (NumberFormatException nfe) {	}	} else {	
invalid delivery mode ignored 

if (waitReply != null) {	timeout = Long.valueOf(waitReply).longValue();	}	String destination = msgProps.getReplyTo().getRoutingKey();	MessageManager listener = new MessageManager(session,destination,msgProps.getCorrelationId());	session.messageSubscribe(msgProps.getReplyTo().getRoutingKey(), destination, Session.TRANSFER_CONFIRM_MODE_REQUIRED, Session.TRANSFER_ACQUIRE_MODE_NO_ACQUIRE, new MessagePartListenerAdapter(listener), null, Option.NO_OPTION);	Message reply = listener.receive(timeout);	if (reply != null) {	processSyncResponse(msgCtx, reply);	} else {	
did not receive a response within ms to destination with correlation id 

========================= synapse sample_3738 =========================

public void testCallOutInlineEndpoint() {	
running test callout mediator invoke a service using an inline endpoint 

========================= synapse sample_818 =========================

public static StatisticsRecord getStatisticsRecord(MessageContext synCtx) {	String messageId = synCtx.getMessageID();	org.apache.axis2.context.MessageContext axisMC = ((Axis2MessageContext) synCtx) .getAxis2MessageContext();	String remoteIP = (String) axisMC.getPropertyNonReplicable( org.apache.axis2.context.MessageContext.REMOTE_ADDR);	String domainName = (String) axisMC.getPropertyNonReplicable(NhttpConstants.REMOTE_HOST);	StatisticsRecord statisticsRecord = new StatisticsRecord(messageId, remoteIP, domainName);	if (log.isDebugEnabled()) {	
created a statisticsrecord 

========================= synapse sample_635 =========================

if (acceptor) {	eventHandlerParam = service.getParameter(FIXConstants.FIX_ACCEPTOR_EVENT_HANDLER);	} else {	eventHandlerParam = service.getParameter(FIXConstants.FIX_INITIATOR_EVENT_HANDLER);	}	if (eventHandlerParam != null && eventHandlerParam.getValue() != null && !"".equals(eventHandlerParam.getValue())) {	try {	Class clazz = getClass().getClassLoader().loadClass( (String) eventHandlerParam.getValue());	eventHandler = (SessionEventHandler) clazz.newInstance();	} catch (ClassNotFoundException e) {	
unable to find the session event handler class 

eventHandlerParam = service.getParameter(FIXConstants.FIX_ACCEPTOR_EVENT_HANDLER);	} else {	eventHandlerParam = service.getParameter(FIXConstants.FIX_INITIATOR_EVENT_HANDLER);	}	if (eventHandlerParam != null && eventHandlerParam.getValue() != null && !"".equals(eventHandlerParam.getValue())) {	try {	Class clazz = getClass().getClassLoader().loadClass( (String) eventHandlerParam.getValue());	eventHandler = (SessionEventHandler) clazz.newInstance();	} catch (ClassNotFoundException e) {	} catch (Exception e) {	
error while initializing the session event handler class 

private boolean isSingleThreaded() {	Parameter singleThreadParam = service.getParameter( FIXConstants.FIX_ACCEPTOR_SINGLE_THREADED);	if (acceptor && singleThreadParam != null && JavaUtils.isTrueExplicitly(singleThreadParam.getValue())) {	
fix acceptor for service is single threaded 

private boolean isSingleThreaded() {	Parameter singleThreadParam = service.getParameter( FIXConstants.FIX_ACCEPTOR_SINGLE_THREADED);	if (acceptor && singleThreadParam != null && JavaUtils.isTrueExplicitly(singleThreadParam.getValue())) {	return true;	}	singleThreadParam = service.getParameter( FIXConstants.FIX_INITIATOR_SINGLE_THREADED);	if (!acceptor && singleThreadParam != null && JavaUtils.isTrueExplicitly(singleThreadParam.getValue())) {	
fix initiator for service is single threaded 

Parameter singleThreadParam = service.getParameter( FIXConstants.FIX_ACCEPTOR_SINGLE_THREADED);	if (acceptor && singleThreadParam != null && JavaUtils.isTrueExplicitly(singleThreadParam.getValue())) {	return true;	}	singleThreadParam = service.getParameter( FIXConstants.FIX_INITIATOR_SINGLE_THREADED);	if (!acceptor && singleThreadParam != null && JavaUtils.isTrueExplicitly(singleThreadParam.getValue())) {	return true;	}	singleThreadParam = service.getParameter( FIXConstants.FIX_PROCESS_SINGLE_THREADED);	if (singleThreadParam != null && JavaUtils.isTrueExplicitly(singleThreadParam.getValue())) {	
fix processor for service is single threaded 

public void onCreate(SessionID sessionID) {	
new fix session created 

public void toAdmin(Message message, SessionID sessionID) {	if (log.isDebugEnabled()) {	StringBuffer sb = new StringBuffer();	try {	sb.append("Sending admin level FIX message to ").append(message.getHeader().getField(new TargetCompID()).getValue());	sb.append("\nMessage Type: ").append(message.getHeader().getField(new MsgType()).getValue());	sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nSender ID: ").append(message.getHeader().getField(new SenderCompID()).getValue());	} catch (FieldNotFound e) {	sb.append("Sending admin level FIX message...");	
one or more required fields are not found in the response message 

try {	sb.append("Sending admin level FIX message to ").append(message.getHeader().getField(new TargetCompID()).getValue());	sb.append("\nMessage Type: ").append(message.getHeader().getField(new MsgType()).getValue());	sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nSender ID: ").append(message.getHeader().getField(new SenderCompID()).getValue());	} catch (FieldNotFound e) {	sb.append("Sending admin level FIX message...");	}	log.debug(sb.toString());	if (log.isTraceEnabled()) {	
message 

public void fromAdmin(Message message, SessionID sessionID) throws FieldNotFound, IncorrectDataFormat, IncorrectTagValue, RejectLogon {	if (log.isDebugEnabled()) {	StringBuffer sb = new StringBuffer();	sb.append("Received admin level FIX message from ").append(message.getHeader().getField(new SenderCompID()).getValue());	sb.append("\nMessage Type: ").append(message.getHeader().getField(new MsgType()).getValue());	sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nReceiver ID: ").append(message.getHeader().getField(new TargetCompID()).getValue());	log.debug(sb.toString());	if (log.isTraceEnabled()) {	
message 

public void toApp(Message message, SessionID sessionID) throws DoNotSend {	if (log.isDebugEnabled()) {	StringBuffer sb = new StringBuffer();	try {	sb.append("Sending application level FIX message to ").append(message.getHeader().getField(new TargetCompID()).getValue());	sb.append("\nMessage Type: ").append(message.getHeader().getField(new MsgType()).getValue());	sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nSender ID: ").append(message.getHeader().getField(new SenderCompID()).getValue());	} catch (FieldNotFound e) {	sb.append("Sending application level FIX message...");	
one or more required fields are not found in the response message 

try {	sb.append("Sending application level FIX message to ").append(message.getHeader().getField(new TargetCompID()).getValue());	sb.append("\nMessage Type: ").append(message.getHeader().getField(new MsgType()).getValue());	sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nSender ID: ").append(message.getHeader().getField(new SenderCompID()).getValue());	} catch (FieldNotFound e) {	sb.append("Sending application level FIX message...");	}	log.debug(sb.toString());	if (log.isTraceEnabled()) {	
message 

public void fromApp(Message message, SessionID sessionID) throws FieldNotFound, IncorrectDataFormat, IncorrectTagValue, UnsupportedMessageType {	if (log.isDebugEnabled()) {	StringBuffer sb = new StringBuffer();	sb.append("Received FIX message from ").append(message.getHeader().getField(new SenderCompID()).getValue());	sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nReceiver ID: ").append(message.getHeader().getField(new TargetCompID()).getValue());	log.debug(sb.toString());	if (log.isTraceEnabled()) {	
message 

sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nReceiver ID: ").append(message.getHeader().getField(new TargetCompID()).getValue());	log.debug(sb.toString());	if (log.isTraceEnabled()) {	}	}	AtomicInteger atomicCounter = countersMap.get(sessionID);	int counter = atomicCounter.incrementAndGet();	boolean rolled = atomicCounter.compareAndSet(FIXConstants.DEFAULT_COUNTER_UPPER_LIMIT, 0);	if (rolled && log.isDebugEnabled()) {	
incoming request counter rolled over for the session 

} else {	if (acceptor) {	handleIncomingRequest(message, sessionID, counter);	} else {	MessageContext outMsgCtx = outgoingMessages.poll();	if (outMsgCtx != null) {	handleIncomingResponse(outMsgCtx, message, sessionID, counter);	} else if (!dropExtraResponses) {	handleIncomingRequest(message, sessionID, counter);	} else {	
dropping additional fix response 

private void handleIncomingRequest(Message message, SessionID sessionID, int counter) {	if (log.isDebugEnabled()) {	
source session received message with sequence number 

========================= synapse sample_2484 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start pojocommand mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	if (synLog.isTraceOrDebugEnabled()) {	
creating a new instance of pojo class 

}	}	if (synLog.isTraceOrDebugEnabled()) {	}	Object commandObject = null;	try {	commandObject = command.newInstance();	} catch (Exception e) {	handleException("Error creating an instance of the POJO command class : " + command.getClass(), e, synCtx);	}	
instance created setting static and dynamic properties 

PropertyHelper.setInstanceProperty(name, staticSetterProperties.get(name), commandObject);	}	for (String name : contextSetterProperties.keySet()) {	PropertyHelper.setInstanceProperty(name, synCtx.getProperty(contextSetterProperties.get(name)), commandObject);	}	for (String name : messageSetterProperties.keySet()) {	SynapseXPath xpath = messageSetterProperties.get(name);	String value = xpath.stringValueOf(synCtx);	PropertyHelper.setInstanceProperty(name, value, commandObject);	}	
pojo initialized successfully invoking the execute method 

Object o = list.get(0);	if (resultValue instanceof String) {	OMAbstractFactory.getOMFactory().createOMText( ((OMNode) o).getParent(), (String) resultValue);	((OMNode) o).detach();	} else if (resultValue instanceof OMNode) {	((OMNode) o).insertSiblingAfter((OMNode) resultValue);	((OMNode) o).detach();	}	} else {	if (synLog.isTraceOrDebugEnabled()) {	
unable to set the message property back to the message specified element by the xpath can not be found 

((OMNode) o).detach();	}	} else {	if (synLog.isTraceOrDebugEnabled()) {	}	}	} catch (JaxenException e) {	handleException("Unable to set the command property " + name + " back to the message", e, synCtx);	}	}	
end pojocommand mediator 

========================= synapse sample_1928 =========================

public void execute(JobExecutionContext ctx) throws JobExecutionException {	String jobName = ctx.getJobDetail().getKey().getName();	if (log.isDebugEnabled()) {	
executing task 

SynapseEnvironment se = (SynapseEnvironment) jdm.get("SynapseEnvironment");	if (initRequired) {	try {	task = (Task) getClass().getClassLoader().loadClass(jobClassName).newInstance();	} catch (Exception e) {	handleException("Cannot instantiate task : " + jobClassName, e);	}	Set properties = (Set) jdm.get(PROPERTIES);	for (Object property : properties) {	OMElement prop = (OMElement) property;	
found property 

========================= synapse sample_623 =========================

factory.createOMText(expiresOm, expires);	OMElement filterOm = factory.createOMElement("Filter", eventingNamespace);	filterOm.addAttribute(factory.createOMAttribute("Dialect", null, "http: factory.createOMText(filterOm, topic);	notifyToOm.addChild(addressOm);	deliveryOm.addChild(notifyToOm);	subscribeOm.addChild(deliveryOm);	if (!(expires.equals("*"))) {	subscribeOm.addChild(expiresOm);	}	subscribeOm.addChild(filterOm);	
subscribing 

deliveryOm.addChild(notifyToOm);	subscribeOm.addChild(deliveryOm);	if (!(expires.equals("*"))) {	subscribeOm.addChild(expiresOm);	}	subscribeOm.addChild(filterOm);	SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	options.setAction("http: OMElement response = serviceClient.sendReceive(subscribeOm);	
subscribed to topic 

}	subscribeOm.addChild(filterOm);	SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	options.setAction("http: OMElement response = serviceClient.sendReceive(subscribeOm);	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	
response received 

subscribeOm.addChild(filterOm);	SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	options.setAction("http: OMElement response = serviceClient.sendReceive(subscribeOm);	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	String subId = response.getFirstChildWithName( new QName(eventingNamespace.getNamespaceURI(), "SubscriptionManager")) .getFirstChildWithName( new QName(addressingNamespace.getNamespaceURI(), "ReferenceParameters")) .getFirstChildWithName( new QName(eventingNamespace.getNamespaceURI(), "Identifier")).getText();	
subscription identifier 

initializeClient(addUrl);	options.setAction("http: OMElement response = serviceClient.sendReceive(subscribeOm);	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	String subId = response.getFirstChildWithName( new QName(eventingNamespace.getNamespaceURI(), "SubscriptionManager")) .getFirstChildWithName( new QName(addressingNamespace.getNamespaceURI(), "ReferenceParameters")) .getFirstChildWithName( new QName(eventingNamespace.getNamespaceURI(), "Identifier")).getText();	clientResult.addProperty("subId", subId);	clientResult.incrementResponseCount();	} catch (Exception e) {	
fault received 

public SampleClientResult unsubscribe(String addUrl, String identifier) {	(01) <s12:Envelope (02)     xmlns:s12="http: (03)     xmlns:wsa="http: (04)     xmlns:wse="http: (05)     xmlns:ow="http: (06)   <s12:Header> (07)     <wsa:Action> (08)       http: (09)     </wsa:Action> (10)     <wsa:MessageID> (11)       uuid:2653f89f-25bc-4c2a-a7c4-620504f6b216 (12)     </wsa:MessageID> (13)     <wsa:ReplyTo> (14)      <wsa:Address>http: (15)     </wsa:ReplyTo> (16)     <wsa:To> (17)       http: (18)     </wsa:To> (19)     <wse:Identifier> (20)       uuid:22e8a584-0d18-4228-b2a8-3716fa2097fa (21)     </wse:Identifier> (22)   </s12:Header> (23)   <s12:Body> (24)     <wse:Unsubscribe /> (25)   </s12:Body> (26) </s12:Envelope>*/ OMElement subscribeOm = factory.createOMElement("Unsubscribe", eventingNamespace);	
unsubscribing 

public SampleClientResult unsubscribe(String addUrl, String identifier) {	(01) <s12:Envelope (02)     xmlns:s12="http: (03)     xmlns:wsa="http: (04)     xmlns:wse="http: (05)     xmlns:ow="http: (06)   <s12:Header> (07)     <wsa:Action> (08)       http: (09)     </wsa:Action> (10)     <wsa:MessageID> (11)       uuid:2653f89f-25bc-4c2a-a7c4-620504f6b216 (12)     </wsa:MessageID> (13)     <wsa:ReplyTo> (14)      <wsa:Address>http: (15)     </wsa:ReplyTo> (16)     <wsa:To> (17)       http: (18)     </wsa:To> (19)     <wse:Identifier> (20)       uuid:22e8a584-0d18-4228-b2a8-3716fa2097fa (21)     </wse:Identifier> (22)   </s12:Header> (23)   <s12:Body> (24)     <wse:Unsubscribe /> (25)   </s12:Body> (26) </s12:Envelope>*/ OMElement subscribeOm = factory.createOMElement("Unsubscribe", eventingNamespace);	SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	options.setAction("http: OMElement identifierOm = factory.createOMElement("Identifier", eventingNamespace);	factory.createOMText(identifierOm, identifier);	serviceClient.addHeader(identifierOm);	OMElement response = serviceClient.sendReceive(subscribeOm);	
unsubscribed to id 

public SampleClientResult unsubscribe(String addUrl, String identifier) {	(01) <s12:Envelope (02)     xmlns:s12="http: (03)     xmlns:wsa="http: (04)     xmlns:wse="http: (05)     xmlns:ow="http: (06)   <s12:Header> (07)     <wsa:Action> (08)       http: (09)     </wsa:Action> (10)     <wsa:MessageID> (11)       uuid:2653f89f-25bc-4c2a-a7c4-620504f6b216 (12)     </wsa:MessageID> (13)     <wsa:ReplyTo> (14)      <wsa:Address>http: (15)     </wsa:ReplyTo> (16)     <wsa:To> (17)       http: (18)     </wsa:To> (19)     <wse:Identifier> (20)       uuid:22e8a584-0d18-4228-b2a8-3716fa2097fa (21)     </wse:Identifier> (22)   </s12:Header> (23)   <s12:Body> (24)     <wse:Unsubscribe /> (25)   </s12:Body> (26) </s12:Envelope>*/ OMElement subscribeOm = factory.createOMElement("Unsubscribe", eventingNamespace);	SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	options.setAction("http: OMElement identifierOm = factory.createOMElement("Identifier", eventingNamespace);	factory.createOMText(identifierOm, identifier);	serviceClient.addHeader(identifierOm);	OMElement response = serviceClient.sendReceive(subscribeOm);	Thread.sleep(1000);	
unsubscribe response received 

SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	options.setAction("http: OMElement identifierOm = factory.createOMElement("Identifier", eventingNamespace);	factory.createOMText(identifierOm, identifier);	serviceClient.addHeader(identifierOm);	OMElement response = serviceClient.sendReceive(subscribeOm);	Thread.sleep(1000);	clientResult.incrementResponseCount();	} catch (Exception e) {	
fault received 

public SampleClientResult renew(String addUrl, String expires, String identifier) {	(02)     xmlns:s12="http: (03)     xmlns:wsa="http: (04)     xmlns:wse="http: (05)     xmlns:ow="http: (06)   <s12:Header> (07)     <wsa:Action> (08)       http: (09)     </wsa:Action> (10)     <wsa:MessageID> (11)       uuid:bd88b3df-5db4-4392-9621-aee9160721f6 (12)     </wsa:MessageID> (13)     <wsa:ReplyTo> (14)      <wsa:Address>http: (15)     </wsa:ReplyTo> (16)     <wsa:To> (17)       http: (18)     </wsa:To> (19)     <wse:Identifier> (20)       uuid:22e8a584-0d18-4228-b2a8-3716fa2097fa (21)     </wse:Identifier> (22)   </s12:Header> (23)   <s12:Body> (24)     <wse:Renew> (25)       <wse:Expires>2004-06-26T21:07:00.000-08:00</wse:Expires> (26)     </wse:Renew> (27)   </s12:Body> (28) </s12:Envelope> OMElement subscribeOm = factory.createOMElement("Renew", eventingNamespace);	OMElement expiresOm = factory.createOMElement("Expires", eventingNamespace);	factory.createOMText(expiresOm, expires);	subscribeOm.addChild(expiresOm);	
synapsesubscription renew 

OMElement expiresOm = factory.createOMElement("Expires", eventingNamespace);	factory.createOMText(expiresOm, expires);	subscribeOm.addChild(expiresOm);	SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	OMElement identifierOm = factory.createOMElement("Identifier", eventingNamespace);	factory.createOMText(identifierOm, identifier);	serviceClient.addHeader(identifierOm);	options.setAction("http: OMElement response = serviceClient.sendReceive(subscribeOm);	
synapsesubscription renew to id 

try {	initializeClient(addUrl);	OMElement identifierOm = factory.createOMElement("Identifier", eventingNamespace);	factory.createOMText(identifierOm, identifier);	serviceClient.addHeader(identifierOm);	options.setAction("http: OMElement response = serviceClient.sendReceive(subscribeOm);	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	
synapsesubscription renew response received 

OMElement identifierOm = factory.createOMElement("Identifier", eventingNamespace);	factory.createOMText(identifierOm, identifier);	serviceClient.addHeader(identifierOm);	options.setAction("http: OMElement response = serviceClient.sendReceive(subscribeOm);	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	clientResult.incrementResponseCount();	} catch (Exception e) {	
fault received 

public SampleClientResult getStatus(String addUrl, String identifier) {	(02)     xmlns:s12="http: (03)     xmlns:wsa="http: (04)     xmlns:wse="http: (05)     xmlns:ow="http: (06)   <s12:Header> (07)     <wsa:Action> (08)       http: (09)     </wsa:Action> (10)     <wsa:MessageID> (11)       uuid:bd88b3df-5db4-4392-9621-aee9160721f6 (12)     </wsa:MessageID> (13)     <wsa:ReplyTo> (14)       <wsa:Address>http: (15)     </wsa:ReplyTo> (16)     <wsa:To> (17)       http: (18)     </wsa:To> (19)     <wse:Identifier> (20)       uuid:22e8a584-0d18-4228-b2a8-3716fa2097fa (21)     </wse:Identifier> (22)   </s12:Header> (23)   <s12:Body> (24)     <wse:GetStatus /> (25)   </s12:Body> (26) </s12:Envelope> OMElement subscribeOm = factory.createOMElement("GetStatus", eventingNamespace);	
getstatus using 

public SampleClientResult getStatus(String addUrl, String identifier) {	(02)     xmlns:s12="http: (03)     xmlns:wsa="http: (04)     xmlns:wse="http: (05)     xmlns:ow="http: (06)   <s12:Header> (07)     <wsa:Action> (08)       http: (09)     </wsa:Action> (10)     <wsa:MessageID> (11)       uuid:bd88b3df-5db4-4392-9621-aee9160721f6 (12)     </wsa:MessageID> (13)     <wsa:ReplyTo> (14)       <wsa:Address>http: (15)     </wsa:ReplyTo> (16)     <wsa:To> (17)       http: (18)     </wsa:To> (19)     <wse:Identifier> (20)       uuid:22e8a584-0d18-4228-b2a8-3716fa2097fa (21)     </wse:Identifier> (22)   </s12:Header> (23)   <s12:Body> (24)     <wse:GetStatus /> (25)   </s12:Body> (26) </s12:Envelope> OMElement subscribeOm = factory.createOMElement("GetStatus", eventingNamespace);	SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	options.setAction("http: OMElement identifierOm = factory.createOMElement("Identifier", eventingNamespace);	factory.createOMText(identifierOm, identifier);	serviceClient.addHeader(identifierOm);	OMElement response = serviceClient.sendReceive(subscribeOm);	
getstatus to id 

try {	initializeClient(addUrl);	options.setAction("http: OMElement identifierOm = factory.createOMElement("Identifier", eventingNamespace);	factory.createOMText(identifierOm, identifier);	serviceClient.addHeader(identifierOm);	OMElement response = serviceClient.sendReceive(subscribeOm);	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	
getstatus response received 

options.setAction("http: OMElement identifierOm = factory.createOMElement("Identifier", eventingNamespace);	factory.createOMText(identifierOm, identifier);	serviceClient.addHeader(identifierOm);	OMElement response = serviceClient.sendReceive(subscribeOm);	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	clientResult.incrementResponseCount();	} catch (Exception e) {	
fault received 

public SampleClientResult sendEvent(String addUrl, String symbol, String price, String qty, String topic, String topicns) {	SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	OMNamespace aipNamespace = factory.createOMNamespace(topicns, "aip");	OMElement topicOm = factory.createOMElement("Topic", aipNamespace);	factory.createOMText(topicOm, topic);	serviceClient.addHeader(topicOm);	options.setProperty(MessageContext.CLIENT_API_NON_BLOCKING, Boolean.FALSE);	OMElement payload = AXIOMUtil.stringToOM("<m:placeOrder xmlns:m=\"http: "    <m:order>\n" + "        <m:price>" + price + "</m:price>\n" + "        <m:quantity>" + qty + "</m:quantity>\n" + "        <m:symbol>" + symbol + "</m:symbol>\n" + "    </m:order>\n" + "</m:placeOrder>");	
sending event 

SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	OMNamespace aipNamespace = factory.createOMNamespace(topicns, "aip");	OMElement topicOm = factory.createOMElement("Topic", aipNamespace);	factory.createOMText(topicOm, topic);	serviceClient.addHeader(topicOm);	options.setProperty(MessageContext.CLIENT_API_NON_BLOCKING, Boolean.FALSE);	OMElement payload = AXIOMUtil.stringToOM("<m:placeOrder xmlns:m=\"http: "    <m:order>\n" + "        <m:price>" + price + "</m:price>\n" + "        <m:quantity>" + qty + "</m:quantity>\n" + "        <m:symbol>" + symbol + "</m:symbol>\n" + "    </m:order>\n" + "</m:placeOrder>");	serviceClient.fireAndForget(payload);	
event sent to topic 

OMNamespace aipNamespace = factory.createOMNamespace(topicns, "aip");	OMElement topicOm = factory.createOMElement("Topic", aipNamespace);	factory.createOMText(topicOm, topic);	serviceClient.addHeader(topicOm);	options.setProperty(MessageContext.CLIENT_API_NON_BLOCKING, Boolean.FALSE);	OMElement payload = AXIOMUtil.stringToOM("<m:placeOrder xmlns:m=\"http: "    <m:order>\n" + "        <m:price>" + price + "</m:price>\n" + "        <m:quantity>" + qty + "</m:quantity>\n" + "        <m:symbol>" + symbol + "</m:symbol>\n" + "    </m:order>\n" + "</m:placeOrder>");	serviceClient.fireAndForget(payload);	Thread.sleep(1000);	clientResult.incrementResponseCount();	} catch (Exception e) {	
fault received 

========================= synapse sample_789 =========================

public void handleIncomingMessage( MessageContext msgCtx, Map trpHeaders, String soapAction, String contentType) {	if (soapAction != null) {	msgCtx.setSoapAction(soapAction);	}	msgCtx.setProperty(MessageContext.TRANSPORT_HEADERS, trpHeaders);	try {	try {	engine.receive(msgCtx);	} catch (AxisFault e) {	if (log.isDebugEnabled()) {	
error receiving message 

public MessageContext createResponseMessageContext(MessageContext outMsgCtx) {	MessageContext responseMsgCtx = null;	try {	responseMsgCtx = outMsgCtx.getOperationContext(). getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);	} catch (AxisFault af) {	
error getting in message context from the operation context 

========================= synapse sample_3779 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
startuptask deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	Startup st = StartupFinder.getInstance().getStartup(artifactConfig, properties);	st.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
startuptask named has been built from the file 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	Startup st = StartupFinder.getInstance().getStartup(artifactConfig, properties);	st.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	st.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	
initialized the startuptask 

try {	Startup st = StartupFinder.getInstance().getStartup(artifactConfig, properties);	st.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	st.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addStartup(st);	if (log.isDebugEnabled()) {	
startuptask deployment from file completed 

Startup st = StartupFinder.getInstance().getStartup(artifactConfig, properties);	st.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	st.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addStartup(st);	if (log.isDebugEnabled()) {	}	
startuptask named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
startuptask update from file has started 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	Startup st = StartupFinder.getInstance().getStartup(artifactConfig, properties);	st.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
startuptask has been built from the file 

if (log.isDebugEnabled()) {	}	Startup existingSt = getSynapseConfiguration().getStartup(existingArtifactName);	existingSt.destroy();	st.init(getSynapseEnvironment());	if (existingArtifactName.equals(st.getName())) {	getSynapseConfiguration().updateStartup(st);	} else {	getSynapseConfiguration().addStartup(st);	getSynapseConfiguration().removeStartup(existingArtifactName);	
startuptask has been undeployed 

}	Startup existingSt = getSynapseConfiguration().getStartup(existingArtifactName);	existingSt.destroy();	st.init(getSynapseEnvironment());	if (existingArtifactName.equals(st.getName())) {	getSynapseConfiguration().updateStartup(st);	} else {	getSynapseConfiguration().addStartup(st);	getSynapseConfiguration().removeStartup(existingArtifactName);	}	
startuptask has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
startuptask undeployment of the task named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	Startup st = getSynapseConfiguration().getStartup(artifactName);	if (st != null) {	getSynapseConfiguration().removeStartup(artifactName);	if (log.isDebugEnabled()) {	
destroying the startuptask named 

if (log.isDebugEnabled()) {	}	try {	Startup st = getSynapseConfiguration().getStartup(artifactName);	if (st != null) {	getSynapseConfiguration().removeStartup(artifactName);	if (log.isDebugEnabled()) {	}	st.destroy();	if (log.isDebugEnabled()) {	
startuptask undeployment of the sequence named completed 

}	try {	Startup st = getSynapseConfiguration().getStartup(artifactName);	if (st != null) {	getSynapseConfiguration().removeStartup(artifactName);	if (log.isDebugEnabled()) {	}	st.destroy();	if (log.isDebugEnabled()) {	}	
startuptask named has been undeployed 

try {	Startup st = getSynapseConfiguration().getStartup(artifactName);	if (st != null) {	getSynapseConfiguration().removeStartup(artifactName);	if (log.isDebugEnabled()) {	}	st.destroy();	if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
startup task has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the startuptask with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	Startup st = getSynapseConfiguration().getStartup(artifactName);	OMElement stElem = StartupFinder.getInstance().serializeStartup(null, st);	if (st.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.TASKS_DIR + File.separator + st.getFileName();	writeToFile(stElem, fileName);	if (log.isDebugEnabled()) {	
restoring the startuptask with name completed 

if (log.isDebugEnabled()) {	}	try {	Startup st = getSynapseConfiguration().getStartup(artifactName);	OMElement stElem = StartupFinder.getInstance().serializeStartup(null, st);	if (st.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.TASKS_DIR + File.separator + st.getFileName();	writeToFile(stElem, fileName);	if (log.isDebugEnabled()) {	}	
startuptask named has been restored 

========================= synapse sample_1601 =========================

public int getPriority(String ip, EndpointReference to) {	int priority=-1;	Map clientMap = (Map) SLAConfig.get(ip);	if(clientMap!=null){	
address 

========================= synapse sample_2884 =========================

public void testCallOutDefinedEndpoint() {	
running test callout mediator invoke a service using a defined endpoint 

========================= synapse sample_2241 =========================

public void testMessageEnrichment() {	String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test message enrichment through synapse 

========================= synapse sample_859 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start script mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

}	boolean returnValue;	if (multiThreadedEngine) {	returnValue = invokeScript(synCtx);	} else {	synchronized (scriptEngine.getClass()) {	returnValue = invokeScript(synCtx);	}	}	if (synLog.isTraceTraceEnabled()) {	
result message after execution of script 

if (multiThreadedEngine) {	returnValue = invokeScript(synCtx);	} else {	synchronized (scriptEngine.getClass()) {	returnValue = invokeScript(synCtx);	}	}	if (synLog.isTraceTraceEnabled()) {	}	if (synLog.isTraceOrDebugEnabled()) {	
end script mediator return value 

protected void initInlineScript() {	try {	initScriptEngine();	if (scriptEngine instanceof Compilable) {	if (log.isDebugEnabled()) {	
script engine supports compilable interface compiling script code 

protected void initInlineScript() {	try {	initScriptEngine();	if (scriptEngine instanceof Compilable) {	if (log.isDebugEnabled()) {	}	compiledScript = ((Compilable) scriptEngine).compile(scriptSourceCode);	} else {	if (log.isDebugEnabled()) {	
script engine does not support the compilable interface in lined script would be evaluated on each invocation 

}	}	}	for (Value includeKey : includes.keySet()) {	String includeSourceCode = (String) includes.get(includeKey);	String generatedKey = includeKey.evaluateValue(synCtx);	Entry includeEntry = synCtx.getConfiguration().getEntryDefinition(generatedKey);	boolean includeEntryNeedsReload = (includeEntry != null) && includeEntry.isDynamic() && (!includeEntry.isCached() || includeEntry.isExpired());	synchronized (resourceLock) {	if (includeSourceCode == null || includeEntryNeedsReload) {	
re loading the include script with key 

protected void initScriptEngine() {	if (log.isDebugEnabled()) {	
initializing script mediator for language 

ScriptEngineManager manager = new ScriptEngineManager();	manager.registerEngineExtension("js", new RhinoScriptEngineFactory());	manager.registerEngineExtension("groovy", new GroovyScriptEngineFactory());	manager.registerEngineExtension("rb", new JRubyScriptEngineFactory());	this.scriptEngine = manager.getEngineByExtension(language);	if (scriptEngine == null) {	handleException("No script engine found for language: " + language);	}	xmlHelper = XMLHelper.getArgHelper(scriptEngine);	this.multiThreadedEngine = scriptEngine.getFactory().getParameter("THREADING") != null;	
script mediator for language supports multithreading 

========================= synapse sample_2580 =========================

if (bindAddressParameter != null) {	this.bindAddress = ((String) bindAddressParameter.getValue()).trim();	}	Parameter hostParameter = parameters.getParameter(TransportListener.HOST_ADDRESS);	if (hostParameter != null) {	host = ((String) hostParameter.getValue()).trim();	} else {	try {	host = java.net.InetAddress.getLocalHost().getHostName();	} catch (UnknownHostException e) {	
unable to lookup local host name using localhost 

========================= synapse sample_2353 =========================

public static ServerConfigurationInformation createServerConfigurationInformation( String[] args) {	ServerConfigurationInformation information = new ServerConfigurationInformation();	information.setAxis2RepoLocation(args[0]);	if (args.length == 1) {	
configuring server manager using deprecated system properties please update your configuration 

public static ServerConfigurationInformation createServerConfigurationInformation( ServletConfig servletConfig) {	ServerConfigurationInformation information = new ServerConfigurationInformation();	String synapseHome = loadParameter(servletConfig, SynapseConstants.SYNAPSE_HOME, false);	if (synapseHome == null) {	
synapse home not set using web application root as default value 

public static ServerConfigurationInformation createServerConfigurationInformation( ServletConfig servletConfig) {	ServerConfigurationInformation information = new ServerConfigurationInformation();	String synapseHome = loadParameter(servletConfig, SynapseConstants.SYNAPSE_HOME, false);	if (synapseHome == null) {	String webInfPath = servletConfig.getServletContext().getRealPath("WEB-INF");	if (webInfPath == null || !webInfPath.endsWith("WEB-INF")) {	handleFatal("Unable to currentState web application root directory");	} else {	synapseHome = webInfPath.substring(0, webInfPath.length() - 7);	
setting synapse home to 

private static String getArgument(CommandLine cmd, String argName) {	if (cmd == null) {	handleFatal("CommandLine is null");	} else {	if (argName == null || "".equals(argName)) {	if (log.isDebugEnabled()) {	
provided argument name is null returning null as value 

private static String loadParameter(ServletConfig servletConfig, String name, boolean required) {	if (System.getProperty(name) == null) {	String value = servletConfig.getInitParameter(name);	if (log.isDebugEnabled()) {	
init parameter 

========================= synapse sample_1986 =========================

public void writeTo(MessageContext messageContext, OMOutputFormat format, OutputStream outputStream, boolean preserve) throws AxisFault {	try {	if (log.isDebugEnabled()) {	
serialize message in to a gzip stream 

========================= synapse sample_4287 =========================

private void registerExtensions() {	Iterator it = Service.providers(StartupFactory.class);	while (it.hasNext()) {	StartupFactory sf = (StartupFactory) it.next();	QName tag = sf.getTagQName();	factoryMap.put(tag, sf.getClass());	serializerMap.put(tag, sf.getSerializerClass());	if (log.isDebugEnabled()) {	
added startupfactory to handle 

public Startup getStartup(OMElement element) {	QName qName = element.getQName();	if (log.isDebugEnabled()) {	
creating the startup for 

========================= synapse sample_3542 =========================

try {	xp = new AXIOMXPath(omPath.getText());	OMElementUtils.addNameSpaces(xp, elem, log);	if(omNS != null){	String prefix = omNS.getAttributeValue(new QName(Constants.NULL_NAMESPACE, "prefix"));	String name = omNS.getAttributeValue(new QName(Constants.NULL_NAMESPACE, "name"));	xp.addNamespace(prefix,name);	}	mediator.setAttachmentPath(xp);	} catch (JaxenException e) {	
error creating xpath for element 

========================= synapse sample_3112 =========================

Parameter trustParam  = transportIn.getParameter("truststore");	if (keyParam != null) {	OMElement ksEle      = keyParam.getParameterElement().getFirstElement();	String location      = ksEle.getFirstChildWithName(new QName("Location")).getText();	String type          = ksEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = ksEle.getFirstChildWithName(new QName("Password")).getText();	String keyPassword   = ksEle.getFirstChildWithName(new QName("KeyPassword")).getText();	try {	KeyStore keyStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	
loading key store from url 

String storePassword = ksEle.getFirstChildWithName(new QName("Password")).getText();	String keyPassword   = ksEle.getFirstChildWithName(new QName("KeyPassword")).getText();	try {	KeyStore keyStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	keyStore.load(url.openStream(), storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

try {	KeyStore keyStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	keyStore.load(url.openStream(), storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

}	}	if (trustParam != null) {	OMElement tsEle      = trustParam.getParameterElement().getFirstElement();	String location      = tsEle.getFirstChildWithName(new QName("Location")).getText();	String type          = tsEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = tsEle.getFirstChildWithName(new QName("Password")).getText();	try {	KeyStore trustStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	
loading trust key store from url 

String type          = tsEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = tsEle.getFirstChildWithName(new QName("Password")).getText();	try {	KeyStore trustStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	trustStore.load(url.openStream(), storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

try {	KeyStore trustStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	trustStore.load(url.openStream(), storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	throw new AxisFault("Error opening Key store : " + location, ioe);	}	}	try {	SSLContext sslcontext = SSLContext.getInstance("TLS");	sslcontext.init(keymanagers, trustManagers, null);	return sslcontext;	} catch (GeneralSecurityException gse) {	
unable to create ssl context with the given configuration 

========================= synapse sample_3407 =========================

public static SynapseConfiguration getConfiguration(String configFile) {	try {	SynapseConfiguration synCfg = XMLConfigurationBuilder.getConfiguration(new FileInputStream(configFile));	
loaded synapse configuration from 

========================= synapse sample_3057 =========================

public boolean startProcess() {	processException = null;	synchronized (synapseServer) {	synapseServer.start();	while (serverState <= STARTING_UP) {	try {	synapseServer.wait(1000);	} catch (InterruptedException e) {	
synapse startup was interrupted 

synapseServer.start();	while (serverState <= STARTING_UP) {	try {	synapseServer.wait(1000);	} catch (InterruptedException e) {	return false;	}	}	}	if (serverState == STARTUP_FAILED) {	
synapse failed to start 

public boolean stopProcess() {	if (serverState == SERVER_ACTIVE) {	synchronized (synapseServer) {	serverState = SHUTTING_DOWN;	synapseServer.notifyAll();	while (serverState > UNDEFINED) {	try {	synapseServer.wait(1000);	} catch (InterruptedException e) {	
synapse shutdown was interrupted 

public void run() {	
starting up synapse 

} finally {	synchronized (this) {	this.notifyAll();	}	}	synchronized (this) {	while (serverState < SHUTTING_DOWN) {	try {	this.wait(1000);	} catch (InterruptedException e) {	
server interrupted 

}	}	synchronized (this) {	while (serverState < SHUTTING_DOWN) {	try {	this.wait(1000);	} catch (InterruptedException e) {	}	}	}	
shutting down synapse 

========================= synapse sample_2216 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start cache mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

if (synLog.isTraceTraceEnabled()) {	}	}	if (maxMessageSize > 0) {	FixedByteArrayOutputStream fbaos = new FixedByteArrayOutputStream(maxMessageSize);	try {	MessageHelper.cloneSOAPEnvelope(synCtx.getEnvelope()).serialize(fbaos);	} catch (XMLStreamException e) {	handleException("Error in checking the message size", e, synCtx);	} catch (SynapseException syne) {	
message size exceeds the upper bound for caching request will not be cached 

} catch (SynapseException syne) {	return true;	}	}	ConfigurationContext cfgCtx = ((Axis2MessageContext) synCtx).getAxis2MessageContext().getConfigurationContext();	if (cfgCtx == null) {	handleException("Unable to perform caching, " + " ConfigurationContext cannot be found", synCtx);	return false;	}	if (synLog.isTraceOrDebugEnabled()) {	
looking up cache at scope with id 

Object prop = cfgCtx.getPropertyNonReplicable(CachingConstants.CACHE_MANAGER);	CacheManager cacheManager;	if (prop != null && prop instanceof CacheManager) {	cacheManager = (CacheManager) prop;	} else {	synchronized (cfgCtx) {	prop = cfgCtx.getPropertyNonReplicable(CachingConstants.CACHE_MANAGER);	if (prop != null && prop instanceof CacheManager) {	cacheManager = (CacheManager) prop;	} else {	
creating recreating the cache object 

}	}	boolean result = true;	try {	if (synCtx.isResponse()) {	processResponseMessage(synCtx, synLog);	} else {	result = processRequestMessage(synCtx, synLog, cacheManager);	}	} catch (ClusteringFault clusteringFault) {	
unable to replicate cache mediator state among the cluster 

}	boolean result = true;	try {	if (synCtx.isResponse()) {	processResponseMessage(synCtx, synLog);	} else {	result = processRequestMessage(synCtx, synLog, cacheManager);	}	} catch (ClusteringFault clusteringFault) {	}	
end cache mediator 

private void processResponseMessage(MessageContext synCtx, SynapseLog synLog) throws ClusteringFault {	if (!collector) {	handleException("Response messages cannot be handled in a non collector cache", synCtx);	}	org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext)synCtx).getAxis2MessageContext();	OperationContext operationContext = msgCtx.getOperationContext();	CachableResponse response = (CachableResponse) operationContext.getPropertyNonReplicable(CachingConstants.CACHED_OBJECT);	if (response != null) {	if (synLog.isTraceOrDebugEnabled()) {	
storing the response message into the cache at scope with id for request hash 

if (!collector) {	handleException("Response messages cannot be handled in a non collector cache", synCtx);	}	org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext)synCtx).getAxis2MessageContext();	OperationContext operationContext = msgCtx.getOperationContext();	CachableResponse response = (CachableResponse) operationContext.getPropertyNonReplicable(CachingConstants.CACHED_OBJECT);	if (response != null) {	if (synLog.isTraceOrDebugEnabled()) {	}	if (synLog.isTraceOrDebugEnabled()) {	
storing the response for the message with id with request hash id in the cache 

handleException("Unable to set the response to the Cache", e, synCtx);	}	if (response.getTimeout() > 0) {	response.setExpireTimeMillis(System.currentTimeMillis() + response.getTimeout());	}	CacheReplicationCommand cacheReplicationCommand = (CacheReplicationCommand) msgCtx.getPropertyNonReplicable( CachingConstants.STATE_REPLICATION_OBJECT);	if (cacheReplicationCommand != null) {	try {	Replicator.replicateState(cacheReplicationCommand, msgCtx.getRootContext().getAxisConfiguration());	} catch (ClusteringFault clusteringFault) {	
cannot replicate cache changes 

}	OperationContext opCtx = ((Axis2MessageContext)synCtx).getAxis2MessageContext(). getOperationContext();	String requestHash = null;	try {	requestHash = digestGenerator.getDigest( ((Axis2MessageContext) synCtx).getAxis2MessageContext());	synCtx.setProperty(CachingConstants.REQUEST_HASH, requestHash);	} catch (CachingException e) {	handleException("Error in calculating the hash value of the request", e, synCtx);	}	if (synLog.isTraceOrDebugEnabled()) {	
generated request hash 

service = new ServiceName(cacheKey);	}	RequestHash hash = new RequestHash(requestHash);	CachableResponse cachedResponse = cacheManager.getCachedResponse(service, hash);	org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext)synCtx).getAxis2MessageContext();	opCtx.setNonReplicableProperty(CachingConstants.REQUEST_HASH, requestHash);	CacheReplicationCommand cacheReplicationCommand = new CacheReplicationCommand();	if (cachedResponse != null) {	if (!cachedResponse.isExpired()) {	if (synLog.isTraceOrDebugEnabled()) {	
cache hit for message id 

synCtx.setEnvelope(omSOAPEnv);	}	} catch (AxisFault axisFault) {	handleException("Error setting response envelope from cache : " + cacheKey, synCtx);	} catch (IOException ioe) {	handleException("Error setting response envelope from cache : " + cacheKey, ioe, synCtx);	} catch (SOAPException soape) {	handleException("Error setting response envelope from cache : " + cacheKey, soape, synCtx);	}	if (onCacheHitSequence != null) {	
delegating message to the oncachinghit anonymous sequence 

handleException("Error setting response envelope from cache : " + cacheKey, synCtx);	} catch (IOException ioe) {	handleException("Error setting response envelope from cache : " + cacheKey, ioe, synCtx);	} catch (SOAPException soape) {	handleException("Error setting response envelope from cache : " + cacheKey, soape, synCtx);	}	if (onCacheHitSequence != null) {	onCacheHitSequence.mediate(synCtx);	} else if (onCacheHitRef != null) {	if (synLog.isTraceOrDebugEnabled()) {	
delegating message to the oncachinghit sequence 

handleException("Error setting response envelope from cache : " + cacheKey, soape, synCtx);	}	if (onCacheHitSequence != null) {	onCacheHitSequence.mediate(synCtx);	} else if (onCacheHitRef != null) {	if (synLog.isTraceOrDebugEnabled()) {	}	synCtx.getSequence(onCacheHitRef).mediate(synCtx);	} else {	if (synLog.isTraceOrDebugEnabled()) {	
request message was served from the cache 

} else {	if (synLog.isTraceOrDebugEnabled()) {	}	synCtx.setTo(null);	Axis2Sender.sendBack(synCtx);	}	return false;	} else {	cachedResponse.reincarnate(timeout);	if (synLog.isTraceOrDebugEnabled()) {	
existing cached response has expired reset cache element 

cacheManager.cacheResponse(service, hash, cachedResponse, cacheReplicationCommand);	opCtx.setNonReplicableProperty(CachingConstants.CACHED_OBJECT, cachedResponse);	opCtx.setNonReplicableProperty(CachingConstants.STATE_REPLICATION_OBJECT, cacheReplicationCommand);	Replicator.replicate(opCtx);	}	} else {	if (cacheManager.getCacheSize(service) >= inMemoryCacheSize) {	cacheManager.removeExpiredResponses(service, cacheReplicationCommand);	if (cacheManager.getCacheSize(service) >= inMemoryCacheSize) {	if (log.isDebugEnabled()) {	
in memory cache is full unable to cache 

========================= synapse sample_1969 =========================

if (information.isCreateNewInstance()) {	validatePath("Axis2 repository", information.getAxis2RepoLocation());	validatePath("axis2.xml location", information.getAxis2Xml());	}	validatePath("synapse.xml location", information.getSynapseXMLLocation());	String serverName = information.getServerName();	if (serverName == null) {	try {	serverName = InetAddress.getLocalHost().getHostName();	} catch (UnknownHostException ignore) {}	
the server name was not specified defaulting to 

validatePath("Axis2 repository", information.getAxis2RepoLocation());	validatePath("axis2.xml location", information.getAxis2Xml());	}	validatePath("synapse.xml location", information.getSynapseXMLLocation());	String serverName = information.getServerName();	if (serverName == null) {	try {	serverName = InetAddress.getLocalHost().getHostName();	} catch (UnknownHostException ignore) {}	} else {	
using server name 

}	validatePath("synapse.xml location", information.getSynapseXMLLocation());	String serverName = information.getServerName();	if (serverName == null) {	try {	serverName = InetAddress.getLocalHost().getHostName();	} catch (UnknownHostException ignore) {}	} else {	}	if (log.isDebugEnabled()) {	
using server configuration as 

validatePath("synapse.xml location", information.getSynapseXMLLocation());	String serverName = information.getServerName();	if (serverName == null) {	try {	serverName = InetAddress.getLocalHost().getHostName();	} catch (UnknownHostException ignore) {}	} else {	}	if (log.isDebugEnabled()) {	}	
the timeout handler will run every s 

private static void validatePath(String msgPre, String path) {	if (path == null) {	handleFatal("The " + msgPre + " must be set as a system property or init-parameter");	} else if (!new File(path).exists()) {	handleFatal("The " + msgPre + " " + path + " doesn't exist");	} else {	
using 

========================= synapse sample_1987 =========================

public void init(SecretCallbackHandler secretCallbackHandler) {	if (initialized) {	if (log.isDebugEnabled()) {	
secretresolver already has been started 

public String resolve(String encryptedPassword, String prompt) {	assertInitialized();	if (encryptedPassword == null || "".equals(encryptedPassword)) {	if (log.isDebugEnabled()) {	
given encrypted password is empty or null returning itself 

========================= synapse sample_1084 =========================

public void onCreate(SessionID sessionID) {	
new fix session created 

public void toAdmin(Message message, SessionID sessionID) {	if (log.isDebugEnabled()) {	StringBuffer sb = new StringBuffer();	try {	sb.append("Sending admin level FIX message to ").append(message.getHeader().getField(new TargetCompID()).getValue());	sb.append("\nMessage Type: ").append(message.getHeader().getField(new MsgType()).getValue());	sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nSender ID: ").append(message.getHeader().getField(new SenderCompID()).getValue());	} catch (FieldNotFound e) {	sb.append("Sending admin level FIX message...");	
one or more required fields are not found in the response message 

try {	sb.append("Sending admin level FIX message to ").append(message.getHeader().getField(new TargetCompID()).getValue());	sb.append("\nMessage Type: ").append(message.getHeader().getField(new MsgType()).getValue());	sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nSender ID: ").append(message.getHeader().getField(new SenderCompID()).getValue());	} catch (FieldNotFound e) {	sb.append("Sending admin level FIX message...");	}	log.debug(sb.toString());	if (log.isTraceEnabled()) {	
message 

public void fromAdmin(Message message, SessionID sessionID) throws FieldNotFound, IncorrectDataFormat, IncorrectTagValue, RejectLogon {	if (log.isDebugEnabled()) {	StringBuffer sb = new StringBuffer();	sb.append("Received admin level FIX message from ").append(message.getHeader().getField(new SenderCompID()).getValue());	sb.append("\nMessage Type: ").append(message.getHeader().getField(new MsgType()).getValue());	sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nReceiver ID: ").append(message.getHeader().getField(new TargetCompID()).getValue());	log.debug(sb.toString());	if (log.isTraceEnabled()) {	
message 

public void toApp(Message message, SessionID sessionID) throws DoNotSend {	if (log.isDebugEnabled()) {	StringBuffer sb = new StringBuffer();	try {	sb.append("Sending application level FIX message to ").append(message.getHeader().getField(new TargetCompID()).getValue());	sb.append("\nMessage Type: ").append(message.getHeader().getField(new MsgType()).getValue());	sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nSender ID: ").append(message.getHeader().getField(new SenderCompID()).getValue());	} catch (FieldNotFound e) {	sb.append("Sending application level FIX message...");	
one or more required fields are not found in the response message 

try {	sb.append("Sending application level FIX message to ").append(message.getHeader().getField(new TargetCompID()).getValue());	sb.append("\nMessage Type: ").append(message.getHeader().getField(new MsgType()).getValue());	sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nSender ID: ").append(message.getHeader().getField(new SenderCompID()).getValue());	} catch (FieldNotFound e) {	sb.append("Sending application level FIX message...");	}	log.debug(sb.toString());	if (log.isTraceEnabled()) {	
message 

public void fromApp(Message message, SessionID sessionID) throws FieldNotFound, IncorrectDataFormat, IncorrectTagValue, UnsupportedMessageType {	if (log.isDebugEnabled()) {	StringBuffer sb = new StringBuffer();	sb.append("Received FIX message from ").append(message.getHeader().getField(new SenderCompID()).getValue());	sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nReceiver ID: ").append(message.getHeader().getField(new TargetCompID()).getValue());	log.debug(sb.toString());	if (log.isTraceEnabled()) {	
message 

========================= synapse sample_4269 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start property mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

org.apache.axis2.context.MessageContext axis2MessageCtx = axis2smc.getAxis2MessageContext();	axis2MessageCtx.removeProperty(name);	} else if (XMLConfigConstants.SCOPE_TRANSPORT.equals(scope) && synCtx instanceof Axis2MessageContext) {	Axis2MessageContext axis2smc = (Axis2MessageContext) synCtx;	org.apache.axis2.context.MessageContext axis2MessageCtx = axis2smc.getAxis2MessageContext();	Object headers = axis2MessageCtx.getProperty( org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);	if (headers != null && headers instanceof Map) {	Map headersMap = (Map) headers;	headersMap.remove(name);	} else {	
no transport headers found for the message 

Axis2MessageContext axis2smc = (Axis2MessageContext) synCtx;	org.apache.axis2.context.MessageContext axis2MessageCtx = axis2smc.getAxis2MessageContext();	Object headers = axis2MessageCtx.getProperty( org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);	if (headers != null && headers instanceof Map) {	Map headersMap = (Map) headers;	headersMap.remove(name);	} else {	}	}	}	
end property mediator 

========================= synapse sample_1968 =========================

public void run() {	if (log.isDebugEnabled()) {	
time and this aggregator expired at 

========================= synapse sample_3685 =========================

protected String extractSessionID(OMElement header, QName keyQName) {	OMElement sgcIDElm = getHeaderBlock(header, keyQName);	if (sgcIDElm != null) {	String sgcID = sgcIDElm.getText();	if (sgcID != null && !"".equals(sgcID)) {	return sgcID.trim();	} else {	if (log.isDebugEnabled()) {	
is null or empty 

if (sgcIDElm != null) {	String sgcID = sgcIDElm.getText();	if (sgcID != null && !"".equals(sgcID)) {	return sgcID.trim();	} else {	if (log.isDebugEnabled()) {	}	}	} else {	if (log.isDebugEnabled()) {	
couldn t find the soap header to find the session 

protected String extractSessionID(MessageContext synCtx, String key) {	if (key != null) {	Map headerMap = getTransportHeaderMap(synCtx);	if (headerMap != null) {	Object hostObj = headerMap.get("Host");	if (log.isDebugEnabled()) {	
a request received with the host name 

if (key != null) {	Map headerMap = getTransportHeaderMap(synCtx);	if (headerMap != null) {	Object hostObj = headerMap.get("Host");	if (log.isDebugEnabled()) {	}	Object cookieObj = headerMap.get(key);	if (cookieObj instanceof String) {	String cookie = (String) cookieObj;	if (log.isDebugEnabled()) {	
cookies string 

if (log.isDebugEnabled()) {	}	Object cookieObj = headerMap.get(key);	if (cookieObj instanceof String) {	String cookie = (String) cookieObj;	if (log.isDebugEnabled()) {	}	String[] sessionIds = cookie.split(";");	if (sessionIds == null || sessionIds.length == 0) {	if (log.isDebugEnabled()) {	
cannot find a session id for the cookie 

}	String[] sessionIds = cookie.split(";");	if (sessionIds == null || sessionIds.length == 0) {	if (log.isDebugEnabled()) {	}	return null;	}	for (String sessionId : sessionIds){	if(sessionId != null && sessionId.indexOf("JSESSIONID") != -1) {	if (log.isDebugEnabled()) {	
extracted sessionid 

for (String sessionId : sessionIds){	if(sessionId != null && sessionId.indexOf("JSESSIONID") != -1) {	if (log.isDebugEnabled()) {	}	return sessionId.trim();	}	}	return null;	} else {	if (log.isDebugEnabled()) {	
couldn t find the header to find the session 

return sessionId.trim();	}	}	return null;	} else {	if (log.isDebugEnabled()) {	}	}	} else {	if (log.isDebugEnabled()) {	
couldn t find the transport headers to find the session 

========================= synapse sample_225 =========================

public SessionInformation getSession(MessageContext synCtx) {	String hostName = extractHost(synCtx);	if (log.isDebugEnabled()) {	
extracted host name 

public SessionInformation getSession(MessageContext synCtx) {	String hostName = extractHost(synCtx);	if (log.isDebugEnabled()) {	}	org.apache.axis2.context.MessageContext axis2MessageContext = ((Axis2MessageContext) synCtx).getAxis2MessageContext();	if (log.isDebugEnabled()) {	
endpoint address 

public SessionInformation getSession(MessageContext synCtx) {	String hostName = extractHost(synCtx);	if (log.isDebugEnabled()) {	}	org.apache.axis2.context.MessageContext axis2MessageContext = ((Axis2MessageContext) synCtx).getAxis2MessageContext();	if (log.isDebugEnabled()) {	}	Map headerMap = getTransportHeaderMap(synCtx);	String contentType = (String)headerMap.get("Content-Type");	if (log.isDebugEnabled()) {	
content type 

if (sessionList != null) {	for (String sessionID : sessionList) {	SessionInformation sessionInfoObj = SALSessions.getInstance().getSession(sessionID);	if (sessionInfoObj != null && sessionInfoObj.getMember() != null) {	Map<String, String> subDomainNames = (Map<String, String>) sessionInfoObj.getMember().getProperties().get(HOSTS);	if (log.isDebugEnabled()) {	log.debug("Member Domain : " + (subDomainNames != null ? subDomainNames.get(hostName) : null) + " : Session ID " + sessionID);	}	if (subDomainNames != null && subDomainNames.get(hostName) != null) {	if (log.isDebugEnabled()) {	
found a matching sessioninfo object for the 

if (subDomainNames != null && subDomainNames.get(hostName) != null) {	if (log.isDebugEnabled()) {	}	return sessionInfoObj;	}	}	}	}	}	if (log.isDebugEnabled()) {	
did not find a session info obj 

public void updateSession(MessageContext synCtx) {	String sessionId = extractSessionID(synCtx, SET_COOKIE);	if (sessionId != null) {	if (log.isDebugEnabled()) {	
found the http header set cookie for updating the session 

public void updateSession(MessageContext synCtx) {	String sessionId = extractSessionID(synCtx, SET_COOKIE);	if (sessionId != null) {	if (log.isDebugEnabled()) {	
using the session id extracted from the set cookie header 

protected List<String> extractSessionIDs(MessageContext synCtx, String key) {	List<String> sessionList = new ArrayList<String>();	if (key != null) {	Map headerMap = getTransportHeaderMap(synCtx);	if (headerMap != null) {	Object hostObj = headerMap.get("Host");	if (log.isDebugEnabled()) {	
a request received with the host name 

if (key != null) {	Map headerMap = getTransportHeaderMap(synCtx);	if (headerMap != null) {	Object hostObj = headerMap.get("Host");	if (log.isDebugEnabled()) {	}	Object cookieObj = headerMap.get(key);	if (cookieObj instanceof String) {	String cookie = (String) cookieObj;	if (log.isDebugEnabled()) {	
cookies string 

if (log.isDebugEnabled()) {	}	Object cookieObj = headerMap.get(key);	if (cookieObj instanceof String) {	String cookie = (String) cookieObj;	if (log.isDebugEnabled()) {	}	String[] sessionIds = cookie.split(";");	if (sessionIds == null || sessionIds.length == 0) {	if (log.isDebugEnabled()) {	
cannot find a session id for the cookie 

}	String[] sessionIds = cookie.split(";");	if (sessionIds == null || sessionIds.length == 0) {	if (log.isDebugEnabled()) {	}	return null;	}	for(String sessionId : sessionIds){	if(sessionId != null && sessionId.contains("JSESSIONID")) {	if (log.isDebugEnabled()) {	
extracted sessionid 

}	for(String sessionId : sessionIds){	if(sessionId != null && sessionId.contains("JSESSIONID")) {	if (log.isDebugEnabled()) {	}	sessionList.add(sessionId.trim());	}	}	} else {	if (log.isDebugEnabled()) {	
couldn t find the header to find the session 

}	sessionList.add(sessionId.trim());	}	}	} else {	if (log.isDebugEnabled()) {	}	}	} else {	if (log.isDebugEnabled()) {	
couldn t find the transport headers to find the session 

========================= synapse sample_1657 =========================

public void testThrottling() {	String addUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to throttle mediator and concurrency throttling 

========================= synapse sample_2240 =========================

public void addProperty(String name, Property value) {	if(name != null && value != null) {	if(globalProps.containsKey(name)) {	
overiding the global property with name 

node = registry.lookup(value.getKey());	if (node == null) {	handleException("Registry key should map to a XML resource.");	}	} catch (Exception e) {	handleException("Registry key should map to a XML resource.");	}	}	globalProps.put(name, value);	} else {	
name and the value of the property cannot be null 

========================= synapse sample_3001 =========================

public void testManipulatingHeadersAndFiltering() {	String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test dumb client mode 

========================= synapse sample_858 =========================

public void init(ConfigurationContext cfgCtx, TransportInDescription trpInDesc) throws AxisFault {	super.init(cfgCtx, trpInDesc);	fixSessionFactory = FIXSessionFactory.getInstance(new FIXApplicationFactory(cfgCtx));	fixSessionFactory.setListenerThreadPool(this.workerPool);	
fix transport listener initialized 

public void startListeningForService(AxisService service) {	try {	boolean acceptorCreated = fixSessionFactory.createFIXAcceptor(service);	boolean initiatorCreated = fixSessionFactory.createFIXInitiator(service);	if (!acceptorCreated && !initiatorCreated) {	
no acceptor or initiator has been configured for the service disabling the fix transport for this service 

========================= synapse sample_2493 =========================

public void onMessage(org.apache.axis2.context.MessageContext messageContext) {	
response received to the callback 

public void onFault(org.apache.axis2.context.MessageContext messageContext) {	
fault received to the callback 

public void onError(Exception e) {	
error inside callback 

========================= synapse sample_788 =========================

public static OMElement getXMLPayload(SOAPEnvelope envelope) {	SOAPBody body = envelope.getBody();	if (body == null) {	
no body found 

public static OMElement getXMLPayload(SOAPEnvelope envelope) {	SOAPBody body = envelope.getBody();	if (body == null) {	return null;	}	OMElement bodyEl = body.getFirstElement();	if (bodyEl == null) {	
no body child found 

public static DataHandler getBinaryPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(BINARYELT)) {	
wrong qname 

public static DataHandler getBinaryPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(BINARYELT)) {	return null;	}	OMNode textNode = el.getFirstOMChild();	if (textNode.getType() != OMNode.TEXT_NODE) {	
text node not found 

return null;	}	OMNode textNode = el.getFirstOMChild();	if (textNode.getType() != OMNode.TEXT_NODE) {	return null;	}	OMText text = (OMText) textNode;	try {	return (DataHandler) text.getDataHandler();	} catch (ClassCastException ce) {	
cannot get datahandler 

public static DataHandler getBinaryPayload(MessageContext mc) {	if (mc.getEnvelope() == null) {	
null envelope 

public static String getTextPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(TEXTELT)) {	
wrong qname 

public static String getTextPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(TEXTELT)) {	return null;	}	OMNode textNode = el.getFirstOMChild();	if (textNode.getType() != OMNode.TEXT_NODE) {	
text node not found 

public static String getTextPayload(MessageContext mc) {	if (mc.getEnvelope() == null) {	
null envelope 

public static SimpleMap getMapPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(MAPELT)) {	
wrong qname 

public static SimpleMap getMapPayload(MessageContext mc) {	if (mc.getEnvelope() == null) {	
null envelope 

public static void setMapPayload(SOAPEnvelope envelope, SimpleMap map) {	if (map instanceof SimpleMapImpl) {	SimpleMapImpl impl = (SimpleMapImpl) map;	OMElement mapElt = impl.getOMElement(envelope.getOMFactory());	if (mapElt == null) {	
null map element returned 

public static XMLStreamReader getStAXPayload(MessageContext mc) {	if (mc.getEnvelope() == null) {	
null envelope 

========================= synapse sample_272 =========================

public void onMessage(Message message) {	try {	if (log.isDebugEnabled()) {	StringBuffer sb = new StringBuffer();	sb.append("Received JMS message to destination : " + message.getJMSDestination());	sb.append("\nMessage ID : " + message.getJMSMessageID());	sb.append("\nCorrelation ID : " + message.getJMSCorrelationID());	sb.append("\nReplyTo ID : " + message.getJMSReplyTo());	log.debug(sb.toString());	if (log.isTraceEnabled() && message instanceof TextMessage) {	
message 

sb.append("Received JMS message to destination : " + message.getJMSDestination());	sb.append("\nMessage ID : " + message.getJMSMessageID());	sb.append("\nCorrelation ID : " + message.getJMSCorrelationID());	sb.append("\nReplyTo ID : " + message.getJMSReplyTo());	log.debug(sb.toString());	if (log.isTraceEnabled() && message instanceof TextMessage) {	}	}	} catch (JMSException e) {	if (log.isDebugEnabled()) {	
error reading jms message headers for debug logging 

}	}	} catch (JMSException e) {	if (log.isDebugEnabled()) {	}	}	try {	long expiryTime = message.getJMSExpiration();	if (expiryTime > 0 && System.currentTimeMillis() > expiryTime) {	if (log.isDebugEnabled()) {	
discard expired message with id 

========================= synapse sample_3778 =========================

private void registerExtensions() {	Iterator it = Service.providers(StartupFactory.class);	while (it.hasNext()) {	StartupFactory sf = (StartupFactory) it.next();	QName tag = sf.getTagQName();	factoryMap.put(tag, sf.getClass());	serializerMap.put(tag, sf.getSerializerClass());	if (log.isDebugEnabled()) {	
added startupfactory to handle 

public Startup getStartup(OMElement element) {	QName qName = element.getQName();	if (log.isDebugEnabled()) {	
creating the startup for 

========================= synapse sample_4052 =========================

public void writeTo(MessageContext msgCtx, OMOutputFormat format, OutputStream out, boolean preserve) throws AxisFault {	if (log.isDebugEnabled()) {	
start writing the hessian message to outputstream 

public void writeTo(MessageContext msgCtx, OMOutputFormat format, OutputStream out, boolean preserve) throws AxisFault {	if (log.isDebugEnabled()) {	}	if (msgCtx.getFLOW() == MessageContext.OUT_FAULT_FLOW || msgCtx.getEnvelope().hasFault()) {	SOAPFault soapFault = msgCtx.getEnvelope().getBody().getFault();	convertAndWriteHessianFault(soapFault, out);	} else {	writeHessianMessage(msgCtx, out);	}	if (log.isDebugEnabled()) {	
writing message as a hessian message is successful 

try {	inputStream = synapseBinaryDataSource.getInputStream();	IOUtils.copy(inputStream, out);	} catch (IOException e) {	handleException("Couldn't get the bytes from the HessianDataSource", e);	} finally {	if (inputStream != null) {	try {	inputStream.close();	} catch (IOException ignore) {	
error closing input stream 

if (inputStream != null) {	try {	inputStream.close();	} catch (IOException ignore) {	}	}	if (out != null) {	try {	out.close();	} catch (IOException ignore) {	
error closing output stream 

HessianUtils.writeFault(hessianFaultCode, hessianFaultMessage, hessianFaultDetail, faultOutStream);	faultOutStream.flush();	} catch (IOException e) {	handleException("Unalbe to write the fault as a Hessian message", e);	} finally {	try {	if (faultOutStream != null) {	faultOutStream.close();	}	} catch (IOException ignore) {	
error closing output stream 

========================= synapse sample_1180 =========================

msg.setHeader(MailConstants.MAIL_HEADER_MESSAGE_ID, msgId);	msg.setHeader(MailConstants.MAIL_HEADER_X_MESSAGE_ID, msgId);	msg.setText(POX_MESSAGE);	Transport.send(msg);	Thread.yield();	Thread.sleep(100);	Object reply = null;	boolean replyNotFound = true;	int retryCount = 50;	while (replyNotFound) {	
checking for response with messageid 

replyNotFound = false;	} else {	if (retryCount-- > 0) {	Thread.sleep(100);	} else {	break;	}	}	}	if (reply != null && reply instanceof String) {	
result body 

options.setProperty(MailConstants.TRANSPORT_MAIL_FORMAT, MailConstants.TRANSPORT_FORMAT_MP);	ServiceClient sender = new ServiceClient(getClientCfgCtx(), null);	sender.setOptions(options);	sender.fireAndForget(createPayload());	Thread.yield();	Thread.sleep(100);	Object reply = null;	boolean replyNotFound = true;	int retryCount = 50;	while (replyNotFound) {	
checking for response with messageid 

replyNotFound = false;	} else {	if (retryCount-- > 0) {	Thread.sleep(100);	} else {	break;	}	}	}	if (reply != null && reply instanceof String) {	
result body 

options.setProperty(MailConstants.TRANSPORT_MAIL_FORMAT, MailConstants.TRANSPORT_FORMAT_MP);	ServiceClient sender = new ServiceClient(getClientCfgCtx(), null);	sender.setOptions(options);	sender.fireAndForget(createKoreanPayload());	Thread.yield();	Thread.sleep(100);	Object reply = null;	boolean replyNotFound = true;	int retryCount = 50;	while (replyNotFound) {	
checking for response with messageid 

replyNotFound = false;	} else {	if (retryCount-- > 0) {	Thread.sleep(100);	} else {	break;	}	}	}	if (reply != null && reply instanceof String) {	
result body 

options.setMessageId(msgId);	ServiceClient sender = new ServiceClient(getClientCfgCtx(), null);	sender.setOptions(options);	sender.fireAndForget(createPayload());	Thread.yield();	Thread.sleep(100);	Object reply = null;	boolean replyNotFound = true;	int retryCount = 50;	while (replyNotFound) {	
checking for response with messageid 

replyNotFound = false;	} else {	if (retryCount-- > 0) {	Thread.sleep(100);	} else {	break;	}	}	}	if (reply != null && reply instanceof String) {	
result body 

options.setMessageId(msgId);	ServiceClient sender = new ServiceClient(getClientCfgCtx(), null);	sender.setOptions(options);	sender.fireAndForget(createKoreanPayload());	Thread.yield();	Thread.sleep(100);	Object reply = null;	boolean replyNotFound = true;	int retryCount = 50;	while (replyNotFound) {	
checking for response with messageid 

replyNotFound = false;	} else {	if (retryCount-- > 0) {	Thread.sleep(100);	} else {	break;	}	}	}	if (reply != null && reply instanceof String) {	
result body 

options.setProperty(Constants.Configuration. CHARACTER_SET_ENCODING, KOREAN_CHARSET);	ServiceClient sender = new ServiceClient(getClientCfgCtx(), null);	sender.setOptions(options);	sender.fireAndForget(createKoreanPayload());	Thread.yield();	Thread.sleep(100);	Object reply = null;	boolean replyNotFound = true;	int retryCount = 50;	while (replyNotFound) {	
checking for response with messageid 

replyNotFound = false;	} else {	if (retryCount-- > 0) {	Thread.sleep(100);	} else {	break;	}	}	}	if (reply != null && reply instanceof String) {	
result body 

private Object getMessage(String requestMsgId) {	Session session = Session.getInstance(props, null);	session.setDebug(log.isTraceEnabled());	Store store = null;	try {	store = session.getStore("test-store");	store.connect(username, password);	Folder folder = store.getFolder(MailConstants.DEFAULT_FOLDER);	folder.open(Folder.READ_WRITE);	Message[] msgs = folder.getMessages();	
replies in reply mailbox 

session.setDebug(log.isTraceEnabled());	Store store = null;	try {	store = session.getStore("test-store");	store.connect(username, password);	Folder folder = store.getFolder(MailConstants.DEFAULT_FOLDER);	folder.open(Folder.READ_WRITE);	Message[] msgs = folder.getMessages();	for (Message m:msgs) {	String[] inReplyTo = m.getHeader(MailConstants.MAIL_HEADER_IN_REPLY_TO);	
got reply to 

========================= synapse sample_4228 =========================

public static SynapseConfiguration getConfiguration(InputStream is) {	
generating the synapse configuration model by parsing the xml configuration 

========================= synapse sample_3017 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start pojocommand mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	if (synLog.isTraceOrDebugEnabled()) {	
creating a new instance of pojo class 

}	}	if (synLog.isTraceOrDebugEnabled()) {	}	Object commandObject = null;	try {	commandObject = getCommand().newInstance();	} catch (Exception e) {	handleException("Error creating an instance of the POJO command class : " + getCommand().getClass(), e, synCtx);	}	
instance created setting static and dynamic properties 

v = xpath.stringValueOf(synCtx);	} else {	throw new UnsupportedOperationException("non-String types not supportted yet");	}	try {	m.invoke(commandObject, v);	} catch (Exception e) {	e.printStackTrace();	}	}	
pojo initialized successfully invoking the execute method 

Method exeMethod = null;	try {	exeMethod = getCommand().getMethod("execute", new Class[]{});	exeMethod.invoke(commandObject, new Object[]{});	} catch (NoSuchMethodException e) {	handleException("Cannot locate an execute() method on POJO class : " + getCommand().getClass(), e, synCtx);	} catch (Exception e) {	handleException("Error invoking the execute() method on POJO class : " + getCommand().getClass(), e, synCtx);	}	}	
end pojocommand mediator 

========================= synapse sample_1929 =========================

public static void registerDataSources(Properties dsProperties) {	if (dsProperties == null) {	if (log.isDebugEnabled()) {	
datasource properties cannot be found 

public static void registerDataSources(Properties dsProperties) {	if (dsProperties == null) {	if (log.isDebugEnabled()) {	}	return;	}	String dataSources = getProperty(dsProperties, SynapseConstants.SYNAPSE_DATASOURCES, null);	if (dataSources == null || "".equals(dataSources)) {	if (log.isDebugEnabled()) {	
no datasources defined for initialization 

}	String dataSources = getProperty(dsProperties, SynapseConstants.SYNAPSE_DATASOURCES, null);	if (dataSources == null || "".equals(dataSources)) {	if (log.isDebugEnabled()) {	}	return;	}	String[] dataSourcesNames = dataSources.split(",");	if (dataSourcesNames == null || dataSourcesNames.length == 0) {	if (log.isDebugEnabled()) {	
no datasource definitions found for initialization 

if (hostname == null) {	String ipAddr = addr.getHostAddress();	if (ipAddr != null) {	providerHost = ipAddr;	}	} else {	providerHost = hostname;	}	}	} catch (UnknownHostException e) {	
unable to determine hostname or ip address using localhost 

}	int port = 2199;	String providerPort = getProperty(dsProperties, rootPrefix + PROP_PROVIDER_PORT, String.valueOf(port));	try {	port = Integer.parseInt(providerPort);	} catch (NumberFormatException ignored) {	}	RMIRegistryController.getInstance().createLocalRegistry(port);	String providerUrl = getProperty(dsProperties, rootPrefix + PROP_PROVIDER_URL, "rmi: props.put(Context.PROVIDER_URL, providerUrl);	jndiEvn.put(Context.PROVIDER_URL, providerUrl);	
datasources will be registered in the jndi context with provider prop url 

private static void registerDataSource(String dsName, Properties dsProperties, InitialContext initialContext, Properties jndiEnv) {	if (dsName == null || "".equals(dsName)) {	if (log.isDebugEnabled()) {	
datasource name is either empty or null ignoring 

private static String getProperty(Properties dsProperties, String name, String def) {	String result = dsProperties.getProperty(name);	if ((result == null || result.length() == 0 || "".equals(result)) && def != null) {	if (log.isDebugEnabled()) {	
the name with cannot be found using default vale 

========================= synapse sample_4044 =========================

public void resetStatistics() {	
operation not supported over jmx 

========================= synapse sample_3781 =========================

public CallService(SynapseEnvironment synapseEnvironment) {	this.environment = synapseEnvironment;	
call service constructor 

public SynapseMessage execute(long timeoutValue, SynapseMessage synapseMsg) {	synapseMessage = (Axis2SynapseMessage) synapseMsg;	
execute called 

newMsg = Axis2FlexibleMEPClient.send(synapseMessage.getMessageContext());	synapseMessage = new Axis2SynapseMessage(newMsg);	}	catch (AxisFault axisFault) {	thePivot();	axisFault.printStackTrace();	}	} else {	final CallThread thread  = new CallThread();	Timer timer = new Timer(false);	
timer defined 

TimerTask task = new TimerTask() {	public void run() {	if (thread.completed) {	thread.interrupt();	}	thread.interrupted = true;	}	};	timer.schedule(task, timeoutValue);	thread.start();	
thread started 

private void thePivot() {	
exception caught for failover 

========================= synapse sample_2893 =========================

public TimeoutHandler(Map callbacks, ServerContextInformation contextInfo) {	this.callbackStore = callbacks;	this.contextInfo = contextInfo;	this.globalTimeout = SynapseConfigUtils.getGlobalTimeoutInterval();	
this engine will expire all callbacks after seconds irrespective of the timeout action after the specified or optional timeout 

statisticsCleaner.clean();	}	SALSessions.getInstance().clearSessions();	synchronized(callbackStore) {	if (callbackStore.size() > 0) {	long currentTime = currentTime();	for (Object key : callbackStore.keySet()) {	AsyncCallback callback = (AsyncCallback) callbackStore.get(key);	if (callback == null) {	if (log.isDebugEnabled()) {	
there is no callback for key 

Stack faultStack = msgContext.getFaultStack();	for (int j = 0; j < faultStack.size(); j++) {	Object o = faultStack.pop();	if (o instanceof FaultHandler) {	((FaultHandler) o).handleFault(msgContext);	}	}	}	}	} else if (currentTime > globalTimeout + callback.getTimeOutOn()) {	
expiring message id dropping message after global timeout of seconds 

========================= synapse sample_1616 =========================

public KeyStore getKeyStore() {	File file = new File(pkPath);	if (!file.exists()) {	if (log.isDebugEnabled()) {	
there is no private key in the given path 

public KeyStore getKeyStore() {	File file = new File(pkPath);	if (!file.exists()) {	if (log.isDebugEnabled()) {	}	return null;	}	File certFile = new File(certPath);	if (!certFile.exists()) {	if (log.isDebugEnabled()) {	
there is no certificate in the given path 

return null;	}	File certFile = new File(certPath);	if (!certFile.exists()) {	if (log.isDebugEnabled()) {	}	return null;	}	try {	if (log.isDebugEnabled()) {	
reading a private key unencrypted from given path 

handleException("IOError reading from file :  " + pkPath, e);	} finally {	try {	bufferedInputStream.close();	fileInputStream.close();	outStream.close();	} catch (IOException ignored) {	}	}	if (log.isDebugEnabled()) {	
creating a private key in using given unencrypted rsa private key 

bufferedInputStream.close();	fileInputStream.close();	outStream.close();	} catch (IOException ignored) {	}	}	if (log.isDebugEnabled()) {	}	PrivateKey key = createPrivateKey(outStream.toByteArray());	if (log.isDebugEnabled()) {	
generating a certificate form given certificate file 

PrivateKey key = createPrivateKey(outStream.toByteArray());	if (log.isDebugEnabled()) {	}	FileInputStream certInputStream = new FileInputStream(certFile);	BufferedInputStream certBufferedInputStream = new BufferedInputStream(certInputStream);	CertificateFactory certFactory = CertificateFactory.getInstance("X509");	Certificate cert = certFactory.generateCertificate(certBufferedInputStream);	certBufferedInputStream.close();	certInputStream.close();	if (log.isDebugEnabled()) {	
creating a keystore instance of type jks from a private key and certificate 

========================= synapse sample_1092 =========================

public void init(ConfigurationContext configurationContext, AxisModule axisModule) throws AxisFault {	Object synEnvParameter = configurationContext.getAxisConfiguration().getParameterValue( SynapseConstants.SYNAPSE_ENV);	if (synEnvParameter != null && !(((SynapseEnvironment) synEnvParameter) .getServerContextInformation().getServerState() == ServerState.STARTED)) {	
initializing the synapse as a handler 

public void init(ConfigurationContext configurationContext, AxisModule axisModule) throws AxisFault {	Object synEnvParameter = configurationContext.getAxisConfiguration().getParameterValue( SynapseConstants.SYNAPSE_ENV);	if (synEnvParameter != null && !(((SynapseEnvironment) synEnvParameter) .getServerContextInformation().getServerState() == ServerState.STARTED)) {	ServerConfigurationInformation configurationInformation = ServerConfigurationInformationFactory.createServerConfigurationInformation( configurationContext.getAxisConfiguration());	ServerContextInformation contextInfo = new ServerContextInformation(configurationContext, configurationInformation);	ServerManager serverManager = new ServerManager();	serverManager.init(configurationInformation, contextInfo);	serverManager.start();	} else {	
detected an already started synapse instance using that for the mediation 

========================= synapse sample_5 =========================

public void testDbReport() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to dbreport mediator 

public void testDbReport() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	result = client.requestStandardQuote(addUrl, trpUrl, null, "IBM" ,null);	assertTrue("Client did not get run successfully ", result.responseReceived());	
running test introduction to the dblookup mediator 

========================= synapse sample_819 =========================

private void startServerEngine(int port) {	HttpParams params = getServerParameters();	try {	ioReactor = new DefaultListeningIOReactor(2, params);	} catch (IOException e) {	
error starting the ioreactor 

try {	ioReactor = new DefaultListeningIOReactor(2, params);	} catch (IOException e) {	}	NHttpServiceHandler handler = new ServerHandler(cfgCtx, params);	IOEventDispatch ioEventDispatch = getEventDispatch(handler, sslContext, params);	try {	ioReactor.listen(new InetSocketAddress(port));	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	
reactor interrupted 

ioReactor = new DefaultListeningIOReactor(2, params);	} catch (IOException e) {	}	NHttpServiceHandler handler = new ServerHandler(cfgCtx, params);	IOEventDispatch ioEventDispatch = getEventDispatch(handler, sslContext, params);	try {	ioReactor.listen(new InetSocketAddress(port));	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	} catch (IOException e) {	
encountered an i o error 

} catch (IOException e) {	}	NHttpServiceHandler handler = new ServerHandler(cfgCtx, params);	IOEventDispatch ioEventDispatch = getEventDispatch(handler, sslContext, params);	try {	ioReactor.listen(new InetSocketAddress(port));	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	} catch (IOException e) {	}	
listener shutdown 

if (param != null) {	port = Integer.parseInt((String) param.getValue());	}	param = transprtIn.getParameter(HOST_ADDRESS);	if (param != null) {	host = ((String) param.getValue()).trim();	} else {	try {	host = java.net.InetAddress.getLocalHost().getHostName();	} catch (UnknownHostException e) {	
unable to lookup local host name using localhost 

public void start() throws AxisFault {	
starting listener 

Thread t = new Thread(new Runnable() {	public void run() {	try {	startServerEngine(port);	} catch (Exception e) {	e.printStackTrace();	}	}	}, "HttpCoreNIOListener");	t.start();	
listener starting on port 

public void stop() throws AxisFault {	try {	ioReactor.shutdown();	
listener shut down 

========================= synapse sample_3410 =========================

public static DataSourceInformationRepository createDataSourceInformationRepository( DataSourceInformationRepositoryListener listener, Properties properties) {	if (log.isDebugEnabled()) {	
creating a new datasourceinformationrepository 

========================= synapse sample_2128 =========================

private synchronized void buildAppContext(MessageContext synCtx) {	
creating spring applicationcontext from property key 

========================= synapse sample_3369 =========================

public void handleFault(MessageContext synCtx) {	boolean traceOn = synCtx.getTracingState() == SynapseConstants.TRACING_ON;	boolean traceOrDebugOn = traceOn || log.isDebugEnabled();	if (traceOrDebugOn) {	traceOrDebugWarn(traceOn, "FaultHandler executing impl: " + this.getClass().getName());	}	try {	
faulthandler executing impl 

boolean traceOrDebugOn = traceOn || log.isDebugEnabled();	synCtx.setProperty(SynapseConstants.ERROR_CODE, "00000");	synCtx.setProperty(SynapseConstants.ERROR_MESSAGE, e.getMessage().split("\n")[0]);	synCtx.setProperty(SynapseConstants.ERROR_DETAIL, getStackTrace(e));	synCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, e);	if (traceOrDebugOn) {	traceOrDebugWarn(traceOn, "Fault handler - setting ERROR_MESSAGE : " + synCtx.getProperty(SynapseConstants.ERROR_MESSAGE));	traceOrDebugWarn(traceOn, "Fault handler - setting ERROR_DETAIL : " + synCtx.getProperty(SynapseConstants.ERROR_DETAIL));	traceOrDebugWarn(traceOn, "Fault handler - setting ERROR_EXCEPTION : " + synCtx.getProperty(SynapseConstants.ERROR_EXCEPTION));	}	
fault handler setting error message 

========================= synapse sample_3693 =========================

boolean active = endpointContext.isActive();	if (!active) {	long recoverOn = endpointContext.getRecoverOn();	if (System.currentTimeMillis() > recoverOn) {	active = true;	endpointContext.setActive(true);	endpointContext.setRecoverOn(0);	}	}	if (log.isDebugEnabled()) {	
endpoint is in state 

boolean isClusteringEnable = false;	org.apache.axis2.context.MessageContext axisMC = ((Axis2MessageContext) synCtx).getAxis2MessageContext();	ConfigurationContext cc = axisMC.getConfigurationContext();	ClusterManager clusterManager = cc.getAxisConfiguration().getClusterManager();	if (clusterManager != null && clusterManager.getContextManager() != null) {	isClusteringEnable = true;	}	String endPointName = this.getName();	if (endPointName == null) {	if (traceOrDebugOn && isClusteringEnable) {	
in a clustering environment the endpoint name should be specified even for anonymous endpoints otherwise the clustering would not be functioned correctly if there are more than one anonymous endpoints 

========================= synapse sample_4013 =========================

ObjectName name = new ObjectName(getObjectName(category, id));	Set set = mbs.queryNames(name, null);	if (set != null && set.isEmpty()) {	mbs.registerMBean(mBeanInstance, name);	} else {	mbs.unregisterMBean(name);	mbs.registerMBean(mBeanInstance, name);	}	return true;	} catch (Exception e) {	
error registering a mbean with name and category name for jmx management 

public boolean unRegisterMBean(String category, String id) {	try {	MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();	ObjectName objName = new ObjectName(getObjectName(category, id));	if (mbs.isRegistered(objName)) {	mbs.unregisterMBean(objName);	return true;	}	} catch (Exception e) {	
error un registering a mbean with name and category name for jmx management 

========================= synapse sample_726 =========================

public void testSmartClientMode() {	String addUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test smart client mode 

========================= synapse sample_862 =========================

public boolean startProcess() {	try {	broker = new BrokerService();	broker.setBrokerName("synapseSampleBroker");	broker.addConnector(providerURL);	broker.start();	
jmsservercontroller broker is successfully started continuing tests 

public boolean startProcess() {	try {	broker = new BrokerService();	broker.setBrokerName("synapseSampleBroker");	broker.addConnector(providerURL);	broker.start();	return true;	} catch (Exception e) {	
there was an error starting jms broker 

public boolean stopProcess() {	try {	broker.stop();	FileUtils.deleteQuietly(broker.getDataDirectoryFile());	return true;	} catch (Exception e) {	
error while shutting down the broker 

========================= synapse sample_2295 =========================

public MessageContext send(EndpointDefinition endpoint, MessageContext messageIn) throws Exception {	String serviceUrl = endpoint.getAddress();	if(log.isDebugEnabled()) {	
start sending the message 

options.setProperty(Constants.Configuration.DISABLE_SOAP_ACTION, true);	} else {	Axis2MessageContext axis2smc = (Axis2MessageContext) messageOut;	org.apache.axis2.context.MessageContext axis2MessageCtx = axis2smc.getAxis2MessageContext();	axis2MessageCtx.getTransportOut().addParameter( new Parameter(HTTPConstants.OMIT_SOAP_12_ACTION, true));	}	}	org.apache.axis2.context.MessageContext axis2Ctx = ((Axis2MessageContext) messageOut).getAxis2MessageContext();	boolean outOnlyMessage = "true".equals(messageIn.getProperty( SynapseConstants.OUT_ONLY)) || WSDL2Constants.MEP_URI_IN_ONLY.equals( axis2Ctx.getOperationContext() .getAxisOperation().getMessageExchangePattern());	if (log.isDebugEnabled()) {	
invoking service url with message 

if(outOnlyMessage) {	sc.sendRobust(payload);	} else {	result = sc.sendReceive(payload);	}	} catch (Exception axisFault) {	if (!outOnlyMessage) {	messageOut.setProperty(ForwardingProcessorConstants.BLOCKING_SENDER_ERROR, "true");	return messageOut;	}	
error sending message to url 

}	if(!outOnlyMessage) {	if(result != null) {	String soapNamespaceURI = axis2Ctx.getEnvelope().getNamespace().getNamespaceURI();	SOAPEnvelope envelope = createSOAPEnvelope(result , soapNamespaceURI);	axis2Ctx.setEnvelope(envelope);	return messageOut;	}	}	} catch (AxisFault axisFault) {	
error sending message to url 

========================= synapse sample_2016 =========================

public boolean mediate(MessageContext synCtx) {	
send mediator mediate 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	try {	if (shouldTrace) {	trace.trace("Start : Send mediator");	trace.trace("Sending Message :: " + synCtx.getEnvelope());	}	if (endpoints.isEmpty()) {	if (log.isDebugEnabled()) {	
sending message using implicit message properties 

boolean shouldTrace = shouldTrace(synCtx.getTracingState());	try {	if (shouldTrace) {	trace.trace("Start : Send mediator");	trace.trace("Sending Message :: " + synCtx.getEnvelope());	}	if (endpoints.isEmpty()) {	if (log.isDebugEnabled()) {	log.debug("Sending To: " + (synCtx.getTo() != null ? synCtx.getTo().getAddress() : "null"));	log.debug("SOAPAction: " + (synCtx.getWSAAction() != null ? synCtx.getWSAAction() : "null"));	
body 

EndPointStatisticsStack endPointStatisticsStack = new EndPointStatisticsStack();	boolean isFault =synCtx.getEnvelope().getBody().hasFault();	endPointStatisticsStack.put(endPointName, System.currentTimeMillis(), !synCtx.isResponse(), statisticsEnable,isFault);	synCtx.setCorrelationProperty(org.apache.synapse.Constants.ENDPOINT_STATISTICS_STACK, endPointStatisticsStack);	}	synCtx.setTo(new EndpointReference(eprAddress));	if (log.isDebugEnabled()) {	log.debug("Sending message to endpoint :: name = " + endPointName + " resolved address = " + eprAddress);	log.debug("Sending To: " + (synCtx.getTo() != null ? synCtx.getTo().getAddress() : "null"));	log.debug("SOAPAction: " + (synCtx.getWSAAction() != null ? synCtx.getWSAAction() : "null"));	
body 

========================= synapse sample_3312 =========================

public void process(SOAPMessageContext smc) {	
processing message 

========================= synapse sample_1401 =========================

public String getMessageTextPayload(Object message) {	try {	return new String( getBytesFromInputStream(getInputStream(message), ((Message) message).getSize()));	} catch (Exception e) {	if (log.isDebugEnabled()) {	
error reading message payload as text for 

========================= synapse sample_4253 =========================

public static ServerConfigurationInformation createServerConfigurationInformation( String[] args) {	ServerConfigurationInformation information = new ServerConfigurationInformation();	information.setAxis2RepoLocation(args[0]);	if (args.length == 1) {	
configuring server manager using deprecated system properties please update your configuration 

public static ServerConfigurationInformation createServerConfigurationInformation( ServletConfig servletConfig) {	ServerConfigurationInformation information = new ServerConfigurationInformation();	String synapseHome = loadParameter(servletConfig, SynapseConstants.SYNAPSE_HOME, false);	if (synapseHome == null) {	
synapse home not set using web application root as default value 

public static ServerConfigurationInformation createServerConfigurationInformation( ServletConfig servletConfig) {	ServerConfigurationInformation information = new ServerConfigurationInformation();	String synapseHome = loadParameter(servletConfig, SynapseConstants.SYNAPSE_HOME, false);	if (synapseHome == null) {	String webInfPath = servletConfig.getServletContext().getRealPath("WEB-INF");	if (webInfPath == null || !webInfPath.endsWith("WEB-INF")) {	handleFatal("Unable to currentState web application root directory");	} else {	synapseHome = webInfPath.substring(0, webInfPath.length() - 7);	
setting synapse home to 

private static String getArgument(CommandLine cmd, String argName) {	if (cmd == null) {	handleFatal("CommandLine is null");	} else {	if (argName == null || "".equals(argName)) {	if (log.isDebugEnabled()) {	
provided argument name is null returning null as value 

private static String loadParameter(ServletConfig servletConfig, String name, boolean required) {	if (System.getProperty(name) == null) {	String value = servletConfig.getInitParameter(name);	if (log.isDebugEnabled()) {	
init parameter 

========================= synapse sample_566 =========================

CertPath certPath = fact.generateCertPath(certChain);	TrustAnchor trustAnchor = new TrustAnchor(fullCertChain.get(fullCertChain.size() - 1), null);	Set<TrustAnchor> trust = Collections.singleton(trustAnchor);	CertPathValidator validator = CertPathValidator.getInstance("PKIX", "BC");	PKIXParameters param = new PKIXParameters(trust);	param.addCertPathChecker(pathChecker);	param.setRevocationEnabled(false);	param.addCertStore(store);	param.setDate(new Date());	validator.validate(certPath, param);	
certificate path validated 

========================= synapse sample_2387 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start enrich mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

try {	sourceNodeList = source.evaluate(synCtx, synLog);	if (sourceNodeList == null) {	handleException("Failed to get the source for Enriching : ", synCtx);	} else {	target.insert(synCtx, sourceNodeList, synLog);	}	} catch (JaxenException e) {	handleException("Failed to get the source for Enriching", e, synCtx);	}	
end enrich mediator 

========================= synapse sample_1952 =========================

public RegistryEntry getRegistryEntry(String key) {	
perform registryentry lookup for key 

========================= synapse sample_3083 =========================

public void onMessage(Message message) {	try {	if (log.isDebugEnabled()) {	StringBuffer sb = new StringBuffer();	sb.append("Received JMS message to destination : " + message.getJMSDestination());	sb.append("\nMessage ID : " + message.getJMSMessageID());	sb.append("\nCorrelation ID : " + message.getJMSCorrelationID());	sb.append("\nReplyTo ID : " + message.getJMSReplyTo());	log.debug(sb.toString());	if (log.isTraceEnabled() && message instanceof TextMessage) {	
message 

sb.append("Received JMS message to destination : " + message.getJMSDestination());	sb.append("\nMessage ID : " + message.getJMSMessageID());	sb.append("\nCorrelation ID : " + message.getJMSCorrelationID());	sb.append("\nReplyTo ID : " + message.getJMSReplyTo());	log.debug(sb.toString());	if (log.isTraceEnabled() && message instanceof TextMessage) {	}	}	} catch (JMSException e) {	if (log.isDebugEnabled()) {	
error reading jms message headers for debug logging 

}	try {	if (message instanceof BytesMessage) {	metrics.incrementBytesReceived((JMSUtils.getBodyLength((BytesMessage) message)));	} else if (message instanceof TextMessage) {	metrics.incrementBytesReceived(((TextMessage) message).getText().getBytes().length);	} else {	handleException("Unsupported JMS message type : " + message.getClass().getName());	}	} catch (JMSException e) {	
error reading jms message size to update transport metrics 

metrics.incrementBytesReceived(((TextMessage) message).getText().getBytes().length);	} else {	handleException("Unsupported JMS message type : " + message.getClass().getName());	}	} catch (JMSException e) {	}	try {	long expiryTime = message.getJMSExpiration();	if (expiryTime > 0 && System.currentTimeMillis() > expiryTime) {	if (log.isDebugEnabled()) {	
discard expired message with id 

========================= synapse sample_4316 =========================

public Integer getIntProperty(String name, Integer def) {	String val = System.getProperty(name);	if (val == null) {	val = props.getProperty(name);	}	if (val != null) {	int intVal;	try {	intVal = Integer.valueOf(val);	} catch (NumberFormatException e) {	
invalid http tuning property value must be an integer 

========================= synapse sample_970 =========================

public void connected(final NHttpServerConnection conn) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection connected 

public void closed(final NHttpServerConnection conn) {	if (this.log.isDebugEnabled()) {	
http connection closed 

public void endOfInput(NHttpServerConnection conn) throws IOException {	if (this.log.isDebugEnabled()) {	
http connection closed at the remote end 

public void requestReceived(final NHttpServerConnection conn) throws IOException, HttpException {	HttpRequest request = conn.getHttpRequest();	if (this.log.isDebugEnabled()) {	
http inrequest received on connection 

public void outputReady(final NHttpServerConnection conn, final ContentEncoder encoder) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection output ready 

public void outputReady(final NHttpServerConnection conn, final ContentEncoder encoder) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	}	this.handler.outputReady(conn, encoder);	if (this.log.isDebugEnabled()) {	
http connection content encoder 

public void responseReady(final NHttpServerConnection conn) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection response ready 

public void inputReady(final NHttpServerConnection conn, final ContentDecoder decoder) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection input ready 

public void inputReady(final NHttpServerConnection conn, final ContentDecoder decoder) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	}	this.handler.inputReady(conn, decoder);	if (this.log.isDebugEnabled()) {	
http connection content decoder 

public void timeout(final NHttpServerConnection conn) throws IOException {	if (this.log.isDebugEnabled()) {	
http connection timeout 

========================= synapse sample_2411 =========================

msg.setHeader(MailConstants.MAIL_HEADER_MESSAGE_ID, msgId);	msg.setHeader(MailConstants.MAIL_HEADER_X_MESSAGE_ID, msgId);	msg.setText(POX_MESSAGE);	Transport.send(msg);	Thread.yield();	Thread.sleep(1000 * 10);	Object reply = null;	boolean replyNotFound = true;	int retryCount = 3;	while (replyNotFound) {	
checking for response with messageid 

replyNotFound = false;	} else {	if (retryCount-- > 0) {	Thread.sleep(10000);	} else {	break;	}	}	}	if (reply != null && reply instanceof String) {	
result body 

options.setProperty(MailConstants.TRANSPORT_MAIL_FORMAT, MailConstants.TRANSPORT_FORMAT_MP);	ServiceClient sender = new ServiceClient(getClientCfgCtx(), null);	sender.setOptions(options);	sender.fireAndForget(createPayload());	Thread.yield();	Thread.sleep(1000 * 10);	Object reply = null;	boolean replyNotFound = true;	int retryCount = 3;	while (replyNotFound) {	
checking for response with messageid 

replyNotFound = false;	} else {	if (retryCount-- > 0) {	Thread.sleep(10000);	} else {	break;	}	}	}	if (reply != null && reply instanceof String) {	
result body 

options.setProperty(MailConstants.TRANSPORT_MAIL_FORMAT, MailConstants.TRANSPORT_FORMAT_MP);	ServiceClient sender = new ServiceClient(getClientCfgCtx(), null);	sender.setOptions(options);	sender.fireAndForget(createKoreanPayload());	Thread.yield();	Thread.sleep(1000 * 10);	Object reply = null;	boolean replyNotFound = true;	int retryCount = 3;	while (replyNotFound) {	
checking for response with messageid 

replyNotFound = false;	} else {	if (retryCount-- > 0) {	Thread.sleep(10000);	} else {	break;	}	}	}	if (reply != null && reply instanceof String) {	
result body 

options.setMessageId(msgId);	ServiceClient sender = new ServiceClient(getClientCfgCtx(), null);	sender.setOptions(options);	sender.fireAndForget(createPayload());	Thread.yield();	Thread.sleep(1000 * 10);	Object reply = null;	boolean replyNotFound = true;	int retryCount = 3;	while (replyNotFound) {	
checking for response with messageid 

replyNotFound = false;	} else {	if (retryCount-- > 0) {	Thread.sleep(10000);	} else {	break;	}	}	}	if (reply != null && reply instanceof String) {	
result body 

options.setMessageId(msgId);	ServiceClient sender = new ServiceClient(getClientCfgCtx(), null);	sender.setOptions(options);	sender.fireAndForget(createKoreanPayload());	Thread.yield();	Thread.sleep(1000 * 10);	Object reply = null;	boolean replyNotFound = true;	int retryCount = 3;	while (replyNotFound) {	
checking for response with messageid 

replyNotFound = false;	} else {	if (retryCount-- > 0) {	Thread.sleep(10000);	} else {	break;	}	}	}	if (reply != null && reply instanceof String) {	
result body 

options.setProperty(Constants.Configuration. CHARACTER_SET_ENCODING, KOREAN_CHARSET);	ServiceClient sender = new ServiceClient(getClientCfgCtx(), null);	sender.setOptions(options);	sender.fireAndForget(createKoreanPayload());	Thread.yield();	Thread.sleep(1000 * 10);	Object reply = null;	boolean replyNotFound = true;	int retryCount = 3;	while (replyNotFound) {	
checking for response with messageid 

replyNotFound = false;	} else {	if (retryCount-- > 0) {	Thread.sleep(10000);	} else {	break;	}	}	}	if (reply != null && reply instanceof String) {	
result body 

private Object getMessage(String requestMsgId) {	Session session = Session.getInstance(props, null);	session.setDebug(log.isTraceEnabled());	Store store = null;	try {	store = session.getStore("pop3");	store.connect(username, password);	Folder folder = store.getFolder(MailConstants.DEFAULT_FOLDER);	folder.open(Folder.READ_WRITE);	Message[] msgs = folder.getMessages();	
replies in reply mailbox 

session.setDebug(log.isTraceEnabled());	Store store = null;	try {	store = session.getStore("pop3");	store.connect(username, password);	Folder folder = store.getFolder(MailConstants.DEFAULT_FOLDER);	folder.open(Folder.READ_WRITE);	Message[] msgs = folder.getMessages();	for (Message m:msgs) {	String[] inReplyTo = m.getHeader(MailConstants.MAIL_HEADER_IN_REPLY_TO);	
got reply to 

========================= synapse sample_3715 =========================

public synchronized void start() throws AMQPTransportException {	try {	if (exchangeName != null) {	channel.exchangeDeclare( exchangeName, exchangeType, isExchangeDurable, isExchangeAutoDelete, isInternalExchange, null);	String newQueueName = channel.queueDeclare().getQueue();	
queuename is set to for service 

QueueingConsumer consumer = new QueueingConsumer(channel);	boolean isAutoAck = isUseTx == true ? false : true;	channel.basicConsume(queueName, isAutoAck, consumer);	ScheduledFuture<?> pollingTaskFuture = pollingTaskScheduler.scheduleWithFixedDelay( new MessageIOTask(consumer, buffers, isUseTx), scheduledTaskInitialDelay, scheduledTaskDelay, scheduledTaskTimeUnit);	taskFutureList.add(pollingTaskFuture);	} catch (IOException e) {	handleException(e.getMessage(), e);	}	}	if (log.isDebugEnabled()) {	
a polling task started listening on the queue on behalf of the service 

if (isUseTx) {	channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);	channel.txCommit();	}	} else {	if (isUseTx) {	channel.txRollback();	}	}	} catch (InterruptedException e) {	
polling task was interrupted for service 

channel.txCommit();	}	} else {	if (isUseTx) {	channel.txRollback();	}	}	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	} catch (IOException e) {	
i o error occurs for the polling tasks for service 

} else {	if (isUseTx) {	channel.txRollback();	}	}	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	} catch (IOException e) {	} catch (ShutdownSignalException e) {	if (e.isHardError()) {	
polling task for service received a shutdown signal 

Thread.currentThread().interrupt();	} catch (IOException e) {	} catch (ShutdownSignalException e) {	if (e.isHardError()) {	Semaphore available = new Semaphore(0, true);	String key = UUID.randomUUID().toString();	haHandler.getBlockedTasks().add(new AMQPTransportHAEntry( available, key, connectionFactoryName));	try {	available.acquire();	} catch (InterruptedException ie) {	
the blocking semaphore was interrupted 

String key = UUID.randomUUID().toString();	haHandler.getBlockedTasks().add(new AMQPTransportHAEntry( available, key, connectionFactoryName));	try {	available.acquire();	} catch (InterruptedException ie) {	Thread.currentThread().interrupt();	return;	}	AMQPTransportHABrokerEntry brokerEntry = haHandler.getConnectionMap().get(key);	if (brokerEntry == null) {	
no new connection factory was found for key 

Thread.currentThread().interrupt();	return;	}	AMQPTransportHABrokerEntry brokerEntry = haHandler.getConnectionMap().get(key);	if (brokerEntry == null) {	} else {	setChannel(brokerEntry.getChannel());	stop();	try {	start();	
worker task for service is re deployed 

return;	}	AMQPTransportHABrokerEntry brokerEntry = haHandler.getConnectionMap().get(key);	if (brokerEntry == null) {	} else {	setChannel(brokerEntry.getChannel());	stop();	try {	start();	} catch (AMQPTransportException ex) {	
start of polling tasks failed system must be restarted 

setChannel(brokerEntry.getChannel());	stop();	try {	start();	} catch (AMQPTransportException ex) {	}	}	} else {	}	} catch (ConsumerCancelledException e) {	
polling task for service received a cancellation signal 

public void run() {	try {	handleIncomingMessage(message, buffers);	} catch (AxisFault axisFault) {	try {	handleFaultMessage(message, buffers, axisFault);	} catch (Exception e) {	
error while sending the fault message to the client client will not receive any errors 

========================= synapse sample_1047 =========================

public void testScriptMediationWithJS() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to the script mediator using js scripts 

========================= synapse sample_823 =========================

public void close() throws IOException {	
close connection 

public void shutdown() throws IOException {	
shutdown connection 

public void submitRequest(final HttpRequest request) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection 

public void consumeInput(final NHttpClientHandler handler) {	
consume input 

public void produceOutput(final NHttpClientHandler handler) {	
produce output 

========================= synapse sample_4300 =========================

public static SynapseConfiguration getConfiguration(String configFile) {	try {	SynapseConfiguration synCfg = XMLConfigurationBuilder.getConfiguration(new FileInputStream(configFile));	
loaded synapse configuration from 

private static void loadSynapseProperties(SynapseConfiguration synCfg) {	String props = System.getProperty(SynapseConstants.SYNAPSE_PROPERTIES);	if (props == null) {	props = SynapseConstants.DEFAULT_PROP_PATH;	}	try {	synCfg.getProperties().load(Thread.currentThread().getContextClassLoader().getResourceAsStream(props));	} catch (Exception e) {	if (log.isDebugEnabled()) {	
unable to load synapse properties using the default tunning parameters for synapse 

========================= synapse sample_3646 =========================

public void destroy() {	if (this.dataSource instanceof BasicDataSource) {	try {	((BasicDataSource) this.dataSource).close();	
successfully shut down db connection pool for url 

public void destroy() {	if (this.dataSource instanceof BasicDataSource) {	try {	((BasicDataSource) this.dataSource).close();	} catch (SQLException e) {	
error shutting down db connection pool for url 

public void destroy() {	if (this.dataSource instanceof BasicDataSource) {	try {	((BasicDataSource) this.dataSource).close();	} catch (SQLException e) {	}	} else if (this.dataSource instanceof PerUserPoolDataSource) {	((PerUserPoolDataSource) this.dataSource).close();	
successfully shut down db connection pool for url 

========================= synapse sample_4183 =========================

public void close() throws IOException {	
close connection 

public void shutdown() throws IOException {	
shutdown connection 

public void submitResponse(final HttpResponse response) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection 

public void consumeInput(final NHttpServerEventHandler handler) {	
consume input 

public void produceOutput(final NHttpServerEventHandler handler) {	
produce output 

========================= synapse sample_2407 =========================

public static TaskDescriptionRepository getTaskDescriptionRepository(String id) {	if (id == null || "".equals(id)) {	throw new SynapseTaskException("Name cannot be found.", log);	}	TaskDescriptionRepository repository = repositoryMap.get(id);	if (repository == null) {	if (log.isDebugEnabled()) {	
creating a taskdescriptionrepository with id 

========================= synapse sample_29 =========================

public void init(SynapseConfiguration synCfg, ServerContextInformation contextInformation) {	if (initialized) {	
attempted to re initialize synapsecallbackreceiver 

public void init(SynapseConfiguration synCfg, ServerContextInformation contextInformation) {	if (initialized) {	return;	}	if (log.isDebugEnabled()) {	
initializing synapsecallbackreceiver 

public void destroy() {	if (!initialized) {	
attempted to destroy uninitialized synapsecallbackreceiver 

public void destroy() {	if (!initialized) {	return;	}	if (log.isDebugEnabled()) {	
destroying synapsecallbackreceiver 

public void addCallback(String MsgID, AxisCallback callback) {	callbackStore.put(MsgID, callback);	if (log.isDebugEnabled()) {	
callback added total callbacks waiting for 

public void receive(MessageContext messageCtx) throws AxisFault {	String messageID = null;	if (messageCtx.getProperty(NhttpConstants.HTTP_202_RECEIVED) != null && "true".equals( messageCtx.getProperty(NhttpConstants.HTTP_202_RECEIVED))) {	if (callbackStore.containsKey(messageCtx.getMessageID())) {	callbackStore.remove(messageCtx.getMessageID());	if (log.isDebugEnabled()) {	
callback registered with message id removed from the callback store since we got an accepted notification 

if (relatesTo != null) {	messageID = relatesTo.getValue();	}	}	} else {	messageID = (String) messageCtx.getProperty(SynapseConstants.RELATES_TO_FOR_POX);	}	if (messageID != null) {	AxisCallback callback = callbackStore.remove(messageID);	if (log.isDebugEnabled()) {	
callback removed for request message id pending callbacks count 

AxisCallback callback = callbackStore.remove(messageID);	if (log.isDebugEnabled()) {	}	RelatesTo[] relates = messageCtx.getRelationships();	if (relates != null && relates.length > 1) {	removeDuplicateRelatesTo(messageCtx, relates);	}	if (callback != null) {	handleMessage(messageID, messageCtx, ((AsyncCallback) callback).getSynapseOutMsgCtx(), (AsyncCallback)callback);	} else {	
synapse received a response for the request with message id but a callback is not registered anymore to process this response 

}	RelatesTo[] relates = messageCtx.getRelationships();	if (relates != null && relates.length > 1) {	removeDuplicateRelatesTo(messageCtx, relates);	}	if (callback != null) {	handleMessage(messageID, messageCtx, ((AsyncCallback) callback).getSynapseOutMsgCtx(), (AsyncCallback)callback);	} else {	}	} else if (!messageCtx.isPropertyTrue(NhttpConstants.SC_ACCEPTED)){	
synapse received a response message without a message id 

} catch (OMException x) {	synapseOutMsgCtx.setEnvelope(response.getEnvelope());	}	Exception e = (Exception) response.getProperty(SynapseConstants.ERROR_EXCEPTION);	synapseOutMsgCtx.setProperty(SynapseConstants.SENDING_FAULT, Boolean.TRUE);	synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_CODE, response.getProperty(SynapseConstants.ERROR_CODE));	synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_MESSAGE, response.getProperty(SynapseConstants.ERROR_MESSAGE));	synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_DETAIL, response.getProperty(SynapseConstants.ERROR_DETAIL));	synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, e);	if (log.isDebugEnabled()) {	
failed request message id new to be retried request message id 

Exception e = (Exception) response.getProperty(SynapseConstants.ERROR_EXCEPTION);	synapseOutMsgCtx.setProperty(SynapseConstants.SENDING_FAULT, Boolean.TRUE);	synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_CODE, response.getProperty(SynapseConstants.ERROR_CODE));	synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_MESSAGE, response.getProperty(SynapseConstants.ERROR_MESSAGE));	synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_DETAIL, response.getProperty(SynapseConstants.ERROR_DETAIL));	synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, e);	if (log.isDebugEnabled()) {	}	int errorCode = (Integer)response.getProperty(SynapseConstants.ERROR_CODE);	if (errorCode == SynapseConstants.NHTTP_CONNECTION_TIMEOUT && callback.getTimeOutAction() == SynapseConstants.DISCARD) {	
synapse timed out for the request with message id ignoring fault handlers since the timeout action is discard 

((FaultHandler) faultStack.pop()).handleFault(synapseOutMsgCtx, null);	}	}	} else {	Stack faultStack = synapseOutMsgCtx.getFaultStack();	if (faultStack != null && !faultStack.isEmpty() && faultStack.peek() instanceof Endpoint) {	Endpoint successfulEndpoint = (Endpoint) faultStack.pop();	successfulEndpoint.onSuccess();	}	if (log.isDebugEnabled()) {	
synapse received an asynchronous response message 

Endpoint successfulEndpoint = (Endpoint) faultStack.pop();	successfulEndpoint.onSuccess();	}	if (log.isDebugEnabled()) {	log.debug("Received To: " + (response.getTo() != null ? response.getTo().getAddress() : "null"));	log.debug("SOAPAction: " + (response.getSoapAction() != null ? response.getSoapAction() : "null"));	log.debug("WSA-Action: " + (response.getWSAAction() != null ? response.getWSAAction() : "null"));	String[] cids = response.getAttachmentMap().getAllContentIDs();	if (cids != null && cids.length > 0) {	for (String cid : cids) {	
attachment 

}	if (log.isDebugEnabled()) {	log.debug("Received To: " + (response.getTo() != null ? response.getTo().getAddress() : "null"));	log.debug("SOAPAction: " + (response.getSoapAction() != null ? response.getSoapAction() : "null"));	log.debug("WSA-Action: " + (response.getWSAAction() != null ? response.getWSAAction() : "null"));	String[] cids = response.getAttachmentMap().getAllContentIDs();	if (cids != null && cids.length > 0) {	for (String cid : cids) {	}	}	
body 

dispatcher.updateSession(synapseInMessageContext);	}	StatisticsReporter.reportForAllOnResponseReceived(synapseInMessageContext);	try {	synapseOutMsgCtx.getEnvironment().injectMessage(synapseInMessageContext);	} catch (SynapseException syne) {	Stack stack = synapseInMessageContext.getFaultStack();	if (stack != null && !stack.isEmpty()) {	((FaultHandler) stack.pop()).handleFault(synapseInMessageContext, syne);	} else {	
synapse encountered an exception no error handlers found message dropped 

========================= synapse sample_209 =========================

public void setMessage(OMElement elem) {	
set message 

public void execute() {	
execute 

public void execute() {	if (synapseEnvironment == null) {	
synapse environment not set 

public void execute() {	if (synapseEnvironment == null) {	return;	}	if (message == null) {	
message not set 

public void execute() {	if (synapseEnvironment == null) {	return;	}	if (message == null) {	return;	}	if (to == null) {	
to address not set 

========================= synapse sample_3703 =========================

try {	xp = new AXIOMXPath(omPath.getText());	OMElementUtils.addNameSpaces(xp, elem, log);	if(omNS != null){	String prefix = omNS.getAttributeValue(new QName(Constants.NULL_NAMESPACE, "prefix"));	String name = omNS.getAttributeValue(new QName(Constants.NULL_NAMESPACE, "name"));	xp.addNamespace(prefix,name);	}	mediator.setAttachmentPath(xp);	} catch (JaxenException e) {	
error creating xpath for element 

========================= synapse sample_3353 =========================

public void produce(MessageContext messageContext) {	String action = queueProducerPolicy.getAction();	if (SEDAQueueProducerPolicy.ADD.equals(action)) {	queue.add(messageContext);	} else if (SEDAQueueProducerPolicy.OFFER.equals(action)) {	long timeout = queueProducerPolicy.getTimeoutOnInsert();	if (timeout < 0) {	if (!queue.offer(messageContext)) {	
error while offering the message to the queue 

queue.add(messageContext);	} else if (SEDAQueueProducerPolicy.OFFER.equals(action)) {	long timeout = queueProducerPolicy.getTimeoutOnInsert();	if (timeout < 0) {	if (!queue.offer(messageContext)) {	}	} else {	try {	queue.offer(messageContext, timeout, TimeUnit.MILLISECONDS);	} catch (InterruptedException e) {	
ignored interruptedexception when ocuured calling queue offer 

} else {	try {	queue.offer(messageContext, timeout, TimeUnit.MILLISECONDS);	} catch (InterruptedException e) {	}	}	} else if (SEDAQueueProducerPolicy.PUT.equals(action)) {	try {	queue.put(messageContext);	} catch (InterruptedException e) {	
ignored interruptedexception when ocuured calling queue put 

========================= synapse sample_1440 =========================

public void testGetQuote() throws Exception {	BasicHttpClient client = new BasicHttpClient();	HttpResponse response = client.doGet("http: assertEquals(response.getStatus(), HttpStatus.SC_INTERNAL_SERVER_ERROR);	OMElement body = response.getBodyAsXML();	assertEquals(body.getLocalName(), "Exception");	
an exception was thrown as expected 

========================= synapse sample_874 =========================

return entry.getValue();	} else if (!entry.isCached()) {	omNode = lookup(entry.getKey());	if (omNode == null) {	return null;	} else {	re = getRegistryEntry(entry.getKey());	}	} else if (entry.isExpired()) {	if (log.isDebugEnabled()) {	
cached object has expired for key 

return null;	} else {	re = getRegistryEntry(entry.getKey());	}	} else if (entry.isExpired()) {	if (log.isDebugEnabled()) {	}	re = getRegistryEntry(entry.getKey());	if (re.getVersion() != Long.MIN_VALUE && re.getVersion() == entry.getVersion()) {	if (log.isDebugEnabled()) {	
expired version number is same as current version in registry 

re = getRegistryEntry(entry.getKey());	if (re.getVersion() != Long.MIN_VALUE && re.getVersion() == entry.getVersion()) {	if (log.isDebugEnabled()) {	}	if (re.getCachableDuration() > 0) {	entry.setExpiryTime( System.currentTimeMillis() + re.getCachableDuration());	} else {	entry.setExpiryTime(-1);	}	if (log.isDebugEnabled()) {	
renew cache lease for another s 

========================= synapse sample_4212 =========================

public void destroy() {	if (dataSourceName != null) {	return;	}	if (this.dataSource instanceof BasicDataSource) {	try {	((BasicDataSource) this.dataSource).close();	
successfully shut down db connection pool for url 

public void destroy() {	if (dataSourceName != null) {	return;	}	if (this.dataSource instanceof BasicDataSource) {	try {	((BasicDataSource) this.dataSource).close();	} catch (SQLException e) {	
error shutting down db connection pool for url 

if (dataSourceName != null) {	return;	}	if (this.dataSource instanceof BasicDataSource) {	try {	((BasicDataSource) this.dataSource).close();	} catch (SQLException e) {	}	} else if (this.dataSource instanceof PerUserPoolDataSource) {	((PerUserPoolDataSource) this.dataSource).close();	
successfully shut down db connection pool for url 

public boolean mediate(MessageContext synCtx) {	String name = (this instanceof DBLookupMediator ? "DBLookup" : "DBReport");	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start mediator 

public boolean mediate(MessageContext synCtx) {	String name = (this instanceof DBLookupMediator ? "DBLookup" : "DBReport");	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	for (Statement aStatement : statementList) {	if (aStatement != null) {	processStatement(aStatement, synCtx);	}	}	if (synLog.isTraceOrDebugEnabled()) {	
end mediator 

protected PreparedStatement getPreparedStatement(Statement stmnt, Connection con, MessageContext msgCtx) throws SQLException {	SynapseLog synLog = getLog(msgCtx);	if (synLog.isTraceOrDebugEnabled()) {	
getting a connection from datasource and preparing statement 

int numActive = basicDataSource.getNumActive();	int numIdle = basicDataSource.getNumIdle();	String connectionId = Integer.toHexString(con.hashCode());	DBPoolView dbPoolView = getDbPoolView();	if (dbPoolView != null) {	dbPoolView.setNumActive(numActive);	dbPoolView.setNumIdle(numIdle);	dbPoolView.updateConnectionUsage(connectionId);	}	if (synLog.isTraceOrDebugEnabled()) {	
db connection 

int numActive = basicDataSource.getNumActive();	int numIdle = basicDataSource.getNumIdle();	String connectionId = Integer.toHexString(con.hashCode());	DBPoolView dbPoolView = getDbPoolView();	if (dbPoolView != null) {	dbPoolView.setNumActive(numActive);	dbPoolView.setNumIdle(numIdle);	dbPoolView.updateConnectionUsage(connectionId);	}	if (synLog.isTraceOrDebugEnabled()) {	
db connection instance identifier 

int numActive = basicDataSource.getNumActive();	int numIdle = basicDataSource.getNumIdle();	String connectionId = Integer.toHexString(con.hashCode());	DBPoolView dbPoolView = getDbPoolView();	if (dbPoolView != null) {	dbPoolView.setNumActive(numActive);	dbPoolView.setNumIdle(numIdle);	dbPoolView.updateConnectionUsage(connectionId);	}	if (synLog.isTraceOrDebugEnabled()) {	
number of active connection 

int numActive = basicDataSource.getNumActive();	int numIdle = basicDataSource.getNumIdle();	String connectionId = Integer.toHexString(con.hashCode());	DBPoolView dbPoolView = getDbPoolView();	if (dbPoolView != null) {	dbPoolView.setNumActive(numActive);	dbPoolView.setNumIdle(numIdle);	dbPoolView.updateConnectionUsage(connectionId);	}	if (synLog.isTraceOrDebugEnabled()) {	
number of idle connection 

}	PreparedStatement ps = con.prepareStatement(stmnt.getRawStatement());	List<Statement.Parameter> params = stmnt.getParameters();	int column = 1;	for (Statement.Parameter param : params) {	if (param == null) {	continue;	}	String value = (param.getPropertyName() != null ? param.getPropertyName() : param.getXpath().stringValueOf(msgCtx));	if (synLog.isTraceOrDebugEnabled()) {	
setting as parameter value as jdbc type see java sql types for valid types 

}	break;	}	default: {	String msg = "Trying to set an un-supported JDBC Type : " + param.getType() + " against column : " + column + " and statement : " + stmnt.getRawStatement() + " used by a DB mediator against DataSource : " + getDSName() + " (see java.sql.Types for valid type values)";	handleException(msg, msgCtx);	}	}	}	if (synLog.isTraceOrDebugEnabled()) {	
successfully prepared statement against datasource 

dataSource = DataSourceFinder.find(dataSourceName, jndiProperties);	if (dataSource == null) {	handleException("Cannot find a DataSource " + dataSourceName + " for given JNDI" + " properties :" + jndiProperties);	}	}	MBeanRepository mBeanRepository = DatasourceMBeanRepository.getInstance();	Object mBean = mBeanRepository.getMBean(dataSourceName);	if (mBean instanceof DBPoolView) {	setDbPoolView((DBPoolView) mBean);	}	
successfully looked up datasource 

protected DataSource createCustomDataSource(DataSourceInformation dataSourceInformation) {	DataSource dataSource = DataSourceFactory.createDataSource(dataSourceInformation);	if (dataSource != null) {	
successfully created data source for 

========================= synapse sample_527 =========================

public void deploy(DeploymentFileData deploymentFileData) throws DeploymentException {	String libFilePath = FilenameUtils.normalize(deploymentFileData.getAbsolutePath());	if (log.isDebugEnabled()) {	
deployment of the synapse library artifact from file started 

public void deploy(DeploymentFileData deploymentFileData) throws DeploymentException {	String libFilePath = FilenameUtils.normalize(deploymentFileData.getAbsolutePath());	if (log.isDebugEnabled()) {	}	if (getServerContextInformation().getServerState() != ServerState.STARTED) {	if (log.isDebugEnabled()) {	
skipped the library artifact deployment since the synapse server doesn t seem to be started yet from file 

if (getServerContextInformation().getServerState() != ServerState.STARTED) {	if (log.isDebugEnabled()) {	}	return;	}	try {	SynapseArtifactDeploymentStore deploymentStore = getSynapseConfiguration().getArtifactDeploymentStore();	Library lib = LibDeployerUtils.createSynapseLibrary(libFilePath);	String libArtifactName = lib.getQName().toString();	if (log.isDebugEnabled()) {	
created the synapse library from 

return;	}	try {	SynapseArtifactDeploymentStore deploymentStore = getSynapseConfiguration().getArtifactDeploymentStore();	Library lib = LibDeployerUtils.createSynapseLibrary(libFilePath);	String libArtifactName = lib.getQName().toString();	if (log.isDebugEnabled()) {	}	if (deploymentStore.isUpdatingArtifact(libFilePath)) {	if (log.isDebugEnabled()) {	
updating library artifact detected with filename 

if (log.isDebugEnabled()) {	}	String existingArtifactName = deploymentStore.getUpdatingArtifactWithFileName(libFilePath);	deploymentStore.removeUpdatingArtifact(libFilePath);	undeploySynapseArtifact(existingArtifactName);	completeDeployment(lib, libArtifactName);	} else {	try {	completeDeployment(lib, libArtifactName);	} catch (SynapseArtifactDeploymentException sade) {	
deployment of the synapse artifact from file failed 

completeDeployment(lib, libArtifactName);	} else {	try {	completeDeployment(lib, libArtifactName);	} catch (SynapseArtifactDeploymentException sade) {	+ backupFile(deploymentFileData.getFile()));*/ }	}	if (libArtifactName != null) {	deploymentStore.addArtifact(libFilePath, libArtifactName);	}	
synapse library named has been deployed from file 

}	if (libArtifactName != null) {	deploymentStore.addArtifact(libFilePath, libArtifactName);	}	} catch (IOException ex) {	handleDeploymentError("Deployment of synapse artifact failed. Error reading " + libFilePath + " : " + ex.getMessage(), ex);	} catch (Exception ex) {	handleDeploymentError("Deployment of synapse artifact failed for synapse libray at : " + libFilePath + " : " + ex.getMessage(), ex);	}	if (log.isDebugEnabled()) {	
deployment of the synapse artifact from file completed 

private void completeDeployment(Library lib, String libArtifactName) throws DeploymentException {	getSynapseConfiguration().addSynapseLibrary(lib.getQName().toString(), lib);	if (log.isDebugEnabled()) {	
synapse library deployment for lib completed 

private void completeDeployment(Library lib, String libArtifactName) throws DeploymentException {	getSynapseConfiguration().addSynapseLibrary(lib.getQName().toString(), lib);	if (log.isDebugEnabled()) {	}	SynapseImport synImport = getSynapseConfiguration().getSynapseImports().get(libArtifactName);	if (synImport != null) {	LibDeployerUtils.loadLibArtifacts(synImport, lib);	if (log.isDebugEnabled()) {	
loading synapse library into memory for import 

public void undeploy(String fileName) throws DeploymentException {	fileName = FilenameUtils.normalize(fileName);	if (log.isDebugEnabled()) {	
undeployment of the synapse library from file started 

public void undeploy(String fileName) throws DeploymentException {	fileName = FilenameUtils.normalize(fileName);	if (log.isDebugEnabled()) {	}	SynapseArtifactDeploymentStore deploymentStore = getSynapseConfiguration().getArtifactDeploymentStore();	if (deploymentStore.containsFileName(fileName)) {	File undeployingFile = new File(fileName);	if (undeployingFile.exists()) {	if (log.isDebugEnabled()) {	
marking artifact as updating from file 

}	if (!deploymentStore.isRestoredFile(fileName)) {	deploymentStore.addUpdatingArtifact( fileName, deploymentStore.getArtifactNameForFile(fileName));	deploymentStore.removeArtifactWithFileName(fileName);	}	} else {	String artifactName = deploymentStore.getArtifactNameForFile(fileName);	try {	undeploySynapseArtifact(artifactName);	deploymentStore.removeArtifactWithFileName(fileName);	
synapse library named has been undeployed 

if (!deploymentStore.isRestoredFile(fileName)) {	deploymentStore.addUpdatingArtifact( fileName, deploymentStore.getArtifactNameForFile(fileName));	deploymentStore.removeArtifactWithFileName(fileName);	}	} else {	String artifactName = deploymentStore.getArtifactNameForFile(fileName);	try {	undeploySynapseArtifact(artifactName);	deploymentStore.removeArtifactWithFileName(fileName);	} catch (SynapseArtifactDeploymentException sade) {	
unable to undeploy the synapse library artifact from file 

deploymentStore.removeArtifactWithFileName(fileName);	} catch (SynapseArtifactDeploymentException sade) {	}	}	} else {	String msg = "Artifact representing the filename " + fileName + " is not deployed on Synapse";	log.error(msg);	throw new DeploymentException(msg);	}	if (log.isDebugEnabled()) {	
undeployment of the synapse library artifact from file completed 

========================= synapse sample_177 =========================

public void testSessionLessLB() {	String addUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test session less load balancing between endpoints 

========================= synapse sample_2283 =========================

public void addProperty(String name, Property value) {	if(name != null && value != null) {	if(globalProps.containsKey(name)) {	
overiding the global property with name 

node = registry.lookup(value.getKey());	if (node == null) {	handleException("Registry key should map to a XML resource.");	}	} catch (Exception e) {	handleException("Registry key should map to a XML resource.");	}	}	globalProps.put(name, value);	} else {	
name and the value of the property cannot be null 

========================= synapse sample_3241 =========================

public boolean mediate(MessageContext synCtx) {	
class mediator mediate 

private void setProperties(Mediator m, MessageContext synCtx, boolean shouldTrace) {	Iterator iter = properties.iterator();	while (iter.hasNext()) {	MediatorProperty mProp = (MediatorProperty) iter.next();	String mName = "set" + Character.toUpperCase(mProp.getName().charAt(0)) + mProp.getName().substring(1);	String value = (mProp.getValue() != null ? mProp.getValue() : Axis2MessageContext.getStringValue(mProp.getExpression(), synCtx));	try {	Method method = m.getClass().getMethod(mName, new Class[] {String.class});	
setting property invoking method 

========================= synapse sample_3304 =========================

}	if (snmpVersion > SnmpConstants.version1) {	if (obj instanceof Long) {	return new Counter64(((Long) obj).longValue());	} else if (obj instanceof Date) {	return new Counter64(((Date) obj).getTime());	}	}	return new OctetString(obj.toString());	} catch (Exception e) {	
unexpected error while retrieving the value of oid 

========================= synapse sample_2132 =========================

public boolean process(MessageContext synCtx) {	if (synCtx.isResponse()) {	return dispatchToAPI(synCtx);	}	org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext) synCtx). getAxis2MessageContext();	String protocol = msgCtx.getIncomingTransportName();	if (!Constants.TRANSPORT_HTTP.equals(protocol) && !Constants.TRANSPORT_HTTPS.equals(protocol)) {	if (log.isDebugEnabled()) {	
invalid protocol for rest api mediation 

private boolean dispatchToAPI(MessageContext synCtx) {	Collection<API> apiSet = synCtx.getEnvironment().getSynapseConfiguration().getAPIs();	API defaultAPI = null;	for (API api : apiSet) {	if ("/".equals(api.getContext())) {	defaultAPI = api;	} else if (api.canProcess(synCtx)) {	if (log.isDebugEnabled()) {	
located specific api for processing message 

========================= synapse sample_679 =========================

public SessionInformation getSession(MessageContext synCtx) {	String hostName = extractHost(synCtx);	if (log.isDebugEnabled()) {	
extracted host name 

public SessionInformation getSession(MessageContext synCtx) {	String hostName = extractHost(synCtx);	if (log.isDebugEnabled()) {	}	org.apache.axis2.context.MessageContext axis2MessageContext = ((Axis2MessageContext) synCtx).getAxis2MessageContext();	if (log.isDebugEnabled()) {	
endpoint address 

public SessionInformation getSession(MessageContext synCtx) {	String hostName = extractHost(synCtx);	if (log.isDebugEnabled()) {	}	org.apache.axis2.context.MessageContext axis2MessageContext = ((Axis2MessageContext) synCtx).getAxis2MessageContext();	if (log.isDebugEnabled()) {	}	Map headerMap = getTransportHeaderMap(synCtx);	String contentType = (String)headerMap.get("Content-Type");	if (log.isDebugEnabled()) {	
content type 

if (sessionList != null) {	for (String sessionID : sessionList) {	SessionInformation sessionInfoObj = SALSessions.getInstance().getSession(sessionID);	if (sessionInfoObj != null && sessionInfoObj.getMember() != null) {	Map<String, String> subDomainNames = (Map<String, String>) sessionInfoObj.getMember().getProperties().get(HOSTS);	if (log.isDebugEnabled()) {	log.debug("Member Domain : " + (subDomainNames != null ? subDomainNames.get(hostName) : null) + " : Session ID " + sessionID);	}	if (subDomainNames != null && subDomainNames.get(hostName) != null) {	if (log.isDebugEnabled()) {	
found a matching sessioninfo object for the 

if (subDomainNames != null && subDomainNames.get(hostName) != null) {	if (log.isDebugEnabled()) {	}	return sessionInfoObj;	}	}	}	}	}	if (log.isDebugEnabled()) {	
did not find a session info obj 

public void updateSession(MessageContext synCtx) {	String sessionId = extractSessionID(synCtx, SET_COOKIE);	if (sessionId != null) {	if (log.isDebugEnabled()) {	
found the http header set cookie for updating the session 

public void updateSession(MessageContext synCtx) {	String sessionId = extractSessionID(synCtx, SET_COOKIE);	if (sessionId != null) {	if (log.isDebugEnabled()) {	
using the session id extracted from the set cookie header 

protected List<String> extractSessionIDs(MessageContext synCtx, String key) {	List<String> sessionList = new ArrayList<String>();	if (key != null) {	Map headerMap = getTransportHeaderMap(synCtx);	if (headerMap != null) {	Object hostObj = headerMap.get("Host");	if (log.isDebugEnabled()) {	
a request received with the host name 

if (key != null) {	Map headerMap = getTransportHeaderMap(synCtx);	if (headerMap != null) {	Object hostObj = headerMap.get("Host");	if (log.isDebugEnabled()) {	}	Object cookieObj = headerMap.get(key);	if (cookieObj instanceof String) {	String cookie = (String) cookieObj;	if (log.isDebugEnabled()) {	
cookies string 

if (log.isDebugEnabled()) {	}	Object cookieObj = headerMap.get(key);	if (cookieObj instanceof String) {	String cookie = (String) cookieObj;	if (log.isDebugEnabled()) {	}	String[] sessionIds = cookie.split(";");	if (sessionIds == null || sessionIds.length == 0) {	if (log.isDebugEnabled()) {	
cannot find a session id for the cookie 

}	String[] sessionIds = cookie.split(";");	if (sessionIds == null || sessionIds.length == 0) {	if (log.isDebugEnabled()) {	}	return null;	}	for(String sessionId : sessionIds){	if(sessionId != null && sessionId.contains("JSESSIONID")) {	if (log.isDebugEnabled()) {	
extracted sessionid 

}	for(String sessionId : sessionIds){	if(sessionId != null && sessionId.contains("JSESSIONID")) {	if (log.isDebugEnabled()) {	}	sessionList.add(sessionId.trim());	}	}	} else {	if (log.isDebugEnabled()) {	
couldn t find the header to find the session 

}	sessionList.add(sessionId.trim());	}	}	} else {	if (log.isDebugEnabled()) {	}	}	} else {	if (log.isDebugEnabled()) {	
couldn t find the transport headers to find the session 

========================= synapse sample_229 =========================

try {	boolean wasError = true;	int retryCount = 0;	int maxRetryCount = VFSUtils.getMaxRetryCount(msgCtx, vfsOutInfo);	long reconnectionTimeout = VFSUtils.getReconnectTimout(msgCtx, vfsOutInfo);	while(wasError == true) {	try {	retryCount++;	replyFile = fsManager.resolveFile(vfsOutInfo.getOutFileURI());	if(replyFile == null) {	
replyfile is null 

long reconnectionTimeout = VFSUtils.getReconnectTimout(msgCtx, vfsOutInfo);	while(wasError == true) {	try {	retryCount++;	replyFile = fsManager.resolveFile(vfsOutInfo.getOutFileURI());	if(replyFile == null) {	throw new FileSystemException("replyFile is null");	}	wasError = false;	} catch(FileSystemException e) {	
cannot resolve replyfile 

========================= synapse sample_3723 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	
start send mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceTraceEnabled()) {	}	if (receivingSequence != null) {	if (synLog.isTraceOrDebugEnabled()) {	
receiving sequence is set to 

}	if (endpoint == null) {	if (synLog.isTraceOrDebugEnabled()) {	StringBuffer sb = new StringBuffer();	sb.append("Sending ").append(synCtx.isResponse() ? "response" : "request") .append(" message using implicit message properties..");	sb.append("\nSending To: ").append(synCtx.getTo() != null ? synCtx.getTo().getAddress() : "null");	sb.append("\nSOAPAction: ").append(synCtx.getWSAAction() != null ? synCtx.getWSAAction() : "null");	synLog.traceOrDebug(sb.toString());	}	if (synLog.isTraceTraceEnabled()) {	
envelope 

sb.append("\nSending To: ").append(synCtx.getTo() != null ? synCtx.getTo().getAddress() : "null");	sb.append("\nSOAPAction: ").append(synCtx.getWSAAction() != null ? synCtx.getWSAAction() : "null");	synLog.traceOrDebug(sb.toString());	}	if (synLog.isTraceTraceEnabled()) {	}	synCtx.getEnvironment().send(null, synCtx);	} else {	endpoint.send(synCtx);	}	
end send mediator 

========================= synapse sample_1964 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	
start validate mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceTraceEnabled()) {	
message 

try {	Validator validator = cachedSchema.newValidator();	validator.setErrorHandler(errorHandler);	validator.validate(validateSrc);	if (errorHandler.isValidationError()) {	if (synLog.isTraceOrDebugEnabled()) {	String msg = "Validation of element returned by XPath : " + source + " failed against the given schema(s) " + schemaKeys + "with error : " + errorHandler.getSaxParseException().getMessage() + " Executing 'on-fail' sequence";	synLog.traceOrDebug(msg);	synCtx.getServiceLog().warn(msg);	if (synLog.isTraceTraceEnabled()) {	
failed message envelope 

synCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, errorHandler.getSaxParseException());	synCtx.setProperty(SynapseConstants.ERROR_DETAIL, FaultHandler.getStackTrace(errorHandler.getSaxParseException()));	return super.mediate(synCtx);	}	} catch (SAXException e) {	handleException("Error validating " + source + " element", e, synCtx);	} catch (IOException e) {	handleException("Error validating " + source + " element", e, synCtx);	}	if (synLog.isTraceOrDebugEnabled()) {	
validation of element returned by the xpath expression succeeded against the given schemas and the current message 

synCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, errorHandler.getSaxParseException());	synCtx.setProperty(SynapseConstants.ERROR_DETAIL, FaultHandler.getStackTrace(errorHandler.getSaxParseException()));	return super.mediate(synCtx);	}	} catch (SAXException e) {	handleException("Error validating " + source + " element", e, synCtx);	} catch (IOException e) {	handleException("Error validating " + source + " element", e, synCtx);	}	if (synLog.isTraceOrDebugEnabled()) {	
end validate mediator 

========================= synapse sample_550 =========================

public void testCallOutSecurity() {	
running test callout mediator with security 

========================= synapse sample_803 =========================

else if (AMQPConstants.AMQP_DELIVERY_MODE.equals(name)) {	Object o = headerMap.get(AMQPConstants.AMQP_DELIVERY_MODE);	if (o instanceof Short) {	deliveryProps.setDeliveryMode(((Short) o).shortValue());	}else if (o instanceof Integer) {	deliveryProps.setDeliveryMode(((Integer) o).shortValue());	}else if (o instanceof String) {	try {	deliveryProps.setDeliveryMode(Short.parseShort((String) o));	} catch (NumberFormatException nfe) {	
invalid delivery mode ignored 

if (o instanceof Short) {	deliveryProps.setDeliveryMode(((Short) o).shortValue());	}else if (o instanceof Integer) {	deliveryProps.setDeliveryMode(((Integer) o).shortValue());	}else if (o instanceof String) {	try {	deliveryProps.setDeliveryMode(Short.parseShort((String) o));	} catch (NumberFormatException nfe) {	}	} else {	
invalid delivery mode ignored 

if (waitReply != null) {	timeout = Long.valueOf(waitReply).longValue();	}	String destination = msgProps.getReplyTo().getRoutingKey();	MessageManager listener = new MessageManager(session,destination,msgProps.getCorrelationId());	session.messageSubscribe(msgProps.getReplyTo().getRoutingKey(), destination, Session.TRANSFER_CONFIRM_MODE_REQUIRED, Session.TRANSFER_ACQUIRE_MODE_PRE_ACQUIRE, new MessagePartListenerAdapter(listener), null, Option.NO_OPTION);	Message reply = listener.receive(timeout);	if (reply != null) {	processSyncResponse(msgCtx, reply);	} else {	
did not receive a response within ms to destination with correlation id 

========================= synapse sample_4265 =========================

} else {	consumer = ((TopicSession) session).createSubscriber((Topic) replyDestination);	}	}	long timeout = JMSConstants.DEFAULT_JMS_TIMEOUT;	String waitReply = (String) msgCtx.getProperty(JMSConstants.JMS_WAIT_REPLY);	if (waitReply != null) {	timeout = Long.valueOf(waitReply).longValue();	}	if (log.isDebugEnabled()) {	
waiting for a maximum of ms for a response message to destination with jms correlation id 

String waitReply = (String) msgCtx.getProperty(JMSConstants.JMS_WAIT_REPLY);	if (waitReply != null) {	timeout = Long.valueOf(waitReply).longValue();	}	if (log.isDebugEnabled()) {	}	Message reply = consumer.receive(timeout);	if (reply != null) {	processSyncResponse(msgCtx, reply);	} else {	
did not receive a jms response within ms to destination with jms correlation id 

private void loadConnectionFactoryDefinitions(TransportOutDescription transportOut) {	Iterator conFacIter = transportOut.getParameters().iterator();	while (conFacIter.hasNext()) {	Parameter conFacParams = (Parameter) conFacIter.next();	JMSConnectionFactory jmsConFactory = new JMSConnectionFactory(conFacParams.getName(), cfgCtx);	JMSUtils.setConnectionFactoryParameters(conFacParams, jmsConFactory);	try {	jmsConFactory.connectAndListen();	} catch (NamingException e) {	
error looking up jms connection factory 

private void loadConnectionFactoryDefinitions(TransportOutDescription transportOut) {	Iterator conFacIter = transportOut.getParameters().iterator();	while (conFacIter.hasNext()) {	Parameter conFacParams = (Parameter) conFacIter.next();	JMSConnectionFactory jmsConFactory = new JMSConnectionFactory(conFacParams.getName(), cfgCtx);	JMSUtils.setConnectionFactoryParameters(conFacParams, jmsConFactory);	try {	jmsConFactory.connectAndListen();	} catch (NamingException e) {	} catch (JMSException e) {	
error connecting to jms connection factory 

========================= synapse sample_3774 =========================

public void init() {	if (log.isDebugEnabled()) {	
initializing beanstalk 

public void init() {	if (log.isDebugEnabled()) {	}	try {	initialCtx = new InitialContext(props);	} catch (NamingException e) {	
could not initialize jndi context for the enterprise beanstalk named 

}	}	int minDelay = Math.min(statelessBeanTimeoutMinutes, statefulBeanTimeoutMinutes);	scheduledFuture = scheduler.scheduleWithFixedDelay( new Runnable() {	public void run() {	removeExpiredBeans();	}	}, minDelay, minDelay, TimeUnit.MINUTES);	MBeanRegistrar.getInstance().registerMBean(new EnterpriseBeanstalkView(this), EnterpriseBeanstalkConstants.ENTERPRISE_BEANSTALK_MBEAN_CATEGORY_NAME, name);	if (log.isDebugEnabled()) {	
successfully initialized beanstalk 

if (entry == null && jndiName != null) {	synchronized (this) {	entry = map.get(getMapKey(className, sessionId));	if (entry == null) {	Object ejb = lookupInJndi(jndiName);	if (ejb != null) {	map.put(getMapKey(className, sessionId), entry = new CacheEntry(ejb));	int size = map.size();	if (size > warnLimit) {	String type = sessionId == null ? "stateless" : "stateful";	
warn limit reached for beans currently there are ejb stubs cached in beanstalk 

private Object lookupInJndi(String jndiName) {	try {	return initialCtx.lookup(jndiName);	} catch (NamingException ex) {	
lookup failed for jndi name 

private void removeExpiredBeansFromMap(Map<String, CacheEntry> map, int timeoutInMinutes) {	Iterator<Map.Entry<String, CacheEntry>> itr = map.entrySet().iterator();	while (itr.hasNext()) {	Map.Entry<String, CacheEntry> mapEntry = itr.next();	if (System.currentTimeMillis() - mapEntry.getValue().getLastAccessTime() > timeoutInMinutes * 60L * 1000L) {	if (log.isDebugEnabled()) {	
removing the timed out ejb stub with key from beanstalk cache 

========================= synapse sample_784 =========================

public void addTaskDescription(TaskDescription taskDescription) {	validateTaskDescription(taskDescription);	String name = taskDescription.getName();	validateName(name);	validateUniqueness(name);	if (log.isDebugEnabled()) {	
storing a taskdescription 

public TaskDescription getTaskDescription(String name) {	validateName(name);	TaskDescription taskDescription = taskDescriptionMap.get(name);	if (taskDescription == null) {	if (log.isDebugEnabled()) {	
taskdescription cannot be found for name returning null 

public TaskDescription getTaskDescription(String name) {	validateName(name);	TaskDescription taskDescription = taskDescriptionMap.get(name);	if (taskDescription == null) {	if (log.isDebugEnabled()) {	}	} else {	if (log.isDebugEnabled()) {	
returning taskdescription 

public TaskDescription removeTaskDescription(String name) {	validateName(name);	if (log.isDebugEnabled()) {	
removing a taskdescription with name 

public TaskDescription removeTaskDescription(String name) {	validateName(name);	if (log.isDebugEnabled()) {	}	TaskDescription taskDescription = taskDescriptionMap.remove(name);	if (taskDescription == null) {	if (log.isDebugEnabled()) {	
there is no taskdescription to be removed with name 

public TaskDescription removeTaskDescription(String name) {	validateName(name);	if (log.isDebugEnabled()) {	}	TaskDescription taskDescription = taskDescriptionMap.remove(name);	if (taskDescription == null) {	if (log.isDebugEnabled()) {	}	} else {	if (log.isDebugEnabled()) {	
removed taskdescription 

========================= synapse sample_1460 =========================

public void testFireAndForget() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test one way messaging fireandforget through synapse 

========================= synapse sample_854 =========================

protected synchronized void open() {	File dir = new File(AccessConstants.DIRECTORY);	if (!dir.exists()) {	if (!dir.mkdirs()) {	
access log open directory failed 

try {	String pathName;	if (isRotatable) {	pathName = dir.getAbsolutePath() + File.separator + AccessConstants.PREFIX + dateStamp + AccessConstants.SUFFIX;	} else {	pathName = dir.getAbsolutePath() + File.separator + AccessConstants.PREFIX + AccessConstants.SUFFIX;	}	writer = new PrintWriter(new BufferedWriter(new FileWriter( pathName, true), 128000), true);	currentLogFile = new File(pathName);	} catch (IOException e) {	
unable to open the print writer 

========================= synapse sample_1030 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start pojocommand mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	if (synLog.isTraceOrDebugEnabled()) {	
creating a new instance of pojo class 

}	}	if (synLog.isTraceOrDebugEnabled()) {	}	Object commandObject = null;	try {	commandObject = getCommand().newInstance();	} catch (Exception e) {	handleException("Error creating an instance of the POJO command class : " + getCommand().getClass(), e, synCtx);	}	
instance created setting static and dynamic properties 

v = xpath.stringValueOf(synCtx);	} else {	throw new UnsupportedOperationException("non-String types not supportted yet");	}	try {	m.invoke(commandObject, v);	} catch (Exception e) {	e.printStackTrace();	}	}	
pojo initialized successfully invoking the execute method 

Method exeMethod = null;	try {	exeMethod = getCommand().getMethod("execute", new Class[]{});	exeMethod.invoke(commandObject, new Object[]{});	} catch (NoSuchMethodException e) {	handleException("Cannot locate an execute() method on POJO class : " + getCommand().getClass(), e, synCtx);	} catch (Exception e) {	handleException("Error invoking the execute() method on POJO class : " + getCommand().getClass(), e, synCtx);	}	}	
end pojocommand mediator 

========================= synapse sample_507 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
invoking target eip sequence paramnames 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

========================= synapse sample_1933 =========================

public void writeTo(MessageContext msgCtx, OMOutputFormat format, OutputStream out, boolean preserve) throws AxisFault {	try {	quickfix.Message message = FIXUtils.getInstance().createFIXMessage(msgCtx);	out.write(message.toString().getBytes());	} catch (IOException e) {	
error while formatting fix soap message 

========================= synapse sample_2489 =========================

protected void handleSingleSecretCallback(SingleSecretCallback singleSecretCallback) {	if (!secretManager.isInitialized()) {	if (log.isWarnEnabled()) {	
secretmanager has not been initialized cannot collect secrets 

========================= synapse sample_2523 =========================

public SampleClientResult sendUsingMTOM(String fileName, String targetEPR) {	clientResult = new SampleClientResult();	try {	OMFactory factory = OMAbstractFactory.getOMFactory();	OMNamespace ns = factory.createOMNamespace("http: payload = factory.createOMElement("uploadFileUsingMTOM", ns);	OMElement request = factory.createOMElement("request", ns);	OMElement image = factory.createOMElement("image", ns);	
sending file as mtom 

serviceClient = new ServiceClient(configContext, null);	Options options = new Options();	options.setTo(new EndpointReference(targetEPR));	options.setAction("urn:uploadFileUsingMTOM");	options.setProperty(Constants.Configuration.ENABLE_MTOM, Constants.VALUE_TRUE);	serviceClient.setOptions(options);	OMElement response = serviceClient.sendReceive(payload);	OMText binaryNode = (OMText) response. getFirstChildWithName(new QName("http: getFirstChildWithName(new QName("http: getFirstOMChild();	dataHandler = (DataHandler) binaryNode.getDataHandler();	InputStream is = dataHandler.getInputStream();	
temp dir java io tmpdir 

File tempFile = File.createTempFile("mtom-", ".gif");	FileOutputStream fos = new FileOutputStream(tempFile);	BufferedOutputStream dest = new BufferedOutputStream(fos, 2048);	byte data[] = new byte[2048];	int count;	while ((count = is.read(data, 0, 2048)) != -1) {	dest.write(data, 0, count);	}	dest.flush();	dest.close();	
saved response to file 

BufferedOutputStream dest = new BufferedOutputStream(fos, 2048);	byte data[] = new byte[2048];	int count;	while ((count = is.read(data, 0, 2048)) != -1) {	dest.write(data, 0, count);	}	dest.flush();	dest.close();	clientResult.incrementResponseCount();	} catch (Exception e) {	
error invoking service 

try {	Options options = new Options();	options.setTo(new EndpointReference(targetEPR));	options.setAction("urn:uploadFileUsingSwA");	options.setProperty(Constants.Configuration.ENABLE_SWA, Constants.VALUE_TRUE);	ConfigurationContext configContext = ConfigurationContextFactory. createConfigurationContextFromFileSystem(configuration.getClientRepo(), configuration.getAxis2Xml());	ServiceClient sender = new ServiceClient(configContext, null);	sender.setOptions(options);	OperationClient mepClient = sender.createClient(ServiceClient.ANON_OUT_IN_OP);	MessageContext mc = new MessageContext();	
sending file as swa 

MessageContext response = mepClient.getMessageContext(WSDLConstants.MESSAGE_LABEL_IN_VALUE);	SOAPBody body = response.getEnvelope().getBody();	String imageContentId = body. getFirstChildWithName(new QName("http: getFirstChildWithName(new QName("http: getFirstChildWithName(new QName("http: getText();	Attachments attachment = response.getAttachmentMap();	dataHandler = attachment.getDataHandler(imageContentId);	File tempFile = File.createTempFile("swa-", ".gif");	FileOutputStream fos = new FileOutputStream(tempFile);	dataHandler.writeTo(fos);	fos.flush();	fos.close();	
saved response to file 

String imageContentId = body. getFirstChildWithName(new QName("http: getFirstChildWithName(new QName("http: getFirstChildWithName(new QName("http: getText();	Attachments attachment = response.getAttachmentMap();	dataHandler = attachment.getDataHandler(imageContentId);	File tempFile = File.createTempFile("swa-", ".gif");	FileOutputStream fos = new FileOutputStream(tempFile);	dataHandler.writeTo(fos);	fos.flush();	fos.close();	clientResult.incrementResponseCount();	} catch (Exception e) {	
error invoking service 

========================= synapse sample_792 =========================

public static void setStaticProperty(OMElement property, Object o) {	if (property.getLocalName().toLowerCase().equals("property")) {	String propertyName = property.getAttributeValue(new QName("name"));	String mName = "set" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1);	if (property.getAttributeValue(new QName("value")) != null) {	String value = property.getAttributeValue(new QName("value"));	try {	Method method = o.getClass().getMethod(mName, String.class);	if (log.isDebugEnabled()) {	
setting property invoking method 

method.invoke(o, value);	} catch (Exception e) {	handleException("Error setting property : " + propertyName + " as a String property into class mediator : " + o.getClass() + " : " + e.getMessage(), e);	}	} else {	OMElement value = property.getFirstElement();	if (value != null) {	try {	Method method = o.getClass().getMethod(mName, OMElement.class);	if (log.isDebugEnabled()) {	
setting property invoking method 

========================= synapse sample_454 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
invoking target eip sequence paramnames 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

========================= synapse sample_511 =========================

private static void registerExtensions() {	Iterator<MediatorFactory> factories = ServiceLoader.load(MediatorFactory.class).iterator();	while (factories.hasNext()) {	MediatorFactory factory = factories.next();	QName tag = factory.getTagQName();	factoryMap.put(tag, factory.getClass());	if (log.isDebugEnabled()) {	
added mediatorfactory to handle 

public Mediator getMediator(OMElement element, Properties properties) {	String localName = element.getLocalName();	QName qName;	if (element.getNamespace() != null) {	qName = new QName(element.getNamespace().getNamespaceURI(), localName);	} else {	qName = new QName(localName);	}	if (log.isDebugEnabled()) {	
getmediator 

} else {	qName = new QName(localName);	}	if (log.isDebugEnabled()) {	}	Class cls = factoryMap.get(qName);	if (cls == null && localName.indexOf('.') > -1) {	String newLocalName = localName.substring(0, localName.indexOf('.'));	qName = new QName(element.getNamespace().getNamespaceURI(), newLocalName);	if (log.isDebugEnabled()) {	
getmediator 

========================= synapse sample_395 =========================

public void writeTo(MessageContext messageContext, OMOutputFormat format, OutputStream outputStream, boolean preserve) throws AxisFault {	try {	if (log.isDebugEnabled()) {	
serialize message in to a gzip stream 

========================= synapse sample_2431 =========================

boolean registryCreated = false;	int jndiPort = jmxInformation.getJndiPort();	if (jndiPort == 0) {	jndiPort = JNDI_AUTO_PORT_OFFSET;	for (int retries = 0; !registryCreated && (retries < 100); retries++) {	try {	RMIRegistryController.getInstance().createLocalRegistry(jndiPort);	registryCreated = true;	} catch (Exception ignored) {	jndiPort++;	
trying alternate port 

}	if (registryCreated) {	jmxInformation.updateJMXUrl();	JMXServiceURL url = new JMXServiceURL(jmxInformation.getJmxUrl());	Map<String, Object> env = createContextMap();	MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();	connectorServer = JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);	try {	connectorServer.start();	} catch (IOException ex) {	
cannot start jmxconnectorserver on 

JMXServiceURL url = new JMXServiceURL(jmxInformation.getJmxUrl());	Map<String, Object> env = createContextMap();	MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();	connectorServer = JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);	try {	connectorServer.start();	} catch (IOException ex) {	}	}	} catch (Exception ex) {	
error while setting up remote jmx connector 

public void stop() {	if (connectorServer != null) {	
jmxconnectorserver stopping on 

public void stop() {	if (connectorServer != null) {	try {	connectorServer.stop();	RMIRegistryController.getInstance().removeLocalRegistry(jmxInformation.getJndiPort());	jmxInformation = null;	} catch (IOException ex) {	
error while stopping remote jmx connector 

private void initConfiguration() {	int jndiPort = jmxInformation.getJndiPort();	if ((jndiPort < 0) || (65535 < jndiPort)) {	throw new SynapseException("JNDI Port for Remote Registry not properly configured");	}	int rmiPort = jmxInformation.getRmiPort();	if ((rmiPort < 0) || (65535 < rmiPort)) {	rmiPort = 0;	
no or invalid value specified for jmx rmi port using dynamic port 

if (pwManager.isInitialized()) {	secretInformation.setGlobalSecretResolver(pwManager.getSecretResolver());	}	env.put(JMXConnectorServer.AUTHENTICATOR, new JmxSecretAuthenticator(jmxInformation.getSecretInformation()));	}	if (jmxInformation.getRemoteAccessFile() != null) {	env.put("jmx.remote.x.access.file", jmxInformation.getRemoteAccessFile());	}	}	if (jmxInformation.isRemoteSSL()) {	
activated ssl communication 

========================= synapse sample_680 =========================

public Map<String, Map<String, InOutStatisticsView>> determineView( List<StatisticsRecord> statisticsRecords, ComponentType type) {	final Map<String, Map<String, InOutStatisticsView>> statisticsMap = new HashMap<String, Map<String, InOutStatisticsView>>();	if (statisticsRecords == null) {	if (log.isDebugEnabled()) {	
statistics records cannot be found 

public Map<String, InOutStatisticsView> determineView(String id, List<StatisticsRecord> statisticsRecords, ComponentType type) {	if (id == null || "".equals(id)) {	handleException("Resource Id cannot be null");	}	Map<String, InOutStatisticsView> statisticsMap = new HashMap<String, InOutStatisticsView>();	if (statisticsRecords == null) {	if (log.isDebugEnabled()) {	
statistics records cannot be found 

========================= synapse sample_2061 =========================

public void destroy() {	if (getDataSource() instanceof BasicDataSource) {	try {	((BasicDataSource) getDataSource()).close();	
successfully shut down db connection pool for url 

public void destroy() {	if (getDataSource() instanceof BasicDataSource) {	try {	((BasicDataSource) getDataSource()).close();	} catch (SQLException e) {	
error shutting down db connection pool for url 

========================= synapse sample_3670 =========================

private void init() {	String algorithm = cipherInformation.getAlgorithm();	CipherOperationMode opMode = cipherInformation.getCipherOperationMode();	if (key == null) {	key = getKey(opMode);	}	if (log.isDebugEnabled()) {	
initializing cipher with algorithm in mode 

========================= synapse sample_1134 =========================

public boolean mediate(MessageContext synCtx) {	
validatemediator validate mediator mediate 

handleException("Error accessing source element for validation : " + source, e);	}	try {	XMLReader reader = XMLReaderFactory.createXMLReader();	SAXSource saxSrc = new SAXSource(reader, new InputSource(baisFromSource));	synchronized (validatorLock) {	initialize(synCtx);	validator.validate(saxSrc);	if (errorHandler.isValidationError()) {	if (log.isDebugEnabled()) {	
validation of element returned by xpath failed against the given schemas with message executing on fail sequence 

handleException("Error accessing source element for validation : " + source, e);	}	try {	XMLReader reader = XMLReaderFactory.createXMLReader();	SAXSource saxSrc = new SAXSource(reader, new InputSource(baisFromSource));	synchronized (validatorLock) {	initialize(synCtx);	validator.validate(saxSrc);	if (errorHandler.isValidationError()) {	if (log.isDebugEnabled()) {	
failed message envelope 

trace.trace("Validation failed. Invoking the \"on-fail\" " + "sequence of mediators");	}	return super.mediate(synCtx);	}	}	} catch (SAXException e) {	handleException("Error validating " + source + " element" + e.getMessage(), e);	} catch (IOException e) {	handleException("Error validating " + source + " element" + e.getMessage(), e);	}	
validation of element returned by the xpath expression succeeded against the given schemas and the current message 

========================= synapse sample_3109 =========================

if (keyParam != null) {	OMElement ksEle      = keyParam.getParameterElement().getFirstElement();	String location      = ksEle.getFirstChildWithName(new QName("Location")).getText();	String type          = ksEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = ksEle.getFirstChildWithName(new QName("Password")).getText();	String keyPassword   = ksEle.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading identity keystore from 

String keyPassword   = ksEle.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

}	if (trustParam != null) {	OMElement tsEle      = trustParam.getParameterElement().getFirstElement();	String location      = tsEle.getFirstChildWithName(new QName("Location")).getText();	String type          = tsEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = tsEle.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading trust keystore from 

String storePassword = tsEle.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

fis.close();	} catch (IOException ignore) {}	}	}	}	try {	SSLContext sslcontext = SSLContext.getInstance("TLS");	sslcontext.init(keymanagers, trustManagers, null);	return sslcontext;	} catch (GeneralSecurityException gse) {	
unable to create ssl context with the given configuration 

========================= synapse sample_950 =========================

public void testCache() {	String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test simple cache implemented on synapse for the actual service 

========================= synapse sample_815 =========================

if (acceptor) {	eventHandlerParam = service.getParameter(FIXConstants.FIX_ACCEPTOR_EVENT_HANDLER);	} else {	eventHandlerParam = service.getParameter(FIXConstants.FIX_INITIATOR_EVENT_HANDLER);	}	if (eventHandlerParam != null && eventHandlerParam.getValue() != null && !"".equals(eventHandlerParam.getValue())) {	try {	Class clazz = getClass().getClassLoader().loadClass( (String) eventHandlerParam.getValue());	eventHandler = (SessionEventHandler) clazz.newInstance();	} catch (ClassNotFoundException e) {	
unable to find the session event handler class 

eventHandlerParam = service.getParameter(FIXConstants.FIX_ACCEPTOR_EVENT_HANDLER);	} else {	eventHandlerParam = service.getParameter(FIXConstants.FIX_INITIATOR_EVENT_HANDLER);	}	if (eventHandlerParam != null && eventHandlerParam.getValue() != null && !"".equals(eventHandlerParam.getValue())) {	try {	Class clazz = getClass().getClassLoader().loadClass( (String) eventHandlerParam.getValue());	eventHandler = (SessionEventHandler) clazz.newInstance();	} catch (ClassNotFoundException e) {	} catch (Exception e) {	
error while initializing the session event handler class 

private boolean isSingleThreaded() {	Parameter singleThreadParam = service.getParameter( FIXConstants.FIX_ACCEPTOR_SINGLE_THREADED);	if (acceptor && singleThreadParam != null && JavaUtils.isTrueExplicitly(singleThreadParam.getValue())) {	
fix acceptor for service is single threaded 

private boolean isSingleThreaded() {	Parameter singleThreadParam = service.getParameter( FIXConstants.FIX_ACCEPTOR_SINGLE_THREADED);	if (acceptor && singleThreadParam != null && JavaUtils.isTrueExplicitly(singleThreadParam.getValue())) {	return true;	}	singleThreadParam = service.getParameter( FIXConstants.FIX_INITIATOR_SINGLE_THREADED);	if (!acceptor && singleThreadParam != null && JavaUtils.isTrueExplicitly(singleThreadParam.getValue())) {	
fix initiator for service is single threaded 

Parameter singleThreadParam = service.getParameter( FIXConstants.FIX_ACCEPTOR_SINGLE_THREADED);	if (acceptor && singleThreadParam != null && JavaUtils.isTrueExplicitly(singleThreadParam.getValue())) {	return true;	}	singleThreadParam = service.getParameter( FIXConstants.FIX_INITIATOR_SINGLE_THREADED);	if (!acceptor && singleThreadParam != null && JavaUtils.isTrueExplicitly(singleThreadParam.getValue())) {	return true;	}	singleThreadParam = service.getParameter( FIXConstants.FIX_PROCESS_SINGLE_THREADED);	if (singleThreadParam != null && JavaUtils.isTrueExplicitly(singleThreadParam.getValue())) {	
fix processor for service is single threaded 

public void onCreate(SessionID sessionID) {	
new fix session created 

public void toAdmin(Message message, SessionID sessionID) {	if (log.isDebugEnabled()) {	StringBuffer sb = new StringBuffer();	try {	sb.append("Sending admin level FIX message to ").append(message.getHeader().getField(new TargetCompID()).getValue());	sb.append("\nMessage Type: ").append(message.getHeader().getField(new MsgType()).getValue());	sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nSender ID: ").append(message.getHeader().getField(new SenderCompID()).getValue());	} catch (FieldNotFound e) {	sb.append("Sending admin level FIX message...");	
one or more required fields are not found in the response message 

try {	sb.append("Sending admin level FIX message to ").append(message.getHeader().getField(new TargetCompID()).getValue());	sb.append("\nMessage Type: ").append(message.getHeader().getField(new MsgType()).getValue());	sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nSender ID: ").append(message.getHeader().getField(new SenderCompID()).getValue());	} catch (FieldNotFound e) {	sb.append("Sending admin level FIX message...");	}	log.debug(sb.toString());	if (log.isTraceEnabled()) {	
message 

public void fromAdmin(Message message, SessionID sessionID) throws FieldNotFound, IncorrectDataFormat, IncorrectTagValue, RejectLogon {	if (log.isDebugEnabled()) {	StringBuffer sb = new StringBuffer();	sb.append("Received admin level FIX message from ").append(message.getHeader().getField(new SenderCompID()).getValue());	sb.append("\nMessage Type: ").append(message.getHeader().getField(new MsgType()).getValue());	sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nReceiver ID: ").append(message.getHeader().getField(new TargetCompID()).getValue());	log.debug(sb.toString());	if (log.isTraceEnabled()) {	
message 

public void toApp(Message message, SessionID sessionID) throws DoNotSend {	if (log.isDebugEnabled()) {	StringBuffer sb = new StringBuffer();	try {	sb.append("Sending application level FIX message to ").append(message.getHeader().getField(new TargetCompID()).getValue());	sb.append("\nMessage Type: ").append(message.getHeader().getField(new MsgType()).getValue());	sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nSender ID: ").append(message.getHeader().getField(new SenderCompID()).getValue());	} catch (FieldNotFound e) {	sb.append("Sending application level FIX message...");	
one or more required fields are not found in the response message 

try {	sb.append("Sending application level FIX message to ").append(message.getHeader().getField(new TargetCompID()).getValue());	sb.append("\nMessage Type: ").append(message.getHeader().getField(new MsgType()).getValue());	sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nSender ID: ").append(message.getHeader().getField(new SenderCompID()).getValue());	} catch (FieldNotFound e) {	sb.append("Sending application level FIX message...");	}	log.debug(sb.toString());	if (log.isTraceEnabled()) {	
message 

public void fromApp(Message message, SessionID sessionID) throws FieldNotFound, IncorrectDataFormat, IncorrectTagValue, UnsupportedMessageType {	if (log.isDebugEnabled()) {	StringBuffer sb = new StringBuffer();	sb.append("Received FIX message from ").append(message.getHeader().getField(new SenderCompID()).getValue());	sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nReceiver ID: ").append(message.getHeader().getField(new TargetCompID()).getValue());	log.debug(sb.toString());	if (log.isTraceEnabled()) {	
message 

sb.append("\nMessage Sequence Number: ").append(message.getHeader().getField(new MsgSeqNum()).getValue());	sb.append("\nReceiver ID: ").append(message.getHeader().getField(new TargetCompID()).getValue());	log.debug(sb.toString());	if (log.isTraceEnabled()) {	}	}	AtomicInteger atomicCounter = countersMap.get(sessionID);	int counter = atomicCounter.incrementAndGet();	boolean rolled = atomicCounter.compareAndSet(FIXConstants.DEFAULT_COUNTER_UPPER_LIMIT, 0);	if (rolled && log.isDebugEnabled()) {	
incoming request counter rolled over for the session 

} else {	if (acceptor) {	handleIncomingRequest(message, sessionID, counter);	} else {	MessageContext outMsgCtx = outgoingMessages.poll();	if (outMsgCtx != null) {	handleIncomingResponse(outMsgCtx, message, sessionID, counter);	} else if (!dropExtraResponses) {	handleIncomingRequest(message, sessionID, counter);	} else {	
dropping additional fix response 

private void handleIncomingRequest(Message message, SessionID sessionID, int counter) {	if (log.isDebugEnabled()) {	
source session received message with sequence number 

========================= synapse sample_1071 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start loopback mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	if (!synCtx.isResponse()) {	synCtx.setResponse(true);	synCtx.setTo(null);	synCtx.getEnvironment().injectMessage(synCtx);	}	if (synLog.isTraceOrDebugEnabled()) {	
end loopback mediator 

========================= synapse sample_546 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	synLog.traceOrDebug("Start : Sequence " + (name == null ? (key == null ? "<anonymous" : "key=<" + key) : "<" + name) + ">");	if (synLog.isTraceTraceEnabled()) {	
message 

if (key == null) {	Mediator errorHandlerMediator = null;	try {	if (isStatisticsEnable()) {	StatisticsReporter.reportForComponent(synCtx, getAspectConfiguration(), ComponentType.SEQUENCE);	}	if (errorHandler != null) {	errorHandlerMediator = synCtx.getSequence(errorHandler);	if (errorHandlerMediator != null) {	if (synLog.isTraceOrDebugEnabled()) {	
setting the onerror handler for the sequence 

Stack faultStack = synCtx.getFaultStack();	if (faultStack != null && !faultStack.isEmpty()) {	Object o = faultStack.peek();	if (o instanceof MediatorFaultHandler && errorHandlerMediator.equals( ((MediatorFaultHandler) o).getFaultMediator())) {	faultStack.pop();	}	}	}	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

}	}	}	} else {	String sequenceKey = key.evaluateValue(synCtx);	Mediator m = synCtx.getSequence(sequenceKey);	if (m == null) {	handleException("Sequence named " + key + " cannot be found", synCtx);	} else {	if (synLog.isTraceOrDebugEnabled()) {	
executing with key 

========================= synapse sample_1972 =========================

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	
shutting down simpleaxisserver 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	stopServer();	
shutdown complete 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	stopServer();	
halting jvm 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	stopServer();	} catch (Exception e) {	
error occurred while shutting down simpleaxisserver 

========================= synapse sample_1266 =========================

}	ConfigurationContext cfgCtx = messageContext.getConfigurationContext();	Object property = cfgCtx.getProperty(NhttpConstants.EPR_TO_SERVICE_NAME_MAP);	if (property != null && property instanceof Map) {	Map eprToserviceNameMap = (Map) property;	if (eprToserviceNameMap.containsKey(toAddress)) {	return cfgCtx.getAxisConfiguration().getService( eprToserviceNameMap.get(toAddress).toString());	}	}	} else {	
unable to dispatch using the custom uri the to header has not been specified 

========================= synapse sample_1636 =========================

public void init(SynapseEnvironment synapseEnvironment) {	super.init(synapseEnvironment);	Template endpointTemplate = synapseEnvironment.getSynapseConfiguration(). getEndpointTemplate(template);	if (endpointTemplate == null) {	
template cannot be found for the endpoint 

if (entry != null && entry.isDynamic()) {	if (!entry.isCached() || entry.isExpired()) {	reLoad = true;	}	} else {	reLoad = false;	}	}	if (reLoad) {	if (log.isDebugEnabled()) {	
loading template endpoint with key 

reLoad = false;	}	}	if (reLoad) {	if (log.isDebugEnabled()) {	}	Template eprTemplate = synCfg.getEndpointTemplate(template);	if (eprTemplate != null) {	realEndpoint = eprTemplate.create(this, synCfg.getProperties());	} else {	
couldn t retrieve the endpoint template with the key 

public boolean readyToSend() {	if (realEndpoint != null && realEndpoint.readyToSend()) {	if (log.isDebugEnabled()) {	
template endpoint is at ready state 

public boolean readyToSend() {	if (realEndpoint != null && realEndpoint.readyToSend()) {	if (log.isDebugEnabled()) {	}	return true;	}	
template endpoint is not in a ready state to process message 

========================= synapse sample_244 =========================

public void testMessageEnrichment() {	String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test message enrichment through synapse 

========================= synapse sample_2276 =========================

public static Object getObject(URL url, Properties properties) {	try {	if (url != null && "file".equals(url.getProtocol())) {	try {	url.openStream();	} catch (IOException ignored) {	String path = url.getPath();	if (log.isDebugEnabled()) {	
can not open a connection to the url with a path 

if (url != null && "file".equals(url.getProtocol())) {	try {	url.openStream();	} catch (IOException ignored) {	String path = url.getPath();	if (log.isDebugEnabled()) {	}	String synapseHome = (String) properties.get(SynapseConstants.SYNAPSE_HOME);	if (synapseHome != null) {	if (log.isDebugEnabled()) {	
trying to resolve an absolute path of the url using the synapse home 

if (log.isDebugEnabled()) {	}	if (synapseHome.endsWith("/")) {	synapseHome = synapseHome.substring(0, synapseHome.lastIndexOf("/"));	}	url = new URL(url.getProtocol() + ":" + synapseHome + "/" + path);	try {	url.openStream();	} catch (IOException e) {	if (log.isDebugEnabled()) {	
failed to resolve an absolute path of the url using the synapse home 

}	if (synapseHome.endsWith("/")) {	synapseHome = synapseHome.substring(0, synapseHome.lastIndexOf("/"));	}	url = new URL(url.getProtocol() + ":" + synapseHome + "/" + path);	try {	url.openStream();	} catch (IOException e) {	if (log.isDebugEnabled()) {	}	
io error reading from url 

String encoding = new String(new Base64().encode(url.getUserInfo().getBytes()));	connection.setRequestProperty("Authorization", "Basic " + encoding);	} else {	handleException("Unsupported protocol [" + protocol + "]. Supports only http " + "and https with basic authentication.");	}	} else {	connection = getURLConnection(url);	}	if (connection == null) {	if (log.isDebugEnabled()) {	
cannot create a urlconnection for given url 

OMXMLParserWrapper builder = OMXMLBuilderFactory.createStAXOMBuilder(parser);	OMElement omElem = builder.getDocumentElement();	omElem.build();	if (xmlToObject != null) {	return xmlToObject.getObjectFromOMNode(omElem, properties);	} else {	return omElem;	}	} catch (XMLStreamException e) {	if (log.isDebugEnabled()) {	
content at url is non xml 

return xmlToObject.getObjectFromOMNode(omElem, properties);	} else {	return omElem;	}	} catch (XMLStreamException e) {	if (log.isDebugEnabled()) {	}	return readNonXML(url);	} catch (OMException e) {	if (log.isDebugEnabled()) {	
content at url is non xml 

public static OMNode readNonXML(URL url) {	try {	URLConnection newConnection = getURLConnection(url);	if (newConnection == null) {	if (log.isDebugEnabled()) {	
cannot create a urlconnection for given url 

public static OMNode getOMElementFromURL(String urlStr, String synapseHome) throws IOException {	URL url = getURLFromPath(urlStr, synapseHome);	if (url == null) {	return null;	}	URLConnection connection = getURLConnection(url);	if (connection == null) {	if (log.isDebugEnabled()) {	
cannot create a urlconnection for given url 

return null;	}	InputStream inStream = connection.getInputStream();	try {	OMXMLParserWrapper builder = OMXMLBuilderFactory.createOMBuilder(inStream);	OMElement doc = builder.getDocumentElement();	doc.build();	return doc;	} catch (Exception e) {	if (log.isDebugEnabled()) {	
content at url is non xml 

doc.build();	return doc;	} catch (Exception e) {	if (log.isDebugEnabled()) {	}	return readNonXML(url);	} finally {	try {	inStream.close();	} catch (IOException e) {	
error while closing the input stream to 

public static InputSource getInputSourceFormURI(URI uri) {	if (uri == null) {	if (log.isDebugEnabled()) {	
can not create a url from null 

try {	URL url = uri.toURL();	String protocol = url.getProtocol();	String path = url.getPath();	if (protocol == null || "".equals(protocol)) {	url = new URL("file:" + path);	}	URLConnection connection = getURLConnection(url);	if (connection == null) {	if (log.isDebugEnabled()) {	
cannot create a urlconnection for given url 

private static HttpsURLConnection getHttpsURLConnection( URL url, Properties synapseProperties, Proxy proxy) {	if (log.isDebugEnabled()) {	
creating a httpsurl connection from given url 

KeyManager[] keyManagers = null;	TrustManager[] trustManagers = null;	IdentityKeyStoreInformation identityInformation = KeyStoreInformationFactory.createIdentityKeyStoreInformation(synapseProperties);	if (identityInformation != null) {	KeyManagerFactory keyManagerFactory = identityInformation.getIdentityKeyManagerFactoryInstance();	if (keyManagerFactory != null) {	keyManagers = keyManagerFactory.getKeyManagers();	}	} else {	if (log.isDebugEnabled()) {	
there is no private key entry store configuration will use jdk s default one 

}	}	TrustKeyStoreInformation trustInformation = KeyStoreInformationFactory.createTrustKeyStoreInformation(synapseProperties);	if (trustInformation != null) {	TrustManagerFactory trustManagerFactory = trustInformation.getTrustManagerFactoryInstance();	if (trustManagerFactory != null) {	trustManagers = trustManagerFactory.getTrustManagers();	}	} else {	if (log.isDebugEnabled()) {	
there is no trusted certificate store configuration will use jdk s default one 

sslContext.init(keyManagers, trustManagers, null);	connection.setSSLSocketFactory(sslContext.getSocketFactory());	if (trustInformation != null) {	boolean enableHostnameVerifier = true;	String value = trustInformation.getParameter( KeyStoreInformation.ENABLE_HOST_NAME_VERIFIER);	if (value != null) {	enableHostnameVerifier = Boolean.parseBoolean(value);	}	if (!enableHostnameVerifier) {	if (log.isDebugEnabled()) {	
overriding default hostname verifier hostname verification disabled 

String value = trustInformation.getParameter( KeyStoreInformation.ENABLE_HOST_NAME_VERIFIER);	if (value != null) {	enableHostnameVerifier = Boolean.parseBoolean(value);	}	if (!enableHostnameVerifier) {	if (log.isDebugEnabled()) {	}	connection.setHostnameVerifier(new javax.net.ssl.HostnameVerifier() {	public boolean verify(String hostname, javax.net.ssl.SSLSession session) {	if (log.isTraceEnabled()) {	
hostname verification disabled 

String value = trustInformation.getParameter( KeyStoreInformation.ENABLE_HOST_NAME_VERIFIER);	if (value != null) {	enableHostnameVerifier = Boolean.parseBoolean(value);	}	if (!enableHostnameVerifier) {	if (log.isDebugEnabled()) {	}	connection.setHostnameVerifier(new javax.net.ssl.HostnameVerifier() {	public boolean verify(String hostname, javax.net.ssl.SSLSession session) {	if (log.isTraceEnabled()) {	
host 

String value = trustInformation.getParameter( KeyStoreInformation.ENABLE_HOST_NAME_VERIFIER);	if (value != null) {	enableHostnameVerifier = Boolean.parseBoolean(value);	}	if (!enableHostnameVerifier) {	if (log.isDebugEnabled()) {	}	connection.setHostnameVerifier(new javax.net.ssl.HostnameVerifier() {	public boolean verify(String hostname, javax.net.ssl.SSLSession session) {	if (log.isTraceEnabled()) {	
peer host 

}	connection.setHostnameVerifier(new javax.net.ssl.HostnameVerifier() {	public boolean verify(String hostname, javax.net.ssl.SSLSession session) {	if (log.isTraceEnabled()) {	}	return true;	}	});	} else {	if (log.isDebugEnabled()) {	
using default hostname verifier 

public static URLConnection getURLConnection(URL url) {	try {	if (url == null) {	if (log.isDebugEnabled()) {	
provided url is null 

public static URL getURLFromPath(String path, String synapseHome) {	if (path == null || "null".equals(path)) {	if (log.isDebugEnabled()) {	
can not create a url from null 

URL url = null;	try {	url = new URL(path);	if ("file".equals(url.getProtocol())) {	try {	url.openStream();	} catch (MalformedURLException e) {	handleException("Invalid URL reference : " + path, e);	} catch (IOException ignored) {	if (log.isDebugEnabled()) {	
can not open a connection to the url with a path 

} catch (MalformedURLException e) {	handleException("Invalid URL reference : " + path, e);	} catch (IOException ignored) {	if (log.isDebugEnabled()) {	}	if (synapseHome != null) {	if (synapseHome.endsWith("/")) {	synapseHome = synapseHome.substring(0, synapseHome.lastIndexOf("/"));	}	if (log.isDebugEnabled()) {	
trying to resolve an absolute path of the url using the synapse home 

}	if (log.isDebugEnabled()) {	}	try {	url = new URL(url.getProtocol() + ":" + synapseHome + "/" + url.getPath());	url.openStream();	} catch (MalformedURLException e) {	handleException("Invalid URL reference " + url.getPath() + e);	} catch (IOException e) {	if (log.isDebugEnabled()) {	
failed to resolve an absolute path of the url using the synapse home 

if (log.isDebugEnabled()) {	}	try {	url = new URL(url.getProtocol() + ":" + synapseHome + "/" + url.getPath());	url.openStream();	} catch (MalformedURLException e) {	handleException("Invalid URL reference " + url.getPath() + e);	} catch (IOException e) {	if (log.isDebugEnabled()) {	}	
io error reading from url 

public static String resolveRelativeURI(String parentLocation, String relativeLocation) {	if (relativeLocation == null) {	throw new IllegalArgumentException("Import URI cannot be null");	}	if (log.isDebugEnabled()) {	
resolving import uri against base uri 

========================= synapse sample_1909 =========================

public void deploy(DeploymentFileData deploymentFileData) throws DeploymentException {	
loading extensions from 

boolean isDirectory = deploymentFileData.getFile().isDirectory();	deploymentFileData.setClassLoader(isDirectory, getClass().getClassLoader(), (File) cfgCtx.getAxisConfiguration().getParameterValue( Constants.Configuration.ARTIFACTS_TEMP_DIR), cfgCtx.getAxisConfiguration().isChildFirstClassLoading());	DeploymentClassLoader urlCl = (DeploymentClassLoader)deploymentFileData.getClassLoader();	Thread.currentThread().setContextClassLoader(urlCl);	for (StartupFactory factory : getProviders(StartupFactory.class, urlCl)) {	QName tagQName = factory.getTagQName();	Class<? extends StartupFactory> clazz = factory.getClass();	StartupFinder finder = StartupFinder.getInstance();	finder.getFactoryMap().put(tagQName, clazz);	finder.getSerializerMap().put(tagQName, factory.getSerializerClass());	
registered startup factory and serializer for 

QName tagQName = factory.getTagQName();	Class<? extends StartupFactory> clazz = factory.getClass();	StartupFinder finder = StartupFinder.getInstance();	finder.getFactoryMap().put(tagQName, clazz);	finder.getSerializerMap().put(tagQName, factory.getSerializerClass());	}	for (MediatorFactory factory : getProviders(MediatorFactory.class, urlCl)) {	QName tagQName = factory.getTagQName();	Class<? extends MediatorFactory> clazz = factory.getClass();	MediatorFactoryFinder.getInstance().getFactoryMap().put(tagQName, clazz);	
registered mediator factory for 

finder.getSerializerMap().put(tagQName, factory.getSerializerClass());	}	for (MediatorFactory factory : getProviders(MediatorFactory.class, urlCl)) {	QName tagQName = factory.getTagQName();	Class<? extends MediatorFactory> clazz = factory.getClass();	MediatorFactoryFinder.getInstance().getFactoryMap().put(tagQName, clazz);	}	for (MediatorSerializer serializer : getProviders(MediatorSerializer.class, urlCl)) {	String mediatorClassName = serializer.getMediatorClassName();	MediatorSerializerFinder.getInstance().getSerializerMap().put( mediatorClassName, serializer);	
registered mediator serializer for 

MediatorSerializerFinder.getInstance().getSerializerMap().put( mediatorClassName, serializer);	}	} catch (IOException e) {	handleException("I/O error in reading the mediator jar file", e);	} catch (Exception e) {	handleException("Error occurred while trying to deploy mediator jar file", e);	} catch (Throwable t) {	handleException("Error occurred while trying to deploy the mediator jar file", t);	} finally {	if (log.isDebugEnabled()) {	
restoring the context class loader to the original 

private <T> List<T> getProviders(Class<T> providerClass, URLClassLoader loader) throws IOException {	List<T> providers = new LinkedList<T>();	String providerClassName = providerClass.getName();	providerClassName = providerClassName.substring(providerClassName.indexOf('.')+1);	URL servicesURL = loader.findResource("META-INF/services/" + providerClass.getName());	if (servicesURL != null) {	BufferedReader in = new BufferedReader(new InputStreamReader(servicesURL.openStream()));	try {	String className;	while ((className = in.readLine()) != null && (!className.trim().equals(""))) {	
loading the implementation 

========================= synapse sample_182 =========================

protected void send(byte[] message) throws Exception {	File tmpFile = new File(requestFile.getParent(), "." + requestFile.getName() + ".tmp");	
writing message to temporary file 

protected void send(byte[] message) throws Exception {	File tmpFile = new File(requestFile.getParent(), "." + requestFile.getName() + ".tmp");	OutputStream out = new FileOutputStream(tmpFile);	out.write(message);	out.close();	
moving to 

protected void send(byte[] message) throws Exception {	File tmpFile = new File(requestFile.getParent(), "." + requestFile.getName() + ".tmp");	OutputStream out = new FileOutputStream(tmpFile);	out.write(message);	out.close();	if (!tmpFile.renameTo(requestFile)) {	throw new IOException("Unable to rename " + tmpFile + " to " + requestFile);	}	
done 

========================= synapse sample_881 =========================

public void start() throws TransportException {	initIOHandler();	registry = new SimpleServiceRegistry();	try {	Service service = new Service(SERVICE_NAME, TransportType.SOCKET, port);	registry.bind(service, httpIOHandler);	SocketAcceptor acceptor = (SocketAcceptor) registry.getIoAcceptor(TransportType.SOCKET);	configureFilters(acceptor);	acceptor.setExceptionMonitor(new LoggingExceptionMonitor());	
nio http transport bound on port 

private void configureFilters(SocketAcceptor acceptor) {	
configuring io workers 

private void configureFilters(SocketAcceptor acceptor) {	IoThreadPoolFilter threadPoolFilter = (IoThreadPoolFilter) acceptor.getFilterChain().getChild("threadPool");	threadPoolFilter.setMaximumPoolSize(ioWorkerCount);	if (isLoggingTraffic) {	
configuring traffic logging filter 

private void initIOHandler() {	if (httpIOHandler == null) {	
no http io handler associated using defaults 

public void exceptionCaught(Object source, Throwable e) {	if (LOG.isWarnEnabled()) {	
niotransport encountered exception on source 

========================= synapse sample_3172 =========================

public synchronized void completeAggregate(Aggregate aggregate) {	if (log.isDebugEnabled()) {	
aggregation completed or timed out 

public synchronized void completeAggregate(Aggregate aggregate) {	if (log.isDebugEnabled()) {	}	aggregate.cancel();	aggregate.setCompleted(true);	MessageContext newSynCtx = getAggregatedMessage(aggregate);	if (newSynCtx == null) {	
an aggregation of messages timed out with no aggregated messages 

private MessageContext getAggregatedMessage(Aggregate aggregate) {	MessageContext newCtx = null;	for (MessageContext synCtx : aggregate.getMessages()) {	if (newCtx == null) {	newCtx = synCtx;	if (log.isDebugEnabled()) {	
generating aggregated message from 

private MessageContext getAggregatedMessage(Aggregate aggregate) {	MessageContext newCtx = null;	for (MessageContext synCtx : aggregate.getMessages()) {	if (newCtx == null) {	newCtx = synCtx;	if (log.isDebugEnabled()) {	}	} else {	try {	if (log.isDebugEnabled()) {	
merging message using xpath 

if (newCtx == null) {	newCtx = synCtx;	if (log.isDebugEnabled()) {	}	} else {	try {	if (log.isDebugEnabled()) {	}	EIPUtils.enrichEnvelope( newCtx.getEnvelope(), synCtx.getEnvelope(), aggregationExpression);	if (log.isDebugEnabled()) {	
merged result 

========================= synapse sample_4199 =========================

public static DataSourceInformation createDataSourceInformation(String dsName, Properties properties) {	if (dsName == null || "".equals(dsName)) {	if (log.isDebugEnabled()) {	
datasource name is either empty or null ignoring 

========================= synapse sample_706 =========================

}	if (!configurable.isStatisticsEnable()) {	return;	}	StatisticsRecord record = null;	if(synCtx.getProperty(SynapseConstants.STATISTICS_STACK) instanceof StatisticsRecord){	record =  (StatisticsRecord) synCtx.getProperty(SynapseConstants.STATISTICS_STACK);	}	if (record == null) {	if (log.isDebugEnabled()) {	
setting a statistics stack on the message context 

public static void reportForAllOnResponseReceived(MessageContext synCtx) {	synCtx.setProperty(SynapseConstants.SENDING_REQUEST, false);	StatisticsRecord statisticsRecord = null;	if (synCtx.getProperty(SynapseConstants.STATISTICS_STACK) instanceof StatisticsRecord) {	statisticsRecord = (StatisticsRecord) synCtx.getProperty( SynapseConstants.STATISTICS_STACK);	}	if (statisticsRecord != null) {	if (log.isDebugEnabled()) {	
reporting a statistics on a response is received 

private static void endReportForAll(MessageContext synCtx) {	StatisticsRecord record = null;	if(synCtx.getProperty(SynapseConstants.STATISTICS_STACK) instanceof StatisticsRecord){	record =  (StatisticsRecord) synCtx.getProperty(SynapseConstants.STATISTICS_STACK);	}	if (record == null) {	return;	}	if (record.isEndReported()) {	if (log.isDebugEnabled()) {	
the statistics record has been already reported 

if (isFault(synCtx)) {	statisticsLog.setFault(true);	statisticsLog.setErrorLog(ErrorLogFactory.createErrorLog(synCtx));	}	statisticsLog.setEndAnyLog(true);	record.collect(statisticsLog);	record.setEndReported(true);	StatisticsCollector collector = synCtx.getEnvironment().getStatisticsCollector();	if (collector == null) {	if (log.isDebugEnabled()) {	
setting statistics collector in the synapse environment 

private static boolean isValid(Identifiable identifiable) {	if (identifiable == null) {	if (log.isDebugEnabled()) {	
invalid aspects configuration it is null 

private static boolean isValid(Identifiable identifiable) {	if (identifiable == null) {	if (log.isDebugEnabled()) {	}	return false;	}	String auditID = identifiable.getId();	if (auditID == null || "".equals(auditID)) {	if (log.isDebugEnabled()) {	
invalid aspects configuration audit name is null 

========================= synapse sample_643 =========================

public InputSource resolve(SynapseConfiguration synCfg, String location) {	String key = resources.get(location);	if (key == null) {	if (log.isDebugEnabled()) {	
no resource mapping is defined for location 

public InputSource resolve(SynapseConfiguration synCfg, String location) {	String key = resources.get(location);	if (key == null) {	if (log.isDebugEnabled()) {	}	return null;	} else {	if (log.isDebugEnabled()) {	
resolving location to registry item 

========================= synapse sample_1724 =========================

public boolean matches(String value) {	if (isDefaultCase()) {	
this is the default case of the switch 

public boolean matches(String value) {	if (isDefaultCase()) {	return true;	}	boolean retVal = regex.matcher(value).matches();	
case evaluated to 

========================= synapse sample_3060 =========================

public void init(Properties properties, String id) {	StringBuffer sb = new StringBuffer();	sb.append(id);	sb.append(DOT);	sb.append(LOCATION);	String filePath = MiscellaneousUtil.getProperty(properties, sb.toString(), DEFAULT_CONF_LOCATION);	Properties cipherProperties = MiscellaneousUtil.loadProperties(filePath);	if (cipherProperties == null) {	if (log.isDebugEnabled()) {	
cipher texts cannot be loaded form 

CipherInformation cipherInformation = new CipherInformation();	cipherInformation.setAlgorithm(algorithm);	cipherInformation.setCipherOperationMode(CipherOperationMode.DECRYPT);	cipherInformation.setInType(EncodingType.BASE64);	DecryptionProvider baseCipher = CipherFactory.createCipher(cipherInformation, keyStoreWrapper);	for (Object alias : cipherProperties.keySet()) {	String key = String.valueOf(alias);	String encryptedText = cipherProperties.getProperty(key);	if (encryptedText == null || "".equals(encryptedText.trim())) {	if (log.isDebugEnabled()) {	
there is no secret for the alias 

public String getSecret(String alias) {	if (alias == null || "".equals(alias)) {	return alias;	}	if (!initialize || secrets.isEmpty()) {	if (log.isDebugEnabled()) {	
there is no secret found for alias returning itself 

}	return alias;	}	StringBuffer sb = new StringBuffer();	sb.append(alias);	sb.append(DOT);	sb.append(SECRET);	String secret = secrets.get(sb.toString());	if (secret == null || "".equals(secret)) {	if (log.isDebugEnabled()) {	
there is no secret found for alias returning itself 

========================= synapse sample_1118 =========================

if (keyParam != null) {	OMElement ksEle      = keyParam.getParameterElement().getFirstElement();	String location      = ksEle.getFirstChildWithName(new QName("Location")).getText();	String type          = ksEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = ksEle.getFirstChildWithName(new QName("Password")).getText();	String keyPassword   = ksEle.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading identity keystore from 

String keyPassword   = ksEle.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

}	if (trustParam != null) {	OMElement tsEle      = trustParam.getParameterElement().getFirstElement();	String location      = tsEle.getFirstChildWithName(new QName("Location")).getText();	String type          = tsEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = tsEle.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading trust keystore from 

String storePassword = tsEle.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

fis.close();	} catch (IOException ignore) {}	}	}	}	try {	SSLContext sslcontext = SSLContext.getInstance("TLS");	sslcontext.init(keymanagers, trustManagers, null);	return sslcontext;	} catch (GeneralSecurityException gse) {	
unable to create ssl context with the given configuration 

========================= synapse sample_2364 =========================

public void clear() {	if (!dataSourcesMBeans.isEmpty()) {	
unregistering dbpool mbeans 

========================= synapse sample_710 =========================

public static OMElement getXMLPayload(SOAPEnvelope envelope) {	SOAPBody body = envelope.getBody();	if (body == null) {	
no body found 

public static OMElement getXMLPayload(SOAPEnvelope envelope) {	SOAPBody body = envelope.getBody();	if (body == null) {	return null;	}	OMElement bodyEl = body.getFirstElement();	if (bodyEl == null) {	
no body child found 

public static DataHandler getBinaryPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(BINARYELT)) {	
wrong qname 

public static DataHandler getBinaryPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(BINARYELT)) {	return null;	}	OMNode textNode = el.getFirstOMChild();	if (textNode.getType() != OMNode.TEXT_NODE) {	
text node not found 

return null;	}	OMNode textNode = el.getFirstOMChild();	if (textNode.getType() != OMNode.TEXT_NODE) {	return null;	}	OMText text = (OMText) textNode;	try {	return (DataHandler) text.getDataHandler();	} catch (ClassCastException ce) {	
cannot get datahandler 

public static DataHandler getBinaryPayload(MessageContext mc) {	if (mc.getEnvelope() == null) {	
null envelope 

public static String getTextPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(TEXTELT)) {	
wrong qname 

public static String getTextPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(TEXTELT)) {	return null;	}	OMNode textNode = el.getFirstOMChild();	if (textNode.getType() != OMNode.TEXT_NODE) {	
text node not found 

public static String getTextPayload(MessageContext mc) {	if (mc.getEnvelope() == null) {	
null envelope 

public static SimpleMap getMapPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(MAPELT)) {	
wrong qname 

public static SimpleMap getMapPayload(MessageContext mc) {	if (mc.getEnvelope() == null) {	
null envelope 

public static void setMapPayload(SOAPEnvelope envelope, SimpleMap map) {	if (map instanceof SimpleMapImpl) {	SimpleMapImpl impl = (SimpleMapImpl) map;	OMElement mapElt = impl.getOMElement(envelope.getOMFactory());	if (mapElt == null) {	
null map element returned 

public static XMLStreamReader getStAXPayload(MessageContext mc) {	if (mc.getEnvelope() == null) {	
null envelope 

========================= synapse sample_1698 =========================

public static Object getObject(URL url) {	try {	if (url != null && "file".equals(url.getProtocol())) {	try {	url.openStream();	} catch (IOException ignored) {	String path = url.getPath();	if (log.isDebugEnabled()) {	
can not open a connection to the url with a path 

if (url != null && "file".equals(url.getProtocol())) {	try {	url.openStream();	} catch (IOException ignored) {	String path = url.getPath();	if (log.isDebugEnabled()) {	}	String synapseHome = ServerManager.getInstance().getSynapseHome();	if (synapseHome != null) {	if (log.isDebugEnabled()) {	
trying to resolve an absolute path of the url using the synapse home 

if (log.isDebugEnabled()) {	}	if (synapseHome.endsWith("/")) {	synapseHome = synapseHome.substring(0, synapseHome.lastIndexOf("/"));	}	url = new URL(url.getProtocol() + ":" + synapseHome + "/" + path);	try {	url.openStream();	} catch (IOException e) {	if (log.isDebugEnabled()) {	
faild to resolve an absolute path of the url using the synapse home 

}	if (synapseHome.endsWith("/")) {	synapseHome = synapseHome.substring(0, synapseHome.lastIndexOf("/"));	}	url = new URL(url.getProtocol() + ":" + synapseHome + "/" + path);	try {	url.openStream();	} catch (IOException e) {	if (log.isDebugEnabled()) {	}	
io error reading from url 

StAXOMBuilder builder = new StAXOMBuilder(parser);	OMElement omElem = builder.getDocumentElement();	omElem.build();	if (xmlToObject != null) {	return xmlToObject.getObjectFromOMNode(omElem);	} else {	return omElem;	}	} catch (XMLStreamException e) {	if (log.isDebugEnabled()) {	
content at url is non xml 

return xmlToObject.getObjectFromOMNode(omElem);	} else {	return omElem;	}	} catch (XMLStreamException e) {	if (log.isDebugEnabled()) {	}	return readNonXML(url);	} catch (OMException e) {	if (log.isDebugEnabled()) {	
content at url is non xml 

conn.setConnectTimeout(getConnectionTimeout());	conn.setRequestProperty("Connection", "close");	BufferedInputStream urlInStream = new BufferedInputStream( conn.getInputStream());	try {	StAXOMBuilder builder = new StAXOMBuilder(urlInStream);	OMElement doc = builder.getDocumentElement();	doc.build();	return doc;	} catch (Exception e) {	if (log.isDebugEnabled()) {	
content at url is non xml 

public static InputSource getInputSourceFormURI(URI uri) {	if (uri == null) {	if (log.isDebugEnabled()) {	
can not create a url from null 

public static URL getURLFromPath(String path) {	if (path == null || "null".equals(path)) {	if (log.isDebugEnabled()) {	
can not create a url from null 

URL url = null;	try {	url = new URL(path);	if ("file".equals(url.getProtocol())) {	try {	url.openStream();	} catch (MalformedURLException e) {	handleException("Invalid URL reference : " + path, e);	} catch (IOException ignored) {	if (log.isDebugEnabled()) {	
can not open a connection to the url with a path 

handleException("Invalid URL reference : " + path, e);	} catch (IOException ignored) {	if (log.isDebugEnabled()) {	}	String synapseHome = ServerManager.getInstance().getSynapseHome();	if (synapseHome != null) {	if (synapseHome.endsWith("/")) {	synapseHome = synapseHome.substring(0, synapseHome.lastIndexOf("/"));	}	if (log.isDebugEnabled()) {	
trying to resolve an absolute path of the url using the synapse home 

}	if (log.isDebugEnabled()) {	}	try {	url = new URL(url.getProtocol() + ":" + synapseHome + "/" + url.getPath());	url.openStream();	} catch (MalformedURLException e) {	handleException("Invalid URL reference " + url.getPath() + e);	} catch (IOException e) {	if (log.isDebugEnabled()) {	
faild to resolve an absolute path of the url using the synapse home 

if (log.isDebugEnabled()) {	}	try {	url = new URL(url.getProtocol() + ":" + synapseHome + "/" + url.getPath());	url.openStream();	} catch (MalformedURLException e) {	handleException("Invalid URL reference " + url.getPath() + e);	} catch (IOException e) {	if (log.isDebugEnabled()) {	}	
io error reading from url 

public static String resolveRelativeURI(String parentLocation, String relativeLocation) {	if (relativeLocation == null) {	throw new IllegalArgumentException("Import URI cannot be null");	}	if (log.isDebugEnabled()) {	
resolving import uri against base uri 

========================= synapse sample_4160 =========================

public boolean process(SynapseEnvironment se, SynapseMessage smc) {	if (xp == null) {	
trying to process xpath without being set 

public boolean process(SynapseEnvironment se, SynapseMessage smc) {	if (xp == null) {	return true;	}	try {	if (xp.booleanValueOf(smc.getEnvelope())) {	
matched xpath 

========================= synapse sample_1362 =========================

OMElement expiryElem = elem.getFirstChildWithName(EXPIRES);	if (expiryElem != null) {	Calendar calendarExpires = null;	try {	if (expiryElem.getText().startsWith("P")) {	calendarExpires = ConverterUtil.convertToDuration(expiryElem.getText()) .getAsCalendar();	} else {	calendarExpires = ConverterUtil.convertToDateTime(expiryElem.getText());	}	} catch (Exception e) {	
error converting the expiration date 

private static boolean isValidDate(String original, Calendar converted) {	try {	String check = ConverterUtil.convertToString(converted);	if (original.equals(check)) {	return true;	} else {	return false;	}	} catch (Exception e) {	
converting the date to string 

========================= synapse sample_655 =========================

public boolean mediate(MessageContext synCtx) {	
drop mediator mediate 

========================= synapse sample_3076 =========================

public void testDbLookup() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to dblookup mediator 

public void testDbLookup() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	result = client.requestStandardQuote(addUrl, trpUrl, null, "IBM" ,null);	assertTrue("Client did not get run successfully ", result.responseReceived());	
running test introduction to the dblookup mediator 

========================= synapse sample_2237 =========================

protected void processStatement(Statement stmnt, MessageContext msgCtx) {	SynapseLog synLog = getLog(msgCtx);	Connection con = null;	try {	con = this.getDataSource().getConnection();	PreparedStatement ps = getPreparedStatement(stmnt, con, msgCtx);	con = ps.getConnection();	int count = ps.executeUpdate();	if (count > 0) {	if (synLog.isTraceOrDebugEnabled()) {	
inserted row s using statement 

try {	con = this.getDataSource().getConnection();	PreparedStatement ps = getPreparedStatement(stmnt, con, msgCtx);	con = ps.getConnection();	int count = ps.executeUpdate();	if (count > 0) {	if (synLog.isTraceOrDebugEnabled()) {	}	} else {	if (synLog.isTraceOrDebugEnabled()) {	
no rows were inserted for statement 

========================= synapse sample_1948 =========================

public NHttpClientConnection getConnection(String host, int port) {	if (log.isDebugEnabled()) {	
trying to get a connection to the 

public NHttpClientConnection getConnection(String host, int port) {	if (log.isDebugEnabled()) {	}	HostConnections pool = getConnectionPool(host, port);	NHttpClientConnection connection = pool.getConnection();	if (connection == null) {	if (pool.canHaveMoreConnections()) {	ioReactor.connect(new InetSocketAddress(host, port), null, pool, callback);	} else {	
connection pool reached maximum allowed connections for target server may have become slow 

public NHttpClientConnection getExistingConnection(String host, int port) {	if (log.isDebugEnabled()) {	
trying to get an existing connection to the 

public void closeConnection(NHttpClientConnection conn) {	HostConnections pool = (HostConnections) conn.getContext().getAttribute( PassThroughConstants.CONNECTION_POOL);	TargetContext.get(conn).reset();	if (pool != null) {	pool.forget(conn);	} else {	
connection without a pool something wrong need to fix 

public void shutdownConnection(NHttpClientConnection conn) {	HostConnections pool = (HostConnections) conn.getContext().getAttribute( PassThroughConstants.CONNECTION_POOL);	TargetContext.get(conn).reset();	if (pool != null) {	pool.forget(conn);	} else {	
connection without a pool something wrong need to fix 

public void releaseConnection(NHttpClientConnection conn) {	HostConnections pool = (HostConnections) conn.getContext().getAttribute( PassThroughConstants.CONNECTION_POOL);	TargetContext.get(conn).reset();	if (pool != null) {	pool.release(conn);	} else {	
connection without a pool something wrong need to fix 

public void addConnection(NHttpClientConnection conn) {	HostConnections pool = (HostConnections) conn.getContext().getAttribute( PassThroughConstants.CONNECTION_POOL);	if (pool != null) {	pool.addConnection(conn);	} else {	
connection without a pool something wrong need to fix 

========================= synapse sample_2372 =========================

public KeyManagerFactory getIdentityKeyManagerFactoryInstance() {	try {	if (log.isDebugEnabled()) {	
creating a identitykeymanagerfactory instance 

========================= synapse sample_2519 =========================

public void closed(final NHttpClientConnection conn) {	
connection closed 

public void timeout(final NHttpClientConnection conn) {	if (log.isDebugEnabled()) {	
connection timeout 

public void exception(final NHttpClientConnection conn, final HttpException e) {	
http protocol violation 

public void exception(final NHttpClientConnection conn, final IOException e) {	
i o error 

public void responseReceived(final NHttpClientConnection conn) {	HttpContext context = conn.getContext();	HttpResponse response = conn.getHttpResponse();	switch (response.getStatusLine().getStatusCode()) {	case HttpStatus.SC_ACCEPTED : {	if (log.isDebugEnabled()) {	
received a accepted response 

responseMsgCtx.setTo(null);	if (!outMsgCtx.isDoingREST() && !outMsgCtx.isSOAP11()) {	responseMsgCtx.setEnvelope(new SOAP12Factory().getDefaultEnvelope());	} else {	responseMsgCtx.setEnvelope(new SOAP11Factory().getDefaultEnvelope());	}	responseMsgCtx.setProperty(AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES, Boolean.TRUE);	responseMsgCtx.setProperty(NhttpConstants.SC_ACCEPTED, Boolean.TRUE);	mr.receive(responseMsgCtx);	} catch (org.apache.axis2.AxisFault af) {	
unable to report back accepted state to the message receiver 

mr.receive(responseMsgCtx);	} catch (org.apache.axis2.AxisFault af) {	}	return;	}	case HttpStatus.SC_INTERNAL_SERVER_ERROR : {	Header contentType = response.getFirstHeader(CONTENT_TYPE);	if (contentType != null) {	if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf(SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	
received an internal server error with a soap payload 

return;	}	case HttpStatus.SC_INTERNAL_SERVER_ERROR : {	Header contentType = response.getFirstHeader(CONTENT_TYPE);	if (contentType != null) {	if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf(SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	}	} else {	if (log.isDebugEnabled()) {	
received an internal server error with a pox rest payload 

if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf(SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	}	} else {	if (log.isDebugEnabled()) {	}	}	processResponse(conn, context, response);	return;	}	
received an internal server error 

processResponse(conn, context, response);	return;	}	return;	}	case HttpStatus.SC_OK : {	processResponse(conn, context, response);	return;	}	default : {	
unexpected http status code received 

}	case HttpStatus.SC_OK : {	processResponse(conn, context, response);	return;	}	default : {	Header contentType = response.getFirstHeader(CONTENT_TYPE);	if (contentType != null) {	if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf(SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	
received an unexpected response with a soap payload 

return;	}	default : {	Header contentType = response.getFirstHeader(CONTENT_TYPE);	if (contentType != null) {	if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf(SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	}	} else if (contentType.getValue().indexOf("html") == -1) {	if (log.isDebugEnabled()) {	
received an unexpected response with a pox rest payload 

default : {	Header contentType = response.getFirstHeader(CONTENT_TYPE);	if (contentType != null) {	if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf(SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	}	} else if (contentType.getValue().indexOf("html") == -1) {	if (log.isDebugEnabled()) {	}	} else {	
received an unexpected response of content type and status code with reason 

if (contentType != null) {	if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf(SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	}	} else if (contentType.getValue().indexOf("html") == -1) {	if (log.isDebugEnabled()) {	}	} else {	}	} else {	
received an unexpected response of unknown content type with status code and reason 

========================= synapse sample_3758 =========================

private void registerExtensions() {	Iterator it = Service.providers(MediatorFactory.class);	while (it.hasNext()) {	MediatorFactory mf = (MediatorFactory) it.next();	QName tag = mf.getTagQName();	factoryMap.put(tag, mf.getClass());	
added mediatorfactory to handle 

public Mediator getMediator(OMElement element) {	String localName = element.getLocalName();	QName qName = null;	if (element.getNamespace() != null) {	qName = new QName(element.getNamespace().getName(), localName);	} else {	qName = new QName(localName);	}	
getmediator 

QName qName = null;	if (element.getNamespace() != null) {	qName = new QName(element.getNamespace().getName(), localName);	} else {	qName = new QName(localName);	}	Class cls = (Class) factoryMap.get(qName);	if (cls == null && localName.indexOf('.') > -1) {	String newLocalName = localName.substring(0, localName.indexOf('.'));	qName = new QName(element.getNamespace().getName(), newLocalName);	
getmediator 

========================= synapse sample_3021 =========================

public void destroy() {	try {	Object o = getServletConfig().getServletContext().getAttribute(SYNAPSE_SERVER_MANAGER);	if (o != null && o instanceof ServerManager) {	ServerManager serverManager = (ServerManager) o;	serverManager.stop();	serverManager.shutdown();	getServletContext().removeAttribute(ALREADY_INITED);	}	} catch (Exception e) {	
error stopping the synapse listener manager 

========================= synapse sample_194 =========================

public Object call(Context context, List args) throws FunctionCallException {	boolean debugOn = log.isDebugEnabled();	if (args == null || args.size() == 0) {	if (debugOn) {	
property key value for lookup is not specified 

}	int size = args.size();	if (size == 1) {	String value = StringFunction.evaluate(args.get(0), context.getNavigator());	return encode(debugOn, SynapseXPathConstants.DEFAULT_CHARSET, value);	} else if (size == 2) {	String value = StringFunction.evaluate(args.get(0), context.getNavigator());	String encoding = StringFunction.evaluate(args.get(1), context.getNavigator());	return encode(debugOn, encoding, value);	} else if (debugOn) {	
url encode function expects only one argument returning empty string 

private Object encode(boolean debugOn, String encoding, String value) throws FunctionCallException {	if (value == null || "".equals(value)) {	if (debugOn) {	
non empty string value should be provided for encoding 

}	String encodedString;	try {	encodedString = URIUtil.encodePathQuery(value, encoding);	} catch (URIException e) {	String msg = "Unsupported charset encoding";	log.error(msg, e);	throw new FunctionCallException(msg, e);	}	if (debugOn) {	
converted string with encoding to url encoded value 

========================= synapse sample_259 =========================

if (addr != null) {	ipAddress = addr.getHostAddress();	if (ipAddress != null) {	}	hostName = addr.getHostName();	if (hostName == null) {	hostName = ipAddress;	}	}	} catch (UnknownHostException e) {	
unable to get the hostname or ip address of the server 

========================= synapse sample_609 =========================

public boolean mediate(MessageContext synCtx) {	
out mediator mediate 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	try {	if (shouldTrace) {	trace.trace("Start : Out mediator");	}	if (test(synCtx)) {	
current message is outgoing executing child mediators 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	try {	if (shouldTrace) {	trace.trace("Start : Out mediator");	}	if (test(synCtx)) {	return super.mediate(synCtx);	} else {	
current message is not outgoing skipping child mediators 

========================= synapse sample_3303 =========================

public static SynapseConfiguration getConfiguration(InputStream is) throws XMLStreamException {	
generating the synapse configuration model by parsing the xml configuration 

========================= synapse sample_4096 =========================

if (keyParam != null) {	OMElement ksEle      = keyParam.getParameterElement().getFirstElement();	String location      = ksEle.getFirstChildWithName(new QName("Location")).getText();	String type          = ksEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = ksEle.getFirstChildWithName(new QName("Password")).getText();	String keyPassword   = ksEle.getFirstChildWithName(new QName("KeyPassword")).getText();	try {	KeyStore keyStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	if (log.isDebugEnabled()) {	
loading key store from url 

try {	KeyStore keyStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	if (log.isDebugEnabled()) {	}	keyStore.load(url.openStream(), storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

URL url = getClass().getClassLoader().getResource(location);	if (log.isDebugEnabled()) {	}	keyStore.load(url.openStream(), storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

}	if (trustParam != null) {	OMElement tsEle      = trustParam.getParameterElement().getFirstElement();	String location      = tsEle.getFirstChildWithName(new QName("Location")).getText();	String type          = tsEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = tsEle.getFirstChildWithName(new QName("Password")).getText();	try {	KeyStore trustStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	if (log.isDebugEnabled()) {	
loading trust key store from url 

try {	KeyStore trustStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	if (log.isDebugEnabled()) {	}	trustStore.load(url.openStream(), storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

URL url = getClass().getClassLoader().getResource(location);	if (log.isDebugEnabled()) {	}	trustStore.load(url.openStream(), storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	throw new AxisFault("Error opening Key store : " + location, ioe);	}	}	try {	SSLContext sslcontext = SSLContext.getInstance("TLS");	sslcontext.init(keymanagers, trustManagers, null);	return sslcontext;	} catch (GeneralSecurityException gse) {	
unable to create ssl context with the given configuration 

========================= synapse sample_3753 =========================

protected void buildArchive(Archiver archiver) throws ArchiverException, MojoExecutionException {	Log log = getLog();	
using base directory 

protected void buildArchive(Archiver archiver) throws ArchiverException, MojoExecutionException {	Log log = getLog();	archiver.addDirectory(buildOutputDirectory);	if (includeDependencies) {	
adding dependencies 

protected void buildArchive(Archiver archiver) throws ArchiverException, MojoExecutionException {	Log log = getLog();	archiver.addDirectory(buildOutputDirectory);	if (includeDependencies) {	addDependencies(archiver);	}	if (generateMetadata) {	
generating xar metadata 

filter.add(new ScopeArtifactFilter(Artifact.SCOPE_RUNTIME));	filter.add(new ArtifactFilter() {	public boolean include(Artifact artifact) {	return !artifact.isOptional();	}	});	filter.add(new TypeArtifactFilter("jar"));	filter.add(buildSynapseRuntimeArtifactFilter());	for (Artifact artifact : filterArtifacts(project.getArtifacts(), filter)) {	String targetFileName = artifact.getArtifactId() + "-" + artifact.getVersion() + "." + artifact.getArtifactHandler().getExtension();	
adding scope 

private void generateMetadata(Archiver archiver) throws ArchiverException, MojoExecutionException {	Log log = getLog();	File tmpServicesDir = new File(new File(tmpDirectory, "META-INF"), "services");	File buildServicesDir = new File(new File(buildOutputDirectory, "META-INF"), "services");	if (!tmpServicesDir.exists() && !tmpServicesDir.mkdirs()) {	throw new MojoExecutionException("Error while creating the directory: " + tmpServicesDir.getPath());	}	
initializing class scanner 

throw new MojoExecutionException("Error while creating the directory: " + tmpServicesDir.getPath());	}	ClassScanner scanner = new ClassScanner(buildOutputDirectory);	for (Artifact artifact : filterArtifacts(project.getArtifacts(), new ScopeArtifactFilter(Artifact.SCOPE_COMPILE))) {	scanner.addToClasspath(artifact.getFile());	}	List<ServiceLocator> serviceLocators = new ArrayList<ServiceLocator>(serviceClassNames.length);	for (String serviceClassName : serviceClassNames) {	File file = new File(buildServicesDir, serviceClassName);	if (file.exists()) {	
exists don t scan for implementation 

}	try {	scanner.scan();	} catch (ClassScannerException e) {	throw new MojoExecutionException("Failed to scan classes for services", e);	}	for (ServiceLocator sl : serviceLocators) {	File file = new File(tmpServicesDir, sl.getServiceClassName());	if (!sl.getImplementations().isEmpty()) {	String destFileName = "META-INF/services/" + sl.getServiceClassName();	
generating 

artifacts.put(artifact.getDependencyConflictId(), artifact);	}	final Set<String> defaultExclusionSet = new HashSet<String>(Arrays.asList(defaultRuntimeExcludes));	return new ArtifactFilter() {	public boolean include(Artifact artifact) {	Artifact runtimeArtifact = artifacts.get(artifact.getDependencyConflictId());	if (runtimeArtifact == null) {	return !defaultExclusionSet.contains(artifact.getDependencyConflictId());	} else {	if (!runtimeArtifact.getVersion().equals(artifact.getVersion())) {	
possible runtime version conflict for xar depends on synapse runtime provides 

private Set<Artifact> getSynapseRuntimeArtifacts() throws MojoExecutionException {	Log log = getLog();	
looking for synapse core artifact in xar project dependencies 

for (Iterator<?> it = project.getDependencyArtifacts().iterator(); it.hasNext(); ) {	Artifact artifact = (Artifact)it.next();	if (artifact.getGroupId().equals("org.apache.synapse") && artifact.getArtifactId().equals("synapse-core")) {	synapseCore = artifact;	break;	}	}	if (synapseCore == null) {	throw new MojoExecutionException("Could not locate dependency on synapse-core");	}	
loading project data for 

synapseCoreProject = projectBuilder.buildFromRepository(synapseCore, remoteArtifactRepositories, localRepository);	} catch (ProjectBuildingException e) {	throw new MojoExecutionException("Unable to retrieve project information for " + synapseCore, e);	}	Set<Artifact> synapseRuntimeDeps;	try {	synapseRuntimeDeps = synapseCoreProject.createArtifacts(artifactFactory, Artifact.SCOPE_RUNTIME, new TypeArtifactFilter("jar"));	} catch (InvalidDependencyVersionException e) {	throw new MojoExecutionException("Unable to get project dependencies for " + synapseCore, e);	}	
direct runtime dependencies for 

} catch (ProjectBuildingException e) {	throw new MojoExecutionException("Unable to retrieve project information for " + synapseCore, e);	}	Set<Artifact> synapseRuntimeDeps;	try {	synapseRuntimeDeps = synapseCoreProject.createArtifacts(artifactFactory, Artifact.SCOPE_RUNTIME, new TypeArtifactFilter("jar"));	} catch (InvalidDependencyVersionException e) {	throw new MojoExecutionException("Unable to get project dependencies for " + synapseCore, e);	}	logArtifacts(synapseRuntimeDeps);	
resolving transitive dependencies for 

throw new MojoExecutionException("Unable to retrieve project information for " + synapseCore, e);	}	Set<Artifact> synapseRuntimeDeps;	try {	synapseRuntimeDeps = synapseCoreProject.createArtifacts(artifactFactory, Artifact.SCOPE_RUNTIME, new TypeArtifactFilter("jar"));	} catch (InvalidDependencyVersionException e) {	throw new MojoExecutionException("Unable to get project dependencies for " + synapseCore, e);	}	logArtifacts(synapseRuntimeDeps);	synapseRuntimeDeps = artifactCollector.collect(synapseRuntimeDeps, synapseCoreProject.getArtifact(), synapseCoreProject.getManagedVersionMap(), localRepository, remoteArtifactRepositories, artifactMetadataSource, null, Collections.<ResolutionListener>singletonList(new DebugResolutionListener(logger))).getArtifacts();	
all runtime dependencies for 

========================= synapse sample_1294 =========================

public boolean mediate(SynapseContext synCtx) {	
mediate 

public boolean mediate(SynapseContext synCtx) {	if (xsltUrl != null) {	performXLST(synCtx.getSynapseMessage());	return true;	} else if (xQueryUrl != null) {	System.err.println("Unimplemented functionality..");	return true;	} else {	
invalid configuration xslt xq not specified 

========================= synapse sample_2791 =========================

public Object call(Context context, List args) throws FunctionCallException {	if (synCtx == null) {	if (log.isDebugEnabled()) {	
synapse message context has not been set for the xpath extension function synapse get property prop name 

========================= synapse sample_520 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start in mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	boolean result = true;	if (test(synCtx)) {	
current message is incoming executing child mediators 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	boolean result = true;	if (test(synCtx)) {	result = super.mediate(synCtx);	} else {	
current message is a response skipping child mediators 

SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	boolean result = true;	if (test(synCtx)) {	result = super.mediate(synCtx);	} else {	}	
end in mediator 

========================= synapse sample_1914 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
message store deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try{	MessageStore ms = MessageStoreFactory.createMessageStore(artifactConfig,properties);	if(ms != null) {	ms.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
message store named has been built from the file 

if (log.isDebugEnabled()) {	}	try{	MessageStore ms = MessageStoreFactory.createMessageStore(artifactConfig,properties);	if(ms != null) {	ms.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	ms.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	
initialized the message store 

MessageStore ms = MessageStoreFactory.createMessageStore(artifactConfig,properties);	if(ms != null) {	ms.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	ms.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addMessageStore(ms.getName(), ms);	if (log.isDebugEnabled()) {	
message store deployment from file completed 

if(ms != null) {	ms.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	ms.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addMessageStore(ms.getName(), ms);	if (log.isDebugEnabled()) {	}	
message store named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
message store update from file has started 

if (log.isDebugEnabled()) {	}	try {	MessageStore ms = MessageStoreFactory.createMessageStore(artifactConfig, properties);	if (ms == null) {	handleSynapseArtifactDeploymentError("Message Store update failed. The artifact " + "defined in the file: " + fileName + " is not valid");	return null;	}	ms.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	
messagestore has been built from the file 

handleSynapseArtifactDeploymentError("Message Store update failed. The artifact " + "defined in the file: " + fileName + " is not valid");	return null;	}	ms.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	ms.init(getSynapseEnvironment());	MessageStore existingMs = getSynapseConfiguration().getMessageStore(existingArtifactName);	getSynapseConfiguration().removeMessageStore(existingArtifactName);	getSynapseConfiguration().addMessageStore(ms.getName(), ms);	
messagestore has been undeployed 

handleSynapseArtifactDeploymentError("Message Store update failed. The artifact " + "defined in the file: " + fileName + " is not valid");	return null;	}	ms.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	ms.init(getSynapseEnvironment());	MessageStore existingMs = getSynapseConfiguration().getMessageStore(existingArtifactName);	getSynapseConfiguration().removeMessageStore(existingArtifactName);	getSynapseConfiguration().addMessageStore(ms.getName(), ms);	
messagestore has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
messagestore undeployment of the messagestore named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	MessageStore ms = getSynapseConfiguration().getMessageStore(artifactName);	if (ms != null) {	getSynapseConfiguration().removeMessageStore(artifactName);	if (log.isDebugEnabled()) {	
destroying the messagestore named 

if (log.isDebugEnabled()) {	}	try {	MessageStore ms = getSynapseConfiguration().getMessageStore(artifactName);	if (ms != null) {	getSynapseConfiguration().removeMessageStore(artifactName);	if (log.isDebugEnabled()) {	}	ms.destroy();	if (log.isDebugEnabled()) {	
messagestore undeployment of the endpoint named completed 

}	try {	MessageStore ms = getSynapseConfiguration().getMessageStore(artifactName);	if (ms != null) {	getSynapseConfiguration().removeMessageStore(artifactName);	if (log.isDebugEnabled()) {	}	ms.destroy();	if (log.isDebugEnabled()) {	}	
messagestore named has been undeployed 

try {	MessageStore ms = getSynapseConfiguration().getMessageStore(artifactName);	if (ms != null) {	getSynapseConfiguration().removeMessageStore(artifactName);	if (log.isDebugEnabled()) {	}	ms.destroy();	if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
messagestore has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the messagestore with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	MessageStore ms = getSynapseConfiguration().getMessageStore(artifactName);	OMElement msElem = MessageStoreSerializer.serializeMessageStore(null,ms);	if (ms.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.MESSAGE_STORE_DIR + File.separator + ms.getFileName();	writeToFile(msElem, fileName);	if (log.isDebugEnabled()) {	
restoring the messagestore with name completed 

if (log.isDebugEnabled()) {	}	try {	MessageStore ms = getSynapseConfiguration().getMessageStore(artifactName);	OMElement msElem = MessageStoreSerializer.serializeMessageStore(null,ms);	if (ms.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.MESSAGE_STORE_DIR + File.separator + ms.getFileName();	writeToFile(msElem, fileName);	if (log.isDebugEnabled()) {	}	
messagestore named has been restored 

========================= synapse sample_170 =========================

this.configContext = ServerManager.getInstance().getConfigurationContext();	this.axisConfiguration = this.configContext.getAxisConfiguration();	servletContext.setAttribute(this.getClass().getName(), this);	this.servletConfig = config;	try {	Field agentField = AxisServlet.class.getDeclaredField("agent");	agentField.setAccessible(true);	agentField.set(this, new ListingAgent(configContext));	}	catch (Throwable ex) {	
unable to initialize axisservlet agent published wsdl documents may be inaccessible 

========================= synapse sample_3495 =========================

boolean handleFault = msgContext.getEnvelope() != null && (msgContext.getEnvelope().getBody().hasFault() || msgContext.isProcessingFault());	boolean faultsAsHttp200 = PassThroughConstants.TRUE.equals( msgContext.getProperty(PassThroughConstants.FAULTS_AS_HTTP_200));	if (handleFault && !faultsAsHttp200) {	httpStatus = HttpStatus.SC_INTERNAL_SERVER_ERROR;	}	Object statusCode = msgContext.getProperty(PassThroughConstants.HTTP_SC);	if (statusCode != null) {	try {	httpStatus = Integer.parseInt( msgContext.getProperty(PassThroughConstants.HTTP_SC).toString());	} catch (NumberFormatException e) {	
unable to set the http status code from the property with value 

========================= synapse sample_936 =========================

public void init(SynapseEnvironment se) {	if (log.isDebugEnabled()) {	
initializing child mediators 

public void destroy() {	if (log.isDebugEnabled()) {	
destroying child mediators 

========================= synapse sample_4184 =========================

public boolean mediate(SynapseMessage synapseMessageContext) {	try {	
sla mediator 

public void setSynapseEnvironment(SynapseEnvironment se) {	this.se = se;	if (se != null) {	
environment not null in sla 

========================= synapse sample_2816 =========================

private static void registerExtensions() {	Iterator<?> it = Service.providers(StartupFactory.class);	while (it.hasNext()) {	StartupFactory sf = (StartupFactory) it.next();	QName tag = sf.getTagQName();	factoryMap.put(tag, sf.getClass());	serializerMap.put(tag, sf.getSerializerClass());	if (log.isDebugEnabled()) {	
added startupfactory to handle 

public Startup getStartup(OMElement element, Properties properties) {	QName qName = element.getQName();	if (log.isDebugEnabled()) {	
creating the startup for 

========================= synapse sample_1739 =========================

public Object call(Context context, List args) throws FunctionCallException {	boolean debugOn = log.isDebugEnabled();	if (args == null || args.size() == 0) {	if (debugOn) {	
property key value for lookup is not specified 

int size = args.size();	if (size == 1) {	String value = StringFunction.evaluate(args.get(0), context.getNavigator());	return encode(debugOn, DEFAULT_CHARSET, value);	} else if (size == 2) {	String value = StringFunction.evaluate(args.get(0), context.getNavigator());	String encoding = StringFunction.evaluate(args.get(1), context.getNavigator());	return encode(debugOn, encoding, value);	} else {	if (debugOn) {	
function expects only one argument returning empty string 

private Object encode(boolean debugOn, String encoding, String value) throws FunctionCallException {	if (value == null || "".equals(value)) {	if (debugOn) {	
non emprty string value should be provided for encoding 

}	String encodedString;	try {	encodedString = new String(encodedValue, encoding);	} catch (UnsupportedEncodingException e) {	String msg = "Unsupported Encoding";	log.error(msg, e);	throw new FunctionCallException(msg, e);	}	if (debugOn) {	
converted string with encoding to encoded value 

========================= synapse sample_1693 =========================

public boolean mediate(MessageContext synCtx) {	
xslt mediator mediate 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	if (shouldTrace) {	trace.trace("Start : XSLT mediator");	}	
performing xslt transformation against property with key 

private void performXLST(MessageContext msgCtx,boolean shouldTrace) {	Source transformSrc = null;	ByteArrayOutputStream baosForTarget = new ByteArrayOutputStream();	StreamResult transformTgt = new StreamResult(baosForTarget);	OMNode sourceNode = getTransformSource(msgCtx);	if (shouldTrace) {	trace.trace("Transformation source : " + sourceNode.toString());	}	if (log.isDebugEnabled()) {	
transformation source 

}	}	try {	transformer.transform(transformSrc, transformTgt);	StAXOMBuilder builder = new StAXOMBuilder( new ByteArrayInputStream(baosForTarget.toByteArray()));	OMElement result = builder.getDocumentElement();	if (shouldTrace) {	trace.trace("Transformation result : " + result.toString());	}	if (log.isDebugEnabled()) {	
transformation result 

========================= synapse sample_3354 =========================

public void init(Properties jndiEnv) {	initialized = true;	if (jndiEnv == null || jndiEnv.isEmpty()) {	if (log.isDebugEnabled()) {	
provided global jndi environment properties is empty or null 

validateInitialized();	String dataSourceName = information.getDatasourceName();	validateDSName(dataSourceName);	Properties properties = information.getProperties();	InitialContext context = null;	Properties jndiEvn = null;	if (properties == null || properties.isEmpty()) {	if (initialContext != null) {	context = initialContext;	if (log.isDebugEnabled()) {	
empty jndi properties for datasource 

validateInitialized();	String dataSourceName = information.getDatasourceName();	validateDSName(dataSourceName);	Properties properties = information.getProperties();	InitialContext context = null;	Properties jndiEvn = null;	if (properties == null || properties.isEmpty()) {	if (initialContext != null) {	context = initialContext;	if (log.isDebugEnabled()) {	
using system wide jndi properties 

jndiEvn = jndiProperties;	}	}	if (context == null) {	jndiEvn = createJNDIEnvironment(properties, information.getAlias());	context = createInitialContext(jndiEvn);	if (context == null) {	validateInitialContext(initialContext);	context = initialContext;	if (log.isDebugEnabled()) {	
cannot create a name context with provided jndi properties 

jndiEvn = jndiProperties;	}	}	if (context == null) {	jndiEvn = createJNDIEnvironment(properties, information.getAlias());	context = createInitialContext(jndiEvn);	if (context == null) {	validateInitialContext(initialContext);	context = initialContext;	if (log.isDebugEnabled()) {	
using system wide jndi properties 

ref.add(new StringRefAddr(DataSourceConstants.PROP_URL, url));	ref.add(new StringRefAddr(SecurityConstants.PROP_USER_NAME, user));	ref.add(new StringRefAddr(SecurityConstants.PROP_PASSWORD, password));	ref.add(new StringRefAddr(DataSourceConstants.PROP_MAX_ACTIVE, maxActive));	ref.add(new StringRefAddr(DataSourceConstants.PROP_MAX_IDLE, maxIdle));	ref.add(new StringRefAddr(DataSourceConstants.PROP_MAX_WAIT, maxWait));	setBasicDataSourceParameters(ref, information);	setCommonParameters(ref, information);	try {	if (log.isDebugEnabled()) {	
registering a datasource with name in the jndi tree with jndiproperties 

}	Reference ref = new Reference("org.apache.commons.dbcp.datasources.PerUserPoolDataSource", "org.apache.commons.dbcp.datasources.PerUserPoolDataSourceFactory", null);	ref.add(new BinaryRefAddr( DataSourceConstants.PROP_JNDI_ENV, MiscellaneousUtil.serialize(jndiEvn)));	ref.add(new StringRefAddr( DataSourceConstants.PROP_DATA_SOURCE_NAME, name));	ref.add(new StringRefAddr( DataSourceConstants.PROP_DEFAULT_MAX_ACTIVE, maxActive));	ref.add(new StringRefAddr( DataSourceConstants.PROP_DEFAULT_MAX_IDLE, maxIdle));	ref.add(new StringRefAddr( DataSourceConstants.PROP_DEFAULT_MAX_WAIT, maxWait));	setCommonParameters(ref, information);	try {	if (log.isDebugEnabled()) {	
registering a datasource with name in the jndi tree with jndiproperties 

public DataSource lookUp(String dsName) {	validateInitialized();	validateDSName(dsName);	if (!cachedNameList.contains(dsName)) {	if (log.isDebugEnabled()) {	
there is no datasource with name in jndi datasource repository 

public DataSource lookUp(String dsName) {	validateInitialized();	validateDSName(dsName);	if (!cachedNameList.contains(dsName)) {	if (log.isDebugEnabled()) {	}	return null;	}	if (log.isDebugEnabled()) {	
getting a datasource with name from the jndi tree 

private Properties createJNDIEnvironment(Properties dsProperties, String name) {	String namingFactory = DataSourceConstants.DEFAULT_IC_FACTORY;	String providerUrl = null;	int port = DataSourceConstants.DEFAULT_PROVIDER_PORT;	String providerPort = null;	Properties jndiEvn = new Properties();	if (dsProperties != null && !dsProperties.isEmpty()) {	if (log.isDebugEnabled()) {	
using properties to create jndi environment 

buffer.append(DataSourceConstants.DOT_STRING);	}	String rootPrefix = buffer.toString();	namingFactory = MiscellaneousUtil.getProperty( dsProperties, rootPrefix + DataSourceConstants.PROP_IC_FACTORY, DataSourceConstants.DEFAULT_IC_FACTORY);	providerUrl = MiscellaneousUtil.getProperty( dsProperties, rootPrefix + DataSourceConstants.PROP_PROVIDER_URL, null);	providerPort = MiscellaneousUtil.getProperty(dsProperties, rootPrefix + DataSourceConstants.PROP_PROVIDER_PORT, String.valueOf(DataSourceConstants.DEFAULT_PROVIDER_PORT));	}	jndiEvn.put(Context.INITIAL_CONTEXT_FACTORY, namingFactory);	if (providerUrl != null && !"".equals(providerUrl)) {	if (log.isDebugEnabled()) {	
using provided initial context provider url 

namingFactory = MiscellaneousUtil.getProperty( dsProperties, rootPrefix + DataSourceConstants.PROP_IC_FACTORY, DataSourceConstants.DEFAULT_IC_FACTORY);	providerUrl = MiscellaneousUtil.getProperty( dsProperties, rootPrefix + DataSourceConstants.PROP_PROVIDER_URL, null);	providerPort = MiscellaneousUtil.getProperty(dsProperties, rootPrefix + DataSourceConstants.PROP_PROVIDER_PORT, String.valueOf(DataSourceConstants.DEFAULT_PROVIDER_PORT));	}	jndiEvn.put(Context.INITIAL_CONTEXT_FACTORY, namingFactory);	if (providerUrl != null && !"".equals(providerUrl)) {	if (log.isDebugEnabled()) {	}	} else {	if (log.isDebugEnabled()) {	
no initial context provider url creaeting a new one 

if (hostname == null) {	String ipAddr = addr.getHostAddress();	if (ipAddr != null) {	providerHost = ipAddr;	}	} else {	providerHost = hostname;	}	}	} catch (UnknownHostException e) {	
unable to determine hostname or ip address using localhost 

if (providerPort != null) {	try {	port = Integer.parseInt(providerPort);	} catch (NumberFormatException ignored) {	}	}	RMIRegistryController.getInstance().createLocalRegistry(port);	cachedPorts.add(port);	providerUrl = "rmi: }	jndiEvn.put(Context.PROVIDER_URL, providerUrl);	
datasources will be registered in the jndi context with provider prop url 

private InitialContext createInitialContext(Properties jndiEnv) {	if (jndiEnv == null || jndiEnv.isEmpty()) {	return null;	}	try {	if (log.isDebugEnabled()) {	
initiating a naming context with jndi environment jndiproperties 

========================= synapse sample_2115 =========================

public void handle(SecretCallback[] secretCallbacks) {	if (secretCallbacks == null || secretCallbacks.length == 0) {	if (log.isDebugEnabled()) {	
provided secretcallbacks are empty or null 

========================= synapse sample_2545 =========================

boolean wasError = true;	int retryCount = 0;	int maxRetryCount = VFSUtils.getMaxRetryCount(msgCtx, vfsOutInfo);	long reconnectionTimeout = VFSUtils.getReconnectTimout(msgCtx, vfsOutInfo);	boolean append = vfsOutInfo.isAppend();	while(wasError == true) {	try {	retryCount++;	replyFile = fsManager.resolveFile(vfsOutInfo.getOutFileURI());	if(replyFile == null) {	
replyfile is null 

boolean append = vfsOutInfo.isAppend();	while(wasError == true) {	try {	retryCount++;	replyFile = fsManager.resolveFile(vfsOutInfo.getOutFileURI());	if(replyFile == null) {	throw new FileSystemException("replyFile is null");	}	wasError = false;	} catch(FileSystemException e) {	
cannot resolve replyfile 

========================= synapse sample_4242 =========================

public void testScriptMediationInLineJS() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to the script mediator using js scripts 

========================= synapse sample_824 =========================

long start = System.currentTimeMillis();	OCSPCache ocspCache = OCSPCache.getCache();	ocspCache.init(cacheSize, cacheDurationMins);	CRLCache crlCache = CRLCache.getCache();	crlCache.init(cacheSize, cacheDurationMins);	RevocationVerifier[] verifiers = {new OCSPVerifier(ocspCache), new CRLVerifier(crlCache)};	for (RevocationVerifier verifier : verifiers) {	try {	CertificatePathValidator pathValidator = new CertificatePathValidator( convertedCertificates, verifier);	pathValidator.validatePath();	
path verification successful with took ms 

CRLCache crlCache = CRLCache.getCache();	crlCache.init(cacheSize, cacheDurationMins);	RevocationVerifier[] verifiers = {new OCSPVerifier(ocspCache), new CRLVerifier(crlCache)};	for (RevocationVerifier verifier : verifiers) {	try {	CertificatePathValidator pathValidator = new CertificatePathValidator( convertedCertificates, verifier);	pathValidator.validatePath();	return;	} catch (Exception e) {	if (log.isDebugEnabled()) {	
certificate verification with failed 

========================= synapse sample_2396 =========================

String targetEp = (String) messageContext.getProperty( ForwardingProcessorConstants.TARGET_ENDPOINT);	if (targetEp != null) {	Endpoint ep = messageContext.getEndpoint(targetEp);	if ((ep != null) && (((AbstractEndpoint) ep).isLeafEndpoint())) {	try {	sender.send(ep, messageContext);	if (delete) {	messageStore.poll();	}	} catch (Exception e) {	
error forwarding message 

========================= synapse sample_598 =========================

}	for (Iterator itr = elem.getChildrenWithName(IMPLEMENTATION_Q); itr.hasNext();) {	OMElement implElem = (OMElement) itr.next();	OMAttribute typeAttr = implElem.getAttribute(ATT_TYPE);	OMAttribute sizeAttr = implElem.getAttribute(ATT_SIZE);	if (typeAttr != null && typeAttr.getAttributeValue() != null) {	String type = typeAttr.getAttributeValue();	if (CachingConstants.TYPE_MEMORY.equals(type) && sizeAttr != null && sizeAttr.getAttributeValue() != null) {	cache.setInMemoryCacheSize(Integer.parseInt(sizeAttr.getAttributeValue()));	} else if (CachingConstants.TYPE_DISK.equals(type)) {	
disk based and hirearchycal caching is not implemented yet 

========================= synapse sample_1806 =========================

public TrustManagerFactory getTrustManagerFactoryInstance() {	try {	if (log.isDebugEnabled()) {	
creating a trustmanagerfactory instance 

========================= synapse sample_1105 =========================

private void executeClientEngine() {	HttpParams params = getClientParameters();	try {	ioReactor = new DefaultConnectingIOReactor( NHttpConfiguration.getInstance().getClientIOWorkers(), params);	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	
system may be unstable ioreactor encountered a checked exception 

private void executeClientEngine() {	HttpParams params = getClientParameters();	try {	ioReactor = new DefaultConnectingIOReactor( NHttpConfiguration.getInstance().getClientIOWorkers(), params);	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	return true;	}	public boolean handle(RuntimeException runtimeException) {	
system may be unstable ioreactor encountered a runtime exception 

ioReactor = new DefaultConnectingIOReactor( NHttpConfiguration.getInstance().getClientIOWorkers(), params);	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	return true;	}	public boolean handle(RuntimeException runtimeException) {	return true;	}	});	} catch (IOException e) {	
error starting the ioreactor 

}	});	} catch (IOException e) {	}	handler = new ClientHandler(cfgCtx, params, metrics);	IOEventDispatch ioEventDispatch = getEventDispatch( handler, sslContext, sslIOSessionHandler, params);	state = BaseConstants.STARTED;	try {	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	
reactor interrupted 

});	} catch (IOException e) {	}	handler = new ClientHandler(cfgCtx, params, metrics);	IOEventDispatch ioEventDispatch = getEventDispatch( handler, sslContext, sslIOSessionHandler, params);	state = BaseConstants.STARTED;	try {	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	} catch (IOException e) {	
encountered an i o error 

} else if ("https".equals(url.getProtocol())) {	port = 443;	}	}	HttpHost httpHost = new HttpHost(url.getHost(), port, url.getProtocol());	Axis2HttpRequest axis2Req = new Axis2HttpRequest(epr, httpHost, msgContext);	NHttpClientConnection conn = ConnectionPool.getConnection(url.getHost(), port);	if (conn == null) {	ioReactor.connect(new InetSocketAddress(url.getHost(), port), null, axis2Req, sessionRequestCallback);	if (log.isDebugEnabled()) {	
a new connection established to 

HttpHost httpHost = new HttpHost(url.getHost(), port, url.getProtocol());	Axis2HttpRequest axis2Req = new Axis2HttpRequest(epr, httpHost, msgContext);	NHttpClientConnection conn = ConnectionPool.getConnection(url.getHost(), port);	if (conn == null) {	ioReactor.connect(new InetSocketAddress(url.getHost(), port), null, axis2Req, sessionRequestCallback);	if (log.isDebugEnabled()) {	}	} else {	((ClientHandler) handler).submitRequest(conn, axis2Req);	if (log.isDebugEnabled()) {	
an existing connection reused to 

response.setStatusCode(HttpStatus.SC_INTERNAL_SERVER_ERROR);	}	if (msgContext.isPropertyTrue(NhttpConstants.SC_ACCEPTED)) {	response.setStatusCode(HttpStatus.SC_ACCEPTED);	} else {	Object statusCode = msgContext.getProperty(NhttpConstants.HTTP_SC);	if (statusCode != null) {	try {	response.setStatusCode(Integer.parseInt( msgContext.getProperty(NhttpConstants.HTTP_SC).toString()));	} catch (NumberFormatException e) {	
unable to set the http status code from the property hhtp sc with value 

public void stop() {	if (state != BaseConstants.STARTED) return;	try {	ioReactor.shutdown();	state = BaseConstants.STOPPED;	} catch (IOException e) {	
error shutting down ioreactor 

if (isTimeout) {	axisFault = new AxisFault("The connection timed out");	} else {	Exception exception = request.getException();	axisFault = new AxisFault(exception.toString(), exception);	}	MessageContext nioFaultMessageContext = MessageContextBuilder.createFaultMessageContext(mc, axisFault);	nioFaultMessageContext.setProperty(NhttpConstants.SENDING_FAULT, Boolean.TRUE);	mr.receive(nioFaultMessageContext);	} catch (AxisFault af) {	
unable to report back failure to the message receiver 

public void pause() throws AxisFault {	if (state != BaseConstants.STARTED) return;	state = BaseConstants.PAUSED;	
sender paused 

public void resume() throws AxisFault {	if (state != BaseConstants.PAUSED) return;	state = BaseConstants.STARTED;	
sender resumed 

public void maintenenceShutdown(long millis) throws AxisFault {	if (state != BaseConstants.STARTED) return;	try {	long start = System.currentTimeMillis();	ioReactor.shutdown(millis);	state = BaseConstants.STOPPED;	
sender shutdown in s 

try {	ObjectName name = new ObjectName(objectName);	Set set = mbs.queryNames(name, null);	if (set != null && set.isEmpty()) {	mbs.registerMBean(mbeanInstance, name);	} else {	mbs.unregisterMBean(name);	mbs.registerMBean(mbeanInstance, name);	}	} catch (Exception e) {	
error registering a mbean with objectname for jmx management 

========================= synapse sample_4307 =========================

Parameter keyParam    = transportOut.getParameter("keystore");	Parameter trustParam  = transportOut.getParameter("truststore");	OMElement ksEle = null;	OMElement tsEle = null;	if (keyParam != null) {	ksEle = keyParam.getParameterElement().getFirstElement();	}	boolean noValidateCert = ParamUtils.getOptionalParamBoolean(transportOut, "novalidatecert", false);	if (trustParam != null) {	if (noValidateCert) {	
ignoring novalidatecert parameter since a truststore has been specified 

private Map<String, SSLContext> getCustomSSLContexts(TransportOutDescription transportOut) throws AxisFault {	if (log.isDebugEnabled()) {	
loading custom ssl profiles for the https sender 

OMElement ksElt = profile.getFirstChildWithName(new QName("KeyStore"));	OMElement trElt = profile.getFirstChildWithName(new QName("TrustStore"));	String noValCert = profile.getAttributeValue(new QName("novalidatecert"));	boolean novalidatecert = "true".equals(noValCert);	SSLContext sslContext = createSSLContext(ksElt, trElt, novalidatecert);	for (String server : servers) {	server = server.trim();	if (!contextMap.containsKey(server)) {	contextMap.put(server, sslContext);	} else {	
multiple ssl profiles were found for the server ignoring the excessive profiles 

SSLContext sslContext = createSSLContext(ksElt, trElt, novalidatecert);	for (String server : servers) {	server = server.trim();	if (!contextMap.containsKey(server)) {	contextMap.put(server, sslContext);	} else {	}	}	}	if (contextMap.size() > 0) {	
custom ssl profiles initialized for servers 

TrustManager[] trustManagers = null;	if (keyStoreElt != null) {	String location      = keyStoreElt.getFirstChildWithName(new QName("Location")).getText();	String type          = keyStoreElt.getFirstChildWithName(new QName("Type")).getText();	String storePassword = keyStoreElt.getFirstChildWithName(new QName("Password")).getText();	String keyPassword   = keyStoreElt.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading identity keystore from 

String keyPassword   = keyStoreElt.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	
error loading keystore 

try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Keystore : " + location, gse);	} catch (IOException ioe) {	
error opening keystore 

} finally {	if (fis != null) {	try {	fis.close();	} catch (IOException ignore) {}	}	}	}	if (trustStoreElt != null) {	if (novalidatecert) {	
ignoring novalidatecert parameter since a truststore has been specified 

if (trustStoreElt != null) {	if (novalidatecert) {	}	String location      = trustStoreElt.getFirstChildWithName(new QName("Location")).getText();	String type          = trustStoreElt.getFirstChildWithName(new QName("Type")).getText();	String storePassword = trustStoreElt.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading trust keystore from 

String storePassword = trustStoreElt.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

} catch (IOException ioe) {	throw new AxisFault("Error opening Key store : " + location, ioe);	} finally {	if (fis != null) {	try {	fis.close();	} catch (IOException ignore) {}	}	}	} else if (novalidatecert) {	
server certificate validation trust has been disabled do not use in production 

}	}	} else if (novalidatecert) {	trustManagers = new TrustManager[] { new NoValidateCertTrustManager() };	}	try {	SSLContext sslcontext = SSLContext.getInstance("TLS");	sslcontext.init(keymanagers, trustManagers, null);	return sslcontext;	} catch (GeneralSecurityException gse) {	
unable to create ssl context with the given configuration 

========================= synapse sample_961 =========================

private Endpoint loadAndInitEndpoint(ConfigurationContext cc, String key) {	Parameter parameter = cc.getAxisConfiguration().getParameter( SynapseConstants.SYNAPSE_CONFIG);	Parameter synEnvParameter = cc.getAxisConfiguration().getParameter( SynapseConstants.SYNAPSE_ENV);	if (parameter.getValue() instanceof SynapseConfiguration && synEnvParameter.getValue() instanceof SynapseEnvironment) {	SynapseConfiguration synCfg = (SynapseConfiguration) parameter.getValue();	SynapseEnvironment synapseEnvironment = (SynapseEnvironment) synEnvParameter.getValue();	if (log.isDebugEnabled()) {	
loading real endpoint with key 

========================= synapse sample_218 =========================

public void rewrite(URIFragments fragments, MessageContext messageContext, Map<String,String> headers) throws URISyntaxException {	if (condition != null) {	String uriString = fragments.toURIString();	EvaluatorContext ctx = new EvaluatorContext(uriString, headers);	if (log.isTraceEnabled()) {	
evaluating condition with uri 

public void rewrite(URIFragments fragments, MessageContext messageContext, Map<String,String> headers) throws URISyntaxException {	if (condition != null) {	String uriString = fragments.toURIString();	EvaluatorContext ctx = new EvaluatorContext(uriString, headers);	if (log.isTraceEnabled()) {	}	try {	if (!condition.evaluate(ctx)) {	if (log.isTraceEnabled()) {	
condition evaluated to false skipping the current action 

EvaluatorContext ctx = new EvaluatorContext(uriString, headers);	if (log.isTraceEnabled()) {	}	try {	if (!condition.evaluate(ctx)) {	if (log.isTraceEnabled()) {	}	return;	}	if (log.isTraceEnabled()) {	
condition evaluated to true performing the stated action 

}	try {	if (!condition.evaluate(ctx)) {	if (log.isTraceEnabled()) {	}	return;	}	if (log.isTraceEnabled()) {	}	} catch (EvaluatorException e) {	
error while evaluating the condition skipping the rule as it failed 

========================= synapse sample_4487 =========================

public boolean mediate(MessageContext synCtx) {	if (log.isDebugEnabled()) {	
mediation for event publisher started 

========================= synapse sample_1955 =========================

public void close() throws IOException {	
close connection 

public void shutdown() throws IOException {	
shutdown connection 

public void submitResponse(final HttpResponse response) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection 

public void consumeInput(final NHttpServerEventHandler handler) {	
consume input 

public void produceOutput(final NHttpServerEventHandler handler) {	
produce output 

========================= synapse sample_998 =========================

private void registerExtensions() {	if (log.isDebugEnabled()) {	
registering mediator extensions found in the classpath java class path 

MediatorSerializer ms = (MediatorSerializer) it.next();	String name = ms.getMediatorClassName();	try {	serializerMap.put(name, ms.getClass().newInstance());	} catch (InstantiationException e) {	handleException("Error instantiating mediator serializer : " + ms);	} catch (IllegalAccessException e) {	handleException("Error instantiating mediator serializer : " + ms);	}	if (log.isDebugEnabled()) {	
added mediatorserializer to handle 

========================= synapse sample_3591 =========================

public void addDestination(String destinationJNDIName, String destinationType, String serviceName) {	String destinationName = getPhysicalDestinationName(destinationJNDIName);	if (destinationName == null) {	
jms destination with jndi name does not exist 

public void addDestination(String destinationJNDIName, String destinationType, String serviceName) {	String destinationName = getPhysicalDestinationName(destinationJNDIName);	if (destinationName == null) {	try {	
creating a jms queue with the jndi name using the connection factory definition named 

public void addDestination(String destinationJNDIName, String destinationType, String serviceName) {	String destinationName = getPhysicalDestinationName(destinationJNDIName);	if (destinationName == null) {	try {	JMSUtils.createDestination(conFactory, destinationJNDIName, destinationType);	destinationName = getPhysicalDestinationName(destinationJNDIName);	} catch (JMSException e) {	
unable to create destination with jndi name 

JMSUtils.createDestination(conFactory, destinationJNDIName, destinationType);	destinationName = getPhysicalDestinationName(destinationJNDIName);	} catch (JMSException e) {	BaseUtils.markServiceAsFaulty( serviceName, "Error creating JMS destination : " + destinationJNDIName, cfgCtx.getAxisConfiguration());	return;	}	}	serviceJNDINameMapping.put(destinationJNDIName, serviceName);	destinationTypeMapping.put(destinationJNDIName, destinationType);	serviceDestinationNameMapping.put(destinationName, serviceName);	
mapped jndi name and jms destination name against service 

public synchronized void connectAndListen() throws JMSException, NamingException {	if (connection != null) {	
re initializing the jms connection factory 

while (sessionIter.hasNext()) {	try {	((Session) sessionIter.next()).close();	} catch (JMSException ignore) {}	}	try {	connection.stop();	} catch (JMSException ignore) {}	} else {	if (log.isDebugEnabled()) {	
initializing the jms connection factory 

}	try {	connection.stop();	} catch (JMSException ignore) {}	} else {	if (log.isDebugEnabled()) {	}	}	context = new InitialContext(jndiProperties);	conFactory = (ConnectionFactory) context.lookup(connFactoryJNDIName);	
connected to the jms connection factory 

} catch (JMSException e) {	handleException("Error connecting to Connection Factory : " + connFactoryJNDIName, e);	}	Iterator destJNDINameIter = serviceJNDINameMapping.keySet().iterator();	while (destJNDINameIter.hasNext()) {	String destJNDIName = (String) destJNDINameIter.next();	String destinationType = (String) destinationTypeMapping.get(destJNDIName);	startListeningOnDestination(destJNDIName, destinationType);	}	connection.start();	
connection factory initialized 

try {	session.close();	} catch (JMSException ignore) {}	}	try {	session = JMSUtils.createSession(connection, false, Session.AUTO_ACKNOWLEDGE, destinationType);	Destination destination = null;	try {	destination = (Destination) context.lookup(destinationJNDIname);	} catch (NameNotFoundException e) {	
cannot find destination creating a queue 

if (connection != null) {	Iterator sessionIter = jmsSessions.values().iterator();	while (sessionIter.hasNext()) {	try {	((Session) sessionIter.next()).close();	} catch (JMSException ignore) {}	}	try {	connection.close();	} catch (JMSException e) {	
error shutting down connection factory 

private String getPhysicalDestinationName(String destinationJndi) {	Destination destination = getPhysicalDestination(destinationJndi);	if (destination != null) {	try {	if (destination instanceof Queue) {	return ((Queue) destination).getQueueName();	} else if (destination instanceof Topic) {	return ((Topic) destination).getTopicName();	}	} catch (JMSException e) {	
error reading destination name for jndi destination 

destination = (Destination) context.lookup(destinationJndi);	} catch (NamingException e) {	String provider = (String) jndiProperties.get(Context.INITIAL_CONTEXT_FACTORY);	if (provider.indexOf("activemq") != -1) {	try {	destination = (Destination) context.lookup( JMSConstants.ACTIVEMQ_DYNAMIC_QUEUE + destinationJndi);	} catch (NamingException ne) {	try {	destination = (Destination) context.lookup( JMSConstants.ACTIVEMQ_DYNAMIC_TOPIC + destinationJndi);	} catch (NamingException e1) {	
error looking up destination for jndi name 

public void onException(JMSException e) {	
jms connection factory encountered an error 

public void onException(JMSException e) {	boolean wasError = true;	while (wasError == true) {	try {	connectAndListen();	wasError = false;	} catch (Exception e1) {	
jms reconnection attempt failed for connection factory 

public void onException(JMSException e) {	boolean wasError = true;	while (wasError == true) {	try {	connectAndListen();	wasError = false;	} catch (Exception e1) {	}	if (wasError == true) {	try {	
attempting reconnection for connection factory in seconds 

========================= synapse sample_4311 =========================

boolean statsOn = (SynapseConstants.STATISTICS_ON == proxy.getStatisticsState());	if (statsOn) {	ProxyServiceStatisticsStack proxyServiceStatisticsStack = new ProxyServiceStatisticsStack();	boolean isFault = synCtx.getEnvelope().getBody().hasFault();	proxyServiceStatisticsStack.put(name, System.currentTimeMillis(), !synCtx.isResponse(), statsOn, isFault);	synCtx.setProperty(SynapseConstants.PROXY_STATS, proxyServiceStatisticsStack);	}	Mediator mandatorySeq = synCtx.getConfiguration().getMandatorySequence();	if (mandatorySeq != null) {	if (log.isDebugEnabled()) {	
start mediating the message in the pre mediate state using the mandatory sequence 

boolean isFault = synCtx.getEnvelope().getBody().hasFault();	proxyServiceStatisticsStack.put(name, System.currentTimeMillis(), !synCtx.isResponse(), statsOn, isFault);	synCtx.setProperty(SynapseConstants.PROXY_STATS, proxyServiceStatisticsStack);	}	Mediator mandatorySeq = synCtx.getConfiguration().getMandatorySequence();	if (mandatorySeq != null) {	if (log.isDebugEnabled()) {	}	if(!mandatorySeq.mediate(synCtx)) {	if(log.isDebugEnabled()) {	
request message for the proxy service dropped in the pre mediation state by the mandatory sequence 

========================= synapse sample_3987 =========================

private static void registerExtensions() {	Iterator it = Service.providers(ConfigurationFactory.class);	while (it.hasNext()) {	ConfigurationFactory cf = (ConfigurationFactory) it.next();	QName tag = cf.getTagQName();	factoryMap.put(tag, cf.getClass());	serializerMap.put(tag, cf.getSerializerClass());	if (log.isDebugEnabled()) {	
added mediatorfactory to handle 

public SynapseConfiguration getConfiguration(OMElement element, Properties properties) {	String localName = element.getLocalName();	QName qName;	if (element.getNamespace() != null) {	qName = new QName(element.getNamespace().getNamespaceURI(), localName);	} else {	qName = new QName(localName);	}	if (log.isDebugEnabled()) {	
getconfiguration 

========================= synapse sample_1810 =========================

public void connected(final NHttpClientConnection conn, final Object attachment) {	if (log.isDebugEnabled() ) {	
clienthandler connected 

ConnectionPool.forget(conn);	String message = getErrorMessage("Connection close", conn);	if (log.isTraceEnabled()) {	log.trace(message);	}	Axis2HttpRequest axis2Request = (Axis2HttpRequest) conn.getContext().getAttribute(AXIS2_HTTP_REQUEST);	if (axis2Request != null && !axis2Request.isCompleted()) {	checkAxisRequestComplete(conn, NhttpConstants.CONNECTION_CLOSED, message, null);	} else {	if (log.isDebugEnabled()) {	
keep alive connection closed 

public void timeout(final NHttpClientConnection conn) {	String message = getErrorMessage("Connection timeout", conn);	if (log.isDebugEnabled()) {	log.debug(message);	}	Axis2HttpRequest axis2Request = (Axis2HttpRequest) conn.getContext().getAttribute(AXIS2_HTTP_REQUEST);	if (axis2Request != null && !axis2Request.isCompleted()) {	checkAxisRequestComplete(conn, NhttpConstants.CONNECTION_TIMEOUT, message, null);	} else {	if (log.isDebugEnabled()) {	
keep alive connection timed out 

}	}	workerPool.execute( new Runnable() {	public void run() {	MessageReceiver mr = mc.getAxisOperation().getMessageReceiver();	try {	AxisFault axisFault = exceptionToRaise != null ? new AxisFault(errorMessage, exceptionToRaise) : new AxisFault(errorMessage);	MessageContext nioFaultMessageContext = MessageContextBuilder.createFaultMessageContext(mc, axisFault);	SOAPEnvelope envelope = nioFaultMessageContext.getEnvelope();	if (log.isDebugEnabled()) {	
sending fault for request with message id 

nioFaultMessageContext.setProperty( NhttpConstants.ERROR_DETAIL, exceptionToRaise.toString());	nioFaultMessageContext.setProperty( NhttpConstants.ERROR_EXCEPTION, exceptionToRaise);	envelope.getBody().getFault().getDetail().setText( exceptionToRaise.toString());	} else {	nioFaultMessageContext.setProperty( NhttpConstants.ERROR_DETAIL, errorMessage);	envelope.getBody().getFault().getDetail().setText(errorMessage);	}	nioFaultMessageContext.setProperty(CLIENT_CONNECTION_DEBUG, mc.getProperty(CLIENT_CONNECTION_DEBUG));	mr.receive(nioFaultMessageContext);	} catch (AxisFault af) {	
unable to report back failure to the message receiver 

public void responseReceived(final NHttpClientConnection conn) {	setServerContextAttribute(NhttpConstants.RES_HEADER_ARRIVAL_TIME, System.currentTimeMillis(), conn);	HttpContext context = conn.getContext();	HttpResponse response = conn.getHttpResponse();	if (response.getStatusLine().getStatusCode() == HttpStatus.SC_CONTINUE) {	if (log.isDebugEnabled()) {	
received a continue response 

return;	}	ClientConnectionDebug ccd = (ClientConnectionDebug) conn.getContext().getAttribute(CLIENT_CONNECTION_DEBUG);	if (ccd != null) {	ccd.recordResponseStartTime(response.getStatusLine().toString());	}	Axis2HttpRequest req = (Axis2HttpRequest) conn.getContext().getAttribute(AXIS2_HTTP_REQUEST);	if (req != null) {	req.setCompleted(true);	if (log.isDebugEnabled()) {	
response received for request 

req.setCompleted(true);	if (log.isDebugEnabled()) {	}	if (!req.isSendingCompleted()) {	req.getMsgContext().setProperty( NhttpConstants.ERROR_CODE, NhttpConstants.SEND_ABORT);	SharedOutputBuffer outputBuffer = (SharedOutputBuffer) conn.getContext().getAttribute(REQUEST_SOURCE_BUFFER);	if (outputBuffer != null) {	outputBuffer.shutdown();	}	if (log.isDebugEnabled()) {	
remote server aborted request being sent and replied for request 

}	context.setAttribute(NhttpConstants.DISCARD_ON_COMPLETE, Boolean.TRUE);	if (metrics != null) {	metrics.incrementFaultsSending(NhttpConstants.SEND_ABORT, req.getMsgContext());	}	}	}	switch (response.getStatusLine().getStatusCode()) {	case HttpStatus.SC_ACCEPTED : {	if (log.isDebugEnabled()) {	
received a accepted response 

responseMsgCtx.setTo(null);	if (!outMsgCtx.isDoingREST() && !outMsgCtx.isSOAP11()) {	responseMsgCtx.setEnvelope(OMAbstractFactory.getSOAP12Factory().getDefaultEnvelope());	} else {	responseMsgCtx.setEnvelope(OMAbstractFactory.getSOAP11Factory().getDefaultEnvelope());	}	responseMsgCtx.setProperty(AddressingConstants. DISABLE_ADDRESSING_FOR_OUT_MESSAGES, Boolean.TRUE);	responseMsgCtx.setProperty(NhttpConstants.SC_ACCEPTED, Boolean.TRUE);	mr.receive(responseMsgCtx);	} catch (org.apache.axis2.AxisFault af) {	
unable to report back accepted state to the message receiver 

}	}	return;	}	case HttpStatus.SC_OK : {	processResponse(conn, context, response);	return;	}	case HttpStatus.SC_INTERNAL_SERVER_ERROR: {	if (warnOnHttp500(response)) {	
received an internal server error 

return;	}	case HttpStatus.SC_INTERNAL_SERVER_ERROR: {	if (warnOnHttp500(response)) {	}	processResponse(conn, context, response);	return;	}	default : {	if (log.isDebugEnabled()) {	
http status code received 

processResponse(conn, context, response);	return;	}	default : {	if (log.isDebugEnabled()) {	}	Header contentType = response.getFirstHeader(HTTP.CONTENT_TYPE);	if (contentType != null) {	if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf( SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	
received an unexpected response with a soap payload 

default : {	if (log.isDebugEnabled()) {	}	Header contentType = response.getFirstHeader(HTTP.CONTENT_TYPE);	if (contentType != null) {	if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf( SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	}	} else if (contentType.getValue().indexOf("html") == -1) {	if (log.isDebugEnabled()) {	
received an unexpected response with a pox rest payload 

}	Header contentType = response.getFirstHeader(HTTP.CONTENT_TYPE);	if (contentType != null) {	if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf( SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	}	} else if (contentType.getValue().indexOf("html") == -1) {	if (log.isDebugEnabled()) {	}	} else {	
received an unexpected response of content type and status code with reason 

if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf( SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	}	} else if (contentType.getValue().indexOf("html") == -1) {	if (log.isDebugEnabled()) {	}	} else {	}	} else {	if (log.isDebugEnabled()) {	
received a response without a content type with status code and reason 

private void shutdownConnection(final NHttpClientConnection conn) {	if (conn instanceof HttpInetConnection) {	HttpInetConnection inetConnection = (HttpInetConnection) conn;	if (log.isDebugEnabled()) {	
connection to remote address from local address is closed 

========================= synapse sample_2441 =========================

public boolean mediate(SynapseMessage synapseMessageContext) {	try {	
sla mediator 

public void setSynapseEnvironment(SynapseEnvironment se) {	this.se = se;	if(se!=null){	
environment not null in sla 

========================= synapse sample_2912 =========================

public void submitResponse(final HttpResponse response) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection 

========================= synapse sample_3745 =========================

public boolean mediate(MessageContext smc) {	
set property mediator mediate 

========================= synapse sample_3315 =========================

assertResponseReceived(result);	getBackendServerControllers().get(1).stopProcess();	sleep(2000);	result = client.sessionlessClient(addUrl, null, 10);	assertResponseReceived(result);	getBackendServerControllers().get(2).stopProcess();	sleep(2000);	result = client.sessionlessClient(addUrl, null, 1);	Exception resultEx = result.getException();	assertNotNull("Did not receive expected error", resultEx);	
got an error as expected 

========================= synapse sample_865 =========================

public int getPriority(String ip, EndpointReference to) {	int priority=-1;	Map clientMap = (Map) SLAConfig.get(ip);	if(clientMap!=null){	
address 

========================= synapse sample_4653 =========================

public boolean startProcess() {	try {	Class.forName("org.apache.derby.jdbc.ClientDriver").newInstance();	server = new NetworkServerControl (InetAddress.getByName("localhost"), port);	server.start(null);	while (true) {	try {	server.ping();	break;	} catch (Exception ignored) {	
waiting for derby server to start 

server = new NetworkServerControl (InetAddress.getByName("localhost"), port);	server.start(null);	while (true) {	try {	server.ping();	break;	} catch (Exception ignored) {	Thread.sleep(2000);	}	}	
derby is successfully started 

try {	server.ping();	break;	} catch (Exception ignored) {	Thread.sleep(2000);	}	}	initData();	return true;	} catch (Exception e) {	
there was an error starting derby server 

private void initData() throws Exception {	
creating the sample table and inserting values 

public boolean stopProcess() {	
shutting down derby server 

public boolean stopProcess() {	try {	try {	DriverManager.getConnection("jdbc:derby:;shutdown=true");	} catch (SQLException se) {	if (se.getErrorCode() == 50000 && "XJ015".equals(se.getSQLState())) {	
derby shut down normally 

try {	DriverManager.getConnection("jdbc:derby:;shutdown=true");	} catch (SQLException se) {	if (se.getErrorCode() == 50000 && "XJ015".equals(se.getSQLState())) {	}	}	server.shutdown();	FileUtils.deleteDirectory(new File("./synapsedb"));	return true;	} catch (Exception e) {	
error while trying to delete database directory 

========================= synapse sample_2292 =========================

String mName = "set" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1);	if (property.getAttributeValue(new QName("value")) != null) {	String value = property.getAttributeValue(new QName("value"));	setInstanceProperty(propertyName, value, o);	} else {	OMElement value = property.getFirstElement();	if (value != null) {	try {	Method method = o.getClass().getMethod(mName, OMElement.class);	if (log.isDebugEnabled()) {	
setting property invoking method 

========================= synapse sample_721 =========================

private Endpoint loadAndInitEndpoint(ConfigurationContext cc, String key) {	Parameter parameter = cc.getAxisConfiguration().getParameter( SynapseConstants.SYNAPSE_CONFIG);	Parameter synEnvParameter = cc.getAxisConfiguration().getParameter( SynapseConstants.SYNAPSE_ENV);	if (parameter.getValue() instanceof SynapseConfiguration && synEnvParameter.getValue() instanceof SynapseEnvironment) {	SynapseConfiguration synCfg = (SynapseConfiguration) parameter.getValue();	SynapseEnvironment synapseEnvironment = (SynapseEnvironment) synEnvParameter.getValue();	if (log.isDebugEnabled()) {	
loading real endpoint with key 

========================= synapse sample_1646 =========================

public void send(MessageContext synMessageContext) {	if (log.isDebugEnabled()) {	
start failover endpoint 

boolean isClusteringEnable = false;	org.apache.axis2.context.MessageContext axisMC = ((Axis2MessageContext) synMessageContext).getAxis2MessageContext();	ConfigurationContext cc = axisMC.getConfigurationContext();	ClusterManager clusterManager = cc.getAxisConfiguration().getClusterManager();	if (clusterManager != null && clusterManager.getContextManager() != null) {	isClusteringEnable = true;	}	String endPointName = this.getName();	if (endPointName == null) {	if (log.isDebugEnabled() && isClusteringEnable) {	
in a clustering environment the endpoint name should be specified even for anonymous endpoints otherwise the clustering would not be functioned correctly if there are more than one anonymous endpoints 

boolean active = endpointContext.isActive();	if (!active) {	for (Endpoint endpoint : endpoints) {	if (endpoint.isActive(synMessageContext)) {	active = true;	endpointContext.setActive(true);	}	}	}	if (log.isDebugEnabled()) {	
endpoint is in state 

========================= synapse sample_4014 =========================

org.apache.synapse.MessageContext synCtx = MessageContextCreatorForAxis2.getSynapseMessageContext(messageContext);	if (messageContext.isServerSide()) {	synCtx.setProperty(SynapseConstants.RESPONSE, Boolean.TRUE);	synCtx.setResponse(true);	synCtx.setProperty(SynapseConstants.RESPONSE, Boolean.TRUE);	synCtx.setResponse(true);	try {	if (HandlerUtil.mediateOutMessage(log, messageContext, synCtx)) {	return InvocationResponse.CONTINUE;	} else {	
synapse has decided to abort the message 

}	} catch (SynapseException syne) {	}	} else {	synCtx.setProperty(SynapseConstants.RESPONSE, Boolean.FALSE);	synCtx.setResponse(false);	try {	if (HandlerUtil.mediateInMessage(log, messageContext, synCtx)) {	return InvocationResponse.CONTINUE;	} else {	
synapse has decided to abort the message 

} else {	return InvocationResponse.ABORT;	}	} catch (SynapseException syne) {	}	}	try {	if (synCtx.getEnvironment().injectMessage(synCtx)) {	return InvocationResponse.CONTINUE;	} else {	
synapse has decided to abort the message 

try {	if (synCtx.getEnvironment().injectMessage(synCtx)) {	return InvocationResponse.CONTINUE;	} else {	return InvocationResponse.ABORT;	}	} catch (SynapseException syne) {	if (!synCtx.getFaultStack().isEmpty()) {	((FaultHandler) synCtx.getFaultStack().pop()).handleFault(synCtx, syne);	} else {	
synapse encountered an exception no error handlers found 

========================= synapse sample_2 =========================

public static String getNameSpaceWithPrefix(String prefix, OMElement elem) {	if (prefix == null || elem == null) {	
searching for null ns prefix and or using null omelement 

========================= synapse sample_3552 =========================

MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();	ObjectName name = new ObjectName(getObjectName(category, id));	Set set = mbs.queryNames(name, null);	if (set != null && set.isEmpty()) {	mbs.registerMBean(mbeanInstance, name);	} else {	mbs.unregisterMBean(name);	mbs.registerMBean(mbeanInstance, name);	}	} catch (Exception e) {	
error registering a mbean with name and category name for jmx management 

public void unRegisterMBean(String category, String id) {	try {	MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();	ObjectName objName = new ObjectName(getObjectName(category, id));	if (mbs.isRegistered(objName)) {	mbs.unregisterMBean(objName);	}	} catch (Exception e) {	
error un registering a mbean with name and category name for jmx management 

========================= synapse sample_1095 =========================

public boolean process(SynapseEnvironment se, SynapseMessage smc) {	if (pattern == null) {	
trying to process with empty pattern 

return true;	}	String toMatch = null;	if (property != null) {	toMatch = smc.getProperty(property).toString();	} else {	toMatch = headerType.getHeader(smc);	}	if (toMatch==null) return true;	if (pattern.matcher(toMatch).matches()) {	
regex pattern matched 

========================= synapse sample_4628 =========================

public void init(SynapseEnvironment synapseEnvironment) {	if (messageQueue.isPersistent()) {	
loading the persisted messages if there are any to the message queue 

public void init(SynapseEnvironment synapseEnvironment) {	if (messageQueue.isPersistent()) {	messageQueue.load();	}	Timer samplingTimer = synapseEnvironment.getSynapseConfiguration().getSynapseTimer();	messageProcessor = new MessageProcessor();	
scheduling the sampling timer to invoke the message processor at an interval of 

public void destroy() {	messageProcessor.cancel();	if (!messageQueue.isEmpty()) {	
there are messages on the sampling message queue but the message processor has been destroyed 

public void destroy() {	messageProcessor.cancel();	if (!messageQueue.isEmpty()) {	if (messageQueue.isPersistent()) {	if (log.isDebugEnabled()) {	
persisting the messages on the message queue 

public void destroy() {	messageProcessor.cancel();	if (!messageQueue.isEmpty()) {	if (messageQueue.isPersistent()) {	if (log.isDebugEnabled()) {	}	if (messageQueue.persist()) {	
completed persisting the messages on the message queue 

public void destroy() {	messageProcessor.cancel();	if (!messageQueue.isEmpty()) {	if (messageQueue.isPersistent()) {	if (log.isDebugEnabled()) {	}	if (messageQueue.persist()) {	} else {	
couldn t persist the messages on the message queue 

public void destroy() {	messageProcessor.cancel();	if (!messageQueue.isEmpty()) {	if (messageQueue.isPersistent()) {	if (log.isDebugEnabled()) {	}	if (messageQueue.persist()) {	} else {	}	} else {	
you are not using a persistent message queue you will be loosing messages which are on the queue 

public boolean mediate(MessageContext messageContext) {	SynapseLog synLog = getLog(messageContext);	
start sampler mediator 

public boolean mediate(MessageContext messageContext) {	SynapseLog synLog = getLog(messageContext);	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext messageContext) {	SynapseLog synLog = getLog(messageContext);	if (synLog.isTraceTraceEnabled()) {	}	if (!messageContext.isResponse()) {	if (synLog.isTraceOrDebugEnabled()) {	
adding the message with message id into the message queue for sampling 

if (synLog.isTraceOrDebugEnabled()) {	}	messageQueue.add(messageContext);	} else {	synLog.auditWarn("Encountered a response message which will not be sampled");	}	OperationContext opCtx = ((Axis2MessageContext) messageContext).getAxis2MessageContext().getOperationContext();	if (opCtx != null) {	opCtx.setProperty(Constants.RESPONSE_WRITTEN, "SKIP");	}	
end sampler mediator 

public void run() {	if (log.isDebugEnabled()) {	
started running the message processor 

public void run() {	if (log.isDebugEnabled()) {	}	for (int i = 0; i < samplingRate && !messageQueue.isEmpty(); i++) {	MessageContext synCtx = messageQueue.get();	if (log.isDebugEnabled()) {	
mediating the message on the message queue with message id 

public void run() {	if (log.isDebugEnabled()) {	}	for (int i = 0; i < samplingRate && !messageQueue.isEmpty(); i++) {	MessageContext synCtx = messageQueue.get();	if (log.isDebugEnabled()) {	}	target.mediate(synCtx);	}	if (log.isDebugEnabled()) {	
message processing completed for the given sampling rate 

========================= synapse sample_1979 =========================

private void executeClientEngine() {	HttpParams params = getClientParameters();	try {	ioReactor = new DefaultConnectingIOReactor( NHttpConfiguration.getInstance().getClientIOWorkers(), params);	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	
system may be unstable ioreactor encountered a checked exception 

private void executeClientEngine() {	HttpParams params = getClientParameters();	try {	ioReactor = new DefaultConnectingIOReactor( NHttpConfiguration.getInstance().getClientIOWorkers(), params);	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	return true;	}	public boolean handle(RuntimeException runtimeException) {	
system may be unstable ioreactor encountered a runtime exception 

ioReactor = new DefaultConnectingIOReactor( NHttpConfiguration.getInstance().getClientIOWorkers(), params);	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	return true;	}	public boolean handle(RuntimeException runtimeException) {	return true;	}	});	} catch (IOException e) {	
error starting the ioreactor 

return true;	}	});	} catch (IOException e) {	}	handler = new ClientHandler(cfgCtx, params);	IOEventDispatch ioEventDispatch = getEventDispatch( handler, sslContext, sslIOSessionHandler, params);	try {	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	
reactor interrupted 

}	});	} catch (IOException e) {	}	handler = new ClientHandler(cfgCtx, params);	IOEventDispatch ioEventDispatch = getEventDispatch( handler, sslContext, sslIOSessionHandler, params);	try {	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	} catch (IOException e) {	
encountered an i o error 

});	} catch (IOException e) {	}	handler = new ClientHandler(cfgCtx, params);	IOEventDispatch ioEventDispatch = getEventDispatch( handler, sslContext, sslIOSessionHandler, params);	try {	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	} catch (IOException e) {	}	
sender shutdown 

} else if ("https".equals(url.getProtocol())) {	port = 443;	}	}	HttpHost httpHost = new HttpHost(url.getHost(), port, url.getProtocol());	Axis2HttpRequest axis2Req = new Axis2HttpRequest(epr, httpHost, msgContext);	NHttpClientConnection conn = ConnectionPool.getConnection(url.getHost(), port);	if (conn == null) {	ioReactor.connect(new InetSocketAddress(url.getHost(), port), null, axis2Req, sessionRequestCallback);	if (log.isDebugEnabled()) {	
a new connection established 

HttpHost httpHost = new HttpHost(url.getHost(), port, url.getProtocol());	Axis2HttpRequest axis2Req = new Axis2HttpRequest(epr, httpHost, msgContext);	NHttpClientConnection conn = ConnectionPool.getConnection(url.getHost(), port);	if (conn == null) {	ioReactor.connect(new InetSocketAddress(url.getHost(), port), null, axis2Req, sessionRequestCallback);	if (log.isDebugEnabled()) {	}	} else {	((ClientHandler) handler).submitRequest(conn, axis2Req);	if (log.isDebugEnabled()) {	
an existing connection reused 

public void stop() {	try {	ioReactor.shutdown();	
sender shut down 

public void stop() {	try {	ioReactor.shutdown();	} catch (IOException e) {	
error shutting down ioreactor 

if (isTimeout) {	axisFault = new AxisFault("The connection timed out");	} else {	Exception exception = request.getException();	axisFault = new AxisFault(exception.toString(), exception);	}	MessageContext nioFaultMessageContext = MessageContextBuilder.createFaultMessageContext(mc, axisFault);	nioFaultMessageContext.setProperty(NhttpConstants.SENDING_FAULT, Boolean.TRUE);	mr.receive(nioFaultMessageContext);	} catch (AxisFault af) {	
unable to report back failure to the message receiver 

========================= synapse sample_3769 =========================

public NativeWorkerPool(int core, int max, int keepAlive, int queueLength, String threadGroupName, String threadGroupId) {	if (log.isDebugEnabled()) {	
using native util concurrent package 

========================= synapse sample_3786 =========================

private boolean isHotDeploymentEnabled() {	try {	return getSynapseConfiguration().isAllowHotUpdate();	} catch (DeploymentException e) {	
error while retrieving the synapseconfiguration 

public void deploy(DeploymentFileData deploymentFileData) throws DeploymentException {	String filename = SynapseArtifactDeploymentStore.getNormalizedAbsolutePath( deploymentFileData.getAbsolutePath());	if (log.isDebugEnabled()) {	
deployment of the synapse artifact from file started 

public void deploy(DeploymentFileData deploymentFileData) throws DeploymentException {	String filename = SynapseArtifactDeploymentStore.getNormalizedAbsolutePath( deploymentFileData.getAbsolutePath());	if (log.isDebugEnabled()) {	}	if (getServerContextInformation().getServerState() != ServerState.STARTED) {	if (log.isDebugEnabled()) {	
skipped the artifact deployment since the synapse server doesn t seem to be started yet from file 

String filename = SynapseArtifactDeploymentStore.getNormalizedAbsolutePath( deploymentFileData.getAbsolutePath());	if (log.isDebugEnabled()) {	}	if (getServerContextInformation().getServerState() != ServerState.STARTED) {	if (log.isDebugEnabled()) {	}	return;	}	if (!isHotDeploymentEnabled()) {	if (log.isDebugEnabled()) {	
hot deployment has been suspended ignoring 

return;	}	if (!isHotDeploymentEnabled()) {	if (log.isDebugEnabled()) {	}	return;	}	SynapseArtifactDeploymentStore deploymentStore = getSynapseConfiguration().getArtifactDeploymentStore();	if (deploymentStore.isRestoredFile(filename)) {	if (log.isDebugEnabled()) {	
restored artifact detected with filename 

}	try {	InputStream in = FileUtils.openInputStream(new File(filename));	try {	OMElement element = OMXMLBuilderFactory.createOMBuilder(in).getDocumentElement();	Properties properties = new Properties();	properties.put(SynapseConstants.RESOLVE_ROOT, getSynapseEnvironment() .getServerContextInformation() .getServerConfigurationInformation().getResolveRoot());	String artifactName = null;	if (deploymentStore.isUpdatingArtifact(filename)) {	if (log.isDebugEnabled()) {	
updating artifact detected with filename 

properties.put(SynapseConstants.RESOLVE_ROOT, getSynapseEnvironment() .getServerContextInformation() .getServerConfigurationInformation().getResolveRoot());	String artifactName = null;	if (deploymentStore.isUpdatingArtifact(filename)) {	if (log.isDebugEnabled()) {	}	String existingArtifactName = deploymentStore.getUpdatingArtifactWithFileName(filename);	deploymentStore.removeUpdatingArtifact(filename);	try {	artifactName = updateSynapseArtifact( element, filename, existingArtifactName, properties);	} catch (SynapseArtifactDeploymentException sade) {	
update of the synapse artifact from file failed 

properties.put(SynapseConstants.RESOLVE_ROOT, getSynapseEnvironment() .getServerContextInformation() .getServerConfigurationInformation().getResolveRoot());	String artifactName = null;	if (deploymentStore.isUpdatingArtifact(filename)) {	if (log.isDebugEnabled()) {	}	String existingArtifactName = deploymentStore.getUpdatingArtifactWithFileName(filename);	deploymentStore.removeUpdatingArtifact(filename);	try {	artifactName = updateSynapseArtifact( element, filename, existingArtifactName, properties);	} catch (SynapseArtifactDeploymentException sade) {	
the updated file has been backed up into 

properties.put(SynapseConstants.RESOLVE_ROOT, getSynapseEnvironment() .getServerContextInformation() .getServerConfigurationInformation().getResolveRoot());	String artifactName = null;	if (deploymentStore.isUpdatingArtifact(filename)) {	if (log.isDebugEnabled()) {	}	String existingArtifactName = deploymentStore.getUpdatingArtifactWithFileName(filename);	deploymentStore.removeUpdatingArtifact(filename);	try {	artifactName = updateSynapseArtifact( element, filename, existingArtifactName, properties);	} catch (SynapseArtifactDeploymentException sade) {	
restoring the existing artifact into the file 

try {	artifactName = updateSynapseArtifact( element, filename, existingArtifactName, properties);	} catch (SynapseArtifactDeploymentException sade) {	restoreSynapseArtifact(existingArtifactName);	artifactName = existingArtifactName;	}	} else {	try {	artifactName = deploySynapseArtifact(element, filename, properties);	} catch (SynapseArtifactDeploymentException sade) {	
deployment of the synapse artifact from file failed 

try {	artifactName = updateSynapseArtifact( element, filename, existingArtifactName, properties);	} catch (SynapseArtifactDeploymentException sade) {	restoreSynapseArtifact(existingArtifactName);	artifactName = existingArtifactName;	}	} else {	try {	artifactName = deploySynapseArtifact(element, filename, properties);	} catch (SynapseArtifactDeploymentException sade) {	
the file has been backed up into 

}	} finally {	in.close();	}	} catch (IOException ex) {	handleDeploymentError("Deployment of synapse artifact failed. Error reading " + filename + " : " + ex.getMessage(), ex, filename);	} catch (OMException ex) {	handleDeploymentError("Deployment of synapse artifact failed. Error parsing " + filename + " : " + ex.getMessage(), ex, filename);	}	if (log.isDebugEnabled()) {	
deployment of the synapse artifact from file completed 

public void undeploy(String fileName) throws DeploymentException {	if (!isHotDeploymentEnabled()) {	if (log.isDebugEnabled()) {	
hot deployment has been suspended ignoring 

public void undeploy(String fileName) throws DeploymentException {	if (!isHotDeploymentEnabled()) {	if (log.isDebugEnabled()) {	}	return;	}	fileName = SynapseArtifactDeploymentStore.getNormalizedAbsolutePath(fileName);	if (log.isDebugEnabled()) {	
undeployment of the synapse artifact from file started 

if (log.isDebugEnabled()) {	}	return;	}	fileName = SynapseArtifactDeploymentStore.getNormalizedAbsolutePath(fileName);	if (log.isDebugEnabled()) {	}	SynapseArtifactDeploymentStore deploymentStore = getSynapseConfiguration().getArtifactDeploymentStore();	if (deploymentStore.isBackedUpArtifact(fileName)) {	if (log.isDebugEnabled()) {	
backedup artifact detected with filename 

if (deploymentStore.isBackedUpArtifact(fileName)) {	if (log.isDebugEnabled()) {	}	deploymentStore.removeBackedUpArtifact(fileName);	return;	}	if (deploymentStore.containsFileName(fileName)) {	File undeployingFile = new File(fileName);	if (undeployingFile.exists()) {	if (log.isDebugEnabled()) {	
marking artifact as updating from file 

if (!deploymentStore.isRestoredFile(fileName)) {	deploymentStore.addUpdatingArtifact( fileName, deploymentStore.getArtifactNameForFile(fileName));	deploymentStore.removeArtifactWithFileName(fileName);	}	} else {	String artifactName = deploymentStore.getArtifactNameForFile(fileName);	try {	undeploySynapseArtifact(artifactName);	deploymentStore.removeArtifactWithFileName(fileName);	} catch (SynapseArtifactDeploymentException sade) {	
unable to undeploy the artifact from file 

if (!deploymentStore.isRestoredFile(fileName)) {	deploymentStore.addUpdatingArtifact( fileName, deploymentStore.getArtifactNameForFile(fileName));	deploymentStore.removeArtifactWithFileName(fileName);	}	} else {	String artifactName = deploymentStore.getArtifactNameForFile(fileName);	try {	undeploySynapseArtifact(artifactName);	deploymentStore.removeArtifactWithFileName(fileName);	} catch (SynapseArtifactDeploymentException sade) {	
restoring the artifact into the file 

} catch (SynapseArtifactDeploymentException sade) {	restoreSynapseArtifact(artifactName);	}	}	} else {	String msg = "Artifact representing the filename " + fileName + " is not deployed on Synapse";	log.error(msg);	throw new DeploymentException(msg);	}	if (log.isDebugEnabled()) {	
undeployment of the synapse artifact from file completed 

private void handleDeploymentError(String msg, Exception e, String fileName) throws DeploymentException {	fileName = SynapseArtifactDeploymentStore.getNormalizedAbsolutePath(fileName);	log.error(msg, e);	SynapseArtifactDeploymentStore deploymentStore = getSynapseConfiguration().getArtifactDeploymentStore();	if (deploymentStore.isUpdatingArtifact(fileName)) {	backupFile(new File(fileName));	
restoring the existing artifact into the file 

========================= synapse sample_1611 =========================

}	if (messageID != null) {	AxisCallback callback = (AxisCallback) callbackStore.remove(messageID);	RelatesTo[] relates = messageCtx.getRelationships();	if (relates != null && relates.length > 1) {	removeDuplicateRelatesTo(messageCtx, relates);	}	if (callback != null) {	handleMessage(messageCtx, ((AsyncCallback) callback).getSynapseOutMsgCtx());	} else {	
synapse received a response for the request with message id but a callback is not registered anymore to process this response 

AxisCallback callback = (AxisCallback) callbackStore.remove(messageID);	RelatesTo[] relates = messageCtx.getRelationships();	if (relates != null && relates.length > 1) {	removeDuplicateRelatesTo(messageCtx, relates);	}	if (callback != null) {	handleMessage(messageCtx, ((AsyncCallback) callback).getSynapseOutMsgCtx());	} else {	}	} else if (!messageCtx.isPropertyTrue(NhttpConstants.SC_ACCEPTED)){	
synapse received a response message without a message id 

((FaultHandler) faultStack.pop()).handleFault(synapseOutMsgCtx, e);	}	}	}	} else {	Stack faultStack = synapseOutMsgCtx.getFaultStack();	if (faultStack !=null && !faultStack.isEmpty() && faultStack.peek() instanceof Endpoint) {	faultStack.pop();	}	if (log.isDebugEnabled()) {	
synapse received an asynchronous response message 

if (faultStack !=null && !faultStack.isEmpty() && faultStack.peek() instanceof Endpoint) {	faultStack.pop();	}	if (log.isDebugEnabled()) {	log.debug("Received To: " + (response.getTo() != null ? response.getTo().getAddress() : "null"));	log.debug("SOAPAction: " + (response.getSoapAction() != null ? response.getSoapAction() : "null"));	log.debug("WSA-Action: " + (response.getWSAAction() != null ? response.getWSAAction() : "null"));	String[] cids = response.getAttachmentMap().getAllContentIDs();	if (cids != null && cids.length > 0) {	for (int i = 0; i < cids.length; i++) {	
attachment 

}	if (log.isDebugEnabled()) {	log.debug("Received To: " + (response.getTo() != null ? response.getTo().getAddress() : "null"));	log.debug("SOAPAction: " + (response.getSoapAction() != null ? response.getSoapAction() : "null"));	log.debug("WSA-Action: " + (response.getWSAAction() != null ? response.getWSAAction() : "null"));	String[] cids = response.getAttachmentMap().getAllContentIDs();	if (cids != null && cids.length > 0) {	for (int i = 0; i < cids.length; i++) {	}	}	
body 

Object key = iter.next();	synapseInMessageContext.setProperty( (String) key, synapseOutMsgCtx.getProperty((String) key));	}	try {	synapseOutMsgCtx.getEnvironment().injectMessage(synapseInMessageContext);	} catch (SynapseException syne) {	Stack stack = synapseInMessageContext.getFaultStack();	if (stack != null && !stack.isEmpty()) {	((FaultHandler) stack.pop()).handleFault(synapseInMessageContext, syne);	} else {	
synapse encountered an exception no error handlers found message dropped 

========================= synapse sample_3505 =========================

private void scanFileOrDirectory(final PollTableEntry entry, String fileURI) {	FileObject fileObject = null;	if (log.isDebugEnabled()) {	
scanning directory or file 

}	boolean wasError = true;	int retryCount = 0;	int maxRetryCount = entry.getMaxRetryCount();	long reconnectionTimeout = entry.getReconnectTimeout();	while (wasError) {	try {	retryCount++;	fileObject = fsManager.resolveFile(fileURI);	if (fileObject == null) {	
fileobject is null 

fileObject = fsManager.resolveFile(fileURI);	if (fileObject == null) {	throw new FileSystemException("fileObject is null");	}	wasError = false;	} catch (FileSystemException e) {	if (retryCount >= maxRetryCount) {	processFailure("Repeatedly failed to resolve the file URI: " + VFSUtils.maskURLPassword(fileURI), e, entry);	return;	} else {	
failed to resolve the file uri in attempt retrying in milliseconds 

if (retryCount >= maxRetryCount) {	processFailure("Repeatedly failed to resolve the file URI: " + VFSUtils.maskURLPassword(fileURI), e, entry);	return;	} else {	}	}	if (wasError) {	try {	Thread.sleep(reconnectionTimeout);	} catch (InterruptedException e2) {	
thread was interrupted while waiting to reconnect 

moveOrDeleteAfterProcessing(entry, fileObject);	} catch (AxisFault axisFault) {	logException("File object '" + fileObject.getURL().toString() + "' " + "cloud not be moved", axisFault);	entry.setLastPollState(PollTableEntry.FAILED);	String timeStamp = VFSUtils.getSystemTime(entry.getFailedRecordTimestampFormat());	addFailedRecord(entry, fileObject, timeStamp);	}	if (entry.isFileLockingEnabled()) {	VFSUtils.releaseLock(fsManager, fileObject);	if (log.isDebugEnabled()) {	
removed the lock file lock of the file 

entry.setLastPollState(PollTableEntry.FAILED);	String timeStamp = VFSUtils.getSystemTime(entry.getFailedRecordTimestampFormat());	addFailedRecord(entry, fileObject, timeStamp);	}	if (entry.isFileLockingEnabled()) {	VFSUtils.releaseLock(fsManager, fileObject);	if (log.isDebugEnabled()) {	}	}	} else if (log.isDebugEnabled()) {	
couldn t get the lock for processing the file 

}	} else if (log.isDebugEnabled()) {	} else if (isFailedRecord) {	if (entry.isFileLockingEnabled()) {	VFSUtils.releaseLock(fsManager, fileObject);	}	if (fsManager.resolveFile(fileObject.getURL().toString()) != null && removeTaskState == STATE_STOPPED && entry.getMoveAfterMoveFailure() != null) {	workerPool.execute(new FileRemoveTask(entry, fileObject));	}	if (log.isDebugEnabled()) {	
file has been marked as a failed record it will not process 

workerPool.execute(new FileRemoveTask(entry, fileObject));	}	if (log.isDebugEnabled()) {	}	}	}	} else {	int failCount = 0;	int successCount = 0;	if (log.isDebugEnabled()) {	
file name pattern 

int successCount = 0;	if (log.isDebugEnabled()) {	}	for (FileObject child : children) {	boolean isFailedRecord = false;	if (entry.getMoveAfterMoveFailure() != null) {	isFailedRecord = isFailedRecord(child, entry);	}	if (entry.getFileNamePattern() != null && child.getName().getBaseName().matches(entry.getFileNamePattern())){	if (log.isDebugEnabled()) {	
matching file 

boolean isFailedRecord = false;	if (entry.getMoveAfterMoveFailure() != null) {	isFailedRecord = isFailedRecord(child, entry);	}	if (entry.getFileNamePattern() != null && child.getName().getBaseName().matches(entry.getFileNamePattern())){	if (log.isDebugEnabled()) {	}	if ((!entry.isFileLockingEnabled() || (entry.isFileLockingEnabled() && VFSUtils.acquireLock(fsManager, child))) && !isFailedRecord){	try {	if (log.isDebugEnabled()) {	
processing file 

String timeStamp = VFSUtils.getSystemTime(entry.getFailedRecordTimestampFormat());	addFailedRecord(entry, child, timeStamp);	} finally {	if (entry.isFileLockingEnabled()) {	VFSUtils.releaseLock(fsManager, child);	}	}	}	} else if (entry.getFileNamePattern()!= null && !child.getName().getBaseName().matches(entry.getFileNamePattern())){	if (log.isDebugEnabled()) {	
non matching file 

}	} else if(isFailedRecord){	if (entry.isFileLockingEnabled()) {	VFSUtils.releaseLock(fsManager, child);	VFSUtils.releaseLock(fsManager, fileObject);	}	if (fsManager.resolveFile(child.getURL().toString()) != null && removeTaskState == STATE_STOPPED && entry.getMoveAfterMoveFailure() != null) {	workerPool.execute(new FileRemoveTask(entry, child));	}	if (log.isDebugEnabled()) {	
file has been marked as a failed record it will not process 

} else if (successCount == 0 && failCount > 0) {	entry.setLastPollState(PollTableEntry.FAILED);	} else {	entry.setLastPollState(PollTableEntry.WITH_ERRORS);	}	}	long now = System.currentTimeMillis();	entry.setLastPollTime(now);	entry.setNextPollTime(now + entry.getPollInterval());	} else if (log.isDebugEnabled()) {	
unable to access or read file or directory reason unknown reason the file can not be read the file does not exists 

if (moveToDirectoryURI != null) {	FileObject moveToDirectory = fsManager.resolveFile(moveToDirectoryURI);	String prefix;	if(entry.getMoveTimestampFormat() != null) {	prefix = entry.getMoveTimestampFormat().format(new Date());	} else {	prefix = "";	}	FileObject dest = moveToDirectory.resolveFile( prefix + fileObject.getName().getBaseName());	if (log.isDebugEnabled()) {	
moving to file 

if (log.isDebugEnabled()) {	}	try {	fileObject.moveTo(dest);	} catch (FileSystemException e) {	handleException("Error moving file : " + fileObject + " to " + moveToDirectoryURI, e);	}	} else {	try {	if (log.isDebugEnabled()) {	
deleting file 

try {	if (log.isDebugEnabled()) {	}	fileObject.close();	if (!fileObject.delete()) {	String msg = "Cannot delete file : " + fileObject;	log.error(msg);	throw new AxisFault(msg);	}	} catch (FileSystemException e) {	
error deleting file 

fileObject.close();	if (!fileObject.delete()) {	String msg = "Cannot delete file : " + fileObject;	log.error(msg);	throw new AxisFault(msg);	}	} catch (FileSystemException e) {	}	}	} catch (FileSystemException e) {	
error resolving directory to move after processing 

} else if (VFSUtils.getProperty( content, BaseConstants.CONTENT_TYPE) != null) {	contentType = VFSUtils.getProperty(content, BaseConstants.CONTENT_TYPE);	}	}	String replyFileURI = entry.getReplyFileURI();	if (replyFileURI != null) {	msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, new VFSOutTransportInfo(replyFileURI, entry.isFileLockingEnabled()));	}	Builder builder;	if (contentType == null) {	
no content type specified using soap builder 

}	Builder builder;	if (contentType == null) {	builder = new SOAPBuilder();	} else {	int index = contentType.indexOf(';');	String type = index > 0 ? contentType.substring(0, index) : contentType;	builder = BuilderUtil.getBuilderFromSelector(type, msgContext);	if (builder == null) {	if (log.isDebugEnabled()) {	
no message builder found for type falling back to soap 

documentElement = ((DataSourceMessageBuilder)builder).processDocument( dataSource, contentType, msgContext);	}	msgContext.setEnvelope(TransportUtils.createSOAPEnvelope(documentElement));	handleIncomingMessage( msgContext, transportHeaders, null, contentType );	} finally {	if (dataSource != null) {	dataSource.destroy();	}	}	if (log.isDebugEnabled()) {	
processed file of content type 

private synchronized void addFailedRecord(PollTableEntry pollTableEntry, FileObject failedObject, String timeString) {	try {	String record = failedObject.getName().getBaseName() + VFSConstants.FAILED_RECORD_DELIMITER + timeString;	String recordFile = pollTableEntry.getFailedRecordFileDestination() + pollTableEntry.getFailedRecordFileName();	File failedRecordFile = new File(recordFile);	if (!failedRecordFile.exists()) {	FileUtils.writeStringToFile(failedRecordFile, record);	if (log.isDebugEnabled()) {	
added fail record into the record file 

if (log.isDebugEnabled()) {	}	} else {	List<String> content = FileUtils.readLines(failedRecordFile);	if (!content.contains(record)) {	content.add(record);	}	FileUtils.writeLines(failedRecordFile, content);	}	} catch (IOException e) {	
failure while writing the failed records 

List list = FileUtils.readLines(file);	for (Object aList : list) {	String str = (String) aList;	StringTokenizer st = new StringTokenizer(str, VFSConstants.FAILED_RECORD_DELIMITER);	String fileName = st.nextToken();	if (fileName != null && fileName.equals(fileObject.getName().getBaseName())) {	return true;	}	}	} catch (IOException e) {	
error while reading the file 

public void run() {	if (log.isDebugEnabled()) {	
new file remove task is starting thread id 

int nextRetryDuration = pollTableEntry.getNextRetryDuration();	int count = 0;	while (!isDeletionSucceed) {	try {	reTryFailedMove(pollTableEntry, failedFileObject);	isDeletionSucceed = true;	removeTaskState = STATE_STOPPED;	} catch (AxisFault axisFault) {	removeTaskState = STATE_RUNNING;	try {	
remove attempt failed for the file next re try will be after milliseconds 

int count = 0;	while (!isDeletionSucceed) {	try {	reTryFailedMove(pollTableEntry, failedFileObject);	isDeletionSucceed = true;	removeTaskState = STATE_STOPPED;	} catch (AxisFault axisFault) {	removeTaskState = STATE_RUNNING;	try {	} catch (FileSystemException e) {	
error while retrying the file url of the file object 

moveToDirectory.createFolder();	}	String prefix;	if (entry.getMoveTimestampFormat() != null) {	prefix = entry.getMoveTimestampFormat().format(new Date());	} else {	prefix = "";	}	FileObject dest = moveToDirectory.resolveFile( prefix + fileObject.getName().getBaseName());	if (log.isDebugEnabled()) {	
the failed file is moving to 

========================= synapse sample_2314 =========================

public void testCreateFaultAndChangeDirection() {	String addUrl = "http: String trpUrl = "http: String expectedError_MSFT = "Error while connecting to the endpoint (Connection Failed)";	String expectedError_SUN = "Error while connecting to the endpoint (Connection Failed)";	StockQuoteSampleClient client = getStockQuoteClient();	
running test creating soap fault messages and changing the direction of a message 

public void testCreateFaultAndChangeDirection() {	String addUrl = "http: String trpUrl = "http: String expectedError_MSFT = "Error while connecting to the endpoint (Connection Failed)";	String expectedError_SUN = "Error while connecting to the endpoint (Connection Failed)";	StockQuoteSampleClient client = getStockQuoteClient();	SampleClientResult result = client.requestStandardQuote(addUrl, trpUrl, null, "MSFT" ,null);	assertFalse("Must not get a response", result.responseReceived());	Exception resultEx = result.getException();	assertNotNull("Did not receive expected error", resultEx);	
got an error as expected 

SampleClientResult result = client.requestStandardQuote(addUrl, trpUrl, null, "MSFT" ,null);	assertFalse("Must not get a response", result.responseReceived());	Exception resultEx = result.getException();	assertNotNull("Did not receive expected error", resultEx);	assertTrue("Did not receive expected error", resultEx instanceof AxisFault);	assertTrue("Did not receive expected error", resultEx.getMessage().indexOf(expectedError_MSFT) != -1);	result = client.requestStandardQuote(addUrl, trpUrl, null, "SUN" ,null);	assertFalse("Must not get a response", result.responseReceived());	resultEx = result.getException();	assertNotNull("Did not receive expected error", resultEx);	
got an error as expected 

result = client.requestStandardQuote(addUrl, trpUrl, null, "SUN" ,null);	assertFalse("Must not get a response", result.responseReceived());	resultEx = result.getException();	assertNotNull("Did not receive expected error", resultEx);	assertTrue("Did not receive expected error", resultEx instanceof AxisFault);	assertTrue("Did not receive expected error", resultEx.getMessage().indexOf(expectedError_SUN) != -1);	result = client.requestStandardQuote(addUrl, trpUrl, null, "IBM" ,null);	assertFalse("Must not get a response", result.responseReceived());	resultEx = result.getException();	assertNotNull("Did not receive expected error", resultEx);	
got an error as expected 

========================= synapse sample_849 =========================

public boolean matches(String value) {	if (value == null) {	
provided character sequence for switch case condition is null switch case will not be executed 

public boolean matches(String value) {	if (value == null) {	return false;	}	Matcher matcher = regex.matcher(value);	if (matcher == null) {	
matcher for the provided character sequence and the pattern cannot be found switch case will not be executed 

========================= synapse sample_1742 =========================

public void init(ConfigurationContext cfgCtx, TransportOutDescription transportOut) throws AxisFault {	super.init(cfgCtx, transportOut);	this.sessionFactory = FIXSessionFactory.getInstance(new FIXApplicationFactory(cfgCtx));	this.workerPool = WorkerPoolFactory.getWorkerPool( 10, 20, 5, -1, "FIX Sender Worker thread group", "FIX-Worker");	this.sessionFactory.setSenderThreadPool(this.workerPool);	messageSender = new FIXOutgoingMessageHandler();	messageSender.setSessionFactory(this.sessionFactory);	
fix transport sender initialized 

public void stop() {	try {	this.workerPool.shutdown(10000);	} catch (InterruptedException e) {	
thread interrupted while waiting for worker pool to shut down 

public void sendMessage(MessageContext msgCtx, String targetEPR, OutTransportInfo outTransportInfo) throws AxisFault {	if (log.isDebugEnabled()) {	
attempting to send a fix message message id 

setDeliverToXFields(fixMessage, targetEPR);	}	}	if (!Session.doesSessionExist(sessionID)) {	sessionFactory.createFIXInitiator(targetEPR, service, sessionID);	}	try {	messageSender.sendMessage(fixMessage, sessionID, srcSession, counter, msgCtx, targetEPR);	return true;	} catch (SessionNotFound e) {	
error while sending the fix message session does not exist 

prepareToForwardMessage(fixMessage, fieldValues);	setDeliverToXFields(fixMessage, service);	}	} else {	setDeliverToXFields(fixMessage, fieldValues);	}	try {	messageSender.sendMessage(fixMessage, sessionID, srcSession, counter, msgCtx, null);	return true;	} catch (SessionNotFound e) {	
error while sending the fix message session does not exist 

========================= synapse sample_2494 =========================

public void destroy() {	if (taskDescription == null) {	if (log.isDebugEnabled()) {	
there is no task to be deleted 

public void init(SynapseEnvironment synapseEnvironment) {	if (taskDescription == null) {	handleException("Error while initializing the startup. TaskDescription is null.");	}	taskManager = synapseEnvironment.getTaskManager();	if (!taskManager.isInitialized()) {	
synapsetaskmanager is not properly initialized initializing now with default parameters 

handleException("Task Description Repository cannot be found");	return;	}	repository.addTaskDescription(taskDescription);	String thisServerName = synapseEnvironment.getServerContextInformation() .getServerConfigurationInformation().getServerName();	if (thisServerName == null || thisServerName.equals("")) {	try {	InetAddress address = InetAddress.getLocalHost();	thisServerName = address.getHostName();	} catch (UnknownHostException e) {	
could not get the host name 

if (thisServerName == null || thisServerName.equals("")) {	try {	InetAddress address = InetAddress.getLocalHost();	thisServerName = address.getHostName();	} catch (UnknownHostException e) {	}	if (thisServerName == null || thisServerName.equals("")) {	thisServerName = "localhost";	}	}	
synapse server name 

thisServerName = address.getHostName();	} catch (UnknownHostException e) {	}	if (thisServerName == null || thisServerName.equals("")) {	thisServerName = "localhost";	}	}	List pinnedServers = taskDescription.getPinnedServers();	if (pinnedServers != null && !pinnedServers.isEmpty()) {	if (!pinnedServers.contains(thisServerName)) {	
server name not in pinned servers list not starting task 

}	}	try {	task = (Task) getClass().getClassLoader().loadClass( taskDescription.getTaskClass()).newInstance();	} catch (Exception e) {	handleException("Cannot instantiate task : " + taskDescription.getTaskClass(), e);	}	Set properties = taskDescription.getProperties();	for (Object property : properties) {	OMElement prop = (OMElement) property;	
found property 

map.put(SimpleQuartzJob.SYNAPSE_ENVIRONMENT, synapseEnvironment);	try {	TaskScheduler taskScheduler = taskManager.getTaskScheduler();	if (taskScheduler != null) {	if (!taskScheduler.isInitialized()) {	taskScheduler.init(synapseEnvironment.getSynapseConfiguration().getProperties());	}	taskScheduler.scheduleTask(taskDescription, map, SimpleQuartzJob.class, task);	} else {	if (log.isDebugEnabled()) {	
taskscheduler cannot be found for therefore ignore scheduling of task 

========================= synapse sample_625 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
template deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	OMElement element = artifactConfig.getFirstChildWithName( new QName(SynapseConstants.SYNAPSE_NAMESPACE, "endpoint"));	if (element != null) {	org.apache.synapse.config.xml.endpoints.TemplateFactory templateFactory = new org.apache.synapse.config.xml.endpoints.TemplateFactory();	Template tm = templateFactory.createEndpointTemplate(artifactConfig, properties);	tm.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	
endpoint template named has been built from the file 

try {	OMElement element = artifactConfig.getFirstChildWithName( new QName(SynapseConstants.SYNAPSE_NAMESPACE, "endpoint"));	if (element != null) {	org.apache.synapse.config.xml.endpoints.TemplateFactory templateFactory = new org.apache.synapse.config.xml.endpoints.TemplateFactory();	Template tm = templateFactory.createEndpointTemplate(artifactConfig, properties);	tm.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEndpointTemplate(tm.getName(), tm);	if (log.isDebugEnabled()) {	
template deployment from file completed 

OMElement element = artifactConfig.getFirstChildWithName( new QName(SynapseConstants.SYNAPSE_NAMESPACE, "endpoint"));	if (element != null) {	org.apache.synapse.config.xml.endpoints.TemplateFactory templateFactory = new org.apache.synapse.config.xml.endpoints.TemplateFactory();	Template tm = templateFactory.createEndpointTemplate(artifactConfig, properties);	tm.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEndpointTemplate(tm.getName(), tm);	if (log.isDebugEnabled()) {	}	
endpoint template named has been deployed from file 

}	return tm.getName();	} else {	element = artifactConfig.getFirstChildWithName( new QName(SynapseConstants.SYNAPSE_NAMESPACE, "sequence"));	if (element != null) {	Mediator mediator = MediatorFactoryFinder.getInstance(). getMediator(artifactConfig, properties);	if (mediator instanceof TemplateMediator) {	TemplateMediator tm = (TemplateMediator) mediator;	tm.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
sequence template named has been built from the file 

element = artifactConfig.getFirstChildWithName( new QName(SynapseConstants.SYNAPSE_NAMESPACE, "sequence"));	if (element != null) {	Mediator mediator = MediatorFactoryFinder.getInstance(). getMediator(artifactConfig, properties);	if (mediator instanceof TemplateMediator) {	TemplateMediator tm = (TemplateMediator) mediator;	tm.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	tm.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	
initialized the template 

if (mediator instanceof TemplateMediator) {	TemplateMediator tm = (TemplateMediator) mediator;	tm.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	tm.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addSequenceTemplate(tm.getName(), tm);	if (log.isDebugEnabled()) {	
template deployment from file completed 

TemplateMediator tm = (TemplateMediator) mediator;	tm.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	tm.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addSequenceTemplate(tm.getName(), tm);	if (log.isDebugEnabled()) {	}	
template named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
template update from file has started 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	OMElement element = artifactConfig.getFirstChildWithName( new QName(SynapseConstants.SYNAPSE_NAMESPACE, "endpoint"));	if (element != null) {	org.apache.synapse.config.xml.endpoints.TemplateFactory templateFactory = new org.apache.synapse.config.xml.endpoints.TemplateFactory();	Template tm = templateFactory.createEndpointTemplate(artifactConfig, properties);	tm.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	
endpoint template named has been built from the file 

Template tm = templateFactory.createEndpointTemplate(artifactConfig, properties);	tm.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	Template existingSt = getSynapseConfiguration(). getEndpointTemplate(existingArtifactName);	if (existingArtifactName.equals(tm.getName())) {	getSynapseConfiguration().updateEndpointTemplate(tm.getName(), tm);	} else {	getSynapseConfiguration().addEndpointTemplate(tm.getName(), tm);	getSynapseConfiguration().removeEndpointTemplate(existingSt.getName());	
template has been undeployed 

tm.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	Template existingSt = getSynapseConfiguration(). getEndpointTemplate(existingArtifactName);	if (existingArtifactName.equals(tm.getName())) {	getSynapseConfiguration().updateEndpointTemplate(tm.getName(), tm);	} else {	getSynapseConfiguration().addEndpointTemplate(tm.getName(), tm);	getSynapseConfiguration().removeEndpointTemplate(existingSt.getName());	}	
template has been updated from the file 

}	return tm.getName();	} else {	element = artifactConfig.getFirstChildWithName( new QName(SynapseConstants.SYNAPSE_NAMESPACE, "sequence"));	if (element != null) {	Mediator mediator = MediatorFactoryFinder.getInstance(). getMediator(artifactConfig, properties);	if (mediator instanceof TemplateMediator) {	TemplateMediator tm = (TemplateMediator) mediator;	tm.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
sequence template named has been built from the file 

element = artifactConfig.getFirstChildWithName( new QName(SynapseConstants.SYNAPSE_NAMESPACE, "sequence"));	if (element != null) {	Mediator mediator = MediatorFactoryFinder.getInstance(). getMediator(artifactConfig, properties);	if (mediator instanceof TemplateMediator) {	TemplateMediator tm = (TemplateMediator) mediator;	tm.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	tm.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	
initialized the template 

}	tm.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	TemplateMediator existingSt = getSynapseConfiguration(). getSequenceTemplate(existingArtifactName);	if (existingArtifactName.equals(tm.getName())) {	getSynapseConfiguration().updateSequenceTemplate(tm.getName(), tm);	} else {	getSynapseConfiguration().addSequenceTemplate(tm.getName(), tm);	getSynapseConfiguration().removeSequenceTemplate(existingSt.getName());	
template has been undeployed 

if (log.isDebugEnabled()) {	}	TemplateMediator existingSt = getSynapseConfiguration(). getSequenceTemplate(existingArtifactName);	if (existingArtifactName.equals(tm.getName())) {	getSynapseConfiguration().updateSequenceTemplate(tm.getName(), tm);	} else {	getSynapseConfiguration().addSequenceTemplate(tm.getName(), tm);	getSynapseConfiguration().removeSequenceTemplate(existingSt.getName());	}	existingSt.destroy();	
template has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
template undeployment of the template named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	Template st = null;	try {	st = getSynapseConfiguration().getEndpointTemplate(artifactName);	} catch (SynapseException e) {	if (e.getMessage().indexOf("Cannot locate an either local or remote entry for key") != -1) {	if (log.isDebugEnabled()) {	
undeploying template is not of endpoint type undeployer will now check for sequence template for the key 

if (e.getMessage().indexOf("Cannot locate an either local or remote entry for key") != -1) {	if (log.isDebugEnabled()) {	}	} else {	throw e;	}	}	if (st != null) {	getSynapseConfiguration().removeEndpointTemplate(artifactName);	if (log.isDebugEnabled()) {	
destroying the template named 

}	} else {	throw e;	}	}	if (st != null) {	getSynapseConfiguration().removeEndpointTemplate(artifactName);	if (log.isDebugEnabled()) {	}	if (log.isDebugEnabled()) {	
template undeployment of the template named completed 

} else {	throw e;	}	}	if (st != null) {	getSynapseConfiguration().removeEndpointTemplate(artifactName);	if (log.isDebugEnabled()) {	}	if (log.isDebugEnabled()) {	}	
template named has been undeployed 

getSynapseConfiguration().removeEndpointTemplate(artifactName);	if (log.isDebugEnabled()) {	}	if (log.isDebugEnabled()) {	}	} else {	TemplateMediator tm = getSynapseConfiguration().getSequenceTemplate(artifactName);	if (tm != null) {	getSynapseConfiguration().removeSequenceTemplate(artifactName);	if (log.isDebugEnabled()) {	
destroying the template named 

if (log.isDebugEnabled()) {	}	} else {	TemplateMediator tm = getSynapseConfiguration().getSequenceTemplate(artifactName);	if (tm != null) {	getSynapseConfiguration().removeSequenceTemplate(artifactName);	if (log.isDebugEnabled()) {	}	tm.destroy();	if (log.isDebugEnabled()) {	
template undeployment of the template named completed 

}	} else {	TemplateMediator tm = getSynapseConfiguration().getSequenceTemplate(artifactName);	if (tm != null) {	getSynapseConfiguration().removeSequenceTemplate(artifactName);	if (log.isDebugEnabled()) {	}	tm.destroy();	if (log.isDebugEnabled()) {	}	
template named has been undeployed 

} else {	TemplateMediator tm = getSynapseConfiguration().getSequenceTemplate(artifactName);	if (tm != null) {	getSynapseConfiguration().removeSequenceTemplate(artifactName);	if (log.isDebugEnabled()) {	}	tm.destroy();	if (log.isDebugEnabled()) {	}	} else {	
template task has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the template with name started 

}	try {	Template st = getSynapseConfiguration().getEndpointTemplate(artifactName);	if (st != null) {	TemplateSerializer ts = new TemplateSerializer();	OMElement stElem = ts.serializeEndpointTemplate(st, null);	if (st.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.TEMPLATES_DIR + File.separator + st.getFileName();	writeToFile(stElem, fileName);	if (log.isDebugEnabled()) {	
restoring the endpoint template with name completed 

try {	Template st = getSynapseConfiguration().getEndpointTemplate(artifactName);	if (st != null) {	TemplateSerializer ts = new TemplateSerializer();	OMElement stElem = ts.serializeEndpointTemplate(st, null);	if (st.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.TEMPLATES_DIR + File.separator + st.getFileName();	writeToFile(stElem, fileName);	if (log.isDebugEnabled()) {	}	
template named has been restored 

}	} else {	TemplateMediator mt = getSynapseConfiguration().getSequenceTemplate(artifactName);	if (mt != null) {	TemplateMediatorSerializer ts = new TemplateMediatorSerializer();	OMElement stElem = ts.serializeMediator(null, mt);	if (mt.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.TEMPLATES_DIR + File.separator + mt.getFileName();	writeToFile(stElem, fileName);	if (log.isDebugEnabled()) {	
restoring the sequence template with name completed 

} else {	TemplateMediator mt = getSynapseConfiguration().getSequenceTemplate(artifactName);	if (mt != null) {	TemplateMediatorSerializer ts = new TemplateMediatorSerializer();	OMElement stElem = ts.serializeMediator(null, mt);	if (mt.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.TEMPLATES_DIR + File.separator + mt.getFileName();	writeToFile(stElem, fileName);	if (log.isDebugEnabled()) {	}	
template named has been restored 

========================= synapse sample_1607 =========================

private static synchronized void initializeSynapse(MessageContext mc) {	if (getSynapseConfig(mc) != null && getSynapseEnvironment(mc) != null) {	return;	}	
synapse config not available creating 

========================= synapse sample_2752 =========================

public String getMessageTextPayload(Object message) {	try {	return new String( getBytesFromInputStream(getInputStream(message), (int) ((FileContent) message).getSize()));	} catch (Exception e) {	if (log.isDebugEnabled()) {	
error reading message payload as text for 

========================= synapse sample_4239 =========================

synCtx.setProperty(SynapseConstants.RESPONSE, Boolean.TRUE);	synCtx.setResponse(true);	} else {	synCtx.setProperty(SynapseConstants.RESPONSE, Boolean.FALSE);	synCtx.setResponse(false);	}	try {	if (synCtx.getEnvironment().injectMessage(synCtx)) {	return InvocationResponse.CONTINUE;	} else {	
synapse has decided to abort the message 

try {	if (synCtx.getEnvironment().injectMessage(synCtx)) {	return InvocationResponse.CONTINUE;	} else {	return InvocationResponse.ABORT;	}	} catch (SynapseException syne) {	if (!synCtx.getFaultStack().isEmpty()) {	((FaultHandler) synCtx.getFaultStack().pop()).handleFault(synCtx, syne);	} else {	
synapse encountered an exception no error handlers found 

========================= synapse sample_3905 =========================

public void testScheduledTaskInjectToProxy() throws Exception {	
waiting seconds for the task to run 

public void testScheduledTaskInjectToProxy() throws Exception {	Thread.sleep(10000);	int messageCount = getAxis2Server().getMessageCount("SimpleStockQuoteService", "getQuote");	
task sent messages 

========================= synapse sample_2247 =========================

public void send(MessageContext synCtx) {	if (log.isDebugEnabled()) {	
start session affinity load balance endpoint 

RelayUtils.buildMessage(((Axis2MessageContext) synCtx).getAxis2MessageContext(),false);	} catch (Exception e) {	handleException("Error while building message", e);	}	}	evaluateProperties(synCtx);	if (sessionInformation == null && endpoints == null) {	sessionInformation = dispatcher.getSession(synCtx);	if (sessionInformation != null) {	if (log.isDebugEnabled()) {	
current session id 

}	}	evaluateProperties(synCtx);	if (sessionInformation == null && endpoints == null) {	sessionInformation = dispatcher.getSession(synCtx);	if (sessionInformation != null) {	if (log.isDebugEnabled()) {	}	endpoints = dispatcher.getEndpoints(sessionInformation);	if (log.isDebugEnabled()) {	
endpoint sequence path on current session 

} else {	endpoint = endpoints.remove(0);	}	}	if (invalidSequence) {	informFailure(synCtx, SynapseConstants.ENDPOINT_SAL_INVALID_PATH, "Invalid endpoint sequence " + endpoints + " for session with id " + sessionID);	return;	}	if (endpoint != null && endpoint.readyToSend()) {	if (log.isDebugEnabled()) {	
using the endpoint for sending the message 

========================= synapse sample_222 =========================

public void createLocalRegistry(int port) {	try {	String key = toKey(port);	synchronized (registriesCache) {	if (registriesCache.containsKey(key)) {	if (log.isDebugEnabled()) {	
there is an rmi registry bound to given port 

public void removeLocalRegistry(int port) {	String key = toKey(port);	synchronized (registriesCache) {	if (registriesCache.containsKey(key)) {	removeRegistry(key, registriesCache.get(key));	} else {	if (log.isDebugEnabled()) {	
there is no rmi registry for port 

private void removeRegistry(String key, Registry registry) {	if (registry != null) {	synchronized (registriesCache) {	try {	
removing the rmi registry bound to port 

========================= synapse sample_2139 =========================

public void init(SynapseEnvironment se) {	if (log.isDebugEnabled()) {	
initializing resource with id 

public void destroy() {	if (log.isDebugEnabled()) {	
destroying resource with id 

========================= synapse sample_672 =========================

public void receive(org.apache.axis2.context.MessageContext mc) throws AxisFault {	
synapse received a new message 

public void receive(org.apache.axis2.context.MessageContext mc) throws AxisFault {	log.debug("Received To: " + (mc.getTo() != null ? mc.getTo().getAddress() : "null"));	log.debug("SOAPAction: " + (mc.getWSAAction() != null ? mc.getWSAAction() : "null"));	if (log.isDebugEnabled()) {	
body 

========================= synapse sample_2990 =========================

public LSInput resolveResource(String type, String namespaceURI, String publicId, String systemId, String baseURI) {	if (log.isDebugEnabled()) {	
resolving schema resource 

public LSInput resolveResource(String type, String namespaceURI, String publicId, String systemId, String baseURI) {	if (log.isDebugEnabled()) {	}	if (resourceMap == null) {	
unable to resolve schema resource systemid external schema resources not defined in validate mediator configuration 

public LSInput resolveResource(String type, String namespaceURI, String publicId, String systemId, String baseURI) {	if (log.isDebugEnabled()) {	}	if (resourceMap == null) {	return null;	}	InputSource inputSource = resourceMap.resolve(synCfg, systemId);	if (inputSource == null) {	
unable to resolve schema resource 

========================= synapse sample_1715 =========================

public void send(MessageContext synCtx) {	if (log.isDebugEnabled()) {	
start session affinity load balance endpoint 

RelayUtils.buildMessage(((Axis2MessageContext) synCtx).getAxis2MessageContext(),false);	} catch (Exception e) {	handleException("Error while building message", e);	}	}	evaluateProperties(synCtx);	if (sessionInformation == null && endpoints == null) {	sessionInformation = dispatcher.getSession(synCtx);	if (sessionInformation != null) {	if (log.isDebugEnabled()) {	
current session id 

}	}	evaluateProperties(synCtx);	if (sessionInformation == null && endpoints == null) {	sessionInformation = dispatcher.getSession(synCtx);	if (sessionInformation != null) {	if (log.isDebugEnabled()) {	}	endpoints = dispatcher.getEndpoints(sessionInformation);	if (log.isDebugEnabled()) {	
endpoint sequence path on current session 

} else {	endpoint = endpoints.remove(0);	}	}	if (invalidSequence) {	informFailure(synCtx, SynapseConstants.ENDPOINT_SAL_INVALID_PATH, "Invalid endpoint sequence " + endpoints + " for session with id " + sessionID);	return;	}	if (endpoint != null && endpoint.readyToSend()) {	if (log.isDebugEnabled()) {	
using the endpoint for sending the message 

========================= synapse sample_1650 =========================

private static void handleConfigurationError(String componentType, String msg) {	if (SynapseConfigUtils.isFailSafeEnabled(componentType)) {	
continue in fail safe mode 

private static void handleConfigurationError(String componentType, String msg, Exception e) {	if (SynapseConfigUtils.isFailSafeEnabled(componentType)) {	
continue in fail safe mode 

========================= synapse sample_367 =========================

public void testXQuery() {	String addUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to the xquery mediator 

========================= synapse sample_808 =========================

public void execute(JobExecutionContext ctx) throws JobExecutionException {	
executing task 

Task task = null;	try {	task = (Task) getClass().getClassLoader().loadClass(jobClassName).newInstance();	} catch (Exception e) {	handleException("Cannot instantiate task : " + jobClassName, e);	}	Set properties = (Set) jdm.get(PROPERTIES);	Iterator it = properties.iterator();	while (it.hasNext()) {	OMElement prop = (OMElement) it.next();	
found property 

========================= synapse sample_4219 =========================

File synapseConfigLocation = new File(configFile);	if (!synapseConfigLocation.exists()) {	String message = "Unable to load the Synapse configuration from : " + configFile + ". Specified file not found";	log.fatal(message);	throw new SynapseException(message);	}	SynapseConfiguration synCfg = null;	if (synapseConfigLocation.isFile()) {	try {	synCfg = XMLConfigurationBuilder.getConfiguration( new FileInputStream(configFile), properties);	
loaded synapse configuration from 

}	SynapseConfiguration synCfg = null;	if (synapseConfigLocation.isFile()) {	try {	synCfg = XMLConfigurationBuilder.getConfiguration( new FileInputStream(configFile), properties);	} catch (Exception e) {	handleException("Could not initialize Synapse : " + e.getMessage(), e);	}	} else if (synapseConfigLocation.isDirectory()) {	synCfg = MultiXMLConfigurationBuilder.getConfiguration(configFile, properties);	
loaded synapse configuration from the artifact repository at 

handleException("Could not initialize Synapse : " + e.getMessage(), e);	}	} else if (synapseConfigLocation.isDirectory()) {	synCfg = MultiXMLConfigurationBuilder.getConfiguration(configFile, properties);	}	assert synCfg != null;	synCfg.setPathToConfigFile(new File(configFile).getAbsolutePath());	Registry localConfigReg = synCfg.getRegistry();	if (synCfg.getLocalRegistry().isEmpty() && synCfg.getProxyServices().isEmpty() && localConfigReg != null) {	if (log.isDebugEnabled()) {	
only the registry is defined in the synapse configuration trying to fetch a configuration from the registry 

if (synCfg.getLocalRegistry().isEmpty() && synCfg.getProxyServices().isEmpty() && localConfigReg != null) {	if (log.isDebugEnabled()) {	}	OMNode remoteConfigNode = localConfigReg.lookup("synapse.xml");	if (remoteConfigNode != null) {	try {	synCfg = XMLConfigurationBuilder.getConfiguration(SynapseConfigUtils .getStreamSource(remoteConfigNode).getInputStream(), properties);	if (synCfg.getRegistry() == null) {	synCfg.setRegistry(localConfigReg);	} else {	
registry declaration has been overwritten by the registry declaration found at the remote configuration 

try {	synCfg = XMLConfigurationBuilder.getConfiguration(SynapseConfigUtils .getStreamSource(remoteConfigNode).getInputStream(), properties);	if (synCfg.getRegistry() == null) {	synCfg.setRegistry(localConfigReg);	} else {	}	} catch (XMLStreamException xse) {	throw new SynapseException("Problem loading remote synapse.xml ", xse);	}	} else if (log.isDebugEnabled()) {	
couldn t find a synapse configuration on the registry 

========================= synapse sample_486 =========================

public void testDynamicEndPoints() {	String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test dynamic endpoints with registry 

========================= synapse sample_2267 =========================

private void registerExtensions() {	
registering extensions 

private void registerExtensions() {	
java class path 

private void registerExtensions() {	Iterator it = Service.providers(MediatorFactory.class);	while (it.hasNext()) {	MediatorFactory mf = (MediatorFactory) it.next();	QName tag = mf.getTagQName();	factoryMap.put(tag, mf.getClass());	
added mediatorfactory to handle 

public Mediator getMediator(OMElement element) {	QName qName = new QName(element.getNamespace().getName(), element.getLocalName());	
getmediator 

========================= synapse sample_2772 =========================

private void verifyMediationResult(String scenario, BasicHttpClient client, StringBuilder message, int childrenCount, String sizeStr, Map<String,String> headers) throws Exception {	
testing payload size 

assertEquals(HttpStatus.SC_OK, response.getStatus());	OMElement body = response.getBodyAsXML();	assertEquals("foo", body.getLocalName());	Iterator childElements = body.getChildrenWithLocalName("bar");	int returnedChildren = 0;	while (childElements.hasNext()) {	returnedChildren++;	childElements.next();	}	assertEquals(childrenCount, returnedChildren);	
success 

========================= synapse sample_2288 =========================

MessageContext synCtx = MessageContextCreatorForAxis2.getSynapseMessageContext(mc);	StatisticsReporter.reportForComponent(synCtx, proxy.getAspectConfiguration(), ComponentType.PROXYSERVICE);	Log serviceLog = logFactory.getInstance(SynapseConstants.SERVICE_LOGGER_PREFIX + name);	((Axis2MessageContext) synCtx).setServiceLog(serviceLog);	synCtx.setProperty(SynapseConstants.PROXY_SERVICE, name);	synCtx.setTracingState(proxy.getTraceState());	try {	Mediator mandatorySeq = synCtx.getConfiguration().getMandatorySequence();	if (mandatorySeq != null) {	if (log.isDebugEnabled()) {	
start mediating the message in the pre mediate state using the mandatory sequence 

((Axis2MessageContext) synCtx).setServiceLog(serviceLog);	synCtx.setProperty(SynapseConstants.PROXY_SERVICE, name);	synCtx.setTracingState(proxy.getTraceState());	try {	Mediator mandatorySeq = synCtx.getConfiguration().getMandatorySequence();	if (mandatorySeq != null) {	if (log.isDebugEnabled()) {	}	if(!mandatorySeq.mediate(synCtx)) {	if(log.isDebugEnabled()) {	
request message for the proxy service dropped in the pre mediation state by the mandatory sequence 

========================= synapse sample_193 =========================

public boolean injectMessage(final MessageContext synCtx) {	if (log.isDebugEnabled()) {	
injecting messagecontext 

StatisticsUtils.processEndPointStatistics(synCtx);	StatisticsUtils.processProxyServiceStatistics(synCtx);	StatisticsUtils.processSequenceStatistics(synCtx);	}	if (synCtx.getProperty(SynapseConstants.PROXY_SERVICE) != null) {	if (synCtx.getConfiguration().getProxyService((String) synCtx.getProperty( SynapseConstants.PROXY_SERVICE)).getTargetOutSequence() != null) {	String sequenceName = synCtx.getConfiguration().getProxyService((String) synCtx. getProperty(SynapseConstants.PROXY_SERVICE)).getTargetOutSequence();	Mediator outSequence = synCtx.getSequence(sequenceName);	if (outSequence != null) {	if (log.isDebugEnabled()) {	
using the sequence named for the outgoing message mediation of the proxy service 

}	if (synCtx.getProperty(SynapseConstants.PROXY_SERVICE) != null) {	if (synCtx.getConfiguration().getProxyService((String) synCtx.getProperty( SynapseConstants.PROXY_SERVICE)).getTargetOutSequence() != null) {	String sequenceName = synCtx.getConfiguration().getProxyService((String) synCtx. getProperty(SynapseConstants.PROXY_SERVICE)).getTargetOutSequence();	Mediator outSequence = synCtx.getSequence(sequenceName);	if (outSequence != null) {	if (log.isDebugEnabled()) {	}	outSequence.mediate(synCtx);	} else {	
unable to find the out sequence specified by the name 

Mediator outSequence = synCtx.getSequence(sequenceName);	if (outSequence != null) {	if (log.isDebugEnabled()) {	}	outSequence.mediate(synCtx);	} else {	throw new SynapseException("Unable to find the " + "out-sequence specified by the name " + sequenceName);	}	} else if (synCtx.getConfiguration().getProxyService((String) synCtx.getProperty( SynapseConstants.PROXY_SERVICE)).getTargetInLineOutSequence() != null) {	if (log.isDebugEnabled()) {	
using the anonymous out sequence specified in the proxy service for outgoing message mediation 

outSequence.mediate(synCtx);	} else {	throw new SynapseException("Unable to find the " + "out-sequence specified by the name " + sequenceName);	}	} else if (synCtx.getConfiguration().getProxyService((String) synCtx.getProperty( SynapseConstants.PROXY_SERVICE)).getTargetInLineOutSequence() != null) {	if (log.isDebugEnabled()) {	}	synCtx.getConfiguration().getProxyService((String) synCtx.getProperty( SynapseConstants.PROXY_SERVICE)).getTargetInLineOutSequence().mediate(synCtx);	} else {	if (log.isDebugEnabled()) {	
proxy service does not specifies an out sequence sending the response back 

if (log.isDebugEnabled()) {	}	synCtx.getConfiguration().getProxyService((String) synCtx.getProperty( SynapseConstants.PROXY_SERVICE)).getTargetInLineOutSequence().mediate(synCtx);	} else {	if (log.isDebugEnabled()) {	}	Axis2Sender.sendBack(synCtx);	}	} else {	if (log.isDebugEnabled()) {	
using main sequence for injected message 

public MessageContext createMessageContext() {	if (log.isDebugEnabled()) {	
creating message context 

========================= synapse sample_3499 =========================

public void testScriptMediationWithRuby() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test using ruby scripts for mediation 

========================= synapse sample_2230 =========================

long start = System.currentTimeMillis();	OCSPCache ocspCache = OCSPCache.getCache();	ocspCache.init(cacheSize, cacheDurationMins);	CRLCache crlCache = CRLCache.getCache();	crlCache.init(cacheSize, cacheDurationMins);	RevocationVerifier[] verifiers = {new OCSPVerifier(ocspCache), new CRLVerifier(crlCache)};	for (RevocationVerifier verifier : verifiers) {	try {	CertificatePathValidator pathValidator = new CertificatePathValidator( convertedCertificates, verifier);	pathValidator.validatePath();	
path verification successful with took ms 

CRLCache crlCache = CRLCache.getCache();	crlCache.init(cacheSize, cacheDurationMins);	RevocationVerifier[] verifiers = {new OCSPVerifier(ocspCache), new CRLVerifier(crlCache)};	for (RevocationVerifier verifier : verifiers) {	try {	CertificatePathValidator pathValidator = new CertificatePathValidator( convertedCertificates, verifier);	pathValidator.validatePath();	return;	} catch (Exception e) {	if (log.isDebugEnabled()) {	
certificate verification with failed 

========================= synapse sample_982 =========================

public boolean mediate(MessageContext synCtx) {	log.debug("Header mediator <" + (action == ACTION_SET ? "Set" : "Remove") + "> :: mediate()");	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	if(shouldTrace) {	trace.trace("Start : Header mediator, action = " + (action == ACTION_SET ? "set" : "remove"));	}	if (action == ACTION_SET) {	String value = (getValue() != null ? getValue() : Axis2MessageContext.getStringValue(getExpression(), synCtx));	
setting header to 

synCtx.setWSAAction(value);	} else if (Constants.HEADER_FAULT.equals(qName.getLocalPart())) {	synCtx.setFaultTo(new EndpointReference(value));	} else if (Constants.HEADER_REPLY_TO.equals(qName.getLocalPart())) {	synCtx.setReplyTo(new EndpointReference(value));	} else {	handleException("Unsupported header : " + qName.getLocalPart());	}	}	} else {	
removing header from current message 

========================= synapse sample_3071 =========================

public void testScheduledTaskInjectToSequence() throws Exception {	
waiting seconds for the task to run 

public void testScheduledTaskInjectToSequence() throws Exception {	Thread.sleep(10000);	int messageCount = getAxis2Server().getMessageCount("SimpleStockQuoteService", "getQuote");	
task sent messages 

========================= synapse sample_828 =========================

Parameter keyParam    = transportOut.getParameter("keystore");	Parameter trustParam  = transportOut.getParameter("truststore");	OMElement ksEle = null;	OMElement tsEle = null;	if (keyParam != null) {	ksEle = keyParam.getParameterElement().getFirstElement();	}	boolean noValidateCert = ParamUtils.getOptionalParamBoolean(transportOut, "novalidatecert", false);	if (trustParam != null) {	if (noValidateCert) {	
ignoring novalidatecert parameter since a truststore has been specified 

private Map<String, SSLContext> getCustomSSLContexts(TransportOutDescription transportOut) throws AxisFault {	if (log.isDebugEnabled()) {	
loading custom ssl profiles for the https sender 

OMElement ksElt = profile.getFirstChildWithName(new QName("KeyStore"));	OMElement trElt = profile.getFirstChildWithName(new QName("TrustStore"));	String noValCert = profile.getAttributeValue(new QName("novalidatecert"));	boolean novalidatecert = "true".equals(noValCert);	SSLContext sslContext = createSSLContext(ksElt, trElt, novalidatecert);	for (String server : servers) {	server = server.trim();	if (!contextMap.containsKey(server)) {	contextMap.put(server, sslContext);	} else {	
multiple ssl profiles were found for the server ignoring the excessive profiles 

SSLContext sslContext = createSSLContext(ksElt, trElt, novalidatecert);	for (String server : servers) {	server = server.trim();	if (!contextMap.containsKey(server)) {	contextMap.put(server, sslContext);	} else {	}	}	}	if (contextMap.size() > 0) {	
custom ssl profiles initialized for servers 

TrustManager[] trustManagers = null;	if (keyStoreElt != null) {	String location      = keyStoreElt.getFirstChildWithName(new QName("Location")).getText();	String type          = keyStoreElt.getFirstChildWithName(new QName("Type")).getText();	String storePassword = keyStoreElt.getFirstChildWithName(new QName("Password")).getText();	String keyPassword   = keyStoreElt.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading identity keystore from 

String keyPassword   = keyStoreElt.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	
error loading keystore 

try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Keystore : " + location, gse);	} catch (IOException ioe) {	
error opening keystore 

} finally {	if (fis != null) {	try {	fis.close();	} catch (IOException ignore) {}	}	}	}	if (trustStoreElt != null) {	if (novalidatecert) {	
ignoring novalidatecert parameter since a truststore has been specified 

if (trustStoreElt != null) {	if (novalidatecert) {	}	String location      = trustStoreElt.getFirstChildWithName(new QName("Location")).getText();	String type          = trustStoreElt.getFirstChildWithName(new QName("Type")).getText();	String storePassword = trustStoreElt.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading trust keystore from 

String storePassword = trustStoreElt.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

} catch (IOException ioe) {	throw new AxisFault("Error opening Key store : " + location, ioe);	} finally {	if (fis != null) {	try {	fis.close();	} catch (IOException ignore) {}	}	}	} else if (novalidatecert) {	
server certificate validation trust has been disabled do not use in production 

}	}	} else if (novalidatecert) {	trustManagers = new TrustManager[] { new NoValidateCertTrustManager() };	}	try {	SSLContext sslcontext = SSLContext.getInstance("TLS");	sslcontext.init(keymanagers, trustManagers, null);	return sslcontext;	} catch (GeneralSecurityException gse) {	
unable to create ssl context with the given configuration 

========================= synapse sample_2375 =========================

if (outCtx != null && "true".equals(outCtx. getProperty(SynapseConstants.BLOCKING_CLIENT_ERROR))) {	if (maxDeliverAttempts > 0) {	processor.incrementSendAttemptCount();	}	if (parameters != null && parameters.get( ForwardingProcessorConstants.FAULT_SEQUENCE) != null) {	String seq = (String) parameters.get( ForwardingProcessorConstants.FAULT_SEQUENCE);	Mediator mediator = outCtx.getSequence(seq);	if (mediator != null) {	mediator.mediate(outCtx);	} else {	
can t send the fault message sequence does not exist 

processor.resetSentAttemptCount();	continue;	}	if (parameters != null && parameters.get( ForwardingProcessorConstants.REPLY_SEQUENCE) != null) {	if (outCtx != null) {	String seq = (String) parameters.get( ForwardingProcessorConstants.REPLY_SEQUENCE);	Mediator mediator = outCtx.getSequence(seq);	if (mediator != null) {	mediator.mediate(outCtx);	} else {	
can t send the out message sequence does not exist 

if (processor.getSendAttemptCount() >= maxDeliverAttempts) {	if (isMaxDeliverAttemptDropEnabled) {	processor.resetSentAttemptCount();	messageStore.poll();	} else {	deactivate(processor, messageContext, parameters);	}	}	}	errorStop = true;	
error forwarding message 

String logMsg;	if (ep == null) {	logMsg = "Endpoint named " + targetEp + " not found.Hence removing " + "the message form store";	} else {	logMsg = "Unsupported endpoint type. Only address/wsdl/default " + "endpoint types supported";	}	log.warn(logMsg);	messageStore.poll();	}	} else {	
property not found in the message context hence removing the message 

private void deactivate(ScheduledMessageForwardingProcessor processor, MessageContext msgContext, Map<String, Object> parameters) {	processor.deactivate();	if (parameters != null && parameters.get(ForwardingProcessorConstants.DEACTIVATE_SEQUENCE) != null) {	if (msgContext != null) {	String seq = (String) parameters.get(ForwardingProcessorConstants.DEACTIVATE_SEQUENCE);	Mediator mediator = msgContext.getSequence(seq);	if (mediator != null) {	mediator.mediate(msgContext);	} else {	
deactivate sequence does not exist 

========================= synapse sample_594 =========================

boolean isClusteringEnable = false;	org.apache.axis2.context.MessageContext axisMC = ((Axis2MessageContext) synCtx).getAxis2MessageContext();	ConfigurationContext cc = axisMC.getConfigurationContext();	ClusterManager clusterManager = cc.getAxisConfiguration().getClusterManager();	if (clusterManager != null && clusterManager.getContextManager() != null) {	isClusteringEnable = true;	}	String endPointName = this.getName();	if (endPointName == null) {	if (traceOrDebugOn && isClusteringEnable) {	
in a clustering environment the endpoint name should be specified even for anonymous endpoints otherwise the clustering would not be functioned correctly if there are more than one anonymous endpoints 

public boolean isActive(MessageContext synMessageContext) {	boolean active = endpointContext.isActive();	if (!active) {	long recoverOn = endpointContext.getRecoverOn();	if (System.currentTimeMillis() > recoverOn) {	active = true;	endpointContext.setActive(true);	}	}	if (log.isDebugEnabled()) {	
endpoint is in state 

========================= synapse sample_4022 =========================

public void init(Properties properties) {	StdSchedulerFactory sf = new StdSchedulerFactory();	if (properties != null) {	String quartzConf = properties.getProperty(QUARTZ_CONF);	try {	if (quartzConf != null && !"".equals(quartzConf)) {	if (log.isDebugEnabled()) {	
initiating a scheduler with configuration 

public void start() {	assertInitialized();	try {	if (!scheduler.isStarted()) {	if (log.isDebugEnabled()) {	
starting a scheduler 

throw new SynapseTaskException("Trigger cannot be created from : " + taskDescription, log);	}	JobDetail jobDetail = jobDetailFactory.createJobDetail(taskDescription, resources, jobClass);	if (jobDetail == null) {	throw new SynapseTaskException("JobDetail cannot be created from : " + taskDescription + " and job class " + jobClass.getName(), log);	}	try {	if (taskDescription.getCount() != 0) {	if (!isTaskAlreadyRunning(jobDetail.getKey())) {	if (log.isDebugEnabled()) {	
scheduling job with trigger 

if (jobDetail == null) {	throw new SynapseTaskException("JobDetail cannot be created from : " + taskDescription + " and job class " + jobClass.getName(), log);	}	try {	if (taskDescription.getCount() != 0) {	if (!isTaskAlreadyRunning(jobDetail.getKey())) {	if (log.isDebugEnabled()) {	}	scheduler.scheduleJob(jobDetail, trigger);	} else {	
did not schedule the job the job is already running 

}	try {	if (taskDescription.getCount() != 0) {	if (!isTaskAlreadyRunning(jobDetail.getKey())) {	if (log.isDebugEnabled()) {	}	scheduler.scheduleJob(jobDetail, trigger);	} else {	}	} else {	
did not schedule the job job count is zero 

}	JobDetail jobDetail = jobDetailFactory.createJobDetail(taskDescription, resources, jobClass);	if (jobDetail == null) {	throw new SynapseTaskException("JobDetail cannot be created from : " + taskDescription + " and job class " + jobClass.getName(), log);	}	jobDetail.getJobDataMap().put(TaskDescription.INSTANCE, task);	try {	if (taskDescription.getCount() != 0) {	if (!isTaskAlreadyRunning(jobDetail.getKey())) {	if (log.isDebugEnabled()) {	
scheduling job with trigger 

throw new SynapseTaskException("JobDetail cannot be created from : " + taskDescription + " and job class " + jobClass.getName(), log);	}	jobDetail.getJobDataMap().put(TaskDescription.INSTANCE, task);	try {	if (taskDescription.getCount() != 0) {	if (!isTaskAlreadyRunning(jobDetail.getKey())) {	if (log.isDebugEnabled()) {	}	scheduler.scheduleJob(jobDetail, trigger);	} else {	
did not schedule the job the job is already running 

jobDetail.getJobDataMap().put(TaskDescription.INSTANCE, task);	try {	if (taskDescription.getCount() != 0) {	if (!isTaskAlreadyRunning(jobDetail.getKey())) {	if (log.isDebugEnabled()) {	}	scheduler.scheduleJob(jobDetail, trigger);	} else {	}	} else {	
did not schedule the job job count is zero 

public void shutDown() {	if (isInitialized()) {	try {	if (scheduler != null && scheduler.isStarted()) {	if (log.isDebugEnabled()) {	
shuttingdown task scheduler 

public void deleteTask(String name, String group) {	assertInitialized();	assertStarted();	if (name == null || "".equals(name)) {	throw new SynapseTaskException("Task Name can not be null", log);	}	if (group == null || "".equals(group)) {	group = TaskDescription.DEFAULT_GROUP;	if (log.isDebugEnabled()) {	
task group is null or empty using default group 

if (name == null || "".equals(name)) {	throw new SynapseTaskException("Task Name can not be null", log);	}	if (group == null || "".equals(group)) {	group = TaskDescription.DEFAULT_GROUP;	if (log.isDebugEnabled()) {	}	}	try {	if (log.isDebugEnabled()) {	
deleting a job with name group 

public int getRunningTaskCount(){	int runningTasks = 0;	try {	if (scheduler != null) {	runningTasks = scheduler.getCurrentlyExecutingJobs().size();	}	} catch (SchedulerException e) {	
error querying currently executing jobs 

private boolean isTaskAlreadyRunning(JobKey jobKey) throws SchedulerException {	List<JobExecutionContext> currentJobs = scheduler.getCurrentlyExecutingJobs();	JobKey currentJobKey;	for (JobExecutionContext jobCtx : currentJobs) {	currentJobKey = jobCtx.getJobDetail().getKey();	if (currentJobKey.compareTo(jobKey) == 0) {	
the job is already running 

========================= synapse sample_22 =========================

public void destroy() {	if (sch != null) {	try {	sch.shutdown();	} catch (SchedulerException e) {	
error shutting down scheduler 

public void init(SynapseEnvironment synapseEnvironment) {	String thisServerName = System.getProperty(SynapseConstants.SYNAPSE_SERVER_NAME);	if(thisServerName == null || thisServerName.equals("")) {	try {	InetAddress addr = InetAddress.getLocalHost();	thisServerName = addr.getHostName();	} catch (UnknownHostException e) {	
could not get local host name 

if(thisServerName == null || thisServerName.equals("")) {	try {	InetAddress addr = InetAddress.getLocalHost();	thisServerName = addr.getHostName();	} catch (UnknownHostException e) {	}	if(thisServerName == null || thisServerName.equals("")) {	thisServerName = "localhost";	}	}	
synapse server name 

thisServerName = addr.getHostName();	} catch (UnknownHostException e) {	}	if(thisServerName == null || thisServerName.equals("")) {	thisServerName = "localhost";	}	}	List pinnedServers = getPinnedServers();	if(pinnedServers != null && !pinnedServers.isEmpty()) {	if(!pinnedServers.contains(thisServerName)) {	
server name not in pinned servers list not starting task 

jobDetail.setName(name);	jobDetail.setGroup("synapse.simple.quartz");	jobDetail.setJobClass(SimpleQuartzJob.class);	JobDataMap jdm = new JobDataMap();	jdm.put(SimpleQuartzJob.SYNAPSE_ENVIRONMENT, synapseEnvironment);	jdm.put(SimpleQuartzJob.CLASSNAME, className);	jdm.put(SimpleQuartzJob.PROPERTIES, xmlProperties);	jobDetail.setJobDataMap(jdm);	sch.scheduleJob(jobDetail, trigger);	sch.start();	
scheduled job for class 

jobDetail.setGroup("synapse.simple.quartz");	jobDetail.setJobClass(SimpleQuartzJob.class);	JobDataMap jdm = new JobDataMap();	jdm.put(SimpleQuartzJob.SYNAPSE_ENVIRONMENT, synapseEnvironment);	jdm.put(SimpleQuartzJob.CLASSNAME, className);	jdm.put(SimpleQuartzJob.PROPERTIES, xmlProperties);	jobDetail.setJobDataMap(jdm);	sch.scheduleJob(jobDetail, trigger);	sch.start();	} catch (Exception e) {	
error starting up scheduler 

========================= synapse sample_3708 =========================

public Object call(Context context, List args) throws FunctionCallException {	if (args.isEmpty()) {	
property key value for lookup was not specified 

public Object call(Context context, List args) throws FunctionCallException {	if (args.isEmpty()) {	return null;	} else if (synCtx == null) {	
synapse context has not been set for the xpath extension function synapse get property prop name 

========================= synapse sample_3067 =========================

try {	for (RewriteRule r : rules) {	r.rewrite(fragments, messageContext);	}	if (outputProperty != null) {	messageContext.setProperty(outputProperty, fragments.toURIString());	} else {	messageContext.setTo(new EndpointReference(fragments.toURIString()));	}	if(log.isDebugEnabled()) {	
url rewrite mediator has rewritten the address url 

========================= synapse sample_1959 =========================

String optionType = option.getOptionType();	return !("repo".equalsIgnoreCase(optionType) || "conf" .equalsIgnoreCase(optionType));	}	});	if ((invalidOptionsList.size() > 0) || (args.length > 4)) {	printUsage();	}	Map optionsMap = optionsParser.getAllOptions();	CommandLineOption repoOption = (CommandLineOption) optionsMap .get("repo");	CommandLineOption confOption = (CommandLineOption) optionsMap .get("conf");	
simpleaxisserver starting 

configCtx = ConfigurationContextFactory .createConfigurationContextFromFileSystem(repoLocation, confLocation);	configurePort(configCtx);	listenerManager = new ListenerManager();	listenerManager.init(configCtx);	listenerManager.start();	ClusteringAgent clusteringAgent = configCtx.getAxisConfiguration().getClusteringAgent();	if(clusteringAgent != null) {	clusteringAgent.setConfigurationContext(configCtx);	clusteringAgent.init();	}	
simpleaxisserver started 

configurePort(configCtx);	listenerManager = new ListenerManager();	listenerManager.init(configCtx);	listenerManager.start();	ClusteringAgent clusteringAgent = configCtx.getAxisConfiguration().getClusteringAgent();	if(clusteringAgent != null) {	clusteringAgent.setConfigurationContext(configCtx);	clusteringAgent.init();	}	} catch (Throwable t) {	
simpleaxisserver shutting down error starting simpleaxisserver 

private void configurePort(ConfigurationContext configCtx) {	TransportInDescription trsIn = configCtx.getAxisConfiguration().getTransportsIn().get("http");	if (trsIn != null) {	String port = System.getProperty("http_port");	if (port != null) {	try {	new Integer(port);	trsIn.getParameter("port").setValue(port);	} catch (NumberFormatException e) {	
given port is not a valid integer using for port 

}	}	TransportInDescription httpsTrsIn = configCtx.getAxisConfiguration(). getTransportsIn().get("https");	if (httpsTrsIn != null) {	String port = System.getProperty("https_port");	if (port != null) {	try {	new Integer(port);	httpsTrsIn.getParameter("port").setValue(port);	} catch (NumberFormatException e) {	
given port is not a valid integer using for port 

========================= synapse sample_2676 =========================

public void testURLRewrite() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to the url rewrite mediator 

========================= synapse sample_2226 =========================

private boolean createCases(SwitchMediator switchMediator, String caseItr) {	String[] caseSet = caseItr.split(DELIMITER_2);	if (caseSet.length == 0) {	
no definitions found for dynamic routing 

========================= synapse sample_582 =========================

public DataSource getDataSource(String name) {	if (name == null || "".equals(name)) {	throw new SynapseCommonsException("DataSource name cannot be found.", log);	}	DataSource result = inMemoryDataSourceRepository.lookUp(name);	if (result != null) {	if (log.isDebugEnabled()) {	
datasource is found in the in memory data source repository datasource name is 

DataSource result = inMemoryDataSourceRepository.lookUp(name);	if (result != null) {	if (log.isDebugEnabled()) {	}	return result;	}	if (jndiBasedDataSourceRepository.isInitialized()) {	result = jndiBasedDataSourceRepository.lookUp(name);	if (result != null) {	if (log.isDebugEnabled()) {	
datasource is found in the jndi data source repository datasource name is 

}	if (jndiBasedDataSourceRepository.isInitialized()) {	result = jndiBasedDataSourceRepository.lookUp(name);	if (result != null) {	if (log.isDebugEnabled()) {	}	return result;	}	}	if (log.isDebugEnabled()) {	
cannot find a datasource with name either in in memory or jndi datasource repositories 

public void addDataSourceInformation(DataSourceInformation dataSourceInformation) {	assertDataSourceInformationNull(dataSourceInformation);	String repositoryType = dataSourceInformation.getRepositoryType();	if (log.isDebugEnabled()) {	
registering a datasource in the repository datasource information is 

public void removeDataSourceInformation(DataSourceInformation dataSourceInformation) {	assertDataSourceInformationNull(dataSourceInformation);	String repositoryType = dataSourceInformation.getRepositoryType();	if (log.isDebugEnabled()) {	
un registering a datasource from the repository datasource information is 

public void reConfigure(Properties confProperties) {	if (log.isDebugEnabled()) {	
reconfiguring datasource repositories 

public void clear() {	if (log.isDebugEnabled()) {	
clearing datasource repositories 

========================= synapse sample_701 =========================

if (GZIP_CODEC.equals(encode)) {	Object obj = response.getProperty(MessageContext.TRANSPORT_HEADERS);	Map responseHeaders;	if (obj != null && obj instanceof Map) {	responseHeaders = (Map) obj;	} else {	responseHeaders = new HashMap();	response.setProperty(MessageContext.TRANSPORT_HEADERS, responseHeaders);	}	if (log.isDebugEnabled()) {	
sets the content encoding header as 

========================= synapse sample_1723 =========================

public StatisticsCleaner(StatisticsCollector collector) {	this.collector = collector;	this.cleanInterval = Long.parseLong(SynapsePropertiesLoader.getPropertyValue( CLEAN_INTERVAL, String.valueOf(DEFAULT_CLEAN_INTERVAL)));	this.isCleanEnable = Boolean.parseBoolean( SynapsePropertiesLoader.getPropertyValue( CLEAN_ENABLE, String.valueOf(true)));	if (isCleanEnable) {	if (log.isDebugEnabled()) {	
statistics cleaning is will be occured with interval s 

public void clean() {	try {	if (!isCleanEnable) {	if (log.isDebugEnabled()) {	
statistics cleaning is disabled 

public void clean() {	try {	if (!isCleanEnable) {	if (log.isDebugEnabled()) {	}	return;	}	if (collector == null) {	if (log.isDebugEnabled()) {	
there are no statistics to be cleaned 

}	long currentTime = System.currentTimeMillis();	if (nextTime == -1) {	nextTime = currentTime + cleanInterval;	}	if (nextTime <= currentTime) {	collector.clearStatistics();	nextTime = currentTime + cleanInterval;	} else {	if (log.isDebugEnabled()) {	
there are no expired statistics to be cleaned 

========================= synapse sample_644 =========================

public SynapseTaskManager() {	if (log.isDebugEnabled()) {	
created the synapsetaskmanager singleton instance 

public void init(TaskDescriptionRepository taskDescriptionRepository, TaskScheduler taskScheduler) {	if (initialized) {	if (log.isDebugEnabled()) {	
task manager already initialized skipping re initialization 

public void init(TaskDescriptionRepository taskDescriptionRepository, TaskScheduler taskScheduler) {	if (initialized) {	if (log.isDebugEnabled()) {	}	return;	}	if (taskDescriptionRepository != null) {	this.taskDescriptionRepository = taskDescriptionRepository;	} else {	if (log.isDebugEnabled()) {	
creating new taskdescriptionrepository as given instance is null 

this.taskDescriptionRepository = taskDescriptionRepository;	} else {	if (log.isDebugEnabled()) {	}	this.taskDescriptionRepository = TaskDescriptionRepositoryFactory.getTaskDescriptionRepository( TaskConstants.TASK_DESCRIPTION_REPOSITORY);	}	if (taskScheduler != null) {	this.taskScheduler = taskScheduler;	} else {	if (log.isDebugEnabled()) {	
creating new taskscheduler as given instance is null 

public void cleanup() {	assertInitialized();	
shutting down the task manager 

========================= synapse sample_34 =========================

public void testFireAndForget() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test one way messaging fireandforget through synapse 

========================= synapse sample_2271 =========================

public void init(ServerConfigurationInformation serverConfigurationInformation, ServerContextInformation serverContextInformation) {	
initializing synapse at 

if (serverContextInformation == null) {	throw new IllegalArgumentException("ServerContextInformation cannot be null");	}	this.serverConfigurationInformation = serverConfigurationInformation;	this.serverContextInformation = serverContextInformation;	to show all MBeans (including the Axis2-MBeans) within the Synapse tree */ if (System.getProperty(JMX_AGENT_NAME) == null) {	System.setProperty(JMX_AGENT_NAME, "org.apache.synapse");	}	if (serverContextInformation.getServerContext() == null || serverConfigurationInformation.isCreateNewInstance()) {	if (log.isDebugEnabled()) {	
initializing synapse in a new server environment instance 

System.setProperty(JMX_AGENT_NAME, "org.apache.synapse");	}	if (serverContextInformation.getServerContext() == null || serverConfigurationInformation.isCreateNewInstance()) {	if (log.isDebugEnabled()) {	}	createNewInstance(serverConfigurationInformation);	} else {	Object context = serverContextInformation.getServerContext();	if (context instanceof ConfigurationContext) {	if (log.isDebugEnabled()) {	
initializing synapse in an already existing server environment instance 

handleFatal("Synapse startup initialization failed : Provided server context is" + " invalid, expected an Axis2 ConfigurationContext instance");	}	}	serverContextInformation.setServerContext(configurationContext);	Parameter serverContextParameter = new Parameter( SynapseConstants.SYNAPSE_SERVER_CTX_INFO, serverContextInformation);	Parameter serverConfigParameter = new Parameter( SynapseConstants.SYNAPSE_SERVER_CONFIG_INFO, serverConfigurationInformation);	try {	configurationContext.getAxisConfiguration().addParameter(serverContextParameter);	configurationContext.getAxisConfiguration().addParameter(serverConfigParameter);	} catch (AxisFault ignored) {	
error adding the parameter to the axis configuration 

private void initSynapseLibraries(SynapseConfiguration synapseConfig, String root) {	File synLibDir = new File(root, "repository" + File.separator +"conf" + File.separator +"synapse-libs");	if (synLibDir.exists()) {	if (log.isDebugEnabled()) {	
loading synapse libraries from 

if (log.isDebugEnabled()) {	}	Iterator synLibFile = FileUtils.iterateFiles(synLibDir, new String[]{LibDeployerConstants.SYNAPSE_LIB_FORMAT}, false);	while (synLibFile.hasNext()) {	File file = (File) synLibFile.next();	Library lib = LibDeployerUtils.createSynapseLibrary(FilenameUtils.normalize(file.getAbsolutePath()));	String libArtifactName = lib.getQName().toString();	synapseConfig.addSynapseLibrary(lib.toString(), lib);	synapseConfig.getArtifactDeploymentStore().addArtifact(file.getAbsolutePath(), libArtifactName);	if (log.isDebugEnabled()) {	
synapse library deployment for lib completed 

Library lib = LibDeployerUtils.createSynapseLibrary(FilenameUtils.normalize(file.getAbsolutePath()));	String libArtifactName = lib.getQName().toString();	synapseConfig.addSynapseLibrary(lib.toString(), lib);	synapseConfig.getArtifactDeploymentStore().addArtifact(file.getAbsolutePath(), libArtifactName);	if (log.isDebugEnabled()) {	}	SynapseImport synImport = synapseConfig.getSynapseImports().get(libArtifactName);	if (synImport != null) {	LibDeployerUtils.loadLibArtifacts(synImport, lib);	if (log.isDebugEnabled()) {	
loading synapse library into memory for import 

RMIRegistryController.getInstance().shutDown();	if (snmpAgent != null) {	snmpAgent.stop();	}	if (configurationContext != null) {	configurationContext.terminate();	}	}	initialized = false;	} catch (Exception e) {	
error stopping the based server environment 

} else {	handleFatal("Couldn't start Synapse, ConfigurationContext not found");	}	if (serverConfigurationInformation.isCreateNewInstance()) {	if (listenerManager != null) {	listenerManager.start();	} else {	handleFatal("Couldn't start Synapse, ListenerManager not found");	}	at the end of the startup process to make it more obvious */ if (jmxAdapter != null && jmxAdapter.isRunning()) {	
management using jmx available via 

}	}	Properties properties = SynapsePropertiesLoader.loadSynapseProperties();	String enabled = properties.getProperty(SNMPConstants.SNMP_ENABLED);	try {	if (enabled != null && JavaUtils.isTrueExplicitly(enabled)) {	snmpAgent = new SynapseSNMPAgent(properties);	snmpAgent.start();	}	} catch (IOException e) {	
error while initializing snmp 

public void startMaintenance() {	
putting transport listeners senders and tasks into maintenance mode 

public void startMaintenance() {	Axis2TransportHelper transportHelper = new Axis2TransportHelper(configurationContext);	transportHelper.pauseListeners();	transportHelper.pauseSenders();	SynapseTaskManager synapseTaskManager = synapseEnvironment.getTaskManager();	if (synapseTaskManager.isInitialized()) {	synapseTaskManager.pauseAll();	}	
entered maintenance mode 

public void endMaintenance() {	
resuming transport listeners senders and tasks from maintenance mode 

public void endMaintenance() {	Axis2TransportHelper transportHelper = new Axis2TransportHelper(configurationContext);	transportHelper.resumeListeners();	transportHelper.resumeSenders();	SynapseTaskManager synapseTaskManager = synapseEnvironment.getTaskManager();	if (synapseTaskManager.isInitialized()) {	synapseTaskManager.resumeAll();	}	
resumed normal operation from maintenance mode 

}	Map<String, AxisModule> moduleMap = configurationContext.getAxisConfiguration().getModules();	for (AxisModule mod : moduleMap.values()) {	if (mod.getModule() != null && !"synapse".equals(mod.getName())) {	mod.getModule().shutdown(configurationContext);	}	}	}	SynapseCallbackReceiver.getInstance().destroy();	} catch (AxisFault e) {	
error stopping the environment 

public SynapseEnvironment createSynapseEnvironment() {	try {	deploySynapseService();	deployProxyServices();	deployEventSources();	} catch (AxisFault axisFault) {	
synapse startup failed 

Properties properties = SynapsePropertiesLoader.loadSynapseProperties();	if (serverConfigurationInformation.getResolveRoot() != null) {	properties.put(SynapseConstants.RESOLVE_ROOT, serverConfigurationInformation.getResolveRoot());	}	if (serverConfigurationInformation.getSynapseHome() != null) {	properties.put(SynapseConstants.SYNAPSE_HOME, serverConfigurationInformation.getSynapseHome());	}	if (synapseXMLLocation != null) {	synapseConfiguration = SynapseConfigurationBuilder.getConfiguration( synapseXMLLocation, properties);	} else {	
system property or init parameter is not specified using default configuration 

public boolean waitUntilSafeToStop(long waitIntervalMillis, long endTime) {	boolean safeToStop = false;	boolean forcefulStop = false;	Axis2TransportHelper transportHelper = new Axis2TransportHelper(configurationContext);	while (!safeToStop && !forcefulStop) {	int pendingListenerThreads = transportHelper.getPendingListenerThreadCount();	if (pendingListenerThreads > 0) {	
waiting for listener threads to complete 

public boolean waitUntilSafeToStop(long waitIntervalMillis, long endTime) {	boolean safeToStop = false;	boolean forcefulStop = false;	Axis2TransportHelper transportHelper = new Axis2TransportHelper(configurationContext);	while (!safeToStop && !forcefulStop) {	int pendingListenerThreads = transportHelper.getPendingListenerThreadCount();	if (pendingListenerThreads > 0) {	}	int pendingSenderThreads = transportHelper.getPendingSenderThreadCount();	if (pendingSenderThreads > 0) {	
waiting for listener threads to complete 

Axis2TransportHelper transportHelper = new Axis2TransportHelper(configurationContext);	while (!safeToStop && !forcefulStop) {	int pendingListenerThreads = transportHelper.getPendingListenerThreadCount();	if (pendingListenerThreads > 0) {	}	int pendingSenderThreads = transportHelper.getPendingSenderThreadCount();	if (pendingSenderThreads > 0) {	}	int activeConnections = transportHelper.getActiveConnectionsCount();	if (activeConnections > 0) {	
waiting for active connections to be closed 

}	int pendingSenderThreads = transportHelper.getPendingSenderThreadCount();	if (pendingSenderThreads > 0) {	}	int activeConnections = transportHelper.getActiveConnectionsCount();	if (activeConnections > 0) {	}	int pendingTransportThreads = pendingListenerThreads + pendingSenderThreads;	int pendingCallbacks = SynapseCallbackReceiver.getInstance().getCallbackCount();	if (pendingCallbacks > 0) {	
waiting for callbacks replies 

}	int pendingTransportThreads = pendingListenerThreads + pendingSenderThreads;	int pendingCallbacks = SynapseCallbackReceiver.getInstance().getCallbackCount();	if (pendingCallbacks > 0) {	}	int runningTasks = 0;	SynapseTaskManager synapseTaskManager = synapseEnvironment.getTaskManager();	if (synapseTaskManager.isInitialized()) {	runningTasks = synapseTaskManager.getTaskScheduler().getRunningTaskCount();	if (runningTasks > 0) {	
waiting for tasks to complete 

}	int runningTasks = 0;	SynapseTaskManager synapseTaskManager = synapseEnvironment.getTaskManager();	if (synapseTaskManager.isInitialized()) {	runningTasks = synapseTaskManager.getTaskScheduler().getRunningTaskCount();	if (runningTasks > 0) {	}	}	safeToStop = ((pendingTransportThreads + pendingCallbacks + runningTasks) == 0);	if (safeToStop) {	
all transport threads and tasks are idle and no pending callbacks 

SynapseTaskManager synapseTaskManager = synapseEnvironment.getTaskManager();	if (synapseTaskManager.isInitialized()) {	runningTasks = synapseTaskManager.getTaskScheduler().getRunningTaskCount();	if (runningTasks > 0) {	}	}	safeToStop = ((pendingTransportThreads + pendingCallbacks + runningTasks) == 0);	if (safeToStop) {	} else {	if (System.currentTimeMillis() < endTime) {	
waiting for a maximum of another seconds until transport threads and tasks become idle active connections to get closed and callbacks to be completed 

private void deploySynapseService() throws AxisFault {	
deploying the synapse service 

private void undeploySynapseService() throws AxisFault {	
undeploying the synapse service 

private void deployProxyServices() {	boolean failSafeProxyEnabled = SynapseConfigUtils.isFailSafeEnabled( SynapseConstants.FAIL_SAFE_MODE_PROXY_SERVICES);	
deploying proxy services 

if (thisServerName == null || "".equals(thisServerName)) {	thisServerName = serverConfigurationInformation.getHostName();	if (thisServerName == null || "".equals(thisServerName)) {	thisServerName = "localhost";	}	}	for (ProxyService proxy : synapseConfiguration.getProxyServices()) {	List pinnedServers = proxy.getPinnedServers();	if (pinnedServers != null && !pinnedServers.isEmpty()) {	if (!pinnedServers.contains(thisServerName)) {	
server name not in pinned servers list not deploying proxy service 

for (ProxyService proxy : synapseConfiguration.getProxyServices()) {	List pinnedServers = proxy.getPinnedServers();	if (pinnedServers != null && !pinnedServers.isEmpty()) {	if (!pinnedServers.contains(thisServerName)) {	continue;	}	}	try {	AxisService proxyService = proxy.buildAxisService(synapseConfiguration, configurationContext.getAxisConfiguration());	if (proxyService != null) {	
deployed proxy service 

continue;	}	}	try {	AxisService proxyService = proxy.buildAxisService(synapseConfiguration, configurationContext.getAxisConfiguration());	if (proxyService != null) {	if (!proxy.isStartOnLoad()) {	proxy.stop(synapseConfiguration);	}	} else {	
the proxy service will not be available 

try {	AxisService proxyService = proxy.buildAxisService(synapseConfiguration, configurationContext.getAxisConfiguration());	if (proxyService != null) {	if (!proxy.isStartOnLoad()) {	proxy.stop(synapseConfiguration);	}	} else {	}	} catch (SynapseException e) {	if (failSafeProxyEnabled) {	
the proxy service cannot be deployed continue in proxy service fail safe mode 

private void undeployProxyServices() throws AxisFault {	
undeploying proxy services 

private void deployMediatorExtensions() {	
loading mediator extensions 

private void deployMediatorExtensions() {	AxisConfigurator configurator = configurationContext.getAxisConfiguration().getConfigurator();	if (configurator instanceof DeploymentEngine) {	((DeploymentEngine) configurator).getRepoListener().checkServices();	} else {	
unable to access the repository listener custom extensions will not get loaded now 

private void deployEventSources() throws AxisFault {	
deploying eventsources 

private void undeployEventSources() throws AxisFault {	
undeploying eventsources 

========================= synapse sample_490 =========================

HttpIOHandler httpIOHandler = new HttpIOHandler();	httpIOHandler.setMaxKeepAlives(maxKeepAlives);	httpIOHandler.setReadIdleTime(readIdleTime);	nioTransport.setHttpIOHandler(httpIOHandler);	List transports = new ArrayList();	transports.add(nioTransport);	svcCont = new BasicServiceContainer();	svcCont.setServiceHandlers(svcHandlers);	svcCont.setTransports(transports);	try {	
starting asynchttplistener on port 

httpIOHandler.setMaxKeepAlives(maxKeepAlives);	httpIOHandler.setReadIdleTime(readIdleTime);	nioTransport.setHttpIOHandler(httpIOHandler);	List transports = new ArrayList();	transports.add(nioTransport);	svcCont = new BasicServiceContainer();	svcCont.setServiceHandlers(svcHandlers);	svcCont.setTransports(transports);	try {	svcCont.start();	
started asynchttplistener on port 

public void stop() throws AxisFault {	svcCont.stop();	
async http protocol listener shut down 

========================= synapse sample_3175 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
message processor deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try{	MessageProcessor mp = MessageProcessorFactory.createMessageProcessor(artifactConfig);	if(mp != null) {	mp.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
message processor named has been built from the file 

if(mp != null) {	mp.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	if(getSynapseConfiguration().getMessageStore(mp.getMessageStoreName()) != null) {	mp.init(getSynapseEnvironment());	} else {	handleSynapseArtifactDeploymentError("Message Processor Deployment from the file :" + fileName + " : Failed. Can not create a Message processor without a Message Store");	}	if (log.isDebugEnabled()) {	
initialized the message processor 

}	if(getSynapseConfiguration().getMessageStore(mp.getMessageStoreName()) != null) {	mp.init(getSynapseEnvironment());	} else {	handleSynapseArtifactDeploymentError("Message Processor Deployment from the file :" + fileName + " : Failed. Can not create a Message processor without a Message Store");	}	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addMessageProcessor(mp.getName(), mp);	if (log.isDebugEnabled()) {	
message processor deployment from file completed 

if(getSynapseConfiguration().getMessageStore(mp.getMessageStoreName()) != null) {	mp.init(getSynapseEnvironment());	} else {	handleSynapseArtifactDeploymentError("Message Processor Deployment from the file :" + fileName + " : Failed. Can not create a Message processor without a Message Store");	}	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addMessageProcessor(mp.getName(), mp);	if (log.isDebugEnabled()) {	}	
message processor named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
message processor update from file has started 

if (log.isDebugEnabled()) {	}	try {	MessageProcessor mp = MessageProcessorFactory.createMessageProcessor(artifactConfig);	if (mp == null) {	handleSynapseArtifactDeploymentError("Message Processor update failed. The artifact " + "defined in the file: " + fileName + " is not valid");	return null;	}	mp.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	
messageprocessor has been built from the file 

return null;	}	mp.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	MessageProcessor existingMp = getSynapseConfiguration().getMessageProcessors(). get(existingArtifactName);	existingMp.destroy();	mp.init(getSynapseEnvironment());	getSynapseConfiguration().addMessageProcessor(mp.getName(), mp);	getSynapseConfiguration().removeMessageStore(existingArtifactName);	
messageprocessor has been undeployed 

return null;	}	mp.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	MessageProcessor existingMp = getSynapseConfiguration().getMessageProcessors(). get(existingArtifactName);	existingMp.destroy();	mp.init(getSynapseEnvironment());	getSynapseConfiguration().addMessageProcessor(mp.getName(), mp);	getSynapseConfiguration().removeMessageStore(existingArtifactName);	
messageprocessor has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
messageprocessor undeployment of the messageprocessor named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	MessageProcessor mp = getSynapseConfiguration().getMessageProcessors().get(artifactName);	if (mp != null) {	getSynapseConfiguration().removeMessageProcessor(artifactName);	if (log.isDebugEnabled()) {	
destroying the messageprocessor named 

if (log.isDebugEnabled()) {	}	try {	MessageProcessor mp = getSynapseConfiguration().getMessageProcessors().get(artifactName);	if (mp != null) {	getSynapseConfiguration().removeMessageProcessor(artifactName);	if (log.isDebugEnabled()) {	}	mp.destroy();	if (log.isDebugEnabled()) {	
messageprocessor undeployment of the endpoint named completed 

}	try {	MessageProcessor mp = getSynapseConfiguration().getMessageProcessors().get(artifactName);	if (mp != null) {	getSynapseConfiguration().removeMessageProcessor(artifactName);	if (log.isDebugEnabled()) {	}	mp.destroy();	if (log.isDebugEnabled()) {	}	
messageprocessor named has been undeployed 

try {	MessageProcessor mp = getSynapseConfiguration().getMessageProcessors().get(artifactName);	if (mp != null) {	getSynapseConfiguration().removeMessageProcessor(artifactName);	if (log.isDebugEnabled()) {	}	mp.destroy();	if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
messageprocessor has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the messageprocessor with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	MessageProcessor mp = getSynapseConfiguration().getMessageProcessors().get(artifactName);	OMElement msElem = MessageProcessorSerializer.serializeMessageProcessor(null,mp);	if (mp.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.MESSAGE_PROCESSOR_DIR + File.separator + mp.getFileName();	writeToFile(msElem, fileName);	if (log.isDebugEnabled()) {	
restoring the messageprocessor with name completed 

if (log.isDebugEnabled()) {	}	try {	MessageProcessor mp = getSynapseConfiguration().getMessageProcessors().get(artifactName);	OMElement msElem = MessageProcessorSerializer.serializeMessageProcessor(null,mp);	if (mp.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.MESSAGE_PROCESSOR_DIR + File.separator + mp.getFileName();	writeToFile(msElem, fileName);	if (log.isDebugEnabled()) {	}	
messageprocessor named has been restored 

========================= synapse sample_185 =========================

this.cfgCtx = cfgCtx;	this.response = response;	this.expectEntityBody = response.isExpectResponseBody();	Map<String,String> headers = response.getHeaders();	String oriURL = headers.get(PassThroughConstants.LOCATION);	if (oriURL != null && response.getStatus() != HttpStatus.SC_MOVED_TEMPORARILY) {	URL url;	try {	url = new URL(oriURL);	} catch (MalformedURLException e) {	
invalid url received 

if (prefix != null) {	headers.put(PassThroughConstants.LOCATION, prefix + url.getFile());	}	}	try {	responseMsgCtx = outMsgCtx.getOperationContext(). getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);	if (responseMsgCtx != null) {	responseMsgCtx.setSoapAction("");	}	} catch (AxisFault af) {	
error getting in message context from the operation context 

responseMsgCtx = outMsgCtx.getOperationContext(). getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);	if (responseMsgCtx != null) {	responseMsgCtx.setSoapAction("");	}	} catch (AxisFault af) {	return;	}	if (responseMsgCtx == null) {	if (outMsgCtx.getOperationContext().isComplete()) {	if (log.isDebugEnabled()) {	
error getting in message context from the operation context possibly an rm terminate sequence message 

if (charSetEnc == null) {	charSetEnc = MessageContext.DEFAULT_CHAR_SET_ENCODING;	}	responseMsgCtx.setProperty( Constants.Configuration.CHARACTER_SET_ENCODING, contentType.indexOf(HTTP.CHARSET_PARAM) > 0 ? charSetEnc : MessageContext.DEFAULT_CHAR_SET_ENCODING);	responseMsgCtx.setServerSide(false);	SOAPFactory fac = OMAbstractFactory.getSOAP11Factory();	SOAPEnvelope envelope = fac.getDefaultEnvelope();	try {	responseMsgCtx.setEnvelope(envelope);	} catch (AxisFault axisFault) {	
error setting the soap envelope 

}	int statusCode = this.response.getStatus();	responseMsgCtx.setProperty(PassThroughConstants.HTTP_SC, statusCode);	if (statusCode >= 400) {	responseMsgCtx.setProperty(PassThroughConstants.FAULT_MESSAGE, PassThroughConstants.TRUE);	}	responseMsgCtx.setProperty(PassThroughConstants.NON_BLOCKING_TRANSPORT, true);	try {	AxisEngine.receive(responseMsgCtx);	} catch (AxisFault af) {	
fault processing response message through 

responseMsgCtx.setProperty(PassThroughConstants.HTTP_SC, statusCode);	if (statusCode >= 400) {	responseMsgCtx.setProperty(PassThroughConstants.FAULT_MESSAGE, PassThroughConstants.TRUE);	}	responseMsgCtx.setProperty(PassThroughConstants.NON_BLOCKING_TRANSPORT, true);	try {	AxisEngine.receive(responseMsgCtx);	} catch (AxisFault af) {	}	} catch (AxisFault af) {	
fault creating response soap envelope 

if (statusCode >= 400) {	responseMsgCtx.setProperty(PassThroughConstants.FAULT_MESSAGE, PassThroughConstants.TRUE);	}	responseMsgCtx.setProperty(PassThroughConstants.NON_BLOCKING_TRANSPORT, true);	try {	AxisEngine.receive(responseMsgCtx);	} catch (AxisFault af) {	}	} catch (AxisFault af) {	} catch (IOException e) {	
error closing input stream from which message was read 

========================= synapse sample_2334 =========================

public static String getNameSpaceWithPrefix(String prefix, OMElement elem) {	if (prefix == null || elem == null) {	
searching for null ns prefix and or using null omelement 

========================= synapse sample_4063 =========================

MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();	ObjectName name = new ObjectName(getObjectName(category, id));	Set set = mbs.queryNames(name, null);	if (set != null && set.isEmpty()) {	mbs.registerMBean(mbeanInstance, name);	} else {	mbs.unregisterMBean(name);	mbs.registerMBean(mbeanInstance, name);	}	} catch (Exception e) {	
error registering a mbean with name and category name for jmx management 

public void unRegisterMBean(String category, String id) {	try {	MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();	ObjectName objName = new ObjectName(getObjectName(category, id));	if (mbs.isRegistered(objName)) {	mbs.unregisterMBean(objName);	}	} catch (Exception e) {	
error un registering a mbean with name and category name for jmx management 

========================= synapse sample_2508 =========================

if (!initialized) {	super.init(synapseEnvironment);	if (algorithmContext == null) {	algorithmContext = new AlgorithmContext(isClusteringEnabled, cc, getName());	}	SALSessions salSessions = SALSessions.getInstance();	if (!salSessions.isInitialized()) {	salSessions.initialize(isClusteringEnabled, cc);	}	}	
dynamic load balance endpoint initialized 

if (lbMembershipHandler.getConfigurationContext() == null) {	lbMembershipHandler.setConfigurationContext(configCtx);	}	if (isSessionAffinityBasedLB()) {	sessionInformation = (SessionInformation) synCtx.getProperty( SynapseConstants.PROP_SAL_CURRENT_SESSION_INFORMATION);	currentMember = (Member) synCtx.getProperty( SynapseConstants.PROP_SAL_ENDPOINT_CURRENT_MEMBER);	if (sessionInformation == null && currentMember == null) {	sessionInformation = dispatcher.getSession(synCtx);	if (sessionInformation != null) {	if (log.isDebugEnabled()) {	
current session id 

protected String extractSessionID(MessageContext synCtx, String key) {	if (key != null) {	Map headerMap = getTransportHeaderMap(synCtx);	if (headerMap != null) {	Object cookieObj = headerMap.get(key);	if (cookieObj instanceof String) {	return (String) cookieObj;	} else {	if (log.isDebugEnabled()) {	
couldn t find the header to find the session 

if (headerMap != null) {	Object cookieObj = headerMap.get(key);	if (cookieObj instanceof String) {	return (String) cookieObj;	} else {	if (log.isDebugEnabled()) {	}	}	} else {	if (log.isDebugEnabled()) {	
couldn t find the transport headers to find the session 

}	Map<String, String> memberHosts;	if ((memberHosts = (Map<String, String>) currentMember.getProperties().get(HttpSessionDispatcher.HOSTS)) == null) {	currentMember.getProperties().put(HttpSessionDispatcher.HOSTS, memberHosts = new HashMap<String, String>());	}	memberHosts.put(extractHost(synCtx), "true");	try {	endpoint.send(synCtx);	} catch (Exception e) {	if(e.getMessage().toLowerCase().contains("io reactor shutdown")){	
system cannot continue normal operation restarting 

========================= synapse sample_243 =========================

public void setType(String type) {	try {	new ContentType(type);	if (log.isDebugEnabled()) {	
content type 

========================= synapse sample_613 =========================

public boolean mediate(MessageContext synCtx) {	
synapse main mediator mediate 

========================= synapse sample_3319 =========================

public HostConnections(String host, int port, int maxSize) {	if (log.isDebugEnabled()) {	
creating new connection pool to the host port 

public NHttpClientConnection getConnection() {	lock.lock();	try {	if (freeConnections.size() > 0) {	if (log.isDebugEnabled()) {	
returning an existing free connection to 

public void release(NHttpClientConnection conn) {	conn.getMetrics().reset();	HttpContext ctx = conn.getContext();	ctx.removeAttribute(HttpCoreContext.HTTP_REQUEST);	ctx.removeAttribute(HttpCoreContext.HTTP_RESPONSE);	lock.lock();	try {	if (busyConnections.remove(conn)) {	freeConnections.add(conn);	} else {	
attempted to releaseconnection connection not in the busy list 

public void addConnection(NHttpClientConnection conn) {	if (log.isDebugEnabled()) {	
new connection to is added to the free list 

========================= synapse sample_957 =========================

public void schedulePoll(AxisService service, long pollInterval) {	pollInterval *= 1000;	TimerTask task = (TimerTask) serviceToTimerTaskMap.get(service);	if (task != null) {	task.cancel();	}	task = new TimerTask() {	public void run() {	if (pollInProgress) {	if (log.isDebugEnabled()) {	
transport onpoll trigger already executing poll 

}	task = new TimerTask() {	public void run() {	if (pollInProgress) {	if (log.isDebugEnabled()) {	}	return;	}	if (state == BaseConstants.PAUSED) {	if (log.isDebugEnabled()) {	
transport onpoll trigger transport is currently paused 

protected void startListeningForService(AxisService service) {	if (service.getName().startsWith("__")) {	return;	}	Parameter param = service.getParameter(TRANSPORT_POLL_INTERVAL);	long pollInterval = DEFAULT_POLL_INTERVAL;	if (param != null && param.getValue() instanceof String) {	try {	pollInterval = Integer.parseInt(param.getValue().toString());	} catch (NumberFormatException e) {	
invalid poll interval for service using defaults 

public void pause() throws AxisFault {	if (state != BaseConstants.STARTED) return;	state = BaseConstants.PAUSED;	
listener paused 

public void resume() throws AxisFault {	if (state != BaseConstants.PAUSED) return;	state = BaseConstants.STARTED;	
listener resumed 

public void maintenenceShutdown(long millis) throws AxisFault {	if (state != BaseConstants.STARTED) return;	stop();	state = BaseConstants.STOPPED;	
listener shutdown 

========================= synapse sample_4331 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start header mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	if (XMLConfigConstants.HEADER_SCOPE_TRANSPORT.equals(scope)) {	alterTransportHeader(synCtx);	} else {	alterSOAPOrKnownHeader(synCtx);	}	
end header mediator 

private void alterSOAPOrKnownHeader(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (action == ACTION_SET) {	String value = (getExpression() == null ? getValue() : expression.stringValueOf(synCtx));	if (synLog.isTraceOrDebugEnabled()) {	
setting header to 

} else if (SynapseConstants.HEADER_RELATES_TO.equals(qName.getLocalPart())) {	synCtx.setRelatesTo(new RelatesTo[] { new RelatesTo(value) });	} else {	addCustomHeader(synCtx, value);	}	} else {	addCustomHeader(synCtx, value);	}	} else {	if (synLog.isTraceOrDebugEnabled()) {	
removing header 

private void alterTransportHeader(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	String headerName = qName.getLocalPart();	String value = (getExpression() == null ? getValue() : expression.stringValueOf(synCtx));	if (action == ACTION_SET) {	if (synLog.isTraceOrDebugEnabled()) {	
setting transport header to 

if (headers != null && headers instanceof Map) {	Map headersMap = (Map) headers;	headersMap.put(headerName, value);	} else if (headers == null) {	Map headersMap = new HashMap();	headersMap.put(headerName, value);	axis2MessageCtx.setProperty( org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS, headersMap);	}	} else {	if (synLog.isTraceOrDebugEnabled()) {	
removing transport header 

} else {	if (synLog.isTraceOrDebugEnabled()) {	}	Axis2MessageContext axis2smc = (Axis2MessageContext) synCtx;	org.apache.axis2.context.MessageContext axis2MessageCtx = axis2smc.getAxis2MessageContext();	Object headers = axis2MessageCtx.getProperty( org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);	if (headers != null && headers instanceof Map) {	Map headersMap = (Map) headers;	headersMap.remove(headerName);	} else {	
no transport headers found 

========================= synapse sample_541 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start aggregate mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

synchronized (lock) {	if (activeAggregates.containsKey(correlateExpression.toString())) {	aggregate = activeAggregates.get(correlateExpression.toString());	if (aggregate != null) {	if (!aggregate.getLock()) {	aggregate = null;	}	}	} else {	if (synLog.isTraceOrDebugEnabled()) {	
creating new aggregator expires in secs without expiry time 

aggregate = activeAggregates.get(correlation);	if (aggregate != null) {	if (!aggregate.getLock()) {	aggregate = null;	}	} else {	break;	}	} else {	if (synLog.isTraceOrDebugEnabled()) {	
creating new aggregator expires in secs without expiry time 

synCtx.getConfiguration().getSynapseTimer(). schedule(aggregate, completionTimeoutMillis);	}	}	}	aggregate.getLock();	activeAggregates.put(correlation, aggregate);	}	}	}	} else {	
unable to find aggrgation correlation property 

}	aggregate.getLock();	activeAggregates.put(correlation, aggregate);	}	}	}	} else {	return true;	}	} else {	
unable to find aggrgation correlation xpath or property 

} else {	return true;	}	} else {	return true;	}	if (aggregate != null) {	boolean collected = aggregate.addMessage(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (collected) {	
collected a message during aggregation 

return true;	}	} else {	return true;	}	if (aggregate != null) {	boolean collected = aggregate.addMessage(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (collected) {	if (synLog.isTraceTraceEnabled()) {	
collected message 

}	if (aggregate != null) {	boolean collected = aggregate.addMessage(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (collected) {	if (synLog.isTraceTraceEnabled()) {	}	}	}	if (aggregate.isComplete(synLog)) {	
aggregation completed invoking oncomplete 

if (aggregate != null) {	boolean collected = aggregate.addMessage(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (collected) {	if (synLog.isTraceTraceEnabled()) {	}	}	}	if (aggregate.isComplete(synLog)) {	completeAggregate(aggregate);	
end aggregate mediator 

}	}	}	if (aggregate.isComplete(synLog)) {	completeAggregate(aggregate);	return true;	} else {	aggregate.releaseLock();	}	} else {	
unable to find an aggregate for this message skip 

return true;	} else {	aggregate.releaseLock();	}	} else {	return true;	}	} catch (JaxenException e) {	handleException("Unable to execute the XPATH over the message", e, synCtx);	}	
end aggregate mediator 

public void completeAggregate(Aggregate aggregate) {	boolean markedCompletedNow = false;	boolean wasComplete = aggregate.isCompleted();	if (wasComplete) {	return;	}	if (log.isDebugEnabled()) {	
aggregation completed or timed out 

aggregate.cancel();	aggregate.setCompleted(true);	markedCompletedNow = true;	}	}	if (!markedCompletedNow) {	return;	}	MessageContext newSynCtx = getAggregatedMessage(aggregate);	if (newSynCtx == null) {	
an aggregation of messages timed out with no aggregated messages 

private MessageContext getAggregatedMessage(Aggregate aggregate) {	MessageContext newCtx = null;	for (MessageContext synCtx : aggregate.getMessages()) {	if (newCtx == null) {	newCtx = synCtx;	if (log.isDebugEnabled()) {	
generating aggregated message from 

private MessageContext getAggregatedMessage(Aggregate aggregate) {	MessageContext newCtx = null;	for (MessageContext synCtx : aggregate.getMessages()) {	if (newCtx == null) {	newCtx = synCtx;	if (log.isDebugEnabled()) {	}	} else {	try {	if (log.isDebugEnabled()) {	
merging message using xpath 

if (newCtx == null) {	newCtx = synCtx;	if (log.isDebugEnabled()) {	}	} else {	try {	if (log.isDebugEnabled()) {	}	EIPUtils.enrichEnvelope( newCtx.getEnvelope(), synCtx.getEnvelope(), synCtx, aggregationExpression);	if (log.isDebugEnabled()) {	
merged result 

========================= synapse sample_1975 =========================

public boolean process(SynapseEnvironment se, SynapseMessage sm) {	
refdfineprocessor process 

========================= synapse sample_4624 =========================

public void writeTo(MessageContext msgCtx, OMOutputFormat format, OutputStream out, boolean preserve) throws AxisFault {	try {	quickfix.Message message = FIXUtils.getInstance().createFIXMessage(msgCtx);	out.write(message.toString().getBytes());	} catch (IOException e) {	
error while formatting fix soap message 

========================= synapse sample_1076 =========================

public void testScriptMediationWithInLineRuby() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test using in lined ruby scripts for mediation 

========================= synapse sample_812 =========================

public void createFIXAcceptor(AxisService service) {	InputStream fixConfigStream = getFIXConfigAsStream(service, true);	if (fixConfigStream != null) {	try {	if (log.isDebugEnabled()) {	
initializing a new fix session for the service 

SessionSettings settings = new SessionSettings(fixConfigStream);	MessageStoreFactory storeFactory = getMessageStoreFactory(service, settings, true);	MessageFactory messageFactory = new DefaultMessageFactory();	quickfix.LogFactory logFactory = getLogFactory(service, settings, true);	Application messageHandler = applicationFactory.getFIXApplication(service, true);	Acceptor acceptor = new SocketAcceptor( messageHandler, storeFactory, settings, logFactory, messageFactory);	acceptorStore.put(service.getName(),acceptor);	acceptor.start();	return;	} catch (ConfigError e) {	
error in the specified fix configuration unable to initialize a fix session for the service 

MessageFactory messageFactory = new DefaultMessageFactory();	quickfix.LogFactory logFactory = getLogFactory(service, settings, true);	Application messageHandler = applicationFactory.getFIXApplication(service, true);	Acceptor acceptor = new SocketAcceptor( messageHandler, storeFactory, settings, logFactory, messageFactory);	acceptorStore.put(service.getName(),acceptor);	acceptor.start();	return;	} catch (ConfigError e) {	}	}	
unable to initialize a fix session for the service 

public void createFIXInitiator(String fixEPR, AxisService service, SessionID sessionID) throws AxisFault {	if (log.isDebugEnabled()) {	
initializing a new fix initiator for the service 

quickfix.LogFactory logFactory = getLogFactory(service, settings, false);	MessageStoreFactory storeFactory = getMessageStoreFactory(service, settings, false);	MessageFactory messageFactory = new DefaultMessageFactory();	Application messageHandler = applicationFactory.getFIXApplication(service, false);	try {	Initiator initiator = new SocketInitiator( messageHandler, storeFactory, settings, logFactory, messageFactory);	initiatorStore.put(fixEPR, initiator);	applicationStore.put(fixEPR, messageHandler);	initiator.start();	FIXIncomingMessageHandler fixMessageHandler = (FIXIncomingMessageHandler) messageHandler;	
waiting for logon procedure to complete 

public void disposeFIXAcceptor(AxisService service) {	if (log.isDebugEnabled()) {	
stopping the fix acceptor for the service 

public void disposeFIXAcceptor(AxisService service) {	if (log.isDebugEnabled()) {	}	Acceptor acceptor = acceptorStore.get(service.getName());	if (acceptor != null) {	acceptor.stop();	
fix session for service terminated 

public String[] getServiceEPRs(String serviceName, String ip) {	if (log.isDebugEnabled()) {	
getting eprs for the service 

fixConfigURLParam = service.getParameter(FIXConstants.FIX_ACCEPTOR_CONFIG_URL_PARAM);	} else {	fixConfigURLParam = service.getParameter(FIXConstants.FIX_INITIATOR_CONFIG_URL_PARAM);	}	if (fixConfigURLParam != null) {	String fixConfigURLValue = fixConfigURLParam.getValue().toString();	try {	URL url = new URL(fixConfigURLValue);	fixConfigStream = url.openStream();	} catch (MalformedURLException e) {	
the fix configuration url is malformed 

} else {	fixConfigURLParam = service.getParameter(FIXConstants.FIX_INITIATOR_CONFIG_URL_PARAM);	}	if (fixConfigURLParam != null) {	String fixConfigURLValue = fixConfigURLParam.getValue().toString();	try {	URL url = new URL(fixConfigURLValue);	fixConfigStream = url.openStream();	} catch (MalformedURLException e) {	} catch (IOException e) {	
error while reading from the url 

}	if (fixConfigURLParam != null) {	String fixConfigURLValue = fixConfigURLParam.getValue().toString();	try {	URL url = new URL(fixConfigURLValue);	fixConfigStream = url.openStream();	} catch (MalformedURLException e) {	} catch (IOException e) {	}	} else {	
fix configuration url is not specified for the service 

if (msgLogMethod != null) {	String method = msgLogMethod.getValue().toString();	log.info("FIX message logging method = " + method);	if (FIXConstants.JDBC_BASED_MESSAGE_STORE.equals(method)) {	storeFactory = new JdbcStoreFactory(settings);	} else if (FIXConstants.SLEEPYCAT_BASED_MESSAGE_STORE.equals(method)) {	storeFactory = new SleepycatStoreFactory(settings);	} else if (FIXConstants.FILE_BASED_MESSAGE_STORE.equals(method)) {	storeFactory = new FileStoreFactory(settings);	} else if (!FIXConstants.MEMORY_BASED_MESSAGE_STORE.equals(method)) {	
invalid message store using defaults 

========================= synapse sample_4274 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	boolean isResponse = synCtx.isResponse();	ConfigurationContext cc;	org.apache.axis2.context.MessageContext axisMC;	if (synLog.isTraceOrDebugEnabled()) {	
start throttle mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	boolean isResponse = synCtx.isResponse();	ConfigurationContext cc;	org.apache.axis2.context.MessageContext axisMC;	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

isClusteringEnable = true;	}	}	if (!isResponse) {	if (isClusteringEnable) {	concurrentAccessController = (ConcurrentAccessController) cc.getProperty(key);	}	if (inLinePolicy != null) {	if (throttle == null) {	if (synLog.isTraceTraceEnabled()) {	
initializing using static throttling policy 

}	}	boolean canAccess = doThrottleByConcurrency(isResponse, synLog);	if (throttle != null && !isResponse && canAccess) {	canAccess = throttleByAccessRate(synCtx, axisMC, cc, synLog);	}	if (isClusteringEnable && concurrentAccessController != null) {	if (cc != null) {	try {	if (synLog.isTraceOrDebugEnabled()) {	
going to replicates the states of the concurrentaccesscontroller with key 

return mediator.mediate(synCtx);	} else {	handleException("Unable to find onReject sequence with key : " + onRejectSeqKey, synCtx);	}	} else if (onRejectMediator != null) {	return onRejectMediator.mediate(synCtx);	} else {	return false;	}	}	
end throttle mediator 

private boolean throttleByAccessRate(MessageContext synCtx, org.apache.axis2.context.MessageContext axisMC, ConfigurationContext cc, SynapseLog synLog) {	String callerId = null;	boolean canAccess = true;	String remoteIP = (String) axisMC.getPropertyNonReplicable( org.apache.axis2.context.MessageContext.REMOTE_ADDR);	String domainName = (String) axisMC.getPropertyNonReplicable(NhttpConstants.REMOTE_HOST);	if (domainName != null) {	if (synLog.isTraceOrDebugEnabled()) {	
the domain name of the caller is 

callerId = config.getConfigurationKeyOfCaller(domainName);	if (callerId != null) {	if (isClusteringEnable) {	context.setConfigurationContext(cc);	context.setThrottleId(id);	}	try {	AccessInformation accessInformation = accessControler.canAccess(context, callerId, ThrottleConstants.DOMAIN_BASE);	canAccess = accessInformation.isAccessAllowed();	if (synLog.isTraceOrDebugEnabled()) {	
access allowed denied for domain name 

cc.setProperty(key, concurrentAccessController);	}	}	} catch (ThrottleException e) {	handleException("Error occurred during throttling", e, synCtx);	}	}	}	}	} else {	
the domain name of the caller cannot be found 

handleException("Error occurred during throttling", e, synCtx);	}	}	}	}	} else {	}	if (callerId == null) {	if (remoteIP == null) {	if (synLog.isTraceOrDebugEnabled()) {	
the ip address of the caller cannot be found 

}	} else {	}	if (callerId == null) {	if (remoteIP == null) {	if (synLog.isTraceOrDebugEnabled()) {	}	canAccess = true;	} else {	if (synLog.isTraceOrDebugEnabled()) {	
the ip address of the caller is 

if (config != null) {	callerId = config.getConfigurationKeyOfCaller(remoteIP);	if (callerId != null) {	if (isClusteringEnable) {	context.setConfigurationContext(cc);	context.setThrottleId(id);	}	AccessInformation accessInformation = accessControler.canAccess( context, callerId, ThrottleConstants.IP_BASE);	canAccess = accessInformation.isAccessAllowed();	if (synLog.isTraceOrDebugEnabled()) {	
access allowed denied for ip 

========================= synapse sample_2573 =========================

public void receive(MessageContext messageContext) throws AxisFault {	
emptyrmmessagereceiver receive and inject the message into synapse environment 

public void receive(MessageContext messageContext) throws AxisFault {	
application message 

outMsgContext.getOperationContext().addMessageContext(outMsgContext);	org.apache.synapse.MessageContext synCtx = Axis2MessageContextFinder.getSynapseMessageContext(messageContext);	messageContext.setProperty(org.apache.synapse.Constants.MESSAGE_RECEIVED_RM_ENGAGED, Boolean.TRUE);	synCtx.getEnvironment().injectMessage(synCtx);	Object obj = messageContext.getProperty(org.apache.synapse.Constants.RESPONSE_SOAP_ENVELOPE);	if (obj != null) {	outMsgContext.setEnvelope((SOAPEnvelope)obj);	} else {	outMsgContext.setEnvelope(messageContext.getEnvelope());	}	
executed emptyrmmessagereceiver receive and java return for rmmediator 

========================= synapse sample_3227 =========================

protected void initInlineScript() {	try {	initScriptEngine();	if (scriptEngine instanceof Compilable) {	if (log.isDebugEnabled()) {	
script engine supports compilable interface compiling script code 

protected void initInlineScript() {	try {	initScriptEngine();	if (scriptEngine instanceof Compilable) {	if (log.isDebugEnabled()) {	}	compiledScript = ((Compilable)scriptEngine).compile(scriptSourceCode);	} else {	if (log.isDebugEnabled()) {	
script engine does not support the compilable interface inlined script would be evaluated on each invocation 

protected void initScriptEngine() {	if (log.isDebugEnabled()) {	
initializing script mediator for language 

protected void initScriptEngine() {	if (log.isDebugEnabled()) {	}	ScriptEngineManager manager = new ScriptEngineManager();	this.scriptEngine = manager.getEngineByExtension(language);	if (scriptEngine == null) {	handleException("No script engine found for language: " + language);	}	xmlHelper = XMLHelper.getArgHelper(scriptEngine);	this.multiThreadedEngine = scriptEngine.getFactory().getParameter("THREADING") != null;	
script mediator for language supports multithreading 

========================= synapse sample_4366 =========================

public void testErrorHandling() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to error handling 

public void testErrorHandling() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	SampleClientResult result = client.requestStandardQuote(addUrl, trpUrl, null, "IBM" ,null);	assertResponseReceived(result);	result = client.requestStandardQuote(addUrl, trpUrl, null, "MSFT" ,null);	assertFalse("Must not get a response", result.responseReceived());	Exception resultEx = result.getException();	assertNotNull("Did not receive expected error" , resultEx);	
got an error as expected 

assertResponseReceived(result);	result = client.requestStandardQuote(addUrl, trpUrl, null, "MSFT" ,null);	assertFalse("Must not get a response", result.responseReceived());	Exception resultEx = result.getException();	assertNotNull("Did not receive expected error" , resultEx);	assertTrue("Did not receive expected error", resultEx instanceof AxisFault);	result = client.requestStandardQuote(addUrl, trpUrl, null, "SUN" ,null);	assertFalse("Must not get a response", result.responseReceived());	Exception resultEx2 = result.getException();	assertNotNull("Did not receive expected error" , resultEx);	
got an error as expected 

========================= synapse sample_845 =========================

public void start() {	validate();	try {	URL.setURLStreamHandlerFactory(new URLStreamHandlerFactoryImpl());	} catch (Throwable t) {	
unable to register a urlstreamhandlerfactory custom url protocols may not work properly e g classpath 

if (trsIn.getParameter("port") != null) {	msg += " on port " + trsIn.getParameter("port").getValue();	}	log.info(msg);	listenerManager.addListener(trsIn, false);	}	Parameter synEnv = configctx.getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_ENV);	Parameter synCfg = configctx.getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_CONFIG);	String message = "Unable to initialize the Synapse Configuration : Cannot find the ";	if (synCfg == null || synCfg.getValue() == null || !(synCfg.getValue() instanceof SynapseConfiguration)) {	
synapse configuration 

}	Parameter synEnv = configctx.getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_ENV);	Parameter synCfg = configctx.getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_CONFIG);	String message = "Unable to initialize the Synapse Configuration : Cannot find the ";	if (synCfg == null || synCfg.getValue() == null || !(synCfg.getValue() instanceof SynapseConfiguration)) {	throw new SynapseException(message + "Synapse Configuration");	} else {	synConfig = (SynapseConfiguration) synCfg.getValue();	}	if (synEnv == null || synEnv.getValue() == null || !(synEnv.getValue() instanceof SynapseEnvironment)) {	
synapse environment 

if (synEnv == null || synEnv.getValue() == null || !(synEnv.getValue() instanceof SynapseEnvironment)) {	throw new SynapseException(message + "Synapse Environment");	} else {	((SynapseEnvironment) synEnv.getValue()).setInitialized(true);	for (Startup stp : ((SynapseConfiguration) synCfg.getValue()).getStartups()) {	if (stp != null) {	stp.init((SynapseEnvironment) synEnv.getValue());	}	}	}	
ready for processing 

throw new SynapseException(message + "Synapse Environment");	} else {	((SynapseEnvironment) synEnv.getValue()).setInitialized(true);	for (Startup stp : ((SynapseConfiguration) synCfg.getValue()).getStartups()) {	if (stp != null) {	stp.init((SynapseEnvironment) synEnv.getValue());	}	}	}	} catch (Throwable t) {	
synaps startup failed 

}	}	if (listenerManager != null) {	listenerManager.stop();	listenerManager.destroy();	}	if (configctx != null) {	configctx.terminate();	}	} catch (Exception e) {	
error stopping the servermanager 

private void validate() {	if (synapseHome == null || !new File(synapseHome).exists()) {	handleFatal("Synapse home");	} else {	
using synapse home as 

private void validate() {	if (synapseHome == null || !new File(synapseHome).exists()) {	handleFatal("Synapse home");	} else {	}	if (axis2Repolocation == null || !new File(axis2Repolocation).exists()) {	handleFatal("Axis2 repository");	} else {	
using the repository 

handleFatal("Synapse home");	} else {	}	if (axis2Repolocation == null || !new File(axis2Repolocation).exists()) {	handleFatal("Axis2 repository");	} else {	}	if (axis2Xml == null || !new File(axis2Xml).exists()) {	handleFatal("axis2.xml location");	} else {	
using the xml 

handleFatal("axis2.xml location");	} else {	}	if (synapseXMLPath == null || !new File(synapseXMLPath).exists()) {	handleFatal("synapse.xml path");	}	if (serverName == null) {	try {	serverName = InetAddress.getLocalHost().getHostName();	} catch (UnknownHostException ignore) {}	
the server name was not specified defaulting to 

} else {	}	if (synapseXMLPath == null || !new File(synapseXMLPath).exists()) {	handleFatal("synapse.xml path");	}	if (serverName == null) {	try {	serverName = InetAddress.getLocalHost().getHostName();	} catch (UnknownHostException ignore) {}	} else {	
using server name 

}	if (synapseXMLPath == null || !new File(synapseXMLPath).exists()) {	handleFatal("synapse.xml path");	}	if (serverName == null) {	try {	serverName = InetAddress.getLocalHost().getHostName();	} catch (UnknownHostException ignore) {}	} else {	}	
the timeout handler will run every s 

========================= synapse sample_4223 =========================

suiteName = "AllSamplesSuite";	for (int i = 0; i <= 20000; i++) {	Class testClass = (Class) sampleClassRepo.get(Integer.toString(i));	if (testClass != null) {	suiteClassesList.add(testClass);	}	}	}	for (Class testClass : suiteClassesList) {	suite.addTestSuite(testClass);	
adding sample 

========================= synapse sample_795 =========================

protected void handleSingleSecretCallback(SingleSecretCallback singleSecretCallback) {	if (secretCallbackHandler == null) {	if (log.isWarnEnabled()) {	
there is no shared secretcallbackhandler please use any other secretcallbackhandler implementations 

========================= synapse sample_2524 =========================

}	pt.setChannel(connectionFactory.getChannel());	pt.setConnectionFactoryName(connectionFactory.getName());	String responseConFac = AMQPTransportUtils.getOptionalStringParameter( AMQPTransportConstant.PARAMETER_RESPONSE_CONNECTION_FACTORY_NAME, svcParam, conFacParam);	if (responseConFac != null) {	pt.setResponseConnectionFactory(responseConFac);	}	String consumerExchange = AMQPTransportUtils.getOptionalStringParameter( AMQPTransportConstant.PARAMETER_BIND_EXCHANGE, svcParam, conFacParam);	if (consumerExchange != null) {	if (exchangeName != null && !consumerExchange.equals(exchangeName)) {	
possible configuration error exchange name is set to and consumer s exchange name is set to 

pt.setScheduledTaskDelay(delay.intValue());	}	} catch (AMQPTransportException e) {	throw new AxisFault("Could not assign the scheduled task delay value", e);	}	String timeUnit = AMQPTransportUtils.getOptionalStringParameter( AMQPTransportConstant.PARAMETER_SCHEDULED_TASK_TIME_UNIT, svcParam, conFacParam);	if (timeUnit != null) {	pt.setScheduledTaskTimeUnit(getTimeUnit(timeUnit));	}	if (log.isDebugEnabled()) {	
a polling task for the service was produced with following parameters exchange name exchange type exchange durable exchange autodelete is internal exchange consumer exchange routing keys queuename is queue durable is queue restricted is queue auto deleted is blocking mode number of concurrent consumers number of dispatching task 

========================= synapse sample_2461 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start spring mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

} else {	if (appContext == null) {	buildAppContext(synCtx, synLog);	}	}	if (appContext != null) {	Object o = appContext.getBean(beanName);	if (o != null && Mediator.class.isAssignableFrom(o.getClass())) {	Mediator m = (Mediator) o;	if (synLog.isTraceOrDebugEnabled()) {	
loaded mediator from bean executing 

}	if (appContext != null) {	Object o = appContext.getBean(beanName);	if (o != null && Mediator.class.isAssignableFrom(o.getClass())) {	Mediator m = (Mediator) o;	if (synLog.isTraceOrDebugEnabled()) {	}	return m.mediate(synCtx);	} else {	if (synLog.isTraceOrDebugEnabled()) {	
unable to load mediator from bean 

}	return m.mediate(synCtx);	} else {	if (synLog.isTraceOrDebugEnabled()) {	}	handleException("Could not load bean named : " + beanName + " from the Spring configuration with key : " + configKey, synCtx);	}	} else {	handleException("Cannot reference application context with key : " + configKey, synCtx);	}	
end spring mediator 

private synchronized void buildAppContext(MessageContext synCtx, SynapseLog synLog) {	if (synLog.isTraceOrDebugEnabled()) {	
creating spring applicationcontext from key 

xbdr.setValidating(false);	Object springConfig = synCtx.getEntry(configKey);	if(springConfig == null) {	String errorMessage = "Cannot look up Spring configuration " + configKey;	log.error(errorMessage);	throw new SynapseException(errorMessage);	}	xbdr.loadBeanDefinitions( new InputStreamResource( SynapseConfigUtils.getStreamSource(springConfig).getInputStream()));	appContext.refresh();	if (synLog.isTraceOrDebugEnabled()) {	
spring applicationcontext from key created 

========================= synapse sample_1172 =========================

public void echoVoid() {	
echo service called 

public void echoOMElementNoResponse(OMElement omEle) {	
echoomelementnoresponse service called 

========================= synapse sample_4235 =========================

public void testFullRegistryBasedConfig() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test local registry entry definitions reusable endpoints and sequences 

========================= synapse sample_853 =========================

public void addDestination(String destinationJNDIName, String destinationType, String serviceName) {	String destinationName = getPhysicalDestinationName(destinationJNDIName);	if (destinationName == null) {	
jms destination with jndi name does not exist 

public void addDestination(String destinationJNDIName, String destinationType, String serviceName) {	String destinationName = getPhysicalDestinationName(destinationJNDIName);	if (destinationName == null) {	try {	
creating a jms queue with the jndi name using the connection factory definition named 

public void addDestination(String destinationJNDIName, String destinationType, String serviceName) {	String destinationName = getPhysicalDestinationName(destinationJNDIName);	if (destinationName == null) {	try {	JMSUtils.createDestination(conFactory, destinationJNDIName, destinationType);	destinationName = getPhysicalDestinationName(destinationJNDIName);	} catch (JMSException e) {	
unable to create destination with jndi name 

JMSUtils.createDestination(conFactory, destinationJNDIName, destinationType);	destinationName = getPhysicalDestinationName(destinationJNDIName);	} catch (JMSException e) {	BaseUtils.markServiceAsFaulty( serviceName, "Error creating JMS destination : " + destinationJNDIName, cfgCtx.getAxisConfiguration());	return;	}	}	serviceJNDINameMapping.put(destinationJNDIName, serviceName);	destinationTypeMapping.put(destinationJNDIName, destinationType);	serviceDestinationNameMapping.put(destinationName, serviceName);	
mapped jndi name and jms destination name against service 

public synchronized void connectAndListen() throws JMSException, NamingException {	if (connection != null) {	
re initializing the jms connection factory 

while (sessionIter.hasNext()) {	try {	((Session) sessionIter.next()).close();	} catch (JMSException ignore) {}	}	try {	connection.stop();	} catch (JMSException ignore) {}	} else {	if (log.isDebugEnabled()) {	
initializing the jms connection factory 

}	try {	connection.stop();	} catch (JMSException ignore) {}	} else {	if (log.isDebugEnabled()) {	}	}	context = new InitialContext(jndiProperties);	conFactory = (ConnectionFactory) context.lookup(connFactoryJNDIName);	
connected to the jms connection factory 

} catch (JMSException e) {	handleException("Error connecting to Connection Factory : " + connFactoryJNDIName, e);	}	Iterator destJNDINameIter = serviceJNDINameMapping.keySet().iterator();	while (destJNDINameIter.hasNext()) {	String destJNDIName = (String) destJNDINameIter.next();	String destinationType = (String) destinationTypeMapping.get(destJNDIName);	startListeningOnDestination(destJNDIName, destinationType);	}	connection.start();	
connection factory initialized 

try {	session.close();	} catch (JMSException ignore) {}	}	try {	session = JMSUtils.createSession(connection, false, Session.AUTO_ACKNOWLEDGE, destinationType);	Destination destination = null;	try {	destination = (Destination) context.lookup(destinationJNDIname);	} catch (NameNotFoundException e) {	
cannot find destination creating a queue 

if (connection != null) {	Iterator sessionIter = jmsSessions.values().iterator();	while (sessionIter.hasNext()) {	try {	((Session) sessionIter.next()).close();	} catch (JMSException ignore) {}	}	try {	connection.close();	} catch (JMSException e) {	
error shutting down connection factory 

private String getPhysicalDestinationName(String destinationJndi) {	Destination destination = getPhysicalDestination(destinationJndi);	if (destination != null) {	try {	if (destination instanceof Queue) {	return ((Queue) destination).getQueueName();	} else if (destination instanceof Topic) {	return ((Topic) destination).getTopicName();	}	} catch (JMSException e) {	
error reading destination name for jndi destination 

destination = (Destination) context.lookup(destinationJndi);	} catch (NamingException e) {	String provider = (String) jndiProperties.get(Context.INITIAL_CONTEXT_FACTORY);	if (provider.indexOf("activemq") != -1) {	try {	destination = (Destination) context.lookup( JMSConstants.ACTIVEMQ_DYNAMIC_QUEUE + destinationJndi);	} catch (NamingException ne) {	try {	destination = (Destination) context.lookup( JMSConstants.ACTIVEMQ_DYNAMIC_TOPIC + destinationJndi);	} catch (NamingException e1) {	
error looking up destination for jndi name 

public void onException(JMSException e) {	
jms connection factory encountered an error 

public void onException(JMSException e) {	boolean wasError = true;	while (wasError == true) {	try {	connectAndListen();	wasError = false;	} catch (Exception e1) {	
jms reconnection attempt failed for connection factory 

public void onException(JMSException e) {	boolean wasError = true;	while (wasError == true) {	try {	connectAndListen();	wasError = false;	} catch (Exception e1) {	}	if (wasError == true) {	try {	
attempting reconnection for connection factory in seconds 

========================= synapse sample_3773 =========================

private static Properties loadProperties(String filePath) {	Properties properties = new Properties();	ClassLoader cl = Thread.currentThread().getContextClassLoader();	if (log.isDebugEnabled()) {	
loading a file from classpath 

private static Properties loadProperties(String filePath) {	Properties properties = new Properties();	ClassLoader cl = Thread.currentThread().getContextClassLoader();	if (log.isDebugEnabled()) {	}	InputStream in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	
unable to load file 

Properties properties = new Properties();	ClassLoader cl = Thread.currentThread().getContextClassLoader();	if (log.isDebugEnabled()) {	}	InputStream in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	}	filePath = "repository/conf" + File.separatorChar + filePath;	if (log.isDebugEnabled()) {	
loading a file from classpath 

InputStream in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	}	filePath = "repository/conf" + File.separatorChar + filePath;	if (log.isDebugEnabled()) {	}	in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	
unable to load file 

========================= synapse sample_2477 =========================

public static void main(String[] args) throws Exception {	if (args.length <= 0 || args.length == 2 || args.length == 3 || args.length >= 8) {	printUsage();	}	
starting apache synapse 

public static void main(String[] args) throws Exception {	if (args.length <= 0 || args.length == 2 || args.length == 3 || args.length >= 8) {	printUsage();	}	ServerConfigurationInformation configurationInformation = ServerConfigurationInformationFactory.createServerConfigurationInformation(args);	serverManager = new ServerManager();	serverManager.init(configurationInformation, null);	try {	serverManager.start();	addShutdownHook();	
apache synapse started successfully 

printUsage();	}	ServerConfigurationInformation configurationInformation = ServerConfigurationInformationFactory.createServerConfigurationInformation(args);	serverManager = new ServerManager();	serverManager.init(configurationInformation, null);	try {	serverManager.start();	addShutdownHook();	new CountDownLatch(1).await();	} catch (SynapseException e) {	
error starting apache synapse trying a clean shutdown 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	
shutting down apache synapse 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	serverManager.shutdown();	
apache synapse shutdown complete 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	serverManager.shutdown();	
halting jvm 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	serverManager.shutdown();	} catch (Exception e) {	
error occurred while shutting down apache synapse it may not be a clean shutdown 

========================= synapse sample_2027 =========================

public static void markServiceAsFaulty(String serviceName, String msg, AxisConfiguration axisCfg) {	if (serviceName != null) {	try {	AxisService service = axisCfg.getService(serviceName);	axisCfg.getFaultyServices().put(service.getName(), msg);	} catch (AxisFault axisFault) {	
error marking service as faulty 

private SOAPEnvelope handleLegacyMessage(MessageContext msgContext, Object message) {	SOAPFactory soapFactory = new SOAP11Factory();	SOAPEnvelope envelope;	if (log.isDebugEnabled()) {	
non soap xml message received 

========================= synapse sample_4327 =========================

public void testConcurrencyAndRateThrottling() {	String addUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test concurrency throttling and request rate based throttling 

========================= synapse sample_804 =========================

public boolean process(SynapseEnvironment se, SynapseMessage smc) {	
processing addressinginhandler 

========================= synapse sample_4632 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start header mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	if (action == ACTION_SET) {	String value = (getExpression() == null ? getValue() : expression.stringValueOf(synCtx));	if (synLog.isTraceOrDebugEnabled()) {	
set soap header to 

} else if (SynapseConstants.HEADER_RELATES_TO.equals(qName.getLocalPart())) {	synCtx.setRelatesTo(new RelatesTo[] { new RelatesTo(value) });	} else {	addCustomHeader(synCtx, value);	}	} else {	addCustomHeader(synCtx, value);	}	} else {	if (synLog.isTraceOrDebugEnabled()) {	
removing soap header 

} else {	SOAPEnvelope envelope = synCtx.getEnvelope();	if (envelope != null) {	SOAPHeader header = envelope.getHeader();	if (header != null) {	removeFromHeaderList(header. getHeaderBlocksWithNSURI(qName.getNamespaceURI()));	}	}	}	}	
end header mediator 

========================= synapse sample_1963 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start clone mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	Iterator<Target> iter = targets.iterator();	int i = 0;	while (iter.hasNext()) {	if (synLog.isTraceOrDebugEnabled()) {	
submitting of messages for processing in parallel 

int i = 0;	while (iter.hasNext()) {	if (synLog.isTraceOrDebugEnabled()) {	}	iter.next().mediate(getClonedMessageContext(synCtx, i++, targets.size()));	}	OperationContext opCtx = ((Axis2MessageContext) synCtx).getAxis2MessageContext().getOperationContext();	if (!continueParent && opCtx != null) {	opCtx.setProperty(Constants.RESPONSE_WRITTEN, "SKIP");	}	
end clone mediator 

========================= synapse sample_557 =========================

public static SynapseConfiguration getConfiguration(InputStream is, Properties properties) throws XMLStreamException {	
generating the synapse configuration model by parsing the xml configuration 

========================= synapse sample_384 =========================

public void streamMessageContents() throws AxisFault {	if (log.isDebugEnabled()) {	
start streaming outgoing http request message id 

public void streamMessageContents() throws AxisFault {	if (log.isDebugEnabled()) {	if (log.isTraceEnabled()) {	
message request message id request message payload 

if (chunked) {	messageFormatter.writeTo(msgContext, format, out, false);	} else {	writeMessageFromTempData(out);	}	}	} catch (Exception e) {	Throwable t = e.getCause();	if (t != null && t.getCause() != null && t.getCause() instanceof ClosedChannelException) {	if (log.isDebugEnabled()) {	
ignore closed channel exception as the sessionrequestcallback handles this exception 

}	} catch (Exception e) {	Throwable t = e.getCause();	if (t != null && t.getCause() != null && t.getCause() instanceof ClosedChannelException) {	if (log.isDebugEnabled()) {	}	} else {	Integer errorCode = msgContext == null ? null : (Integer) msgContext.getProperty(NhttpConstants.ERROR_CODE);	if (errorCode == null || errorCode == NhttpConstants.SEND_ABORT) {	if (log.isDebugEnabled()) {	
remote server aborted request being sent and responded 

========================= synapse sample_2420 =========================

private void scanFileOrDirectory(final PollTableEntry entry, String fileURI) {	FileObject fileObject = null;	if (log.isDebugEnabled()) {	
scanning directory or file 

}	boolean wasError = true;	int retryCount = 0;	int maxRetryCount = entry.getMaxRetryCount();	long reconnectionTimeout = entry.getReconnectTimeout();	while(wasError == true) {	try {	retryCount++;	fileObject = fsManager.resolveFile(fileURI);	if(fileObject == null) {	
fileobject is null 

long reconnectionTimeout = entry.getReconnectTimeout();	while(wasError == true) {	try {	retryCount++;	fileObject = fsManager.resolveFile(fileURI);	if(fileObject == null) {	throw new FileSystemException("fileObject is null");	}	wasError = false;	} catch(FileSystemException e) {	
cannot resolve fileobject 

entry.setLastPollState(PollTableEntry.SUCCSESSFUL);	} catch (AxisFault e) {	entry.setLastPollState(PollTableEntry.FAILED);	}	moveOrDeleteAfterProcessing(entry, fileObject);	}	} else {	int failCount = 0;	int successCount = 0;	if (log.isDebugEnabled()) {	
file name pattern 

}	moveOrDeleteAfterProcessing(entry, fileObject);	}	} else {	int failCount = 0;	int successCount = 0;	if (log.isDebugEnabled()) {	}	for (int i = 0; i < children.length; i++) {	if (log.isDebugEnabled()) {	
matching file 

int failCount = 0;	int successCount = 0;	if (log.isDebugEnabled()) {	}	for (int i = 0; i < children.length; i++) {	if (log.isDebugEnabled()) {	}	if ( (entry.getFileNamePattern() != null) && (children[i].getName().getBaseName().matches(entry.getFileNamePattern()))) {	try {	if (log.isDebugEnabled()) {	
processing file 

entry.setLastPollState(PollTableEntry.FAILED);	} else {	entry.setLastPollState(PollTableEntry.WITH_ERRORS);	}	}	long now = System.currentTimeMillis();	entry.setLastPollTime(now);	entry.setNextPollTime(now + entry.getPollInterval());	} else {	if (log.isDebugEnabled()) {	
unable to access or read file or directory 

break;	case PollTableEntry.FAILED: if (entry.getActionAfterProcess() == PollTableEntry.MOVE) {	moveToDirectory = entry.getMoveAfterFailure();	}	break;	case PollTableEntry.NONE: return;	}	if (moveToDirectory != null) {	String destName = moveToDirectory + File.separator + fileObject.getName().getBaseName();	if (log.isDebugEnabled()) {	
moving to file 

case PollTableEntry.NONE: return;	}	if (moveToDirectory != null) {	String destName = moveToDirectory + File.separator + fileObject.getName().getBaseName();	if (log.isDebugEnabled()) {	}	FileObject dest = fsManager.resolveFile(destName);	try {	fileObject.moveTo(dest);	} catch (FileSystemException e) {	
error moving file to 

if (log.isDebugEnabled()) {	}	FileObject dest = fsManager.resolveFile(destName);	try {	fileObject.moveTo(dest);	} catch (FileSystemException e) {	}	} else {	try {	if (log.isDebugEnabled()) {	
deleting file 

try {	fileObject.moveTo(dest);	} catch (FileSystemException e) {	}	} else {	try {	if (log.isDebugEnabled()) {	}	fileObject.close();	if (!fileObject.delete()) {	
cannot delete file 

} catch (FileSystemException e) {	}	} else {	try {	if (log.isDebugEnabled()) {	}	fileObject.close();	if (!fileObject.delete()) {	}	} catch (FileSystemException e) {	
error deleting file 

try {	if (log.isDebugEnabled()) {	}	fileObject.close();	if (!fileObject.delete()) {	}	} catch (FileSystemException e) {	}	}	} catch (FileSystemException e) {	
error resolving directory to move after processing 

if (operation != null) {	msgContext.setAxisOperation(operation);	}	Parameter param = service.getParameter(VFSConstants.REPLY_FILE_URI);	if (param != null && param.getValue() != null) {	msgContext.setProperty( Constants.OUT_TRANSPORT_INFO, new VFSOutTransportInfo((String) param.getValue()));	}	VFSUtils.getInstace().setSOAPEnvelope(content, msgContext, contentType);	handleIncomingMessage( msgContext, transportHeaders, null, contentType );	if (log.isDebugEnabled()) {	
processed file of content type 

VFSUtils.getInstace().setSOAPEnvelope(content, msgContext, contentType);	handleIncomingMessage( msgContext, transportHeaders, null, contentType );	if (log.isDebugEnabled()) {	}	} catch (FileSystemException e) {	handleException("Error reading file content or attributes : " + file, e);	} finally {	try {	file.close();	} catch (FileSystemException warn) {	
cannot close file after processing 

protected void startListeningForService(AxisService service) {	Parameter param = service.getParameter(BaseConstants.TRANSPORT_POLL_INTERVAL);	long pollInterval = BaseConstants.DEFAULT_POLL_INTERVAL;	if (param != null && param.getValue() instanceof String) {	try {	pollInterval = Integer.parseInt(param.getValue().toString());	} catch (NumberFormatException e) {	
invalid poll interval for service default to sec 

========================= synapse sample_3725 =========================

private static void registerExtensions() {	Iterator<ConfigurationFactory> factories = ServiceLoader.load(ConfigurationFactory.class).iterator();	while (factories.hasNext()) {	ConfigurationFactory factory = factories.next();	QName tag = factory.getTagQName();	factoryMap.put(tag, factory.getClass());	serializerMap.put(tag, factory.getSerializerClass());	if (log.isDebugEnabled()) {	
added mediatorfactory to handle 

public SynapseConfiguration getConfiguration(OMElement element, Properties properties) {	String localName = element.getLocalName();	QName qName;	if (element.getNamespace() != null) {	qName = new QName(element.getNamespace().getNamespaceURI(), localName);	} else {	qName = new QName(localName);	}	if (log.isDebugEnabled()) {	
getconfiguration 

========================= synapse sample_385 =========================

public SNMPAgent(Properties properties) {	super(new File(SNMPConstants.BC_FILE), new File(SNMPConstants.CONFIG_FILE), new CommandProcessor(new OctetString(MPv3.createLocalEngineID())));	this.properties = properties;	String version = getProperty(SNMPConstants.SNMP_VERSION, SNMPConstants.SNMP_DEFAULT_VERSION);	if (SNMPConstants.SNMP_VERSION_1.equals(version)) {	this.snmpVersion = SnmpConstants.version1;	} else if (SNMPConstants.SNMP_VERSION_2_C.equals(version)) {	this.snmpVersion = SnmpConstants.version2c;	} else {	
unsupported snmp version using defaults 

protected void initTransportMappings() throws IOException {	String host = getProperty(SNMPConstants.SNMP_HOST, SNMPConstants.SNMP_DEFAULT_HOST);	int port = Integer.parseInt(getProperty(SNMPConstants.SNMP_PORT, String.valueOf(SNMPConstants.SNMP_DEFAULT_PORT)));	String address = host + "/" + port;	Address adr = GenericAddress.parse(address);	TransportMapping tm = TransportMappings.getInstance().createTransportMapping(adr);	transportMappings = new TransportMapping[] { tm };	
snmp transport adapter initialized on udp 

protected void registerManagedObjects() {	
initializing synapse snmp mib 

attributeNames.add(attributeInfo.getName());	if (Map.class.getName().equals(attributeInfo.getType())) {	mapAttributes.add(attributeInfo.getName());	}	}	Collections.sort(attributeNames);	doRegister(attributeNames, mapAttributes, oidString, objectName);	}	}	} catch (Exception e) {	
error while initializing the snmp mib 

private void doRegister(List<String> attributeNames, List<String> mapAttributes, String oidString, ObjectName objectName) {	for (int i = 0; i < attributeNames.size(); i++) {	String attributeName = attributeNames.get(i);	if (mapAttributes.contains(attributeName)) {	continue;	}	OID oid = new OID(oidString + "." + (i + 1) + ".0");	if (log.isDebugEnabled()) {	
registering as oid 

if (mapAttributes.contains(attributeName)) {	continue;	}	OID oid = new OID(oidString + "." + (i + 1) + ".0");	if (log.isDebugEnabled()) {	}	try {	server.register(new SynapseMOScalar( oid, objectName, attributeName, snmpVersion), null);	registeredOIDs.add(oid);	} catch (DuplicateRegistrationException e) {	
error while registering the oid for object and attribute 

protected void unregisterManagedObjects() {	if (log.isDebugEnabled()) {	
cleaning up registered oids 

protected void addCommunities(SnmpCommunityMIB communityMIB) {	String community = getProperty(SNMPConstants.SNMP_COMMUNITY_NAME, SNMPConstants.SNMP_DEFAULT_COMMUNITY_NAME);	String securityName = getProperty(SNMPConstants.SNMP_SECURITY_NAME, SNMPConstants.SNMP_DEFAULT_SECURITY_NAME);	String context = getProperty(SNMPConstants.SNMP_CONTEXT_NAME, SNMPConstants.SNMP_DEFAULT_CONTEXT_NAME);	if (log.isDebugEnabled()) {	
registering snmp community string under the context 

========================= synapse sample_2134 =========================

public static NHttpClientConnection getConnection(String host, int port) {	String key = host + ":" + Integer.toString(port);	List<NHttpClientConnection> connections = connMap.get(key);	if (connections == null || connections.isEmpty()) {	if (log.isDebugEnabled()) {	
no connections available for reuse 

if (log.isDebugEnabled()) {	}	return null;	} else {	NHttpClientConnection conn;	synchronized (connections) {	while (!connections.isEmpty()) {	conn = connections.remove(0);	if (conn.isOpen() && !conn.isStale()) {	if (log.isDebugEnabled()) {	
a connection to host on port is available in the pool and will be reused 

synchronized (connections) {	while (!connections.isEmpty()) {	conn = connections.remove(0);	if (conn.isOpen() && !conn.isStale()) {	if (log.isDebugEnabled()) {	}	conn.requestInput();	return conn;	} else {	if (log.isDebugEnabled()) {	
closing stale connection to 

connections = connMap.get(key);	if (connections == null) {	connections = Collections.synchronizedList(new LinkedList<NHttpClientConnection>());	connMap.put(key, connections);	}	}	}	cleanConnectionReferences(conn);	connections.add(conn);	if (log.isDebugEnabled()) {	
released a connection to host on port to the connection pool of current size 

========================= synapse sample_2421 =========================

public void receive(org.apache.axis2.context.MessageContext mc) throws AxisFault {	
synapse received a new message 

public void receive(org.apache.axis2.context.MessageContext mc) throws AxisFault {	log.debug("Received To: " + (mc.getTo() != null ? mc.getTo().getAddress() : "null"));	log.debug("SOAPAction: " + (mc.getWSAAction() != null ? mc.getWSAAction() : "null"));	if (log.isDebugEnabled()) {	
body 

========================= synapse sample_3230 =========================

public void testAccessingAPIUsingScripting() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test accessing synapse message context api methods using scripting language 

========================= synapse sample_805 =========================

protected void doInit() throws AxisFault {	connectionFactoryES = Executors.newFixedThreadPool( AMQPTransportUtils.getIntProperty( AMQPTransportConstant.PARAM_CONNECTION_FACTORY_POOL_SIZE, AMQPTransportConstant.CONNECTION_FACTORY_POOL_DEFAULT));	connectionFactoryManager = new AMQPTransportConnectionFactoryManager();	connectionFactoryManager.addConnectionFactories( getTransportInDescription(), connectionFactoryES);	workerPool = Executors.newScheduledThreadPool( AMQPTransportUtils.getIntProperty(AMQPTransportConstant.PARAM_WORKER_POOL_SIZE, AMQPTransportConstant.WORKER_POOL_DEFAULT));	int initialReconnectDuration = AMQPTransportUtils.getIntProperty( AMQPTransportConstant.PARAM_INITIAL_RE_CONNECTION_DURATION, 1000);	double reconnectionProgressionFactor = AMQPTransportUtils.getDoubleProperty( AMQPTransportConstant.PARAM_RE_CONNECTION_PROGRESSION_FACTOR, 2.0);	int maxReconnectionDuration = AMQPTransportUtils.getIntProperty( AMQPTransportConstant.PARAM_MAX_RE_CONNECTION_DURATION, 1000 * 60 * 10);	haHandlerTask = new AMQPTransportReconnectHandler( connectionFactoryES, maxReconnectionDuration, reconnectionProgressionFactor, initialReconnectDuration, connectionFactoryManager);	new Thread(haHandlerTask, "AMQP-HA-handler-task").start();	
amqp transport listener initializing 

protected void startEndpoint(AMQPTransportEndpoint endpoint) throws AxisFault {	AMQPTransportPollingTask ptm = endpoint.getPollingTask();	try {	ptm.start();	} catch (AMQPTransportException e) {	throw new AxisFault(e.getMessage(), e);	}	
amqp transport polling task started listen for service 

protected void stopEndpoint(AMQPTransportEndpoint endpoint) {	AMQPTransportPollingTask ptm = endpoint.getPollingTask();	ptm.stop();	
amqp transport polling task stopped listen for service 

public void stop() throws AxisFault {	super.stop();	workerPool.shutdown();	try {	connectionFactoryManager.shutDownConnectionFactories();	} catch (AMQPTransportException e) {	
error while shutting down connection factories continue anyway 

========================= synapse sample_1061 =========================

public boolean process(SynapseEnvironment se, SynapseMessage sm) {	
process 

========================= synapse sample_4633 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start fault mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

synCtx.setTo(synCtx.getFaultTo());	} else if (synCtx.getReplyTo() != null) {	synCtx.setTo(synCtx.getReplyTo());	} else {	synCtx.setTo(null);	}	if(synCtx.getMessageID() != null) {	RelatesTo relatesTo = new RelatesTo(synCtx.getMessageID());	synCtx.setRelatesTo(new RelatesTo[] { relatesTo });	}	
end fault mediator 

========================= synapse sample_1962 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start iterate mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	try {	SOAPEnvelope envelope = MessageHelper.cloneSOAPEnvelope(synCtx.getEnvelope());	List splitElements = EIPUtils.getDetachedMatchingElements(envelope, synCtx, expression);	if (synLog.isTraceOrDebugEnabled()) {	
splitting with xpath resulted in elements 

if (!preservePayload && envelope.getBody() != null) {	envelope.getBody().removeChildren();	}	int msgCount = splitElements.size();	int msgNumber = 0;	for (Object o : splitElements) {	if (!(o instanceof OMNode)) {	handleException("Error splitting message with XPath : " + expression + " - result not an OMNode", synCtx);	}	if (synLog.isTraceOrDebugEnabled()) {	
submitting of messages for processing in parallel messages for processing sequentially 

}	} catch (JaxenException e) {	handleException("Error evaluating split XPath expression : " + expression, e, synCtx);	} catch (AxisFault af) {	handleException("Error creating an iterated copy of the message", af, synCtx);	}	OperationContext opCtx = ((Axis2MessageContext) synCtx).getAxis2MessageContext().getOperationContext();	if (!continueParent && opCtx != null) {	opCtx.setProperty(Constants.RESPONSE_WRITTEN,"SKIP");	}	
end iterate mediator 

========================= synapse sample_556 =========================

public void init(Properties props) {	if (props == null) {	if (log.isDebugEnabled()) {	
enterprise beanstalk properties cannot be found 

public void init(Properties props) {	if (props == null) {	if (log.isDebugEnabled()) {	}	return;	}	String beanstalkNameList = MiscellaneousUtil.getProperty(props, EnterpriseBeanstalkConstants.SYNAPSE_BEANSTALK_PREFIX, null);	if (beanstalkNameList == null || "".equals(beanstalkNameList)) {	if (log.isDebugEnabled()) {	
no beanstalks defined for initialization 

}	String beanstalkNameList = MiscellaneousUtil.getProperty(props, EnterpriseBeanstalkConstants.SYNAPSE_BEANSTALK_PREFIX, null);	if (beanstalkNameList == null || "".equals(beanstalkNameList)) {	if (log.isDebugEnabled()) {	}	return;	}	String[] beanstalkNames = beanstalkNameList.split(",");	if (beanstalkNames == null || beanstalkNames.length == 0) {	if (log.isDebugEnabled()) {	
no beanstalk definitions found for initialization 

public void destroy() {	Iterator<EnterpriseBeanstalk> it = beanstalkMap.values().iterator();	while (it.hasNext()) {	it.next().destroy();	it.remove();	}	if (scheduler != null && !scheduler.isShutdown()) {	if (log.isDebugEnabled()) {	
shutting down enterprise beanstalk cache cleaner executor 

========================= synapse sample_782 =========================

public RegistryEntry getRegistryEntry(String key) {	
perform registryentry lookup for key 

========================= synapse sample_3322 =========================

public void addConnectionFactories(ParameterInclude transportInDescription, ExecutorService es) {	for (Parameter p : transportInDescription.getParameters()) {	try {	addConnectionFactory(p, es);	} catch (AMQPTransportException e) {	
error whiling adding the connection factory with name 

========================= synapse sample_2476 =========================

if (GZIP_CODEC.equals(encode)) {	Object obj = response.getProperty(MessageContext.TRANSPORT_HEADERS);	Map responseHeaders;	if (obj != null && obj instanceof Map) {	responseHeaders = (Map) obj;	} else {	responseHeaders = new HashMap();	response.setProperty(MessageContext.TRANSPORT_HEADERS, responseHeaders);	}	if (log.isDebugEnabled()) {	
sets the content encoding header as 

========================= synapse sample_297 =========================

Parameter keyParam    = transportOut.getParameter("keystore");	Parameter trustParam  = transportOut.getParameter("truststore");	OMElement ksEle = null;	OMElement tsEle = null;	if (keyParam != null) {	ksEle = keyParam.getParameterElement().getFirstElement();	}	boolean novalidatecert = ParamUtils.getOptionalParamBoolean(transportOut, "novalidatecert", false);	if (trustParam != null) {	if (novalidatecert) {	
ignoring novalidatecert parameter since a truststore has been specified 

private Map<String, SSLContext> getCustomSSLContexts(TransportOutDescription transportOut) throws AxisFault {	if (log.isDebugEnabled()) {	
loading custom ssl profiles for the https sender 

OMElement ksElt = profile.getFirstChildWithName(new QName("KeyStore"));	OMElement trElt = profile.getFirstChildWithName(new QName("TrustStore"));	String noValCert = profile.getAttributeValue(new QName("novalidatecert"));	boolean novalidatecert = "true".equals(noValCert);	SSLContext sslContext = createSSLContext(ksElt, trElt, novalidatecert);	for (String server : servers) {	server = server.trim();	if (!contextMap.containsKey(server)) {	contextMap.put(server, sslContext);	} else {	
multiple ssl profiles were found for the server ignoring the excessive profiles 

SSLContext sslContext = createSSLContext(ksElt, trElt, novalidatecert);	for (String server : servers) {	server = server.trim();	if (!contextMap.containsKey(server)) {	contextMap.put(server, sslContext);	} else {	}	}	}	if (contextMap.size() > 0) {	
custom ssl profiles initialized for servers 

TrustManager[] trustManagers = null;	if (keyStoreElt != null) {	String location      = keyStoreElt.getFirstChildWithName(new QName("Location")).getText();	String type          = keyStoreElt.getFirstChildWithName(new QName("Type")).getText();	String storePassword = keyStoreElt.getFirstChildWithName(new QName("Password")).getText();	String keyPassword   = keyStoreElt.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading identity keystore from 

String keyPassword   = keyStoreElt.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	
error loading keystore 

try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Keystore : " + location, gse);	} catch (IOException ioe) {	
error opening keystore 

} finally {	if (fis != null) {	try {	fis.close();	} catch (IOException ignore) {}	}	}	}	if (trustStoreElt != null) {	if (novalidatecert) {	
ignoring novalidatecert parameter since a truststore has been specified 

if (trustStoreElt != null) {	if (novalidatecert) {	}	String location      = trustStoreElt.getFirstChildWithName(new QName("Location")).getText();	String type          = trustStoreElt.getFirstChildWithName(new QName("Type")).getText();	String storePassword = trustStoreElt.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading trust keystore from 

String storePassword = trustStoreElt.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

} catch (IOException ioe) {	throw new AxisFault("Error opening Key store : " + location, ioe);	} finally {	if (fis != null) {	try {	fis.close();	} catch (IOException ignore) {}	}	}	} else if (novalidatecert) {	
server certificate validation trust has been disabled do not use in production 

}	}	} else if (novalidatecert) {	trustManagers = new TrustManager[] { new NoValidateCertTrustManager() };	}	try {	SSLContext sslcontext = SSLContext.getInstance("TLS");	sslcontext.init(keymanagers, trustManagers, null);	return sslcontext;	} catch (GeneralSecurityException gse) {	
unable to create ssl context with the given configuration 

========================= synapse sample_1036 =========================

public void testLocalEntriesReusableEndPointsSequences() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test local registry entry definitions reusable endpoints and sequences 

========================= synapse sample_852 =========================

public void submitRequest(final HttpRequest request) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection 

========================= synapse sample_3764 =========================

public LoadBalancingConfigurator(InputStream instream) {	
loadbalancing configurator created 

private Map generateMap(InputStream instream) throws Exception {	
generating map for loadbalancing 

public Map getConfig(EndpointReference to) {	
giving loadbalancing map for 

========================= synapse sample_2876 =========================

}	URL url = SynapseConfigUtils.getURLFromPath(root + key, properties.get( SynapseConstants.SYNAPSE_HOME) != null ? properties.get(SynapseConstants.SYNAPSE_HOME).toString() : "");	if (url == null) {	return null;	}	BufferedInputStream inputStream;	try {	URLConnection connection = SynapseConfigUtils.getURLConnection(url);	if (connection == null) {	if (log.isDebugEnabled()) {	
cannot create a urlconnection for given url 

return null;	}	OMNode result = null;	if (inputStream != null) {	try {	XMLStreamReader parser = XMLInputFactory.newInstance(). createXMLStreamReader(inputStream);	OMXMLParserWrapper builder = OMXMLBuilderFactory.createStAXOMBuilder(parser);	result = builder.getDocumentElement();	} catch (OMException ignored) {	if (log.isDebugEnabled()) {	
the resource at the provided url isn t well formed xml so takes it as a text 

try {	XMLStreamReader parser = XMLInputFactory.newInstance(). createXMLStreamReader(inputStream);	OMXMLParserWrapper builder = OMXMLBuilderFactory.createStAXOMBuilder(parser);	result = builder.getDocumentElement();	} catch (OMException ignored) {	if (log.isDebugEnabled()) {	}	try {	inputStream.close();	} catch (IOException e) {	
error in closing the input stream 

} catch (OMException ignored) {	if (log.isDebugEnabled()) {	}	try {	inputStream.close();	} catch (IOException e) {	}	result = SynapseConfigUtils.readNonXML(url);	} catch (XMLStreamException ignored) {	if (log.isDebugEnabled()) {	
the resource at the provided url isn t well formed xml so takes it as a text 

inputStream.close();	} catch (IOException e) {	}	result = SynapseConfigUtils.readNonXML(url);	} catch (XMLStreamException ignored) {	if (log.isDebugEnabled()) {	}	try {	inputStream.close();	} catch (IOException e) {	
error in closing the input stream 

result = SynapseConfigUtils.readNonXML(url);	} finally {	try {	if (result != null && result.getParent() != null) {	result.detach();	OMDocument omDocument = omFactory.createOMDocument();	omDocument.addChild(result);	}	inputStream.close();	} catch (IOException e) {	
error in closing the input stream 

public RegistryEntry getRegistryEntry(String key) {	if (log.isDebugEnabled()) {	
perform registryentry lookup for key 

public RegistryEntry getRegistryEntry(String key) {	if (log.isDebugEnabled()) {	}	URL url = SynapseConfigUtils.getURLFromPath(root + key, properties.get( SynapseConstants.SYNAPSE_HOME) != null ? properties.get(SynapseConstants.SYNAPSE_HOME).toString() : "");	if (url == null) {	return null;	}	URLConnection connection = SynapseConfigUtils.getURLConnection(url);	if (connection == null) {	if (log.isDebugEnabled()) {	
cannot create a urlconnection for given url 

========================= synapse sample_2030 =========================

public synchronized void start() throws AMQPTransportException {	try {	if (exchangeName != null) {	channel.exchangeDeclare( exchangeName, exchangeType, isExchangeDurable, isExchangeAutoDelete, isInternalExchange, null);	String newQueueName = channel.queueDeclare().getQueue();	
queuename is set to for service 

QueueingConsumer consumer = new QueueingConsumer(channel);	boolean isAutoAck = isUseTx == true ? false : true;	channel.basicConsume(queueName, isAutoAck, consumer);	ScheduledFuture<?> pollingTaskFuture = pollingTaskScheduler.scheduleWithFixedDelay( new MessageIOTask(consumer, buffers, isUseTx), scheduledTaskInitialDelay, scheduledTaskDelay, scheduledTaskTimeUnit);	taskFutureList.add(pollingTaskFuture);	} catch (IOException e) {	handleException(e.getMessage(), e);	}	}	if (log.isDebugEnabled()) {	
a polling task started listening on the queue on behalf of the service 

if (isUseTx) {	channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);	channel.txCommit();	}	} else {	if (isUseTx) {	channel.txRollback();	}	}	} catch (InterruptedException e) {	
polling task was interrupted for service 

channel.txCommit();	}	} else {	if (isUseTx) {	channel.txRollback();	}	}	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	} catch (IOException e) {	
i o error occurs for the polling tasks for service 

} else {	if (isUseTx) {	channel.txRollback();	}	}	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	} catch (IOException e) {	} catch (ShutdownSignalException e) {	if (e.isHardError()) {	
polling task for service received a shutdown signal 

Thread.currentThread().interrupt();	} catch (IOException e) {	} catch (ShutdownSignalException e) {	if (e.isHardError()) {	Semaphore available = new Semaphore(0, true);	String key = UUID.randomUUID().toString();	haHandler.getBlockedTasks().add(new AMQPTransportHAEntry( available, key, connectionFactoryName));	try {	available.acquire();	} catch (InterruptedException ie) {	
the blocking semaphore was interrupted 

String key = UUID.randomUUID().toString();	haHandler.getBlockedTasks().add(new AMQPTransportHAEntry( available, key, connectionFactoryName));	try {	available.acquire();	} catch (InterruptedException ie) {	Thread.currentThread().interrupt();	return;	}	AMQPTransportHABrokerEntry brokerEntry = haHandler.getConnectionMap().get(key);	if (brokerEntry == null) {	
no new connection factory was found for key 

Thread.currentThread().interrupt();	return;	}	AMQPTransportHABrokerEntry brokerEntry = haHandler.getConnectionMap().get(key);	if (brokerEntry == null) {	} else {	setChannel(brokerEntry.getChannel());	stop();	try {	start();	
worker task for service is re deployed 

return;	}	AMQPTransportHABrokerEntry brokerEntry = haHandler.getConnectionMap().get(key);	if (brokerEntry == null) {	} else {	setChannel(brokerEntry.getChannel());	stop();	try {	start();	} catch (AMQPTransportException ex) {	
start of polling tasks failed system must be restarted 

setChannel(brokerEntry.getChannel());	stop();	try {	start();	} catch (AMQPTransportException ex) {	}	}	} else {	}	} catch (ConsumerCancelledException e) {	
polling task for service received a cancellation signal 

public void run() {	try {	handleIncomingMessage(message, buffers);	} catch (AxisFault axisFault) {	try {	handleFaultMessage(message, buffers, axisFault);	} catch (Exception e) {	
error while sending the fault message to the client client will not receive any errors 

========================= synapse sample_2460 =========================

public void register(DataSourceInformation dataSourceInformation) {	if (dataSourceInformation == null) {	throw new SynapseCommonsException("DataSourceInformation cannot be found.", log);	}	DataSource dataSource = DataSourceFactory.createDataSource(dataSourceInformation);	if (dataSource == null) {	if (log.isDebugEnabled()) {	
datasource cannot be created or found for datasource information 

throw new SynapseCommonsException("DataSourceInformation cannot be found.", log);	}	DataSource dataSource = DataSourceFactory.createDataSource(dataSourceInformation);	if (dataSource == null) {	if (log.isDebugEnabled()) {	}	return;	}	String name = dataSourceInformation.getDatasourceName();	if (log.isDebugEnabled()) {	
registering a datsource with name in local pool 

public void clear() {	if (!dataSources.isEmpty()) {	
clearing all in memory datasources 

========================= synapse sample_2122 =========================

private void registerExtensions() {	if (log.isDebugEnabled()) {	
registering mediator extensions found in the classpath 

MediatorSerializer serializer = serializers.next();	String name = serializer.getMediatorClassName();	try {	serializerMap.put(name, serializer.getClass().newInstance());	} catch (InstantiationException e) {	handleException("Error instantiating mediator serializer : " + serializer);	} catch (IllegalAccessException e) {	handleException("Error instantiating mediator serializer : " + serializer);	}	if (log.isDebugEnabled()) {	
added mediatorserializer to handle 

========================= synapse sample_393 =========================

String optionType = option.getOptionType();	return !("repo".equalsIgnoreCase(optionType) || "conf" .equalsIgnoreCase(optionType));	}	});	if ((invalidOptionsList.size() > 0) || (args.length > 4)) {	printUsage();	}	Map optionsMap = optionsParser.getAllOptions();	CommandLineOption repoOption = (CommandLineOption) optionsMap .get("repo");	CommandLineOption confOption = (CommandLineOption) optionsMap .get("conf");	
simpleaxisserver starting 

if (confOption != null) {	confLocation = confOption.getOptionValue();	System.out .println("[SimpleAxisServer] Using the Axis2 Configuration File : " + new File(confLocation).getAbsolutePath());	}	try {	configctx = ConfigurationContextFactory .createConfigurationContextFromFileSystem(repoLocation, confLocation);	configurePort(configctx);	listenerManager = new ListenerManager();	listenerManager.init(configctx);	listenerManager.start();	
simpleaxisserver started 

confLocation = confOption.getOptionValue();	System.out .println("[SimpleAxisServer] Using the Axis2 Configuration File : " + new File(confLocation).getAbsolutePath());	}	try {	configctx = ConfigurationContextFactory .createConfigurationContextFromFileSystem(repoLocation, confLocation);	configurePort(configctx);	listenerManager = new ListenerManager();	listenerManager.init(configctx);	listenerManager.start();	} catch (Throwable t) {	
simpleaxisserver shutting down error starting simpleaxisserver 

private void configurePort(ConfigurationContext configCtx) {	TransportInDescription trsIn = (TransportInDescription) configCtx.getAxisConfiguration().getTransportsIn().get("http");	if (trsIn != null) {	String port = System.getProperty("http_port");	if (port != null) {	try {	new Integer(port);	trsIn.getParameter("port").setValue(port);	} catch (NumberFormatException e) {	
given port is not a valid integer using for port 

}	}	TransportInDescription httpsTrsIn = (TransportInDescription) configCtx.getAxisConfiguration().getTransportsIn().get("https");	if (httpsTrsIn != null) {	String port = System.getProperty("https_port");	if (port != null) {	try {	new Integer(port);	httpsTrsIn.getParameter("port").setValue(port);	} catch (NumberFormatException e) {	
given port is not a valid integer using for port 

========================= synapse sample_4449 =========================

if (traceOn && trace.isTraceEnabled()) {	trace.trace("Message : " + synCtx.getEnvelope());	}	}	String logMessage = getLogMessage(synCtx);	synCtx.getServiceLog().info(logMessage);	if (log.isInfoEnabled()) {	log.info(logMessage);	}	if (traceOn) {	
log message 

========================= synapse sample_3676 =========================

public void shutDownConnection(NHttpServerConnection conn, boolean isError) {	if (log.isDebugEnabled()) {	
shutting down connection forcefully 

public void closeConnection(NHttpServerConnection conn) {	if (log.isDebugEnabled()) {	
closing connection forcefully 

========================= synapse sample_956 =========================

public void handle(SecretCallback[] secretCallbacks) {	if (secretCallbacks == null || secretCallbacks.length == 0) {	if (log.isDebugEnabled()) {	
provided secretcallbacks are empty or null 

========================= synapse sample_1132 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start fault mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

synCtx.setTo(synCtx.getFaultTo());	} else if (synCtx.getReplyTo() != null) {	synCtx.setTo(synCtx.getReplyTo());	} else {	synCtx.setTo(null);	}	if(synCtx.getMessageID() != null) {	RelatesTo relatesTo = new RelatesTo(synCtx.getMessageID());	synCtx.setRelatesTo(new RelatesTo[] { relatesTo });	}	
end fault mediator 

========================= synapse sample_540 =========================

public void run() {	while (true) {	if (completed) {	break;	}	if (getLock()) {	if (log.isDebugEnabled()) {	
time and this aggregator expired at 

========================= synapse sample_1974 =========================

public boolean process(SynapseEnvironment se, SynapseMessage smc) {	
process 

public boolean process(SynapseEnvironment se, SynapseMessage smc) {	if (processors == null) {	
process called on empty processor list 

public void setList(List p) {	
setting list 

========================= synapse sample_4625 =========================

public void testSpringBeanAsAMediator() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test spring bean as a mediator 

========================= synapse sample_813 =========================

if (o != null && o instanceof Entry) {	Entry entry = (Entry) o;	if (!entry.isDynamic() || (entry.isCached() && !entry.isExpired())) {	return entry.getValue();	}	if (registry != null) {	if (entry.isCached()) {	try {	o = registry.getResource(entry, getProperties());	} catch (Exception e) {	
error while loading the resource from the remote registry previously cached value will be used check the registry accessibility 

try {	o = registry.getResource(entry, getProperties());	} catch (Exception e) {	return entry.getValue();	}	} else {	o = registry.getResource(entry, getProperties());	}	} else {	if (entry.isCached()) {	
the registry is no longer available in the synapse configuration using the previously cached value for the resource 

return entry.getValue();	}	} else {	o = registry.getResource(entry, getProperties());	}	} else {	if (entry.isCached()) {	return entry.getValue();	} else {	if (log.isDebugEnabled()) {	
will not evaluate the value of the remote entry with a key because the registry is not available 

Entry entry = new Entry(key);	entry.setType(Entry.REMOTE_ENTRY);	addEntry(key, entry);	return entry;	}	}	}	return (Entry) o;	} else {	if (log.isDebugEnabled()) {	
there is no local registry entry for key 

public synchronized void init(SynapseEnvironment se) {	if (initialized) {	
attempted to re initialize synapseconfiguration 

public synchronized void init(SynapseEnvironment se) {	if (initialized) {	return;	}	if (log.isDebugEnabled()) {	
initializing the synapse configuration using the synapseenvironment 

public synchronized void destroy() {	if (!initialized) {	
attempted to destroy uninitialized synapseconfiguration 

public synchronized void destroy() {	if (!initialized) {	return;	}	if (log.isDebugEnabled()) {	
destroying the synapse configuration 

========================= synapse sample_307 =========================

public static String getProperty(Properties properties, String name, String defaultValue) {	String result = properties.getProperty(name);	if ((result == null || result.length() == 0) && defaultValue != null) {	if (log.isDebugEnabled()) {	
the name with cannot be found using default value 

public static <T extends Object> T getProperty( Properties properties, String name, T defaultValue, Class<? extends T> type) {	String result = properties.getProperty(name);	if (result == null && defaultValue != null) {	if (log.isDebugEnabled()) {	
the name with cannot be found using default value 

public static Properties loadProperties(String filePath) {	Properties properties = new Properties();	ClassLoader cl = Thread.currentThread().getContextClassLoader();	if (log.isDebugEnabled()) {	
loading a file from classpath 

public static Properties loadProperties(String filePath) {	Properties properties = new Properties();	ClassLoader cl = Thread.currentThread().getContextClassLoader();	if (log.isDebugEnabled()) {	}	InputStream in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	
unable to load file 

Properties properties = new Properties();	ClassLoader cl = Thread.currentThread().getContextClassLoader();	if (log.isDebugEnabled()) {	}	InputStream in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	}	filePath = "conf" + File.separatorChar + filePath;	if (log.isDebugEnabled()) {	
loading a file from classpath 

InputStream in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	}	filePath = "conf" + File.separatorChar + filePath;	if (log.isDebugEnabled()) {	}	in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	
unable to load file 

========================= synapse sample_2509 =========================

entry.setVersion(re.getVersion());	}	}	if (omNode == null) {	return null;	} else {	re = getRegistryEntry(entry.getKey());	}	} else if (entry.isExpired()) {	if (log.isDebugEnabled()) {	
cached object has expired for key 

return null;	} else {	re = getRegistryEntry(entry.getKey());	}	} else if (entry.isExpired()) {	if (log.isDebugEnabled()) {	}	re = getRegistryEntry(entry.getKey());	if (re.getVersion() != Long.MIN_VALUE && re.getVersion() == entry.getVersion()) {	if (log.isDebugEnabled()) {	
expired version number is same as current version in registry 

re = getRegistryEntry(entry.getKey());	if (re.getVersion() != Long.MIN_VALUE && re.getVersion() == entry.getVersion()) {	if (log.isDebugEnabled()) {	}	if (re.getCachableDuration() > 0) {	entry.setExpiryTime( System.currentTimeMillis() + re.getCachableDuration());	} else {	entry.setExpiryTime(-1);	}	if (log.isDebugEnabled()) {	
renew cache lease for another s 

========================= synapse sample_612 =========================

public void testFullRegistryBasedConfig() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test local registry entry definitions reusable endpoints and sequences 

========================= synapse sample_2270 =========================

public void testSessionFullLBFailOver() {	final String addUrl = "http: final StockQuoteSampleClient client = getStockQuoteClient();	
running test failover sending among endpoints 

========================= synapse sample_868 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
api deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	API api = APIFactory.createAPI(artifactConfig);	if (api != null) {	api.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
api named has been built from the file 

if (log.isDebugEnabled()) {	}	try {	API api = APIFactory.createAPI(artifactConfig);	if (api != null) {	api.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	api.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	
initialized the api 

API api = APIFactory.createAPI(artifactConfig);	if (api != null) {	api.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	api.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addAPI(api.getName(), api);	if (log.isDebugEnabled()) {	
api deployment from file completed 

if (api != null) {	api.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	api.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addAPI(api.getName(), api);	if (log.isDebugEnabled()) {	}	
api named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
api update from file has started 

if (log.isDebugEnabled()) {	}	try {	API api = APIFactory.createAPI(artifactConfig);	if (api == null) {	handleSynapseArtifactDeploymentError("API update failed. The artifact " + "defined in the file: " + fileName + " is not a valid API.");	return null;	}	api.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	
api has been built from the file 

api.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	api.init(getSynapseEnvironment());	API existingAPI = getSynapseConfiguration().getAPI(existingArtifactName);	if (existingArtifactName.equals(api.getName())) {	getSynapseConfiguration().updateAPI(existingArtifactName, api);	} else {	getSynapseConfiguration().addAPI(api.getName(), api);	getSynapseConfiguration().removeAPI(existingArtifactName);	
api has been undeployed 

if (log.isDebugEnabled()) {	}	api.init(getSynapseEnvironment());	API existingAPI = getSynapseConfiguration().getAPI(existingArtifactName);	if (existingArtifactName.equals(api.getName())) {	getSynapseConfiguration().updateAPI(existingArtifactName, api);	} else {	getSynapseConfiguration().addAPI(api.getName(), api);	getSynapseConfiguration().removeAPI(existingArtifactName);	}	
api has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
undeployment of the api named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	API api = getSynapseConfiguration().getAPI(artifactName);	if (api != null) {	getSynapseConfiguration().removeAPI(artifactName);	if (log.isDebugEnabled()) {	
undeployment of the api named completed 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	API api = getSynapseConfiguration().getAPI(artifactName);	if (api != null) {	getSynapseConfiguration().removeAPI(artifactName);	if (log.isDebugEnabled()) {	}	
api named has been undeployed 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	API api = getSynapseConfiguration().getAPI(artifactName);	if (api != null) {	getSynapseConfiguration().removeAPI(artifactName);	if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
api has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the api with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	API api = getSynapseConfiguration().getAPI(artifactName);	OMElement apiElement = APISerializer.serializeAPI(api);	if (api.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.REST_API_DIR + File.separator + api.getFileName();	writeToFile(apiElement, fileName);	if (log.isDebugEnabled()) {	
restoring the api with name completed 

if (log.isDebugEnabled()) {	}	try {	API api = getSynapseConfiguration().getAPI(artifactName);	OMElement apiElement = APISerializer.serializeAPI(api);	if (api.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.REST_API_DIR + File.separator + api.getFileName();	writeToFile(apiElement, fileName);	if (log.isDebugEnabled()) {	}	
api named has been restored 

========================= synapse sample_184 =========================

private boolean assertListerNotNull() {	if (listener == null) {	if (log.isDebugEnabled()) {	
cannot find a datasourceinformationrepositorylistener 

private boolean assertListerNotNull() {	if (listener == null) {	if (log.isDebugEnabled()) {	}	return false;	}	if (log.isDebugEnabled()) {	
using datasourceinformationrepositorylistener as 

========================= synapse sample_700 =========================

public void onClosed(ErrorCode errorCode, String reason) {	
amqp connection encountered an error error code reason 

public void onClosed(ErrorCode errorCode, String reason) {	boolean wasError = true;	while (wasError == true) {	try {	wasError = false;	} catch (Exception e1) {	
amqp reconnection attempt failed for connection 

public void onClosed(ErrorCode errorCode, String reason) {	boolean wasError = true;	while (wasError == true) {	try {	wasError = false;	} catch (Exception e1) {	}	if (wasError == true) {	try {	
attempting reconnection for connection in seconds 

========================= synapse sample_4259 =========================

lookup.put(((ProcessorConfigurator) c.newInstance()) .getTagQName(), c);	} catch (Exception e) {	throw new SynapseException(e);	}	}	Iterator it = Service.providers(ProcessorConfigurator.class);	while (it.hasNext()) {	ProcessorConfigurator p = (ProcessorConfigurator) it.next();	QName tag = p.getTagQName();	lookup.put(tag, p.getClass());	
added processor to handle 

========================= synapse sample_4609 =========================

public void testExternalXQuery() {	String addUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test how to use the data from an external xml document with in xquery 

========================= synapse sample_2227 =========================

public void stop() {	if (state == State.START) {	try {	if (scheduler != null && scheduler.isStarted()) {	if (log.isDebugEnabled()) {	
shuttingdown message processor scheduler 

public void init(SynapseEnvironment se) {	super.init(se);	StdSchedulerFactory sf = new StdSchedulerFactory();	try {	if (quartzConfig != null && !"".equals(quartzConfig)) {	if (log.isDebugEnabled()) {	
initiating a scheduler with configuration 

public void destroy() {	try {	scheduler.deleteJob( new JobKey(name + "-trigger",SCHEDULED_MESSAGE_PROCESSOR_GROUP));	scheduler.shutdown(true);	} catch (SchedulerException e) {	
error while destroying the task 

========================= synapse sample_583 =========================

if (traceOn && trace.isTraceEnabled()) {	trace.trace("Message : " + synCtx.getEnvelope());	}	}	String logMessage = getLogMessage(synCtx);	synCtx.getServiceLog().info(logMessage);	if (log.isInfoEnabled()) {	log.info(logMessage);	}	if (traceOn) {	
log message 

========================= synapse sample_4189 =========================

if (!initialized) {	super.init(synapseEnvironment);	if (algorithmContext == null) {	algorithmContext = new AlgorithmContext(isClusteringEnabled, cc, getName());	}	SALSessions salSessions = SALSessions.getInstance();	if (!salSessions.isInitialized()) {	salSessions.initialize(isClusteringEnabled, cc);	}	}	
dynamic load balance endpoint initialized 

if (lbMembershipHandler.getConfigurationContext() == null) {	lbMembershipHandler.setConfigurationContext(configCtx);	}	if (isSessionAffinityBasedLB()) {	sessionInformation = (SessionInformation) synCtx.getProperty( SynapseConstants.PROP_SAL_CURRENT_SESSION_INFORMATION);	currentMember = (Member) synCtx.getProperty( SynapseConstants.PROP_SAL_ENDPOINT_CURRENT_MEMBER);	if (sessionInformation == null && currentMember == null) {	sessionInformation = dispatcher.getSession(synCtx);	if (sessionInformation != null) {	if (log.isDebugEnabled()) {	
current session id 

protected String extractSessionID(MessageContext synCtx, String key) {	if (key != null) {	Map headerMap = getTransportHeaderMap(synCtx);	if (headerMap != null) {	Object cookieObj = headerMap.get(key);	if (cookieObj instanceof String) {	return (String) cookieObj;	} else {	if (log.isDebugEnabled()) {	
couldn t find the header to find the session 

if (headerMap != null) {	Object cookieObj = headerMap.get(key);	if (cookieObj instanceof String) {	return (String) cookieObj;	} else {	if (log.isDebugEnabled()) {	}	}	} else {	if (log.isDebugEnabled()) {	
couldn t find the transport headers to find the session 

}	Map<String, String> memberHosts;	if ((memberHosts = (Map<String, String>) currentMember.getProperties().get(HttpSessionDispatcher.HOSTS)) == null) {	currentMember.getProperties().put(HttpSessionDispatcher.HOSTS, memberHosts = new HashMap<String, String>());	}	memberHosts.put(extractHost(synCtx), "true");	try {	endpoint.send(synCtx);	} catch (Exception e) {	if(e.getMessage().toLowerCase().contains("io reactor shutdown")){	
system cannot continue normal operation restarting 

========================= synapse sample_1671 =========================

private static String getArgument(CommandLine cmd, String argName, String defaultValue) {	if (cmd == null) {	handleException("CommandLine is null");	}	if (argName == null || "".equals(argName)) {	if (log.isDebugEnabled()) {	
provided argument name is null returning null as value 

private static boolean isArgumentPresent(CommandLine cmd, String argName) {	if (cmd == null) {	handleException("CommandLine is null");	}	if (argName == null || "".equals(argName)) {	if (log.isDebugEnabled()) {	
provided argument name is null returning null as value 

========================= synapse sample_2548 =========================

public boolean mediate(MessageContext synCtx) {	try {	
script mediator mediate 

ScriptMessageContext scriptMC = new ScriptMessageContext(synCtx, convertor);	ThreadLocalMessageContext.setMC(scriptMC);	Vector paramValues = new Vector();	paramValues.add(scriptMC);	Object response = bsfEngine.apply(scriptName, 0, 0, scriptSrc, PARAM_NAMES, paramValues);	if (response instanceof Boolean) {	return ((Boolean) response).booleanValue();	}	return true;	} catch (BSFException e) {	
error executing inline script 

========================= synapse sample_3359 =========================

String name = null;	if (faultMediator instanceof SequenceMediator) {	name = ((SequenceMediator) faultMediator).getName();	}	if (name == null) {	name = faultMediator.getClass().getName();	}	if (traceOrDebugOn) {	traceOrDebugWarn(traceOn, "Executing fault handler mediator : " + name);	}	
executing fault sequence mediator 

========================= synapse sample_4166 =========================

public void testCallOut() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test simple callout mediator for synchronizing web service invocation 

========================= synapse sample_2231 =========================

public boolean mediate(MessageContext synCtx) {	
fault mediator mediate 

OMDocument soapFaultDocument = factory.createOMDocument();	SOAPEnvelope faultEnvelope = factory.getDefaultFaultEnvelope();	soapFaultDocument.addChild(faultEnvelope);	SOAPFault fault = factory.createSOAPFault();	setFaultCode(synCtx, factory, fault);	setFaultResaon(synCtx, factory, fault);	setFaultNode(factory, fault);	setFaultRole(factory, fault);	setFaultDetail(factory, fault);	faultEnvelope.getBody().setFirstChild(fault);	
setting the fault message as 

SOAPFault fault = factory.createSOAPFault();	setFaultCode(synCtx, factory, fault);	setFaultResaon(synCtx, factory, fault);	setFaultNode(factory, fault);	setFaultRole(factory, fault);	setFaultDetail(factory, fault);	faultEnvelope.getBody().setFirstChild(fault);	EndpointReference toEPR = synCtx.getTo();	EndpointReference faultToEPR = synCtx.getFaultTo();	if (faultToEPR != null) {	
setting fault message to 

SOAPFault fault = factory.createSOAPFault();	setFaultCode(synCtx, factory, fault);	setFaultResaon(synCtx, factory, fault);	setFaultNode(factory, fault);	setFaultRole(factory, fault);	setFaultDetail(factory, fault);	faultEnvelope.getBody().setFirstChild(fault);	EndpointReference toEPR = synCtx.getTo();	EndpointReference faultToEPR = synCtx.getFaultTo();	if (faultToEPR != null) {	
setting fault message replyto 

setFaultRole(factory, fault);	setFaultDetail(factory, fault);	faultEnvelope.getBody().setFirstChild(fault);	EndpointReference toEPR = synCtx.getTo();	EndpointReference faultToEPR = synCtx.getFaultTo();	if (faultToEPR != null) {	synCtx.setTo(faultToEPR);	synCtx.setReplyTo(toEPR);	} else {	EndpointReference replyToEPR = synCtx.getReplyTo();	
setting fault message to 

setFaultRole(factory, fault);	setFaultDetail(factory, fault);	faultEnvelope.getBody().setFirstChild(fault);	EndpointReference toEPR = synCtx.getTo();	EndpointReference faultToEPR = synCtx.getFaultTo();	if (faultToEPR != null) {	synCtx.setTo(faultToEPR);	synCtx.setReplyTo(toEPR);	} else {	EndpointReference replyToEPR = synCtx.getReplyTo();	
setting fault message replyto 

========================= synapse sample_3070 =========================

public void testScheduledTask() throws Exception {	
waiting seconds for the task to run 

public void testScheduledTask() throws Exception {	Thread.sleep(10000);	int messageCount = getAxis2Server().getMessageCount("SimpleStockQuoteService", "getQuote");	
task sent messages 

========================= synapse sample_829 =========================

public static byte[] encode(ByteArrayOutputStream baos, EncodingType encodingType) {	switch (encodingType) {	case BASE64: if (log.isDebugEnabled()) {	
encoding on output 

public static byte[] encode(ByteArrayOutputStream baos, EncodingType encodingType) {	switch (encodingType) {	case BASE64: if (log.isDebugEnabled()) {	}	return Base64.encodeBase64(baos.toByteArray());	case BIGINTEGER16: if (log.isDebugEnabled()) {	
biginteger encoding on output 

public static InputStream decode(InputStream inputStream, EncodingType encodingType) throws IOException {	InputStream decodedInputStream = null;	switch (encodingType) {	case BASE64: if (log.isDebugEnabled()) {	
decoding on input 

public static InputStream decode(InputStream inputStream, EncodingType encodingType) throws IOException {	InputStream decodedInputStream = null;	switch (encodingType) {	case BASE64: if (log.isDebugEnabled()) {	}	decodedInputStream = new ByteArrayInputStream( Base64.decodeBase64(MiscellaneousUtil.asBytes(inputStream)));	break;	case BIGINTEGER16: if (log.isDebugEnabled()) {	
biginteger encoding on output 

========================= synapse sample_1108 =========================

public boolean mediate(MessageContext synCtx) {	try {	
script mediator mediate 

ScriptMessageContext scriptMC = new ScriptMessageContext(synCtx, convertor);	ThreadLocalMessageContext.setMC(scriptMC);	Vector paramValues = new Vector();	paramValues.add(scriptMC);	Object response = bsfEngine.apply(scriptName, 0, 0, scriptSrc, PARAM_NAMES, paramValues);	if (response instanceof Boolean) {	return ((Boolean) response).booleanValue();	}	return true;	} catch (BSFException e) {	
error executing inline script 

========================= synapse sample_3135 =========================

public boolean mediate(SynapseMessage synapseMessageContext) {	try {	long start = System.currentTimeMillis();	ManagementInformationExchange mix = new ManagementInformationExchange();	MediatorExecInfoObject meio = new MediatorExecInfoObject();	meio.setMediatorName("DEPRECATION");	
deprecation mediation 

private void loadConfig(SynapseMessage synapseMessageContext) {	boolean flag = false;	InputStream deprecationInStream;	String resource;	AxisConfiguration ac = ((Axis2SynapseMessage) synapseMessageContext).getMessageContext().getConfigurationContext().getAxisConfiguration();	Parameter param = ac.getParameter("PolicyRepo");	if (param != null) {	resource = param.getValue().toString().trim() + File.separator + "policy"+File.separator+"mediators" + File.separator + DeprecationConstants.CFG_DEPRECATION_XML;	resource = resource.replace('\\','/');	
resource from repo 

InputStream deprecationInStream;	String resource;	AxisConfiguration ac = ((Axis2SynapseMessage) synapseMessageContext).getMessageContext().getConfigurationContext().getAxisConfiguration();	Parameter param = ac.getParameter("PolicyRepo");	if (param != null) {	resource = param.getValue().toString().trim() + File.separator + "policy"+File.separator+"mediators" + File.separator + DeprecationConstants.CFG_DEPRECATION_XML;	resource = resource.replace('\\','/');	File file = new File(resource);	try{	flag = (file.lastModified() != modifiedTime);	
flag 

if (param != null) {	resource = param.getValue().toString().trim() + File.separator + "policy"+File.separator+"mediators" + File.separator + DeprecationConstants.CFG_DEPRECATION_XML;	resource = resource.replace('\\','/');	File file = new File(resource);	try{	flag = (file.lastModified() != modifiedTime);	modifiedTime = file.lastModified();	}  catch(Exception e){	e.printStackTrace();	}	
getting the stream 

try{	flag = (file.lastModified() != modifiedTime);	modifiedTime = file.lastModified();	}  catch(Exception e){	e.printStackTrace();	}	try {	deprecationInStream = new FileInputStream(file);	}	catch(Exception e) {	
error here 

flag = (file.lastModified() != modifiedTime);	modifiedTime = file.lastModified();	}  catch(Exception e){	e.printStackTrace();	}	try {	deprecationInStream = new FileInputStream(file);	}	catch(Exception e) {	resource = DeprecationConstants.CFG_XML_FOLDER + "/" + DeprecationConstants.CFG_DEPRECATION_XML;	
resource from aar 

}	try {	deprecationInStream = new FileInputStream(file);	}	catch(Exception e) {	resource = DeprecationConstants.CFG_XML_FOLDER + "/" + DeprecationConstants.CFG_DEPRECATION_XML;	deprecationInStream = this.classLoader.getResourceAsStream(resource);	}	} else {	resource = DeprecationConstants.CFG_XML_FOLDER + "/" + DeprecationConstants.CFG_DEPRECATION_XML;	
resource from aar 

deprecationInStream = new FileInputStream(file);	}	catch(Exception e) {	resource = DeprecationConstants.CFG_XML_FOLDER + "/" + DeprecationConstants.CFG_DEPRECATION_XML;	deprecationInStream = this.classLoader.getResourceAsStream(resource);	}	} else {	resource = DeprecationConstants.CFG_XML_FOLDER + "/" + DeprecationConstants.CFG_DEPRECATION_XML;	deprecationInStream = this.classLoader.getResourceAsStream(resource);	}	
deprecation in stream 

deprecationInStream = this.classLoader.getResourceAsStream(resource);	}	if ((!flag)&&(synapseEnvironment.getProperty("deprecation_synapseObject") != null)) {	deprecation = (SynapseObject) synapseEnvironment.getProperty("deprecation_synapseObject");	} else {	if(deprecationInStream!=null){	deprecation = Utils.xmlToSynapseObject(deprecationInStream);	synapseEnvironment.setProperty("deprecation_synapseObject", deprecation);	}	else {	
null stream 

========================= synapse sample_2909 =========================

public boolean offer(MessageContext messageContext) {	lock.lock();	try {	if (messageContext != null) {	messageContext.getEnvelope().build();	messageList.offer(messageContext);	notifyMessageAddition(messageContext.getMessageID());	if (log.isDebugEnabled()) {	
message with id stored 

========================= synapse sample_604 =========================

public static Object getObject(URL url, Properties properties) {	try {	if (url != null && "file".equals(url.getProtocol())) {	try {	url.openStream();	} catch (IOException ignored) {	String path = url.getPath();	if (log.isDebugEnabled()) {	
can not open a connection to the url with a path 

if (url != null && "file".equals(url.getProtocol())) {	try {	url.openStream();	} catch (IOException ignored) {	String path = url.getPath();	if (log.isDebugEnabled()) {	}	String synapseHome = (String) properties.get(SynapseConstants.SYNAPSE_HOME);	if (synapseHome != null) {	if (log.isDebugEnabled()) {	
trying to resolve an absolute path of the url using the synapse home 

if (log.isDebugEnabled()) {	}	if (synapseHome.endsWith("/")) {	synapseHome = synapseHome.substring(0, synapseHome.lastIndexOf("/"));	}	url = new URL(url.getProtocol() + ":" + synapseHome + "/" + path);	try {	url.openStream();	} catch (IOException e) {	if (log.isDebugEnabled()) {	
failed to resolve an absolute path of the url using the synapse home 

}	if (synapseHome.endsWith("/")) {	synapseHome = synapseHome.substring(0, synapseHome.lastIndexOf("/"));	}	url = new URL(url.getProtocol() + ":" + synapseHome + "/" + path);	try {	url.openStream();	} catch (IOException e) {	if (log.isDebugEnabled()) {	}	
io error reading from url 

String encoding = new String(new Base64().encode(url.getUserInfo().getBytes()));	connection.setRequestProperty("Authorization", "Basic " + encoding);	} else {	handleException("Unsupported protocol [" + protocol + "]. Supports only http " + "and https with basic authentication.");	}	} else {	connection = getURLConnection(url);	}	if (connection == null) {	if (log.isDebugEnabled()) {	
cannot create a urlconnection for given url 

OMXMLParserWrapper builder = OMXMLBuilderFactory.createStAXOMBuilder(parser);	OMElement omElem = builder.getDocumentElement();	omElem.build();	if (xmlToObject != null) {	return xmlToObject.getObjectFromOMNode(omElem, properties);	} else {	return omElem;	}	} catch (XMLStreamException e) {	if (log.isDebugEnabled()) {	
content at url is non xml 

return xmlToObject.getObjectFromOMNode(omElem, properties);	} else {	return omElem;	}	} catch (XMLStreamException e) {	if (log.isDebugEnabled()) {	}	return readNonXML(url);	} catch (OMException e) {	if (log.isDebugEnabled()) {	
content at url is non xml 

public static OMNode readNonXML(URL url) {	try {	URLConnection newConnection = getURLConnection(url);	if (newConnection == null) {	if (log.isDebugEnabled()) {	
cannot create a urlconnection for given url 

public static OMNode getOMElementFromURL(String urlStr, String synapseHome) throws IOException {	URL url = getURLFromPath(urlStr, synapseHome);	if (url == null) {	return null;	}	URLConnection connection = getURLConnection(url);	if (connection == null) {	if (log.isDebugEnabled()) {	
cannot create a urlconnection for given url 

return null;	}	InputStream inStream = connection.getInputStream();	try {	OMXMLParserWrapper builder = OMXMLBuilderFactory.createOMBuilder(inStream);	OMElement doc = builder.getDocumentElement();	doc.build();	return doc;	} catch (Exception e) {	if (log.isDebugEnabled()) {	
content at url is non xml 

doc.build();	return doc;	} catch (Exception e) {	if (log.isDebugEnabled()) {	}	return readNonXML(url);	} finally {	try {	inStream.close();	} catch (IOException e) {	
error while closing the input stream to 

public static InputSource getInputSourceFormURI(URI uri) {	if (uri == null) {	if (log.isDebugEnabled()) {	
can not create a url from null 

try {	URL url = uri.toURL();	String protocol = url.getProtocol();	String path = url.getPath();	if (protocol == null || "".equals(protocol)) {	url = new URL("file:" + path);	}	URLConnection connection = getURLConnection(url);	if (connection == null) {	if (log.isDebugEnabled()) {	
cannot create a urlconnection for given url 

private static HttpsURLConnection getHttpsURLConnection( URL url, Properties synapseProperties, Proxy proxy) {	if (log.isDebugEnabled()) {	
creating a httpsurl connection from given url 

KeyManager[] keyManagers = null;	TrustManager[] trustManagers = null;	IdentityKeyStoreInformation identityInformation = KeyStoreInformationFactory.createIdentityKeyStoreInformation(synapseProperties);	if (identityInformation != null) {	KeyManagerFactory keyManagerFactory = identityInformation.getIdentityKeyManagerFactoryInstance();	if (keyManagerFactory != null) {	keyManagers = keyManagerFactory.getKeyManagers();	}	} else {	if (log.isDebugEnabled()) {	
there is no private key entry store configuration will use jdk s default one 

}	}	TrustKeyStoreInformation trustInformation = KeyStoreInformationFactory.createTrustKeyStoreInformation(synapseProperties);	if (trustInformation != null) {	TrustManagerFactory trustManagerFactory = trustInformation.getTrustManagerFactoryInstance();	if (trustManagerFactory != null) {	trustManagers = trustManagerFactory.getTrustManagers();	}	} else {	if (log.isDebugEnabled()) {	
there is no trusted certificate store configuration will use jdk s default one 

sslContext.init(keyManagers, trustManagers, null);	connection.setSSLSocketFactory(sslContext.getSocketFactory());	if (trustInformation != null) {	boolean enableHostnameVerifier = true;	String value = trustInformation.getParameter( KeyStoreInformation.ENABLE_HOST_NAME_VERIFIER);	if (value != null) {	enableHostnameVerifier = Boolean.parseBoolean(value);	}	if (!enableHostnameVerifier) {	if (log.isDebugEnabled()) {	
overriding default hostname verifier hostname verification disabled 

String value = trustInformation.getParameter( KeyStoreInformation.ENABLE_HOST_NAME_VERIFIER);	if (value != null) {	enableHostnameVerifier = Boolean.parseBoolean(value);	}	if (!enableHostnameVerifier) {	if (log.isDebugEnabled()) {	}	connection.setHostnameVerifier(new javax.net.ssl.HostnameVerifier() {	public boolean verify(String hostname, javax.net.ssl.SSLSession session) {	if (log.isTraceEnabled()) {	
hostname verification disabled 

String value = trustInformation.getParameter( KeyStoreInformation.ENABLE_HOST_NAME_VERIFIER);	if (value != null) {	enableHostnameVerifier = Boolean.parseBoolean(value);	}	if (!enableHostnameVerifier) {	if (log.isDebugEnabled()) {	}	connection.setHostnameVerifier(new javax.net.ssl.HostnameVerifier() {	public boolean verify(String hostname, javax.net.ssl.SSLSession session) {	if (log.isTraceEnabled()) {	
host 

String value = trustInformation.getParameter( KeyStoreInformation.ENABLE_HOST_NAME_VERIFIER);	if (value != null) {	enableHostnameVerifier = Boolean.parseBoolean(value);	}	if (!enableHostnameVerifier) {	if (log.isDebugEnabled()) {	}	connection.setHostnameVerifier(new javax.net.ssl.HostnameVerifier() {	public boolean verify(String hostname, javax.net.ssl.SSLSession session) {	if (log.isTraceEnabled()) {	
peer host 

}	connection.setHostnameVerifier(new javax.net.ssl.HostnameVerifier() {	public boolean verify(String hostname, javax.net.ssl.SSLSession session) {	if (log.isTraceEnabled()) {	}	return true;	}	});	} else {	if (log.isDebugEnabled()) {	
using default hostname verifier 

public static URLConnection getURLConnection(URL url) {	try {	if (url == null) {	if (log.isDebugEnabled()) {	
provided url is null 

public static URL getURLFromPath(String path, String synapseHome) {	if (path == null || "null".equals(path)) {	if (log.isDebugEnabled()) {	
can not create a url from null 

URL url = null;	try {	url = new URL(path);	if ("file".equals(url.getProtocol())) {	try {	url.openStream();	} catch (MalformedURLException e) {	handleException("Invalid URL reference : " + path, e);	} catch (IOException ignored) {	if (log.isDebugEnabled()) {	
can not open a connection to the url with a path 

} catch (MalformedURLException e) {	handleException("Invalid URL reference : " + path, e);	} catch (IOException ignored) {	if (log.isDebugEnabled()) {	}	if (synapseHome != null) {	if (synapseHome.endsWith("/")) {	synapseHome = synapseHome.substring(0, synapseHome.lastIndexOf("/"));	}	if (log.isDebugEnabled()) {	
trying to resolve an absolute path of the url using the synapse home 

}	if (log.isDebugEnabled()) {	}	try {	url = new URL(url.getProtocol() + ":" + synapseHome + "/" + url.getPath());	url.openStream();	} catch (MalformedURLException e) {	handleException("Invalid URL reference " + url.getPath() + e);	} catch (IOException e) {	if (log.isDebugEnabled()) {	
failed to resolve an absolute path of the url using the synapse home 

if (log.isDebugEnabled()) {	}	try {	url = new URL(url.getProtocol() + ":" + synapseHome + "/" + url.getPath());	url.openStream();	} catch (MalformedURLException e) {	handleException("Invalid URL reference " + url.getPath() + e);	} catch (IOException e) {	if (log.isDebugEnabled()) {	}	
io error reading from url 

public static String resolveRelativeURI(String parentLocation, String relativeLocation) {	if (relativeLocation == null) {	throw new IllegalArgumentException("Import URI cannot be null");	}	if (log.isDebugEnabled()) {	
resolving import uri against base uri 

========================= synapse sample_487 =========================

public void testCreateFaultAndChangeDirection() {	String addUrl = "http: String trpUrl = "http: String expectedError_MSFT = "Error while connecting to the endpoint (Connection Failed)";	String expectedError_SUN = "Error while connecting to the endpoint (Connection Failed)";	StockQuoteSampleClient client = getStockQuoteClient();	
running test creating soap fault messages and changing the direction of a message 

public void testCreateFaultAndChangeDirection() {	String addUrl = "http: String trpUrl = "http: String expectedError_MSFT = "Error while connecting to the endpoint (Connection Failed)";	String expectedError_SUN = "Error while connecting to the endpoint (Connection Failed)";	StockQuoteSampleClient client = getStockQuoteClient();	SampleClientResult result = client.requestStandardQuote(addUrl, trpUrl, null, "MSFT" ,null);	assertFalse("Must not get a response", result.responseReceived());	Exception resultEx = result.getException();	assertNotNull("Did not receive expected error", resultEx);	
got an error as expected 

SampleClientResult result = client.requestStandardQuote(addUrl, trpUrl, null, "MSFT" ,null);	assertFalse("Must not get a response", result.responseReceived());	Exception resultEx = result.getException();	assertNotNull("Did not receive expected error", resultEx);	assertTrue("Did not receive expected error", resultEx instanceof AxisFault);	assertTrue("Did not receive expected error", resultEx.getMessage().indexOf(expectedError_MSFT) != -1);	result = client.requestStandardQuote(addUrl, trpUrl, null, "SUN" ,null);	assertFalse("Must not get a response", result.responseReceived());	resultEx = result.getException();	assertNotNull("Did not receive expected error", resultEx);	
got an error as expected 

result = client.requestStandardQuote(addUrl, trpUrl, null, "SUN" ,null);	assertFalse("Must not get a response", result.responseReceived());	resultEx = result.getException();	assertNotNull("Did not receive expected error", resultEx);	assertTrue("Did not receive expected error", resultEx instanceof AxisFault);	assertTrue("Did not receive expected error", resultEx.getMessage().indexOf(expectedError_SUN) != -1);	result = client.requestStandardQuote(addUrl, trpUrl, null, "IBM" ,null);	assertFalse("Must not get a response", result.responseReceived());	resultEx = result.getException();	assertNotNull("Did not receive expected error", resultEx);	
got an error as expected 

========================= synapse sample_2266 =========================

if (nameAtt != null) {	messageStore.setName(nameAtt.getAttributeValue());	} else {	handleException("Message Store name not specified");	}	OMElement descriptionElem = elem.getFirstChildWithName(DESCRIPTION_Q);	if (descriptionElem != null) {	messageStore.setDescription(descriptionElem.getText());	}	messageStore.setParameters(getParameters(elem));	
successfully created message store 

========================= synapse sample_468 =========================

return !("repo".equalsIgnoreCase(optionType) || "conf" .equalsIgnoreCase(optionType));	}	});	if ((invalidOptionsList.size()>0)||(args.length>4)) {	printUsage();	return;	}	Map optionsMap = optionsParser.getAllOptions();	CommandLineOption repoOption = (CommandLineOption) optionsMap .get("repo");	CommandLineOption confOption = (CommandLineOption) optionsMap .get("conf");	
simpleaxisserver starting 

});	if ((invalidOptionsList.size()>0)||(args.length>4)) {	printUsage();	return;	}	Map optionsMap = optionsParser.getAllOptions();	CommandLineOption repoOption = (CommandLineOption) optionsMap .get("repo");	CommandLineOption confOption = (CommandLineOption) optionsMap .get("conf");	if (repoOption != null) {	repoLocation = repoOption.getOptionValue();	
simpleaxisserver using the repository 

if (confOption != null) {	confLocation = confOption.getOptionValue();	System.out .println("[SimpleAxisServer] Using the Axis2 Configuration File" + new File(confLocation).getAbsolutePath());	}	try {	ConfigurationContext configctx = ConfigurationContextFactory .createConfigurationContextFromFileSystem(repoLocation, confLocation);	configurePort(configctx);	ListenerManager listenerManager =  new ListenerManager();	listenerManager.init(configctx);	listenerManager.start();	
simpleaxisserver started 

confLocation = confOption.getOptionValue();	System.out .println("[SimpleAxisServer] Using the Axis2 Configuration File" + new File(confLocation).getAbsolutePath());	}	try {	ConfigurationContext configctx = ConfigurationContextFactory .createConfigurationContextFromFileSystem(repoLocation, confLocation);	configurePort(configctx);	ListenerManager listenerManager =  new ListenerManager();	listenerManager.init(configctx);	listenerManager.start();	} catch (Throwable t) {	
simpleaxisserver shutting down error starting simpleaxisserver 

private static void configurePort(ConfigurationContext configCtx) {	TransportInDescription trsIn = (TransportInDescription) configCtx.getAxisConfiguration().getTransportsIn().get(new QName("http"));	if(trsIn != null) {	String port = System.getProperty("port");	if(port != null) {	try {	new Integer(port);	trsIn.getParameter("port").setValue(port);	} catch (NumberFormatException e) {	
given port is not a valid integer using for port 

========================= synapse sample_3162 =========================

public void deploy(DeploymentFileData deploymentFileData) throws DeploymentException {	
loading mediator from 

if (facURL != null) {	InputStream facStream = facURL.openStream();	InputStreamReader facreader = new InputStreamReader(facStream);	StringBuffer facSB = new StringBuffer();	int c;	while ((c = facreader.read()) != -1) {	facSB.append((char) c);	}	String[] facClassName = facSB.toString().split("\n");	for (int i=0; i<facClassName.length; i++) {	
registering the mediator factory 

StringBuffer facSB = new StringBuffer();	int c;	while ((c = facreader.read()) != -1) {	facSB.append((char) c);	}	String[] facClassName = facSB.toString().split("\n");	for (int i=0; i<facClassName.length; i++) {	Class facClass = urlCl.loadClass(facClassName[i]);	MediatorFactory facInst = (MediatorFactory) facClass.newInstance();	MediatorFactoryFinder.getInstance() .getFactoryMap().put(facInst.getTagQName(), facClass);	
mediator loaded and registered for the tag name 

if (serURL != null) {	InputStream serStream = serURL.openStream();	InputStreamReader serReader = new InputStreamReader(serStream);	StringBuffer serSB = new StringBuffer();	int c;	while ((c = serReader.read()) != -1) {	serSB.append((char) c);	}	String[] serClassName = serSB.toString().split("\n");	for (int i=0; i<serClassName.length; i++) {	
registering the mediator serializer 

StringBuffer serSB = new StringBuffer();	int c;	while ((c = serReader.read()) != -1) {	serSB.append((char) c);	}	String[] serClassName = serSB.toString().split("\n");	for (int i=0; i<serClassName.length; i++) {	Class serClass = urlCl.loadClass(serClassName[i]);	MediatorSerializer serInst = (MediatorSerializer) serClass.newInstance();	MediatorSerializerFinder.getInstance() .getSerializerMap().put(serInst.getMediatorClassName(), serInst);	
mediator loaded and registered for the serialization as 

serSB.append((char) c);	}	String[] serClassName = serSB.toString().split("\n");	for (int i=0; i<serClassName.length; i++) {	Class serClass = urlCl.loadClass(serClassName[i]);	MediatorSerializer serInst = (MediatorSerializer) serClass.newInstance();	MediatorSerializerFinder.getInstance() .getSerializerMap().put(serInst.getMediatorClassName(), serInst);	}	} else {	if (log.isDebugEnabled()) {	
unable to find the mediatorserializer implementation unable to register the mediatorserializer with the serializerfinder 

} catch (IOException e) {	handleException("I/O error in reading the mediator jar file", e);	} catch (ClassNotFoundException e) {	handleException("Unable to find the specified class on the path or in the jar file", e);	} catch (IllegalAccessException e) {	handleException("Unable to load the class from the jar", e);	} catch (InstantiationException e) {	handleException("Unable to instantiate the class specified", e);	} finally {	if (log.isDebugEnabled()) {	
restoring the context class loader to the original 

========================= synapse sample_3498 =========================

expectedValue = countersMap.get(sourceSession);	} else {	countersMap.put(sourceSession, 1);	messagesMap.put(sourceSession, new ConcurrentHashMap<Integer,Object[]>());	expectedValue = 1;	}	if (expectedValue == counter) {	sendToTarget(msgCtx, targetEPR, message, targetSession);	if (FIXConstants.DEFAULT_COUNTER_UPPER_LIMIT == expectedValue) {	if (log.isDebugEnabled()) {	
outgoing request counter rolled over for the session from 

if (FIXConstants.DEFAULT_COUNTER_UPPER_LIMIT == expectedValue) {	if (log.isDebugEnabled()) {	}	expectedValue = 1;	}	countersMap.put(sourceSession, ++expectedValue);	sendQueuedMessages(expectedValue, sourceSession);	}	else {	if (log.isDebugEnabled()) {	
source session expected sequence number does not match with the actual sequence number holding the message back for later delivery 

while (obj != null) {	Message message = (Message) obj[0];	SessionID sessionID = (SessionID) obj[1];	MessageContext msgCtx = null;	String targetEPR = null;	if (obj[2] != null) {	msgCtx = (MessageContext) obj[2];	targetEPR = (String) obj[3];	}	if (log.isDebugEnabled()) {	
source session sending the previously queued message with the sequence number 

if (obj[2] != null) {	msgCtx = (MessageContext) obj[2];	targetEPR = (String) obj[3];	}	if (log.isDebugEnabled()) {	}	sendToTarget(msgCtx, targetEPR, message, sessionID);	messages.remove(expectedValue);	if (FIXConstants.DEFAULT_COUNTER_UPPER_LIMIT == expectedValue) {	if (log.isDebugEnabled()) {	
outgoing request counter rolled over for the session from 

public void cleanUpMessages(String session) {	if (countersMap.containsKey(session)) {	int expectedValue = countersMap.get(session);	Map<Integer,  Object[]> messages = messagesMap.get(session);	while (!messages.isEmpty()) {	Object[] obj = messages.get(expectedValue);	if (obj != null) {	Message message = (Message) obj[0];	SessionID sessionID = (SessionID) obj[1];	if (log.isDebugEnabled()) {	
source session flushing the previously queued message with the sequence number 

========================= synapse sample_1082 =========================

public void execute() throws MojoExecutionException {	File xarFile = new File(outputDirectory, xarName + ".xar");	
generating xar 

========================= synapse sample_2704 =========================

private void init(String addUrl, String trpUrl, String prxUrl, String policyKey, long timeout) throws Exception {	if (log.isDebugEnabled()) {	
initializing sample client 

HttpTransportProperties.ProxyProperties proxyProperties = new HttpTransportProperties.ProxyProperties();	URL url = new URL(prxUrl);	proxyProperties.setProxyName(url.getHost());	proxyProperties.setProxyPort(url.getPort());	proxyProperties.setUserName("");	proxyProperties.setPassWord("");	proxyProperties.setDomain("");	options.setProperty(HTTPConstants.PROXY, proxyProperties);	}	if (policyKey != null && !"".equals(policyKey)) {	
using ws security 

options.setProperty(HTTPConstants.PROXY, proxyProperties);	}	if (policyKey != null && !"".equals(policyKey)) {	serviceClient.engageModule("addressing");	serviceClient.engageModule("rampart");	OMXMLParserWrapper builder = OMXMLBuilderFactory.createOMBuilder(new FileInputStream(policyKey));	Policy policy = PolicyEngine.getPolicy(builder.getDocumentElement());	options.setProperty(RampartMessageData.KEY_RAMPART_POLICY, policy);	}	if (timeout > 0) {	
setting client timeout to 

private void terminate() {	if (serviceClient != null) {	if (log.isDebugEnabled()) {	
cleaning up client 

private void terminate() {	if (serviceClient != null) {	if (log.isDebugEnabled()) {	}	try {	serviceClient.cleanupTransport();	serviceClient.cleanup();	configContext.terminate();	} catch (AxisFault axisFault) {	
error terminating client 

public SampleClientResult requestStandardQuote(String addUrl, String trpUrl, String prxUrl, String symbol, String svcPolicy) {	
sending standard quote request 

public SampleClientResult requestStandardQuote(String addUrl, String trpUrl, String prxUrl, String symbol, String svcPolicy) {	SampleClientResult clientResult = new SampleClientResult();	try {	init(addUrl, trpUrl, prxUrl, svcPolicy, 10000);	payload = StockQuoteHandler.createStandardQuoteRequest( symbol, 1);	serviceClient.getOptions().setAction("urn:getQuote");	OMElement resultElement = serviceClient.sendReceive(payload);	log.info("Standard :: Stock price = $" + StockQuoteHandler.parseStandardQuoteResponse(resultElement));	clientResult.incrementResponseCount();	} catch (Exception e) {	
error invoking service 

public SampleClientResult requestDualQuote(String addUrl, String trpUrl, String prxUrl, String symbol) {	
sending dual quote request 

while (true) {	if (isCompleted()) {	log.info("Standard dual channel :: Stock price = $" + StockQuoteHandler.parseStandardQuoteResponse(getResponse()));	clientResult.incrementResponseCount();	break;	} else {	Thread.sleep(100);	}	}	} catch (Exception e) {	
error invoking service 

public SampleClientResult requestCustomQuote(String addUrl, String trpUrl, String prxUrl, String symbol) {	
sending custom quote request 

public SampleClientResult requestCustomQuote(String addUrl, String trpUrl, String prxUrl, String symbol) {	SampleClientResult clientResult = new SampleClientResult();	try {	init(addUrl, trpUrl, prxUrl, null, 10000);	payload = StockQuoteHandler.createCustomQuoteRequest(symbol);	serviceClient.getOptions().setAction("urn:getQuote");	OMElement resultElement = serviceClient.sendReceive(payload);	log.info("Custom :: Stock price = $" + StockQuoteHandler.parseCustomQuoteResponse(resultElement));	clientResult.incrementResponseCount();	} catch (Exception e) {	
error invoking service 

public SampleClientResult placeOrder(String addUrl, String trpUrl, String prxUrl, String symbol) {	
sending fire and forget place order request 

public SampleClientResult placeOrder(String addUrl, String trpUrl, String prxUrl, String symbol) {	SampleClientResult clientResult = new SampleClientResult();	try {	init(addUrl, trpUrl, prxUrl, null, 10000);	double price = getRandom(100, 0.9, true);	int quantity = (int) getRandom(10000, 1.0, true);	payload = StockQuoteHandler.createPlaceOrderRequest(price, quantity, symbol);	serviceClient.getOptions().setAction("urn:placeOrder");	serviceClient.fireAndForget(payload);	Thread.sleep(5000);	
order placed for shares of stock at a price of 

try {	init(addUrl, trpUrl, prxUrl, null, 10000);	double price = getRandom(100, 0.9, true);	int quantity = (int) getRandom(10000, 1.0, true);	payload = StockQuoteHandler.createPlaceOrderRequest(price, quantity, symbol);	serviceClient.getOptions().setAction("urn:placeOrder");	serviceClient.fireAndForget(payload);	Thread.sleep(5000);	clientResult.incrementResponseCount();	} catch (Exception e) {	
error invoking service 

public SampleClientResult requestRestQuote(String addUrl, String trpUrl, String prxUrl, String symbol) {	
sending rest request 

SampleClientResult clientResult = new SampleClientResult();	try {	init(addUrl, trpUrl, prxUrl, null, 10000);	payload = StockQuoteHandler.createStandardQuoteRequest(symbol, 1);	serviceClient.getOptions().setAction("urn:getQuote");	serviceClient.getOptions().setProperty(Constants.Configuration.ENABLE_REST, Constants.VALUE_TRUE);	OMElement resultElement = serviceClient.sendReceive(payload);	log.info("Standard :: Stock price = $" + StockQuoteHandler. parseStandardQuoteResponse(resultElement));	clientResult.incrementResponseCount();	} catch (Exception e) {	
error invoking service 

while (i < iterations || infinite) {	serviceClient.getOptions().setManageSession(true);	OMElement responseElement = serviceClient.sendReceive(value);	String response = responseElement.getText();	clientResult.incrementResponseCount();	i++;	log.info("Request: " + i + " ==> " + response);	testString = testString.concat(":" + i + ">" + response + ":");	}	} catch (Exception e) {	
error invoking service 

if (httpSession) {	if (receivedSetCookie != null && !"".equals(receivedSetCookie)) {	cookies[cookieNumber] = receivedCookie;	}	}	SOAPEnvelope responseEnvelope = responseContext.getEnvelope();	OMElement vElement = responseEnvelope.getBody().getFirstChildWithName(new QName("Value"));	clientResult.incrementResponseCount();	log.info("Request: " + i + " with Session ID: " + (httpSession ? cookie : sessionNumber) + " ---- " + "Response : with  " + (httpSession && receivedCookie != null ? (receivedSetCookie != null ? receivedSetCookie : receivedCookie) : " ") + " " + vElement.getText());	} catch (AxisFault axisFault) {	
request with session id get a fault 

}	}	SOAPEnvelope responseEnvelope = responseContext.getEnvelope();	OMElement vElement = responseEnvelope.getBody().getFirstChildWithName(new QName("Value"));	clientResult.incrementResponseCount();	log.info("Request: " + i + " with Session ID: " + (httpSession ? cookie : sessionNumber) + " ---- " + "Response : with  " + (httpSession && receivedCookie != null ? (receivedSetCookie != null ? receivedSetCookie : receivedCookie) : " ") + " " + vElement.getText());	} catch (AxisFault axisFault) {	}	}	} catch (Exception e) {	
error invoking service 

========================= synapse sample_2211 =========================

public void testURLRewrite() {	
running test conditional url rewriting 

========================= synapse sample_809 =========================

public void updateSession(MessageContext synCtx) {	SOAPHeader header = synCtx.getEnvelope().getHeader();	if (header != null) {	OMElement replyTo = header.getFirstChildWithName( AddressingConstants.Final.QNAME_WSA_REPLY_TO);	if (replyTo != null) {	OMElement referenceParameters = replyTo.getFirstChildWithName(new QName( "http: if (referenceParameters != null) {	SALSessions.getInstance().updateSession(synCtx, extractSessionID(referenceParameters, QNAME_SERVICE_GROUP_ID));	} else if (log.isDebugEnabled()) {	
couldn t find the wsa referenceparameters in the reply to header to retrieve the serviceqroupid 

public void updateSession(MessageContext synCtx) {	SOAPHeader header = synCtx.getEnvelope().getHeader();	if (header != null) {	OMElement replyTo = header.getFirstChildWithName( AddressingConstants.Final.QNAME_WSA_REPLY_TO);	if (replyTo != null) {	OMElement referenceParameters = replyTo.getFirstChildWithName(new QName( "http: if (referenceParameters != null) {	SALSessions.getInstance().updateSession(synCtx, extractSessionID(referenceParameters, QNAME_SERVICE_GROUP_ID));	} else if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
couldn t find the wsa reply to header to retrieve the serviceqroupid 

========================= synapse sample_223 =========================

public void init(SynapseEnvironment se) {	if (log.isDebugEnabled()) {	
initializing resource with id 

public void destroy() {	if (log.isDebugEnabled()) {	
destroying resource with id 

========================= synapse sample_2092 =========================

public void release() {	if (temporaryFile != null) {	if (log.isDebugEnabled()) {	
deleting temporary file 

protected void finalize() throws Throwable {	if (temporaryFile != null) {	
cleaning up unreleased temporary file 

========================= synapse sample_2138 =========================

public static void serializeConfiguration(SynapseConfiguration synCfg, OutputStream outputStream) throws XMLStreamException {	
serializing the xml configuration to the output stream 

========================= synapse sample_4146 =========================

public void updateSession(MessageContext synCtx) {	SOAPHeader header = synCtx.getEnvelope().getHeader();	if (header != null) {	OMElement replyTo = header.getFirstChildWithName( AddressingConstants.Final.QNAME_WSA_REPLY_TO);	if (replyTo != null) {	OMElement referenceParameters = replyTo.getFirstChildWithName(new QName( "http: if (referenceParameters != null) {	SALSessions.getInstance().updateSession(synCtx, extractSessionID(referenceParameters, QNAME_SERVICE_GROUP_ID));	} else if (log.isDebugEnabled()) {	
couldn t find the wsa referenceparameters in the reply to header to retrieve the serviceqroupid 

public void updateSession(MessageContext synCtx) {	SOAPHeader header = synCtx.getEnvelope().getHeader();	if (header != null) {	OMElement replyTo = header.getFirstChildWithName( AddressingConstants.Final.QNAME_WSA_REPLY_TO);	if (replyTo != null) {	OMElement referenceParameters = replyTo.getFirstChildWithName(new QName( "http: if (referenceParameters != null) {	SALSessions.getInstance().updateSession(synCtx, extractSessionID(referenceParameters, QNAME_SERVICE_GROUP_ID));	} else if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
couldn t find the wsa reply to header to retrieve the serviceqroupid 

========================= synapse sample_1651 =========================

private synchronized void buildAppContext(MessageContext synCtx) {	
creating spring applicationcontext from property key 

========================= synapse sample_3142 =========================

synCtx.setProperty(SynapseConstants.RESPONSE, Boolean.TRUE);	synCtx.setResponse(true);	} else {	synCtx.setProperty(SynapseConstants.RESPONSE, Boolean.FALSE);	synCtx.setResponse(false);	}	try {	if (synCtx.getEnvironment().injectMessage(synCtx)) {	return InvocationResponse.CONTINUE;	} else {	
synapse has decided to abort the message 

try {	if (synCtx.getEnvironment().injectMessage(synCtx)) {	return InvocationResponse.CONTINUE;	} else {	return InvocationResponse.ABORT;	}	} catch (SynapseException syne) {	if (!synCtx.getFaultStack().isEmpty()) {	((FaultHandler) synCtx.getFaultStack().pop()).handleFault(synCtx, syne);	} else {	
synapse encountered an exception no error handlers found 

========================= synapse sample_3904 =========================

public void testRestrictedThrottling() {	String addUrl = "http: String expectedError = "Access Denied";	StockQuoteSampleClient client = getStockQuoteClient();	
running test restricting requests based on policies 

String addUrl = "http: String expectedError = "Access Denied";	StockQuoteSampleClient client = getStockQuoteClient();	for (int i = 0; i < 4; i++) {	result = client.requestStandardQuote(addUrl, null, null, "IBM", null);	}	assertTrue("Client did not get run successfully ", result.responseReceived());	result = client.requestStandardQuote(addUrl, null, null, "IBM", null);	assertFalse("Should not get a response", result.responseReceived());	Exception resultEx = result.getException();	assertNotNull("Did not receive expected error", resultEx);	
got an error as expected 

========================= synapse sample_2246 =========================

public Startup createStartup(OMElement el) {	if (log.isDebugEnabled()) {	
creating simplequartz task 

========================= synapse sample_624 =========================

expectedValue = countersMap.get(sourceSession);	} else {	countersMap.put(sourceSession, 1);	messagesMap.put(sourceSession, new ConcurrentHashMap<Integer,Object[]>());	expectedValue = 1;	}	if (expectedValue == counter) {	sendToTarget(msgCtx, targetEPR, message, targetSession);	if (FIXConstants.DEFAULT_COUNTER_UPPER_LIMIT == expectedValue) {	if (log.isDebugEnabled()) {	
outgoing request counter rolled over for the session from 

if (FIXConstants.DEFAULT_COUNTER_UPPER_LIMIT == expectedValue) {	if (log.isDebugEnabled()) {	}	expectedValue = 1;	}	countersMap.put(sourceSession, ++expectedValue);	sendQueuedMessages(expectedValue, sourceSession);	}	else {	if (log.isDebugEnabled()) {	
source session expected sequence number does not match with the actual sequence number holding the message back for later delivery 

while (obj != null) {	Message message = (Message) obj[0];	SessionID sessionID = (SessionID) obj[1];	MessageContext msgCtx = null;	String targetEPR = null;	if (obj[2] != null) {	msgCtx = (MessageContext) obj[2];	targetEPR = (String) obj[3];	}	if (log.isDebugEnabled()) {	
source session sending the previously queued message with the sequence number 

if (obj[2] != null) {	msgCtx = (MessageContext) obj[2];	targetEPR = (String) obj[3];	}	if (log.isDebugEnabled()) {	}	sendToTarget(msgCtx, targetEPR, message, sessionID);	messages.remove(expectedValue);	if (FIXConstants.DEFAULT_COUNTER_UPPER_LIMIT == expectedValue) {	if (log.isDebugEnabled()) {	
outgoing request counter rolled over for the session from 

public void cleanUpMessages(String session) {	if (countersMap.containsKey(session)) {	int expectedValue = countersMap.get(session);	Map<Integer,  Object[]> messages = messagesMap.get(session);	while (!messages.isEmpty()) {	Object[] obj = messages.get(expectedValue);	if (obj != null) {	Message message = (Message) obj[0];	SessionID sessionID = (SessionID) obj[1];	if (log.isDebugEnabled()) {	
source session flushing the previously queued message with the sequence number 

========================= synapse sample_2495 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
endpoint deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	Endpoint ep = EndpointFactory.getEndpointFromElement(artifactConfig, false, properties);	if (ep != null) {	ep.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
endpoint named has been built from the file 

if (log.isDebugEnabled()) {	}	try {	Endpoint ep = EndpointFactory.getEndpointFromElement(artifactConfig, false, properties);	if (ep != null) {	ep.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	ep.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	
initialized the endpoint 

Endpoint ep = EndpointFactory.getEndpointFromElement(artifactConfig, false, properties);	if (ep != null) {	ep.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	ep.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEndpoint(ep.getName(), ep);	if (log.isDebugEnabled()) {	
endpoint deployment from file completed 

if (ep != null) {	ep.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	ep.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEndpoint(ep.getName(), ep);	if (log.isDebugEnabled()) {	}	
endpoint named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
endpoint update from file has started 

if (log.isDebugEnabled()) {	}	try {	Endpoint ep = EndpointFactory.getEndpointFromElement(artifactConfig, false, properties);	if (ep == null) {	handleSynapseArtifactDeploymentError("Endpoint update failed. The artifact " + "defined in the file: " + fileName + " is not a valid endpoint.");	return null;	}	ep.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	
endpoint has been built from the file 

ep.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	ep.init(getSynapseEnvironment());	Endpoint existingEp = getSynapseConfiguration().getDefinedEndpoints().get(existingArtifactName);	if (existingArtifactName.equals(ep.getName())) {	getSynapseConfiguration().updateEndpoint(existingArtifactName, ep);	} else {	getSynapseConfiguration().addEndpoint(ep.getName(), ep);	getSynapseConfiguration().removeEndpoint(existingArtifactName);	
endpoint has been undeployed 

if (log.isDebugEnabled()) {	}	ep.init(getSynapseEnvironment());	Endpoint existingEp = getSynapseConfiguration().getDefinedEndpoints().get(existingArtifactName);	if (existingArtifactName.equals(ep.getName())) {	getSynapseConfiguration().updateEndpoint(existingArtifactName, ep);	} else {	getSynapseConfiguration().addEndpoint(ep.getName(), ep);	getSynapseConfiguration().removeEndpoint(existingArtifactName);	}	
endpoint has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
endpoint undeployment of the endpoint named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	Endpoint ep = getSynapseConfiguration().getDefinedEndpoints().get(artifactName);	if (ep != null) {	getSynapseConfiguration().removeEndpoint(artifactName);	if (log.isDebugEnabled()) {	
destroying the endpoint named 

if (log.isDebugEnabled()) {	}	try {	Endpoint ep = getSynapseConfiguration().getDefinedEndpoints().get(artifactName);	if (ep != null) {	getSynapseConfiguration().removeEndpoint(artifactName);	if (log.isDebugEnabled()) {	}	ep.destroy();	if (log.isDebugEnabled()) {	
endpoint undeployment of the endpoint named completed 

}	try {	Endpoint ep = getSynapseConfiguration().getDefinedEndpoints().get(artifactName);	if (ep != null) {	getSynapseConfiguration().removeEndpoint(artifactName);	if (log.isDebugEnabled()) {	}	ep.destroy();	if (log.isDebugEnabled()) {	}	
endpoint named has been undeployed 

try {	Endpoint ep = getSynapseConfiguration().getDefinedEndpoints().get(artifactName);	if (ep != null) {	getSynapseConfiguration().removeEndpoint(artifactName);	if (log.isDebugEnabled()) {	}	ep.destroy();	if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
endpoint has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the endpoint with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	Endpoint ep = getSynapseConfiguration().getDefinedEndpoints().get(artifactName);	OMElement epElem = EndpointSerializer.getElementFromEndpoint(ep);	if (ep.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.ENDPOINTS_DIR + File.separator + ep.getFileName();	writeToFile(epElem, fileName);	if (log.isDebugEnabled()) {	
restoring the endpoint with name completed 

if (log.isDebugEnabled()) {	}	try {	Endpoint ep = getSynapseConfiguration().getDefinedEndpoints().get(artifactName);	OMElement epElem = EndpointSerializer.getElementFromEndpoint(ep);	if (ep.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.ENDPOINTS_DIR + File.separator + ep.getFileName();	writeToFile(epElem, fileName);	if (log.isDebugEnabled()) {	}	
endpoint named has been restored 

========================= synapse sample_1606 =========================

public boolean matches(String value) {	if (value == null) {	
provided character sequence for switch case condition is null switch case will not be executed 

public boolean matches(String value) {	if (value == null) {	return false;	}	Matcher matcher = regex.matcher(value);	if (matcher == null) {	
matcher for the provided character sequence and the pattern cannot be found switch case will not be executed 

========================= synapse sample_4054 =========================

public void testDynamicSequences() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test dynamic sequences with registry 

========================= synapse sample_848 =========================

public boolean startProcess() {	processException = null;	synchronized (axis2Server) {	axis2Server.start();	while (serverState <= STARTING_UP) {	try {	axis2Server.wait(1000);	} catch (InterruptedException e) {	
server startup was interrupted 

axis2Server.start();	while (serverState <= STARTING_UP) {	try {	axis2Server.wait(1000);	} catch (InterruptedException e) {	return false;	}	}	}	if (serverState == STARTUP_FAILED) {	
server failed to start 

public boolean stopProcess() {	if (serverState == SERVER_ACTIVE) {	synchronized (axis2Server) {	serverState = SHUTTING_DOWN;	axis2Server.notifyAll();	while (serverState > UNDEFINED) {	try {	axis2Server.wait(1000);	} catch (InterruptedException e) {	
server shutdown was interrupted 

TransportInDescription httpsTrsIn = configContext.getAxisConfiguration(). getTransportsIn().get("https");	httpsTrsIn.getParameter("port").setValue(httpsPort);	}	ClusteringAgent clusteringAgent = configContext.getAxisConfiguration().getClusteringAgent();	String avoidInit = ClusteringConstants.Parameters.AVOID_INITIATION;	if (clusteringAgent != null && clusteringAgent.getParameter(avoidInit) != null && ((String) clusteringAgent.getParameter(avoidInit).getValue()). equalsIgnoreCase("true")) {	clusteringAgent.setConfigurationContext(configContext);	clusteringAgent.init();	}	if (counterEnabled) {	
engaging server side message counter 

========================= synapse sample_798 =========================

public void acknowledgeMessage(MessageContext msgContext) throws AxisFault {	if (log.isDebugEnabled()) {	
acking one way request 

public void awaitResponse() throws InterruptedException, AxisFault {	if (log.isDebugEnabled()) {	
returning thread but keeping socket open awaiting response 

public void signalResponseReady() {	if (log.isDebugEnabled()) {	
signal response available 

========================= synapse sample_3768 =========================

public static String getNameSpaceWithPrefix(String prefix, OMElement elem) {	if (prefix == null || elem == null) {	
searching for null ns prefix and or using null omelement 

========================= synapse sample_1755 =========================

public void deploy(DeploymentFileData deploymentFileData) throws DeploymentException {	
loading extensions from 

boolean isDirectory = deploymentFileData.getFile().isDirectory();	deploymentFileData.setClassLoader(isDirectory, getClass().getClassLoader(), (File) cfgCtx.getAxisConfiguration().getParameterValue( Constants.Configuration.ARTIFACTS_TEMP_DIR), cfgCtx.getAxisConfiguration().isChildFirstClassLoading());	DeploymentClassLoader urlCl = (DeploymentClassLoader)deploymentFileData.getClassLoader();	Thread.currentThread().setContextClassLoader(urlCl);	for (StartupFactory factory : getProviders(StartupFactory.class, urlCl)) {	QName tagQName = factory.getTagQName();	Class<? extends StartupFactory> clazz = factory.getClass();	StartupFinder finder = StartupFinder.getInstance();	finder.getFactoryMap().put(tagQName, clazz);	finder.getSerializerMap().put(tagQName, factory.getSerializerClass());	
registered startup factory and serializer for 

QName tagQName = factory.getTagQName();	Class<? extends StartupFactory> clazz = factory.getClass();	StartupFinder finder = StartupFinder.getInstance();	finder.getFactoryMap().put(tagQName, clazz);	finder.getSerializerMap().put(tagQName, factory.getSerializerClass());	}	for (MediatorFactory factory : getProviders(MediatorFactory.class, urlCl)) {	QName tagQName = factory.getTagQName();	Class<? extends MediatorFactory> clazz = factory.getClass();	MediatorFactoryFinder.getInstance().getFactoryMap().put(tagQName, clazz);	
registered mediator factory for 

finder.getSerializerMap().put(tagQName, factory.getSerializerClass());	}	for (MediatorFactory factory : getProviders(MediatorFactory.class, urlCl)) {	QName tagQName = factory.getTagQName();	Class<? extends MediatorFactory> clazz = factory.getClass();	MediatorFactoryFinder.getInstance().getFactoryMap().put(tagQName, clazz);	}	for (MediatorSerializer serializer : getProviders(MediatorSerializer.class, urlCl)) {	String mediatorClassName = serializer.getMediatorClassName();	MediatorSerializerFinder.getInstance().getSerializerMap().put( mediatorClassName, serializer);	
registered mediator serializer for 

MediatorSerializerFinder.getInstance().getSerializerMap().put( mediatorClassName, serializer);	}	} catch (IOException e) {	handleException("I/O error in reading the mediator jar file", e);	} catch (Exception e) {	handleException("Error occurred while trying to deploy mediator jar file", e);	} catch (Throwable t) {	handleException("Error occurred while trying to deploy the mediator jar file", t);	} finally {	if (log.isDebugEnabled()) {	
restoring the context class loader to the original 

private <T> List<T> getProviders(Class<T> providerClass, URLClassLoader loader) throws IOException {	List<T> providers = new LinkedList<T>();	String providerClassName = providerClass.getName();	providerClassName = providerClassName.substring(providerClassName.indexOf('.')+1);	URL servicesURL = loader.findResource("META-INF/services/" + providerClass.getName());	if (servicesURL != null) {	BufferedReader in = new BufferedReader(new InputStreamReader(servicesURL.openStream()));	try {	String className;	while ((className = in.readLine()) != null && (!className.trim().equals(""))) {	
loading the implementation 

========================= synapse sample_1610 =========================

public InvocationResponse invoke(MessageContext messageContext) throws AxisFault {	HandlerUtil.doHandlerLogging(log, messageContext);	org.apache.synapse.MessageContext synCtx = MessageContextCreatorForAxis2.getSynapseMessageContext(messageContext);	if (!messageContext.isServerSide()) {	synCtx.setProperty(SynapseConstants.RESPONSE, Boolean.TRUE);	synCtx.setResponse(true);	try {	if (HandlerUtil.mediateOutMessage(log, messageContext, synCtx)) {	return InvocationResponse.CONTINUE;	} else {	
synapse has decided to abort the message 

}	} catch (SynapseException syne) {	}	} else {	synCtx.setProperty(SynapseConstants.RESPONSE, Boolean.FALSE);	synCtx.setResponse(false);	try {	if (HandlerUtil.mediateInMessage(log, messageContext, synCtx)) {	return InvocationResponse.CONTINUE;	} else {	
synapse has decided to abort the message 

========================= synapse sample_3 =========================

public void connected(final NHttpClientConnection conn, final Object attachment) {	if (this.log.isDebugEnabled()) {	
http connection connected 

public void closed(final NHttpClientConnection conn) {	if (this.log.isDebugEnabled()) {	
http connection closed 

public void exception(final NHttpClientConnection conn, final IOException ex) {	
http connection 

public void exception(final NHttpClientConnection conn, final HttpException ex) {	
http connection 

public void requestReady(final NHttpClientConnection conn) {	if (this.log.isDebugEnabled()) {	
http connection request ready 

public void outputReady(final NHttpClientConnection conn, final ContentEncoder encoder) {	if (this.log.isDebugEnabled()) {	
http connection output ready 

public void outputReady(final NHttpClientConnection conn, final ContentEncoder encoder) {	if (this.log.isDebugEnabled()) {	}	this.handler.outputReady(conn, encoder);	if (this.log.isDebugEnabled()) {	
http connection content encoder 

public void responseReceived(final NHttpClientConnection conn) {	HttpResponse response = conn.getHttpResponse();	if (this.log.isDebugEnabled()) {	
http connection 

public void inputReady(final NHttpClientConnection conn, final ContentDecoder decoder) {	if (this.log.isDebugEnabled()) {	
http connection input ready 

public void inputReady(final NHttpClientConnection conn, final ContentDecoder decoder) {	if (this.log.isDebugEnabled()) {	}	this.handler.inputReady(conn, decoder);	if (this.log.isDebugEnabled()) {	
http connection content decoder 

public void timeout(final NHttpClientConnection conn) {	if (this.log.isDebugEnabled()) {	
http connection timeout 

========================= synapse sample_4296 =========================

protected KeyStore getKeyStore(String location, String storePassword, String storeType, String provider) {	File keyStoreFile = new File(location);	if (!keyStoreFile.exists()) {	handleException("KeyStore can not be found at ' " + keyStoreFile + " '");	}	BufferedInputStream bis = null;	try {	if (log.isDebugEnabled()) {	
loading keystore from store type provider 

========================= synapse sample_1094 =========================

public ClientWorker(ConfigurationContext cfgCtx, InputStream in, HttpResponse response, MessageContext outMsgCtx) {	this.cfgCtx = cfgCtx;	this.in = in;	this.response = response;	try {	responseMsgCtx = outMsgCtx.getOperationContext(). getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);	if (responseMsgCtx != null) {	responseMsgCtx.setSoapAction("");	}	} catch (AxisFault af) {	
error getting in message context from the operation context 

try {	responseMsgCtx = outMsgCtx.getOperationContext(). getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);	if (responseMsgCtx != null) {	responseMsgCtx.setSoapAction("");	}	} catch (AxisFault af) {	return;	}	if (responseMsgCtx == null && outMsgCtx.getOperationContext().isComplete()) {	if (log.isDebugEnabled()) {	
error getting in message context from the operation context possibly an rm terminate sequence message 

}	if (contentType.indexOf(HTTP.CHARSET_PARAM) > 0) {	responseMsgCtx.setProperty(Constants.Configuration.CHARACTER_SET_ENCODING, charSetEnc);	} else {	responseMsgCtx.setProperty(Constants.Configuration.CHARACTER_SET_ENCODING, MessageContext.DEFAULT_CHAR_SET_ENCODING);	}	responseMsgCtx.setServerSide(false);	try {	envelope = TransportUtils.createSOAPMessage( responseMsgCtx, HTTPTransportUtils.handleGZip(responseMsgCtx, in), contentType);	} catch (OMException e) {	
unexpected response received 

code.setText(Integer.toString(this.response.getStatusLine().getStatusCode()));	envelope.getBody().getFault().setCode(code);	}	responseMsgCtx.setServerSide(true);	responseMsgCtx.setEnvelope(envelope);	responseMsgCtx.setProperty(NhttpConstants.HTTP_SC, this.response.getStatusLine().getStatusCode());	AxisEngine engine = new AxisEngine(cfgCtx);	try {	engine.receive(responseMsgCtx);	} catch (AxisFault af) {	
fault processing response message through 

}	responseMsgCtx.setServerSide(true);	responseMsgCtx.setEnvelope(envelope);	responseMsgCtx.setProperty(NhttpConstants.HTTP_SC, this.response.getStatusLine().getStatusCode());	AxisEngine engine = new AxisEngine(cfgCtx);	try {	engine.receive(responseMsgCtx);	} catch (AxisFault af) {	}	} catch (AxisFault af) {	
fault creating response soap envelope 

responseMsgCtx.setEnvelope(envelope);	responseMsgCtx.setProperty(NhttpConstants.HTTP_SC, this.response.getStatusLine().getStatusCode());	AxisEngine engine = new AxisEngine(cfgCtx);	try {	engine.receive(responseMsgCtx);	} catch (AxisFault af) {	}	} catch (AxisFault af) {	return;	} catch (XMLStreamException e) {	
error creating response soap envelope 

responseMsgCtx.setProperty(NhttpConstants.HTTP_SC, this.response.getStatusLine().getStatusCode());	AxisEngine engine = new AxisEngine(cfgCtx);	try {	engine.receive(responseMsgCtx);	} catch (AxisFault af) {	}	} catch (AxisFault af) {	return;	} catch (XMLStreamException e) {	} catch (IOException e) {	
error closing input stream from which message was read 

========================= synapse sample_4279 =========================

if (System.getProperty(SynapseConstants.SYNAPSE_XML) == null) {	System.setProperty(SynapseConstants.SYNAPSE_XML, configurationContext. getAxisConfiguration().getRepository().getPath() + "/conf/synapse.xml");	}	if (new File(System.getProperty(SynapseConstants.SYNAPSE_XML)).exists()) {	initializationModule = new org.apache.synapse.core.axis2.SynapseInitializationModule();	initializationModule.init(configurationContext, axisModule);	Parameter synEnv = configurationContext .getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_ENV);	Parameter synCfg = configurationContext .getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_CONFIG);	String message = "Unable to initialize the Synapse Configuration : Can not find the ";	if (synCfg == null || synCfg.getValue() == null || !(synCfg.getValue() instanceof SynapseConfiguration)) {	
synapse configuration 

if (new File(System.getProperty(SynapseConstants.SYNAPSE_XML)).exists()) {	initializationModule = new org.apache.synapse.core.axis2.SynapseInitializationModule();	initializationModule.init(configurationContext, axisModule);	Parameter synEnv = configurationContext .getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_ENV);	Parameter synCfg = configurationContext .getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_CONFIG);	String message = "Unable to initialize the Synapse Configuration : Can not find the ";	if (synCfg == null || synCfg.getValue() == null || !(synCfg.getValue() instanceof SynapseConfiguration)) {	throw new SynapseException(message + "Synapse Configuration");	}	if (synEnv == null || synEnv.getValue() == null || !(synEnv.getValue() instanceof SynapseEnvironment)) {	
synapse environment 

========================= synapse sample_3416 =========================

public void receive(MessageContext messageContext) throws AxisFault {	
emptyrmmessagereceiver receive and inject the message into synapse environment 

public void receive(MessageContext messageContext) throws AxisFault {	
application message 

outMsgContext.getOperationContext().addMessageContext(outMsgContext);	org.apache.synapse.MessageContext synCtx = Axis2MessageContextFinder.getSynapseMessageContext(messageContext);	messageContext.setProperty(org.apache.synapse.Constants.MESSAGE_RECEIVED_RM_ENGAGED, Boolean.TRUE);	synCtx.getEnvironment().injectMessage(synCtx);	Object obj = messageContext.getProperty(org.apache.synapse.Constants.RESPONSE_SOAP_ENVELOPE);	if (obj != null) {	outMsgContext.setEnvelope((SOAPEnvelope)obj);	} else {	outMsgContext.setEnvelope(messageContext.getEnvelope());	}	
executed emptyrmmessagereceiver receive and java return for rmmediator 

========================= synapse sample_2987 =========================

public void run() {	String action = queueConsumerPolicy.getAction();	if (SEDAQueueConsumerPolicy.TAKE.equals(action)) {	try {	consume(queue.take());	} catch (InterruptedException ignored) {	
ignored interruptedexception when ocuured calling queue take 

} catch (InterruptedException ignored) {	}	} else if (SEDAQueueConsumerPolicy.POLL.equals(action)) {	long timeout = queueConsumerPolicy.getTimeoutOnPoll();	if (timeout < 0) {	consume(queue.poll());	} else {	try {	consume(queue.poll(timeout, TimeUnit.MILLISECONDS));	} catch (InterruptedException ignored) {	
ignored interruptedexception when ocuured calling queue poll 

========================= synapse sample_15 =========================

public static String getProperty(Properties properties, String name, String defaultValue) {	String result = properties.getProperty(name);	if ((result == null || result.length() == 0) && defaultValue != null) {	if (log.isDebugEnabled()) {	
the name with cannot be found using default value 

public static <T extends Object> T getProperty( Properties properties, String name, T defaultValue, Class<? extends T> type) {	String result = properties.getProperty(name);	if (result == null && defaultValue != null) {	if (log.isDebugEnabled()) {	
the name with cannot be found using default value 

public static Properties loadProperties(String filePath) {	Properties properties = new Properties();	ClassLoader cl = Thread.currentThread().getContextClassLoader();	if (log.isDebugEnabled()) {	
loading a file from classpath 

public static Properties loadProperties(String filePath) {	Properties properties = new Properties();	ClassLoader cl = Thread.currentThread().getContextClassLoader();	if (log.isDebugEnabled()) {	}	InputStream in  = null;	if (System.getProperty(CONF_LOCATION) != null) {	try {	in = new FileInputStream(System.getProperty(CONF_LOCATION) + File.separator + filePath);	} catch (FileNotFoundException e) {	
error loading properties from a file at the system defined location 

try {	in = new FileInputStream(System.getProperty(CONF_LOCATION) + File.separator + filePath);	} catch (FileNotFoundException e) {	}	}	if (in == null){	in = cl.getResourceAsStream(filePath);	}	if (in == null) {	if (log.isDebugEnabled()) {	
unable to load file 

}	}	if (in == null){	in = cl.getResourceAsStream(filePath);	}	if (in == null) {	if (log.isDebugEnabled()) {	}	filePath = "conf" + File.separatorChar + filePath;	if (log.isDebugEnabled()) {	
loading a file from classpath 

}	if (in == null) {	if (log.isDebugEnabled()) {	}	filePath = "conf" + File.separatorChar + filePath;	if (log.isDebugEnabled()) {	}	in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	
unable to load file 

========================= synapse sample_720 =========================

if (clusteringAgent.getGroupManagementAgent(domain) == null) {	clusteringAgent.addGroupManagementAgent(new DefaultGroupManagementAgent(), domain);	}	}	slbMembershipHandler = new ServiceLoadBalanceMembershipHandler(hostDomainMap, getAlgorithm(), cfgCtx, isClusteringEnabled, getName());	SALSessions salSessions = SALSessions.getInstance();	if (!salSessions.isInitialized()) {	salSessions.initialize(isClusteringEnabled, cfgCtx);	}	initialized = true;	
servicedynamicloadbalanceendpoint initialized 

setCookieHeader(synCtx);	Member currentMember = null;	SessionInformation sessionInformation = null;	if (isSessionAffinityBasedLB()) {	sessionInformation = (SessionInformation) synCtx.getProperty( SynapseConstants.PROP_SAL_CURRENT_SESSION_INFORMATION);	currentMember = (Member) synCtx.getProperty( SynapseConstants.PROP_SAL_ENDPOINT_CURRENT_MEMBER);	if (sessionInformation == null && currentMember == null) {	sessionInformation = dispatcher.getSession(synCtx);	if (sessionInformation != null) {	if (log.isDebugEnabled()) {	
current session id 

public void onFault(MessageContext synCtx) {	if (currentMember == null) {	return;	}	currentMember.suspend(10000);	
suspended member for 

}	Integer errorCode = (Integer) synCtx.getProperty(SynapseConstants.ERROR_CODE);	if (errorCode != null) {	if (errorCode.equals(NhttpConstants.CONNECTION_FAILED) || errorCode.equals(NhttpConstants.CONNECT_CANCEL) || errorCode.equals(NhttpConstants.CONNECT_TIMEOUT)) {	Member newMember = slbMembershipHandler.getNextApplicationMember(host);	if (newMember == null) {	String msg = "No application members available";	log.error(msg);	throw new SynapseException(msg);	}	
failed over to 

========================= synapse sample_1647 =========================

public void connected(final NHttpServerConnection conn) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection connected 

public void closed(final NHttpServerConnection conn) {	if (this.log.isDebugEnabled()) {	
http connection closed 

public void endOfInput(NHttpServerConnection conn) throws IOException {	if (this.log.isDebugEnabled()) {	
http connection closed at the remote end 

public void requestReceived(final NHttpServerConnection conn) throws IOException, HttpException {	HttpRequest request = conn.getHttpRequest();	if (this.log.isDebugEnabled()) {	
http inrequest received on connection 

public void outputReady(final NHttpServerConnection conn, final ContentEncoder encoder) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection output ready 

public void outputReady(final NHttpServerConnection conn, final ContentEncoder encoder) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	}	this.handler.outputReady(conn, encoder);	if (this.log.isDebugEnabled()) {	
http connection content encoder 

public void responseReady(final NHttpServerConnection conn) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection response ready 

public void inputReady(final NHttpServerConnection conn, final ContentDecoder decoder) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection input ready 

public void inputReady(final NHttpServerConnection conn, final ContentDecoder decoder) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	}	this.handler.inputReady(conn, decoder);	if (this.log.isDebugEnabled()) {	
http connection content decoder 

public void timeout(final NHttpServerConnection conn) throws IOException {	if (this.log.isDebugEnabled()) {	
http connection timeout 

========================= synapse sample_1000 =========================

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	
shutting down simpleaxisserver 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	stopServer();	
shutdown complete 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	stopServer();	
halting jvm 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	stopServer();	} catch (Exception e) {	
error occurred while shutting down simpleaxisserver 

========================= synapse sample_3894 =========================

public boolean mediate(SynapseContext synCtx) {	
mediate 

public boolean test(SynapseContext synCtx) {	try {	if (xpath != null) {	return xpath.booleanValueOf(synCtx.getSynapseMessage().getEnvelope());	} else if (source != null && regex != null) {	return regex.matcher(Util.getStringValue(source, synCtx)).matches();	} else {	
invalid configuration specified 

public boolean test(SynapseContext synCtx) {	try {	if (xpath != null) {	return xpath.booleanValueOf(synCtx.getSynapseMessage().getEnvelope());	} else if (source != null && regex != null) {	return regex.matcher(Util.getStringValue(source, synCtx)).matches();	} else {	return false;	}	} catch (JaxenException e) {	
xpath error 

========================= synapse sample_2786 =========================

try {	for (RewriteRule r : rules) {	r.rewrite(fragments, messageContext);	}	if (outputProperty != null) {	messageContext.setProperty(outputProperty, fragments.toURIString());	} else {	messageContext.setTo(new EndpointReference(fragments.toURIString()));	}	if(log.isDebugEnabled()) {	
url rewrite mediator has rewritten the address url 

========================= synapse sample_537 =========================

public boolean startProcess() {	try {	requestListener = new RequestListenerThread(port);	requestListener.start();	return true;	} catch (IOException e) {	
error while initializing echo server 

public void run() {	
listening on port 

Socket socket = this.serversocket.accept();	HttpServerConnection conn = this.connFactory.createConnection(socket);	Thread t = new WorkerThread(this.httpService, conn, counter.incrementAndGet());	t.start();	} catch (InterruptedIOException ex) {	break;	} catch (IOException e) {	if (Thread.interrupted()) {	break;	}	
i o error initializing connection thread 

public void halt() {	
shutting down echo server 

try {	this.interrupt();	this.serversocket.close();	while (this.isAlive() || !this.serversocket.isClosed()) {	try {	Thread.sleep(100);	} catch (InterruptedException ignored) {	}	}	} catch (IOException e) {	
error while shutting down echo server 

public void run() {	HttpContext context = new BasicHttpContext(null);	try {	while (!Thread.interrupted() && this.conn.isOpen()) {	this.httpservice.handleRequest(this.conn, context);	}	} catch (ConnectionClosedException ex) {	
client closed the connection 

public void run() {	HttpContext context = new BasicHttpContext(null);	try {	while (!Thread.interrupted() && this.conn.isOpen()) {	this.httpservice.handleRequest(this.conn, context);	}	} catch (ConnectionClosedException ex) {	} catch (IOException ex) {	
i o error 

public void run() {	HttpContext context = new BasicHttpContext(null);	try {	while (!Thread.interrupted() && this.conn.isOpen()) {	this.httpservice.handleRequest(this.conn, context);	}	} catch (ConnectionClosedException ex) {	} catch (IOException ex) {	} catch (HttpException ex) {	
unrecoverable http protocol violation 

========================= synapse sample_2293 =========================

public TimeoutHandler(Map callbacks, ServerContextInformation contextInfo) {	this.callbackStore = callbacks;	this.contextInfo = contextInfo;	this.globalTimeout = SynapseConfigUtils.getGlobalTimeoutInterval();	
this engine will expire all callbacks after seconds irrespective of the timeout action after the specified or optional timeout 

statisticsCleaner.clean();	}	SALSessions.getInstance().clearSessions();	synchronized(callbackStore) {	if (callbackStore.size() > 0) {	long currentTime = currentTime();	for (Object key : callbackStore.keySet()) {	AsyncCallback callback = (AsyncCallback) callbackStore.get(key);	if (callback == null) {	if (log.isDebugEnabled()) {	
there is no callback for key 

Stack faultStack = msgContext.getFaultStack();	for (int j = 0; j < faultStack.size(); j++) {	Object o = faultStack.pop();	if (o instanceof FaultHandler) {	((FaultHandler) o).handleFault(msgContext);	}	}	}	}	} else if (currentTime > globalTimeout + callback.getTimeOutOn()) {	
expiring message id dropping message after global timeout of seconds 

========================= synapse sample_188 =========================

private void tryNextMessage(MessageContext messageContext, NHttpClientConnection conn) {	if (conn != null) {	try {	TargetContext.get(conn).setRequestMsgCtx(messageContext);	submitRequest(conn, messageContext);	} catch (AxisFault e) {	
io error while sending the request out 

private void submitRequest(NHttpClientConnection conn, MessageContext msgContext) throws AxisFault {	if (log.isDebugEnabled()) {	
submitting new request to the connection 

========================= synapse sample_2339 =========================

public void init(ConfigurationContext configurationContext, TransportOutDescription transportOutDescription) throws AxisFault {	if (log.isDebugEnabled()) {	
initializing pass through http s sender 

proxyPort = Integer.parseInt((String) proxyPortParam.getValue());	} else if (System.getProperty("http.proxyPort") != null) {	proxyPort = Integer.parseInt(System.getProperty("http.proxyPort"));	}	Parameter bypassList = transportOutDescription.getParameter("http.nonProxyHosts");	if (bypassList != null) {	proxyBypassList = ((String) bypassList.getValue()).split("\\|");	} else if (System.getProperty("http.nonProxyHosts") != null) {	proxyBypassList = (System.getProperty("http.nonProxyHosts")).split("\\|");	}	
http sender using proxy bypassing 

configurationContext.setProperty(PassThroughConstants.PASS_THROUGH_TRANSPORT_WORKER_POOL, targetConfiguration.getWorkerPool());	PassThroughTransportMetricsCollector metrics = new PassThroughTransportMetricsCollector(false, sslContext != null);	TransportView view = new TransportView(null, this, metrics, null);	MBeanRegistrar.getInstance().registerMBean(view, "Transport", "passthru-" + namePrefix.toLowerCase() + "-sender");	targetConfiguration.setMetrics(metrics);	try {	String prefix = namePrefix + "-PT-Sender I/O Dispatcher";	ioReactor = new DefaultConnectingIOReactor( targetConfiguration.getReactorConfig(false), new NativeThreadFactory(new ThreadGroup(prefix + " Thread Group"), prefix));	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	
system may be unstable connectingioreactor encountered a checked exception 

MBeanRegistrar.getInstance().registerMBean(view, "Transport", "passthru-" + namePrefix.toLowerCase() + "-sender");	targetConfiguration.setMetrics(metrics);	try {	String prefix = namePrefix + "-PT-Sender I/O Dispatcher";	ioReactor = new DefaultConnectingIOReactor( targetConfiguration.getReactorConfig(false), new NativeThreadFactory(new ThreadGroup(prefix + " Thread Group"), prefix));	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	return true;	}	public boolean handle(RuntimeException runtimeException) {	
system may be unstable connectingioreactor encountered a runtime exception 

targetConfiguration.setConnections(targetConnections);	deliveryAgent = new DeliveryAgent(targetConfiguration, targetConnections);	connectCallback.setDeliveryAgent(deliveryAgent);	TargetHandler handler = new TargetHandler(deliveryAgent, targetConfiguration);	final IOEventDispatch ioEventDispatch = getEventDispatch(handler, sslContext, sslSetupHandler, targetConfiguration.getConnectionConfig(), transportOutDescription);	Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (Exception ex) {	
exception encountered in the sender no more connections will be initiated by this transport 

deliveryAgent = new DeliveryAgent(targetConfiguration, targetConnections);	connectCallback.setDeliveryAgent(deliveryAgent);	TargetHandler handler = new TargetHandler(deliveryAgent, targetConfiguration);	final IOEventDispatch ioEventDispatch = getEventDispatch(handler, sslContext, sslSetupHandler, targetConfiguration.getConnectionConfig(), transportOutDescription);	Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (Exception ex) {	}	
sender shutdown 

Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (Exception ex) {	}	}	}, "PassThrough" + namePrefix + "Sender");	t.start();	state = BaseConstants.STARTED;	
pass through sender started 

public void stop() {	try {	ioReactor.shutdown();	} catch (IOException e) {	
error shutting down the passthroughhttpsender 

if (forceContentLength && copyContentLength && msgContext.getProperty(PassThroughConstants.ORIGINAL_CONTENT_LENGTH) != null) {	long contentLength = Long.parseLong((String) msgContext.getProperty( PassThroughConstants.ORIGINAL_CONTENT_LENGTH));	msgContext.setProperty(PassThroughConstants.PASS_THROUGH_MESSAGE_LENGTH, contentLength);	}	if (Boolean.TRUE.equals(msgContext.getProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED))) {	synchronized (msgContext) {	while (!Boolean.TRUE.equals(msgContext.getProperty(PassThroughConstants.WAIT_BUILDER_IN_STREAM_COMPLETE)) && !Boolean.TRUE.equals(msgContext.getProperty(PassThroughConstants.PASSTHRU_CONNECT_ERROR))) {	try {	msgContext.wait();	} catch (InterruptedException e) {	
interrupted while waiting for message serialization to complete 

OMOutputFormat format = PassThroughTransportUtils.getOMOutputFormat(msgContext);	formatter.writeTo(msgContext, format, out, false);	}	pipe.setSerializationComplete(true);	out.close();	}	conn.requestOutput();	} else {	if (errorCode != null) {	if (log.isDebugEnabled()) {	
a source connection is closed because of an error in target 

}	pipe.setSerializationComplete(true);	out.close();	}	conn.requestOutput();	} else {	if (errorCode != null) {	if (log.isDebugEnabled()) {	}	} else {	
a source connection is closed because source handler is already in the process of writing a response while another response is submitted 

public void pause() throws AxisFault {	if (state != BaseConstants.STARTED) {	return;	}	state = BaseConstants.PAUSED;	
sender paused 

public void resume() throws AxisFault {	if (state != BaseConstants.PAUSED) {	return;	}	state = BaseConstants.STARTED;	
sender resumed 

public void maintenanceShutdown(long millis) throws AxisFault {	if (state != BaseConstants.STARTED) return;	try {	long start = System.currentTimeMillis();	ioReactor.shutdown(millis);	state = BaseConstants.STOPPED;	
sender shutdown in s 

========================= synapse sample_921 =========================

messageStore.poll();	final ExecutorService executor = messageContext.getEnvironment(). getExecutorService();	executor.submit(new Runnable() {	public void run() {	try {	Mediator processingSequence = messageContext.getSequence(sequence);	if (processingSequence != null) {	processingSequence.mediate(messageContext);	}	} catch (Throwable t) {	
error occurred while executing the message 

========================= synapse sample_2010 =========================

if (param != null) {	bindAddress = ((String) param.getValue()).trim();	}	param = transportIn.getParameter(TransportListener.HOST_ADDRESS);	if (param != null) {	host = ((String) param.getValue()).trim();	} else {	try {	host = InetAddress.getLocalHost().getHostName();	} catch (UnknownHostException e) {	
unable to lookup local host name using localhost 

if (defPriorityAttr != null) {	parser = new Parser(Integer.parseInt(defPriorityAttr.getAttributeValue()));	} else {	parser = new Parser();	}	try {	parser.init(conditionsElem);	} catch (EvaluatorException e) {	handleException("Invalid " + EvaluatorConstants.CONDITIONS + " configuration for priority based mediation", e);	}	
created a priority based executor from the configuration 

========================= synapse sample_2440 =========================

public Axis2HttpRequest(EndpointReference epr, HttpHost httpHost, MessageContext msgContext) {	this.epr = epr;	this.httpHost = httpHost;	this.msgContext = msgContext;	this.format = NhttpUtils.getOMOutputFormat(msgContext);	try {	messageFormatter = TransportUtils.getMessageFormatter(msgContext);	} catch (AxisFault axisFault) {	
cannot find a suitable messageformatter 

this.httpHost = httpHost;	this.msgContext = msgContext;	this.format = NhttpUtils.getOMOutputFormat(msgContext);	try {	messageFormatter = TransportUtils.getMessageFormatter(msgContext);	} catch (AxisFault axisFault) {	}	try {	this.pipe = new PipeImpl();	} catch (IOException e) {	
error creating pipe to write message body 

public ReadableByteChannel getSourceChannel() {	if (log.isDebugEnabled()) {	
get source channel of the pipe on which the outgoing response is written 

public void streamMessageContents() throws AxisFault {	if (log.isDebugEnabled()) {	
start streaming outgoing http request 

========================= synapse sample_3744 =========================

public boolean mediate(MessageContext smc) {	if (log.isDebugEnabled()) {	
rmsequence mediator mediate 

public boolean mediate(MessageContext smc) {	if (log.isDebugEnabled()) {	}	boolean shouldTrace = shouldTrace(smc.getTracingState());	if (shouldTrace) {	trace.trace("Start : RMSequence mediator");	}	if (!(smc instanceof Axis2MessageContext)) {	if (log.isDebugEnabled()) {	
rmsequence mediator only message context is supported 

if (log.isDebugEnabled()) {	}	return true;	}	Axis2MessageContext axis2MessageCtx = (Axis2MessageContext) smc;	org.apache.axis2.context.MessageContext orgMessageCtx = axis2MessageCtx.getAxis2MessageContext();	cleanupSequenceMap();	String version = getVersionValue();	orgMessageCtx.getOptions().setProperty( Constants.SANDESHA_SPEC_VERSION, version);	if (log.isDebugEnabled()) {	
using ws rm version 

if (log.isDebugEnabled()) {	}	if (isSingle()) {	String sequenceID = UUIDGenerator.getUUID();	orgMessageCtx.getOptions().setProperty( Constants.SANDESHA_SEQUENCE_KEY, sequenceID);	orgMessageCtx.getOptions().setProperty( Constants.SANDESHA_LAST_MESSAGE, "true");	return true;	}	String correlationValue = getCorrelationValue(smc);	if (log.isDebugEnabled()) {	
correlation value is 

String sequenceID = UUIDGenerator.getUUID();	orgMessageCtx.getOptions().setProperty( Constants.SANDESHA_SEQUENCE_KEY, sequenceID);	orgMessageCtx.getOptions().setProperty( Constants.SANDESHA_LAST_MESSAGE, "true");	return true;	}	String correlationValue = getCorrelationValue(smc);	if (log.isDebugEnabled()) {	}	boolean lastMessage = isLastMessage(smc);	if (log.isDebugEnabled()) {	
is this message the last message in sequence 

}	String correlationValue = getCorrelationValue(smc);	if (log.isDebugEnabled()) {	}	boolean lastMessage = isLastMessage(smc);	if (log.isDebugEnabled()) {	}	String sequenceID = retrieveSequenceID(correlationValue);	orgMessageCtx.getOptions().setProperty( Constants.SANDESHA_SEQUENCE_KEY, sequenceID);	if (log.isDebugEnabled()) {	
rmsequence mediator using sequence 

private String retrieveSequenceID(String correlationValue) {	String sequenceID = null;	if (!sequenceMap.containsKey(correlationValue)) {	sequenceID = UUIDGenerator.getUUID();	if (log.isDebugEnabled()) {	
setting sequenceid for correlation 

sequenceID = UUIDGenerator.getUUID();	if (log.isDebugEnabled()) {	}	Property sequenceProperty = new Property();	sequenceProperty.setValue(sequenceID);	sequenceProperty.setExpiryTime(System.currentTimeMillis() + SEQUENCE_EXPIRY_TIME);	sequenceMap.put(correlationValue, sequenceProperty);	} else {	sequenceID = (String) ((Property) sequenceMap.get(correlationValue)).getValue();	if (log.isDebugEnabled()) {	
got sequenceid for correlation 

private String getCorrelationValue(MessageContext smc) {	OMElement node = null;	try {	node = (OMElement) getCorrelation().selectSingleNode(smc.getEnvelope());	} catch (JaxenException e) {	
xpath error 

private String getCorrelationValue(MessageContext smc) {	OMElement node = null;	try {	node = (OMElement) getCorrelation().selectSingleNode(smc.getEnvelope());	} catch (JaxenException e) {	throw new SynapseException("XPath error : " + e.getMessage());	}	if (node == null) {	
xpath expression did not return any node 

private boolean isLastMessage(MessageContext smc) {	if (getLastMessage() == null) {	return false;	}	try {	return getLastMessage().booleanValueOf(smc.getEnvelope());	} catch (JaxenException e) {	
xpath error 

========================= synapse sample_3314 =========================

public void addProcessor(Processor p) {	
adding processor with name 

public void addProcessor(Processor p) {	
name already present 

========================= synapse sample_1329 =========================

public KeyStore getKeyStore() {	File file = new File(pkPath);	if (!file.exists()) {	if (log.isDebugEnabled()) {	
there is no private key in the given path 

public KeyStore getKeyStore() {	File file = new File(pkPath);	if (!file.exists()) {	if (log.isDebugEnabled()) {	}	return null;	}	File certFile = new File(certPath);	if (!certFile.exists()) {	if (log.isDebugEnabled()) {	
there is no certificate in the given path 

return null;	}	File certFile = new File(certPath);	if (!certFile.exists()) {	if (log.isDebugEnabled()) {	}	return null;	}	try {	if (log.isDebugEnabled()) {	
reading a private key unencrypted from given path 

handleException("IOError reading from file :  " + pkPath, e);	} finally {	try {	bufferedInputStream.close();	fileInputStream.close();	outStream.close();	} catch (IOException ignored) {	}	}	if (log.isDebugEnabled()) {	
creating a private key in using given unencrypted rsa private key 

bufferedInputStream.close();	fileInputStream.close();	outStream.close();	} catch (IOException ignored) {	}	}	if (log.isDebugEnabled()) {	}	PrivateKey key = createPrivateKey(outStream.toByteArray());	if (log.isDebugEnabled()) {	
generating a certificate form given certificate file 

PrivateKey key = createPrivateKey(outStream.toByteArray());	if (log.isDebugEnabled()) {	}	FileInputStream certInputStream = new FileInputStream(certFile);	BufferedInputStream certBufferedInputStream = new BufferedInputStream(certInputStream);	CertificateFactory certFactory = CertificateFactory.getInstance("X509");	Certificate cert = certFactory.generateCertificate(certBufferedInputStream);	certBufferedInputStream.close();	certInputStream.close();	if (log.isDebugEnabled()) {	
creating a keystore instance of type jks from a private key and certificate 

========================= synapse sample_2505 =========================

public void insert(MessageContext synContext, ArrayList<OMNode> sourceNodeList, SynapseLog synLog) throws JaxenException {	if (targetType == EnrichMediator.CUSTOM) {	assert xpath != null : "Xpath cannot be null for CUSTOM";	if (sourceNodeList.isEmpty()) {	
cannot enrich message from an empty source 

targetText.detach();	((OMElement)targetParent).addChild(sourceNodeList.get(0));	}	}	} else if (targetObj instanceof OMAttribute){	OMAttribute attribute = (OMAttribute)targetObj;	if (sourceNodeList.get(0) instanceof OMText){	attribute.setAttributeValue(((OMText)sourceNodeList.get(0)).getText());	}	} else {	
invalid target object to enrich 

SOAPEnvelope env = synContext.getEnvelope();	SOAPBody body = env.getBody();	OMElement e = body.getFirstElement();	if (e != null) {	insertElement(sourceNodeList, e, synLog);	} else {	for (OMNode elem : sourceNodeList) {	if (elem instanceof OMElement) {	body.addChild(elem);	} else {	
invalid object type to be inserted into message body 

} else {	}	}	}	} else if (targetType == EnrichMediator.ENVELOPE) {	OMNode node = sourceNodeList.get(0);	if (node instanceof SOAPEnvelope) {	try {	synContext.setEnvelope((SOAPEnvelope) node);	} catch (AxisFault axisFault) {	
failed to set the soap envelope 

}	} else if (targetType == EnrichMediator.ENVELOPE) {	OMNode node = sourceNodeList.get(0);	if (node instanceof SOAPEnvelope) {	try {	synContext.setEnvelope((SOAPEnvelope) node);	} catch (AxisFault axisFault) {	throw new SynapseException("Failed to set the SOAP Envelope");	}	} else {	
soapenvelope is expected 

========================= synapse sample_1954 =========================

public void completed(SessionRequest request) {	HostConnections pool = (HostConnections) request.getAttachment();	pool.pendingConnectionSucceeded();	if (log.isDebugEnabled()) {	if (request.getSession() != null && request.getSession().getLocalAddress() != null) {	
connected to remote address from local address 

========================= synapse sample_2381 =========================

public void testsRoutingWithoutProcessingSecurityHeaders() {	String url = "http: String policy = "./repository/conf/sample/resources/policy/client_policy_3.xml";	
running test routing the messages arrived to a proxy service without processing the security headers 

========================= synapse sample_833 =========================

public void destroy() {	if (log.isDebugEnabled()) {	
destroying class mediator instance for 

public void init(SynapseEnvironment se) {	if (log.isDebugEnabled()) {	
initializing class mediator instance for 

public void init(SynapseEnvironment se) {	if (log.isDebugEnabled()) {	}	if (mediator == null) {	
init called before mediator reference set 

========================= synapse sample_3656 =========================

this.cfgCtx = cfgCtx;	this.in = in;	this.response = response;	this.endpointURLPrefix = endpointURLPrefix;	try {	responseMsgCtx = outMsgCtx.getOperationContext(). getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);	if (responseMsgCtx != null) {	responseMsgCtx.setSoapAction("");	}	} catch (AxisFault af) {	
error getting in message context from the operation context 

try {	responseMsgCtx = outMsgCtx.getOperationContext(). getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);	if (responseMsgCtx != null) {	responseMsgCtx.setSoapAction("");	}	} catch (AxisFault af) {	return;	}	if (responseMsgCtx == null && outMsgCtx.getOperationContext().isComplete()) {	if (log.isDebugEnabled()) {	
error getting in message context from the operation context possibly an rm terminate sequence message 

responseMsgCtx.setProperty( Constants.Configuration.CHARACTER_SET_ENCODING, charSetEnc);	responseMsgCtx.setServerSide(false);	SOAPEnvelope envelope;	try {	envelope = TransportUtils.createSOAPMessage( responseMsgCtx, HTTPTransportUtils.handleGZip(responseMsgCtx, in), contentType);	} catch (OMException e) {	String errorMessage = "Unexpected response received. HTTP response code : " + this.response.getStatusLine().getStatusCode() + " HTTP status : " + this.response.getStatusLine().getReasonPhrase() + " exception : " + e.getMessage();	log.warn(errorMessage);	if (log.isDebugEnabled()) {	log.debug(errorMessage, e);	
creating the soapfault to be injected 

if (endpointURLPrefix != null) {	responseMsgCtx.setProperty(NhttpConstants.ENDPOINT_PREFIX, endpointURLPrefix);	}	try {	AxisEngine.receive(responseMsgCtx);	} catch (AxisFault af) {	String errorMessage = "Fault processing response message through Axis2: " + af.getMessage();	log.warn(errorMessage);	if (log.isDebugEnabled()) {	log.debug(errorMessage, af);	
directly invoking synapsecallbackreceiver after setting error properties 

log.debug(errorMessage, af);	}	responseMsgCtx.setProperty( NhttpConstants.SENDING_FAULT, Boolean.TRUE);	responseMsgCtx.setProperty( NhttpConstants.ERROR_CODE, NhttpConstants.RESPONSE_PROCESSING_FAILURE);	responseMsgCtx.setProperty( NhttpConstants.ERROR_MESSAGE, errorMessage.split("\n")[0]);	responseMsgCtx.setProperty( NhttpConstants.ERROR_DETAIL, JavaUtils.stackToString(af));	responseMsgCtx.setProperty( NhttpConstants.ERROR_EXCEPTION, af);	responseMsgCtx.getAxisOperation().getMessageReceiver().receive(responseMsgCtx);	}	} catch (AxisFault af) {	
fault creating response soap envelope 

}	responseMsgCtx.setProperty( NhttpConstants.SENDING_FAULT, Boolean.TRUE);	responseMsgCtx.setProperty( NhttpConstants.ERROR_CODE, NhttpConstants.RESPONSE_PROCESSING_FAILURE);	responseMsgCtx.setProperty( NhttpConstants.ERROR_MESSAGE, errorMessage.split("\n")[0]);	responseMsgCtx.setProperty( NhttpConstants.ERROR_DETAIL, JavaUtils.stackToString(af));	responseMsgCtx.setProperty( NhttpConstants.ERROR_EXCEPTION, af);	responseMsgCtx.getAxisOperation().getMessageReceiver().receive(responseMsgCtx);	}	} catch (AxisFault af) {	} catch (XMLStreamException e) {	
error creating response soap envelope 

responseMsgCtx.setProperty( NhttpConstants.SENDING_FAULT, Boolean.TRUE);	responseMsgCtx.setProperty( NhttpConstants.ERROR_CODE, NhttpConstants.RESPONSE_PROCESSING_FAILURE);	responseMsgCtx.setProperty( NhttpConstants.ERROR_MESSAGE, errorMessage.split("\n")[0]);	responseMsgCtx.setProperty( NhttpConstants.ERROR_DETAIL, JavaUtils.stackToString(af));	responseMsgCtx.setProperty( NhttpConstants.ERROR_EXCEPTION, af);	responseMsgCtx.getAxisOperation().getMessageReceiver().receive(responseMsgCtx);	}	} catch (AxisFault af) {	} catch (XMLStreamException e) {	} catch (IOException e) {	
error closing input stream from which message was read 

========================= synapse sample_2417 =========================

public synchronized ServerState start() {	assertInitialized();	ServerState serverState = ServerStateDetectionStrategy.currentState( serverContextInformation, serverConfigurationInformation);	if (serverState == ServerState.INITIALIZED || serverState == ServerState.STOPPED) {	serverContextInformation.setSynapseConfiguration( synapseController.createSynapseConfiguration());	serverContextInformation.setSynapseEnvironment( synapseController.createSynapseEnvironment());	synapseController.start();	changeState(ServerState.STARTED);	
server ready for processing 

public synchronized ServerState stopGracefully(long maxWaitMillis) {	final long startTime = System.currentTimeMillis();	final long endTime = startTime + maxWaitMillis;	final long waitIntervalMillis = 2000;	
requesting a graceful shutdown at in a maximum of seconds 

public synchronized ServerState stopGracefully(long maxWaitMillis) {	final long startTime = System.currentTimeMillis();	final long endTime = startTime + maxWaitMillis;	final long waitIntervalMillis = 2000;	startMaintenance();	if (synapseController.waitUntilSafeToStop(waitIntervalMillis, endTime)) {	
the instance could not be gracefully stopped in seconds performing an immediate stop 

public synchronized ServerState stopGracefully(long maxWaitMillis) {	final long startTime = System.currentTimeMillis();	final long endTime = startTime + maxWaitMillis;	final long waitIntervalMillis = 2000;	startMaintenance();	if (synapseController.waitUntilSafeToStop(waitIntervalMillis, endTime)) {	}	stop();	
graceful stop request completed in milliseconds 

========================= synapse sample_2047 =========================

if (clusteringAgent.getGroupManagementAgent(domain) == null) {	clusteringAgent.addGroupManagementAgent(new DefaultGroupManagementAgent(), domain);	}	}	slbMembershipHandler = new ServiceLoadBalanceMembershipHandler(hostDomainMap, getAlgorithm(), cfgCtx, isClusteringEnabled, getName());	SALSessions salSessions = SALSessions.getInstance();	if (!salSessions.isInitialized()) {	salSessions.initialize(isClusteringEnabled, cfgCtx);	}	initialized = true;	
servicedynamicloadbalanceendpoint initialized 

setCookieHeader(synCtx);	Member currentMember = null;	SessionInformation sessionInformation = null;	if (isSessionAffinityBasedLB()) {	sessionInformation = (SessionInformation) synCtx.getProperty( SynapseConstants.PROP_SAL_CURRENT_SESSION_INFORMATION);	currentMember = (Member) synCtx.getProperty( SynapseConstants.PROP_SAL_ENDPOINT_CURRENT_MEMBER);	if (sessionInformation == null && currentMember == null) {	sessionInformation = dispatcher.getSession(synCtx);	if (sessionInformation != null) {	if (log.isDebugEnabled()) {	
current session id 

public void onFault(MessageContext synCtx) {	if (currentMember == null) {	return;	}	currentMember.suspend(10000);	
suspended member for 

}	Integer errorCode = (Integer) synCtx.getProperty(SynapseConstants.ERROR_CODE);	if (errorCode != null) {	if (errorCode.equals(NhttpConstants.CONNECTION_FAILED) || errorCode.equals(NhttpConstants.CONNECT_CANCEL) || errorCode.equals(NhttpConstants.CONNECT_TIMEOUT)) {	Member newMember = slbMembershipHandler.getNextApplicationMember(host);	if (newMember == null) {	String msg = "No application members available";	log.error(msg);	throw new SynapseException(msg);	}	
failed over to 

========================= synapse sample_219 =========================

public void testCallOutSecurityWithDifferentPoliciesForInboundAndOutbound() {	
running test callout mediator security sample with different policies for inbound and outbound flows 

========================= synapse sample_825 =========================

private void registerExtensions() {	Iterator it = Service.providers(ConfigurationFactory.class);	while (it.hasNext()) {	ConfigurationFactory cf = (ConfigurationFactory) it.next();	QName tag = cf.getTagQName();	factoryMap.put(tag, cf.getClass());	serializerMap.put(tag, cf.getSerializerClass());	if (log.isDebugEnabled()) {	
added mediatorfactory to handle 

public SynapseConfiguration getConfiguration(OMElement element) {	String localName = element.getLocalName();	QName qName = null;	if (element.getNamespace() != null) {	qName = new QName(element.getNamespace().getNamespaceURI(), localName);	} else {	qName = new QName(localName);	}	if (log.isDebugEnabled()) {	
getconfiguration 

========================= synapse sample_3586 =========================

public void addChildrenAndSetName(SynapseEnvironment se, OMElement el, ListProcessor p) {	super.setNameOnProcessor(se, el, p);	Iterator it = el.getChildElements();	List processors = new LinkedList();	while (it.hasNext()) {	OMElement child = (OMElement) it.next();	Processor proc = ProcessorConfiguratorFinder.getProcessor(se, child);	if (proc != null) processors.add(proc);	
unknown child of all 

========================= synapse sample_4613 =========================

public Object call(Context context, List args) throws FunctionCallException {	if (synCtx == null) {	if (log.isDebugEnabled()) {	
synapse message context has not been set for the xpath extension function synapse get property prop name 

========================= synapse sample_1942 =========================

return;	}	targetConfiguration.getWorkerPool().execute(new Runnable() {	public void run() {	MessageReceiver mr = mc.getAxisOperation().getMessageReceiver();	try {	AxisFault axisFault = (exceptionToRaise != null ? new AxisFault(errorMessage, exceptionToRaise) : new AxisFault(errorMessage));	MessageContext faultMessageContext = MessageContextBuilder.createFaultMessageContext(mc, axisFault);	SOAPEnvelope envelope = faultMessageContext.getEnvelope();	if (log.isDebugEnabled()) {	
sending fault for request with message id 

faultMessageContext.setProperty( PassThroughConstants.ERROR_DETAIL, exceptionToRaise.toString());	faultMessageContext.setProperty( PassThroughConstants.ERROR_EXCEPTION, exceptionToRaise);	envelope.getBody().getFault().getDetail().setText( exceptionToRaise.toString());	} else {	faultMessageContext.setProperty( PassThroughConstants.ERROR_DETAIL, errorMessage);	envelope.getBody().getFault().getDetail().setText(errorMessage);	}	faultMessageContext.setProperty(PassThroughConstants.NO_ENTITY_BODY, true);	mr.receive(faultMessageContext);	} catch (AxisFault af) {	
unable to report back failure to the message receiver 

========================= synapse sample_2378 =========================

public static void convertSOAP11toSOAP12( org.apache.axis2.context.MessageContext axisOutMsgCtx) throws AxisFault {	if(log.isDebugEnabled()) {	
convert to 

OMAttribute attr = (OMAttribute) allAttributes.next();	if(attr.getNamespace() != null && SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals( attr.getNamespace().getNamespaceURI())) {	String attrName = attr.getLocalName();	if(SOAP_ATR_ACTOR.equals(attrName)) {	OMAttribute newAtr = omNode.getOMFactory().createOMAttribute( SOAP_ATR_ROLE, newEnvelope.getNamespace(), attr.getAttributeValue());	newSOAPHeader.addAttribute(newAtr);	} else if(SOAP_ATR_MUST_UNDERSTAND.equals(attrName)) {	boolean isMustUnderstand = soapHeader.getMustUnderstand();	newSOAPHeader.setMustUnderstand(isMustUnderstand);	} else {	
removed unsupported attribute from soap namespace when converting to soap 

public static void convertSOAP12toSOAP11( org.apache.axis2.context.MessageContext axisOutMsgCtx) throws AxisFault {	if (log.isDebugEnabled()) {	
convert to 

OMAttribute attr = (OMAttribute) allAttributes.next();	if(attr.getNamespace() != null && SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals( attr.getNamespace().getNamespaceURI())) {	String attrName = attr.getLocalName();	if(SOAP_ATR_ROLE.equals(attrName)) {	OMAttribute newAtr = omNode.getOMFactory().createOMAttribute( SOAP_ATR_ACTOR, newEnvelope.getNamespace(), attr.getAttributeValue());	newSOAPHeader.addAttribute(newAtr);	} else if(SOAP_ATR_MUST_UNDERSTAND.equals(attrName)) {	boolean isMustUnderstand = soapHeaderBlock.getMustUnderstand();	newSOAPHeader.setMustUnderstand(isMustUnderstand);	} else {	
removed unsupported attribute from soap namespace when converting to soap 

========================= synapse sample_3990 =========================

public void setAlgorithm(String algorithm) {	if (algorithm == null || "".equals(algorithm)) {	
given algorithm is null using a default one rsa 

========================= synapse sample_1104 =========================

public void acknowledgeMessage(MessageContext msgContext) throws AxisFault {	if (log.isDebugEnabled()) {	
acking one way request 

public void awaitResponse() throws InterruptedException, AxisFault {	if (log.isDebugEnabled()) {	
returning thread but keeping socket open awaiting response 

public void signalResponseReady() {	if (log.isDebugEnabled()) {	
signal response available 

========================= synapse sample_4306 =========================

String serviceUrl = cacheValue.serviceUrl;	OCSPReq request = cacheValue.request;	OCSPResp response= ocspVerifier.getOCSPResponse(serviceUrl, request);	if (OCSPRespStatus.SUCCESSFUL != response.getStatus()) throw new CertificateVerificationException("OCSP response status not SUCCESSFUL");	BasicOCSPResp basicResponse = (BasicOCSPResp) response.getResponseObject();	SingleResp[] responses = (basicResponse == null) ? null : basicResponse.getResponses();	if (responses == null) throw new CertificateVerificationException("Cant get OCSP response");	SingleResp resp = responses[0];	this.setCacheValue(cacheValue.serialNumber, resp, request, serviceUrl);	} catch (Exception e){	
cant replace old cachevalue with new cachevalue so remove 

public synchronized void setCacheValue(BigInteger serialNumber, SingleResp singleResp, OCSPReq request, String serviceUrl) {	OCSPCacheValue cacheValue = new OCSPCacheValue(serialNumber, singleResp, request, serviceUrl);	if (log.isDebugEnabled()) {	
before set hashmap size 

public synchronized void setCacheValue(BigInteger serialNumber, SingleResp singleResp, OCSPReq request, String serviceUrl) {	OCSPCacheValue cacheValue = new OCSPCacheValue(serialNumber, singleResp, request, serviceUrl);	if (log.isDebugEnabled()) {	}	hashMap.put(serialNumber, cacheValue);	if (log.isDebugEnabled()) {	
after set hashmap size 

public synchronized void removeCacheValue(BigInteger serialNumber) {	if (log.isDebugEnabled()) {	
before remove hashmap size 

public synchronized void removeCacheValue(BigInteger serialNumber) {	if (log.isDebugEnabled()) {	}	hashMap.remove(serialNumber);	if (log.isDebugEnabled()) {	
after remove hashmap size 

========================= synapse sample_2401 =========================

}	}	}	transformer.setErrorListener(new ErrorListener() {	public void warning(TransformerException e) throws TransformerException {	if (traceOrDebugOn) {	traceOrDebugWarn( traceOn, "Warning encountered during transformation : " + e);	}	}	public void error(TransformerException e) throws TransformerException {	
error occured in xslt transformation 

transformer.setErrorListener(new ErrorListener() {	public void warning(TransformerException e) throws TransformerException {	if (traceOrDebugOn) {	traceOrDebugWarn( traceOn, "Warning encountered during transformation : " + e);	}	}	public void error(TransformerException e) throws TransformerException {	throw e;	}	public void fatalError(TransformerException e) throws TransformerException {	
fatal error occured in the xslt transformation 

========================= synapse sample_4185 =========================

public boolean mediate(SynapseContext synCtx) {	
mediate 

========================= synapse sample_2790 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start filter mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

synLog.traceOrDebug((xpath == null ? "Source : " + source + " against : " + regex.pattern() + " does not match" : "XPath expression : "  + xpath + " evaluates to false") + " - executing the else path child mediators");	}	result = elseMediator.mediate(synCtx);	} else {	if (synLog.isTraceOrDebugEnabled()) {	synLog.traceOrDebug((xpath == null ? "Source : " + source + " against : " + regex.pattern() + " does not match" : "XPath expression : "  + xpath + " evaluates to false and no else path") + " - skipping child mediators");	}	result = true;	}	}	
end filter mediator 

if (xpath != null) {	try {	return xpath.booleanValueOf(synCtx);	} catch (JaxenException e) {	handleException("Error evaluating XPath expression : " + xpath, e, synCtx);	}	} else if (source != null && regex != null) {	String sourceString = source.stringValueOf(synCtx);	if (sourceString == null) {	if (synLog.isTraceOrDebugEnabled()) {	
source string evaluates to null 

} else if (source != null && regex != null) {	String sourceString = source.stringValueOf(synCtx);	if (sourceString == null) {	if (synLog.isTraceOrDebugEnabled()) {	}	return false;	}	Matcher matcher = regex.matcher(sourceString);	if (matcher == null) {	if (synLog.isTraceOrDebugEnabled()) {	
regex pattern matcher for against source is null 

========================= synapse sample_1915 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
localentry deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	Entry e = EntryFactory.createEntry(artifactConfig, properties);	if (e != null) {	e.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
localentry with key has been built from the file 

if (log.isDebugEnabled()) {	}	try {	Entry e = EntryFactory.createEntry(artifactConfig, properties);	if (e != null) {	e.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEntry(e.getKey(), e);	if (log.isDebugEnabled()) {	
localentry deployment from file completed 

}	try {	Entry e = EntryFactory.createEntry(artifactConfig, properties);	if (e != null) {	e.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEntry(e.getKey(), e);	if (log.isDebugEnabled()) {	}	
localentry named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
localentry update from file has started 

if (log.isDebugEnabled()) {	}	try {	Entry e = EntryFactory.createEntry(artifactConfig, properties);	if (e == null) {	handleSynapseArtifactDeploymentError("Local entry update failed. The artifact " + "defined in the file: " + fileName + " is not a valid local entry.");	return null;	}	e.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	
local entry has been built from the file 

return null;	}	e.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	if (existingArtifactName.equals(e.getKey())) {	getSynapseConfiguration().updateEntry(existingArtifactName, e);	} else {	getSynapseConfiguration().addEntry(e.getKey(), e);	getSynapseConfiguration().removeEntry(existingArtifactName);	
local entry has been undeployed 

}	e.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	if (existingArtifactName.equals(e.getKey())) {	getSynapseConfiguration().updateEntry(existingArtifactName, e);	} else {	getSynapseConfiguration().addEntry(e.getKey(), e);	getSynapseConfiguration().removeEntry(existingArtifactName);	}	
endpoint has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
localentry undeployment of the entry named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	Entry e = getSynapseConfiguration().getDefinedEntries().get(artifactName);	if (e != null && e.getType() != Entry.REMOTE_ENTRY) {	getSynapseConfiguration().removeEntry(artifactName);	if (log.isDebugEnabled()) {	
localentry undeployment of the entry named completed 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	Entry e = getSynapseConfiguration().getDefinedEntries().get(artifactName);	if (e != null && e.getType() != Entry.REMOTE_ENTRY) {	getSynapseConfiguration().removeEntry(artifactName);	if (log.isDebugEnabled()) {	}	
localentry named has been undeployed 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	Entry e = getSynapseConfiguration().getDefinedEntries().get(artifactName);	if (e != null && e.getType() != Entry.REMOTE_ENTRY) {	getSynapseConfiguration().removeEntry(artifactName);	if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
local entry has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
localentry the sequence with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	Entry e = getSynapseConfiguration().getDefinedEntries().get(artifactName);	OMElement entryElem = EntrySerializer.serializeEntry(e, null);	if (e.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.LOCAL_ENTRY_DIR + File.separator + e.getFileName();	writeToFile(entryElem, fileName);	if (log.isDebugEnabled()) {	
restoring the localentry with name completed 

if (log.isDebugEnabled()) {	}	try {	Entry e = getSynapseConfiguration().getDefinedEntries().get(artifactName);	OMElement entryElem = EntrySerializer.serializeEntry(e, null);	if (e.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.LOCAL_ENTRY_DIR + File.separator + e.getFileName();	writeToFile(entryElem, fileName);	if (log.isDebugEnabled()) {	}	
localentry named has been restored 

========================= synapse sample_171 =========================

private void verifyMediationResult(String scenario, BasicHttpClient client, StringBuilder message, int childrenCount, String sizeStr, Map<String,String> headers) throws Exception {	
testing payload size 

assertEquals(HttpStatus.SC_OK, response.getStatus());	OMElement body = response.getBodyAsXML();	assertEquals("foo", body.getLocalName());	Iterator childElements = body.getChildrenWithLocalName("bar");	int returnedChildren = 0;	while (childElements.hasNext()) {	returnedChildren++;	childElements.next();	}	assertEquals(childrenCount, returnedChildren);	
success 

========================= synapse sample_872 =========================

OMNamespace omNamespace = OMAbstractFactory.getOMFactory().createOMNamespace(WSS_WSSECURITY_SECEXT_1_0_XSD, WSSE);	SOAPHeaderBlock soapBlockingHeader = OMAbstractFactory.getSOAP12Factory().createSOAPHeaderBlock("Security",omNamespace);	OMElement securityHeader = (OMElement) element.getFirstOMChild();	if (securityHeader != null) {	while (securityHeader.getChildElements().hasNext()) {	soapBlockingHeader.addChild((OMNode) securityHeader.getChildElements().next());	}	messageContext.getEnvelope().getHeader().addChild(soapBlockingHeader);	}	} catch (Exception e) {	
error while executing the message at relaysecurity handler 

private void build(MessageContext messageContext) {	try {	RelayUtils.buildMessage(messageContext, false);	} catch (Exception e) {	
error while executing the message at relaysecurity handler 

========================= synapse sample_937 =========================

}	String axis2Xml = System.getProperty(org.apache.axis2.Constants.AXIS2_CONF);	if (axis2Xml == null) {	System.setProperty(org.apache.axis2.Constants.AXIS2_CONF, synapseHome + File.separator + "WEB-INF/conf" + File.separator + org.apache.axis2.Constants.AXIS2_CONF);	}	String synapseXml = System.getProperty(org.apache.synapse.SynapseConstants.SYNAPSE_XML);	if (synapseXml == null) {	System.setProperty(org.apache.synapse.SynapseConstants.SYNAPSE_XML, synapseHome + File.separator + "WEB-INF/conf" + File.separator + org.apache.synapse.SynapseConstants.SYNAPSE_XML);	}	} else {	
can not resolve synapse home startup failed 

========================= synapse sample_3494 =========================

public void testSessionFullLBFailOver() {	final String addUrl = "http: final StockQuoteSampleClient client = getStockQuoteClient();	
running test failover sending among endpoints 

========================= synapse sample_2285 =========================

public void setSynapseEnvironment(SynapseEnvironment se) {	if(se!=null){	
environment not null in ci 

========================= synapse sample_2905 =========================

private static Properties readManagementProperties() {	Properties managementProperties = new Properties();	String configFileName = System.getProperty("com.sun.management.config.file");	if (configFileName != null) {	FileInputStream configFile = null;	try {	configFile = new FileInputStream(configFileName);	managementProperties.load(configFile);	if (log.isDebugEnabled()) {	
initialized management properties from file 

Properties managementProperties = new Properties();	String configFileName = System.getProperty("com.sun.management.config.file");	if (configFileName != null) {	FileInputStream configFile = null;	try {	configFile = new FileInputStream(configFileName);	managementProperties.load(configFile);	if (log.isDebugEnabled()) {	}	} catch (FileNotFoundException ex) {	
cannot open 

String configFileName = System.getProperty("com.sun.management.config.file");	if (configFileName != null) {	FileInputStream configFile = null;	try {	configFile = new FileInputStream(configFileName);	managementProperties.load(configFile);	if (log.isDebugEnabled()) {	}	} catch (FileNotFoundException ex) {	} catch (IOException ex) {	
error while reading 

========================= synapse sample_2143 =========================

public boolean mediate(MessageContext synCtx) {	
switch mediator mediate 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	if (shouldTrace) {	trace.trace("Start : Switch mediator");	}	String sourceText = Axis2MessageContext.getStringValue(source, synCtx);	
applying switch case regex patterns against evaluated source value 

if (shouldTrace) {	trace.trace("Executing case for : " + swCase.getRegex());	}	return swCase.mediate(synCtx);	}	}	if (shouldTrace) {	trace.trace("End Case mediator lis");	}	if (defaultCase != null) {	
executing default case 

========================= synapse sample_3302 =========================

public BackportWorkerPool(int core, int max, int keepAlive, int queueLength, String threadGroupName, String threadGroupId) {	if (log.isDebugEnabled()) {	
using backport of the util concurrent package 

========================= synapse sample_3752 =========================

private void registerExtensions() {	Iterator it = Service.providers(ConfigurationFactory.class);	while (it.hasNext()) {	ConfigurationFactory cf = (ConfigurationFactory) it.next();	QName tag = cf.getTagQName();	factoryMap.put(tag, cf.getClass());	serializerMap.put(tag, cf.getSerializerClass());	if (log.isDebugEnabled()) {	
added mediatorfactory to handle 

public SynapseConfiguration getConfiguration(OMElement element) {	String localName = element.getLocalName();	QName qName = null;	if (element.getNamespace() != null) {	qName = new QName(element.getNamespace().getNamespaceURI(), localName);	} else {	qName = new QName(localName);	}	if (log.isDebugEnabled()) {	
getconfiguration 

========================= synapse sample_4097 =========================

public ClientWorker(ConfigurationContext cfgCtx, InputStream in, MessageContext outMsgCtx) {	this.cfgCtx = cfgCtx;	this.in = in;	this.outMsgCtx = outMsgCtx;	try {	responseMsgCtx = outMsgCtx.getOperationContext(). getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);	} catch (AxisFault af) {	
error getting in message context from the operation context 

public ClientWorker(ConfigurationContext cfgCtx, InputStream in, MessageContext outMsgCtx) {	this.cfgCtx = cfgCtx;	this.in = in;	this.outMsgCtx = outMsgCtx;	try {	responseMsgCtx = outMsgCtx.getOperationContext(). getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);	} catch (AxisFault af) {	return;	}	if (responseMsgCtx == null) {	
error getting in message context from the operation context 

public void run() {	SOAPEnvelope envelope = null;	try {	envelope = TransportUtils.createSOAPMessage( responseMsgCtx, in, outMsgCtx.getEnvelope().getNamespace().getNamespaceURI());	responseMsgCtx.setEnvelope(envelope);	} catch (AxisFault af) {	
fault creating response soap envelope 

public void run() {	SOAPEnvelope envelope = null;	try {	envelope = TransportUtils.createSOAPMessage( responseMsgCtx, in, outMsgCtx.getEnvelope().getNamespace().getNamespaceURI());	responseMsgCtx.setEnvelope(envelope);	} catch (AxisFault af) {	return;	} catch (IOException e) {	
error closing input stream from which message was read 

} catch (IOException e) {	}	AxisEngine engine = new AxisEngine(cfgCtx);	try {	if (envelope.getBody().hasFault()) {	engine.receiveFault(responseMsgCtx);	} else {	engine.receive(responseMsgCtx);	}	} catch (AxisFault af) {	
fault processing response message through 

========================= synapse sample_3403 =========================

public SampleClientResult sendUsingMTOM(String fileName, String targetEPR) {	clientResult = new SampleClientResult();	try {	OMFactory factory = OMAbstractFactory.getOMFactory();	OMNamespace ns = factory.createOMNamespace("http: payload = factory.createOMElement("uploadFileUsingMTOM", ns);	OMElement request = factory.createOMElement("request", ns);	OMElement image = factory.createOMElement("image", ns);	
sending file as mtom 

serviceClient = new ServiceClient(configContext, null);	Options options = new Options();	options.setTo(new EndpointReference(targetEPR));	options.setAction("urn:uploadFileUsingMTOM");	options.setProperty(Constants.Configuration.ENABLE_MTOM, Constants.VALUE_TRUE);	serviceClient.setOptions(options);	OMElement response = serviceClient.sendReceive(payload);	OMText binaryNode = (OMText) response. getFirstChildWithName(new QName("http: getFirstChildWithName(new QName("http: getFirstOMChild();	dataHandler = (DataHandler) binaryNode.getDataHandler();	InputStream is = dataHandler.getInputStream();	
temp dir java io tmpdir 

File tempFile = File.createTempFile("mtom-", ".gif");	FileOutputStream fos = new FileOutputStream(tempFile);	BufferedOutputStream dest = new BufferedOutputStream(fos, 2048);	byte data[] = new byte[2048];	int count;	while ((count = is.read(data, 0, 2048)) != -1) {	dest.write(data, 0, count);	}	dest.flush();	dest.close();	
saved response to file 

BufferedOutputStream dest = new BufferedOutputStream(fos, 2048);	byte data[] = new byte[2048];	int count;	while ((count = is.read(data, 0, 2048)) != -1) {	dest.write(data, 0, count);	}	dest.flush();	dest.close();	clientResult.incrementResponseCount();	} catch (Exception e) {	
error invoking service 

try {	Options options = new Options();	options.setTo(new EndpointReference(targetEPR));	options.setAction("urn:uploadFileUsingSwA");	options.setProperty(Constants.Configuration.ENABLE_SWA, Constants.VALUE_TRUE);	ConfigurationContext configContext = ConfigurationContextFactory. createConfigurationContextFromFileSystem(configuration.getClientRepo(), configuration.getAxis2Xml());	ServiceClient sender = new ServiceClient(configContext, null);	sender.setOptions(options);	OperationClient mepClient = sender.createClient(ServiceClient.ANON_OUT_IN_OP);	MessageContext mc = new MessageContext();	
sending file as swa 

MessageContext response = mepClient.getMessageContext(WSDLConstants.MESSAGE_LABEL_IN_VALUE);	SOAPBody body = response.getEnvelope().getBody();	String imageContentId = body. getFirstChildWithName(new QName("http: getFirstChildWithName(new QName("http: getFirstChildWithName(new QName("http: getText();	Attachments attachment = response.getAttachmentMap();	dataHandler = attachment.getDataHandler(imageContentId);	File tempFile = File.createTempFile("swa-", ".gif");	FileOutputStream fos = new FileOutputStream(tempFile);	dataHandler.writeTo(fos);	fos.flush();	fos.close();	
saved response to file 

String imageContentId = body. getFirstChildWithName(new QName("http: getFirstChildWithName(new QName("http: getFirstChildWithName(new QName("http: getText();	Attachments attachment = response.getAttachmentMap();	dataHandler = attachment.getDataHandler(imageContentId);	File tempFile = File.createTempFile("swa-", ".gif");	FileOutputStream fos = new FileOutputStream(tempFile);	dataHandler.writeTo(fos);	fos.flush();	fos.close();	clientResult.incrementResponseCount();	} catch (Exception e) {	
error invoking service 

========================= synapse sample_2212 =========================

public void init(SynapseEnvironment synapseEnvironment) {	if (messageQueue.isPersistent()) {	
loading the persisted messages if there are any to the message queue 

public void init(SynapseEnvironment synapseEnvironment) {	if (messageQueue.isPersistent()) {	messageQueue.load();	}	Timer samplingTimer = synapseEnvironment.getSynapseConfiguration().getSynapseTimer();	messageProcessor = new MessageProcessor();	
scheduling the sampling timer to invoke the message processor at an interval of 

public void destroy() {	messageProcessor.cancel();	if (!messageQueue.isEmpty()) {	
there are messages on the sampling message queue but the message processor has been destroyed 

public void destroy() {	messageProcessor.cancel();	if (!messageQueue.isEmpty()) {	if (messageQueue.isPersistent()) {	if (log.isDebugEnabled()) {	
persisting the messages on the message queue 

public void destroy() {	messageProcessor.cancel();	if (!messageQueue.isEmpty()) {	if (messageQueue.isPersistent()) {	if (log.isDebugEnabled()) {	}	if (messageQueue.persist()) {	
completed persisting the messages on the message queue 

public void destroy() {	messageProcessor.cancel();	if (!messageQueue.isEmpty()) {	if (messageQueue.isPersistent()) {	if (log.isDebugEnabled()) {	}	if (messageQueue.persist()) {	} else {	
couldn t persist the messages on the message queue 

public void destroy() {	messageProcessor.cancel();	if (!messageQueue.isEmpty()) {	if (messageQueue.isPersistent()) {	if (log.isDebugEnabled()) {	}	if (messageQueue.persist()) {	} else {	}	} else {	
you are not using a persistent message queue you will be loosing messages which are on the queue 

public boolean mediate(MessageContext messageContext) {	SynapseLog synLog = getLog(messageContext);	
start sampler mediator 

public boolean mediate(MessageContext messageContext) {	SynapseLog synLog = getLog(messageContext);	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext messageContext) {	SynapseLog synLog = getLog(messageContext);	if (synLog.isTraceTraceEnabled()) {	}	if (!messageContext.isResponse()) {	if (synLog.isTraceOrDebugEnabled()) {	
adding the message with message id into the message queue for sampling 

if (synLog.isTraceOrDebugEnabled()) {	}	messageQueue.add(messageContext);	} else {	synLog.auditWarn("Encountered a response message which will not be sampled");	}	OperationContext opCtx = ((Axis2MessageContext) messageContext).getAxis2MessageContext().getOperationContext();	if (opCtx != null) {	opCtx.setProperty(Constants.RESPONSE_WRITTEN, "SKIP");	}	
end sampler mediator 

public void run() {	if (log.isDebugEnabled()) {	
started running the message processor 

public void run() {	if (log.isDebugEnabled()) {	}	for (int i = 0; i < samplingRate && !messageQueue.isEmpty(); i++) {	MessageContext synCtx = messageQueue.get();	if (log.isDebugEnabled()) {	
mediating the message on the message queue with message id 

public void run() {	if (log.isDebugEnabled()) {	}	for (int i = 0; i < samplingRate && !messageQueue.isEmpty(); i++) {	MessageContext synCtx = messageQueue.get();	if (log.isDebugEnabled()) {	}	target.mediate(synCtx);	}	if (log.isDebugEnabled()) {	
message processing completed for the given sampling rate 

========================= synapse sample_559 =========================

public void init(ConfigurationContext cfgCtx, TransportOutDescription transportOut) throws AxisFault {	super.init(cfgCtx, transportOut);	this.sessionFactory = FIXSessionFactory.getInstance(new FIXApplicationFactory(cfgCtx));	this.workerPool = WorkerPoolFactory.getWorkerPool( 10, 20, 5, -1, "FIX Sender Worker thread group", "FIX-Worker");	this.sessionFactory.setSenderThreadPool(this.workerPool);	messageSender = new FIXOutgoingMessageHandler();	messageSender.setSessionFactory(this.sessionFactory);	
fix transport sender initialized 

public void stop() {	try {	this.workerPool.shutdown(10000);	} catch (InterruptedException e) {	
thread interrupted while waiting for worker pool to shut down 

public void sendMessage(MessageContext msgCtx, String targetEPR, OutTransportInfo outTransportInfo) throws AxisFault {	if (log.isDebugEnabled()) {	
attempting to send a fix message message id 

setDeliverToXFields(fixMessage, targetEPR);	}	}	if (!Session.doesSessionExist(sessionID)) {	sessionFactory.createFIXInitiator(targetEPR, service, sessionID);	}	try {	messageSender.sendMessage(fixMessage, sessionID, srcSession, counter, msgCtx, targetEPR);	return true;	} catch (SessionNotFound e) {	
error while sending the fix message session does not exist 

prepareToForwardMessage(fixMessage, fieldValues);	setDeliverToXFields(fixMessage, service);	}	} else {	setDeliverToXFields(fixMessage, fieldValues);	}	try {	messageSender.sendMessage(fixMessage, sessionID, srcSession, counter, msgCtx, null);	return true;	} catch (SessionNotFound e) {	
error while sending the fix message session does not exist 

========================= synapse sample_1081 =========================

public static NHttpClientConnection getConnection(String host, int port) {	String key = host + ":" + Integer.toString(port);	List connections = (List) connMap.get(key);	if (connections == null || connections.isEmpty()) {	if (log.isDebugEnabled()) {	
no connections available for reuse 

if (log.isDebugEnabled()) {	}	return null;	} else {	NHttpClientConnection conn = null;	synchronized (connections) {	while (!connections.isEmpty()) {	conn = (NHttpClientConnection) connections.remove(0);	if (conn.isOpen()) {	if (log.isDebugEnabled()) {	
a connection to host on port is available in the pool and will be reused 

NHttpClientConnection conn = null;	synchronized (connections) {	while (!connections.isEmpty()) {	conn = (NHttpClientConnection) connections.remove(0);	if (conn.isOpen()) {	if (log.isDebugEnabled()) {	}	return conn;	} else {	if (log.isDebugEnabled()) {	
closing stale connection to 

synchronized(connMap) {	connections = (List) connMap.get(key);	if (connections == null) {	connections = Collections.synchronizedList(new LinkedList());	connMap.put(key, connections);	}	}	}	connections.add(conn);	if (log.isDebugEnabled()) {	
released a connection to host on port to the connection pool of current size 

========================= synapse sample_4283 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start spring mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

} else {	if (appContext == null) {	buildAppContext(synCtx, synLog);	}	}	if (appContext != null) {	Object o = appContext.getBean(beanName);	if (o != null && Mediator.class.isAssignableFrom(o.getClass())) {	Mediator m = (Mediator) o;	if (synLog.isTraceOrDebugEnabled()) {	
loaded mediator from bean executing 

}	if (appContext != null) {	Object o = appContext.getBean(beanName);	if (o != null && Mediator.class.isAssignableFrom(o.getClass())) {	Mediator m = (Mediator) o;	if (synLog.isTraceOrDebugEnabled()) {	}	return m.mediate(synCtx);	} else {	if (synLog.isTraceOrDebugEnabled()) {	
unable to load mediator from bean 

}	return m.mediate(synCtx);	} else {	if (synLog.isTraceOrDebugEnabled()) {	}	handleException("Could not load bean named : " + beanName + " from the Spring configuration with key : " + configKey, synCtx);	}	} else {	handleException("Cannot reference application context with key : " + configKey, synCtx);	}	
end spring mediator 

private synchronized void buildAppContext(MessageContext synCtx, SynapseLog synLog) {	if (synLog.isTraceOrDebugEnabled()) {	
creating spring applicationcontext from key 

xbdr.setValidating(false);	Object springConfig = synCtx.getEntry(configKey);	if(springConfig == null) {	String errorMessage = "Cannot look up Spring configuration " + configKey;	log.error(errorMessage);	throw new SynapseException(errorMessage);	}	xbdr.loadBeanDefinitions( new InputStreamResource( SynapseConfigUtils.getStreamSource(springConfig).getInputStream()));	appContext.refresh();	if (synLog.isTraceOrDebugEnabled()) {	
spring applicationcontext from key created 

========================= synapse sample_2584 =========================

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	
shutting down simpleaxisserver 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	stopServer();	
shutdown complete 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	stopServer();	
halting jvm 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	stopServer();	} catch (Exception e) {	
error occurred while shutting down simpleaxisserver 

========================= synapse sample_4450 =========================

lookup.put(((ProcessorConfigurator) c.newInstance()) .getTagQName(), c);	} catch (Exception e) {	throw new SynapseException(e);	}	}	Iterator it = Service.providers(ProcessorConfigurator.class);	while (it.hasNext()) {	ProcessorConfigurator p = (ProcessorConfigurator) it.next();	QName tag = p.getTagQName();	lookup.put(tag, p.getClass());	
added processor to handle 

========================= synapse sample_1347 =========================

public static void setStaticProperty(OMElement property, Object o) {	if (property.getLocalName().toLowerCase().equals("property")) {	String propertyName = property.getAttributeValue(new QName("name"));	String mName = "set" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1);	if (property.getAttributeValue(new QName("value")) != null) {	String value = property.getAttributeValue(new QName("value"));	try {	Method method = o.getClass().getMethod(mName, new Class[]{String.class});	if (log.isDebugEnabled()) {	
setting property invoking method 

method.invoke(o, new Object[]{value});	} catch (Exception e) {	handleException("Error setting property : " + propertyName + " as a String property into class mediator : " + o.getClass() + " : " + e.getMessage(), e);	}	} else {	OMElement value = property.getFirstElement();	if (value != null) {	try {	Method method = o.getClass().getMethod(mName, new Class[]{OMElement.class});	if (log.isDebugEnabled()) {	
setting property invoking method 

========================= synapse sample_4145 =========================

if (nameAtt != null) {	messageStore.setName(nameAtt.getAttributeValue());	} else {	handleException("Message Store name not specified");	}	OMElement descriptionElem = elem.getFirstChildWithName(DESCRIPTION_Q);	if (descriptionElem != null) {	messageStore.setDescription(descriptionElem.getText());	}	messageStore.setParameters(getParameters(elem));	
successfully created message store 

========================= synapse sample_1890 =========================

public void testCallOutSecurityWithDifferentPoliciesForInboundAndOutbound() {	
running test callout mediator security sample with different policies for inbound and outbound flows 

========================= synapse sample_2245 =========================

public void deploy(DeploymentFileData deploymentFileData) throws DeploymentException {	String libFilePath = FilenameUtils.normalize(deploymentFileData.getAbsolutePath());	if (log.isDebugEnabled()) {	
deployment of the synapse library artifact from file started 

public void deploy(DeploymentFileData deploymentFileData) throws DeploymentException {	String libFilePath = FilenameUtils.normalize(deploymentFileData.getAbsolutePath());	if (log.isDebugEnabled()) {	}	if (getServerContextInformation().getServerState() != ServerState.STARTED) {	if (log.isDebugEnabled()) {	
skipped the library artifact deployment since the synapse server doesn t seem to be started yet from file 

if (getServerContextInformation().getServerState() != ServerState.STARTED) {	if (log.isDebugEnabled()) {	}	return;	}	try {	SynapseArtifactDeploymentStore deploymentStore = getSynapseConfiguration().getArtifactDeploymentStore();	Library lib = LibDeployerUtils.createSynapseLibrary(libFilePath);	String libArtifactName = lib.getQName().toString();	if (log.isDebugEnabled()) {	
created the synapse library from 

return;	}	try {	SynapseArtifactDeploymentStore deploymentStore = getSynapseConfiguration().getArtifactDeploymentStore();	Library lib = LibDeployerUtils.createSynapseLibrary(libFilePath);	String libArtifactName = lib.getQName().toString();	if (log.isDebugEnabled()) {	}	if (deploymentStore.isUpdatingArtifact(libFilePath)) {	if (log.isDebugEnabled()) {	
updating library artifact detected with filename 

if (log.isDebugEnabled()) {	}	String existingArtifactName = deploymentStore.getUpdatingArtifactWithFileName(libFilePath);	deploymentStore.removeUpdatingArtifact(libFilePath);	undeploySynapseArtifact(existingArtifactName);	completeDeployment(lib, libArtifactName);	} else {	try {	completeDeployment(lib, libArtifactName);	} catch (SynapseArtifactDeploymentException sade) {	
deployment of the synapse artifact from file failed 

completeDeployment(lib, libArtifactName);	} else {	try {	completeDeployment(lib, libArtifactName);	} catch (SynapseArtifactDeploymentException sade) {	+ backupFile(deploymentFileData.getFile()));*/ }	}	if (libArtifactName != null) {	deploymentStore.addArtifact(libFilePath, libArtifactName);	}	
synapse library named has been deployed from file 

}	if (libArtifactName != null) {	deploymentStore.addArtifact(libFilePath, libArtifactName);	}	} catch (IOException ex) {	handleDeploymentError("Deployment of synapse artifact failed. Error reading " + libFilePath + " : " + ex.getMessage(), ex);	} catch (Exception ex) {	handleDeploymentError("Deployment of synapse artifact failed for synapse libray at : " + libFilePath + " : " + ex.getMessage(), ex);	}	if (log.isDebugEnabled()) {	
deployment of the synapse artifact from file completed 

private void completeDeployment(Library lib, String libArtifactName) throws DeploymentException {	getSynapseConfiguration().addSynapseLibrary(lib.getQName().toString(), lib);	if (log.isDebugEnabled()) {	
synapse library deployment for lib completed 

private void completeDeployment(Library lib, String libArtifactName) throws DeploymentException {	getSynapseConfiguration().addSynapseLibrary(lib.getQName().toString(), lib);	if (log.isDebugEnabled()) {	}	SynapseImport synImport = getSynapseConfiguration().getSynapseImports().get(libArtifactName);	if (synImport != null) {	LibDeployerUtils.loadLibArtifacts(synImport, lib);	if (log.isDebugEnabled()) {	
loading synapse library into memory for import 

public void undeploy(String fileName) throws DeploymentException {	fileName = FilenameUtils.normalize(fileName);	if (log.isDebugEnabled()) {	
undeployment of the synapse library from file started 

public void undeploy(String fileName) throws DeploymentException {	fileName = FilenameUtils.normalize(fileName);	if (log.isDebugEnabled()) {	}	SynapseArtifactDeploymentStore deploymentStore = getSynapseConfiguration().getArtifactDeploymentStore();	if (deploymentStore.containsFileName(fileName)) {	File undeployingFile = new File(fileName);	if (undeployingFile.exists()) {	if (log.isDebugEnabled()) {	
marking artifact as updating from file 

}	if (!deploymentStore.isRestoredFile(fileName)) {	deploymentStore.addUpdatingArtifact( fileName, deploymentStore.getArtifactNameForFile(fileName));	deploymentStore.removeArtifactWithFileName(fileName);	}	} else {	String artifactName = deploymentStore.getArtifactNameForFile(fileName);	try {	undeploySynapseArtifact(artifactName);	deploymentStore.removeArtifactWithFileName(fileName);	
synapse library named has been undeployed 

if (!deploymentStore.isRestoredFile(fileName)) {	deploymentStore.addUpdatingArtifact( fileName, deploymentStore.getArtifactNameForFile(fileName));	deploymentStore.removeArtifactWithFileName(fileName);	}	} else {	String artifactName = deploymentStore.getArtifactNameForFile(fileName);	try {	undeploySynapseArtifact(artifactName);	deploymentStore.removeArtifactWithFileName(fileName);	} catch (SynapseArtifactDeploymentException sade) {	
unable to undeploy the synapse library artifact from file 

deploymentStore.removeArtifactWithFileName(fileName);	} catch (SynapseArtifactDeploymentException sade) {	}	}	} else {	String msg = "Artifact representing the filename " + fileName + " is not deployed on Synapse";	log.error(msg);	throw new DeploymentException(msg);	}	if (log.isDebugEnabled()) {	
undeployment of the synapse library artifact from file completed 

========================= synapse sample_1605 =========================

public void schedulePoll(AxisService service, long pollInterval) {	pollInterval *= 1000;	TimerTask task = (TimerTask) serviceToTimerTaskMap.get(service);	if (task != null) {	task.cancel();	}	task = new TimerTask() {	public void run() {	if (pollInProgress) {	if (log.isDebugEnabled()) {	
transport onpoll trigger already executing poll 

public void onPoll() {}	protected void startListeningForService(AxisService service) {	Parameter param = service.getParameter(TRANSPORT_POLL_INTERVAL);	long pollInterval = DEFAULT_POLL_INTERVAL;	if (param != null && param.getValue() instanceof String) {	try {	pollInterval = Integer.parseInt(param.getValue().toString());	} catch (NumberFormatException e) {	
invalid poll interval for service using defaults 

========================= synapse sample_3792 =========================

if (addr != null) {	ipAddress = addr.getHostAddress();	if (ipAddress != null) {	}	hostName = addr.getHostName();	if (hostName == null) {	hostName = ipAddress;	}	}	} catch (UnknownHostException e) {	
unable to get the hostname or ip address of the server 

========================= synapse sample_2029 =========================

public InputSource resolve(SynapseConfiguration synCfg, String location) {	String key = resources.get(location);	if (key == null) {	if (log.isDebugEnabled()) {	
no resource mapping is defined for location 

public InputSource resolve(SynapseConfiguration synCfg, String location) {	String key = resources.get(location);	if (key == null) {	if (log.isDebugEnabled()) {	}	return null;	} else {	if (log.isDebugEnabled()) {	
resolving location to registry item 

========================= synapse sample_298 =========================

public synchronized ServerState start() {	assertInitialized();	ServerState serverState = ServerStateDetectionStrategy.currentState( serverContextInformation, serverConfigurationInformation);	if (serverState == ServerState.INITIALIZED || serverState == ServerState.STOPPED) {	serverContextInformation.setSynapseConfiguration( synapseController.createSynapseConfiguration());	serverContextInformation.setSynapseEnvironment( synapseController.createSynapseEnvironment());	synapseController.start();	changeState(ServerState.STARTED);	
server ready for processing 

public synchronized ServerState stopGracefully(long maxWaitMillis) {	final long startTime = System.currentTimeMillis();	final long endTime = startTime + maxWaitMillis;	final long waitIntervalMillis = 2000;	
requesting a graceful shutdown at in a maximum of seconds 

public synchronized ServerState stopGracefully(long maxWaitMillis) {	final long startTime = System.currentTimeMillis();	final long endTime = startTime + maxWaitMillis;	final long waitIntervalMillis = 2000;	startMaintenance();	if (synapseController.waitUntilSafeToStop(waitIntervalMillis, endTime)) {	
the instance could not be gracefully stopped in seconds performing an immediate stop 

public synchronized ServerState stopGracefully(long maxWaitMillis) {	final long startTime = System.currentTimeMillis();	final long endTime = startTime + maxWaitMillis;	final long waitIntervalMillis = 2000;	startMaintenance();	if (synapseController.waitUntilSafeToStop(waitIntervalMillis, endTime)) {	}	stop();	
graceful stop request completed in milliseconds 

========================= synapse sample_627 =========================

public void testTransportAndFormatSwitching() {	String url2 = "https: String trustStore = FilenameUtils.normalize(System.getProperty("user.dir") + "/modules/integration/src/test/resources/trust.jks");	System.setProperty("javax.net.ssl.trustStore", trustStore);	StockQuoteSampleClient client = getStockQuoteClient();	
running test switching transports and message format from soap to rest pox 

========================= synapse sample_2253 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
message processor deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try{	MessageProcessor mp = MessageProcessorFactory.createMessageProcessor(artifactConfig);	if(mp != null) {	mp.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
message processor named has been built from the file 

if(mp != null) {	mp.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	if(getSynapseConfiguration().getMessageStore(mp.getMessageStoreName()) != null) {	mp.init(getSynapseEnvironment());	} else {	handleSynapseArtifactDeploymentError("Message Processor Deployment from the file :" + fileName + " : Failed. Can not create a Message processor without a Message Store");	}	if (log.isDebugEnabled()) {	
initialized the message processor 

}	if(getSynapseConfiguration().getMessageStore(mp.getMessageStoreName()) != null) {	mp.init(getSynapseEnvironment());	} else {	handleSynapseArtifactDeploymentError("Message Processor Deployment from the file :" + fileName + " : Failed. Can not create a Message processor without a Message Store");	}	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addMessageProcessor(mp.getName(), mp);	if (log.isDebugEnabled()) {	
message processor deployment from file completed 

if(getSynapseConfiguration().getMessageStore(mp.getMessageStoreName()) != null) {	mp.init(getSynapseEnvironment());	} else {	handleSynapseArtifactDeploymentError("Message Processor Deployment from the file :" + fileName + " : Failed. Can not create a Message processor without a Message Store");	}	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addMessageProcessor(mp.getName(), mp);	if (log.isDebugEnabled()) {	}	
message processor named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
message processor update from file has started 

if (log.isDebugEnabled()) {	}	try {	MessageProcessor mp = MessageProcessorFactory.createMessageProcessor(artifactConfig);	if (mp == null) {	handleSynapseArtifactDeploymentError("Message Processor update failed. The artifact " + "defined in the file: " + fileName + " is not valid");	return null;	}	mp.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	
messageprocessor has been built from the file 

return null;	}	mp.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	MessageProcessor existingMp = getSynapseConfiguration().getMessageProcessors(). get(existingArtifactName);	existingMp.destroy();	mp.init(getSynapseEnvironment());	getSynapseConfiguration().addMessageProcessor(mp.getName(), mp);	getSynapseConfiguration().removeMessageStore(existingArtifactName);	
messageprocessor has been undeployed 

return null;	}	mp.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	MessageProcessor existingMp = getSynapseConfiguration().getMessageProcessors(). get(existingArtifactName);	existingMp.destroy();	mp.init(getSynapseEnvironment());	getSynapseConfiguration().addMessageProcessor(mp.getName(), mp);	getSynapseConfiguration().removeMessageStore(existingArtifactName);	
messageprocessor has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
messageprocessor undeployment of the messageprocessor named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	MessageProcessor mp = getSynapseConfiguration().getMessageProcessors().get(artifactName);	if (mp != null) {	getSynapseConfiguration().removeMessageProcessor(artifactName);	if (log.isDebugEnabled()) {	
destroying the messageprocessor named 

if (log.isDebugEnabled()) {	}	try {	MessageProcessor mp = getSynapseConfiguration().getMessageProcessors().get(artifactName);	if (mp != null) {	getSynapseConfiguration().removeMessageProcessor(artifactName);	if (log.isDebugEnabled()) {	}	mp.destroy();	if (log.isDebugEnabled()) {	
messageprocessor undeployment of the endpoint named completed 

}	try {	MessageProcessor mp = getSynapseConfiguration().getMessageProcessors().get(artifactName);	if (mp != null) {	getSynapseConfiguration().removeMessageProcessor(artifactName);	if (log.isDebugEnabled()) {	}	mp.destroy();	if (log.isDebugEnabled()) {	}	
messageprocessor named has been undeployed 

try {	MessageProcessor mp = getSynapseConfiguration().getMessageProcessors().get(artifactName);	if (mp != null) {	getSynapseConfiguration().removeMessageProcessor(artifactName);	if (log.isDebugEnabled()) {	}	mp.destroy();	if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
messageprocessor has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the messageprocessor with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	MessageProcessor mp = getSynapseConfiguration().getMessageProcessors().get(artifactName);	OMElement msElem = MessageProcessorSerializer.serializeMessageProcessor(null,mp);	if (mp.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.MESSAGE_PROCESSOR_DIR + File.separator + mp.getFileName();	writeToFile(msElem, fileName);	if (log.isDebugEnabled()) {	
restoring the messageprocessor with name completed 

if (log.isDebugEnabled()) {	}	try {	MessageProcessor mp = getSynapseConfiguration().getMessageProcessors().get(artifactName);	OMElement msElem = MessageProcessorSerializer.serializeMessageProcessor(null,mp);	if (mp.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.MESSAGE_PROCESSOR_DIR + File.separator + mp.getFileName();	writeToFile(msElem, fileName);	if (log.isDebugEnabled()) {	}	
messageprocessor named has been restored 

========================= synapse sample_1613 =========================

public void init() {	if (log.isDebugEnabled()) {	
initializing beanstalk 

public void init() {	if (log.isDebugEnabled()) {	}	try {	initialCtx = new InitialContext(props);	} catch (NamingException e) {	
could not initialize jndi context for the enterprise beanstalk named 

}	}	int minDelay = Math.min(statelessBeanTimeoutMinutes, statefulBeanTimeoutMinutes);	scheduledFuture = scheduler.scheduleWithFixedDelay( new Runnable() {	public void run() {	removeExpiredBeans();	}	}, minDelay, minDelay, TimeUnit.MINUTES);	MBeanRegistrar.getInstance().registerMBean(new EnterpriseBeanstalkView(this), EnterpriseBeanstalkConstants.ENTERPRISE_BEANSTALK_MBEAN_CATEGORY_NAME, name);	if (log.isDebugEnabled()) {	
successfully initialized beanstalk 

if (entry == null && jndiName != null) {	synchronized (this) {	entry = map.get(getMapKey(className, sessionId));	if (entry == null) {	Object ejb = lookupInJndi(jndiName);	if (ejb != null) {	map.put(getMapKey(className, sessionId), entry = new CacheEntry(ejb));	int size = map.size();	if (size > warnLimit) {	String type = sessionId == null ? "stateless" : "stateful";	
warn limit reached for beans currently there are ejb stubs cached in beanstalk 

private Object lookupInJndi(String jndiName) {	try {	return initialCtx.lookup(jndiName);	} catch (NamingException ex) {	
lookup failed for jndi name 

private void removeExpiredBeansFromMap(Map<String, CacheEntry> map, int timeoutInMinutes) {	Iterator<Map.Entry<String, CacheEntry>> itr = map.entrySet().iterator();	while (itr.hasNext()) {	Map.Entry<String, CacheEntry> mapEntry = itr.next();	if (System.currentTimeMillis() - mapEntry.getValue().getLastAccessTime() > timeoutInMinutes * 60L * 1000L) {	if (log.isDebugEnabled()) {	
removing the timed out ejb stub with key from beanstalk cache 

========================= synapse sample_2204 =========================

public boolean createFIXAcceptor(AxisService service) throws AxisFault {	InputStream fixConfigStream = getFIXConfigAsStream(service, true);	if (fixConfigStream != null) {	try {	if (log.isDebugEnabled()) {	
initializing a new fix session for the service 

public void createFIXInitiator(String fixEPR, AxisService service, SessionID sessionID) throws AxisFault {	if (log.isDebugEnabled()) {	
initializing a new fix initiator for the service 

if (threadedConnector) {	initiator = new ThreadedSocketInitiator( messageHandler, storeFactory, settings, logFactory, messageFactory);	} else {	initiator = new SocketInitiator( messageHandler, storeFactory, settings, logFactory, messageFactory);	}	initiator.start();	initJMX(initiator, service.getName());	initiatorStore.put(fixEPR, initiator);	applicationStore.put(fixEPR, messageHandler);	FIXIncomingMessageHandler fixMessageHandler = (FIXIncomingMessageHandler) messageHandler;	
waiting for logon procedure to complete 

public boolean createFIXInitiator(AxisService service) throws AxisFault {	InputStream fixConfigStream = getFIXConfigAsStream(service, false);	if (fixConfigStream != null) {	if (log.isDebugEnabled()) {	
attempting to initialize a new fix initiator for the service 

} catch (FieldConvertError e) {	String msg = "FIX configuration file for the initiator session of the service " + service.getName() + " is either incomplete or invalid." + " Not creating the initiator session at this stage.";	log.error(msg, e);	throw new AxisFault(msg, e);	} catch (ConfigError e) {	String msg = "FIX configuration file for the initiator session of the service " + service.getName() + " is either incomplete or invalid." + " Not creating the initiator session at this stage.";	log.error(msg, e);	throw new AxisFault(msg, e);	}	} else {	
the parameter is not specified unable to initialize the initiator session at this stage 

public void disposeFIXAcceptor(AxisService service) {	if (log.isDebugEnabled()) {	
stopping the fix acceptor for the service 

public void disposeFIXAcceptor(AxisService service) {	if (log.isDebugEnabled()) {	}	Acceptor acceptor = acceptorStore.get(service.getName());	if (acceptor != null) {	acceptor.stop();	
fix session for service terminated 

public void disposeFIXInitiators() {	boolean debugEnabled = log.isDebugEnabled();	for (String key : initiatorStore.keySet()) {	initiatorStore.get(key).stop();	if (debugEnabled) {	
fix initiator to the epr stopped 

public String[] getServiceEPRs(String serviceName, String ip) {	if (log.isDebugEnabled()) {	
getting eprs for the service 

fixConfigURLParam = service.getParameter(FIXConstants.FIX_ACCEPTOR_CONFIG_URL_PARAM);	} else {	fixConfigURLParam = service.getParameter(FIXConstants.FIX_INITIATOR_CONFIG_URL_PARAM);	}	if (fixConfigURLParam != null) {	String fixConfigURLValue = fixConfigURLParam.getValue().toString();	try {	URL url = new URL(fixConfigURLValue);	fixConfigStream = url.openStream();	} catch (MalformedURLException e) {	
the fix configuration url is malformed 

} else {	fixConfigURLParam = service.getParameter(FIXConstants.FIX_INITIATOR_CONFIG_URL_PARAM);	}	if (fixConfigURLParam != null) {	String fixConfigURLValue = fixConfigURLParam.getValue().toString();	try {	URL url = new URL(fixConfigURLValue);	fixConfigStream = url.openStream();	} catch (MalformedURLException e) {	} catch (IOException e) {	
error while reading from the url 

}	if (fixConfigURLParam != null) {	String fixConfigURLValue = fixConfigURLParam.getValue().toString();	try {	URL url = new URL(fixConfigURLValue);	fixConfigStream = url.openStream();	} catch (MalformedURLException e) {	} catch (IOException e) {	}	} else {	
fix configuration url is not specified for the service 

if (msgLogMethod != null) {	String method = msgLogMethod.getValue().toString();	log.info("FIX message logging method = " + method);	if (FIXConstants.JDBC_BASED_MESSAGE_STORE.equals(method)) {	storeFactory = new JdbcStoreFactory(settings);	} else if (FIXConstants.SLEEPYCAT_BASED_MESSAGE_STORE.equals(method)) {	storeFactory = new SleepycatStoreFactory(settings);	} else if (FIXConstants.FILE_BASED_MESSAGE_STORE.equals(method)) {	storeFactory = new FileStoreFactory(settings);	} else if (!FIXConstants.MEMORY_BASED_MESSAGE_STORE.equals(method)) {	
invalid message store using defaults 

private void initJMX(Connector connector, String service) {	try {	JmxExporter jmxExporter = new JmxExporter();	jmxExporter.setRegistrationBehavior(JmxExporter.REGISTRATION_IGNORE_EXISTING);	jmxExporter.export(connector);	} catch (JMException e) {	
error while initializing jmx support for the service 

========================= synapse sample_1078 =========================

synCtx.setProperty(SynapseConstants.RESPONSE, Boolean.TRUE);	synCtx.setResponse(true);	} else {	synCtx.setProperty(SynapseConstants.RESPONSE, Boolean.FALSE);	synCtx.setResponse(false);	}	try {	if (synCtx.getEnvironment().injectMessage(synCtx)) {	return InvocationResponse.CONTINUE;	} else {	
synapse has decided to abort the message 

try {	if (synCtx.getEnvironment().injectMessage(synCtx)) {	return InvocationResponse.CONTINUE;	} else {	return InvocationResponse.ABORT;	}	} catch (SynapseException syne) {	if (!synCtx.getFaultStack().isEmpty()) {	((FaultHandler) synCtx.getFaultStack().pop()).handleFault(synCtx, syne);	} else {	
synapse encountered an exception no error handlers found 

========================= synapse sample_3415 =========================

public void writeTo(MessageContext msgCtx, OMOutputFormat format, OutputStream out, boolean preserve) throws AxisFault {	if (log.isDebugEnabled()) {	
start writing the hessian message to outputstream 

public void writeTo(MessageContext msgCtx, OMOutputFormat format, OutputStream out, boolean preserve) throws AxisFault {	if (log.isDebugEnabled()) {	}	if (msgCtx.getFLOW() == MessageContext.OUT_FAULT_FLOW || msgCtx.getEnvelope().hasFault()) {	SOAPFault soapFault = msgCtx.getEnvelope().getBody().getFault();	convertAndWriteHessianFault(soapFault, out);	} else {	writeHessianMessage(msgCtx, out);	}	if (log.isDebugEnabled()) {	
writing message as a hessian message is successful 

try {	inputStream = synapseBinaryDataSource.getInputStream();	IOUtils.copy(inputStream, out);	} catch (IOException e) {	handleException("Couldn't get the bytes from the HessianDataSource", e);	} finally {	if (inputStream != null) {	try {	inputStream.close();	} catch (IOException ignore) {	
error closing input stream 

if (inputStream != null) {	try {	inputStream.close();	} catch (IOException ignore) {	}	}	if (out != null) {	try {	out.close();	} catch (IOException ignore) {	
error closing output stream 

HessianUtils.writeFault(hessianFaultCode, hessianFaultMessage, hessianFaultDetail, faultOutStream);	faultOutStream.flush();	} catch (IOException e) {	handleException("Unalbe to write the fault as a Hessian message", e);	} finally {	try {	if (faultOutStream != null) {	faultOutStream.close();	}	} catch (IOException ignore) {	
error closing output stream 

========================= synapse sample_2592 =========================

private static Properties readManagementProperties() {	Properties managementProperties = new Properties();	String configFileName = System.getProperty("com.sun.management.config.file");	if (configFileName != null) {	FileInputStream configFile = null;	try {	configFile = new FileInputStream(configFileName);	managementProperties.load(configFile);	if (log.isDebugEnabled()) {	
initialized management properties from file 

Properties managementProperties = new Properties();	String configFileName = System.getProperty("com.sun.management.config.file");	if (configFileName != null) {	FileInputStream configFile = null;	try {	configFile = new FileInputStream(configFileName);	managementProperties.load(configFile);	if (log.isDebugEnabled()) {	}	} catch (FileNotFoundException ex) {	
cannot open 

String configFileName = System.getProperty("com.sun.management.config.file");	if (configFileName != null) {	FileInputStream configFile = null;	try {	configFile = new FileInputStream(configFileName);	managementProperties.load(configFile);	if (log.isDebugEnabled()) {	}	} catch (FileNotFoundException ex) {	} catch (IOException ex) {	
error while reading 

========================= synapse sample_723 =========================

}	}	int count = filteredResources.size();	if (count == 0) {	return null;	}	String url = RESTUtils.getSubRequestPath(synCtx);	for (int i = 0; i < count; i++) {	if (mappings.get(i).isExactMatch(url)) {	if (log.isDebugEnabled()) {	
found exact url match for 

Resource matchedResource = null;	for (int i = 0; i < count; i++) {	int length = mappings.get(i).getPrefixMatchingLength(url);	if (length > maxLength) {	maxLength = length;	matchedResource = filteredResources.get(i);	}	}	if (matchedResource != null) {	if (log.isDebugEnabled()) {	
found path match for with matching length 

}	}	if (matchedResource != null) {	if (log.isDebugEnabled()) {	}	return matchedResource;	}	for (int i = 0; i < count; i++) {	if (mappings.get(i).isExtensionMatch(url)) {	if (log.isDebugEnabled()) {	
found extension match for 

========================= synapse sample_2087 =========================

public void receive(org.apache.axis2.context.MessageContext mc) throws AxisFault {	
proxy service received a new message 

public void receive(org.apache.axis2.context.MessageContext mc) throws AxisFault {	log.debug("Message To: " + (mc.getTo() != null ? mc.getTo().getAddress() : "null"));	log.debug("SOAPAction: " + (mc.getWSAAction() != null ? mc.getWSAAction() : "null"));	
body 

public void receive(org.apache.axis2.context.MessageContext mc) throws AxisFault {	log.debug("Message To: " + (mc.getTo() != null ? mc.getTo().getAddress() : "null"));	log.debug("SOAPAction: " + (mc.getWSAAction() != null ? mc.getWSAAction() : "null"));	MessageContext synCtx = Axis2MessageContextFinder.getSynapseMessageContext(mc);	if (targetEndpoint != null) {	Endpoint endpoint = synCtx.getConfiguration().getNamedEndpoint(targetEndpoint);	if (endpoint == null) {	
the endpoint named is not defined dropping current message 

public void receive(org.apache.axis2.context.MessageContext mc) throws AxisFault {	log.debug("Message To: " + (mc.getTo() != null ? mc.getTo().getAddress() : "null"));	log.debug("SOAPAction: " + (mc.getWSAAction() != null ? mc.getWSAAction() : "null"));	MessageContext synCtx = Axis2MessageContextFinder.getSynapseMessageContext(mc);	if (targetEndpoint != null) {	Endpoint endpoint = synCtx.getConfiguration().getNamedEndpoint(targetEndpoint);	if (endpoint == null) {	} else {	synCtx.setTo(new EndpointReference(endpoint.getAddress()));	
forwarding message directly to the endpoint named 

if (targetEndpoint != null) {	Endpoint endpoint = synCtx.getConfiguration().getNamedEndpoint(targetEndpoint);	if (endpoint == null) {	} else {	synCtx.setTo(new EndpointReference(endpoint.getAddress()));	org.apache.axis2.context.MessageContext axisInMsgContext = ((Axis2MessageContext) synCtx).getAxis2MessageContext();	org.apache.axis2.context.MessageContext axisOutMsgContext = Axis2FlexibleMEPClient.send( false, false, endpoint.getWsSecPolicyKey(), endpoint.isReliableMessagingOn(), endpoint.getWsRMPolicyKey(), endpoint.isUseSeparateListener(), synCtx);	axisOutMsgContext.setServerSide(true);	axisOutMsgContext.setProperty(org.apache.axis2.context.MessageContext.TRANSPORT_OUT, axisInMsgContext.getProperty( org.apache.axis2.context.MessageContext.TRANSPORT_OUT));	axisOutMsgContext.setTransportIn(axisInMsgContext.getTransportIn());	
reply body 

org.apache.axis2.context.MessageContext axisOutMsgContext = Axis2FlexibleMEPClient.send( false, false, endpoint.getWsSecPolicyKey(), endpoint.isReliableMessagingOn(), endpoint.getWsRMPolicyKey(), endpoint.isUseSeparateListener(), synCtx);	axisOutMsgContext.setServerSide(true);	axisOutMsgContext.setProperty(org.apache.axis2.context.MessageContext.TRANSPORT_OUT, axisInMsgContext.getProperty( org.apache.axis2.context.MessageContext.TRANSPORT_OUT));	axisOutMsgContext.setTransportIn(axisInMsgContext.getTransportIn());	AxisEngine ae = new AxisEngine(axisOutMsgContext.getConfigurationContext());	try {	axisOutMsgContext.setProperty( org.apache.synapse.Constants.ISRESPONSE_PROPERTY, Boolean.TRUE);	mc.getOperationContext().setProperty( Constants.RESPONSE_WRITTEN, Constants.VALUE_TRUE);	ae.send(axisOutMsgContext);	} catch (AxisFault e) {	
axis fault encountered while forwarding message to endpoint 

AxisEngine ae = new AxisEngine(axisOutMsgContext.getConfigurationContext());	try {	axisOutMsgContext.setProperty( org.apache.synapse.Constants.ISRESPONSE_PROPERTY, Boolean.TRUE);	mc.getOperationContext().setProperty( Constants.RESPONSE_WRITTEN, Constants.VALUE_TRUE);	ae.send(axisOutMsgContext);	} catch (AxisFault e) {	}	}	} else {	if (targetOutSequence != null) {	
outsequence for the proxy set to the messagecontext 

} catch (AxisFault e) {	}	}	} else {	if (targetOutSequence != null) {	synCtx.setProperty(org.apache.synapse.Constants.OUT_SEQUENCE, targetOutSequence);	}	if (targetInSequence != null) {	Mediator mediator = synCtx.getConfiguration().getNamedSequence(targetInSequence);	if (mediator == null) {	
the mediator named is not defined dropping current message 

}	}	} else {	if (targetOutSequence != null) {	synCtx.setProperty(org.apache.synapse.Constants.OUT_SEQUENCE, targetOutSequence);	}	if (targetInSequence != null) {	Mediator mediator = synCtx.getConfiguration().getNamedSequence(targetInSequence);	if (mediator == null) {	} else {	
using sequence named for message mediation 

if (targetOutSequence != null) {	synCtx.setProperty(org.apache.synapse.Constants.OUT_SEQUENCE, targetOutSequence);	}	if (targetInSequence != null) {	Mediator mediator = synCtx.getConfiguration().getNamedSequence(targetInSequence);	if (mediator == null) {	} else {	mediator.mediate(synCtx);	}	} else {	
using default main mediator for message mediation 

========================= synapse sample_2984 =========================

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	
shutting down apache synapse 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	ServerManager.getInstance().stop();	
shutdown complete 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	ServerManager.getInstance().stop();	
halting jvm 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	ServerManager.getInstance().stop();	} catch (Exception e) {	
error occurred while shutting down apache synapse 

========================= synapse sample_3696 =========================

public void setNameOnProcessor(SynapseEnvironment se, OMElement el, Processor p) {	OMAttribute nm = el.getAttribute(new QName("name"));	if (nm != null) {	String name = nm.getAttributeValue().trim();	p.setName(name);	se.addProcessor(p);	}	
compile with name on 

========================= synapse sample_1351 =========================

public void init(ConfigurationContext cfgCtx, TransportInDescription transportInDescription) throws AxisFault {	if (log.isDebugEnabled()) {	
initializing pass through http s listener 

public void start() throws AxisFault {	
starting pass through listener 

public void start() throws AxisFault {	try {	String prefix = namePrefix + "-PT-Listener I/O Dispatcher";	ioReactor = new DefaultListeningIOReactor( sourceConfiguration.getReactorConfig(true), new NativeThreadFactory(new ThreadGroup(prefix + " Thread Group"), prefix));	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	
system may be unstable listeningioreactor encountered a checked exception 

public void start() throws AxisFault {	try {	String prefix = namePrefix + "-PT-Listener I/O Dispatcher";	ioReactor = new DefaultListeningIOReactor( sourceConfiguration.getReactorConfig(true), new NativeThreadFactory(new ThreadGroup(prefix + " Thread Group"), prefix));	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	return true;	}	public boolean handle(RuntimeException runtimeException) {	
system may be unstable listeningioreactor encountered a runtime exception 

}	HttpGetRequestProcessor getProcessor = sourceConfiguration.getHttpGetRequestProcessor();	if (getProcessor != null){	getProcessor.init(sourceConfiguration.getConfigurationContext(), handler);	}	Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (Exception e) {	
exception encountered in the listener no more connections will be accepted by this transport 

HttpGetRequestProcessor getProcessor = sourceConfiguration.getHttpGetRequestProcessor();	if (getProcessor != null){	getProcessor.init(sourceConfiguration.getConfigurationContext(), handler);	}	Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (Exception e) {	}	
listener shutdown 

try {	ioReactor.execute(ioEventDispatch);	} catch (Exception e) {	}	}	}, "PassThrough" + namePrefix + "Listener");	t.start();	try {	endpoint.waitFor();	} catch (InterruptedException e) {	
pass through listener startup was interrupted 

} catch (Exception e) {	}	}	}, "PassThrough" + namePrefix + "Listener");	t.start();	try {	endpoint.waitFor();	} catch (InterruptedException e) {	}	state = BaseConstants.STARTED;	
pass through listener started on port 

public void stop() throws AxisFault {	
stopping pass through listener 

public void destroy() {	if (log.isDebugEnabled()) {	
destroying pass through listener 

public void pause() throws AxisFault {	if (state != BaseConstants.STARTED) return;	try {	ioReactor.pause();	state = BaseConstants.PAUSED;	
listener paused 

public void maintenanceShutdown(long milliSecs) throws AxisFault {	if (state != BaseConstants.STARTED) return;	try {	long start = System.currentTimeMillis();	ioReactor.pause();	ioReactor.shutdown(milliSecs);	state = BaseConstants.STOPPED;	
listener shutdown in s 

========================= synapse sample_922 =========================

public void testGetQuote() throws Exception {	BasicHttpClient client = new BasicHttpClient();	HttpResponse response = client.doGet("http: assertEquals(response.getStatus(), HttpStatus.SC_INTERNAL_SERVER_ERROR);	OMElement body = response.getBodyAsXML();	assertEquals(body.getLocalName(), "Exception");	
an exception was thrown as expected 

========================= synapse sample_2290 =========================

public void close() throws IOException {	
close connection 

public void shutdown() throws IOException {	
shutdown connection 

public void submitRequest(final HttpRequest request) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection 

public void consumeInput(final NHttpClientEventHandler handler) {	
consume input 

public void produceOutput(final NHttpClientEventHandler handler) {	
produce output 

========================= synapse sample_1003 =========================

public boolean mediate(MessageContext synCtx) {	
try mediator mediate 

========================= synapse sample_3317 =========================

public int getPriority(String ip, EndpointReference to) {	int priority=-1;	Map clientMap = (Map) SLAConfig.get(ip);	if(clientMap!=null){	
address 

========================= synapse sample_2910 =========================

protected synchronized void open() {	File dir = new File(AccessConstants.DIRECTORY);	if (!dir.exists()) {	if (!dir.mkdirs()) {	
access log open directory failed 

try {	String pathName;	if (isRotatable) {	pathName = dir.getAbsolutePath() + File.separator + AccessConstants.PREFIX + dateStamp + AccessConstants.SUFFIX;	} else {	pathName = dir.getAbsolutePath() + File.separator + AccessConstants.PREFIX + AccessConstants.SUFFIX;	}	writer = new PrintWriter(new BufferedWriter(new FileWriter( pathName, true), 128000), true);	currentLogFile = new File(pathName);	} catch (IOException e) {	
unable to open the print writer 

========================= synapse sample_2443 =========================

public Object getProperty(Property dp) {	OMNode omNode = null;	RegistryEntry re = null;	if (dp.isCached() && !dp.isExpired()) {	return dp.getValue();	} else if (!dp.isCached()) {	omNode = lookup(dp.getKey());	re = getRegistryEntry(dp.getKey());	} else if (dp.isExpired()) {	
cached object has expired for key 

OMNode omNode = null;	RegistryEntry re = null;	if (dp.isCached() && !dp.isExpired()) {	return dp.getValue();	} else if (!dp.isCached()) {	omNode = lookup(dp.getKey());	re = getRegistryEntry(dp.getKey());	} else if (dp.isExpired()) {	re = getRegistryEntry(dp.getKey());	if (re.getVersion() != Long.MIN_VALUE && re.getVersion() == dp.getVersion()) {	
expired version number is same as current version in registry 

RegistryEntry re = null;	if (dp.isCached() && !dp.isExpired()) {	return dp.getValue();	} else if (!dp.isCached()) {	omNode = lookup(dp.getKey());	re = getRegistryEntry(dp.getKey());	} else if (dp.isExpired()) {	re = getRegistryEntry(dp.getKey());	if (re.getVersion() != Long.MIN_VALUE && re.getVersion() == dp.getVersion()) {	dp.setExpiryTime( System.currentTimeMillis() + re.getCachableDuration());	
renew cache lease for another s 

========================= synapse sample_3086 =========================

public void init(ConfigurationContext cfgCtx, TransportInDescription trpInDesc) throws AxisFault {	setTransportName(TRANSPORT_NAME);	super.init(cfgCtx, trpInDesc);	loadConnectionFactoryDefinitions(trpInDesc);	if (connectionFactories.isEmpty()) {	
no jms connection factories are defined cannot listen for jms 

public void init(ConfigurationContext cfgCtx, TransportInDescription trpInDesc) throws AxisFault {	setTransportName(TRANSPORT_NAME);	super.init(cfgCtx, trpInDesc);	loadConnectionFactoryDefinitions(trpInDesc);	if (connectionFactories.isEmpty()) {	return;	}	
jms transport receiver listener initialized 

if (cf == null) {	String msg = "Service " + service.getName() + " does not specify" + "a JMS connection factory or refers to an invalid factory. " + "This service is being marked as faulty and will not be " + "available over the JMS transport";	log.warn(msg);	BaseUtils.markServiceAsFaulty(service.getName(), msg, service.getAxisConfiguration());	disableTransportForService(service);	return;	}	String destinationName = JMSUtils.getJNDIDestinationNameForService(service);	serviceNameToEPRMap.put(service.getName(), JMSUtils.getEPR(cf, destinationName));	String destinationType = JMSUtils.getDestinationTypeForService(service);	
starting to listen on destination of type for service 

public void pause() throws AxisFault {	if (state != BaseConstants.STARTED) return;	try {	Iterator iter = connectionFactories.values().iterator();	while (iter.hasNext()) {	JMSConnectionFactory conFac = (JMSConnectionFactory) iter.next();	conFac.pause();	}	state = BaseConstants.PAUSED;	
listener paused 

public void pause() throws AxisFault {	if (state != BaseConstants.STARTED) return;	try {	Iterator iter = connectionFactories.values().iterator();	while (iter.hasNext()) {	JMSConnectionFactory conFac = (JMSConnectionFactory) iter.next();	conFac.pause();	}	state = BaseConstants.PAUSED;	} catch (AxisJMSException e) {	
at least one connection factory could not be paused 

public void resume() throws AxisFault {	if (state != BaseConstants.PAUSED) return;	try {	Iterator iter = connectionFactories.values().iterator();	while (iter.hasNext()) {	JMSConnectionFactory conFac = (JMSConnectionFactory) iter.next();	conFac.resume();	}	state = BaseConstants.STARTED;	
listener resumed 

public void resume() throws AxisFault {	if (state != BaseConstants.PAUSED) return;	try {	Iterator iter = connectionFactories.values().iterator();	while (iter.hasNext()) {	JMSConnectionFactory conFac = (JMSConnectionFactory) iter.next();	conFac.resume();	}	state = BaseConstants.STARTED;	} catch (AxisJMSException e) {	
at least one connection factory could not be resumed 

public void maintenenceShutdown(long millis) throws AxisFault {	if (state != BaseConstants.STARTED) return;	try {	long start = System.currentTimeMillis();	stop();	state = BaseConstants.STOPPED;	
listener shutdown in s 

========================= synapse sample_4313 =========================

protected void handleSingleSecretCallback(SingleSecretCallback singleSecretCallback) {	if (secretCallbackHandler == null) {	if (log.isWarnEnabled()) {	
there is no shared secretcallbackhandler please use any other secretcallbackhandler implementations 

========================= synapse sample_1111 =========================

public boolean mediate(MessageContext synCtx) {	try {	
implicit sequence mediate 

========================= synapse sample_3069 =========================

public void testXQuery() {	String addUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to the xquery mediator 

========================= synapse sample_2228 =========================

public boolean mediate(MessageContext synCtx) {	boolean returnValue = true;	if (log.isDebugEnabled()) {	
target mediation start 

public boolean mediate(MessageContext synCtx) {	boolean returnValue = true;	if (log.isDebugEnabled()) {	}	if (soapAction != null) {	if (log.isDebugEnabled()) {	
setting the soapaction as 

boolean returnValue = true;	if (log.isDebugEnabled()) {	}	if (soapAction != null) {	if (log.isDebugEnabled()) {	}	synCtx.setSoapAction(soapAction);	}	if (toAddress != null) {	if (log.isDebugEnabled()) {	
setting the to header as 

}	if (synCtx.getTo() != null) {	synCtx.getTo().setAddress(toAddress);	} else {	synCtx.setTo(new EndpointReference(toAddress));	}	}	if (sequence != null) {	if (asynchronous) {	if (log.isDebugEnabled()) {	
asynchronously mediating using the in lined anonymous sequence 

synCtx.setTo(new EndpointReference(toAddress));	}	}	if (sequence != null) {	if (asynchronous) {	if (log.isDebugEnabled()) {	}	synCtx.getEnvironment().injectAsync(synCtx, sequence);	} else {	if (log.isDebugEnabled()) {	
synchronously mediating using the in lined anonymous sequence 

} else {	if (log.isDebugEnabled()) {	}	returnValue = sequence.mediate(synCtx);	}	} else if (sequenceRef != null) {	SequenceMediator refSequence = (SequenceMediator) synCtx.getSequence(sequenceRef);	if (refSequence != null) {	if (asynchronous) {	if (log.isDebugEnabled()) {	
asynchronously mediating using the sequence named 

}	} else if (sequenceRef != null) {	SequenceMediator refSequence = (SequenceMediator) synCtx.getSequence(sequenceRef);	if (refSequence != null) {	if (asynchronous) {	if (log.isDebugEnabled()) {	}	synCtx.getEnvironment().injectAsync(synCtx, refSequence);	} else {	if (log.isDebugEnabled()) {	
synchronously mediating using the sequence named 

} else {	if (log.isDebugEnabled()) {	}	returnValue = refSequence.mediate(synCtx);	}	} else {	handleException("Couldn't find the sequence named : " + sequenceRef);	}	} else if (endpoint != null) {	if (log.isDebugEnabled()) {	
sending using the in lined anonymous endpoint 

handleException("Couldn't find the sequence named : " + sequenceRef);	}	} else if (endpoint != null) {	if (log.isDebugEnabled()) {	}	endpoint.send(synCtx);	} else if (endpointRef != null) {	Endpoint epr = synCtx.getConfiguration().getEndpoint(endpointRef);	if (epr != null) {	if (log.isDebugEnabled()) {	
sending using the endpoint named 

Endpoint epr = synCtx.getConfiguration().getEndpoint(endpointRef);	if (epr != null) {	if (log.isDebugEnabled()) {	}	epr.send(synCtx);	} else {	handleException("Couldn't find the endpoint named : " + endpointRef);	}	}	if (log.isDebugEnabled()) {	
target mediation end 

========================= synapse sample_563 =========================

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	
shutting down simpleaxisserver 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	stopServer();	
shutdown complete 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	stopServer();	
halting jvm 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	stopServer();	} catch (Exception e) {	
error occurred while shutting down simpleaxisserver 

========================= synapse sample_2678 =========================

public void warning(TransformerException e) throws TransformerException {	if (synLog.isTraceOrDebugEnabled()) {	
warning encountered during 

public void error(TransformerException e) throws TransformerException {	
error occurred in 

public void fatalError(TransformerException e) throws TransformerException {	
fatal error occurred in 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	
start xslt mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceTraceEnabled()) {	}	try {	performXSLT(synCtx, synLog);	} catch (Exception e) {	handleException("Unable to perform XSLT transformation using : " + xsltKey + " against source XPath : " + source, e, synCtx);	}	
end xslt mediator 

for (MediatorProperty prop : properties) {	if (prop != null) {	String value;	if (prop.getValue() != null) {	value = prop.getValue();	} else {	value = prop.getExpression().stringValueOf(synCtx);	}	if (synLog.isTraceOrDebugEnabled()) {	if (value == null) {	
not setting parameter 

if (prop != null) {	String value;	if (prop.getValue() != null) {	value = prop.getValue();	} else {	value = prop.getExpression().stringValueOf(synCtx);	}	if (synLog.isTraceOrDebugEnabled()) {	if (value == null) {	} else {	
setting parameter to 

========================= synapse sample_1957 =========================

public void run() {	if (log.isDebugEnabled()) {	
starting a new server worker instance 

String contentType = contentTypeHdr!=null ? TransportUtils.getContentType(contentTypeHdr, msgContext) : null;	if (contentType == null || "".equals(contentType) || HTTPConstants.MEDIA_TYPE_X_WWW_FORM.equals(contentType)) {	contentType = contentTypeHdr != null ? contentTypeHdr : HTTPConstants.MEDIA_TYPE_X_WWW_FORM;	msgContext.setTo(new EndpointReference(request.getRequest().getRequestLine().getUri()));	msgContext.setProperty(Constants.Configuration.CONTENT_TYPE,contentType);	String charSetEncoding = BuilderUtil.getCharSetEncoding(contentType);	msgContext.setProperty(Constants.Configuration.CHARACTER_SET_ENCODING, charSetEncoding);	try {	RESTUtil.dispatchAndVerify(msgContext);	} catch (AxisFault e1) {	
error while building message for rest url request 

String defaultSvcName = PassThroughConfiguration.getInstance().getStringProperty( "nhttp.default.service", "__SynapseService");	axisService =  msgContext.getConfigurationContext().getAxisConfiguration() .getService(defaultSvcName);	msgContext.setAxisService(axisService);	}	} catch (AxisFault e) {	handleException("Error processing " + request.getMethod() + " request for : " + request.getUri(), e);	}	try {	soapEnvelope = TransportUtils.createSOAPMessage(msgContext, null, contentType);	} catch (Exception e) {	
error while building message for rest url request 

boolean nioAck = msgContext.isPropertyTrue("NIO-ACK-Requested", false);	if (respWillFollow || ack || forced || nioAck) {	NHttpServerConnection conn = request.getConnection();	SourceResponse sourceResponse;	if (!nioAck) {	msgContext.removeProperty(MessageContext.TRANSPORT_HEADERS);	sourceResponse = SourceResponseFactory.create(msgContext, request, sourceConfiguration);	sourceResponse.setStatus(HttpStatus.SC_ACCEPTED);	} else {	if (log.isDebugEnabled()) {	
sending ack response with status for messageid 

========================= synapse sample_2382 =========================

public void start() {	try {	URL.setURLStreamHandlerFactory(new URLStreamHandlerFactoryImpl());	} catch (Throwable t) {	
unable to register a urlstreamhandlerfactory custom url protocols may not work properly e g classpath 

public void start() {	try {	URL.setURLStreamHandlerFactory(new URLStreamHandlerFactoryImpl());	} catch (Throwable t) {	if (axis2Repolocation == null) {	
the repository must be provided 

public void start() {	try {	URL.setURLStreamHandlerFactory(new URLStreamHandlerFactoryImpl());	} catch (Throwable t) {	if (axis2Repolocation == null) {	return;	}	
using the repository 

String msg = "Starting transport " + trsIn.getName();	if (trsIn.getParameter("port") != null) {	msg += " on port " + trsIn.getParameter("port").getValue();	}	log.info(msg);	}	Parameter synEnv = configctx.getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_ENV);	Parameter synCfg = configctx.getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_CONFIG);	String message = "Unable to initialize the Synapse Configuration : Can not find the ";	if (synCfg == null || synCfg.getValue() == null || !(synCfg.getValue() instanceof SynapseConfiguration)) {	
synapse configuration 

}	log.info(msg);	}	Parameter synEnv = configctx.getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_ENV);	Parameter synCfg = configctx.getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_CONFIG);	String message = "Unable to initialize the Synapse Configuration : Can not find the ";	if (synCfg == null || synCfg.getValue() == null || !(synCfg.getValue() instanceof SynapseConfiguration)) {	throw new SynapseException(message + "Synapse Configuration");	}	if (synEnv == null || synEnv.getValue() == null || !(synEnv.getValue() instanceof SynapseEnvironment)) {	
synapse environment 

((SynapseEnvironment) synEnv.getValue()).setInitialized(true);	Collection startups = ((SynapseConfiguration) synCfg.getValue()).getStartups();	for (Iterator it = startups.iterator(); it.hasNext();) {	Object o = it.next();	if (o instanceof ManagedLifecycle) {	ManagedLifecycle m = (ManagedLifecycle) o;	m.init((SynapseEnvironment) synEnv.getValue());	}	}	}	
ready for processing 

for (Iterator it = startups.iterator(); it.hasNext();) {	Object o = it.next();	if (o instanceof ManagedLifecycle) {	ManagedLifecycle m = (ManagedLifecycle) o;	m.init((SynapseEnvironment) synEnv.getValue());	}	}	}	} catch (Throwable t) {	t.printStackTrace();	
startup failed 

private static void selectPort(ConfigurationContext configCtx) {	TransportInDescription trsIn = (TransportInDescription) configCtx.getAxisConfiguration().getTransportsIn().get("http");	if (trsIn != null) {	int port = 8080;	String bindAddress = null;	String strPort = System.getProperty("port");	if (strPort != null) {	try {	port = new Integer(strPort).intValue();	} catch (NumberFormatException e) {	
system property port does not provide a valid integer 

ServerSocket sock = null;	try {	if (bindAddress == null) {	sock = new ServerSocket(port);	} else {	sock = new ServerSocket(port, 50, InetAddress.getByName(bindAddress));	}	trsIn.getParameter("port").setValue(Integer.toString(port));	break;	} catch (Exception e) {	
port already in use trying alternate 

========================= synapse sample_3710 =========================

public void close() throws IOException {	
close connection 

public void shutdown() throws IOException {	
shutdown connection 

public void submitRequest(final HttpRequest request) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection 

public void consumeInput(final NHttpClientEventHandler handler) {	
consume input 

public void produceOutput(final NHttpClientEventHandler handler) {	
produce output 

========================= synapse sample_2414 =========================

public Startup createStartup(OMElement el) {	if (log.isDebugEnabled()) {	
creating simplequartz task 

========================= synapse sample_2044 =========================

if (entry != null && entry.isDynamic()) {	if (!entry.isCached() || entry.isExpired()) {	reLoad = true;	}	} else {	reLoad = true;	}	}	if (reLoad) {	if (log.isDebugEnabled()) {	
loading real endpoint with key 

========================= synapse sample_1668 =========================

public void setStoreType(String storeType) {	if (storeType == null || "".equals(storeType)) {	if (log.isDebugEnabled()) {	
given store type is null using default type jks 

public void setAlias(String alias) {	if (alias == null || "".equals(alias)) {	if (log.isDebugEnabled()) {	
alias for a key entry or a certificate is null 

protected KeyStore getKeyStore() {	if (log.isDebugEnabled()) {	
loading keystore with type 

switch (storeType) {	case JKS: IKeyStoreLoader jksKeyStoreLoader = new JKSKeyStoreLoader(location, keyStorePassword);	return jksKeyStoreLoader.getKeyStore();	case PKCS12: IKeyStoreLoader pkcs12KeyStoreLoader = new PKCS12KeyStoreLoader(location, keyStorePassword);	return pkcs12KeyStoreLoader.getKeyStore();	case PKCS8: IKeyStoreLoader pkcs8KeyStoreLoader = new PKCS8KeyStoreLoader(location, parameters.get(KEY_STORE_CERTIFICATE_FILE_PATH), keyStorePassword, alias);	return pkcs8KeyStoreLoader.getKeyStore();	case CA_CERTIFICATES_PATH: ICACertsLoader caCertsLoader = new CACertsLoader();	return caCertsLoader.loadTrustStore(location);	default: if (log.isDebugEnabled()) {	
no keystore found 

========================= synapse sample_1107 =========================

} else {	service.printUserWSDL(output, parameterValue);	}	response.addHeader(CONTENT_TYPE, TEXT_XML);	sendResponseAndFinish(response, output.toByteArray(), conn, os, msgContext);	} catch (Exception e) {	handleBrowserException(response, msgContext, conn, os, "Error generating ?wsdl output for service : " + serviceName, e);	}	} else {	if (log.isDebugEnabled()) {	
unable to find service for wsdl generation 

========================= synapse sample_963 =========================

public boolean injectMessage(final MessageContext synCtx) {	if (log.isDebugEnabled()) {	
injecting messagecontext 

}	synCtx.setEnvironment(this);	if (synCtx.isResponse()) {	StatisticsUtils.processEndPointStatistics(synCtx);	StatisticsUtils.processProxyServiceStatistics(synCtx);	StatisticsUtils.processSequenceStatistics(synCtx);	}	Mediator mandatorySeq = synCtx.getConfiguration().getMandatorySequence();	if (mandatorySeq != null) {	if (log.isDebugEnabled()) {	
start mediating the message in the pre mediate state using the mandatory sequence 

}	return false;	}	}	if (synCtx.getProperty(SynapseConstants.PROXY_SERVICE) != null) {	if (synCtx.getConfiguration().getProxyService((String) synCtx.getProperty( SynapseConstants.PROXY_SERVICE)).getTargetOutSequence() != null) {	String sequenceName = synCtx.getConfiguration().getProxyService((String) synCtx. getProperty(SynapseConstants.PROXY_SERVICE)).getTargetOutSequence();	Mediator outSequence = synCtx.getSequence(sequenceName);	if (outSequence != null) {	if (log.isDebugEnabled()) {	
using the sequence named for the outgoing message mediation of the proxy service 

}	if (synCtx.getProperty(SynapseConstants.PROXY_SERVICE) != null) {	if (synCtx.getConfiguration().getProxyService((String) synCtx.getProperty( SynapseConstants.PROXY_SERVICE)).getTargetOutSequence() != null) {	String sequenceName = synCtx.getConfiguration().getProxyService((String) synCtx. getProperty(SynapseConstants.PROXY_SERVICE)).getTargetOutSequence();	Mediator outSequence = synCtx.getSequence(sequenceName);	if (outSequence != null) {	if (log.isDebugEnabled()) {	}	outSequence.mediate(synCtx);	} else {	
unable to find the out sequence specified by the name 

Mediator outSequence = synCtx.getSequence(sequenceName);	if (outSequence != null) {	if (log.isDebugEnabled()) {	}	outSequence.mediate(synCtx);	} else {	throw new SynapseException("Unable to find the " + "out-sequence specified by the name " + sequenceName);	}	} else if (synCtx.getConfiguration().getProxyService((String) synCtx.getProperty( SynapseConstants.PROXY_SERVICE)).getTargetInLineOutSequence() != null) {	if (log.isDebugEnabled()) {	
using the anonymous out sequence specified in the proxy service for outgoing message mediation 

outSequence.mediate(synCtx);	} else {	throw new SynapseException("Unable to find the " + "out-sequence specified by the name " + sequenceName);	}	} else if (synCtx.getConfiguration().getProxyService((String) synCtx.getProperty( SynapseConstants.PROXY_SERVICE)).getTargetInLineOutSequence() != null) {	if (log.isDebugEnabled()) {	}	synCtx.getConfiguration().getProxyService((String) synCtx.getProperty( SynapseConstants.PROXY_SERVICE)).getTargetInLineOutSequence().mediate(synCtx);	} else {	if (log.isDebugEnabled()) {	
proxy service does not specifies an out sequence sending the response back 

if (log.isDebugEnabled()) {	}	synCtx.getConfiguration().getProxyService((String) synCtx.getProperty( SynapseConstants.PROXY_SERVICE)).getTargetInLineOutSequence().mediate(synCtx);	} else {	if (log.isDebugEnabled()) {	}	Axis2Sender.sendBack(synCtx);	}	} else {	if (log.isDebugEnabled()) {	
using main sequence for injected message 

public MessageContext createMessageContext() {	if (log.isDebugEnabled()) {	
creating message context 

========================= synapse sample_3993 =========================

public boolean mediate(MessageContext synCtx) {	
starting spring meditor 

public boolean mediate(MessageContext synCtx) {	
bean in initialized with user 

public boolean mediate(MessageContext synCtx) {	
e mail 

public boolean mediate(MessageContext synCtx) {	
massage id 

public boolean mediate(MessageContext synCtx) {	
logged 

========================= synapse sample_2681 =========================

public RevocationStatus checkRevocationStatus(X509Certificate peerCert, X509Certificate issuerCert) throws CertificateVerificationException {	List<String> list = getCrlDistributionPoints(peerCert);	for (String crlUrl : list) {	if (log.isDebugEnabled()) {	
trying to get crl for url 

public RevocationStatus checkRevocationStatus(X509Certificate peerCert, X509Certificate issuerCert) throws CertificateVerificationException {	List<String> list = getCrlDistributionPoints(peerCert);	for (String crlUrl : list) {	if (log.isDebugEnabled()) {	}	if (cache != null) {	X509CRL x509CRL = cache.getCacheValue(crlUrl);	if (x509CRL != null) {	RevocationStatus status = getRevocationStatus(x509CRL, peerCert);	
crl taken from cache 

try {	X509CRL x509CRL = downloadCRLFromWeb(crlUrl);	if (x509CRL != null) {	if (cache != null) {	cache.setCacheValue(crlUrl, x509CRL);	}	return getRevocationStatus(x509CRL, peerCert);	}	} catch (Exception e) {	if (log.isDebugEnabled()) {	
either the url is bad or cannot build check with the next url in the list 

========================= synapse sample_2394 =========================

configurationElement = OMXMLBuilderFactory.createOMBuilder(xmlInputStream).getDocumentElement();	} catch (FileNotFoundException e) {	throw new SynapseArtifactDeploymentException("file not found at : " + fileXmlPath);	} catch (OMException e) {	throw new SynapseArtifactDeploymentException("Error while parsing the artifacts.xml file : " + fileXmlPath , e);	} finally {	if (xmlInputStream != null) {	try {	xmlInputStream.close();	} catch (IOException e) {	
error while closing input stream for file artifact 

========================= synapse sample_575 =========================

public void testRestrictedThrottling() {	String addUrl = "http: String expectedError = "Access Denied";	StockQuoteSampleClient client = getStockQuoteClient();	
running test restricting requests based on policies 

String addUrl = "http: String expectedError = "Access Denied";	StockQuoteSampleClient client = getStockQuoteClient();	for (int i = 0; i < 4; i++) {	result = client.requestStandardQuote(addUrl, null, null, "IBM", null);	}	assertTrue("Client did not get run successfully ", result.responseReceived());	result = client.requestStandardQuote(addUrl, null, null, "IBM", null);	assertFalse("Should not get a response", result.responseReceived());	Exception resultEx = result.getException();	assertNotNull("Did not receive expected error", resultEx);	
got an error as expected 

========================= synapse sample_826 =========================

public static SynapseConfiguration getConfiguration(InputStream is) throws XMLStreamException {	
generating the synapse configuration model by parsing the xml configuration 

========================= synapse sample_3585 =========================

private void init() {	String algorithm = cipherInformation.getAlgorithm();	CipherOperationMode opMode = cipherInformation.getCipherOperationMode();	if (key == null) {	key = getKey(opMode);	}	if (log.isDebugEnabled()) {	
initializing cipher with algorithm in mode 

========================= synapse sample_2547 =========================

public void execute(JobExecutionContext ctx) throws JobExecutionException {	
executing task 

Task task = null;	try {	task = (Task) getClass().getClassLoader().loadClass(jobClassName).newInstance();	} catch (Exception e) {	handleException("Cannot instantiate task : " + jobClassName, e);	}	Set properties = (Set) jdm.get(PROPERTIES);	Iterator it = properties.iterator();	while (it.hasNext()) {	OMElement prop = (OMElement) it.next();	
found property 

========================= synapse sample_3706 =========================

public int getPriority(String ip, EndpointReference to) {	int priority=-1;	Map clientMap = (Map) SLAConfig.get(ip);	if(clientMap!=null){	
address 

========================= synapse sample_2814 =========================

public void destroy() {	if (log.isDebugEnabled()) {	
destroying class mediator instance for 

public void init(SynapseEnvironment se) {	if (log.isDebugEnabled()) {	
initializing class mediator instance for 

public void init(SynapseEnvironment se) {	if (log.isDebugEnabled()) {	}	if (mediator == null) {	
init called before mediator reference set 

========================= synapse sample_4169 =========================

public void createLocalRegistry(int port) {	try {	String key = toKey(port);	synchronized (registriesCache) {	if (registriesCache.containsKey(key)) {	if (log.isDebugEnabled()) {	
there is an rmi registry bound to given port 

public void removeLocalRegistry(int port) {	String key = toKey(port);	synchronized (registriesCache) {	if (registriesCache.containsKey(key)) {	removeRegistry(key, registriesCache.get(key));	} else {	if (log.isDebugEnabled()) {	
there is no rmi registry for port 

private void removeRegistry(String key, Registry registry) {	if (registry != null) {	synchronized (registriesCache) {	try {	
removing the rmi registry bound to port 

========================= synapse sample_719 =========================

public RevocationStatus checkRevocationStatus(X509Certificate peerCert, X509Certificate issuerCert) throws CertificateVerificationException {	if (cache != null) {	SingleResp resp = cache.getCacheValue(peerCert.getSerialNumber());	if (resp != null) {	RevocationStatus status = getRevocationStatus(resp);	
ocsp response taken from cache 

========================= synapse sample_2402 =========================

public void run() {	String action = queueConsumerPolicy.getAction();	if (SEDAQueueConsumerPolicy.TAKE.equals(action)) {	try {	consume(queue.take());	} catch (InterruptedException ignored) {	
ignored interruptedexception when ocuured calling queue take 

} catch (InterruptedException ignored) {	}	} else if (SEDAQueueConsumerPolicy.POLL.equals(action)) {	long timeout = queueConsumerPolicy.getTimeoutOnPoll();	if (timeout < 0) {	consume(queue.poll());	} else {	try {	consume(queue.poll(timeout, TimeUnit.MILLISECONDS));	} catch (InterruptedException ignored) {	
ignored interruptedexception when ocuured calling queue poll 

========================= synapse sample_1445 =========================

public void testLocalEntriesReusableEndPointsSequences() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test local registry entry definitions reusable endpoints and sequences 

========================= synapse sample_2269 =========================

public boolean mediate(SynapseContext synCtx) {	
mediate 

========================= synapse sample_2793 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start switch mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	int parentsEffectiveTraceState = synCtx.getTracingState();	setEffectiveTraceState(synCtx);	String sourceText = source.stringValueOf(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
xpath evaluates to 

if (synLog.isTraceTraceEnabled()) {	}	}	int parentsEffectiveTraceState = synCtx.getTracingState();	setEffectiveTraceState(synCtx);	String sourceText = source.stringValueOf(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	}	try {	if ((sourceText == null || cases.isEmpty()) && defaultCase != null) {	
source xpath evaluated to null or no switch cases found executing the default case 

if (synLog.isTraceOrDebugEnabled()) {	}	try {	if ((sourceText == null || cases.isEmpty()) && defaultCase != null) {	return defaultCase.mediate(synCtx);	} else {	for (SwitchCase swCase : cases) {	if (swCase != null) {	if (swCase.matches(sourceText)) {	if (synLog.isTraceOrDebugEnabled()) {	
matching case found 

for (SwitchCase swCase : cases) {	if (swCase != null) {	if (swCase.matches(sourceText)) {	if (synLog.isTraceOrDebugEnabled()) {	}	return swCase.mediate(synCtx);	}	}	}	if (defaultCase != null) {	
none of the switch cases matched executing default 

if (swCase.matches(sourceText)) {	if (synLog.isTraceOrDebugEnabled()) {	}	return swCase.mediate(synCtx);	}	}	}	if (defaultCase != null) {	return defaultCase.mediate(synCtx);	} else {	
none of the switch cases matched no default case 

}	}	if (defaultCase != null) {	return defaultCase.mediate(synCtx);	} else {	}	}	} finally {	synCtx.setTracingState(parentsEffectiveTraceState);	}	
end switch mediator 

========================= synapse sample_1916 =========================

public void sequenceAdded(Mediator sequence) {	
sequence was added to the synapse configuration successfully 

public void sequenceRemoved(Mediator sequence) {	
sequence was removed from the synapse configuration successfully 

public void sequenceTemplateAdded(Mediator template) {	
template was added to the synapse configuration successfully 

public void sequenceTemplateRemoved(Mediator template) {	
template was removed to the synapse configuration successfully 

public void entryAdded(Entry entry) {	
local entry was added to the synapse configuration successfully 

public void entryRemoved(Entry entry) {	
local entry was removed from the synapse configuration successfully 

public void endpointAdded(Endpoint endpoint) {	
endpoint was added to the synapse configuration successfully 

public void endpointRemoved(Endpoint endpoint) {	
endpoint was removed from the synapse configuration successfully 

public void proxyServiceAdded(ProxyService proxy) {	
proxy service was added to the synapse configuration successfully 

public void proxyServiceRemoved(ProxyService proxy) {	
proxy service was removed from the synapse configuration successfully 

public void startupAdded(Startup startup) {	
startup was added to the synapse configuration successfully 

public void startupRemoved(Startup startup) {	
startup was removed from the synapse configuration successfully 

public void eventSourceAdded(SynapseEventSource eventSource) {	
event source was added to the synapse configuration successfully 

public void eventSourceRemoved(SynapseEventSource eventSource) {	
event source was removed from the synapse configuration successfully 

public void priorityExecutorAdded(PriorityExecutor exec) {	
priority executor was added to the synapse configuration successfully 

public void priorityExecutorRemoved(PriorityExecutor exec) {	
priority executor was removed from the synapse configuration successfully 

========================= synapse sample_488 =========================

public boolean mediate(MessageContext synCtx) {	
filter mediator mediate 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	try {	if (shouldTrace) {	trace.trace("Start : Filter mediator ");	}	if (test(synCtx)) {	
filter condition satisfied executing child mediators 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	try {	if (shouldTrace) {	trace.trace("Start : Filter mediator ");	}	if (test(synCtx)) {	return super.mediate(synCtx);	} else {	
filter condition failed will skip executing child mediators 

public boolean test(MessageContext synCtx) {	try {	if (xpath != null) {	
evaluating xpath expression 

public boolean test(MessageContext synCtx) {	try {	if (xpath != null) {	if (shouldTrace(synCtx.getTracingState())) {	trace.trace("XPath expression : " + xpath + " evaluates to : " + xpath.booleanValueOf(synCtx.getEnvelope()));	}	return xpath.booleanValueOf(synCtx.getEnvelope());	} else if (source != null && regex != null) {	
evaluating regular expression against source 

trace.trace("XPath expression : " + xpath + " evaluates to : " + xpath.booleanValueOf(synCtx.getEnvelope()));	}	return xpath.booleanValueOf(synCtx.getEnvelope());	} else if (source != null && regex != null) {	String sourceString = Axis2MessageContext.getStringValue(source, synCtx);	if (shouldTrace(synCtx.getTracingState())) {	trace.trace("Regular expression : " + regex.pattern() + " and Source " + sourceString + " matches : " + regex.matcher(sourceString).matches());	}	return regex.matcher(sourceString).matches();	} else {	
invalid configuration specified 

} else if (source != null && regex != null) {	String sourceString = Axis2MessageContext.getStringValue(source, synCtx);	if (shouldTrace(synCtx.getTracingState())) {	trace.trace("Regular expression : " + regex.pattern() + " and Source " + sourceString + " matches : " + regex.matcher(sourceString).matches());	}	return regex.matcher(sourceString).matches();	} else {	return false;	}	} catch (JaxenException e) {	
xpath error 

========================= synapse sample_3301 =========================

}	for (Iterator itr = elem.getChildrenWithName(IMPLEMENTATION_Q); itr.hasNext();) {	OMElement implElem = (OMElement) itr.next();	OMAttribute typeAttr = implElem.getAttribute(ATT_TYPE);	OMAttribute sizeAttr = implElem.getAttribute(ATT_SIZE);	if (typeAttr != null && typeAttr.getAttributeValue() != null) {	String type = typeAttr.getAttributeValue();	if (CachingConstants.TYPE_MEMORY.equals(type) && sizeAttr != null && sizeAttr.getAttributeValue() != null) {	cache.setInMemoryCacheSize(Integer.parseInt(sizeAttr.getAttributeValue()));	} else if (CachingConstants.TYPE_DISK.equals(type)) {	
disk based and hirearchycal caching is not implemented yet 

========================= synapse sample_4094 =========================

public static String getProperty(Properties properties, String name, String defaultValue) {	String result = properties.getProperty(name);	if ((result == null || result.length() == 0) && defaultValue != null) {	if (log.isDebugEnabled()) {	
the name with cannot be found using default value 

public static <T extends Object> T getProperty( Properties properties, String name, T defaultValue, Class<? extends T> type) {	String result = properties.getProperty(name);	if (result == null && defaultValue != null) {	if (log.isDebugEnabled()) {	
the name with cannot be found using default value 

public static Properties loadProperties(String filePath) {	Properties properties = new Properties();	ClassLoader cl = Thread.currentThread().getContextClassLoader();	if (log.isDebugEnabled()) {	
loading a file from classpath 

public static Properties loadProperties(String filePath) {	Properties properties = new Properties();	ClassLoader cl = Thread.currentThread().getContextClassLoader();	if (log.isDebugEnabled()) {	}	InputStream in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	
unable to load file 

Properties properties = new Properties();	ClassLoader cl = Thread.currentThread().getContextClassLoader();	if (log.isDebugEnabled()) {	}	InputStream in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	}	filePath = "conf" + File.separatorChar + filePath;	if (log.isDebugEnabled()) {	
loading a file from classpath 

InputStream in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	}	filePath = "conf" + File.separatorChar + filePath;	if (log.isDebugEnabled()) {	}	in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	
unable to load file 

========================= synapse sample_2140 =========================

if (retryDelay != null && retryDelay.getText() != null) {	try {	definition.setRetryDurationOnTimeout( Integer.parseInt(retryDelay.getText().trim()));	} catch (NumberFormatException e) {	handleException("The retry delay for timeouts should be specified " + "as a valid number : " + retryDelay.getText(), e);	}	}	}	OMElement suspendDurationOnFailure = elem.getFirstChildWithName(new QName( SynapseConstants.SYNAPSE_NAMESPACE, "suspendDurationOnFailure"));	if (suspendDurationOnFailure != null && suspendDurationOnFailure.getText() != null) {	
configuration uses deprecated style for endpoint suspenddurationonfailure 

========================= synapse sample_1783 =========================

public MessageContext send(Endpoint endpoint, MessageContext synapseInMsgCtx) throws Exception {	if (log.isDebugEnabled()) {	
start sending the message 

org.apache.axis2.context.MessageContext axisOutMsgCtx = new org.apache.axis2.context.MessageContext();	String endpointReferenceValue = null;	if (endpointDefinition.getAddress() != null) {	endpointReferenceValue = endpointDefinition.getAddress();	} else if (axisInMsgCtx.getTo() != null) {	endpointReferenceValue = axisInMsgCtx.getTo().getAddress();	} else {	handleException("Service url, Endpoint or 'To' header is required");	}	if (log.isDebugEnabled()) {	
epr is set to 

BlockingClientUtils.fillClientOptions(endpointDefinition, clientOptions, synapseInMsgCtx);	AxisService anonymousService = AnonymousServiceFactory.getAnonymousService(null, configurationContext.getAxisConfiguration(), endpointDefinition.isAddressingOn(), endpointDefinition.isSecurityOn(), false);	anonymousService.getParent().addParameter(SynapseConstants.HIDDEN_SERVICE_PARAM, "true");	ServiceGroupContext serviceGroupContext = new ServiceGroupContext(configurationContext, (AxisServiceGroup) anonymousService.getParent());	ServiceContext serviceCtx = serviceGroupContext.getServiceContext(anonymousService);	axisOutMsgCtx.setServiceContext(serviceCtx);	boolean isOutOnly = isOutOnly(synapseInMsgCtx, axisOutMsgCtx);	try {	if (isOutOnly) {	if (log.isDebugEnabled()) {	
invoking service in out only manner 

ServiceContext serviceCtx = serviceGroupContext.getServiceContext(anonymousService);	axisOutMsgCtx.setServiceContext(serviceCtx);	boolean isOutOnly = isOutOnly(synapseInMsgCtx, axisOutMsgCtx);	try {	if (isOutOnly) {	if (log.isDebugEnabled()) {	}	sendRobust(axisOutMsgCtx, clientOptions, anonymousService, serviceCtx);	} else {	if (log.isDebugEnabled()) {	
invoking service in out in manner 

========================= synapse sample_1629 =========================

result = "";	}	} else {	result = value;	}	if (fragmentIndex == URIFragments.FULL_URI) {	URI uri;	if (result != null) {	uri = new URI(result);	if (log.isTraceEnabled()) {	
setting the uri to 

========================= synapse sample_1961 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start aggregate mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

synchronized (lock) {	if (activeAggregates.containsKey(correlateExpression.toString())) {	aggregate = activeAggregates.get(correlateExpression.toString());	if (aggregate != null) {	if (!aggregate.getLock()) {	aggregate = null;	}	}	} else {	if (synLog.isTraceOrDebugEnabled()) {	
creating new aggregator expires in secs without expiry time 

aggregate = activeAggregates.get(correlation);	if (aggregate != null) {	if (!aggregate.getLock()) {	aggregate = null;	}	} else {	break;	}	} else {	if (synLog.isTraceOrDebugEnabled()) {	
creating new aggregator expires in secs without expiry time 

synCtx.getConfiguration().getSynapseTimer(). schedule(aggregate, completionTimeoutMillis);	}	}	}	aggregate.getLock();	activeAggregates.put(correlation, aggregate);	}	}	}	} else {	
unable to find aggrgation correlation property 

}	aggregate.getLock();	activeAggregates.put(correlation, aggregate);	}	}	}	} else {	return true;	}	} else {	
unable to find aggrgation correlation xpath or property 

} else {	return true;	}	} else {	return true;	}	if (aggregate != null) {	boolean collected = aggregate.addMessage(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (collected) {	
collected a message during aggregation 

return true;	}	} else {	return true;	}	if (aggregate != null) {	boolean collected = aggregate.addMessage(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (collected) {	if (synLog.isTraceTraceEnabled()) {	
collected message 

}	if (aggregate != null) {	boolean collected = aggregate.addMessage(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (collected) {	if (synLog.isTraceTraceEnabled()) {	}	}	}	if (aggregate.isComplete(synLog)) {	
aggregation completed invoking oncomplete 

if (aggregate != null) {	boolean collected = aggregate.addMessage(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (collected) {	if (synLog.isTraceTraceEnabled()) {	}	}	}	if (aggregate.isComplete(synLog)) {	completeAggregate(aggregate);	
end aggregate mediator 

}	}	}	if (aggregate.isComplete(synLog)) {	completeAggregate(aggregate);	return true;	} else {	aggregate.releaseLock();	}	} else {	
unable to find an aggregate for this message skip 

return true;	} else {	aggregate.releaseLock();	}	} else {	return true;	}	} catch (JaxenException e) {	handleException("Unable to execute the XPATH over the message", e, synCtx);	}	
end aggregate mediator 

public void completeAggregate(Aggregate aggregate) {	boolean markedCompletedNow = false;	boolean wasComplete = aggregate.isCompleted();	if (wasComplete) {	return;	}	if (log.isDebugEnabled()) {	
aggregation completed or timed out 

aggregate.cancel();	aggregate.setCompleted(true);	markedCompletedNow = true;	}	}	if (!markedCompletedNow) {	return;	}	MessageContext newSynCtx = getAggregatedMessage(aggregate);	if (newSynCtx == null) {	
an aggregation of messages timed out with no aggregated messages 

private MessageContext getAggregatedMessage(Aggregate aggregate) {	MessageContext newCtx = null;	for (MessageContext synCtx : aggregate.getMessages()) {	if (newCtx == null) {	newCtx = synCtx;	if (log.isDebugEnabled()) {	
generating aggregated message from 

private MessageContext getAggregatedMessage(Aggregate aggregate) {	MessageContext newCtx = null;	for (MessageContext synCtx : aggregate.getMessages()) {	if (newCtx == null) {	newCtx = synCtx;	if (log.isDebugEnabled()) {	}	} else {	try {	if (log.isDebugEnabled()) {	
merging message using xpath 

if (newCtx == null) {	newCtx = synCtx;	if (log.isDebugEnabled()) {	}	} else {	try {	if (log.isDebugEnabled()) {	}	EIPUtils.enrichEnvelope( newCtx.getEnvelope(), synCtx.getEnvelope(), synCtx, aggregationExpression);	if (log.isDebugEnabled()) {	
merged result 

========================= synapse sample_555 =========================

public void testURLRewrite() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to the url rewrite mediator 

========================= synapse sample_806 =========================

public static List<AMQPBinding> getBindingsForService(AxisService service) {	Parameter bindingsParam = service.getParameter(AMQPConstants.BINDINGS_PARAM);	ParameterIncludeImpl pi = new ParameterIncludeImpl();	try {	pi.deserializeParameters((OMElement) bindingsParam.getValue());	} catch (AxisFault axisFault) {	
error reading parameters for amqp binding definitions 

========================= synapse sample_4260 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
message store deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try{	MessageStore ms = MessageStoreFactory.createMessageStore(artifactConfig,properties);	if(ms != null) {	ms.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
message store named has been built from the file 

if (log.isDebugEnabled()) {	}	try{	MessageStore ms = MessageStoreFactory.createMessageStore(artifactConfig,properties);	if(ms != null) {	ms.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	ms.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	
initialized the message store 

MessageStore ms = MessageStoreFactory.createMessageStore(artifactConfig,properties);	if(ms != null) {	ms.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	ms.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addMessageStore(ms.getName(), ms);	if (log.isDebugEnabled()) {	
message store deployment from file completed 

if(ms != null) {	ms.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	ms.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addMessageStore(ms.getName(), ms);	if (log.isDebugEnabled()) {	}	
message store named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
message store update from file has started 

if (log.isDebugEnabled()) {	}	try {	MessageStore ms = MessageStoreFactory.createMessageStore(artifactConfig, properties);	if (ms == null) {	handleSynapseArtifactDeploymentError("Message Store update failed. The artifact " + "defined in the file: " + fileName + " is not valid");	return null;	}	ms.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	
messagestore has been built from the file 

handleSynapseArtifactDeploymentError("Message Store update failed. The artifact " + "defined in the file: " + fileName + " is not valid");	return null;	}	ms.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	ms.init(getSynapseEnvironment());	MessageStore existingMs = getSynapseConfiguration().getMessageStore(existingArtifactName);	getSynapseConfiguration().removeMessageStore(existingArtifactName);	getSynapseConfiguration().addMessageStore(ms.getName(), ms);	
messagestore has been undeployed 

handleSynapseArtifactDeploymentError("Message Store update failed. The artifact " + "defined in the file: " + fileName + " is not valid");	return null;	}	ms.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	ms.init(getSynapseEnvironment());	MessageStore existingMs = getSynapseConfiguration().getMessageStore(existingArtifactName);	getSynapseConfiguration().removeMessageStore(existingArtifactName);	getSynapseConfiguration().addMessageStore(ms.getName(), ms);	
messagestore has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
messagestore undeployment of the messagestore named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	MessageStore ms = getSynapseConfiguration().getMessageStore(artifactName);	if (ms != null) {	getSynapseConfiguration().removeMessageStore(artifactName);	if (log.isDebugEnabled()) {	
destroying the messagestore named 

if (log.isDebugEnabled()) {	}	try {	MessageStore ms = getSynapseConfiguration().getMessageStore(artifactName);	if (ms != null) {	getSynapseConfiguration().removeMessageStore(artifactName);	if (log.isDebugEnabled()) {	}	ms.destroy();	if (log.isDebugEnabled()) {	
messagestore undeployment of the endpoint named completed 

}	try {	MessageStore ms = getSynapseConfiguration().getMessageStore(artifactName);	if (ms != null) {	getSynapseConfiguration().removeMessageStore(artifactName);	if (log.isDebugEnabled()) {	}	ms.destroy();	if (log.isDebugEnabled()) {	}	
messagestore named has been undeployed 

try {	MessageStore ms = getSynapseConfiguration().getMessageStore(artifactName);	if (ms != null) {	getSynapseConfiguration().removeMessageStore(artifactName);	if (log.isDebugEnabled()) {	}	ms.destroy();	if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
messagestore has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the messagestore with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	MessageStore ms = getSynapseConfiguration().getMessageStore(artifactName);	OMElement msElem = MessageStoreSerializer.serializeMessageStore(null,ms);	if (ms.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.MESSAGE_STORE_DIR + File.separator + ms.getFileName();	writeToFile(msElem, fileName);	if (log.isDebugEnabled()) {	
restoring the messagestore with name completed 

if (log.isDebugEnabled()) {	}	try {	MessageStore ms = getSynapseConfiguration().getMessageStore(artifactName);	OMElement msElem = MessageStoreSerializer.serializeMessageStore(null,ms);	if (ms.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.MESSAGE_STORE_DIR + File.separator + ms.getFileName();	writeToFile(msElem, fileName);	if (log.isDebugEnabled()) {	}	
messagestore named has been restored 

========================= synapse sample_1598 =========================

org.apache.synapse.MessageContext synCtx = MessageContextCreatorForAxis2.getSynapseMessageContext(messageContext);	if (messageContext.isServerSide()) {	synCtx.setProperty(SynapseConstants.RESPONSE, Boolean.TRUE);	synCtx.setResponse(true);	synCtx.setProperty(SynapseConstants.RESPONSE, Boolean.TRUE);	synCtx.setResponse(true);	try {	if (HandlerUtil.mediateOutMessage(log, messageContext, synCtx)) {	return InvocationResponse.CONTINUE;	} else {	
synapse has decided to abort the message 

}	} catch (SynapseException syne) {	}	} else {	synCtx.setProperty(SynapseConstants.RESPONSE, Boolean.FALSE);	synCtx.setResponse(false);	try {	if (HandlerUtil.mediateInMessage(log, messageContext, synCtx)) {	return InvocationResponse.CONTINUE;	} else {	
synapse has decided to abort the message 

} else {	return InvocationResponse.ABORT;	}	} catch (SynapseException syne) {	}	}	try {	if (synCtx.getEnvironment().injectMessage(synCtx)) {	return InvocationResponse.CONTINUE;	} else {	
synapse has decided to abort the message 

try {	if (synCtx.getEnvironment().injectMessage(synCtx)) {	return InvocationResponse.CONTINUE;	} else {	return InvocationResponse.ABORT;	}	} catch (SynapseException syne) {	if (!synCtx.getFaultStack().isEmpty()) {	((FaultHandler) synCtx.getFaultStack().pop()).handleFault(synCtx, syne);	} else {	
synapse encountered an exception no error handlers found 

========================= synapse sample_1432 =========================

public NativeWorkerPool(int core, int max, int keepAlive, int queueLength, String threadGroupName, String threadGroupId) {	if (log.isDebugEnabled()) {	
using native util concurrent package 

========================= synapse sample_4325 =========================

protected void initInlineScript() {	try {	initScriptEngine();	if (scriptEngine instanceof Compilable) {	if (log.isDebugEnabled()) {	
script engine supports compilable interface compiling script code 

protected void initInlineScript() {	try {	initScriptEngine();	if (scriptEngine instanceof Compilable) {	if (log.isDebugEnabled()) {	}	compiledScript = ((Compilable)scriptEngine).compile(scriptSourceCode);	} else {	if (log.isDebugEnabled()) {	
script engine does not support the compilable interface inlined script would be evaluated on each invocation 

protected void initScriptEngine() {	if (log.isDebugEnabled()) {	
initializing script mediator for language 

protected void initScriptEngine() {	if (log.isDebugEnabled()) {	}	ScriptEngineManager manager = new ScriptEngineManager();	this.scriptEngine = manager.getEngineByExtension(language);	if (scriptEngine == null) {	handleException("No script engine found for language: " + language);	}	xmlHelper = XMLHelper.getArgHelper(scriptEngine);	this.multiThreadedEngine = scriptEngine.getFactory().getParameter("THREADING") != null;	
script mediator for language supports multithreading 

========================= synapse sample_3819 =========================

public static void serializeConfiguration(SynapseConfiguration synCfg, OutputStream outputStream) throws XMLStreamException {	
serializing the xml configuration to the output stream 

========================= synapse sample_3634 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
priorityexecutor deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	PriorityExecutor e = PriorityExecutorFactory.createExecutor( SynapseConstants.SYNAPSE_NAMESPACE, artifactConfig, true, properties);	if (e != null) {	e.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
priorityexecutor with name has been built from the file 

}	try {	PriorityExecutor e = PriorityExecutorFactory.createExecutor( SynapseConstants.SYNAPSE_NAMESPACE, artifactConfig, true, properties);	if (e != null) {	e.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addPriorityExecutor(e.getName(), e);	e.init();	if (log.isDebugEnabled()) {	
priorityexecutor deployment from file completed 

try {	PriorityExecutor e = PriorityExecutorFactory.createExecutor( SynapseConstants.SYNAPSE_NAMESPACE, artifactConfig, true, properties);	if (e != null) {	e.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addPriorityExecutor(e.getName(), e);	e.init();	if (log.isDebugEnabled()) {	}	
priorityexecutor named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
priorityexecutor update from file has started 

if (log.isDebugEnabled()) {	}	try {	PriorityExecutor e = PriorityExecutorFactory.createExecutor( SynapseConstants.SYNAPSE_NAMESPACE, artifactConfig, true, properties);	if (e == null) {	handleSynapseArtifactDeploymentError("PriorityExecutor update failed. The artifact " + "defined in the file: " + fileName + " is not a valid executor.");	return null;	}	e.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	
executor has been built from the file 

e.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	e.init();	PriorityExecutor existingExecutor = getSynapseConfiguration().getPriorityExecutors(). get(existingArtifactName);	if (existingArtifactName.equals(e.getName())) {	getSynapseConfiguration().updatePriorityExecutor(existingArtifactName, e);	} else {	getSynapseConfiguration().addPriorityExecutor(e.getName(), e);	getSynapseConfiguration().removeExecutor(existingArtifactName);	
executor has been undeployed 

e.init();	PriorityExecutor existingExecutor = getSynapseConfiguration().getPriorityExecutors(). get(existingArtifactName);	if (existingArtifactName.equals(e.getName())) {	getSynapseConfiguration().updatePriorityExecutor(existingArtifactName, e);	} else {	getSynapseConfiguration().addPriorityExecutor(e.getName(), e);	getSynapseConfiguration().removeExecutor(existingArtifactName);	}	waitForCompletion();	existingExecutor.destroy();	
priorityexecutor has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
priorityexecutor undeployment of the entry named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	PriorityExecutor e = getSynapseConfiguration().getPriorityExecutors().get(artifactName);	if (e != null) {	e = getSynapseConfiguration().removeExecutor(artifactName);	if (log.isDebugEnabled()) {	
priorityexecutor undeployment of the entry named completed 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	PriorityExecutor e = getSynapseConfiguration().getPriorityExecutors().get(artifactName);	if (e != null) {	e = getSynapseConfiguration().removeExecutor(artifactName);	if (log.isDebugEnabled()) {	}	e.destroy();	
priorityexecutor named has been undeployed 

if (log.isDebugEnabled()) {	}	try {	PriorityExecutor e = getSynapseConfiguration().getPriorityExecutors().get(artifactName);	if (e != null) {	e = getSynapseConfiguration().removeExecutor(artifactName);	if (log.isDebugEnabled()) {	}	e.destroy();	} else if (log.isDebugEnabled()) {	
priorityexecutor has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring priorityexecutor with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	PriorityExecutor e = getSynapseConfiguration().getPriorityExecutors().get(artifactName);	OMElement entryElem = PriorityExecutorSerializer.serialize(null, e, SynapseConstants.SYNAPSE_NAMESPACE);	if (e.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.EXECUTORS_DIR + File.separator + e.getFileName();	writeToFile(entryElem, fileName);	if (log.isDebugEnabled()) {	
restoring the priorityexecutor with name completed 

if (log.isDebugEnabled()) {	}	try {	PriorityExecutor e = getSynapseConfiguration().getPriorityExecutors().get(artifactName);	OMElement entryElem = PriorityExecutorSerializer.serialize(null, e, SynapseConstants.SYNAPSE_NAMESPACE);	if (e.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.EXECUTORS_DIR + File.separator + e.getFileName();	writeToFile(entryElem, fileName);	if (log.isDebugEnabled()) {	}	
priorityexecutor named has been restored 

========================= synapse sample_1609 =========================

private static void selectPort(ConfigurationContext configCtx) {	TransportInDescription trsIn = (TransportInDescription) configCtx.getAxisConfiguration().getTransportsIn().get(new QName("http"));	if (trsIn != null) {	int port = 8080;	String strPort = System.getProperty("port");	if(strPort != null) {	try {	port = new Integer(strPort).intValue();	} catch (NumberFormatException e) {	
given port is not a valid integer port specified in the configuration is used for the server 

========================= synapse sample_3321 =========================

public void init(Properties properties) {	if (initialized) {	if (log.isDebugEnabled()) {	
secret manager already has been started 

public void init(Properties properties) {	if (initialized) {	if (log.isDebugEnabled()) {	}	return;	}	if (properties == null) {	if (log.isDebugEnabled()) {	
keystore configuration properties cannot be found 

}	if (properties == null) {	if (log.isDebugEnabled()) {	}	return;	}	String configurationFile = MiscellaneousUtil.getProperty( properties, PROP_SECRET_MANAGER_CONF, PROP_DEFAULT_CONF_LOCATION);	Properties configurationProperties = MiscellaneousUtil.loadProperties(configurationFile);	if (configurationProperties == null || configurationProperties.isEmpty()) {	if (log.isDebugEnabled()) {	
configuration properties can not be loaded form will use synapse properties 

String configurationFile = MiscellaneousUtil.getProperty( properties, PROP_SECRET_MANAGER_CONF, PROP_DEFAULT_CONF_LOCATION);	Properties configurationProperties = MiscellaneousUtil.loadProperties(configurationFile);	if (configurationProperties == null || configurationProperties.isEmpty()) {	if (log.isDebugEnabled()) {	}	configurationProperties = properties;	}	String repositoriesString = MiscellaneousUtil.getProperty( configurationProperties, PROP_SECRET_REPOSITORIES, null);	if (repositoriesString == null || "".equals(repositoriesString)) {	if (log.isDebugEnabled()) {	
no secret repositories have been configured 

}	String repositoriesString = MiscellaneousUtil.getProperty( configurationProperties, PROP_SECRET_REPOSITORIES, null);	if (repositoriesString == null || "".equals(repositoriesString)) {	if (log.isDebugEnabled()) {	}	return;	}	String[] repositories = repositoriesString.split(",");	if (repositories == null || repositories.length == 0) {	if (log.isDebugEnabled()) {	
no secret repositories have been configured 

}	return;	}	IdentityKeyStoreInformation identityInformation = KeyStoreInformationFactory.createIdentityKeyStoreInformation(properties);	TrustKeyStoreInformation trustInformation = KeyStoreInformationFactory.createTrustKeyStoreInformation(properties);	String identityKeyPass = identityInformation .getKeyPasswordProvider().getResolvedSecret();	String identityStorePass = identityInformation .getKeyStorePasswordProvider().getResolvedSecret();	String trustStorePass = trustInformation .getKeyStorePasswordProvider().getResolvedSecret();	if (!validatePasswords(identityStorePass, identityKeyPass, trustStorePass)) {	if (log.isDebugEnabled()) {	
either identity or trust keystore password is mandatory in order to initialized secret manager 

sb.append(DOT);	sb.append(secretRepo);	String id = sb.toString();	sb.append(DOT);	sb.append(PROP_PROVIDER);	String provider = MiscellaneousUtil.getProperty( configurationProperties, sb.toString(), null);	if (provider == null || "".equals(provider)) {	handleException("Repository provider cannot be null ");	}	if (log.isDebugEnabled()) {	
initiating a file based secret repository 

Object instance = aClass.newInstance();	if (instance instanceof SecretRepositoryProvider) {	SecretRepository secretRepository = ((SecretRepositoryProvider) instance). getSecretRepository(identityKeyStoreWrapper, trustKeyStoreWrapper);	secretRepository.init(configurationProperties, id);	if (parentRepository == null) {	parentRepository = secretRepository;	}	secretRepository.setParent(currentParent);	currentParent = secretRepository;	if (log.isDebugEnabled()) {	
successfully initiate a secret repository provided by 

public String getSecret(String alias) {	if (!initialized || parentRepository == null) {	if (log.isDebugEnabled()) {	
there is no secret repository returning alias itself 

private boolean validatePasswords(String identityStorePass, String identityKeyPass, String trustStorePass) {	boolean isValid = false;	if (trustStorePass != null && !"".equals(trustStorePass)) {	if (log.isDebugEnabled()) {	
trust store password cannot be found 

private boolean validatePasswords(String identityStorePass, String identityKeyPass, String trustStorePass) {	boolean isValid = false;	if (trustStorePass != null && !"".equals(trustStorePass)) {	if (log.isDebugEnabled()) {	}	isValid = true;	} else {	if (identityStorePass != null && !"".equals(identityStorePass) && identityKeyPass != null && !"".equals(identityKeyPass)) {	if (log.isDebugEnabled()) {	
identity store password and identity store private key password cannot be found 

========================= synapse sample_2530 =========================

proxyPort = Integer.parseInt((String) proxyPortParam.getValue());	} else if (System.getProperty("http.proxyPort") != null) {	proxyPort = Integer.parseInt(System.getProperty("http.proxyPort"));	}	Parameter bypassList = transportOut.getParameter("http.nonProxyHosts");	if (bypassList != null) {	proxyBypassList = ((String) bypassList.getValue()).split("\\|");	} else if (System.getProperty("http.nonProxyHosts") != null) {	proxyBypassList = (System.getProperty("http.nonProxyHosts")).split("\\|");	}	
http sender using proxy bypassing 

Parameter param = transportOut.getParameter("warnOnHTTP500");	if (param != null) {	String[] warnOnHttp500 = ((String) param.getValue()).split("\\|");	cfgCtx.setNonReplicableProperty("warnOnHTTP500", warnOnHttp500);	}	try {	String prefix = (sslContext == null ? "http" : "https") + "-Sender I/O dispatcher";	ioReactor = new DefaultConnectingIOReactor( getReactorConfig(), new NativeThreadFactory(new ThreadGroup(prefix + " thread group"), prefix));	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	
system may be unstable ioreactor encountered a checked exception 

cfgCtx.setNonReplicableProperty("warnOnHTTP500", warnOnHttp500);	}	try {	String prefix = (sslContext == null ? "http" : "https") + "-Sender I/O dispatcher";	ioReactor = new DefaultConnectingIOReactor( getReactorConfig(), new NativeThreadFactory(new ThreadGroup(prefix + " thread group"), prefix));	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	return true;	}	public boolean handle(RuntimeException runtimeException) {	
system may be unstable ioreactor encountered a runtime exception 

ioReactor = new DefaultConnectingIOReactor( getReactorConfig(), new NativeThreadFactory(new ThreadGroup(prefix + " thread group"), prefix));	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	return true;	}	public boolean handle(RuntimeException runtimeException) {	return true;	}	});	} catch (IOException e) {	
error starting the ioreactor 

} catch (IOException e) {	}	metrics = new NhttpMetricsCollector(false, transportOut.getName());	handler = new ClientHandler(cfgCtx, metrics);	final IOEventDispatch ioEventDispatch = getEventDispatch( handler, sslContext, sslSetupHandler, getConnectionConfig(), transportOut);	Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	
reactor interrupted 

}	metrics = new NhttpMetricsCollector(false, transportOut.getName());	handler = new ClientHandler(cfgCtx, metrics);	final IOEventDispatch ioEventDispatch = getEventDispatch( handler, sslContext, sslSetupHandler, getConnectionConfig(), transportOut);	Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	} catch (IOException e) {	
encountered an i o error 

if (ccd == null) {	ccd = new ClientConnectionDebug(scd);	scd.setClientConnectionDebug(ccd);	}	ccd.recordRequestStartTime(conn, axis2Req);	msgContext.setProperty(ClientHandler.CLIENT_CONNECTION_DEBUG, ccd);	}	if (conn == null) {	ioReactor.connect(new InetSocketAddress(host, port), null, axis2Req, sessionRequestCallback);	if (log.isDebugEnabled()) {	
a new connection established to 

msgContext.setProperty(ClientHandler.CLIENT_CONNECTION_DEBUG, ccd);	}	if (conn == null) {	ioReactor.connect(new InetSocketAddress(host, port), null, axis2Req, sessionRequestCallback);	if (log.isDebugEnabled()) {	}	} else {	try {	handler.submitRequest(conn, axis2Req);	if (log.isDebugEnabled()) {	
an existing connection reused to 

if (log.isDebugEnabled()) {	}	} else {	try {	handler.submitRequest(conn, axis2Req);	if (log.isDebugEnabled()) {	}	} catch (ConnectionClosedException e) {	ioReactor.connect(new InetSocketAddress(host, port), null, axis2Req, sessionRequestCallback);	if (log.isDebugEnabled()) {	
a new connection established to 

}	} else {	messageFormatter.writeTo(msgContext, format, out, false);	}	}	out.close();	if (lstMetrics != null) {	lstMetrics.incrementMessagesSent();	}	} catch (ProtocolException e) {	
synapse may be trying to send an exact response more than once 

} catch (ProtocolException e) {	} catch (HttpException e) {	if (lstMetrics != null) {	lstMetrics.incrementFaultsSending();	}	handleException("Unexpected HTTP protocol error sending response to : " + worker.getRemoteAddress(), e);	} catch (ConnectionClosedException e) {	if (lstMetrics != null) {	lstMetrics.incrementFaultsSending();	}	
connection closed by client 

boolean handleFault = msgContext.getEnvelope().getBody().hasFault() || msgContext.isProcessingFault();	boolean faultsAsHttp200 = NhttpConstants.TRUE.equals( msgContext.getProperty(NhttpConstants.FAULTS_AS_HTTP_200));	if (handleFault && !faultsAsHttp200) {	httpStatus = HttpStatus.SC_INTERNAL_SERVER_ERROR;	}	Object statusCode = msgContext.getProperty(NhttpConstants.HTTP_SC);	if (statusCode != null) {	try {	httpStatus = Integer.parseInt( msgContext.getProperty(NhttpConstants.HTTP_SC).toString());	} catch (NumberFormatException e) {	
unable to set the http status code from the property with value 

public void stop() {	if (state == BaseConstants.STOPPED) return;	try {	ioReactor.shutdown();	handler.stop();	state = BaseConstants.STOPPED;	} catch (IOException e) {	
error shutting down ioreactor 

private SessionRequestCallback getSessionRequestCallback() {	return new SessionRequestCallback() {	public void completed(SessionRequest request) {	if (log.isDebugEnabled() && request.getSession() != null && request.getSession().getLocalAddress() != null) {	
connected to remote address from local address 

public void maintenenceShutdown(long millis) throws AxisFault {	if (state != BaseConstants.STARTED) return;	try {	long start = System.currentTimeMillis();	ioReactor.shutdown(millis);	state = BaseConstants.STOPPED;	
sender shutdown in s 

========================= synapse sample_1035 =========================

public static String getNameSpaceWithPrefix(String prefix, OMElement elem) {	if (prefix == null || elem == null) {	
searching for null ns prefix and or using null omelement 

========================= synapse sample_3008 =========================

public void testCBR() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test cbr with the switch case mediator using message properties 

========================= synapse sample_851 =========================

public void testScheduledTask() throws Exception {	
waiting seconds for the task to run 

public void testScheduledTask() throws Exception {	Thread.sleep(10000);	int messageCount = getAxis2Server().getMessageCount("SimpleStockQuoteService", "getQuote");	
task sent messages 

========================= synapse sample_2249 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start bean mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	boolean output = false;	switch (action) {	case CREATE: if (synLog.isTraceOrDebugEnabled()) {	
creating a new bean of type with var name 

if (synLog.isTraceTraceEnabled()) {	}	}	boolean output = false;	switch (action) {	case CREATE: if (synLog.isTraceOrDebugEnabled()) {	}	output = mediateCreateBeanAction(synCtx);	break;	case REMOVE: if (synLog.isTraceOrDebugEnabled()) {	
removing the bean with var name 

switch (action) {	case CREATE: if (synLog.isTraceOrDebugEnabled()) {	}	output = mediateCreateBeanAction(synCtx);	break;	case REMOVE: if (synLog.isTraceOrDebugEnabled()) {	}	output = mediateRemoveBeanAction(synCtx);	break;	case SET_PROPERTY: if (synLog.isTraceOrDebugEnabled()) {	
setting property of the bean with var name 

break;	case REMOVE: if (synLog.isTraceOrDebugEnabled()) {	}	output = mediateRemoveBeanAction(synCtx);	break;	case SET_PROPERTY: if (synLog.isTraceOrDebugEnabled()) {	}	output = mediateSetPropertyAction(synCtx);	break;	case GET_PROPERTY: if (synLog.isTraceOrDebugEnabled()) {	
retrieving property of the bean with var name 

}	output = mediateSetPropertyAction(synCtx);	break;	case GET_PROPERTY: if (synLog.isTraceOrDebugEnabled()) {	}	output = mediateGetPropertyAction(synCtx);	break;	default: assert false;	}	if (synLog.isTraceOrDebugEnabled()) {	
end bean mediator 

========================= synapse sample_502 =========================

public BackportWorkerPool(int core, int max, int keepAlive, int queueLength, String threadGroupName, String threadGroupId) {	if (log.isDebugEnabled()) {	
using backport of the util concurrent package 

========================= synapse sample_3788 =========================

public void setType(String type) {	try {	new ContentType(type);	if (log.isDebugEnabled()) {	
content type 

========================= synapse sample_2033 =========================

public boolean mediate(MessageContext synCtx) {	UserTransaction tx = null;	final SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start transaction mediator 

public boolean mediate(MessageContext synCtx) {	UserTransaction tx = null;	final SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

try {	status = tx.getStatus();	} catch (Exception e) {	handleException("Unable to query transaction status", e, synCtx);	}	if (status != Status.STATUS_ACTIVE) throw new SynapseException("No active transaction. Require an active transaction");	} else {	handleException("Invalid transaction mediator action : " + action, synCtx);	}	if (synLog.isTraceOrDebugEnabled()) {	
end transaction mediator 

========================= synapse sample_1920 =========================

public void destroy() {	if (sch != null) {	try {	sch.shutdown();	} catch (SchedulerException e) {	
error shutting down scheduler 

public void init(SynapseEnvironment synapseEnvironment) {	String thisServerName = ServerManager.getInstance().getServerName();	if(thisServerName == null || thisServerName.equals("")) {	try {	InetAddress addr = InetAddress.getLocalHost();	thisServerName = addr.getHostName();	} catch (UnknownHostException e) {	
could not get local host name 

if(thisServerName == null || thisServerName.equals("")) {	try {	InetAddress addr = InetAddress.getLocalHost();	thisServerName = addr.getHostName();	} catch (UnknownHostException e) {	}	if(thisServerName == null || thisServerName.equals("")) {	thisServerName = "localhost";	}	}	
synapse server name 

thisServerName = addr.getHostName();	} catch (UnknownHostException e) {	}	if(thisServerName == null || thisServerName.equals("")) {	thisServerName = "localhost";	}	}	List pinnedServers = getPinnedServers();	if(pinnedServers != null && !pinnedServers.isEmpty()) {	if(!pinnedServers.contains(thisServerName)) {	
server name not in pinned servers list not starting task 

jobDetail.setName(name);	jobDetail.setGroup("synapse.simple.quartz");	jobDetail.setJobClass(SimpleQuartzJob.class);	JobDataMap jdm = new JobDataMap();	jdm.put(SimpleQuartzJob.SYNAPSE_ENVIRONMENT, synapseEnvironment);	jdm.put(SimpleQuartzJob.CLASSNAME, className);	jdm.put(SimpleQuartzJob.PROPERTIES, xmlProperties);	jobDetail.setJobDataMap(jdm);	sch.scheduleJob(jobDetail, trigger);	sch.start();	
scheduled job for class 

jobDetail.setGroup("synapse.simple.quartz");	jobDetail.setJobClass(SimpleQuartzJob.class);	JobDataMap jdm = new JobDataMap();	jdm.put(SimpleQuartzJob.SYNAPSE_ENVIRONMENT, synapseEnvironment);	jdm.put(SimpleQuartzJob.CLASSNAME, className);	jdm.put(SimpleQuartzJob.PROPERTIES, xmlProperties);	jobDetail.setJobDataMap(jdm);	sch.scheduleJob(jobDetail, trigger);	sch.start();	} catch (Exception e) {	
error starting up scheduler 

========================= synapse sample_4221 =========================

public void testRegistryAndXSLTMediator() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to static and dynamic registry resources and using xslt transformations 

========================= synapse sample_847 =========================

public boolean mediate(MessageContext synCtx) {	try {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start xquery mediator 

public boolean mediate(MessageContext synCtx) {	try {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	try {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	
performing xquery using query resource with key 

public boolean mediate(MessageContext synCtx) {	try {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	performQuery(synCtx, synLog);	
end xquery mediator 

private void bindVariable(XQDynamicContext xqDynamicContext, MediatorVariable variable, SynapseLog synLog) throws XQException {	if (variable != null) {	QName name = variable.getName();	int type = variable.getType();	Object value = variable.getValue();	if (value != null && type != -1) {	if (synLog.isTraceOrDebugEnabled()) {	
binding a variable to the dynamiccontext with a name and a value 

========================= synapse sample_1166 =========================

public StatisticsCleaner(StatisticsCollector collector) {	this.collector = collector;	this.cleanInterval = Long.parseLong(SynapsePropertiesLoader.getPropertyValue( CLEAN_INTERVAL, String.valueOf(DEFAULT_CLEAN_INTERVAL)));	this.isCleanEnable = Boolean.parseBoolean( SynapsePropertiesLoader.getPropertyValue( CLEAN_ENABLE, String.valueOf(true)));	if (isCleanEnable) {	if (log.isDebugEnabled()) {	
statistics cleaning is will be occured with interval s 

public void clean() {	try {	if (!isCleanEnable) {	if (log.isDebugEnabled()) {	
statistics cleaning is disabled 

public void clean() {	try {	if (!isCleanEnable) {	if (log.isDebugEnabled()) {	}	return;	}	if (collector == null) {	if (log.isDebugEnabled()) {	
there are no statistics to be cleaned 

}	long currentTime = System.currentTimeMillis();	if (nextTime == -1) {	nextTime = currentTime + cleanInterval;	}	if (nextTime <= currentTime) {	collector.clearStatistics();	nextTime = currentTime + cleanInterval;	} else {	if (log.isDebugEnabled()) {	
there are no expired statistics to be cleaned 

========================= synapse sample_2064 =========================

public DataSource getDataSource(String name) {	if (name == null || "".equals(name)) {	throw new SynapseCommonsException("DataSource name cannot be found.", log);	}	DataSource result = inMemoryDataSourceRepository.lookUp(name);	if (result != null) {	if (log.isDebugEnabled()) {	
datasource is found in the in memory data source repository datasource name is 

DataSource result = inMemoryDataSourceRepository.lookUp(name);	if (result != null) {	if (log.isDebugEnabled()) {	}	return result;	}	if (jndiBasedDataSourceRepository.isInitialized()) {	result = jndiBasedDataSourceRepository.lookUp(name);	if (result != null) {	if (log.isDebugEnabled()) {	
datasource is found in the jndi data source repository datasource name is 

}	if (jndiBasedDataSourceRepository.isInitialized()) {	result = jndiBasedDataSourceRepository.lookUp(name);	if (result != null) {	if (log.isDebugEnabled()) {	}	return result;	}	}	if (log.isDebugEnabled()) {	
cannot find a datasource with name either in in memory or jndi datasource repositories 

public void addDataSourceInformation(DataSourceInformation dataSourceInformation) {	assertDataSourceInformationNull(dataSourceInformation);	String repositoryType = dataSourceInformation.getRepositoryType();	if (log.isDebugEnabled()) {	
registering a datasource in the repository datasource information is 

public void removeDataSourceInformation(DataSourceInformation dataSourceInformation) {	assertDataSourceInformationNull(dataSourceInformation);	String repositoryType = dataSourceInformation.getRepositoryType();	if (log.isDebugEnabled()) {	
un registering a datasource from the repository datasource information is 

public void reConfigure(Properties confProperties) {	if (log.isDebugEnabled()) {	
reconfiguring datasource repositories 

public void clear() {	if (log.isDebugEnabled()) {	
clearing datasource repositories 

========================= synapse sample_2121 =========================

public boolean process(SynapseEnvironment se, SynapseMessage sm) {	
process 

========================= synapse sample_4626 =========================

public void init(ConfigurationContext cfgCtx, TransportInDescription trpInDesc) throws AxisFault {	setTransportName(FIXConstants.TRANSPORT_NAME);	super.init(cfgCtx, trpInDesc);	fixSessionFactory = new FIXSessionFactory(new FIXApplicationFactory(this.cfgCtx, this.workerPool));	FIXTransportSender sender = (FIXTransportSender) cfgCtx. getAxisConfiguration().getTransportOut(FIXConstants.TRANSPORT_NAME).getSender();	sender.setSessionFactory(fixSessionFactory);	
fix transport listener initialized 

========================= synapse sample_4276 =========================

public void testScriptMediationWithRuby() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test using ruby scripts for mediation 

========================= synapse sample_810 =========================

public void onMessage(org.apache.axis2.context.MessageContext messageContext) {	
response received to the callback 

public void onFault(org.apache.axis2.context.MessageContext messageContext) {	
fault received to the callback 

public void onError(Exception e) {	
error inside callback 

========================= synapse sample_2208 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog log = getLog(synCtx);	if (log.isTraceOrDebugEnabled()) {	
start enqueue mediator 

Mediator m = synCtx.getSequence(sequenceName);	if (m != null && m instanceof SequenceMediator) {	MediatorWorker worker = new MediatorWorker(m, synCtx);	try {	executor.execute(worker, priority);	} catch (RejectedExecutionException ex) {	handleException("Unable to process message in priority executor " + executorName + " with priority " + priority + ". Thread pool exhausted.", ex, synCtx);	}	((Axis2MessageContext) synCtx).getAxis2MessageContext().getOperationContext().setProperty( org.apache.axis2.Constants.RESPONSE_WRITTEN, "SKIP");	if (log.isTraceOrDebugEnabled()) {	
end enqueue mediator 

========================= synapse sample_543 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start clone mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	Iterator<Target> iter = targets.iterator();	int i = 0;	while (iter.hasNext()) {	if (synLog.isTraceOrDebugEnabled()) {	
submitting of messages for processing in parallel 

int i = 0;	while (iter.hasNext()) {	if (synLog.isTraceOrDebugEnabled()) {	}	iter.next().mediate(getClonedMessageContext(synCtx, i++, targets.size()));	}	OperationContext opCtx = ((Axis2MessageContext) synCtx).getAxis2MessageContext().getOperationContext();	if (!continueParent && opCtx != null) {	opCtx.setProperty(Constants.RESPONSE_WRITTEN, "SKIP");	}	
end clone mediator 

========================= synapse sample_1977 =========================

Replicator.setAndReplicateState(REMAINING_RETRIES_KEY, definition.getRetriesOnTimeoutBeforeSuspend(), cfgCtx);	Replicator.setAndReplicateState(LAST_SUSPEND_DURATION_KEY, null, cfgCtx);	break;	}	case ST_TIMEOUT: {	Integer retries = (Integer) cfgCtx.getPropertyNonReplicable(REMAINING_RETRIES_KEY);	if (retries == null) {	retries = definition.getRetriesOnTimeoutBeforeSuspend();	}	if (retries <= 0) {	
endpoint has been marked for suspension but no further retries remain thus it will be suspended 

Integer retries = (Integer) cfgCtx.getPropertyNonReplicable(REMAINING_RETRIES_KEY);	if (retries == null) {	retries = definition.getRetriesOnTimeoutBeforeSuspend();	}	if (retries <= 0) {	setState(ST_SUSPENDED);	} else {	Replicator.setAndReplicateState( REMAINING_RETRIES_KEY, (retries - 1), cfgCtx);	long nextRetry = System.currentTimeMillis() + definition.getRetryDurationOnTimeout();	Replicator.setAndReplicateState(NEXT_RETRY_TIME_KEY, nextRetry, cfgCtx);	
endpoint is marked as timeout and will be retried more time s after until its marked suspended for failure 

localRemainingRetries = definition.getRetriesOnTimeoutBeforeSuspend();	localLastSuspendDuration = -1;	break;	}	case ST_TIMEOUT: {	int retries = localRemainingRetries;	if (retries == -1) {	retries = definition.getRetriesOnTimeoutBeforeSuspend();	}	if (retries <= 0) {	
endpoint has been marked for suspension but no further retries remain thus it will be suspended 

case ST_TIMEOUT: {	int retries = localRemainingRetries;	if (retries == -1) {	retries = definition.getRetriesOnTimeoutBeforeSuspend();	}	if (retries <= 0) {	setState(ST_SUSPENDED);	} else {	localRemainingRetries = retries - 1;	localNextRetryTime = System.currentTimeMillis() + definition.getRetryDurationOnTimeout();	
endpoint is marked as timeout and will be retried more time s after until its marked suspended for failure 

public void onSuccess() {	if (isClustered) {	Integer state = (Integer) cfgCtx.getPropertyNonReplicable(STATE_KEY);	if ((state != null) && ((state != ST_ACTIVE) && (state != ST_OFF))) {	
endpoint currently will now be marked active since it processed its last message 

public void onSuccess() {	if (isClustered) {	Integer state = (Integer) cfgCtx.getPropertyNonReplicable(STATE_KEY);	if ((state != null) && ((state != ST_ACTIVE) && (state != ST_OFF))) {	setState(ST_ACTIVE);	}	} else {	if (localState != ST_ACTIVE && localState != ST_OFF) {	
endpoint currently will now be marked active since it processed its last message 

public void onFault() {	
endpoint will be marked suspended as it failed 

public void onTimeout() {	if (log.isDebugEnabled()) {	
endpoint will be marked for suspension due to the occurrence of one of the configured errors 

nextSuspendDuration = SynapseConstants.DEFAULT_ENDPOINT_SUSPEND_TIME;	}	long nextRetryTime = System.currentTimeMillis() + nextSuspendDuration;	if (isClustered) {	Replicator.setAndReplicateState(LAST_SUSPEND_DURATION_KEY, nextSuspendDuration, cfgCtx);	Replicator.setAndReplicateState(NEXT_RETRY_TIME_KEY, nextRetryTime, cfgCtx);	} else {	localLastSuspendDuration = nextSuspendDuration;	localNextRetryTime = nextRetryTime;	}	
suspending endpoint last suspend duration was ms and current suspend duration is ms next retry after 

public boolean readyToSend() {	if (log.isDebugEnabled()) {	
checking if endpoint currently at state can be used now 

} else {	if (state == ST_ACTIVE) {	return true;	} else if (state == ST_OFF) {	return false;	} else if (System.currentTimeMillis() >= nextRetryTime) {	if (state == ST_TIMEOUT) {	remainingRetries--;	Replicator.setAndReplicateState( REMAINING_RETRIES_KEY, remainingRetries, cfgCtx);	if (log.isDebugEnabled()) {	
endpoint which is currently in timeout state is ready to be retried remaining retries before suspension 

} else if (state == ST_OFF) {	return false;	} else if (System.currentTimeMillis() >= nextRetryTime) {	if (state == ST_TIMEOUT) {	remainingRetries--;	Replicator.setAndReplicateState( REMAINING_RETRIES_KEY, remainingRetries, cfgCtx);	if (log.isDebugEnabled()) {	}	} else {	if (log.isDebugEnabled()) {	
endpoint which is currently suspended is ready to be retried now 

}	}	} else {	if (localState == ST_ACTIVE) {	return true;	} else if (localState == ST_OFF) {	return false;	} else if (System.currentTimeMillis() >= localNextRetryTime) {	if (localState == ST_TIMEOUT) {	if (log.isDebugEnabled()) {	
endpoint which is currently in timeout state is ready to be retried remaining retries before suspension 

if (localState == ST_ACTIVE) {	return true;	} else if (localState == ST_OFF) {	return false;	} else if (System.currentTimeMillis() >= localNextRetryTime) {	if (localState == ST_TIMEOUT) {	if (log.isDebugEnabled()) {	}	} else {	if (log.isDebugEnabled()) {	
endpoint which is currently suspended is ready to be retried now 

if (log.isDebugEnabled()) {	}	} else {	if (log.isDebugEnabled()) {	}	}	return true;	}	}	if (log.isDebugEnabled()) {	
endpoint not ready and is currently next retry will be after 

public void switchOff() {	
manually switching off endpoint 

public void switchOn() {	
manually activating endpoint 

========================= synapse sample_241 =========================

public static void convertSOAPFaultToPOX(MessageContext msgCtx) {	SOAPBody body = msgCtx.getEnvelope().getBody();	SOAPFault fault = body.getFault();	if (fault != null) {	OMFactory fac = msgCtx.getEnvelope().getOMFactory();	OMElement faultPayload = fac.createOMElement(new QName("Exception"));	if (fault.getDetail() != null && !fault.getDetail().getText().equals("")) {	String faultDetail = fault.getDetail().getText();	if (log.isDebugEnabled()) {	
setting the fault detail as athe pox fault 

String faultDetail = fault.getDetail().getText();	if (log.isDebugEnabled()) {	}	OMElement om = POXUtils.getOMFromXML(faultDetail);	if(om != null) {	faultPayload.addChild(om);	}	} else if (fault.getReason() != null && !fault.getReason().getText().equals("")) {	String faultReasonValue = fault.getReason().getText();	if (log.isDebugEnabled()) {	
setting the fault reason as athe pox fault 

OMElement om = POXUtils.getOMFromXML(faultDetail);	if(om != null) {	faultPayload.addChild(om);	}	} else if (fault.getReason() != null && !fault.getReason().getText().equals("")) {	String faultReasonValue = fault.getReason().getText();	if (log.isDebugEnabled()) {	}	faultPayload.setText(faultReasonValue);	} else if (log.isDebugEnabled()) {	
couldn t find the fault detail or reason to compose pox fault 

========================= synapse sample_304 =========================

public void init(ConfigurationContext configurationContext, TransportOutDescription transportOutDescription) throws AxisFault {	if (log.isDebugEnabled()) {	
initializing pass through http s sender 

proxyPort = Integer.parseInt((String) proxyPortParam.getValue());	} else if (System.getProperty("http.proxyPort") != null) {	proxyPort = Integer.parseInt(System.getProperty("http.proxyPort"));	}	Parameter bypassList = transportOutDescription.getParameter("http.nonProxyHosts");	if (bypassList != null) {	proxyBypassList = ((String) bypassList.getValue()).split("\\|");	} else if (System.getProperty("http.nonProxyHosts") != null) {	proxyBypassList = (System.getProperty("http.nonProxyHosts")).split("\\|");	}	
http sender using proxy bypassing 

configurationContext.setProperty(PassThroughConstants.PASS_THROUGH_TRANSPORT_WORKER_POOL, targetConfiguration.getWorkerPool());	PassThroughTransportMetricsCollector metrics = new PassThroughTransportMetricsCollector(false, sslContext != null);	TransportView view = new TransportView(null, this, metrics, null);	MBeanRegistrar.getInstance().registerMBean(view, "Transport", "passthru-" + namePrefix.toLowerCase() + "-sender");	targetConfiguration.setMetrics(metrics);	try {	String prefix = namePrefix + "-PT-Sender I/O Dispatcher";	ioReactor = new DefaultConnectingIOReactor( targetConfiguration.getReactorConfig(false), new NativeThreadFactory(new ThreadGroup(prefix + " Thread Group"), prefix));	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	
system may be unstable connectingioreactor encountered a checked exception 

MBeanRegistrar.getInstance().registerMBean(view, "Transport", "passthru-" + namePrefix.toLowerCase() + "-sender");	targetConfiguration.setMetrics(metrics);	try {	String prefix = namePrefix + "-PT-Sender I/O Dispatcher";	ioReactor = new DefaultConnectingIOReactor( targetConfiguration.getReactorConfig(false), new NativeThreadFactory(new ThreadGroup(prefix + " Thread Group"), prefix));	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	return true;	}	public boolean handle(RuntimeException runtimeException) {	
system may be unstable connectingioreactor encountered a runtime exception 

targetConfiguration.setConnections(targetConnections);	deliveryAgent = new DeliveryAgent(targetConfiguration, targetConnections);	connectCallback.setDeliveryAgent(deliveryAgent);	TargetHandler handler = new TargetHandler(deliveryAgent, targetConfiguration);	final IOEventDispatch ioEventDispatch = getEventDispatch(handler, sslContext, sslSetupHandler, targetConfiguration.getConnectionConfig(), transportOutDescription);	Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (Exception ex) {	
exception encountered in the sender no more connections will be initiated by this transport 

deliveryAgent = new DeliveryAgent(targetConfiguration, targetConnections);	connectCallback.setDeliveryAgent(deliveryAgent);	TargetHandler handler = new TargetHandler(deliveryAgent, targetConfiguration);	final IOEventDispatch ioEventDispatch = getEventDispatch(handler, sslContext, sslSetupHandler, targetConfiguration.getConnectionConfig(), transportOutDescription);	Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (Exception ex) {	}	
sender shutdown 

Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (Exception ex) {	}	}	}, "PassThrough" + namePrefix + "Sender");	t.start();	state = BaseConstants.STARTED;	
pass through sender started 

public void stop() {	try {	ioReactor.shutdown();	} catch (IOException e) {	
error shutting down the passthroughhttpsender 

private void sendRequestContent(final MessageContext msgContext) throws AxisFault {	if (Boolean.TRUE.equals(msgContext.getProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED))) {	synchronized (msgContext) {	while (!Boolean.TRUE.equals(msgContext.getProperty("READY2ROCK")) && !Boolean.TRUE.equals(msgContext.getProperty("PASSTHRU_CONNECT_ERROR"))) {	try {	msgContext.wait();	} catch (InterruptedException e) {	
interrupted while waiting for message serialization to complete 

OMOutputFormat format = PassThroughTransportUtils.getOMOutputFormat(msgContext);	formatter.writeTo(msgContext, format, out, false);	}	pipe.setSerializationComplete(true);	out.close();	}	conn.requestOutput();	} else {	if (errorCode != null) {	if (log.isDebugEnabled()) {	
a source connection is closed because of an error in target 

}	pipe.setSerializationComplete(true);	out.close();	}	conn.requestOutput();	} else {	if (errorCode != null) {	if (log.isDebugEnabled()) {	}	} else {	
a source connection is closed because source handler is already in the process of writing a response while another response is submitted 

public void pause() throws AxisFault {	if (state != BaseConstants.STARTED) {	return;	}	state = BaseConstants.PAUSED;	
sender paused 

public void resume() throws AxisFault {	if (state != BaseConstants.PAUSED) {	return;	}	state = BaseConstants.STARTED;	
sender resumed 

public void maintenanceShutdown(long millis) throws AxisFault {	if (state != BaseConstants.STARTED) return;	try {	long start = System.currentTimeMillis();	ioReactor.shutdown(millis);	state = BaseConstants.STOPPED;	
sender shutdown in s 

========================= synapse sample_2336 =========================

public void testDumbClientMode() {	String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test dumb client mode 

========================= synapse sample_2273 =========================

public void rewrite(URIFragments fragments, MessageContext messageContext) throws URISyntaxException {	if (condition != null) {	String uriString = fragments.toURIString();	Map<String, String> headers = getHeaders(messageContext);	EvaluatorContext ctx = new EvaluatorContext(uriString, headers);	ctx.setProperties(((Axis2MessageContext) messageContext).getProperties());	ctx.setMessageContext(((Axis2MessageContext) messageContext).getAxis2MessageContext());	if (log.isTraceEnabled()) {	
evaluating condition with uri 

String uriString = fragments.toURIString();	Map<String, String> headers = getHeaders(messageContext);	EvaluatorContext ctx = new EvaluatorContext(uriString, headers);	ctx.setProperties(((Axis2MessageContext) messageContext).getProperties());	ctx.setMessageContext(((Axis2MessageContext) messageContext).getAxis2MessageContext());	if (log.isTraceEnabled()) {	}	try {	if (!condition.evaluate(ctx)) {	if (log.isTraceEnabled()) {	
condition evaluated to false skipping the current action 

ctx.setMessageContext(((Axis2MessageContext) messageContext).getAxis2MessageContext());	if (log.isTraceEnabled()) {	}	try {	if (!condition.evaluate(ctx)) {	if (log.isTraceEnabled()) {	}	return;	}	if (log.isTraceEnabled()) {	
condition evaluated to true performing the stated action 

}	try {	if (!condition.evaluate(ctx)) {	if (log.isTraceEnabled()) {	}	return;	}	if (log.isTraceEnabled()) {	}	} catch (EvaluatorException e) {	
error while evaluating the condition skipping the rule as it failed 

========================= synapse sample_538 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start in mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	boolean result = true;	if (test(synCtx)) {	
current message is incoming executing child mediators 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	boolean result = true;	if (test(synCtx)) {	result = super.mediate(synCtx);	} else {	
current message is a response skipping child mediators 

SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	boolean result = true;	if (test(synCtx)) {	result = super.mediate(synCtx);	} else {	}	
end in mediator 

========================= synapse sample_492 =========================

private boolean start() {	if (scheduledFuture == null || (scheduledFuture.isCancelled())) {	scheduledFuture = scheduler.scheduleWithFixedDelay(cacheManagingTask, duration, duration, TimeUnit.MINUTES);	
cache manager started 

public boolean wakeUpNow(){	if (scheduledFuture !=null) {	if (!scheduledFuture.isCancelled()) {	scheduledFuture.cancel(DO_NOT_INTERRUPT_IF_RUNNING);	}	scheduledFuture = scheduler.scheduleWithFixedDelay(cacheManagingTask, 0, duration,TimeUnit.MINUTES);	
cache manager wakened up 

public boolean stop(){	if (scheduledFuture !=null && !scheduledFuture.isCancelled()){	scheduledFuture.cancel(DO_NOT_INTERRUPT_IF_RUNNING);	
cache manager stopped 

public void run() {	long start = System.currentTimeMillis();	if (log.isDebugEnabled()) {	
cache manager task started 

}	ManageableCacheValue nextCacheValue;	int cacheSize = cache.getCacheSize();	int numberToRemove = (cacheSize>cacheMaxSize)?  cacheSize - cacheMaxSize: 0;	List<ManageableCacheValue> entriesToRemove = new ArrayList<ManageableCacheValue>();	LRUEntryCollector lruEntryCollector = new LRUEntryCollector(entriesToRemove, numberToRemove);	cache.resetIterator();	while ((cacheSize--) > 0) {	nextCacheValue = cache.getNextCacheValue();	if (nextCacheValue == null) {	
cache manager iteration through cache values done 

int numberToRemove = (cacheSize>cacheMaxSize)?  cacheSize - cacheMaxSize: 0;	List<ManageableCacheValue> entriesToRemove = new ArrayList<ManageableCacheValue>();	LRUEntryCollector lruEntryCollector = new LRUEntryCollector(entriesToRemove, numberToRemove);	cache.resetIterator();	while ((cacheSize--) > 0) {	nextCacheValue = cache.getNextCacheValue();	if (nextCacheValue == null) {	break;	}	if (!nextCacheValue.isValid()) {	
updating invalid cache value by manager 

break;	}	if (!nextCacheValue.isValid()) {	nextCacheValue.updateCacheWithNewValue();	}	if (numberToRemove > 0) {	lruEntryCollector.collectEntriesToRemove(nextCacheValue);	}	}	for (ManageableCacheValue oldCacheValue: entriesToRemove) {	
removing lru value from cache 

nextCacheValue.updateCacheWithNewValue();	}	if (numberToRemove > 0) {	lruEntryCollector.collectEntriesToRemove(nextCacheValue);	}	}	for (ManageableCacheValue oldCacheValue: entriesToRemove) {	oldCacheValue.removeThisCacheValue();	}	if (log.isDebugEnabled()) {	
cache manager task done took ms 

========================= synapse sample_979 =========================

public void testConcurrencyAndRateThrottling() {	String addUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test concurrency throttling and request rate based throttling 

========================= synapse sample_2224 =========================

try {	AMQPTransportHAEntry entry = blockedTasks.take();	if (entry != null) {	Map<String, String> params = connectionFactoryManager. getConnectionFactory(entry.getConnectionFactoryName()).getParameters();	int count = 1;	long retryDuration = initialReconnectDuration;	while (true) {	try {	Thread.sleep(initialReconnectDuration);	new AMQPTransportConnectionFactory(params, es);	
the reconnection attempt was successful 

long retryDuration = initialReconnectDuration;	while (true) {	try {	Thread.sleep(initialReconnectDuration);	new AMQPTransportConnectionFactory(params, es);	break;	} catch (AMQPTransportException e) {	retryDuration = (long) (retryDuration * reconnectionProgressionFactor);	if (retryDuration > maxReconnectionDuration) {	retryDuration = initialReconnectDuration;	
the retry duration exceeded the maximum reconnection duration the retry duration is set to initial reconnection duration value s 

while (true) {	try {	Thread.sleep(initialReconnectDuration);	new AMQPTransportConnectionFactory(params, es);	break;	} catch (AMQPTransportException e) {	retryDuration = (long) (retryDuration * reconnectionProgressionFactor);	if (retryDuration > maxReconnectionDuration) {	retryDuration = initialReconnectDuration;	}	
the reconnection attempt number failed next re try will be after seconds 

} catch (InterruptedException ignore) {	}	}	}	ConcurrentHashMap<String, AMQPTransportConnectionFactory> allFac = connectionFactoryManager.getAllFactories();	for (Map.Entry me : allFac.entrySet()) {	String name = (String) me.getKey();	Map<String, String> param = ((AMQPTransportConnectionFactory) me.getValue()).getParameters();	connectionFactoryManager.removeConnectionFactory(name);	connectionFactoryManager.addConnectionFactory( name, new AMQPTransportConnectionFactory(param, es));	
a new connection factory was created for 

String conFacName = entry.getConnectionFactoryName();	AMQPTransportConnectionFactory cf = connectionFactoryManager. getConnectionFactory(conFacName);	connectionMap.put( entry.getKey(), new AMQPTransportHABrokerEntry(cf.getChannel(), cf.getConnection()));	entry.getLock().release();	while (!blockedTasks.isEmpty()) {	entry = blockedTasks.take();	conFacName = entry.getConnectionFactoryName();	cf = connectionFactoryManager. getConnectionFactory(conFacName);	connectionMap.put( entry.getKey(), new AMQPTransportHABrokerEntry(cf.getChannel(), cf.getConnection()));	if (log.isDebugEnabled()) {	
the worker task with key was combined with a new connection factory 

cf = connectionFactoryManager. getConnectionFactory(conFacName);	connectionMap.put( entry.getKey(), new AMQPTransportHABrokerEntry(cf.getChannel(), cf.getConnection()));	if (log.isDebugEnabled()) {	}	entry.getLock().release();	}	}	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	} catch (AMQPTransportException e) {	
high availability handler just died it s time to reboot the system 

========================= synapse sample_1058 =========================

public boolean process(SynapseEnvironment se, SynapseMessage smc) {	
process 

========================= synapse sample_1367 =========================

public boolean injectMessage(final MessageContext synCtx) {	if (log.isDebugEnabled()) {	
injecting messagecontext 

public boolean injectMessage(final MessageContext synCtx) {	if (log.isDebugEnabled()) {	}	synCtx.setEnvironment(this);	Mediator mandatorySeq = synCtx.getConfiguration().getMandatorySequence();	if (mandatorySeq != null) {	if (log.isDebugEnabled()) {	
start mediating the message in the pre mediate state using the mandatory sequence 

String receivingSequence = (String) synCtx.getProperty(SynapseConstants.RECEIVING_SEQUENCE);	Set keySet = synCtx.getPropertyKeySet();	if (keySet != null) {	keySet.remove(SynapseConstants.RECEIVING_SEQUENCE);	}	String proxyName = (String) synCtx.getProperty(SynapseConstants.PROXY_SERVICE);	if (proxyName == null || "".equals(proxyName)) {	synCtx.pushFaultHandler(new MediatorFaultHandler(synCtx.getFaultSequence()));	if (receivingSequence != null) {	if (log.isDebugEnabled()) {	
using sequence with name for injected message 

String proxyName = (String) synCtx.getProperty(SynapseConstants.PROXY_SERVICE);	if (proxyName == null || "".equals(proxyName)) {	synCtx.pushFaultHandler(new MediatorFaultHandler(synCtx.getFaultSequence()));	if (receivingSequence != null) {	if (log.isDebugEnabled()) {	}	Mediator seqMediator = synCtx.getSequence(receivingSequence);	if (seqMediator != null) {	return seqMediator.mediate(synCtx);	} else {	
cannot find a sequence with name for injecting the response message 

return seqMediator.mediate(synCtx);	} else {	return false;	}	} else {	boolean processed = restHandler.process(synCtx);	if (processed) {	return true;	}	if (log.isDebugEnabled()) {	
using main sequence for injected message 

return synCtx.getMainSequence().mediate(synCtx);	}	}	ProxyService proxyService = synCtx.getConfiguration().getProxyService(proxyName);	if (proxyService != null) {	if (proxyService.getTargetFaultSequence() != null) {	Mediator faultSequence = synCtx.getSequence(proxyService.getTargetFaultSequence());	if (faultSequence != null) {	synCtx.pushFaultHandler(new MediatorFaultHandler(faultSequence));	} else {	
cloud not find any fault sequence named setting the default fault sequence for out path 

synCtx.pushFaultHandler(new MediatorFaultHandler(synCtx.getFaultSequence()));	}	} else if (proxyService.getTargetInLineFaultSequence() != null) {	synCtx.pushFaultHandler( new MediatorFaultHandler(proxyService.getTargetInLineFaultSequence()));	} else {	synCtx.pushFaultHandler(new MediatorFaultHandler(synCtx.getFaultSequence()));	}	Mediator outSequence = getProxyOutSequence(synCtx, proxyService);	if (receivingSequence != null) {	if (log.isDebugEnabled()) {	
using sequence with name for injected message 

synCtx.pushFaultHandler(new MediatorFaultHandler(synCtx.getFaultSequence()));	}	Mediator outSequence = getProxyOutSequence(synCtx, proxyService);	if (receivingSequence != null) {	if (log.isDebugEnabled()) {	}	Mediator seqMediator = synCtx.getSequence(receivingSequence);	if (seqMediator != null) {	seqMediator.mediate(synCtx);	} else {	
cannot find a sequence with name for injecting the message 

Mediator seqMediator = synCtx.getSequence(receivingSequence);	if (seqMediator != null) {	seqMediator.mediate(synCtx);	} else {	return false;	}	} else if (outSequence != null) {	outSequence.mediate(synCtx);	} else {	if (log.isDebugEnabled()) {	
does not specifies an out sequence sending the response back 

public MessageContext createMessageContext() {	if (log.isDebugEnabled()) {	
creating message context 

private Mediator getProxyOutSequence(MessageContext synCtx, ProxyService proxyService) {	String sequenceName = proxyService.getTargetOutSequence();	if (sequenceName != null && !"".equals(sequenceName)) {	Mediator outSequence = synCtx.getSequence(sequenceName);	if (outSequence != null) {	if (log.isDebugEnabled()) {	
using the sequence named for the outgoing message mediation of the proxy service 

private Mediator getProxyOutSequence(MessageContext synCtx, ProxyService proxyService) {	String sequenceName = proxyService.getTargetOutSequence();	if (sequenceName != null && !"".equals(sequenceName)) {	Mediator outSequence = synCtx.getSequence(sequenceName);	if (outSequence != null) {	if (log.isDebugEnabled()) {	}	return outSequence;	} else {	
unable to find the out sequence specified by the name 

if (log.isDebugEnabled()) {	}	return outSequence;	} else {	throw new SynapseException("Unable to find the " + "out-sequence specified by the name " + sequenceName);	}	} else {	Mediator outSequence = proxyService.getTargetInLineOutSequence();	if (outSequence != null) {	if (log.isDebugEnabled()) {	
using the anonymous out sequence specified in the proxy service for outgoing message mediation 

========================= synapse sample_200 =========================

private void setAndReplicateState(String key, Object value) {	if (configCtx != null && key != null && value != null) {	try {	if (log.isDebugEnabled()) {	
going to replicate the property with key value 

========================= synapse sample_4020 =========================

public void init(SynapseEnvironment synapseEnvironment) {	super.init(synapseEnvironment);	Template endpointTemplate = synapseEnvironment.getSynapseConfiguration(). getEndpointTemplate(template);	if (endpointTemplate == null) {	
template cannot be found for the endpoint 

if (entry != null && entry.isDynamic()) {	if (!entry.isCached() || entry.isExpired()) {	reLoad = true;	}	} else {	reLoad = false;	}	}	if (reLoad) {	if (log.isDebugEnabled()) {	
loading template endpoint with key 

reLoad = false;	}	}	if (reLoad) {	if (log.isDebugEnabled()) {	}	Template eprTemplate = synCfg.getEndpointTemplate(template);	if (eprTemplate != null) {	realEndpoint = eprTemplate.create(this, synCfg.getProperties());	} else {	
couldn t retrieve the endpoint template with the key 

public boolean readyToSend() {	if (realEndpoint != null && realEndpoint.readyToSend()) {	if (log.isDebugEnabled()) {	
template endpoint is at ready state 

public boolean readyToSend() {	if (realEndpoint != null && realEndpoint.readyToSend()) {	if (log.isDebugEnabled()) {	}	return true;	}	
template endpoint is not in a ready state to process message 

========================= synapse sample_1672 =========================

} else {	service.printUserWSDL(output, parameterValue);	}	response.addHeader(CONTENT_TYPE, TEXT_XML);	sendResponseAndFinish(response, output.toByteArray(), conn, os, msgContext);	} catch (Exception e) {	handleBrowserException(response, msgContext, conn, os, "Error generating ?wsdl output for service : " + serviceName, e);	}	} else {	if (log.isDebugEnabled()) {	
unable to find service for wsdl generation 

========================= synapse sample_2377 =========================

public MessageContext send(EndpointDefinition endpoint, MessageContext messageIn) throws Exception {	String serviceUrl = endpoint.getAddress();	if(log.isDebugEnabled()) {	
start sending the message 

options.setProperty(Constants.Configuration.DISABLE_SOAP_ACTION, true);	} else {	Axis2MessageContext axis2smc = (Axis2MessageContext) messageOut;	org.apache.axis2.context.MessageContext axis2MessageCtx = axis2smc.getAxis2MessageContext();	axis2MessageCtx.getTransportOut().addParameter( new Parameter(HTTPConstants.OMIT_SOAP_12_ACTION, true));	}	}	org.apache.axis2.context.MessageContext axis2Ctx = ((Axis2MessageContext) messageOut).getAxis2MessageContext();	boolean outOnlyMessage = "true".equals(messageIn.getProperty( SynapseConstants.OUT_ONLY)) || WSDL2Constants.MEP_URI_IN_ONLY.equals( axis2Ctx.getOperationContext() .getAxisOperation().getMessageExchangePattern());	if (log.isDebugEnabled()) {	
invoking service url with message 

if(outOnlyMessage) {	sc.sendRobust(payload);	} else {	result = sc.sendReceive(payload);	}	} catch (Exception axisFault) {	if (!outOnlyMessage) {	messageOut.setProperty(ForwardingProcessorConstants.BLOCKING_SENDER_ERROR, "true");	return messageOut;	}	
error sending message to url 

}	if(!outOnlyMessage) {	if(result != null) {	String soapNamespaceURI = axis2Ctx.getEnvelope().getNamespace().getNamespaceURI();	SOAPEnvelope envelope = createSOAPEnvelope(result , soapNamespaceURI);	axis2Ctx.setEnvelope(envelope);	return messageOut;	}	}	} catch (AxisFault axisFault) {	
error sending message to url 

========================= synapse sample_596 =========================

public RevocationStatus checkRevocationStatus(X509Certificate peerCert, X509Certificate issuerCert) throws CertificateVerificationException {	List<String> list = getCrlDistributionPoints(peerCert);	for (String crlUrl : list) {	if (log.isDebugEnabled()) {	
trying to get crl for url 

public RevocationStatus checkRevocationStatus(X509Certificate peerCert, X509Certificate issuerCert) throws CertificateVerificationException {	List<String> list = getCrlDistributionPoints(peerCert);	for (String crlUrl : list) {	if (log.isDebugEnabled()) {	}	if (cache != null) {	X509CRL x509CRL = cache.getCacheValue(crlUrl);	if (x509CRL != null) {	RevocationStatus status = getRevocationStatus(x509CRL, peerCert);	
crl taken from cache 

try {	X509CRL x509CRL = downloadCRLFromWeb(crlUrl);	if (x509CRL != null) {	if (cache != null) {	cache.setCacheValue(crlUrl, x509CRL);	}	return getRevocationStatus(x509CRL, peerCert);	}	} catch (Exception e) {	if (log.isDebugEnabled()) {	
either the url is bad or cannot build check with the next url in the list 

========================= synapse sample_980 =========================

public boolean mediate(MessageContext synCtx) {	
log mediator mediate 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	if (shouldTrace) {	
start log mediator 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	if (shouldTrace) {	}	String logMessage = getLogMessage(synCtx);	log.info(logMessage);	if (shouldTrace) {	trace.trace(logMessage);	
end log mediator 

========================= synapse sample_3073 =========================

public void testScriptMediationWithInLineRuby() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test using in lined ruby scripts for mediation 

========================= synapse sample_2232 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start callout mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

sc.addHeader((OMElement) headerElements.next());	}	}	}	options.setProperty( AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES, Boolean.TRUE);	sc.setOptions(options);	OMElement request = getRequestPayload(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	synLog.traceOrDebug("About to invoke service : " + getServiceURL() + (getAction() != null ? " with action : " + getAction() : ""));	if (synLog.isTraceTraceEnabled()) {	
request message payload 

}	}	OMElement result = null;	try {	options.setCallTransportCleanup(true);	result = sc.sendReceive(request);	} catch (AxisFault axisFault) {	handleFault(synCtx, axisFault);	}	if (synLog.isTraceTraceEnabled()) {	
response payload received 

tgtNode.insertSiblingAfter(result);	tgtNode.detach();	} else {	handleException("Evaluation of target XPath expression : " + getTargetXPath().toString() + " did not yeild an OMNode", synCtx);	}	}	if (getTargetKey() != null) {	synCtx.setProperty(getTargetKey(), result);	}	} else {	
service returned a null response 

if (getTargetKey() != null) {	synCtx.setProperty(getTargetKey(), result);	}	} else {	}	} catch (AxisFault e) {	handleException("Error invoking service : " + getServiceURL() + (getAction() != null ? " with action : " + getAction() : ""), e, synCtx);	} catch (JaxenException e) {	handleException("Error while evaluating the XPath expression: " + getTargetXPath(), e, synCtx);	}	
end callout mediator 

========================= synapse sample_579 =========================

public static void main(String[] args) throws Exception {	if (args.length <= 0 || args.length == 2 || args.length == 3 || args.length >= 8) {	printUsage();	}	
starting apache synapse 

public static void main(String[] args) throws Exception {	if (args.length <= 0 || args.length == 2 || args.length == 3 || args.length >= 8) {	printUsage();	}	ServerConfigurationInformation configurationInformation = ServerConfigurationInformationFactory.createServerConfigurationInformation(args);	serverManager = new ServerManager();	serverManager.init(configurationInformation, null);	try {	serverManager.start();	addShutdownHook();	
apache synapse started successfully 

printUsage();	}	ServerConfigurationInformation configurationInformation = ServerConfigurationInformationFactory.createServerConfigurationInformation(args);	serverManager = new ServerManager();	serverManager.init(configurationInformation, null);	try {	serverManager.start();	addShutdownHook();	new CountDownLatch(1).await();	} catch (SynapseException e) {	
error starting apache synapse trying a clean shutdown 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	
shutting down apache synapse 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	serverManager.shutdown();	
apache synapse shutdown complete 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	serverManager.shutdown();	
halting jvm 

private static void addShutdownHook() {	Thread shutdownHook = new Thread() {	public void run() {	try {	serverManager.shutdown();	} catch (Exception e) {	
error occurred while shutting down apache synapse it may not be a clean shutdown 

========================= synapse sample_607 =========================

public static void convertSOAP11toSOAP12( org.apache.axis2.context.MessageContext axisOutMsgCtx) throws AxisFault {	if(log.isDebugEnabled()) {	
convert to 

OMAttribute attr = (OMAttribute) allAttributes.next();	if(attr.getNamespace() != null && SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals( attr.getNamespace().getNamespaceURI())) {	String attrName = attr.getLocalName();	if(SOAP_ATR_ACTOR.equals(attrName)) {	OMAttribute newAtr = omNode.getOMFactory().createOMAttribute( SOAP_ATR_ROLE, newEnvelope.getNamespace(), attr.getAttributeValue());	newSOAPHeader.addAttribute(newAtr);	} else if(SOAP_ATR_MUST_UNDERSTAND.equals(attrName)) {	boolean isMustUnderstand = soapHeader.getMustUnderstand();	newSOAPHeader.setMustUnderstand(isMustUnderstand);	} else {	
removed unsupported attribute from soap namespace when converting to soap 

public static void convertSOAP12toSOAP11( org.apache.axis2.context.MessageContext axisOutMsgCtx) throws AxisFault {	if (log.isDebugEnabled()) {	
convert to 

OMAttribute attr = (OMAttribute) allAttributes.next();	if (attr.getNamespace() != null && SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals( attr.getNamespace().getNamespaceURI())) {	String attrName = attr.getLocalName();	if (SOAP_ATR_ROLE.equals(attrName)) {	OMAttribute newAtr = omNode.getOMFactory().createOMAttribute( SOAP_ATR_ACTOR, newEnvelope.getNamespace(), attr.getAttributeValue());	newSOAPHeader.addAttribute(newAtr);	} else if(SOAP_ATR_MUST_UNDERSTAND.equals(attrName)) {	boolean isMustUnderstand = soapHeaderBlock.getMustUnderstand();	newSOAPHeader.setMustUnderstand(isMustUnderstand);	} else {	
removed unsupported attribute from soap namespace when converting to soap 

private static QName getMappingSOAP12Code(QName soap11Code) {	if (S11_FAULTCODE_VERSIONMISMATCH.equals(soap11Code)) {	return S12_FAULTCODE_VERSIONMISMATCH;	} else if (S11_FAULTCODE_MUSTUNDERSTAND.equals(soap11Code)) {	return S12_FAULTCODE_MUSTUNDERSTAND;	} else if (S11_FAULTCODE_CLIENT.equals(soap11Code)) {	return S12_FAULTCODE_SENDER;	} else if (S11_FAULTCODE_SERVER.equals(soap11Code)) {	return S12_FAULTCODE_RECEIVER;	} else {	
an unidentified faultcode encountered returning a blank qname 

private static QName getMappingSOAP11Code(QName soap12Code) {	if (S12_FAULTCODE_VERSIONMISMATCH.equals(soap12Code)) {	return S11_FAULTCODE_VERSIONMISMATCH;	} else if (S12_FAULTCODE_MUSTUNDERSTAND.equals(soap12Code)) {	return S11_FAULTCODE_MUSTUNDERSTAND;	} else if (S12_FAULTCODE_SENDER.equals(soap12Code)) {	return S11_FAULTCODE_SERVER;	} else if (S12_FAULTCODE_RECEIVER.equals(soap12Code)) {	return S11_FAULTCODE_SERVER;	} else if (S12_FAULTCODE_DATAENCODINGUNKNOWN.equals(soap12Code)) {	
there is no matching code value for fault code dataencodingunknown returning a blank qname 

return S11_FAULTCODE_VERSIONMISMATCH;	} else if (S12_FAULTCODE_MUSTUNDERSTAND.equals(soap12Code)) {	return S11_FAULTCODE_MUSTUNDERSTAND;	} else if (S12_FAULTCODE_SENDER.equals(soap12Code)) {	return S11_FAULTCODE_SERVER;	} else if (S12_FAULTCODE_RECEIVER.equals(soap12Code)) {	return S11_FAULTCODE_SERVER;	} else if (S12_FAULTCODE_DATAENCODINGUNKNOWN.equals(soap12Code)) {	return new QName("");	} else {	
an unidentified faultcode encountered returning a blank qname 

========================= synapse sample_1625 =========================

public static String getNameSpaceWithPrefix(String prefix, OMElement elem) {	if (prefix == null || elem == null) {	
searching for null ns prefix and or using null omelement 

========================= synapse sample_3248 =========================

try {	channel.queueDeclare(queueName, false, false, false, null);	QueueingConsumer queueingConsumer = new QueueingConsumer(channel);	channel.basicConsume(queueName, true, queueingConsumer);	QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();	AMQPTransportMessage msg = new AMQPTransportMessage(delivery);	responseMessage.put(msg.getCorrelationId(), msg);	Semaphore semaphore = responseTracker.get(msg.getCorrelationId());	semaphore.release();	} catch (IOException e) {	
i o error occurred 

channel.queueDeclare(queueName, false, false, false, null);	QueueingConsumer queueingConsumer = new QueueingConsumer(channel);	channel.basicConsume(queueName, true, queueingConsumer);	QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();	AMQPTransportMessage msg = new AMQPTransportMessage(delivery);	responseMessage.put(msg.getCorrelationId(), msg);	Semaphore semaphore = responseTracker.get(msg.getCorrelationId());	semaphore.release();	} catch (IOException e) {	} catch (InterruptedException e) {	
retrieving task was interrupted 

channel.basicConsume(queueName, true, queueingConsumer);	QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();	AMQPTransportMessage msg = new AMQPTransportMessage(delivery);	responseMessage.put(msg.getCorrelationId(), msg);	Semaphore semaphore = responseTracker.get(msg.getCorrelationId());	semaphore.release();	} catch (IOException e) {	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	} catch (ShutdownSignalException e) {	
shutdown signal was received for simple consumer task 

========================= synapse sample_2459 =========================

Random random = new Random();	byte[] lockValue = String.valueOf(random.nextLong()).getBytes();	try {	String fullPath = fo.getName().getURI();	int pos = fullPath.indexOf("?");	if (pos != -1) {	fullPath = fullPath.substring(0, pos);	}	FileObject lockObject = fsManager.resolveFile(fullPath + ".lock");	if (lockObject.exists()) {	
there seems to be an external lock aborting the processing of the file this could possibly be due to some other party already processing this file or the file is still being uploaded 

if (lockObject.exists()) {	} else {	lockObject.createFile();	OutputStream stream = lockObject.getContent().getOutputStream();	try {	stream.write(lockValue);	stream.flush();	stream.close();	} catch (IOException e) {	lockObject.delete();	
couldn t create the lock file before processing the file 

return false;	} finally {	lockObject.close();	}	FileObject verifyingLockObject = fsManager.resolveFile( fullPath + ".lock");	if (verifyingLockObject.exists() && verifyLock(lockValue, verifyingLockObject)) {	return true;	}	}	} catch (FileSystemException fse) {	
cannot get the lock for the file before processing 

String fullPath = fo.getName().getURI();	int pos = fullPath.indexOf("?");	if (pos > -1) {	fullPath = fullPath.substring(0, pos);	}	FileObject lockObject = fsManager.resolveFile(fullPath + ".lock");	if (lockObject.exists()) {	lockObject.delete();	}	} catch (FileSystemException e) {	
couldn t release the lock for the file after processing 

private static boolean verifyLock(byte[] lockValue, FileObject lockObject) {	try {	InputStream is = lockObject.getContent().getInputStream();	byte[] val = new byte[lockValue.length];	is.read(val);	if (Arrays.equals(lockValue, val) && is.read() == -1) {	return true;	} else {	
the lock has been acquired by an another party 

private static boolean verifyLock(byte[] lockValue, FileObject lockObject) {	try {	InputStream is = lockObject.getContent().getInputStream();	byte[] val = new byte[lockValue.length];	is.read(val);	if (Arrays.equals(lockValue, val) && is.read() == -1) {	return true;	} else {	}	} catch (FileSystemException e) {	
couldn t verify the lock 

InputStream is = lockObject.getContent().getInputStream();	byte[] val = new byte[lockValue.length];	is.read(val);	if (Arrays.equals(lockValue, val) && is.read() == -1) {	return true;	} else {	}	} catch (FileSystemException e) {	return false;	} catch (IOException e) {	
couldn t verify the lock 

========================= synapse sample_892 =========================

public PipeEndpointListener(PipeEndpoint endpoint, DatagramDispatcherCallback callback) throws IOException {	this.endpoint = endpoint;	this.callback = callback;	pipe = new RandomAccessFile(endpoint.getPipe(), "rw");	FileDescriptor fd = pipe.getFD();	readChannel = new FileInputStream(fd).getChannel();	writeChannel = new FileOutputStream(fd).getChannel();	if (log.isDebugEnabled()) {	
pipe opened 

try {	while (true) {	ProtocolDecoder decoder;	decoder = endpoint.getProtocol().createProtocolDecoder();	while (true) {	while (decoder.inputRequired()) {	int c;	try {	c = readChannel.read(readBuffer);	} catch (IOException ex) {	
error while reading from pipe shutting down listener 

decoder = endpoint.getProtocol().createProtocolDecoder();	while (true) {	while (decoder.inputRequired()) {	int c;	try {	c = readChannel.read(readBuffer);	} catch (IOException ex) {	return;	}	if (c == -1) {	
pipe was unexpectedly closed shutting down listener 

}	byte[] message = decoder.getNext();	callback.receive(endpoint, message, message.length, null);	}	}	}	finally {	try {	pipe.close();	if (log.isDebugEnabled()) {	
pipe closed 

callback.receive(endpoint, message, message.length, null);	}	}	}	finally {	try {	pipe.close();	if (log.isDebugEnabled()) {	}	} catch (IOException ex) {	
error while closing pipe 

public void stop() throws IOException {	if (log.isDebugEnabled()) {	
stopping listener for pipe 

synchronized (guard) {	running = false;	writeChannel.write(ByteBuffer.allocate(1));	}	try {	done.await();	} catch (InterruptedException ex) {	Thread.currentThread().interrupt();	}	if (log.isDebugEnabled()) {	
listener for pipe stopped 

========================= synapse sample_2320 =========================

public void testDynamicSequences() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test dynamic sequences with registry 

========================= synapse sample_2265 =========================

if (keyParam != null) {	OMElement ksEle      = keyParam.getParameterElement().getFirstElement();	String location      = ksEle.getFirstChildWithName(new QName("Location")).getText();	String type          = ksEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = ksEle.getFirstChildWithName(new QName("Password")).getText();	String keyPassword   = ksEle.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading identity keystore from 

String keyPassword   = ksEle.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

}	if (trustParam != null) {	OMElement tsEle      = trustParam.getParameterElement().getFirstElement();	String location      = tsEle.getFirstChildWithName(new QName("Location")).getText();	String type          = tsEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = tsEle.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading trust keystore from 

String storePassword = tsEle.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

fis.close();	} catch (IOException ignore) {}	}	}	}	try {	SSLContext sslcontext = SSLContext.getInstance("TLS");	sslcontext.init(keymanagers, trustManagers, null);	return sslcontext;	} catch (GeneralSecurityException gse) {	
unable to create ssl context with the given configuration 

========================= synapse sample_1019 =========================

if (bindAddressParameter != null) {	this.bindAddress = ((String) bindAddressParameter.getValue()).trim();	}	Parameter hostParameter = parameters.getParameter(TransportListener.HOST_ADDRESS);	if (hostParameter != null) {	host = ((String) hostParameter.getValue()).trim();	} else {	try {	host = java.net.InetAddress.getLocalHost().getHostName();	} catch (UnknownHostException e) {	
unable to lookup local host name using localhost 

========================= synapse sample_939 =========================

public static OMElement getXMLPayload(SOAPEnvelope envelope) {	SOAPBody body = envelope.getBody();	if (body == null) {	
no body found 

public static OMElement getXMLPayload(SOAPEnvelope envelope) {	SOAPBody body = envelope.getBody();	if (body == null) {	return null;	}	OMElement bodyEl = body.getFirstElement();	if (bodyEl == null) {	
no body child found 

public static DataHandler getBinaryPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(BINARYELT)) {	
wrong qname 

public static DataHandler getBinaryPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(BINARYELT)) {	return null;	}	OMNode textNode = el.getFirstOMChild();	if (textNode.getType() != OMNode.TEXT_NODE) {	
text node not found 

}	OMNode textNode = el.getFirstOMChild();	if (textNode.getType() != OMNode.TEXT_NODE) {	return null;	}	OMText text = (OMText) textNode;	DataHandler dh = null;	try {	dh = (DataHandler) text.getDataHandler();	} catch (ClassCastException ce) {	
cannot get datahandler 

public static DataHandler getBinaryPayload(MessageContext mc) {	if (mc.getEnvelope() == null) {	
null envelope 

public static String getTextPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(TEXTELT)) {	
wrong qname 

public static String getTextPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(TEXTELT)) {	return null;	}	OMNode textNode = el.getFirstOMChild();	if (textNode.getType() != OMNode.TEXT_NODE) {	
text node not found 

public static String getTextPayload(MessageContext mc) {	if (mc.getEnvelope() == null) {	
null envelope 

public static SimpleMap getMapPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(MAPELT)) {	
wrong qname 

public static SimpleMap getMapPayload(MessageContext mc) {	if (mc.getEnvelope() == null) {	
null envelope 

public static void setMapPayload(SOAPEnvelope envelope, SimpleMap map) {	if (map instanceof SimpleMapImpl) {	SimpleMapImpl impl = (SimpleMapImpl) map;	OMElement mapElt = impl.getOMElement(envelope.getOMFactory());	if (mapElt == null) {	
null map element returned 

public static XMLStreamReader getStAXPayload(MessageContext mc) {	if (mc.getEnvelope() == null) {	
null envelope 

========================= synapse sample_3530 =========================

public void testRegistryAndXSLTMediator() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to static and dynamic registry resources and using xslt transformations 

========================= synapse sample_2264 =========================

public void writeTo(MessageContext messageContext, OMOutputFormat format, OutputStream outputStream, boolean preserve) throws AxisFault {	try {	if (log.isDebugEnabled()) {	
serialize message in to a gzip stream 

========================= synapse sample_1018 =========================

public void receive(MessageContext mc) throws AxisFault {	
receiving message 

========================= synapse sample_1331 =========================

public void destroy() {	try {	scheduler.deleteJob(new JobKey(name + "-sampling-job", ScheduledMessageProcessor.SCHEDULED_MESSAGE_PROCESSOR_GROUP));	} catch (SchedulerException e) {	
error while destroying the task 

========================= synapse sample_2008 =========================

private static void registerExtensions() {	Iterator<StartupFactory> factories = ServiceLoader.load(StartupFactory.class).iterator();	while (factories.hasNext()) {	StartupFactory factory = factories.next();	QName tag = factory.getTagQName();	factoryMap.put(tag, factory.getClass());	serializerMap.put(tag, factory.getSerializerClass());	if (log.isDebugEnabled()) {	
added startupfactory to handle 

public Startup getStartup(OMElement element, Properties properties) {	QName qName = element.getQName();	if (log.isDebugEnabled()) {	
creating the startup for 

========================= synapse sample_313 =========================

public SourceHandler(SourceConfiguration sourceConfiguration) {	this.sourceConfiguration = sourceConfiguration;	this.metrics = sourceConfiguration.getMetrics();	try {	if (!sourceConfiguration.isSsl()) {	this.latencyView = new LatencyView(sourceConfiguration.isSsl());	} else {	this.s2sLatencyView = new LatencyView(sourceConfiguration.isSsl());	}	} catch (AxisFault e) {	
error while initializing latency view calculators 

request.start(conn);	metrics.incrementMessagesReceived();	String method = request.getRequest() != null ? request.getRequest().getRequestLine().getMethod().toUpperCase() : "";	if ("GET".equals(method)) {	HttpContext context = request.getConnection().getContext();	ContentOutputBuffer outputBuffer = new SimpleOutputBuffer(8192, HeapByteBufferAllocator.INSTANCE);	context.setAttribute(PassThroughConstants.PASS_THROUGH_RESPONSE_SOURCE_BUFFER, outputBuffer);	}	sourceConfiguration.getWorkerPool().execute( new ServerWorker(request, sourceConfiguration));	} catch (HttpException e) {	
http exception while processing request 

metrics.incrementBytesSent(bytesWritten);	}	conn.requestInput();	if (!outBuf.hasData() && encoder.isCompleted()) {	PassThroughTransportUtils.finishUsingSourceConnection(conn.getHttpResponse(), conn, sourceConfiguration.getSourceConnections());	}	}	return;	}	if (protocolState != ProtocolState.RESPONSE_HEAD && protocolState != ProtocolState.RESPONSE_BODY) {	
illegal incoming connection state possibly two send backs are happening for the same request 

public void endOfInput(NHttpServerConnection conn) throws IOException {	ProtocolState state = SourceContext.getState(conn);	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	
keep alive connection was closed by the client 

public void endOfInput(NHttpServerConnection conn) throws IOException {	ProtocolState state = SourceContext.getState(conn);	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_BODY || state == ProtocolState.REQUEST_HEAD) {	informReaderError(conn);	
connection closed by the client while reading the request 

public void endOfInput(NHttpServerConnection conn) throws IOException {	ProtocolState state = SourceContext.getState(conn);	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_BODY || state == ProtocolState.REQUEST_HEAD) {	informReaderError(conn);	} else if (state == ProtocolState.RESPONSE_BODY || state == ProtocolState.RESPONSE_HEAD) {	informWriterError(conn);	
connection closed by the client end while writing the response 

public void endOfInput(NHttpServerConnection conn) throws IOException {	ProtocolState state = SourceContext.getState(conn);	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_BODY || state == ProtocolState.REQUEST_HEAD) {	informReaderError(conn);	} else if (state == ProtocolState.RESPONSE_BODY || state == ProtocolState.RESPONSE_HEAD) {	informWriterError(conn);	} else if (state == ProtocolState.REQUEST_DONE) {	
connection closed by the client after request is read 

public void exception(NHttpServerConnection conn, Exception e) {	if (e instanceof HttpException) {	exception(conn, (HttpException) e);	} else if (e instanceof IOException) {	exception(conn, (IOException) e);	} else {	
unexpected exception encountered in sourcehandler 

public void exception(NHttpServerConnection conn, HttpException e) {	if (log.isDebugEnabled()) {	
http protocol error encountered in sourcehandler 

HttpContext httpContext = conn.getContext();	HttpResponse response = new BasicHttpResponse( HttpVersion.HTTP_1_1, HttpStatus.SC_BAD_REQUEST, "Bad request");	response.addHeader(HTTP.CONN_DIRECTIVE, HTTP.CONN_CLOSE);	httpContext.setAttribute(HttpCoreContext.HTTP_CONNECTION, conn);	httpContext.setAttribute(HttpCoreContext.HTTP_REQUEST, null);	httpContext.setAttribute(HttpCoreContext.HTTP_RESPONSE, response);	try {	sourceConfiguration.getHttpProcessor().process(response, httpContext);	conn.submitResponse(response);	} catch (Exception ex) {	
error while handling httpexception 

public void timeout(NHttpServerConnection conn) {	ProtocolState state = SourceContext.getState(conn);	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	
keep alive connection was time out 

public void timeout(NHttpServerConnection conn) {	ProtocolState state = SourceContext.getState(conn);	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_BODY || state == ProtocolState.REQUEST_HEAD) {	metrics.incrementTimeoutsReceiving();	informReaderError(conn);	
connection time out while reading the request 

public void timeout(NHttpServerConnection conn) {	ProtocolState state = SourceContext.getState(conn);	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_BODY || state == ProtocolState.REQUEST_HEAD) {	metrics.incrementTimeoutsReceiving();	informReaderError(conn);	} else if (state == ProtocolState.RESPONSE_BODY || state == ProtocolState.RESPONSE_HEAD) {	informWriterError(conn);	
connection time out while writing the response 

ProtocolState state = SourceContext.getState(conn);	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_BODY || state == ProtocolState.REQUEST_HEAD) {	metrics.incrementTimeoutsReceiving();	informReaderError(conn);	} else if (state == ProtocolState.RESPONSE_BODY || state == ProtocolState.RESPONSE_HEAD) {	informWriterError(conn);	} else if (state == ProtocolState.REQUEST_DONE){	
connection time out after request is read 

public void closed(NHttpServerConnection conn) {	ProtocolState state = SourceContext.getState(conn);	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	
keep alive connection was closed 

public void closed(NHttpServerConnection conn) {	ProtocolState state = SourceContext.getState(conn);	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_BODY || state == ProtocolState.REQUEST_HEAD) {	informReaderError(conn);	
connection closed while reading the request 

public void closed(NHttpServerConnection conn) {	ProtocolState state = SourceContext.getState(conn);	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_BODY || state == ProtocolState.REQUEST_HEAD) {	informReaderError(conn);	} else if (state == ProtocolState.RESPONSE_BODY || state == ProtocolState.RESPONSE_HEAD) {	informWriterError(conn);	
connection closed while writing the response 

public void closed(NHttpServerConnection conn) {	ProtocolState state = SourceContext.getState(conn);	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_BODY || state == ProtocolState.REQUEST_HEAD) {	informReaderError(conn);	} else if (state == ProtocolState.RESPONSE_BODY || state == ProtocolState.RESPONSE_HEAD) {	informWriterError(conn);	} else if (state == ProtocolState.REQUEST_DONE) {	
connection closed after request is read 

private void handleInvalidState(NHttpServerConnection conn, String action) {	
while the handler is in an inconsistent state 

========================= synapse sample_2376 =========================

public static SynapseConfiguration getConfiguration(InputStream is, Properties properties) throws XMLStreamException {	
generating the synapse configuration model by parsing the xml configuration 

========================= synapse sample_1809 =========================

public void destroy() {	try {	scheduler.deleteJob(new JobKey(name + "-forward job", ScheduledMessageProcessor.SCHEDULED_MESSAGE_PROCESSOR_GROUP));	scheduler.shutdown(true);	} catch (SchedulerException e) {	
error while destroying the task 

========================= synapse sample_597 =========================

if (keyParam != null) {	OMElement ksEle      = keyParam.getParameterElement().getFirstElement();	String location      = ksEle.getFirstChildWithName(new QName("Location")).getText();	String type          = ksEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = ksEle.getFirstChildWithName(new QName("Password")).getText();	String keyPassword   = ksEle.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading identity keystore from 

String keyPassword   = ksEle.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	
error loading keystore 

try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Keystore : " + location, gse);	} catch (IOException ioe) {	
error opening keystore 

}	if (trustParam != null) {	OMElement tsEle      = trustParam.getParameterElement().getFirstElement();	String location      = tsEle.getFirstChildWithName(new QName("Location")).getText();	String type          = tsEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = tsEle.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading trust keystore from 

String storePassword = tsEle.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

fis.close();	} catch (IOException ignore) {}	}	}	}	try {	SSLContext sslcontext = SSLContext.getInstance("TLS");	sslcontext.init(keymanagers, trustManagers, null);	return sslcontext;	} catch (GeneralSecurityException gse) {	
unable to create ssl context with the given configuration 

========================= synapse sample_4308 =========================

private synchronized void replaceNewCacheValue(CRLCacheValue cacheValue) {	if (cacheValue.isValid()) {	return;	}	try {	String crlUrl = cacheValue.crlUrl;	X509CRL x509CRL = crlVerifier.downloadCRLFromWeb(crlUrl);	this.setCacheValue(crlUrl, x509CRL);	} catch (Exception e) {	
cant replace old cachevalue with new cachevalue so remove 

public synchronized void setCacheValue(String crlUrl, X509CRL crl) {	CRLCacheValue cacheValue = new CRLCacheValue(crlUrl, crl);	if (log.isDebugEnabled()) {	
before set hashmap size 

public synchronized void setCacheValue(String crlUrl, X509CRL crl) {	CRLCacheValue cacheValue = new CRLCacheValue(crlUrl, crl);	if (log.isDebugEnabled()) {	}	hashMap.put(crlUrl, cacheValue);	if (log.isDebugEnabled()) {	
after set hashmap size 

public synchronized void removeCacheValue(String crlUrl) {	if (log.isDebugEnabled()) {	
before remove hashmap size 

public synchronized void removeCacheValue(String crlUrl) {	if (log.isDebugEnabled()) {	}	hashMap.remove(crlUrl);	if (log.isDebugEnabled()) {	
after remove hashmap size 

========================= synapse sample_981 =========================

public boolean mediate(MessageContext synCtx) {	
send mediator mediate 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	if (shouldTrace) {	trace.trace("Start : Send mediator");	trace.trace("Sending Message :: " + synCtx.getEnvelope());	}	if (endpoints.isEmpty()) {	
sending message using implicit message properties 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	if (shouldTrace) {	trace.trace("Start : Send mediator");	trace.trace("Sending Message :: " + synCtx.getEnvelope());	}	if (endpoints.isEmpty()) {	log.debug("Sending To: " + (synCtx.getTo() != null ? synCtx.getTo().getAddress() : "null"));	log.debug("SOAPAction: " + (synCtx.getWSAAction() != null ? synCtx.getWSAAction() : "null"));	
body 

} else if (singleEndpoint.isUseSwa()) {	synCtx.setDoingSWA(true);	}	if (singleEndpoint.isUseSeparateListener()) {	synCtx.setProperty(Constants.OUTFLOW_USE_SEPARATE_LISTENER, Boolean.TRUE);	}	log.debug("Sending message to endpoint :: name = " + singleEndpoint.getName() + " resolved address = " + eprAddress);	synCtx.setTo(new EndpointReference(eprAddress));	log.debug("Sending To: " + (synCtx.getTo() != null ? synCtx.getTo().getAddress() : "null"));	log.debug("SOAPAction: " + (synCtx.getWSAAction() != null ? synCtx.getWSAAction() : "null"));	
body 

========================= synapse sample_3072 =========================

public void testSpringBeanAsAMediator() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test spring bean as a mediator 

========================= synapse sample_2233 =========================

public boolean process(SynapseEnvironment se, SynapseMessage smc) {	
process 

========================= synapse sample_1366 =========================

public MessageContext send(Endpoint endpoint, MessageContext synapseInMsgCtx) throws Exception {	if (log.isDebugEnabled()) {	
start sending the message 

org.apache.axis2.context.MessageContext axisOutMsgCtx = new org.apache.axis2.context.MessageContext();	String endpointReferenceValue = null;	if (endpointDefinition.getAddress() != null) {	endpointReferenceValue = endpointDefinition.getAddress();	} else if (axisInMsgCtx.getTo() != null) {	endpointReferenceValue = axisInMsgCtx.getTo().getAddress();	} else {	handleException("Service url, Endpoint or 'To' header is required");	}	if (log.isDebugEnabled()) {	
epr is set to 

BlockingClientUtils.fillClientOptions(endpointDefinition, clientOptions, synapseInMsgCtx);	AxisService anonymousService = AnonymousServiceFactory.getAnonymousService(null, configurationContext.getAxisConfiguration(), endpointDefinition.isAddressingOn(), endpointDefinition.isSecurityOn(), false);	anonymousService.getParent().addParameter(SynapseConstants.HIDDEN_SERVICE_PARAM, "true");	ServiceGroupContext serviceGroupContext = new ServiceGroupContext(configurationContext, (AxisServiceGroup) anonymousService.getParent());	ServiceContext serviceCtx = serviceGroupContext.getServiceContext(anonymousService);	axisOutMsgCtx.setServiceContext(serviceCtx);	boolean isOutOnly = isOutOnly(synapseInMsgCtx, axisOutMsgCtx);	try {	if (isOutOnly) {	if (log.isDebugEnabled()) {	
invoking service in out only manner 

ServiceContext serviceCtx = serviceGroupContext.getServiceContext(anonymousService);	axisOutMsgCtx.setServiceContext(serviceCtx);	boolean isOutOnly = isOutOnly(synapseInMsgCtx, axisOutMsgCtx);	try {	if (isOutOnly) {	if (log.isDebugEnabled()) {	}	sendRobust(axisOutMsgCtx, clientOptions, anonymousService, serviceCtx);	} else {	if (log.isDebugEnabled()) {	
invoking service in out in manner 

========================= synapse sample_201 =========================

public SNMPAgent(Properties properties) {	super(new File(SNMPConstants.BC_FILE), new File(SNMPConstants.CONFIG_FILE), new CommandProcessor(new OctetString(MPv3.createLocalEngineID())));	this.properties = properties;	String version = getProperty(SNMPConstants.SNMP_VERSION, SNMPConstants.SNMP_DEFAULT_VERSION);	if (SNMPConstants.SNMP_VERSION_1.equals(version)) {	this.snmpVersion = SnmpConstants.version1;	} else if (SNMPConstants.SNMP_VERSION_2_C.equals(version)) {	this.snmpVersion = SnmpConstants.version2c;	} else {	
unsupported snmp version using defaults 

protected void initTransportMappings() throws IOException {	String host = getProperty(SNMPConstants.SNMP_HOST, SNMPConstants.SNMP_DEFAULT_HOST);	int port = Integer.parseInt(getProperty(SNMPConstants.SNMP_PORT, String.valueOf(SNMPConstants.SNMP_DEFAULT_PORT)));	String address = host + "/" + port;	Address adr = GenericAddress.parse(address);	TransportMapping tm = TransportMappings.getInstance().createTransportMapping(adr);	transportMappings = new TransportMapping[] { tm };	
snmp transport adapter initialized on udp 

protected void registerManagedObjects() {	
initializing synapse snmp mib 

attributeNames.add(attributeInfo.getName());	if (Map.class.getName().equals(attributeInfo.getType())) {	mapAttributes.add(attributeInfo.getName());	}	}	Collections.sort(attributeNames);	doRegister(attributeNames, mapAttributes, oidString, objectName);	}	}	} catch (Exception e) {	
error while initializing the snmp mib 

private void doRegister(List<String> attributeNames, List<String> mapAttributes, String oidString, ObjectName objectName) {	for (int i = 0; i < attributeNames.size(); i++) {	String attributeName = attributeNames.get(i);	if (mapAttributes.contains(attributeName)) {	continue;	}	OID oid = new OID(oidString + "." + (i + 1) + ".0");	if (log.isDebugEnabled()) {	
registering as oid 

if (mapAttributes.contains(attributeName)) {	continue;	}	OID oid = new OID(oidString + "." + (i + 1) + ".0");	if (log.isDebugEnabled()) {	}	try {	server.register(new SynapseMOScalar( oid, objectName, attributeName, snmpVersion), null);	registeredOIDs.add(oid);	} catch (DuplicateRegistrationException e) {	
error while registering the oid for object and attribute 

protected void unregisterManagedObjects() {	if (log.isDebugEnabled()) {	
cleaning up registered oids 

protected void addCommunities(SnmpCommunityMIB communityMIB) {	String community = getProperty(SNMPConstants.SNMP_COMMUNITY_NAME, SNMPConstants.SNMP_DEFAULT_COMMUNITY_NAME);	String securityName = getProperty(SNMPConstants.SNMP_SECURITY_NAME, SNMPConstants.SNMP_DEFAULT_SECURITY_NAME);	String context = getProperty(SNMPConstants.SNMP_CONTEXT_NAME, SNMPConstants.SNMP_DEFAULT_CONTEXT_NAME);	if (log.isDebugEnabled()) {	
registering snmp community string under the context 

========================= synapse sample_714 =========================

private boolean createDynamicRoute(MessageContext synCtx, ConditionalRouterMediator conditionalRouterMediator) {	String conditionRouts = (String) EIPUtils.lookupFunctionParam(synCtx, "conditions");	String[] conditionsSet = conditionRouts.split(DELIMITER_1);	if (conditionsSet.length == 0) {	
no definitions found for dynamic routing 

========================= synapse sample_581 =========================

public void destroy() {	try {	ServerManager serverManager = ServerManager.getInstance();	serverManager.stop();	servletContext.removeAttribute(ALREADY_INITED);	} catch (Exception e) {	
error stopping the synapse listener manager 

private String loadParameter(ServletConfig servletConfig, String name) throws ServletException {	if (System.getProperty(name) == null) {	String value = servletConfig.getInitParameter(name);	
init parameter 

========================= synapse sample_3988 =========================

public void testAccessingAPIUsingScripting() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test accessing synapse message context api methods using scripting language 

========================= synapse sample_2225 =========================

public boolean mediate(MessageContext synCtx) {	
class mediator mediate 

private void setProperties(Mediator m, MessageContext synCtx, boolean shouldTrace) {	Iterator iter = properties.iterator();	while (iter.hasNext()) {	MediatorProperty mProp = (MediatorProperty) iter.next();	String mName = "set" + Character.toUpperCase(mProp.getName().charAt(0)) + mProp.getName().substring(1);	String value = (mProp.getValue() != null ? mProp.getValue() : Axis2MessageContext.getStringValue(mProp.getExpression(), synCtx));	try {	Method method = m.getClass().getMethod(mName, new Class[] {String.class});	
setting property invoking method 

========================= synapse sample_3064 =========================

public void connected(final NHttpClientConnection conn, final Object attachment) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection connected 

public void closed(final NHttpClientConnection conn) {	if (this.log.isDebugEnabled()) {	
http connection closed 

public void endOfInput(NHttpClientConnection conn) throws IOException {	if (this.log.isDebugEnabled()) {	
http connection closed at remote end 

public void requestReady(final NHttpClientConnection conn) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection inrequest ready 

public void outputReady(final NHttpClientConnection conn, final ContentEncoder encoder) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection output ready 

public void outputReady(final NHttpClientConnection conn, final ContentEncoder encoder) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	}	this.handler.outputReady(conn, encoder);	if (this.log.isDebugEnabled()) {	
http connection content encoder 

public void responseReceived(final NHttpClientConnection conn) throws IOException, HttpException {	HttpResponse response = conn.getHttpResponse();	if (this.log.isDebugEnabled()) {	
http connection 

public void inputReady(final NHttpClientConnection conn, final ContentDecoder decoder) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection input ready 

public void inputReady(final NHttpClientConnection conn, final ContentDecoder decoder) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	}	this.handler.inputReady(conn, decoder);	if (this.log.isDebugEnabled()) {	
http connection content decoder 

public void timeout(final NHttpClientConnection conn) throws IOException, HttpException {	if (this.log.isDebugEnabled()) {	
http connection timeout 

========================= synapse sample_997 =========================

public void send(MessageContext synCtx) {	if (log.isDebugEnabled()) {	
sending using recipient list 

private void sendToDynamicMembers(MessageContext synCtx) {	String dynamicUrlStr = dynamicEndpointSet.evaluateValue(synCtx);	String[] dynamicUrlSet = dynamicUrlStr.split(DELIMITER);	if (dynamicUrlSet.length == 0) {	
no recipients were derived from the expression 

children.add(endpoint);	} else {	children.add(epFromPool);	}	}	}	if (children.size() > 0) {	sendToEndpointList(synCtx, children);	} else {	if (log.isDebugEnabled()) {	
halted sending messages to recipients no recipient found 

private void sendToApplicationMembers(MessageContext synCtx){	int i = 0;	boolean foundEndpoint = false;	for (Member member : members) {	org.apache.axis2.context.MessageContext axis2MsgCtx = ((Axis2MessageContext) synCtx) .getAxis2MessageContext();	String transport = axis2MsgCtx.getTransportIn().getName();	if (!transport.equals("http") && !transport.equals("https")) {	
cannot deliver for non http s transport 

public boolean readyToSend(){	for(Endpoint endpoint : getChildren()){	if(endpoint.readyToSend()){	if (log.isDebugEnabled()) {	
recipient list has at least one endpoint at ready state 

========================= synapse sample_217 =========================

public void stop() {	
stop called 

public void stop() {	if(embedded != null) {	embedded.destroy();	}	
simple axis server quits 

========================= synapse sample_4522 =========================

public boolean process(SynapseEnvironment se, SynapseMessage smc) {	
process 

========================= synapse sample_1370 =========================

if (xpath != null) {	result = xpath.stringValueOf(messageContext);	} else {	result = value;	}	if (fragmentIndex == URIFragments.FULL_URI) {	URI uri;	if (result != null) {	uri = new URI(result);	if (log.isTraceEnabled()) {	
setting the uri to 

========================= synapse sample_4488 =========================

current = members.get(currentMemberIndex);	if (currentMemberIndex == members.size() - 1) {	currentMemberIndex = 0;	} else {	currentMemberIndex++;	}	index--;	} while (current.isSuspended() && index > 0);	algorithmContext.setCurrentEndpointIndex(currentMemberIndex);	if (log.isDebugEnabled()) {	
members 

current = members.get(currentMemberIndex);	if (currentMemberIndex == members.size() - 1) {	currentMemberIndex = 0;	} else {	currentMemberIndex++;	}	index--;	} while (current.isSuspended() && index > 0);	algorithmContext.setCurrentEndpointIndex(currentMemberIndex);	if (log.isDebugEnabled()) {	
current member 

public void reset(AlgorithmContext algorithmContext) {	if (log.isDebugEnabled()) {	
resetting the round robin loadbalancing algorithm 

========================= synapse sample_1665 =========================

public static OMElement getXMLPayload(SOAPEnvelope envelope) {	SOAPBody body = envelope.getBody();	if (body == null) {	
no body found 

public static OMElement getXMLPayload(SOAPEnvelope envelope) {	SOAPBody body = envelope.getBody();	if (body == null) {	return null;	}	OMElement bodyEl = body.getFirstElement();	if (bodyEl == null) {	
no body child found 

public static DataHandler getBinaryPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(BINARYELT)) {	
wrong qname 

public static DataHandler getBinaryPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(BINARYELT)) {	return null;	}	OMNode textNode = el.getFirstOMChild();	if (textNode.getType() != OMNode.TEXT_NODE) {	
text node not found 

}	OMNode textNode = el.getFirstOMChild();	if (textNode.getType() != OMNode.TEXT_NODE) {	return null;	}	OMText text = (OMText) textNode;	DataHandler dh = null;	try {	dh = (DataHandler) text.getDataHandler();	} catch (ClassCastException ce) {	
cannot get datahandler 

public static DataHandler getBinaryPayload(MessageContext mc) {	if (mc.getEnvelope() == null) {	
null envelope 

public static String getTextPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(TEXTELT)) {	
wrong qname 

public static String getTextPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(TEXTELT)) {	return null;	}	OMNode textNode = el.getFirstOMChild();	if (textNode.getType() != OMNode.TEXT_NODE) {	
text node not found 

public static String getTextPayload(MessageContext mc) {	if (mc.getEnvelope() == null) {	
null envelope 

public static SimpleMap getMapPayload(SOAPEnvelope envelope) {	OMElement el = getXMLPayload(envelope);	if (el == null) return null;	if (!el.getQName().equals(MAPELT)) {	
wrong qname 

public static SimpleMap getMapPayload(MessageContext mc) {	if (mc.getEnvelope() == null) {	
null envelope 

public static void setMapPayload(SOAPEnvelope envelope, SimpleMap map) {	if (map instanceof SimpleMapImpl) {	SimpleMapImpl impl = (SimpleMapImpl) map;	OMElement mapElt = impl.getOMElement(envelope.getOMFactory());	if (mapElt == null) {	
null map element returned 

public static XMLStreamReader getStAXPayload(MessageContext mc) {	if (mc.getEnvelope() == null) {	
null envelope 

========================= synapse sample_4037 =========================

public void register(DataSourceInformation dataSourceInformation) {	if (dataSourceInformation == null) {	throw new SynapseCommonsException("DataSourceInformation cannot be found.", log);	}	DataSource dataSource = DataSourceFactory.createDataSource(dataSourceInformation);	if (dataSource == null) {	if (log.isDebugEnabled()) {	
datasource cannot be created or found for datasource information 

throw new SynapseCommonsException("DataSourceInformation cannot be found.", log);	}	DataSource dataSource = DataSourceFactory.createDataSource(dataSourceInformation);	if (dataSource == null) {	if (log.isDebugEnabled()) {	}	return;	}	String name = dataSourceInformation.getDatasourceName();	if (log.isDebugEnabled()) {	
registering a datsource with name in local pool 

public void clear() {	if (!dataSources.isEmpty()) {	
clearing all in memory datasources 

========================= synapse sample_702 =========================

public void addArtifact(String fileName, String artifactName) {	fileName = getNormalizedAbsolutePath(fileName);	if (!fileName2ArtifactName.containsKey(fileName)) {	if (log.isDebugEnabled()) {	
added deployment artifact with file 

public void addArtifact(String fileName, String artifactName) {	fileName = getNormalizedAbsolutePath(fileName);	if (!fileName2ArtifactName.containsKey(fileName)) {	if (log.isDebugEnabled()) {	}	fileName2ArtifactName.put(fileName, artifactName);	} else {	
an artifact has already been loaded from the file 

public void removeArtifactWithFileName(String fileName) {	fileName = getNormalizedAbsolutePath(fileName);	if (log.isDebugEnabled()) {	
removing deployment artifact with file 

public void addUpdatingArtifact(String fileName, String artifactName) {	fileName = getNormalizedAbsolutePath(fileName);	if (log.isDebugEnabled()) {	
added updating file 

public void removeUpdatingArtifact(String fileName) {	fileName = getNormalizedAbsolutePath(fileName);	if (log.isDebugEnabled()) {	
removing the updating file 

public void addRestoredArtifact(String fileName) {	fileName = getNormalizedAbsolutePath(fileName);	if (log.isDebugEnabled()) {	
added restored file 

public void removeRestoredFile(String fileName) {	fileName = getNormalizedAbsolutePath(fileName);	if (log.isDebugEnabled()) {	
removing restored file 

public void addBackedUpArtifact(String fileName) {	fileName = getNormalizedAbsolutePath(fileName);	if (log.isDebugEnabled()) {	
added backup file 

public void removeBackedUpArtifact(String fileName) {	fileName = getNormalizedAbsolutePath(fileName);	if (log.isDebugEnabled()) {	
removing backup file 

public static String getNormalizedAbsolutePath(String fileName) {	String path;	File file = new File(fileName);	try {	path = file.getCanonicalPath();	} catch (IOException e) {	
error while computing the canonical path of file 

========================= synapse sample_186 =========================

public void init(ConfigurationContext cfgCtx, TransportInDescription transportInDescription) throws AxisFault {	if (log.isDebugEnabled()) {	
initializing pass through http s listener 

public void start() throws AxisFault {	
starting pass through listener 

public void start() throws AxisFault {	try {	String prefix = namePrefix + "-PT-Listener I/O Dispatcher";	ioReactor = new DefaultListeningIOReactor( sourceConfiguration.getReactorConfig(true), new NativeThreadFactory(new ThreadGroup(prefix + " Thread Group"), prefix));	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	
system may be unstable listeningioreactor encountered a checked exception 

public void start() throws AxisFault {	try {	String prefix = namePrefix + "-PT-Listener I/O Dispatcher";	ioReactor = new DefaultListeningIOReactor( sourceConfiguration.getReactorConfig(true), new NativeThreadFactory(new ThreadGroup(prefix + " Thread Group"), prefix));	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	return true;	}	public boolean handle(RuntimeException runtimeException) {	
system may be unstable listeningioreactor encountered a runtime exception 

}	HttpGetRequestProcessor getProcessor = sourceConfiguration.getHttpGetRequestProcessor();	if (getProcessor != null){	getProcessor.init(sourceConfiguration.getConfigurationContext(), handler);	}	Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (Exception e) {	
exception encountered in the listener no more connections will be accepted by this transport 

HttpGetRequestProcessor getProcessor = sourceConfiguration.getHttpGetRequestProcessor();	if (getProcessor != null){	getProcessor.init(sourceConfiguration.getConfigurationContext(), handler);	}	Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (Exception e) {	}	
listener shutdown 

try {	ioReactor.execute(ioEventDispatch);	} catch (Exception e) {	}	}	}, "PassThrough" + namePrefix + "Listener");	t.start();	try {	endpoint.waitFor();	} catch (InterruptedException e) {	
pass through listener startup was interrupted 

} catch (Exception e) {	}	}	}, "PassThrough" + namePrefix + "Listener");	t.start();	try {	endpoint.waitFor();	} catch (InterruptedException e) {	}	state = BaseConstants.STARTED;	
pass through listener started on port 

public void stop() throws AxisFault {	
stopping pass through listener 

public void destroy() {	if (log.isDebugEnabled()) {	
destroying pass through listener 

public void pause() throws AxisFault {	if (state != BaseConstants.STARTED) return;	try {	ioReactor.pause();	state = BaseConstants.PAUSED;	
listener paused 

public void maintenanceShutdown(long milliSecs) throws AxisFault {	if (state != BaseConstants.STARTED) return;	try {	long start = System.currentTimeMillis();	ioReactor.pause();	ioReactor.shutdown(milliSecs);	state = BaseConstants.STOPPED;	
listener shutdown in s 

========================= synapse sample_2337 =========================

public boolean mediate(SynapseContext synCtx) {	
mediate 

========================= synapse sample_2788 =========================

result = "";	}	} else {	result = value;	}	if (fragmentIndex == URIFragments.FULL_URI) {	URI uri;	if (result != null) {	uri = new URI(result);	if (log.isTraceEnabled()) {	
setting the uri to 

========================= synapse sample_539 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start filter mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

synLog.traceOrDebug((xpath == null ? "Source : " + source + " against : " + regex.pattern() + " does not match" : "XPath expression : "  + xpath + " evaluates to false") + " - executing the else path child mediators");	}	result = elseMediator.mediate(synCtx);	} else {	if (synLog.isTraceOrDebugEnabled()) {	synLog.traceOrDebug((xpath == null ? "Source : " + source + " against : " + regex.pattern() + " does not match" : "XPath expression : "  + xpath + " evaluates to false and no else path") + " - skipping child mediators");	}	result = true;	}	}	
end filter mediator 

if (xpath != null) {	try {	return xpath.booleanValueOf(synCtx);	} catch (JaxenException e) {	handleException("Error evaluating XPath expression : " + xpath, e, synCtx);	}	} else if (source != null && regex != null) {	String sourceString = source.stringValueOf(synCtx);	if (sourceString == null) {	if (synLog.isTraceOrDebugEnabled()) {	
source string evaluates to null 

} else if (source != null && regex != null) {	String sourceString = source.stringValueOf(synCtx);	if (sourceString == null) {	if (synLog.isTraceOrDebugEnabled()) {	}	return false;	}	Matcher matcher = regex.matcher(sourceString);	if (matcher == null) {	if (synLog.isTraceOrDebugEnabled()) {	
regex pattern matcher for against source is null 

========================= synapse sample_493 =========================

if (entry != null && entry.isDynamic()) {	if (!entry.isCached() || entry.isExpired()) {	reLoad = true;	}	} else {	reLoad = true;	}	}	if (reLoad) {	if (log.isDebugEnabled()) {	
loading real endpoint with key 

========================= synapse sample_240 =========================

}	URL url = SynapseConfigUtils.getURLFromPath(root + key, properties.get( SynapseConstants.SYNAPSE_HOME) != null ? properties.get(SynapseConstants.SYNAPSE_HOME).toString() : "");	if (url == null) {	return null;	}	BufferedInputStream inputStream;	try {	URLConnection connection = SynapseConfigUtils.getURLConnection(url);	if (connection == null) {	if (log.isDebugEnabled()) {	
cannot create a urlconnection for given url 

return null;	}	OMNode result = null;	if (inputStream != null) {	try {	XMLStreamReader parser = XMLInputFactory.newInstance(). createXMLStreamReader(inputStream);	OMXMLParserWrapper builder = OMXMLBuilderFactory.createStAXOMBuilder(parser);	result = builder.getDocumentElement();	} catch (OMException ignored) {	if (log.isDebugEnabled()) {	
the resource at the provided url isn t well formed xml so takes it as a text 

try {	XMLStreamReader parser = XMLInputFactory.newInstance(). createXMLStreamReader(inputStream);	OMXMLParserWrapper builder = OMXMLBuilderFactory.createStAXOMBuilder(parser);	result = builder.getDocumentElement();	} catch (OMException ignored) {	if (log.isDebugEnabled()) {	}	try {	inputStream.close();	} catch (IOException e) {	
error in closing the input stream 

} catch (OMException ignored) {	if (log.isDebugEnabled()) {	}	try {	inputStream.close();	} catch (IOException e) {	}	result = SynapseConfigUtils.readNonXML(url);	} catch (XMLStreamException ignored) {	if (log.isDebugEnabled()) {	
the resource at the provided url isn t well formed xml so takes it as a text 

inputStream.close();	} catch (IOException e) {	}	result = SynapseConfigUtils.readNonXML(url);	} catch (XMLStreamException ignored) {	if (log.isDebugEnabled()) {	}	try {	inputStream.close();	} catch (IOException e) {	
error in closing the input stream 

result = SynapseConfigUtils.readNonXML(url);	} finally {	try {	if (result != null && result.getParent() != null) {	result.detach();	OMDocument omDocument = omFactory.createOMDocument();	omDocument.addChild(result);	}	inputStream.close();	} catch (IOException e) {	
error in closing the input stream 

public RegistryEntry getRegistryEntry(String key) {	if (log.isDebugEnabled()) {	
perform registryentry lookup for key 

public RegistryEntry getRegistryEntry(String key) {	if (log.isDebugEnabled()) {	}	URL url = SynapseConfigUtils.getURLFromPath(root + key, properties.get( SynapseConstants.SYNAPSE_HOME) != null ? properties.get(SynapseConstants.SYNAPSE_HOME).toString() : "");	if (url == null) {	return null;	}	URLConnection connection = SynapseConfigUtils.getURLConnection(url);	if (connection == null) {	if (log.isDebugEnabled()) {	
cannot create a urlconnection for given url 

========================= synapse sample_610 =========================

public static Properties loadSynapseProperties() {	if (reload) {	if (log.isDebugEnabled()) {	
loading synapse properties from a property file 

public static Properties loadSynapseProperties() {	if (reload) {	if (log.isDebugEnabled()) {	}	cacheProperties.putAll(MiscellaneousUtil.loadProperties( SynapseConstants.SYNAPSE_PROPERTIES));	reload = false;	} else {	if (log.isDebugEnabled()) {	
retrieving synapse properties from the cache 

public static Properties reloadSynapseProperties() {	if (log.isDebugEnabled()) {	
reloading synapse properties 

========================= synapse sample_305 =========================

public boolean process(SynapseEnvironment se, SynapseMessage smc) {	if (xp == null) {	
trying to process xpath without being set 

public boolean process(SynapseEnvironment se, SynapseMessage smc) {	if (xp == null) {	return true;	}	try {	if (xp.booleanValueOf(smc.getEnvelope())) {	
matched xpath 

========================= synapse sample_4627 =========================

} catch (Exception e) {	handleException("Error while creating FIX SOAP envelope", e);	}	try {	message = new quickfix.Message(messageString.toString(), null, false);	} catch (InvalidMessage e) {	handleException("Error while creating FIX SOAP envelope", e);	return null;	}	if (log.isDebugEnabled()) {	
creating soap envelope for fix message 

========================= synapse sample_1075 =========================

public void testCallOut() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test simple callout mediator for synchronizing web service invocation 

========================= synapse sample_811 =========================

public void init(ConfigurationContext cfgCtx, TransportOutDescription transportOut) throws AxisFault {	setTransportName(FIXConstants.TRANSPORT_NAME);	super.init(cfgCtx, transportOut);	messageSender = new FIXOutgoingMessageHandler();	
fix transport sender initialized 

public void sendMessage(MessageContext msgCtx, String targetEPR, OutTransportInfo outTransportInfo) throws AxisFault {	if (log.isDebugEnabled()) {	
attempting to send a fix message message id 

}	}	if (!Session.doesSessionExist(sessionID)) {	AxisService service = cfgCtx.getAxisConfiguration().getService(serviceName);	sessionFactory.createFIXInitiator(targetEPR, service, sessionID);	}	try {	messageSender.sendMessage(fixMessage, sessionID, srcSession, counter, msgCtx, targetEPR);	return true;	} catch (SessionNotFound e) {	
error while sending the fix message session does not exist 

AxisService service = cfgCtx.getAxisConfiguration().getService(serviceName);	setDeliverToXFields(fixMessage, service);	}	} else {	setDeliverToXFields(fixMessage, fieldValues);	}	try {	messageSender.sendMessage(fixMessage, sessionID, srcSession, counter, null, null);	return true;	} catch (SessionNotFound e) {	
error while sending the fix message session does not exist 

========================= synapse sample_4277 =========================

factory.createOMText(expiresOm, expires);	OMElement filterOm = factory.createOMElement("Filter", eventingNamespace);	filterOm.addAttribute(factory.createOMAttribute("Dialect", null, "http: factory.createOMText(filterOm, topic);	notifyToOm.addChild(addressOm);	deliveryOm.addChild(notifyToOm);	subscribeOm.addChild(deliveryOm);	if (!(expires.equals("*"))) {	subscribeOm.addChild(expiresOm);	}	subscribeOm.addChild(filterOm);	
subscribing 

deliveryOm.addChild(notifyToOm);	subscribeOm.addChild(deliveryOm);	if (!(expires.equals("*"))) {	subscribeOm.addChild(expiresOm);	}	subscribeOm.addChild(filterOm);	SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	options.setAction("http: OMElement response = serviceClient.sendReceive(subscribeOm);	
subscribed to topic 

}	subscribeOm.addChild(filterOm);	SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	options.setAction("http: OMElement response = serviceClient.sendReceive(subscribeOm);	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	
response received 

subscribeOm.addChild(filterOm);	SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	options.setAction("http: OMElement response = serviceClient.sendReceive(subscribeOm);	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	String subId = response.getFirstChildWithName( new QName(eventingNamespace.getNamespaceURI(), "SubscriptionManager")) .getFirstChildWithName( new QName(addressingNamespace.getNamespaceURI(), "ReferenceParameters")) .getFirstChildWithName( new QName(eventingNamespace.getNamespaceURI(), "Identifier")).getText();	
subscription identifier 

initializeClient(addUrl);	options.setAction("http: OMElement response = serviceClient.sendReceive(subscribeOm);	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	String subId = response.getFirstChildWithName( new QName(eventingNamespace.getNamespaceURI(), "SubscriptionManager")) .getFirstChildWithName( new QName(addressingNamespace.getNamespaceURI(), "ReferenceParameters")) .getFirstChildWithName( new QName(eventingNamespace.getNamespaceURI(), "Identifier")).getText();	clientResult.addProperty("subId", subId);	clientResult.incrementResponseCount();	} catch (Exception e) {	
fault received 

public SampleClientResult unsubscribe(String addUrl, String identifier) {	(01) <s12:Envelope (02)     xmlns:s12="http: (03)     xmlns:wsa="http: (04)     xmlns:wse="http: (05)     xmlns:ow="http: (06)   <s12:Header> (07)     <wsa:Action> (08)       http: (09)     </wsa:Action> (10)     <wsa:MessageID> (11)       uuid:2653f89f-25bc-4c2a-a7c4-620504f6b216 (12)     </wsa:MessageID> (13)     <wsa:ReplyTo> (14)      <wsa:Address>http: (15)     </wsa:ReplyTo> (16)     <wsa:To> (17)       http: (18)     </wsa:To> (19)     <wse:Identifier> (20)       uuid:22e8a584-0d18-4228-b2a8-3716fa2097fa (21)     </wse:Identifier> (22)   </s12:Header> (23)   <s12:Body> (24)     <wse:Unsubscribe /> (25)   </s12:Body> (26) </s12:Envelope>*/ OMElement subscribeOm = factory.createOMElement("Unsubscribe", eventingNamespace);	
unsubscribing 

public SampleClientResult unsubscribe(String addUrl, String identifier) {	(01) <s12:Envelope (02)     xmlns:s12="http: (03)     xmlns:wsa="http: (04)     xmlns:wse="http: (05)     xmlns:ow="http: (06)   <s12:Header> (07)     <wsa:Action> (08)       http: (09)     </wsa:Action> (10)     <wsa:MessageID> (11)       uuid:2653f89f-25bc-4c2a-a7c4-620504f6b216 (12)     </wsa:MessageID> (13)     <wsa:ReplyTo> (14)      <wsa:Address>http: (15)     </wsa:ReplyTo> (16)     <wsa:To> (17)       http: (18)     </wsa:To> (19)     <wse:Identifier> (20)       uuid:22e8a584-0d18-4228-b2a8-3716fa2097fa (21)     </wse:Identifier> (22)   </s12:Header> (23)   <s12:Body> (24)     <wse:Unsubscribe /> (25)   </s12:Body> (26) </s12:Envelope>*/ OMElement subscribeOm = factory.createOMElement("Unsubscribe", eventingNamespace);	SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	options.setAction("http: OMElement identifierOm = factory.createOMElement("Identifier", eventingNamespace);	factory.createOMText(identifierOm, identifier);	serviceClient.addHeader(identifierOm);	OMElement response = serviceClient.sendReceive(subscribeOm);	
unsubscribed to id 

public SampleClientResult unsubscribe(String addUrl, String identifier) {	(01) <s12:Envelope (02)     xmlns:s12="http: (03)     xmlns:wsa="http: (04)     xmlns:wse="http: (05)     xmlns:ow="http: (06)   <s12:Header> (07)     <wsa:Action> (08)       http: (09)     </wsa:Action> (10)     <wsa:MessageID> (11)       uuid:2653f89f-25bc-4c2a-a7c4-620504f6b216 (12)     </wsa:MessageID> (13)     <wsa:ReplyTo> (14)      <wsa:Address>http: (15)     </wsa:ReplyTo> (16)     <wsa:To> (17)       http: (18)     </wsa:To> (19)     <wse:Identifier> (20)       uuid:22e8a584-0d18-4228-b2a8-3716fa2097fa (21)     </wse:Identifier> (22)   </s12:Header> (23)   <s12:Body> (24)     <wse:Unsubscribe /> (25)   </s12:Body> (26) </s12:Envelope>*/ OMElement subscribeOm = factory.createOMElement("Unsubscribe", eventingNamespace);	SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	options.setAction("http: OMElement identifierOm = factory.createOMElement("Identifier", eventingNamespace);	factory.createOMText(identifierOm, identifier);	serviceClient.addHeader(identifierOm);	OMElement response = serviceClient.sendReceive(subscribeOm);	Thread.sleep(1000);	
unsubscribe response received 

SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	options.setAction("http: OMElement identifierOm = factory.createOMElement("Identifier", eventingNamespace);	factory.createOMText(identifierOm, identifier);	serviceClient.addHeader(identifierOm);	OMElement response = serviceClient.sendReceive(subscribeOm);	Thread.sleep(1000);	clientResult.incrementResponseCount();	} catch (Exception e) {	
fault received 

public SampleClientResult renew(String addUrl, String expires, String identifier) {	(02)     xmlns:s12="http: (03)     xmlns:wsa="http: (04)     xmlns:wse="http: (05)     xmlns:ow="http: (06)   <s12:Header> (07)     <wsa:Action> (08)       http: (09)     </wsa:Action> (10)     <wsa:MessageID> (11)       uuid:bd88b3df-5db4-4392-9621-aee9160721f6 (12)     </wsa:MessageID> (13)     <wsa:ReplyTo> (14)      <wsa:Address>http: (15)     </wsa:ReplyTo> (16)     <wsa:To> (17)       http: (18)     </wsa:To> (19)     <wse:Identifier> (20)       uuid:22e8a584-0d18-4228-b2a8-3716fa2097fa (21)     </wse:Identifier> (22)   </s12:Header> (23)   <s12:Body> (24)     <wse:Renew> (25)       <wse:Expires>2004-06-26T21:07:00.000-08:00</wse:Expires> (26)     </wse:Renew> (27)   </s12:Body> (28) </s12:Envelope> OMElement subscribeOm = factory.createOMElement("Renew", eventingNamespace);	OMElement expiresOm = factory.createOMElement("Expires", eventingNamespace);	factory.createOMText(expiresOm, expires);	subscribeOm.addChild(expiresOm);	
synapsesubscription renew 

OMElement expiresOm = factory.createOMElement("Expires", eventingNamespace);	factory.createOMText(expiresOm, expires);	subscribeOm.addChild(expiresOm);	SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	OMElement identifierOm = factory.createOMElement("Identifier", eventingNamespace);	factory.createOMText(identifierOm, identifier);	serviceClient.addHeader(identifierOm);	options.setAction("http: OMElement response = serviceClient.sendReceive(subscribeOm);	
synapsesubscription renew to id 

try {	initializeClient(addUrl);	OMElement identifierOm = factory.createOMElement("Identifier", eventingNamespace);	factory.createOMText(identifierOm, identifier);	serviceClient.addHeader(identifierOm);	options.setAction("http: OMElement response = serviceClient.sendReceive(subscribeOm);	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	
synapsesubscription renew response received 

OMElement identifierOm = factory.createOMElement("Identifier", eventingNamespace);	factory.createOMText(identifierOm, identifier);	serviceClient.addHeader(identifierOm);	options.setAction("http: OMElement response = serviceClient.sendReceive(subscribeOm);	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	clientResult.incrementResponseCount();	} catch (Exception e) {	
fault received 

public SampleClientResult getStatus(String addUrl, String identifier) {	(02)     xmlns:s12="http: (03)     xmlns:wsa="http: (04)     xmlns:wse="http: (05)     xmlns:ow="http: (06)   <s12:Header> (07)     <wsa:Action> (08)       http: (09)     </wsa:Action> (10)     <wsa:MessageID> (11)       uuid:bd88b3df-5db4-4392-9621-aee9160721f6 (12)     </wsa:MessageID> (13)     <wsa:ReplyTo> (14)       <wsa:Address>http: (15)     </wsa:ReplyTo> (16)     <wsa:To> (17)       http: (18)     </wsa:To> (19)     <wse:Identifier> (20)       uuid:22e8a584-0d18-4228-b2a8-3716fa2097fa (21)     </wse:Identifier> (22)   </s12:Header> (23)   <s12:Body> (24)     <wse:GetStatus /> (25)   </s12:Body> (26) </s12:Envelope> OMElement subscribeOm = factory.createOMElement("GetStatus", eventingNamespace);	
getstatus using 

public SampleClientResult getStatus(String addUrl, String identifier) {	(02)     xmlns:s12="http: (03)     xmlns:wsa="http: (04)     xmlns:wse="http: (05)     xmlns:ow="http: (06)   <s12:Header> (07)     <wsa:Action> (08)       http: (09)     </wsa:Action> (10)     <wsa:MessageID> (11)       uuid:bd88b3df-5db4-4392-9621-aee9160721f6 (12)     </wsa:MessageID> (13)     <wsa:ReplyTo> (14)       <wsa:Address>http: (15)     </wsa:ReplyTo> (16)     <wsa:To> (17)       http: (18)     </wsa:To> (19)     <wse:Identifier> (20)       uuid:22e8a584-0d18-4228-b2a8-3716fa2097fa (21)     </wse:Identifier> (22)   </s12:Header> (23)   <s12:Body> (24)     <wse:GetStatus /> (25)   </s12:Body> (26) </s12:Envelope> OMElement subscribeOm = factory.createOMElement("GetStatus", eventingNamespace);	SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	options.setAction("http: OMElement identifierOm = factory.createOMElement("Identifier", eventingNamespace);	factory.createOMText(identifierOm, identifier);	serviceClient.addHeader(identifierOm);	OMElement response = serviceClient.sendReceive(subscribeOm);	
getstatus to id 

try {	initializeClient(addUrl);	options.setAction("http: OMElement identifierOm = factory.createOMElement("Identifier", eventingNamespace);	factory.createOMText(identifierOm, identifier);	serviceClient.addHeader(identifierOm);	OMElement response = serviceClient.sendReceive(subscribeOm);	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	
getstatus response received 

options.setAction("http: OMElement identifierOm = factory.createOMElement("Identifier", eventingNamespace);	factory.createOMText(identifierOm, identifier);	serviceClient.addHeader(identifierOm);	OMElement response = serviceClient.sendReceive(subscribeOm);	try {	Thread.sleep(1000);	} catch (InterruptedException e) {	}	clientResult.incrementResponseCount();	} catch (Exception e) {	
fault received 

public SampleClientResult sendEvent(String addUrl, String symbol, String price, String qty, String topic, String topicns) {	SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	OMNamespace aipNamespace = factory.createOMNamespace(topicns, "aip");	OMElement topicOm = factory.createOMElement("Topic", aipNamespace);	factory.createOMText(topicOm, topic);	serviceClient.addHeader(topicOm);	options.setProperty(MessageContext.CLIENT_API_NON_BLOCKING, Boolean.FALSE);	OMElement payload = AXIOMUtil.stringToOM("<m:placeOrder xmlns:m=\"http: "    <m:order>\n" + "        <m:price>" + price + "</m:price>\n" + "        <m:quantity>" + qty + "</m:quantity>\n" + "        <m:symbol>" + symbol + "</m:symbol>\n" + "    </m:order>\n" + "</m:placeOrder>");	
sending event 

SampleClientResult clientResult = new SampleClientResult();	try {	initializeClient(addUrl);	OMNamespace aipNamespace = factory.createOMNamespace(topicns, "aip");	OMElement topicOm = factory.createOMElement("Topic", aipNamespace);	factory.createOMText(topicOm, topic);	serviceClient.addHeader(topicOm);	options.setProperty(MessageContext.CLIENT_API_NON_BLOCKING, Boolean.FALSE);	OMElement payload = AXIOMUtil.stringToOM("<m:placeOrder xmlns:m=\"http: "    <m:order>\n" + "        <m:price>" + price + "</m:price>\n" + "        <m:quantity>" + qty + "</m:quantity>\n" + "        <m:symbol>" + symbol + "</m:symbol>\n" + "    </m:order>\n" + "</m:placeOrder>");	serviceClient.fireAndForget(payload);	
event sent to topic 

OMNamespace aipNamespace = factory.createOMNamespace(topicns, "aip");	OMElement topicOm = factory.createOMElement("Topic", aipNamespace);	factory.createOMText(topicOm, topic);	serviceClient.addHeader(topicOm);	options.setProperty(MessageContext.CLIENT_API_NON_BLOCKING, Boolean.FALSE);	OMElement payload = AXIOMUtil.stringToOM("<m:placeOrder xmlns:m=\"http: "    <m:order>\n" + "        <m:price>" + price + "</m:price>\n" + "        <m:quantity>" + qty + "</m:quantity>\n" + "        <m:symbol>" + symbol + "</m:symbol>\n" + "    </m:order>\n" + "</m:placeOrder>");	serviceClient.fireAndForget(payload);	Thread.sleep(1000);	clientResult.incrementResponseCount();	} catch (Exception e) {	
fault received 

========================= synapse sample_2209 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	
start send mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceTraceEnabled()) {	}	if (receivingSequence != null) {	if (synLog.isTraceOrDebugEnabled()) {	
receiving sequence is set to 

}	if (endpoint == null) {	if (synLog.isTraceOrDebugEnabled()) {	StringBuffer sb = new StringBuffer();	sb.append("Sending ").append(synCtx.isResponse() ? "response" : "request") .append(" message using implicit message properties..");	sb.append("\nSending To: ").append(synCtx.getTo() != null ? synCtx.getTo().getAddress() : "null");	sb.append("\nSOAPAction: ").append(synCtx.getWSAAction() != null ? synCtx.getWSAAction() : "null");	synLog.traceOrDebug(sb.toString());	}	if (synLog.isTraceTraceEnabled()) {	
envelope 

sb.append("\nSending To: ").append(synCtx.getTo() != null ? synCtx.getTo().getAddress() : "null");	sb.append("\nSOAPAction: ").append(synCtx.getWSAAction() != null ? synCtx.getWSAAction() : "null");	synLog.traceOrDebug(sb.toString());	}	if (synLog.isTraceTraceEnabled()) {	}	synCtx.getEnvironment().send(null, synCtx);	} else {	endpoint.send(synCtx);	}	
end send mediator 

========================= synapse sample_542 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start iterate mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	try {	SOAPEnvelope envelope = MessageHelper.cloneSOAPEnvelope(synCtx.getEnvelope());	List splitElements = EIPUtils.getDetachedMatchingElements(envelope, synCtx, expression);	if (synLog.isTraceOrDebugEnabled()) {	
splitting with xpath resulted in elements 

if (!preservePayload && envelope.getBody() != null) {	envelope.getBody().removeChildren();	}	int msgCount = splitElements.size();	int msgNumber = 0;	for (Object o : splitElements) {	if (!(o instanceof OMNode)) {	handleException("Error splitting message with XPath : " + expression + " - result not an OMNode", synCtx);	}	if (synLog.isTraceOrDebugEnabled()) {	
submitting of messages for processing in parallel messages for processing sequentially 

}	} catch (JaxenException e) {	handleException("Error evaluating split XPath expression : " + expression, e, synCtx);	} catch (AxisFault af) {	handleException("Error creating an iterated copy of the message", af, synCtx);	}	OperationContext opCtx = ((Axis2MessageContext) synCtx).getAxis2MessageContext().getOperationContext();	if (!continueParent && opCtx != null) {	opCtx.setProperty(Constants.RESPONSE_WRITTEN,"SKIP");	}	
end iterate mediator 

========================= synapse sample_1976 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start callout mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

sc.addHeader((OMElement) headerElements.next());	}	}	}	options.setProperty( AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES, Boolean.TRUE);	sc.setOptions(options);	OMElement request = getRequestPayload(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	synLog.traceOrDebug("About to invoke service : " + getServiceURL() + (getAction() != null ? " with action : " + getAction() : ""));	if (synLog.isTraceTraceEnabled()) {	
request message payload 

}	}	OMElement result = null;	try {	options.setCallTransportCleanup(true);	result = sc.sendReceive(request);	} catch (AxisFault axisFault) {	handleFault(synCtx, axisFault);	}	if (synLog.isTraceTraceEnabled()) {	
response payload received 

tgtNode.insertSiblingAfter(result);	tgtNode.detach();	} else {	handleException("Evaluation of target XPath expression : " + getTargetXPath().toString() + " did not yeild an OMNode", synCtx);	}	}	if (getTargetKey() != null) {	synCtx.setProperty(getTargetKey(), result);	}	} else {	
service returned a null response 

if (getTargetKey() != null) {	synCtx.setProperty(getTargetKey(), result);	}	} else {	}	} catch (AxisFault e) {	handleException("Error invoking service : " + getServiceURL() + (getAction() != null ? " with action : " + getAction() : ""), e, synCtx);	} catch (JaxenException e) {	handleException("Error while evaluating the XPath expression: " + getTargetXPath(), e, synCtx);	}	
end callout mediator 

========================= synapse sample_1999 =========================

public void setEventMask(int ops) {	if (this.log.isDebugEnabled()) {	
i o session set event mask 

public void setEvent(int op) {	if (this.log.isDebugEnabled()) {	
i o session set event 

public void clearEvent(int op) {	if (this.log.isDebugEnabled()) {	
i o session clear event 

public void close() {	if (this.log.isDebugEnabled()) {	
i o session close 

public void shutdown() {	if (this.log.isDebugEnabled()) {	
i o session shutdown 

public void setSocketTimeout(int timeout) {	if (this.log.isDebugEnabled()) {	
i o session set timeout 

public void setAttribute(final String name, final Object obj) {	if (this.log.isDebugEnabled()) {	
i o session set attribute 

public Object removeAttribute(final String name) {	if (this.log.isDebugEnabled()) {	
i o session remove attribute 

public int read(final ByteBuffer dst) throws IOException {	int bytesRead = session.channel().read(dst);	if (log.isDebugEnabled()) {	
i o session bytes read 

public int write(final ByteBuffer src) throws IOException {	int byteWritten = session.channel().write(src);	if (log.isDebugEnabled()) {	
i o session bytes written 

public void close() throws IOException {	if (log.isDebugEnabled()) {	
i o session channel close 

========================= synapse sample_4298 =========================

public void receive(org.apache.axis2.context.MessageContext mc) throws AxisFault {	
proxy service received a new message 

public void receive(org.apache.axis2.context.MessageContext mc) throws AxisFault {	log.debug("Message To: " + (mc.getTo() != null ? mc.getTo().getAddress() : "null"));	log.debug("SOAPAction: " + (mc.getWSAAction() != null ? mc.getWSAAction() : "null"));	
body 

if (statisticsEnable) {	ProxyServiceStatisticsStack proxyServiceStatisticsStack = new ProxyServiceStatisticsStack();	boolean isFault = synCtx.getEnvelope().getBody().hasFault();	proxyServiceStatisticsStack.put(name, System.currentTimeMillis(), !synCtx.isResponse(), statisticsEnable, isFault);	synCtx.setCorrelationProperty(org.apache.synapse.Constants.PROXYSERVICE_STATISTICS_STACK, proxyServiceStatisticsStack);	}	}	if (targetEndpoint != null) {	Endpoint endpoint = synCtx.getConfiguration().getNamedEndpoint(targetEndpoint);	if (endpoint == null) {	
the endpoint named is not defined dropping current message 

boolean isFault = synCtx.getEnvelope().getBody().hasFault();	proxyServiceStatisticsStack.put(name, System.currentTimeMillis(), !synCtx.isResponse(), statisticsEnable, isFault);	synCtx.setCorrelationProperty(org.apache.synapse.Constants.PROXYSERVICE_STATISTICS_STACK, proxyServiceStatisticsStack);	}	}	if (targetEndpoint != null) {	Endpoint endpoint = synCtx.getConfiguration().getNamedEndpoint(targetEndpoint);	if (endpoint == null) {	} else {	synCtx.setTo(new EndpointReference(endpoint.getAddress()));	
forwarding message directly to the endpoint named 

synCtx.setTo(new EndpointReference(endpoint.getAddress()));	org.apache.axis2.context.MessageContext axisInMsgContext = ((Axis2MessageContext) synCtx).getAxis2MessageContext();	org.apache.axis2.context.MessageContext axisOutMsgContext = Axis2FlexibleMEPClient.send(endpoint, synCtx);	if (axisOutMsgContext == null) {	return;	} else {	axisOutMsgContext.setServerSide(true);	axisOutMsgContext.setProperty(org.apache.axis2.context.MessageContext.TRANSPORT_OUT, axisInMsgContext.getProperty( org.apache.axis2.context.MessageContext.TRANSPORT_OUT));	axisOutMsgContext.setTransportIn(axisInMsgContext.getTransportIn());	if (log.isDebugEnabled()) {	
reply body 

endPointStatisticsStack.put(endPointName, System.currentTimeMillis(), !synCtx.isResponse(), endPointStatisticsEnable,isFault);	synCtx.setCorrelationProperty(org.apache.synapse.Constants.ENDPOINT_STATISTICS_STACK, endPointStatisticsStack);	}	AxisEngine ae = new AxisEngine(axisOutMsgContext.getConfigurationContext());	try {	axisOutMsgContext.setProperty( org.apache.synapse.Constants.ISRESPONSE_PROPERTY, Boolean.TRUE);	mc.getOperationContext().setProperty( Constants.RESPONSE_WRITTEN, Constants.VALUE_TRUE);	ae.send(axisOutMsgContext);	} catch (AxisFault e) {	synCtx.setProperty(org.apache.synapse.Constants.SYNAPSE_ERROR,Boolean.TRUE);	
axis fault encountered while forwarding message to endpoint 

synCtx.setProperty(org.apache.synapse.Constants.SYNAPSE_ERROR,Boolean.TRUE);	} finally {	if (endPointStatisticsEnable) {	StatisticsUtils.processEndPointStatistics(synCtx);	}	}	}	}	} else {	if (targetOutSequence != null) {	
outsequence for the proxy set to the messagecontext 

}	}	}	} else {	if (targetOutSequence != null) {	synCtx.setProperty(org.apache.synapse.Constants.OUT_SEQUENCE, targetOutSequence);	}	if (targetInSequence != null) {	Mediator mediator = synCtx.getConfiguration().getNamedSequence(targetInSequence);	if (mediator == null) {	
the mediator named is not defined dropping current message 

}	}	} else {	if (targetOutSequence != null) {	synCtx.setProperty(org.apache.synapse.Constants.OUT_SEQUENCE, targetOutSequence);	}	if (targetInSequence != null) {	Mediator mediator = synCtx.getConfiguration().getNamedSequence(targetInSequence);	if (mediator == null) {	} else {	
using sequence named for message mediation 

if (targetOutSequence != null) {	synCtx.setProperty(org.apache.synapse.Constants.OUT_SEQUENCE, targetOutSequence);	}	if (targetInSequence != null) {	Mediator mediator = synCtx.getConfiguration().getNamedSequence(targetInSequence);	if (mediator == null) {	} else {	mediator.mediate(synCtx);	}	} else {	
using default main mediator for message mediation 

========================= synapse sample_3224 =========================

public void send(MessageContext synCtx) {	if (log.isDebugEnabled()) {	
sending using load balance 

synCtx.setTo(epr);	if (failover) {	synCtx.getEnvelope().build();	}	AddressEndpoint endpoint = new AddressEndpoint();	EndpointDefinition definition = new EndpointDefinition();	endpoint.setDefinition(definition);	endpoint.init(synCtx.getEnvironment());	endpoint.send(synCtx);	} else {	
cannot load balance for non http s transport 

public boolean readyToSend() {	for (Endpoint endpoint : getChildren()) {	if (endpoint.readyToSend()) {	if (log.isDebugEnabled()) {	
load balance has at least one endpoint at ready state 

public boolean readyToSend() {	for (Endpoint endpoint : getChildren()) {	if (endpoint.readyToSend()) {	if (log.isDebugEnabled()) {	}	return true;	}	}	
load balance has no endpoints at ready state to process message 

public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {	logOnChildEndpointFail(endpoint, synMessageContext);	if (failover) {	if (!((AbstractEndpoint)endpoint).isRetryDisabled(synMessageContext)) {	if (log.isDebugEnabled()) {	
retry attempt for request with message id to 

public void setAlgorithm(LoadbalanceAlgorithm algorithm) {	if (log.isDebugEnabled()) {	
load balance will be using the algorithm for load distribution 

private boolean canConnect(Member member) {	if(log.isDebugEnabled()){	
trying to connect to member 

SocketAddress httpsSockaddr = new InetSocketAddress(addr, httpsPort);	new Socket().connect(httpsSockaddr, 10000);	}	return true;	} catch (IOException e) {	if(log.isDebugEnabled()){	log.debug("", e);	}	String msg = e.getMessage();	if (msg.indexOf("Connection refused") == -1 && msg.indexOf("connect timed out") == -1) {	
cannot connect to member 

========================= synapse sample_1649 =========================

private void checkMail(final PollTableEntry entry, InternetAddress emailAddress) {	if (log.isDebugEnabled()) {	
checking mail for account 

}	boolean connected = false;	int retryCount = 0;	int maxRetryCount = entry.getMaxRetryCount();	long reconnectionTimeout = entry.getReconnectTimeout();	Store store = null;	while (!connected) {	try {	retryCount++;	if (log.isDebugEnabled()) {	
attempting to connect to imap server for using 

Session session = Session.getInstance(entry.getProperties(), null);	session.setDebug(log.isTraceEnabled());	store = session.getStore(entry.getProtocol());	if (entry.getUserName() != null && entry.getPassword() != null) {	store.connect(entry.getUserName(), entry.getPassword());	} else {	handleException("Unable to locate username and password for mail login", null);	}	connected = store.isConnected();	} catch (Exception e) {	
error connecting to mail server for address 

}	connected = store.isConnected();	} catch (Exception e) {	if (maxRetryCount <= retryCount) {	processFailure("Error connecting to mail server for address : " + emailAddress + " :: " + e.getMessage(), e, entry);	return;	}	}	if (!connected) {	try {	
connection to mail server for account failed retrying in seconds 

} else {	folder = store.getFolder(MailConstants.DEFAULT_FOLDER);	}	if (folder == null) {	folder = store.getDefaultFolder();	}	if (folder == null) {	processFailure("Unable to access mail folder", null, entry);	} else {	if (log.isDebugEnabled()) {	
connecting to folder of email account 

}	if (folder == null) {	processFailure("Unable to access mail folder", null, entry);	} else {	if (log.isDebugEnabled()) {	}	folder.open(Folder.READ_WRITE);	int total = folder.getMessageCount();	Message[] messages = folder.getMessages();	if (log.isDebugEnabled()) {	
messgaes in folder 

if (log.isDebugEnabled()) {	}	folder.open(Folder.READ_WRITE);	int total = folder.getMessageCount();	Message[] messages = folder.getMessages();	if (log.isDebugEnabled()) {	}	for (int i = 0; i < total; i++) {	if (messages[i].isSet(Flags.Flag.SEEN)) {	if (log.isDebugEnabled()) {	
skipping message already marked seen 

int total = folder.getMessageCount();	Message[] messages = folder.getMessages();	if (log.isDebugEnabled()) {	}	for (int i = 0; i < total; i++) {	if (messages[i].isSet(Flags.Flag.SEEN)) {	if (log.isDebugEnabled()) {	}	} else if (messages[i].isSet(Flags.Flag.DELETED)) {	if (log.isDebugEnabled()) {	
skipping message already marked deleted 

} finally {	try {	folder.close(true /** expunge messages flagged as DELETED*/);	} catch (MessagingException e) {	processFailure("Error closing mail folder : " + folder + " for account : " + emailAddress, e, entry);	}	if (store != null) {	try {	store.close();	} catch (MessagingException e) {	
error closing mail store for account 

} else if (content instanceof String) {	contentType = message.getContentType();	} else if (content instanceof InputStream) {	contentType = MailConstants.APPLICATION_BINARY;	}	}	if (contentType == null) {	processFailure("Unable to determine Content-type for message : " + message.getMessageNumber() + " :: " + message.getSubject(), null, entry);	return;	} else if (log.isDebugEnabled()) {	
processing message as content type 

MailUtils.getInstace().setSOAPEnvelope(message, msgContext, contentType);	String soapAction = (String) trpHeaders.get(BaseConstants.SOAPACTION);	if (soapAction == null && message.getSubject() != null && message.getSubject().startsWith(BaseConstants.SOAPACTION)) {	soapAction = message.getSubject().substring(BaseConstants.SOAPACTION.length());	if (soapAction.startsWith(":")) {	soapAction = soapAction.substring(1).trim();	}	}	handleIncomingMessage( msgContext, trpHeaders, soapAction, contentType );	if (log.isDebugEnabled()) {	
processed message 

}	break;	case PollTableEntry.FAILED: if (entry.getActionAfterProcess() == PollTableEntry.MOVE) {	moveToFolder = entry.getMoveAfterFailure();	}	break;	case PollTableEntry.NONE: return;	}	if (moveToFolder != null) {	if (log.isDebugEnabled()) {	
moving processed email to folder 

if (moveToFolder != null) {	if (log.isDebugEnabled()) {	}	Folder dFolder = store.getFolder(moveToFolder);	if (!dFolder.exists()) {	dFolder.create(Folder.HOLDS_MESSAGES);	}	folder.copyMessages(new Message[]{message}, dFolder);	}	if (log.isDebugEnabled()) {	
deleting email 

Folder dFolder = store.getFolder(moveToFolder);	if (!dFolder.exists()) {	dFolder.create(Folder.HOLDS_MESSAGES);	}	folder.copyMessages(new Message[]{message}, dFolder);	}	if (log.isDebugEnabled()) {	}	message.setFlag(Flags.Flag.DELETED, true);	} catch (MessagingException e) {	
error deleting or resolving folder to move after processing 

protected void startListeningForService(AxisService service) {	Parameter param = service.getParameter(BaseConstants.TRANSPORT_POLL_INTERVAL);	long pollInterval = BaseConstants.DEFAULT_POLL_INTERVAL;	if (param != null && param.getValue() instanceof String) {	try {	pollInterval = Integer.parseInt(param.getValue().toString());	} catch (NumberFormatException e) {	
invalid poll interval for service default to sec 

========================= synapse sample_3731 =========================

private boolean assertListerNotNull() {	if (listener == null) {	if (log.isDebugEnabled()) {	
cannot find a datasourceinformationrepositorylistener 

private boolean assertListerNotNull() {	if (listener == null) {	if (log.isDebugEnabled()) {	}	return false;	}	if (log.isDebugEnabled()) {	
using datasourceinformationrepositorylistener as 

========================= synapse sample_2120 =========================

String name = null;	if (faultMediator instanceof SequenceMediator) {	name = ((SequenceMediator) faultMediator).getName();	}	if (name == null) {	name = faultMediator.getClass().getName();	}	if (traceOrDebugOn) {	traceOrDebugWarn(traceOn, "Executing fault handler mediator : " + name);	}	
executing fault sequence mediator 

========================= synapse sample_1921 =========================

public void testDynamicStaticKeys() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to dynamic and static keys 

========================= synapse sample_846 =========================

public Startup createStartup(OMElement el) {	if (log.isDebugEnabled()) {	
creating simplequartz task 

========================= synapse sample_4220 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start script mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

}	boolean returnValue;	if (multiThreadedEngine) {	returnValue = invokeScript(synCtx);	} else {	synchronized (scriptEngine.getClass()) {	returnValue = invokeScript(synCtx);	}	}	if (synLog.isTraceTraceEnabled()) {	
result message after execution of script 

if (multiThreadedEngine) {	returnValue = invokeScript(synCtx);	} else {	synchronized (scriptEngine.getClass()) {	returnValue = invokeScript(synCtx);	}	}	if (synLog.isTraceTraceEnabled()) {	}	if (synLog.isTraceOrDebugEnabled()) {	
end script mediator return value 

protected void initInlineScript() {	try {	initScriptEngine();	if (scriptEngine instanceof Compilable) {	if (log.isDebugEnabled()) {	
script engine supports compilable interface compiling script code 

protected void initInlineScript() {	try {	initScriptEngine();	if (scriptEngine instanceof Compilable) {	if (log.isDebugEnabled()) {	}	compiledScript = ((Compilable) scriptEngine).compile(scriptSourceCode);	} else {	if (log.isDebugEnabled()) {	
script engine does not support the compilable interface in lined script would be evaluated on each invocation 

}	}	}	for (Value includeKey : includes.keySet()) {	String includeSourceCode = (String) includes.get(includeKey);	String generatedKey = includeKey.evaluateValue(synCtx);	Entry includeEntry = synCtx.getConfiguration().getEntryDefinition(generatedKey);	boolean includeEntryNeedsReload = (includeEntry != null) && includeEntry.isDynamic() && (!includeEntry.isCached() || includeEntry.isExpired());	synchronized (resourceLock) {	if (includeSourceCode == null || includeEntryNeedsReload) {	
re loading the include script with key 

protected void initScriptEngine() {	if (log.isDebugEnabled()) {	
initializing script mediator for language 

this.scriptEngine = manager.getEngineByExtension(language);	if (scriptEngine == null) {	handleException("No script engine found for language: " + language);	}	if (language.equalsIgnoreCase(JAVA_SCRIPT)) {	xmlHelper = new JavaScriptXmlHelper();	} else {	xmlHelper = XMLHelper.getArgHelper(scriptEngine);	}	this.multiThreadedEngine = scriptEngine.getFactory().getParameter("THREADING") != null;	
script mediator for language supports multithreading 

========================= synapse sample_1167 =========================

public static void markServiceAsFaulty(String serviceName, String msg, AxisConfiguration axisCfg) {	if (serviceName != null) {	try {	AxisService service = axisCfg.getService(serviceName);	axisCfg.getFaultyServices().put(service.getName(), msg);	} catch (AxisFault axisFault) {	
error marking service as faulty 

private SOAPEnvelope handleLegacyMessage(MessageContext msgContext, Object message) {	SOAPFactory soapFactory = new SOAP11Factory();	SOAPEnvelope envelope = null;	if (log.isDebugEnabled()) {	
non soap xml message received 

========================= synapse sample_3789 =========================

entry.setVersion(re.getVersion());	}	}	if (omNode == null) {	return null;	} else {	re = getRegistryEntry(entry.getKey());	}	} else if (entry.isExpired()) {	if (log.isDebugEnabled()) {	
cached object has expired for key 

return null;	} else {	re = getRegistryEntry(entry.getKey());	}	} else if (entry.isExpired()) {	if (log.isDebugEnabled()) {	}	re = getRegistryEntry(entry.getKey());	if (re.getVersion() != Long.MIN_VALUE && re.getVersion() == entry.getVersion()) {	if (log.isDebugEnabled()) {	
expired version number is same as current version in registry 

re = getRegistryEntry(entry.getKey());	if (re.getVersion() != Long.MIN_VALUE && re.getVersion() == entry.getVersion()) {	if (log.isDebugEnabled()) {	}	if (re.getCachableDuration() > 0) {	entry.setExpiryTime( System.currentTimeMillis() + re.getCachableDuration());	} else {	entry.setExpiryTime(-1);	}	if (log.isDebugEnabled()) {	
renew cache lease for another s 

========================= synapse sample_2032 =========================

public boolean startProcess() {	processException = null;	synchronized (synapseServer) {	synapseServer.start();	while (serverState <= STARTING_UP) {	try {	synapseServer.wait(1000);	} catch (InterruptedException e) {	
synapse startup was interrupted 

synapseServer.start();	while (serverState <= STARTING_UP) {	try {	synapseServer.wait(1000);	} catch (InterruptedException e) {	return false;	}	}	}	if (serverState == STARTUP_FAILED) {	
synapse failed to start 

public boolean stopProcess() {	if (serverState == SERVER_ACTIVE) {	synchronized (synapseServer) {	serverState = SHUTTING_DOWN;	synapseServer.notifyAll();	while (serverState > UNDEFINED) {	try {	synapseServer.wait(1000);	} catch (InterruptedException e) {	
synapse shutdown was interrupted 

public void run() {	
starting up synapse 

} finally {	synchronized (this) {	this.notifyAll();	}	}	synchronized (this) {	while (serverState < SHUTTING_DOWN) {	try {	this.wait(1000);	} catch (InterruptedException e) {	
server interrupted 

}	}	synchronized (this) {	while (serverState < SHUTTING_DOWN) {	try {	this.wait(1000);	} catch (InterruptedException e) {	}	}	}	
shutting down synapse 

========================= synapse sample_796 =========================

private void startServerEngine(int port) {	HttpParams params = getServerParameters();	try {	ioReactor = new DefaultListeningIOReactor( NHttpConfiguration.getInstance().getServerIOWorkers(), params);	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	
system may be unstable ioreactor encountered a checked exception 

private void startServerEngine(int port) {	HttpParams params = getServerParameters();	try {	ioReactor = new DefaultListeningIOReactor( NHttpConfiguration.getInstance().getServerIOWorkers(), params);	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	return true;	}	public boolean handle(RuntimeException runtimeException) {	
system may be unstable ioreactor encountered a runtime exception 

ioReactor = new DefaultListeningIOReactor( NHttpConfiguration.getInstance().getServerIOWorkers(), params);	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	return true;	}	public boolean handle(RuntimeException runtimeException) {	return true;	}	});	} catch (IOException e) {	
error starting the ioreactor 

IOEventDispatch ioEventDispatch = getEventDispatch( handler, sslContext, sslIOSessionHandler, params);	state = BaseConstants.STARTED;	try {	if (bindAddress == null) {	ioReactor.listen(new InetSocketAddress(port));	} else {	ioReactor.listen(new InetSocketAddress( InetAddress.getByName(bindAddress), port));	}	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	
reactor interrupted 

state = BaseConstants.STARTED;	try {	if (bindAddress == null) {	ioReactor.listen(new InetSocketAddress(port));	} else {	ioReactor.listen(new InetSocketAddress( InetAddress.getByName(bindAddress), port));	}	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	} catch (IOException e) {	
encountered an i o error 

try {	if (bindAddress == null) {	ioReactor.listen(new InetSocketAddress(port));	} else {	ioReactor.listen(new InetSocketAddress( InetAddress.getByName(bindAddress), port));	}	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	} catch (IOException e) {	}	
listener shutdown 

if (param != null) {	bindAddress = ((String) param.getValue()).trim();	}	param = transprtIn.getParameter(HOST_ADDRESS);	if (param != null) {	host = ((String) param.getValue()).trim();	} else {	try {	host = java.net.InetAddress.getLocalHost().getHostName();	} catch (UnknownHostException e) {	
unable to lookup local host name using localhost 

public void start() throws AxisFault {	if (log.isDebugEnabled()) {	
starting listener 

public void stop() throws AxisFault {	if (state != BaseConstants.STARTED) return;	try {	ioReactor.shutdown();	state = BaseConstants.STOPPED;	
listener shut down 

public void pause() throws AxisFault {	if (state != BaseConstants.STARTED) return;	try {	ioReactor.pause();	state = BaseConstants.PAUSED;	
listener paused 

public void resume() throws AxisFault {	if (state != BaseConstants.PAUSED) return;	try {	ioReactor.resume();	state = BaseConstants.STARTED;	
listener resumed 

public void maintenenceShutdown(long millis) throws AxisFault {	if (state != BaseConstants.STARTED) return;	try {	long start = System.currentTimeMillis();	ioReactor.pause();	ioReactor.shutdown(millis);	state = BaseConstants.STOPPED;	
listener shutdown in s 

try {	ObjectName name = new ObjectName(objectName);	Set set = mbs.queryNames(name, null);	if (set != null && set.isEmpty()) {	mbs.registerMBean(mbeanInstance, name);	} else {	mbs.unregisterMBean(name);	mbs.registerMBean(mbeanInstance, name);	}	} catch (Exception e) {	
error registering a mbean with objectname for jmx management 

========================= synapse sample_3766 =========================

public SynapseTaskManager() {	if (log.isDebugEnabled()) {	
created the synapsetaskmanager singleton instance 

public void init(TaskDescriptionRepository taskDescriptionRepository, TaskScheduler taskScheduler) {	if (initialized) {	if (log.isDebugEnabled()) {	
task manager already initialized skipping re initialization 

public void init(TaskDescriptionRepository taskDescriptionRepository, TaskScheduler taskScheduler) {	if (initialized) {	if (log.isDebugEnabled()) {	}	return;	}	if (taskDescriptionRepository != null) {	this.taskDescriptionRepository = taskDescriptionRepository;	} else {	if (log.isDebugEnabled()) {	
creating new taskdescriptionrepository as given instance is null 

this.taskDescriptionRepository = taskDescriptionRepository;	} else {	if (log.isDebugEnabled()) {	}	this.taskDescriptionRepository = TaskDescriptionRepositoryFactory.getTaskDescriptionRepository( TaskConstants.TASK_DESCRIPTION_REPOSITORY);	}	if (taskScheduler != null) {	this.taskScheduler = taskScheduler;	} else {	if (log.isDebugEnabled()) {	
creating new taskscheduler as given instance is null 

public void cleanup() {	assertInitialized();	
shutting down the task manager 

========================= synapse sample_1464 =========================

public void acknowledgeMessage(MessageContext msgContext) throws AxisFault {	if (log.isDebugEnabled()) {	
acking one way request 

public void awaitResponse() throws InterruptedException, AxisFault {	if (log.isDebugEnabled()) {	
returning thread but keeping socket open awaiting response 

public void signalResponseReady() {	if (log.isDebugEnabled()) {	
signal response available 

========================= synapse sample_1034 =========================

public void testDynamicEndPoints() {	String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test dynamic endpoints with registry 

========================= synapse sample_850 =========================

public void testScheduledTaskInjectToSequence() throws Exception {	
waiting seconds for the task to run 

public void testScheduledTaskInjectToSequence() throws Exception {	Thread.sleep(10000);	int messageCount = getAxis2Server().getMessageCount("SimpleStockQuoteService", "getQuote");	
task sent messages 

========================= synapse sample_2248 =========================

protected void doInit() throws AxisFault {	connectionFactoryES = Executors.newFixedThreadPool( AMQPTransportUtils.getIntProperty( AMQPTransportConstant.PARAM_CONNECTION_FACTORY_POOL_SIZE, AMQPTransportConstant.CONNECTION_FACTORY_POOL_DEFAULT));	connectionFactoryManager = new AMQPTransportConnectionFactoryManager();	connectionFactoryManager.addConnectionFactories( getTransportInDescription(), connectionFactoryES);	workerPool = Executors.newScheduledThreadPool( AMQPTransportUtils.getIntProperty(AMQPTransportConstant.PARAM_WORKER_POOL_SIZE, AMQPTransportConstant.WORKER_POOL_DEFAULT));	int initialReconnectDuration = AMQPTransportUtils.getIntProperty( AMQPTransportConstant.PARAM_INITIAL_RE_CONNECTION_DURATION, 1000);	double reconnectionProgressionFactor = AMQPTransportUtils.getDoubleProperty( AMQPTransportConstant.PARAM_RE_CONNECTION_PROGRESSION_FACTOR, 2.0);	int maxReconnectionDuration = AMQPTransportUtils.getIntProperty( AMQPTransportConstant.PARAM_MAX_RE_CONNECTION_DURATION, 1000 * 60 * 10);	haHandlerTask = new AMQPTransportReconnectHandler( connectionFactoryES, maxReconnectionDuration, reconnectionProgressionFactor, initialReconnectDuration, connectionFactoryManager);	new Thread(haHandlerTask, "AMQP-HA-handler-task").start();	
amqp transport listener initializing 

protected void startEndpoint(AMQPTransportEndpoint endpoint) throws AxisFault {	AMQPTransportPollingTask ptm = endpoint.getPollingTask();	try {	ptm.start();	} catch (AMQPTransportException e) {	throw new AxisFault(e.getMessage(), e);	}	
amqp transport polling task started listen for service 

protected void stopEndpoint(AMQPTransportEndpoint endpoint) {	AMQPTransportPollingTask ptm = endpoint.getPollingTask();	ptm.stop();	
amqp transport polling task stopped listen for service 

public void stop() throws AxisFault {	super.stop();	workerPool.shutdown();	try {	connectionFactoryManager.shutDownConnectionFactories();	} catch (AMQPTransportException e) {	
error while shutting down connection factories continue anyway 

========================= synapse sample_2474 =========================

public boolean offer(MessageContext messageContext) {	lock.lock();	try {	if (messageContext != null) {	messageContext.getEnvelope().build();	messageList.offer(messageContext);	notifyMessageAddition(messageContext.getMessageID());	if (log.isDebugEnabled()) {	
message with id stored 

========================= synapse sample_2024 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	boolean failSafeProxyEnabled = SynapseConfigUtils.isFailSafeEnabled( SynapseConstants.FAIL_SAFE_MODE_PROXY_SERVICES);	if (log.isDebugEnabled()) {	
proxyservice deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	boolean failSafeProxyEnabled = SynapseConfigUtils.isFailSafeEnabled( SynapseConstants.FAIL_SAFE_MODE_PROXY_SERVICES);	if (log.isDebugEnabled()) {	}	try {	ProxyService proxy = ProxyServiceFactory.createProxy(artifactConfig, properties);	if (proxy != null) {	proxy.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
proxyservice named has been built from the file 

if (log.isDebugEnabled()) {	}	try {	ProxyService proxy = ProxyServiceFactory.createProxy(artifactConfig, properties);	if (proxy != null) {	proxy.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	initializeProxy(proxy);	if (log.isDebugEnabled()) {	
initialized the proxyservice 

ProxyService proxy = ProxyServiceFactory.createProxy(artifactConfig, properties);	if (proxy != null) {	proxy.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	initializeProxy(proxy);	if (log.isDebugEnabled()) {	}	proxy.buildAxisService(getSynapseConfiguration(), getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	
started the proxyservice 

if (log.isDebugEnabled()) {	}	initializeProxy(proxy);	if (log.isDebugEnabled()) {	}	proxy.buildAxisService(getSynapseConfiguration(), getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addProxyService(proxy.getName(), proxy);	if (log.isDebugEnabled()) {	
proxyservice deployment from file completed 

}	initializeProxy(proxy);	if (log.isDebugEnabled()) {	}	proxy.buildAxisService(getSynapseConfiguration(), getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addProxyService(proxy.getName(), proxy);	if (log.isDebugEnabled()) {	}	
proxyservice named has been deployed from file 

}	getSynapseConfiguration().addProxyService(proxy.getName(), proxy);	if (log.isDebugEnabled()) {	}	return proxy.getName();	} else {	handleSynapseArtifactDeploymentError("ProxyService Deployment Failed. The " + "artifact described in the file " + fileName + " is not a ProxyService");	}	} catch (Exception e) {	if (failSafeProxyEnabled) {	
proxy service hot deployment from file failed continue in fail safe mode 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
proxyservice update from file started 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	ProxyService proxy = ProxyServiceFactory.createProxy(artifactConfig, properties);	if (proxy != null) {	proxy.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
proxyservice named has been built from the file 

if (log.isDebugEnabled()) {	}	try {	ProxyService proxy = ProxyServiceFactory.createProxy(artifactConfig, properties);	if (proxy != null) {	proxy.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	initializeProxy(proxy);	if (log.isDebugEnabled()) {	
initialized the proxyservice 

proxy.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	initializeProxy(proxy);	if (log.isDebugEnabled()) {	}	ProxyService currentProxy = getSynapseConfiguration().getProxyService(existingArtifactName);	currentProxy.stop(getSynapseConfiguration());	getSynapseConfiguration().removeProxyService(existingArtifactName);	if (!existingArtifactName.equals(proxy.getName())) {	
proxyservice named has been undeployed 

initializeProxy(proxy);	if (log.isDebugEnabled()) {	}	ProxyService currentProxy = getSynapseConfiguration().getProxyService(existingArtifactName);	currentProxy.stop(getSynapseConfiguration());	getSynapseConfiguration().removeProxyService(existingArtifactName);	if (!existingArtifactName.equals(proxy.getName())) {	}	proxy.buildAxisService(getSynapseConfiguration(), getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	
started the proxyservice 

ProxyService currentProxy = getSynapseConfiguration().getProxyService(existingArtifactName);	currentProxy.stop(getSynapseConfiguration());	getSynapseConfiguration().removeProxyService(existingArtifactName);	if (!existingArtifactName.equals(proxy.getName())) {	}	proxy.buildAxisService(getSynapseConfiguration(), getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addProxyService(proxy.getName(), proxy);	if (log.isDebugEnabled()) {	
proxyservice update deployment from file completed 

currentProxy.stop(getSynapseConfiguration());	getSynapseConfiguration().removeProxyService(existingArtifactName);	if (!existingArtifactName.equals(proxy.getName())) {	}	proxy.buildAxisService(getSynapseConfiguration(), getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addProxyService(proxy.getName(), proxy);	if (log.isDebugEnabled()) {	}	
proxyservice named has been updated deployed from file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
proxyservice undeployment of the proxy named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	ProxyService proxy = getSynapseConfiguration().getProxyService(artifactName);	if (proxy != null) {	if (log.isDebugEnabled()) {	
stopping the proxyservice named 

if (log.isDebugEnabled()) {	}	try {	ProxyService proxy = getSynapseConfiguration().getProxyService(artifactName);	if (proxy != null) {	if (log.isDebugEnabled()) {	}	proxy.stop(getSynapseConfiguration());	getSynapseConfiguration().removeProxyService(artifactName);	if (log.isDebugEnabled()) {	
proxyservice undeployment of the proxy named completed 

}	try {	ProxyService proxy = getSynapseConfiguration().getProxyService(artifactName);	if (proxy != null) {	if (log.isDebugEnabled()) {	}	proxy.stop(getSynapseConfiguration());	getSynapseConfiguration().removeProxyService(artifactName);	if (log.isDebugEnabled()) {	}	
proxyservice named has been undeployed 

try {	ProxyService proxy = getSynapseConfiguration().getProxyService(artifactName);	if (proxy != null) {	if (log.isDebugEnabled()) {	}	proxy.stop(getSynapseConfiguration());	getSynapseConfiguration().removeProxyService(artifactName);	if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
proxy service has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the proxyservice with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	ProxyService proxy = getSynapseConfiguration().getProxyService(artifactName);	OMElement proxyElem = ProxyServiceSerializer.serializeProxy(null, proxy);	if (proxy.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.PROXY_SERVICES_DIR + File.separator + proxy.getFileName();	writeToFile(proxyElem, fileName);	if (log.isDebugEnabled()) {	
restoring the proxyservice with name completed 

if (log.isDebugEnabled()) {	}	try {	ProxyService proxy = getSynapseConfiguration().getProxyService(artifactName);	OMElement proxyElem = ProxyServiceSerializer.serializeProxy(null, proxy);	if (proxy.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.PROXY_SERVICES_DIR + File.separator + proxy.getFileName();	writeToFile(proxyElem, fileName);	if (log.isDebugEnabled()) {	}	
proxyservice named has been restored 

========================= synapse sample_1608 =========================

if (keyParam != null) {	OMElement ksEle      = keyParam.getParameterElement().getFirstElement();	String location      = ksEle.getFirstChildWithName(new QName("Location")).getText();	String type          = ksEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = ksEle.getFirstChildWithName(new QName("Password")).getText();	String keyPassword   = ksEle.getFirstChildWithName(new QName("KeyPassword")).getText();	try {	KeyStore keyStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	if (log.isDebugEnabled()) {	
loading key store from url 

try {	KeyStore keyStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	if (log.isDebugEnabled()) {	}	keyStore.load(url.openStream(), storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

URL url = getClass().getClassLoader().getResource(location);	if (log.isDebugEnabled()) {	}	keyStore.load(url.openStream(), storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

}	if (trustParam != null) {	OMElement tsEle      = trustParam.getParameterElement().getFirstElement();	String location      = tsEle.getFirstChildWithName(new QName("Location")).getText();	String type          = tsEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = tsEle.getFirstChildWithName(new QName("Password")).getText();	try {	KeyStore trustStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	if (log.isDebugEnabled()) {	
loading trust key store from url 

try {	KeyStore trustStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	if (log.isDebugEnabled()) {	}	trustStore.load(url.openStream(), storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

URL url = getClass().getClassLoader().getResource(location);	if (log.isDebugEnabled()) {	}	trustStore.load(url.openStream(), storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	throw new AxisFault("Error opening Key store : " + location, ioe);	}	}	try {	SSLContext sslcontext = SSLContext.getInstance("TLS");	sslcontext.init(keymanagers, trustManagers, null);	return sslcontext;	} catch (GeneralSecurityException gse) {	
unable to create ssl context with the given configuration 

========================= synapse sample_3770 =========================

public void init(Properties properties, String id) {	StringBuffer sb = new StringBuffer();	sb.append(id);	sb.append(DOT);	sb.append(LOCATION);	String filePath = MiscellaneousUtil.getProperty(properties, sb.toString(), DEFAULT_CONF_LOCATION);	Properties cipherProperties = MiscellaneousUtil.loadProperties(filePath);	if (cipherProperties == null) {	if (log.isDebugEnabled()) {	
cipher texts cannot be loaded form 

CipherInformation cipherInformation = new CipherInformation();	cipherInformation.setAlgorithm(algorithm);	cipherInformation.setCipherOperationMode(CipherOperationMode.DECRYPT);	cipherInformation.setInType(EncodingType.BASE64);	DecryptionProvider baseCipher = CipherFactory.createCipher(cipherInformation, keyStoreWrapper);	for (Object alias : cipherProperties.keySet()) {	String key = String.valueOf(alias);	String encryptedText = cipherProperties.getProperty(key);	if (encryptedText == null || "".equals(encryptedText.trim())) {	if (log.isDebugEnabled()) {	
there is no secret for the alias 

public String getSecret(String alias) {	if (alias == null || "".equals(alias)) {	return alias;	}	if (!initialize || secrets.isEmpty()) {	if (log.isDebugEnabled()) {	
there is no secret found for alias returning itself 

}	return alias;	}	StringBuffer sb = new StringBuffer();	sb.append(alias);	sb.append(DOT);	sb.append(SECRET);	String secret = secrets.get(sb.toString());	if (secret == null || "".equals(secret)) {	if (log.isDebugEnabled()) {	
there is no secret found for alias returning itself 

========================= synapse sample_2531 =========================

public void rewrite(URIFragments fragments, MessageContext messageContext) throws URISyntaxException {	if (condition != null) {	String uriString = fragments.toURIString();	Map<String, String> headers = getHeaders(messageContext);	EvaluatorContext ctx = new EvaluatorContext(uriString, headers);	ctx.setProperties(((Axis2MessageContext) messageContext).getProperties());	ctx.setMessageContext(((Axis2MessageContext) messageContext).getAxis2MessageContext());	if (log.isTraceEnabled()) {	
evaluating condition with uri 

String uriString = fragments.toURIString();	Map<String, String> headers = getHeaders(messageContext);	EvaluatorContext ctx = new EvaluatorContext(uriString, headers);	ctx.setProperties(((Axis2MessageContext) messageContext).getProperties());	ctx.setMessageContext(((Axis2MessageContext) messageContext).getAxis2MessageContext());	if (log.isTraceEnabled()) {	}	try {	if (!condition.evaluate(ctx)) {	if (log.isTraceEnabled()) {	
condition evaluated to false skipping the current action 

ctx.setMessageContext(((Axis2MessageContext) messageContext).getAxis2MessageContext());	if (log.isTraceEnabled()) {	}	try {	if (!condition.evaluate(ctx)) {	if (log.isTraceEnabled()) {	}	return;	}	if (log.isTraceEnabled()) {	
condition evaluated to true performing the stated action 

}	try {	if (!condition.evaluate(ctx)) {	if (log.isTraceEnabled()) {	}	return;	}	if (log.isTraceEnabled()) {	}	} catch (EvaluatorException e) {	
error while evaluating the condition skipping the rule as it failed 

========================= synapse sample_1960 =========================

public void run() {	while (true) {	if (completed) {	break;	}	if (getLock()) {	if (log.isDebugEnabled()) {	
time and this aggregator expired at 

========================= synapse sample_554 =========================

public void init(ConfigurationContext cfgCtx, TransportInDescription transportIn) throws AxisFault {	setTransportName(TRANSPORT_NAME);	super.init(cfgCtx, transportIn);	loadConnectionDefinitions(transportIn);	if (connections.isEmpty()) {	
no amqp connections are defined cannot listen on amqp 

public void init(ConfigurationContext cfgCtx, TransportInDescription transportIn) throws AxisFault {	setTransportName(TRANSPORT_NAME);	super.init(cfgCtx, transportIn);	loadConnectionDefinitions(transportIn);	if (connections.isEmpty()) {	return;	}	
amqp transport receiver listener initialized 

}	AMQPConnection con = getConnectionFactory(service);	if (con == null) {	String msg = "Service " + service.getName() + " does not specify" + "an AMQP connection or refers to an invalid connection. " + "This service is being marked as faulty and will not be " + "available over the AMQP transport";	log.warn(msg);	BaseUtils.markServiceAsFaulty(service.getName(), msg, service.getAxisConfiguration());	return;	}	List<AMQPBinding> bindings = AMQPUtils.getBindingsForService(service);	serviceNameToEPRMap.put(service.getName(), URIParser.getEPR(bindings,con.getUrl()));	
starting to listen for service 

private void loadConnectionDefinitions(TransportInDescription transprtIn) {	Iterator conIter = transprtIn.getParameters().iterator();	while (conIter.hasNext()) {	Parameter conParams = (Parameter) conIter.next();	ParameterIncludeImpl pi = new ParameterIncludeImpl();	AMQPConnection conDef = new AMQPConnection();	try {	pi.deserializeParameters((OMElement) conParams.getValue());	} catch (AxisFault axisFault) {	
error reading parameters for amqp connection definitions 

========================= synapse sample_4261 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
localentry deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	Entry e = EntryFactory.createEntry(artifactConfig, properties);	if (e != null) {	e.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
localentry with key has been built from the file 

if (log.isDebugEnabled()) {	}	try {	Entry e = EntryFactory.createEntry(artifactConfig, properties);	if (e != null) {	e.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEntry(e.getKey(), e);	if (log.isDebugEnabled()) {	
localentry deployment from file completed 

}	try {	Entry e = EntryFactory.createEntry(artifactConfig, properties);	if (e != null) {	e.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEntry(e.getKey(), e);	if (log.isDebugEnabled()) {	}	
localentry named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
localentry update from file has started 

if (log.isDebugEnabled()) {	}	try {	Entry e = EntryFactory.createEntry(artifactConfig, properties);	if (e == null) {	handleSynapseArtifactDeploymentError("Local entry update failed. The artifact " + "defined in the file: " + fileName + " is not a valid local entry.");	return null;	}	e.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	
local entry has been built from the file 

return null;	}	e.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	if (existingArtifactName.equals(e.getKey())) {	getSynapseConfiguration().updateEntry(existingArtifactName, e);	} else {	getSynapseConfiguration().addEntry(e.getKey(), e);	getSynapseConfiguration().removeEntry(existingArtifactName);	
local entry has been undeployed 

}	e.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	if (existingArtifactName.equals(e.getKey())) {	getSynapseConfiguration().updateEntry(existingArtifactName, e);	} else {	getSynapseConfiguration().addEntry(e.getKey(), e);	getSynapseConfiguration().removeEntry(existingArtifactName);	}	
endpoint has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
localentry undeployment of the entry named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	Entry e = getSynapseConfiguration().getDefinedEntries().get(artifactName);	if (e != null && e.getType() != Entry.REMOTE_ENTRY) {	getSynapseConfiguration().removeEntry(artifactName);	if (log.isDebugEnabled()) {	
localentry undeployment of the entry named completed 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	Entry e = getSynapseConfiguration().getDefinedEntries().get(artifactName);	if (e != null && e.getType() != Entry.REMOTE_ENTRY) {	getSynapseConfiguration().removeEntry(artifactName);	if (log.isDebugEnabled()) {	}	
localentry named has been undeployed 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	Entry e = getSynapseConfiguration().getDefinedEntries().get(artifactName);	if (e != null && e.getType() != Entry.REMOTE_ENTRY) {	getSynapseConfiguration().removeEntry(artifactName);	if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
local entry has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
localentry the sequence with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	Entry e = getSynapseConfiguration().getDefinedEntries().get(artifactName);	OMElement entryElem = EntrySerializer.serializeEntry(e, null);	if (e.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.LOCAL_ENTRY_DIR + File.separator + e.getFileName();	writeToFile(entryElem, fileName);	if (log.isDebugEnabled()) {	
restoring the localentry with name completed 

if (log.isDebugEnabled()) {	}	try {	Entry e = getSynapseConfiguration().getDefinedEntries().get(artifactName);	OMElement entryElem = EntrySerializer.serializeEntry(e, null);	if (e.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.LOCAL_ENTRY_DIR + File.separator + e.getFileName();	writeToFile(entryElem, fileName);	if (log.isDebugEnabled()) {	}	
localentry named has been restored 

========================= synapse sample_1599 =========================

public void testExternalXQuery() {	String addUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test how to use the data from an external xml document with in xquery 

========================= synapse sample_807 =========================

public void addConnectionFactories(ParameterInclude transportInDescription, ExecutorService es) {	for (Parameter p : transportInDescription.getParameters()) {	try {	addConnectionFactory(p, es);	} catch (AMQPTransportException e) {	
error whiling adding the connection factory with name 

========================= synapse sample_1063 =========================

public InvocationResponse invoke(MessageContext messageContext) throws AxisFault {	HandlerUtil.doHandlerLogging(log, messageContext);	org.apache.synapse.MessageContext synCtx = MessageContextCreatorForAxis2.getSynapseMessageContext(messageContext);	if (!messageContext.isServerSide()) {	synCtx.setProperty(SynapseConstants.RESPONSE, Boolean.TRUE);	synCtx.setResponse(true);	try {	if (HandlerUtil.mediateOutMessage(log, messageContext, synCtx)) {	return InvocationResponse.CONTINUE;	} else {	
synapse has decided to abort the message 

}	} catch (SynapseException syne) {	}	} else {	synCtx.setProperty(SynapseConstants.RESPONSE, Boolean.FALSE);	synCtx.setResponse(false);	try {	if (HandlerUtil.mediateInMessage(log, messageContext, synCtx)) {	return InvocationResponse.CONTINUE;	} else {	
synapse has decided to abort the message 

========================= synapse sample_1433 =========================

public String getMessageTextPayload(Object message) {	try {	return new String( getBytesFromInputStream(getInputStream(message), ((Message) message).getSize()));	} catch (Exception e) {	if (log.isDebugEnabled()) {	
error reading message payload as text for 

========================= synapse sample_3727 =========================

public boolean matches(String value) {	if (isDefaultCase()) {	
this is the default case of the switch 

public boolean matches(String value) {	if (isDefaultCase()) {	return true;	}	boolean retVal = regex.matcher(value).matches();	
case evaluated to 

========================= synapse sample_3300 =========================

public NativeWorkerPool(int core, int max, int keepAlive, int queueLength, String threadGroupName, String threadGroupId) {	if (log.isDebugEnabled()) {	
using native util concurrent package 

========================= synapse sample_3750 =========================

String mName = "set" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1);	if (property.getAttributeValue(new QName("value")) != null) {	String value = property.getAttributeValue(new QName("value"));	setInstanceProperty(propertyName, value, o);	} else {	OMElement value = property.getFirstElement();	if (value != null) {	try {	Method method = o.getClass().getMethod(mName, OMElement.class);	if (log.isDebugEnabled()) {	
setting property invoking method 

========================= synapse sample_2141 =========================

break;	}	processor.tried++;	} while (processor.tried < processor.getRequiredInitMsgsDelay().get());	}	if (!processor.isInitSeqNo().get()) {	while (true) {	if (messageStore.size() > 0) {	selectStartingSeqNo(processor, messageStore, seqNoxPath);	if (!processor.isInitSeqNo().get()) {	
resequencer failed to select starting sequence number with in given timeout 

for (int messageIndex = 0; ; messageIndex++) {	MessageContext messageContext = messageStore.get(messageIndex);	if (messageContext == null) {	errorStop = true;	break;	}	int sequenceNo;	try {	sequenceNo = Integer.parseInt(seqNoxPath.stringValueOf(messageContext));	} catch (Exception e) {	
can t find sequence number from message 

private void delay(long timePeriod) {	try {	Thread.sleep(timePeriod);	} catch (InterruptedException e) {	
interrupted while thread sleeping in resequencer 

========================= synapse sample_2004 =========================

public boolean injectMessage(final MessageContext synCtx) {	if (log.isDebugEnabled()) {	
injecting messagecontext 

public boolean injectMessage(final MessageContext synCtx) {	if (log.isDebugEnabled()) {	}	synCtx.setEnvironment(this);	Mediator mandatorySeq = synCtx.getConfiguration().getMandatorySequence();	if (mandatorySeq != null) {	if (log.isDebugEnabled()) {	
start mediating the message in the pre mediate state using the mandatory sequence 

String receivingSequence = (String) synCtx.getProperty(SynapseConstants.RECEIVING_SEQUENCE);	Set keySet = synCtx.getPropertyKeySet();	if (keySet != null) {	keySet.remove(SynapseConstants.RECEIVING_SEQUENCE);	}	String proxyName = (String) synCtx.getProperty(SynapseConstants.PROXY_SERVICE);	if (proxyName == null || "".equals(proxyName)) {	synCtx.pushFaultHandler(new MediatorFaultHandler(synCtx.getFaultSequence()));	if (receivingSequence != null) {	if (log.isDebugEnabled()) {	
using sequence with name for injected message 

String proxyName = (String) synCtx.getProperty(SynapseConstants.PROXY_SERVICE);	if (proxyName == null || "".equals(proxyName)) {	synCtx.pushFaultHandler(new MediatorFaultHandler(synCtx.getFaultSequence()));	if (receivingSequence != null) {	if (log.isDebugEnabled()) {	}	Mediator seqMediator = synCtx.getSequence(receivingSequence);	if (seqMediator != null) {	return seqMediator.mediate(synCtx);	} else {	
cannot find a sequence with name for injecting the response message 

return seqMediator.mediate(synCtx);	} else {	return false;	}	} else {	boolean processed = restHandler.process(synCtx);	if (processed) {	return true;	}	if (log.isDebugEnabled()) {	
using main sequence for injected message 

return synCtx.getMainSequence().mediate(synCtx);	}	}	ProxyService proxyService = synCtx.getConfiguration().getProxyService(proxyName);	if (proxyService != null) {	if (proxyService.getTargetFaultSequence() != null) {	Mediator faultSequence = synCtx.getSequence(proxyService.getTargetFaultSequence());	if (faultSequence != null) {	synCtx.pushFaultHandler(new MediatorFaultHandler(faultSequence));	} else {	
cloud not find any fault sequence named setting the default fault sequence for out path 

synCtx.pushFaultHandler(new MediatorFaultHandler(synCtx.getFaultSequence()));	}	} else if (proxyService.getTargetInLineFaultSequence() != null) {	synCtx.pushFaultHandler( new MediatorFaultHandler(proxyService.getTargetInLineFaultSequence()));	} else {	synCtx.pushFaultHandler(new MediatorFaultHandler(synCtx.getFaultSequence()));	}	Mediator outSequence = getProxyOutSequence(synCtx, proxyService);	if (receivingSequence != null) {	if (log.isDebugEnabled()) {	
using sequence with name for injected message 

synCtx.pushFaultHandler(new MediatorFaultHandler(synCtx.getFaultSequence()));	}	Mediator outSequence = getProxyOutSequence(synCtx, proxyService);	if (receivingSequence != null) {	if (log.isDebugEnabled()) {	}	Mediator seqMediator = synCtx.getSequence(receivingSequence);	if (seqMediator != null) {	seqMediator.mediate(synCtx);	} else {	
cannot find a sequence with name for injecting the message 

Mediator seqMediator = synCtx.getSequence(receivingSequence);	if (seqMediator != null) {	seqMediator.mediate(synCtx);	} else {	return false;	}	} else if (outSequence != null) {	outSequence.mediate(synCtx);	} else {	if (log.isDebugEnabled()) {	
does not specifies an out sequence sending the response back 

public MessageContext createMessageContext() {	if (log.isDebugEnabled()) {	
creating message context 

private Mediator getProxyOutSequence(MessageContext synCtx, ProxyService proxyService) {	String sequenceName = proxyService.getTargetOutSequence();	if (sequenceName != null && !"".equals(sequenceName)) {	Mediator outSequence = synCtx.getSequence(sequenceName);	if (outSequence != null) {	if (log.isDebugEnabled()) {	
using the sequence named for the outgoing message mediation of the proxy service 

private Mediator getProxyOutSequence(MessageContext synCtx, ProxyService proxyService) {	String sequenceName = proxyService.getTargetOutSequence();	if (sequenceName != null && !"".equals(sequenceName)) {	Mediator outSequence = synCtx.getSequence(sequenceName);	if (outSequence != null) {	if (log.isDebugEnabled()) {	}	return outSequence;	} else {	
unable to find the out sequence specified by the name 

if (log.isDebugEnabled()) {	}	return outSequence;	} else {	throw new SynapseException("Unable to find the " + "out-sequence specified by the name " + sequenceName);	}	} else {	Mediator outSequence = proxyService.getTargetInLineOutSequence();	if (outSequence != null) {	if (log.isDebugEnabled()) {	
using the anonymous out sequence specified in the proxy service for outgoing message mediation 

========================= synapse sample_1628 =========================

public LoadBalancingMediator() {	
loadbalancing mediator created 

private void roundRobinStrategy(SynapseObject contract) {	
roundrobin loadbalncing 

private void loadConfig(SynapseMessage synapseMessageContext) {	boolean flag = false;	InputStream loadbalancingInStream;	String resource;	AxisConfiguration ac = ((Axis2SynapseMessage) synapseMessageContext).getMessageContext().getConfigurationContext().getAxisConfiguration();	Parameter param = ac.getParameter("PolicyRepo");	if (param != null) {	resource = param.getValue().toString().trim() + File.separator + "policy"+File.separator+"mediators" + File.separator + LoadBalancingConstants.CFG_LOADBALANCING_XML;	resource = resource.replace('\\','/');	
resource from repo 

InputStream loadbalancingInStream;	String resource;	AxisConfiguration ac = ((Axis2SynapseMessage) synapseMessageContext).getMessageContext().getConfigurationContext().getAxisConfiguration();	Parameter param = ac.getParameter("PolicyRepo");	if (param != null) {	resource = param.getValue().toString().trim() + File.separator + "policy"+File.separator+"mediators" + File.separator + LoadBalancingConstants.CFG_LOADBALANCING_XML;	resource = resource.replace('\\','/');	File file = new File(resource);	try{	flag = (file.lastModified() != modifiedTime);	
flag 

if (param != null) {	resource = param.getValue().toString().trim() + File.separator + "policy"+File.separator+"mediators" + File.separator + LoadBalancingConstants.CFG_LOADBALANCING_XML;	resource = resource.replace('\\','/');	File file = new File(resource);	try{	flag = (file.lastModified() != modifiedTime);	modifiedTime = file.lastModified();	}  catch(Exception e){	e.printStackTrace();	}	
getting the stream 

try{	flag = (file.lastModified() != modifiedTime);	modifiedTime = file.lastModified();	}  catch(Exception e){	e.printStackTrace();	}	try {	loadbalancingInStream = new FileInputStream(file);	}	catch(Exception e) {	
error here 

flag = (file.lastModified() != modifiedTime);	modifiedTime = file.lastModified();	}  catch(Exception e){	e.printStackTrace();	}	try {	loadbalancingInStream = new FileInputStream(file);	}	catch(Exception e) {	resource = LoadBalancingConstants.CFG_XML_FOLDER + "/" + LoadBalancingConstants.CFG_LOADBALANCING_XML;	
resource from aar 

}	try {	loadbalancingInStream = new FileInputStream(file);	}	catch(Exception e) {	resource = LoadBalancingConstants.CFG_XML_FOLDER + "/" + LoadBalancingConstants.CFG_LOADBALANCING_XML;	loadbalancingInStream = this.classLoader.getResourceAsStream(resource);	}	} else {	resource = LoadBalancingConstants.CFG_XML_FOLDER + "/" + LoadBalancingConstants.CFG_LOADBALANCING_XML;	
resource from aar 

loadbalancingInStream = new FileInputStream(file);	}	catch(Exception e) {	resource = LoadBalancingConstants.CFG_XML_FOLDER + "/" + LoadBalancingConstants.CFG_LOADBALANCING_XML;	loadbalancingInStream = this.classLoader.getResourceAsStream(resource);	}	} else {	resource = LoadBalancingConstants.CFG_XML_FOLDER + "/" + LoadBalancingConstants.CFG_LOADBALANCING_XML;	loadbalancingInStream = this.classLoader.getResourceAsStream(resource);	}	
loadbalancing in stream 

}	if ((!flag)&&(synapseEnvironment.getProperty("loadbalancing_synapseObject") != null)) {	loadbalancing = (SynapseObject) synapseEnvironment.getProperty("loadbalancing_synapseObject");	} else {	if(loadbalancingInStream!=null){	loadbalancing = Utils.xmlToSynapseObject(loadbalancingInStream);	addCurrentServiceAttrib();	synapseEnvironment.setProperty("loadbalancing_synapseObject", loadbalancing);	}	else {	
null stream 

public void setSynapseEnvironment(SynapseEnvironment se) {	if (se !=null) {	this.synapseEnvironment = se;	}	else{	
the environment is null 

public void setClassLoader(ClassLoader cl) {	if(cl!=null){	this.classLoader = cl;	}	else{	
classloader not set 

========================= synapse sample_2907 =========================

public static void convertSOAP11toSOAP12( org.apache.axis2.context.MessageContext axisOutMsgCtx) throws AxisFault {	if(log.isDebugEnabled()) {	
convert to 

OMAttribute attr = (OMAttribute) allAttributes.next();	if(attr.getNamespace() != null && SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals( attr.getNamespace().getNamespaceURI())) {	String attrName = attr.getLocalName();	if(SOAP_ATR_ACTOR.equals(attrName)) {	OMAttribute newAtr = omNode.getOMFactory().createOMAttribute( SOAP_ATR_ROLE, newEnvelope.getNamespace(), attr.getAttributeValue());	newSOAPHeader.addAttribute(newAtr);	} else if(SOAP_ATR_MUST_UNDERSTAND.equals(attrName)) {	boolean isMustUnderstand = soapHeader.getMustUnderstand();	newSOAPHeader.setMustUnderstand(isMustUnderstand);	} else {	
removed unsupported attribute from soap namespace when converting to soap 

public static void convertSOAP12toSOAP11( org.apache.axis2.context.MessageContext axisOutMsgCtx) throws AxisFault {	if (log.isDebugEnabled()) {	
convert to 

OMAttribute attr = (OMAttribute) allAttributes.next();	if(attr.getNamespace() != null && SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals( attr.getNamespace().getNamespaceURI())) {	String attrName = attr.getLocalName();	if(SOAP_ATR_ROLE.equals(attrName)) {	OMAttribute newAtr = omNode.getOMFactory().createOMAttribute( SOAP_ATR_ACTOR, newEnvelope.getNamespace(), attr.getAttributeValue());	newSOAPHeader.addAttribute(newAtr);	} else if(SOAP_ATR_MUST_UNDERSTAND.equals(attrName)) {	boolean isMustUnderstand = soapHeaderBlock.getMustUnderstand();	newSOAPHeader.setMustUnderstand(isMustUnderstand);	} else {	
removed unsupported attribute from soap namespace when converting to soap 

========================= synapse sample_3496 =========================

useFallbackBuilder = JavaUtils.isTrueExplicitly(useFallbackParameter.getValue(), useFallbackBuilder);	}	OMElement element = null;	Builder builder;	if (contentType != null) {	builder = configuration.getMessageBuilder(_contentType, useFallbackBuilder);	if (builder != null) {	try {	element = builder.processDocument(in, contentType, msgCtx);	} catch (AxisFault axisFault) {	
error building message 

}	}	if (element == null) {	if (msgCtx.isDoingREST()) {	element = BuilderUtil.createPOXBuilder(in, null).getDocumentElement();	} else {	builder = new SOAPBuilder();	try {	element = builder.processDocument(in, contentType, msgCtx);	} catch (AxisFault axisFault) {	
error building message using soap builder 

========================= synapse sample_935 =========================

public void setMessage(OMElement elem) {	
set message 

public void execute() {	
execute 

public void execute() {	if (synapseEnvironment == null) {	
synapse environment not set 

public void execute() {	if (synapseEnvironment == null) {	return;	}	if (message == null) {	
message not set 

public void execute() {	if (synapseEnvironment == null) {	return;	}	if (message == null) {	return;	}	if (to == null) {	
to address not set 

========================= synapse sample_4216 =========================

public void testCBR() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test cbr with the switch case mediator using message properties 

========================= synapse sample_2268 =========================

public boolean mediate(SynapseContext synCtx) {	
mediate 

========================= synapse sample_2792 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start out mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	boolean result = true;	if (test(synCtx)) {	
current message is outgoing executing child mediators 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	boolean result = true;	if (test(synCtx)) {	result = super.mediate(synCtx);	} else {	
current message is a request skipping child mediators 

SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	boolean result = true;	if (test(synCtx)) {	result = super.mediate(synCtx);	} else {	}	
end out mediator 

========================= synapse sample_1917 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
startuptask deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	Startup st = StartupFinder.getInstance().getStartup(artifactConfig, properties);	st.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
startuptask named has been built from the file 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	Startup st = StartupFinder.getInstance().getStartup(artifactConfig, properties);	st.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	st.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	
initialized the startuptask 

try {	Startup st = StartupFinder.getInstance().getStartup(artifactConfig, properties);	st.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	st.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addStartup(st);	if (log.isDebugEnabled()) {	
startuptask deployment from file completed 

Startup st = StartupFinder.getInstance().getStartup(artifactConfig, properties);	st.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	st.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addStartup(st);	if (log.isDebugEnabled()) {	}	
startuptask named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
startuptask update from file has started 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	Startup st = StartupFinder.getInstance().getStartup(artifactConfig, properties);	st.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
startuptask has been built from the file 

if (log.isDebugEnabled()) {	}	Startup existingSt = getSynapseConfiguration().getStartup(existingArtifactName);	existingSt.destroy();	st.init(getSynapseEnvironment());	if (existingArtifactName.equals(st.getName())) {	getSynapseConfiguration().updateStartup(st);	} else {	getSynapseConfiguration().addStartup(st);	getSynapseConfiguration().removeStartup(existingArtifactName);	
startuptask has been undeployed 

}	Startup existingSt = getSynapseConfiguration().getStartup(existingArtifactName);	existingSt.destroy();	st.init(getSynapseEnvironment());	if (existingArtifactName.equals(st.getName())) {	getSynapseConfiguration().updateStartup(st);	} else {	getSynapseConfiguration().addStartup(st);	getSynapseConfiguration().removeStartup(existingArtifactName);	}	
startuptask has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
startuptask undeployment of the task named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	Startup st = getSynapseConfiguration().getStartup(artifactName);	if (st != null) {	getSynapseConfiguration().removeStartup(artifactName);	if (log.isDebugEnabled()) {	
destroying the startuptask named 

if (log.isDebugEnabled()) {	}	try {	Startup st = getSynapseConfiguration().getStartup(artifactName);	if (st != null) {	getSynapseConfiguration().removeStartup(artifactName);	if (log.isDebugEnabled()) {	}	st.destroy();	if (log.isDebugEnabled()) {	
startuptask undeployment of the sequence named completed 

}	try {	Startup st = getSynapseConfiguration().getStartup(artifactName);	if (st != null) {	getSynapseConfiguration().removeStartup(artifactName);	if (log.isDebugEnabled()) {	}	st.destroy();	if (log.isDebugEnabled()) {	}	
startuptask named has been undeployed 

try {	Startup st = getSynapseConfiguration().getStartup(artifactName);	if (st != null) {	getSynapseConfiguration().removeStartup(artifactName);	if (log.isDebugEnabled()) {	}	st.destroy();	if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
startup task has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the startuptask with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	Startup st = getSynapseConfiguration().getStartup(artifactName);	OMElement stElem = StartupFinder.getInstance().serializeStartup(null, st);	if (st.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.TASKS_DIR + File.separator + st.getFileName();	writeToFile(stElem, fileName);	if (log.isDebugEnabled()) {	
restoring the startuptask with name completed 

if (log.isDebugEnabled()) {	}	try {	Startup st = getSynapseConfiguration().getStartup(artifactName);	OMElement stElem = StartupFinder.getInstance().serializeStartup(null, st);	if (st.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.TASKS_DIR + File.separator + st.getFileName();	writeToFile(stElem, fileName);	if (log.isDebugEnabled()) {	}	
startuptask named has been restored 

========================= synapse sample_173 =========================

public Startup createStartup(OMElement el) {	if (log.isDebugEnabled()) {	
creating simplequartz task 

========================= synapse sample_3707 =========================

public void release() {	if (temporaryFile != null) {	if (log.isDebugEnabled()) {	
deleting temporary file 

protected void finalize() throws Throwable {	if (temporaryFile != null) {	
cleaning up unreleased temporary file 

========================= synapse sample_718 =========================

public KeyManagerFactory getIdentityKeyManagerFactoryInstance() {	try {	if (log.isDebugEnabled()) {	
creating a identitykeymanagerfactory instance 

========================= synapse sample_1106 =========================

private void startServerEngine(int port) {	HttpParams params = getServerParameters();	try {	ioReactor = new DefaultListeningIOReactor( NHttpConfiguration.getInstance().getServerIOWorkers(), params);	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	
system may be unstable ioreactor encountered a checked exception 

private void startServerEngine(int port) {	HttpParams params = getServerParameters();	try {	ioReactor = new DefaultListeningIOReactor( NHttpConfiguration.getInstance().getServerIOWorkers(), params);	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	return true;	}	public boolean handle(RuntimeException runtimeException) {	
system may be unstable ioreactor encountered a runtime exception 

ioReactor = new DefaultListeningIOReactor( NHttpConfiguration.getInstance().getServerIOWorkers(), params);	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	return true;	}	public boolean handle(RuntimeException runtimeException) {	return true;	}	});	} catch (IOException e) {	
error starting the ioreactor 

IOEventDispatch ioEventDispatch = getEventDispatch( handler, sslContext, sslIOSessionHandler, params);	state = BaseConstants.STARTED;	try {	if (bindAddress == null) {	ioReactor.listen(new InetSocketAddress(port));	} else {	ioReactor.listen(new InetSocketAddress( InetAddress.getByName(bindAddress), port));	}	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	
reactor interrupted 

state = BaseConstants.STARTED;	try {	if (bindAddress == null) {	ioReactor.listen(new InetSocketAddress(port));	} else {	ioReactor.listen(new InetSocketAddress( InetAddress.getByName(bindAddress), port));	}	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	} catch (IOException e) {	
encountered an i o error 

if (param != null) {	bindAddress = ((String) param.getValue()).trim();	}	param = transprtIn.getParameter(HOST_ADDRESS);	if (param != null) {	host = ((String) param.getValue()).trim();	} else {	try {	host = java.net.InetAddress.getLocalHost().getHostName();	} catch (UnknownHostException e) {	
unable to lookup local host name using localhost 

public void start() throws AxisFault {	if (log.isDebugEnabled()) {	
starting listener 

public void pause() throws AxisFault {	if (state != BaseConstants.STARTED) return;	try {	ioReactor.pause();	state = BaseConstants.PAUSED;	
listener paused 

public void resume() throws AxisFault {	if (state != BaseConstants.PAUSED) return;	try {	ioReactor.resume();	state = BaseConstants.STARTED;	
listener resumed 

public void maintenenceShutdown(long millis) throws AxisFault {	if (state != BaseConstants.STARTED) return;	try {	long start = System.currentTimeMillis();	ioReactor.pause();	ioReactor.shutdown(millis);	state = BaseConstants.STOPPED;	
listener shutdown in s 

try {	ObjectName name = new ObjectName(objectName);	Set set = mbs.queryNames(name, null);	if (set != null && set.isEmpty()) {	mbs.registerMBean(mbeanInstance, name);	} else {	mbs.unregisterMBean(name);	mbs.registerMBean(mbeanInstance, name);	}	} catch (Exception e) {	
error registering a mbean with objectname for jmx management 

========================= synapse sample_4304 =========================

public SourceHandler(SourceConfiguration sourceConfiguration) {	this.sourceConfiguration = sourceConfiguration;	this.metrics = sourceConfiguration.getMetrics();	try {	if (!sourceConfiguration.isSsl()) {	this.latencyView = new LatencyView(sourceConfiguration.isSsl());	} else {	this.s2sLatencyView = new LatencyView(sourceConfiguration.isSsl());	}	} catch (AxisFault e) {	
error while initializing latency view calculators 

request.start(conn);	metrics.incrementMessagesReceived();	String method = request.getRequest() != null ? request.getRequest().getRequestLine().getMethod().toUpperCase() : "";	if ("GET".equals(method)) {	HttpContext context = request.getConnection().getContext();	ContentOutputBuffer outputBuffer = new SimpleOutputBuffer(8192, HeapByteBufferAllocator.INSTANCE);	context.setAttribute(PassThroughConstants.PASS_THROUGH_RESPONSE_SOURCE_BUFFER, outputBuffer);	}	sourceConfiguration.getWorkerPool().execute( new ServerWorker(request, sourceConfiguration));	} catch (HttpException e) {	
http exception while processing request 

metrics.incrementBytesSent(bytesWritten);	}	conn.requestInput();	if (!outBuf.hasData() && encoder.isCompleted()) {	PassThroughTransportUtils.finishUsingSourceConnection(conn.getHttpResponse(), conn, sourceConfiguration.getSourceConnections());	}	}	return;	}	if (protocolState != ProtocolState.RESPONSE_HEAD && protocolState != ProtocolState.RESPONSE_BODY) {	
illegal incoming connection state possibly two send backs are happening for the same request 

public void endOfInput(NHttpServerConnection conn) throws IOException {	ProtocolState state = SourceContext.getState(conn);	boolean isError = false;	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	
keep alive connection was closed by the client 

public void endOfInput(NHttpServerConnection conn) throws IOException {	ProtocolState state = SourceContext.getState(conn);	boolean isError = false;	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_BODY || state == ProtocolState.REQUEST_HEAD) {	isError = true;	informReaderError(conn);	
connection closed by the client while reading the request 

boolean isError = false;	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_BODY || state == ProtocolState.REQUEST_HEAD) {	isError = true;	informReaderError(conn);	} else if (state == ProtocolState.RESPONSE_BODY || state == ProtocolState.RESPONSE_HEAD) {	isError = true;	informWriterError(conn);	
connection closed by the client end while writing the response 

if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_BODY || state == ProtocolState.REQUEST_HEAD) {	isError = true;	informReaderError(conn);	} else if (state == ProtocolState.RESPONSE_BODY || state == ProtocolState.RESPONSE_HEAD) {	isError = true;	informWriterError(conn);	} else if (state == ProtocolState.REQUEST_DONE) {	isError = true;	
connection closed by the client after request is read 

public void exception(NHttpServerConnection conn, Exception e) {	if (e instanceof HttpException) {	exception(conn, (HttpException) e);	} else if (e instanceof IOException) {	exception(conn, (IOException) e);	} else {	
unexpected exception encountered in sourcehandler 

public void exception(NHttpServerConnection conn, HttpException e) {	if (log.isDebugEnabled()) {	
http protocol error encountered in sourcehandler 

HttpContext httpContext = conn.getContext();	HttpResponse response = new BasicHttpResponse( HttpVersion.HTTP_1_1, HttpStatus.SC_BAD_REQUEST, "Bad request");	response.addHeader(HTTP.CONN_DIRECTIVE, HTTP.CONN_CLOSE);	httpContext.setAttribute(HttpCoreContext.HTTP_CONNECTION, conn);	httpContext.setAttribute(HttpCoreContext.HTTP_REQUEST, null);	httpContext.setAttribute(HttpCoreContext.HTTP_RESPONSE, response);	try {	sourceConfiguration.getHttpProcessor().process(response, httpContext);	conn.submitResponse(response);	} catch (Exception ex) {	
error while handling httpexception 

public void timeout(NHttpServerConnection conn) {	ProtocolState state = SourceContext.getState(conn);	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	
keep alive connection was time out 

public void timeout(NHttpServerConnection conn) {	ProtocolState state = SourceContext.getState(conn);	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_BODY || state == ProtocolState.REQUEST_HEAD) {	metrics.incrementTimeoutsReceiving();	informReaderError(conn);	
connection time out while reading the request 

public void timeout(NHttpServerConnection conn) {	ProtocolState state = SourceContext.getState(conn);	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_BODY || state == ProtocolState.REQUEST_HEAD) {	metrics.incrementTimeoutsReceiving();	informReaderError(conn);	} else if (state == ProtocolState.RESPONSE_BODY || state == ProtocolState.RESPONSE_HEAD) {	informWriterError(conn);	
connection time out while writing the response 

ProtocolState state = SourceContext.getState(conn);	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_BODY || state == ProtocolState.REQUEST_HEAD) {	metrics.incrementTimeoutsReceiving();	informReaderError(conn);	} else if (state == ProtocolState.RESPONSE_BODY || state == ProtocolState.RESPONSE_HEAD) {	informWriterError(conn);	} else if (state == ProtocolState.REQUEST_DONE){	
connection time out after request is read 

public void closed(NHttpServerConnection conn) {	ProtocolState state = SourceContext.getState(conn);	boolean isFault = false;	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	
keep alive connection was closed 

public void closed(NHttpServerConnection conn) {	ProtocolState state = SourceContext.getState(conn);	boolean isFault = false;	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_BODY || state == ProtocolState.REQUEST_HEAD) {	isFault = true;	informReaderError(conn);	
connection closed while reading the request 

boolean isFault = false;	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_BODY || state == ProtocolState.REQUEST_HEAD) {	isFault = true;	informReaderError(conn);	} else if (state == ProtocolState.RESPONSE_BODY || state == ProtocolState.RESPONSE_HEAD) {	isFault = true;	informWriterError(conn);	
connection closed while writing the response 

if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_BODY || state == ProtocolState.REQUEST_HEAD) {	isFault = true;	informReaderError(conn);	} else if (state == ProtocolState.RESPONSE_BODY || state == ProtocolState.RESPONSE_HEAD) {	isFault = true;	informWriterError(conn);	} else if (state == ProtocolState.REQUEST_DONE) {	isFault = true;	
connection closed after request is read 

private void handleInvalidState(NHttpServerConnection conn, String action) {	
while the handler is in an inconsistent state 

========================= synapse sample_962 =========================

public void deploy(DeploymentFileData deploymentFileData) throws DeploymentException {	
loading mediator from 

if (facURL != null) {	InputStream facStream = facURL.openStream();	InputStreamReader facreader = new InputStreamReader(facStream);	StringBuffer facSB = new StringBuffer();	int c;	while ((c = facreader.read()) != -1) {	facSB.append((char) c);	}	String[] facClassNames = facSB.toString().split("\n");	for (String facClassName : facClassNames) {	
registering the mediator factory 

StringBuffer facSB = new StringBuffer();	int c;	while ((c = facreader.read()) != -1) {	facSB.append((char) c);	}	String[] facClassNames = facSB.toString().split("\n");	for (String facClassName : facClassNames) {	Class facClass = urlCl.loadClass(facClassName);	MediatorFactory facInst = (MediatorFactory) facClass.newInstance();	MediatorFactoryFinder.getInstance() .getFactoryMap().put(facInst.getTagQName(), facClass);	
mediator loaded and registered for the tag name 

if (serURL != null) {	InputStream serStream = serURL.openStream();	InputStreamReader serReader = new InputStreamReader(serStream);	StringBuffer serSB = new StringBuffer();	int c;	while ((c = serReader.read()) != -1) {	serSB.append((char) c);	}	String[] serClassNames = serSB.toString().split("\n");	for (String serClassName : serClassNames) {	
registering the mediator serializer 

StringBuffer serSB = new StringBuffer();	int c;	while ((c = serReader.read()) != -1) {	serSB.append((char) c);	}	String[] serClassNames = serSB.toString().split("\n");	for (String serClassName : serClassNames) {	Class serClass = urlCl.loadClass(serClassName);	MediatorSerializer serInst = (MediatorSerializer) serClass.newInstance();	MediatorSerializerFinder.getInstance() .getSerializerMap().put(serInst.getMediatorClassName(), serInst);	
mediator loaded and registered for the serialization as 

serSB.append((char) c);	}	String[] serClassNames = serSB.toString().split("\n");	for (String serClassName : serClassNames) {	Class serClass = urlCl.loadClass(serClassName);	MediatorSerializer serInst = (MediatorSerializer) serClass.newInstance();	MediatorSerializerFinder.getInstance() .getSerializerMap().put(serInst.getMediatorClassName(), serInst);	}	} else {	if (log.isDebugEnabled()) {	
unable to find the mediatorserializer implementation unable to register the mediatorserializer with the serializerfinder 

} catch (IOException e) {	handleException("I/O error in reading the mediator jar file", e);	} catch (ClassNotFoundException e) {	handleException("Unable to find the specified class on the path or in the jar file", e);	} catch (IllegalAccessException e) {	handleException("Unable to load the class from the jar", e);	} catch (InstantiationException e) {	handleException("Unable to instantiate the class specified", e);	} finally {	if (log.isDebugEnabled()) {	
restoring the context class loader to the original 

========================= synapse sample_3992 =========================

private synchronized void replaceNewCacheValue(CRLCacheValue cacheValue) {	if (cacheValue.isValid()) {	return;	}	try {	String crlUrl = cacheValue.crlUrl;	X509CRL x509CRL = crlVerifier.downloadCRLFromWeb(crlUrl);	this.setCacheValue(crlUrl, x509CRL);	} catch (Exception e) {	
cant replace old cachevalue with new cachevalue so remove 

public synchronized void setCacheValue(String crlUrl, X509CRL crl) {	CRLCacheValue cacheValue = new CRLCacheValue(crlUrl, crl);	if (log.isDebugEnabled()) {	
before set hashmap size 

public synchronized void setCacheValue(String crlUrl, X509CRL crl) {	CRLCacheValue cacheValue = new CRLCacheValue(crlUrl, crl);	if (log.isDebugEnabled()) {	}	hashMap.put(crlUrl, cacheValue);	if (log.isDebugEnabled()) {	
after set hashmap size 

public synchronized void removeCacheValue(String crlUrl) {	if (log.isDebugEnabled()) {	
before remove hashmap size 

public synchronized void removeCacheValue(String crlUrl) {	if (log.isDebugEnabled()) {	}	hashMap.remove(crlUrl);	if (log.isDebugEnabled()) {	
after remove hashmap size 

========================= synapse sample_2395 =========================

public void testScheduledTaskInjectToProxy() throws Exception {	
waiting seconds for the task to run 

public void testScheduledTaskInjectToProxy() throws Exception {	Thread.sleep(10000);	int messageCount = getAxis2Server().getMessageCount("SimpleStockQuoteService", "getQuote");	
task sent messages 

========================= synapse sample_827 =========================

boolean registryCreated = false;	int jndiPort = jmxInformation.getJndiPort();	if (jndiPort == 0) {	jndiPort = JNDI_AUTO_PORT_OFFSET;	for (int retries = 0; !registryCreated && (retries < 100); retries++) {	try {	RMIRegistryController.getInstance().createLocalRegistry(jndiPort);	registryCreated = true;	} catch (Exception ignored) {	jndiPort++;	
trying alternate port 

}	if (registryCreated) {	jmxInformation.updateJMXUrl();	JMXServiceURL url = new JMXServiceURL(jmxInformation.getJmxUrl());	Map<String, Object> env = createContextMap();	MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();	connectorServer = JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);	try {	connectorServer.start();	} catch (IOException ex) {	
cannot start jmxconnectorserver on 

JMXServiceURL url = new JMXServiceURL(jmxInformation.getJmxUrl());	Map<String, Object> env = createContextMap();	MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();	connectorServer = JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);	try {	connectorServer.start();	} catch (IOException ex) {	}	}	} catch (Exception ex) {	
error while setting up remote jmx connector 

public void stop() {	if (connectorServer != null) {	
jmxconnectorserver stopping on 

public void stop() {	if (connectorServer != null) {	try {	connectorServer.stop();	RMIRegistryController.getInstance().removeLocalRegistry(jmxInformation.getJndiPort());	jmxInformation = null;	} catch (IOException ex) {	
error while stopping remote jmx connector 

private void initConfiguration() {	int jndiPort = jmxInformation.getJndiPort();	if ((jndiPort < 0) || (65535 < jndiPort)) {	throw new SynapseException("JNDI Port for Remote Registry not properly configured");	}	int rmiPort = jmxInformation.getRmiPort();	if ((rmiPort < 0) || (65535 < rmiPort)) {	rmiPort = 0;	
no or invalid value specified for jmx rmi port using dynamic port 

if (pwManager.isInitialized()) {	secretInformation.setGlobalSecretResolver(pwManager.getSecretResolver());	}	env.put(JMXConnectorServer.AUTHENTICATOR, new JmxSecretAuthenticator(jmxInformation.getSecretInformation()));	}	if (jmxInformation.getRemoteAccessFile() != null) {	env.put("jmx.remote.x.access.file", jmxInformation.getRemoteAccessFile());	}	}	if (jmxInformation.isRemoteSSL()) {	
activated ssl communication 

========================= synapse sample_2100 =========================

public void destroy() {	if (taskDescription == null) {	if (log.isDebugEnabled()) {	
there is no task to be deleted 

public void init(SynapseEnvironment synapseEnvironment) {	if (taskDescription == null) {	handleException("Error while initializing the startup. TaskDescription is null.");	}	taskManager = synapseEnvironment.getTaskManager();	if (!taskManager.isInitialized()) {	
synapsetaskmanager is not properly initialized initializing now with default parameters 

handleException("Task Description Repository cannot be found");	return;	}	repository.addTaskDescription(taskDescription);	String thisServerName = synapseEnvironment.getServerContextInformation() .getServerConfigurationInformation().getServerName();	if (thisServerName == null || thisServerName.equals("")) {	try {	InetAddress address = InetAddress.getLocalHost();	thisServerName = address.getHostName();	} catch (UnknownHostException e) {	
could not get the host name 

if (thisServerName == null || thisServerName.equals("")) {	try {	InetAddress address = InetAddress.getLocalHost();	thisServerName = address.getHostName();	} catch (UnknownHostException e) {	}	if (thisServerName == null || thisServerName.equals("")) {	thisServerName = "localhost";	}	}	
synapse server name 

thisServerName = address.getHostName();	} catch (UnknownHostException e) {	}	if (thisServerName == null || thisServerName.equals("")) {	thisServerName = "localhost";	}	}	List pinnedServers = taskDescription.getPinnedServers();	if (pinnedServers != null && !pinnedServers.isEmpty()) {	if (!pinnedServers.contains(thisServerName)) {	
server name not in pinned servers list not starting task 

}	}	try {	task = (Task) getClass().getClassLoader().loadClass( taskDescription.getTaskClass()).newInstance();	} catch (Exception e) {	handleException("Cannot instantiate task : " + taskDescription.getTaskClass(), e);	}	Set properties = taskDescription.getProperties();	for (Object property : properties) {	OMElement prop = (OMElement) property;	
found property 

map.put(SimpleQuartzJob.SYNAPSE_ENVIRONMENT, synapseEnvironment);	try {	TaskScheduler taskScheduler = taskManager.getTaskScheduler();	if (taskScheduler != null) {	if (!taskScheduler.isInitialized()) {	taskScheduler.init(synapseEnvironment.getSynapseConfiguration().getProperties());	}	taskScheduler.scheduleTask(taskDescription, map, SimpleQuartzJob.class, task);	} else {	if (log.isDebugEnabled()) {	
taskscheduler cannot be found for therefore ignore scheduling of task 

========================= synapse sample_2045 =========================

Replicator.setAndReplicateState(REMAINING_RETRIES_KEY, definition.getRetriesOnTimeoutBeforeSuspend(), cfgCtx);	Replicator.setAndReplicateState(LAST_SUSPEND_DURATION_KEY, null, cfgCtx);	break;	}	case ST_TIMEOUT: {	Integer retries = (Integer) cfgCtx.getPropertyNonReplicable(REMAINING_RETRIES_KEY);	if (retries == null) {	retries = definition.getRetriesOnTimeoutBeforeSuspend();	}	if (retries <= 0) {	
endpoint has been marked for suspension but no further retries remain thus it will be suspended 

Integer retries = (Integer) cfgCtx.getPropertyNonReplicable(REMAINING_RETRIES_KEY);	if (retries == null) {	retries = definition.getRetriesOnTimeoutBeforeSuspend();	}	if (retries <= 0) {	setState(ST_SUSPENDED);	} else {	Replicator.setAndReplicateState( REMAINING_RETRIES_KEY, (retries - 1), cfgCtx);	long nextRetry = System.currentTimeMillis() + definition.getRetryDurationOnTimeout();	Replicator.setAndReplicateState(NEXT_RETRY_TIME_KEY, nextRetry, cfgCtx);	
endpoint is marked as timeout and will be retried more time s after until its marked suspended for failure 

localRemainingRetries = definition.getRetriesOnTimeoutBeforeSuspend();	localLastSuspendDuration = -1;	break;	}	case ST_TIMEOUT: {	int retries = localRemainingRetries;	if (retries == -1) {	retries = definition.getRetriesOnTimeoutBeforeSuspend();	}	if (retries <= 0) {	
endpoint has been marked for suspension but no further retries remain thus it will be suspended 

case ST_TIMEOUT: {	int retries = localRemainingRetries;	if (retries == -1) {	retries = definition.getRetriesOnTimeoutBeforeSuspend();	}	if (retries <= 0) {	setState(ST_SUSPENDED);	} else {	localRemainingRetries = retries - 1;	localNextRetryTime = System.currentTimeMillis() + definition.getRetryDurationOnTimeout();	
endpoint is marked as timeout and will be retried more time s after until its marked suspended for failure 

public void onSuccess() {	if (isClustered) {	Integer state = (Integer) cfgCtx.getPropertyNonReplicable(STATE_KEY);	if ((state != null) && ((state != ST_ACTIVE) && (state != ST_OFF))) {	
endpoint currently will now be marked active since it processed its last message 

public void onSuccess() {	if (isClustered) {	Integer state = (Integer) cfgCtx.getPropertyNonReplicable(STATE_KEY);	if ((state != null) && ((state != ST_ACTIVE) && (state != ST_OFF))) {	setState(ST_ACTIVE);	}	} else {	if (localState != ST_ACTIVE && localState != ST_OFF) {	
endpoint currently will now be marked active since it processed its last message 

public void onFault() {	
endpoint will be marked suspended as it failed 

public void onTimeout() {	if (log.isDebugEnabled()) {	
endpoint will be marked for suspension due to the occurrence of one of the configured errors 

nextSuspendDuration = SynapseConstants.DEFAULT_ENDPOINT_SUSPEND_TIME;	}	long nextRetryTime = System.currentTimeMillis() + nextSuspendDuration;	if (isClustered) {	Replicator.setAndReplicateState(LAST_SUSPEND_DURATION_KEY, nextSuspendDuration, cfgCtx);	Replicator.setAndReplicateState(NEXT_RETRY_TIME_KEY, nextRetryTime, cfgCtx);	} else {	localLastSuspendDuration = nextSuspendDuration;	localNextRetryTime = nextRetryTime;	}	
suspending endpoint last suspend duration was ms and current suspend duration is ms next retry after 

public boolean readyToSend() {	if (log.isDebugEnabled()) {	
checking if endpoint currently at state can be used now 

} else {	if (state == ST_ACTIVE) {	return true;	} else if (state == ST_OFF) {	return false;	} else if (System.currentTimeMillis() >= nextRetryTime) {	if (state == ST_TIMEOUT) {	remainingRetries--;	Replicator.setAndReplicateState( REMAINING_RETRIES_KEY, remainingRetries, cfgCtx);	if (log.isDebugEnabled()) {	
endpoint which is currently in timeout state is ready to be retried remaining retries before suspension 

} else if (state == ST_OFF) {	return false;	} else if (System.currentTimeMillis() >= nextRetryTime) {	if (state == ST_TIMEOUT) {	remainingRetries--;	Replicator.setAndReplicateState( REMAINING_RETRIES_KEY, remainingRetries, cfgCtx);	if (log.isDebugEnabled()) {	}	} else {	if (log.isDebugEnabled()) {	
endpoint which is currently suspended is ready to be retried now 

}	}	} else {	if (localState == ST_ACTIVE) {	return true;	} else if (localState == ST_OFF) {	return false;	} else if (System.currentTimeMillis() >= localNextRetryTime) {	if (localState == ST_TIMEOUT) {	if (log.isDebugEnabled()) {	
endpoint which is currently in timeout state is ready to be retried remaining retries before suspension 

if (localState == ST_ACTIVE) {	return true;	} else if (localState == ST_OFF) {	return false;	} else if (System.currentTimeMillis() >= localNextRetryTime) {	if (localState == ST_TIMEOUT) {	if (log.isDebugEnabled()) {	}	} else {	if (log.isDebugEnabled()) {	
endpoint which is currently suspended is ready to be retried now 

if (log.isDebugEnabled()) {	}	} else {	if (log.isDebugEnabled()) {	}	}	return true;	}	}	if (log.isDebugEnabled()) {	
endpoint not ready and is currently next retry will be after 

public void switchOff() {	
manually switching off endpoint 

public void switchOn() {	
manually activating endpoint 

========================= synapse sample_1669 =========================

private String retrieveSequenceID(String correlationValue) {	String sequenceID = null;	if (!sequenceMap.containsKey(correlationValue)) {	sequenceID = UUIDGenerator.getUUID();	if (log.isDebugEnabled()) {	
setting sequenceid for correlation 

sequenceID = UUIDGenerator.getUUID();	if (log.isDebugEnabled()) {	}	Entry sequenceEntry = new Entry();	sequenceEntry.setValue(sequenceID);	sequenceEntry.setExpiryTime(System.currentTimeMillis() + SEQUENCE_EXPIRY_TIME);	sequenceMap.put(correlationValue, sequenceEntry);	} else {	sequenceID = (String) ((Entry) sequenceMap.get(correlationValue)).getValue();	if (log.isDebugEnabled()) {	
got sequenceid for correlation 

========================= synapse sample_4191 =========================

metrics.incrementMessagesSent();	try {	if (message instanceof BytesMessage) {	metrics.incrementBytesSent(JMSUtils.getBodyLength((BytesMessage) message));	} else if (message instanceof TextMessage) {	metrics.incrementBytesSent(( (TextMessage) message).getText().getBytes().length);	} else {	handleException("Unsupported JMS message type : " + message.getClass().getName());	}	} catch (JMSException e) {	
error reading jms message size to update transport metrics 

} else {	consumer = ((TopicSession) session).createSubscriber((Topic) replyDestination);	}	}	long timeout = JMSConstants.DEFAULT_JMS_TIMEOUT;	String waitReply = (String) msgCtx.getProperty(JMSConstants.JMS_WAIT_REPLY);	if (waitReply != null) {	timeout = Long.valueOf(waitReply).longValue();	}	if (log.isDebugEnabled()) {	
waiting for a maximum of ms for a response message to destination with jms correlation id 

metrics.incrementMessagesReceived();	try {	if (reply instanceof BytesMessage) {	metrics.incrementBytesReceived(JMSUtils.getBodyLength((BytesMessage) reply));	} else if (reply instanceof TextMessage) {	metrics.incrementBytesReceived(( (TextMessage) reply).getText().getBytes().length);	} else {	handleException("Unsupported JMS message type : " + reply.getClass().getName());	}	} catch (JMSException e) {	
error reading jms message size to update transport metrics 

} catch (JMSException e) {	}	try {	processSyncResponse(msgCtx, reply);	metrics.incrementMessagesReceived();	} catch (AxisFault e) {	metrics.incrementFaultsReceiving();	throw e;	}	} else {	
did not receive a jms response within ms to destination with jms correlation id 

private void loadConnectionFactoryDefinitions(TransportOutDescription transportOut) {	Iterator conFacIter = transportOut.getParameters().iterator();	while (conFacIter.hasNext()) {	Parameter conFacParams = (Parameter) conFacIter.next();	JMSConnectionFactory jmsConFactory = new JMSConnectionFactory(conFacParams.getName(), cfgCtx);	JMSUtils.setConnectionFactoryParameters(conFacParams, jmsConFactory);	try {	jmsConFactory.connectAndListen();	} catch (NamingException e) {	
error looking up jms connection factory 

private void loadConnectionFactoryDefinitions(TransportOutDescription transportOut) {	Iterator conFacIter = transportOut.getParameters().iterator();	while (conFacIter.hasNext()) {	Parameter conFacParams = (Parameter) conFacIter.next();	JMSConnectionFactory jmsConFactory = new JMSConnectionFactory(conFacParams.getName(), cfgCtx);	JMSUtils.setConnectionFactoryParameters(conFacParams, jmsConFactory);	try {	jmsConFactory.connectAndListen();	} catch (NamingException e) {	} catch (JMSException e) {	
error connecting to jms connection factory 

========================= synapse sample_4312 =========================

protected void handleSingleSecretCallback(SingleSecretCallback singleSecretCallback) {	if (!secretManager.isInitialized()) {	if (log.isWarnEnabled()) {	
secretmanager has not been initialized cannot collect secrets 

========================= synapse sample_1110 =========================

private void registerExtensions() {	Iterator it = Service.providers(MediatorFactory.class);	while (it.hasNext()) {	MediatorFactory mf = (MediatorFactory) it.next();	QName tag = mf.getTagQName();	factoryMap.put(tag, mf.getClass());	if (log.isDebugEnabled()) {	
added mediatorfactory to handle 

public Mediator getMediator(OMElement element) {	String localName = element.getLocalName();	QName qName = null;	if (element.getNamespace() != null) {	qName = new QName(element.getNamespace().getNamespaceURI(), localName);	} else {	qName = new QName(localName);	}	if (log.isDebugEnabled()) {	
getmediator 

} else {	qName = new QName(localName);	}	if (log.isDebugEnabled()) {	}	Class cls = (Class) factoryMap.get(qName);	if (cls == null && localName.indexOf('.') > -1) {	String newLocalName = localName.substring(0, localName.indexOf('.'));	qName = new QName(element.getNamespace().getNamespaceURI(), newLocalName);	if (log.isDebugEnabled()) {	
getmediator 

========================= synapse sample_3592 =========================

private void checkMail(final PollTableEntry entry, InternetAddress emailAddress) {	if (log.isDebugEnabled()) {	
checking mail for account 

}	boolean connected = false;	int retryCount = 0;	int maxRetryCount = entry.getMaxRetryCount();	long reconnectionTimeout = entry.getReconnectTimeout();	Store store = null;	while (!connected) {	try {	retryCount++;	if (log.isDebugEnabled()) {	
attempting to connect to imap server for using 

Session session = Session.getInstance(entry.getProperties(), null);	session.setDebug(log.isTraceEnabled());	store = session.getStore(entry.getProtocol());	if (entry.getUserName() != null && entry.getPassword() != null) {	store.connect(entry.getUserName(), entry.getPassword());	} else {	handleException("Unable to locate username and password for mail login", null);	}	connected = store.isConnected();	} catch (Exception e) {	
error connecting to mail server for address 

}	connected = store.isConnected();	} catch (Exception e) {	if (maxRetryCount <= retryCount) {	processFailure("Error connecting to mail server for address : " + emailAddress + " :: " + e.getMessage(), e, entry);	return;	}	}	if (!connected) {	try {	
connection to mail server for account failed retrying in seconds 

} else {	folder = store.getFolder(MailConstants.DEFAULT_FOLDER);	}	if (folder == null) {	folder = store.getDefaultFolder();	}	if (folder == null) {	processFailure("Unable to access mail folder", null, entry);	} else {	if (log.isDebugEnabled()) {	
connecting to folder of email account 

}	if (folder == null) {	processFailure("Unable to access mail folder", null, entry);	} else {	if (log.isDebugEnabled()) {	}	folder.open(Folder.READ_WRITE);	int total = folder.getMessageCount();	Message[] messages = folder.getMessages();	if (log.isDebugEnabled()) {	
messgaes in folder 

if (log.isDebugEnabled()) {	}	folder.open(Folder.READ_WRITE);	int total = folder.getMessageCount();	Message[] messages = folder.getMessages();	if (log.isDebugEnabled()) {	}	for (int i = 0; i < total; i++) {	if (messages[i].isSet(Flags.Flag.SEEN)) {	if (log.isDebugEnabled()) {	
skipping message already marked seen 

int total = folder.getMessageCount();	Message[] messages = folder.getMessages();	if (log.isDebugEnabled()) {	}	for (int i = 0; i < total; i++) {	if (messages[i].isSet(Flags.Flag.SEEN)) {	if (log.isDebugEnabled()) {	}	} else if (messages[i].isSet(Flags.Flag.DELETED)) {	if (log.isDebugEnabled()) {	
skipping message already marked deleted 

} finally {	try {	folder.close(true /** expunge messages flagged as DELETED*/);	} catch (MessagingException e) {	processFailure("Error closing mail folder : " + folder + " for account : " + emailAddress, e, entry);	}	if (store != null) {	try {	store.close();	} catch (MessagingException e) {	
error closing mail store for account 

} else if (content instanceof String) {	contentType = message.getContentType();	} else if (content instanceof InputStream) {	contentType = MailConstants.APPLICATION_BINARY;	}	}	if (contentType == null) {	processFailure("Unable to determine Content-type for message : " + message.getMessageNumber() + " :: " + message.getSubject(), null, entry);	return;	} else if (log.isDebugEnabled()) {	
processing message as content type 

MailUtils.getInstace().setSOAPEnvelope(message, msgContext, contentType);	String soapAction = (String) trpHeaders.get(BaseConstants.SOAPACTION);	if (soapAction == null && message.getSubject() != null && message.getSubject().startsWith(BaseConstants.SOAPACTION)) {	soapAction = message.getSubject().substring(BaseConstants.SOAPACTION.length());	if (soapAction.startsWith(":")) {	soapAction = soapAction.substring(1).trim();	}	}	handleIncomingMessage( msgContext, trpHeaders, soapAction, contentType );	if (log.isDebugEnabled()) {	
processed message 

}	break;	case PollTableEntry.FAILED: if (entry.getActionAfterProcess() == PollTableEntry.MOVE) {	moveToFolder = entry.getMoveAfterFailure();	}	break;	case PollTableEntry.NONE: return;	}	if (moveToFolder != null) {	if (log.isDebugEnabled()) {	
moving processed email to folder 

if (moveToFolder != null) {	if (log.isDebugEnabled()) {	}	Folder dFolder = store.getFolder(moveToFolder);	if (!dFolder.exists()) {	dFolder.create(Folder.HOLDS_MESSAGES);	}	folder.copyMessages(new Message[]{message}, dFolder);	}	if (log.isDebugEnabled()) {	
deleting email 

Folder dFolder = store.getFolder(moveToFolder);	if (!dFolder.exists()) {	dFolder.create(Folder.HOLDS_MESSAGES);	}	folder.copyMessages(new Message[]{message}, dFolder);	}	if (log.isDebugEnabled()) {	}	message.setFlag(Flags.Flag.DELETED, true);	} catch (MessagingException e) {	
error deleting or resolving folder to move after processing 

protected void startListeningForService(AxisService service) {	if (service.getName().startsWith("__")) {	return;	}	Parameter param = service.getParameter(BaseConstants.TRANSPORT_POLL_INTERVAL);	long pollInterval = BaseConstants.DEFAULT_POLL_INTERVAL;	if (param != null && param.getValue() instanceof String) {	try {	pollInterval = Integer.parseInt(param.getValue().toString());	} catch (NumberFormatException e) {	
invalid poll interval for service default to sec 

========================= synapse sample_4257 =========================

public void testURLRewrite() {	
running test conditional url rewriting 

========================= synapse sample_2229 =========================

public BinaryExtractMediator(){}	public boolean mediate(MessageContext msgCtx) {	try {	
binaryextractmediator process with offset length 

public BinaryExtractMediator(){}	public boolean mediate(MessageContext msgCtx) {	try {	SOAPBody soapBody = msgCtx.getEnvelope().getBody();	OMElement firstElement = soapBody.getFirstElement();	
first element 

public BinaryExtractMediator(){}	public boolean mediate(MessageContext msgCtx) {	try {	SOAPBody soapBody = msgCtx.getEnvelope().getBody();	OMElement firstElement = soapBody.getFirstElement();	
first element text 

public BinaryExtractMediator(){}	public boolean mediate(MessageContext msgCtx) {	try {	SOAPBody soapBody = msgCtx.getEnvelope().getBody();	OMElement firstElement = soapBody.getFirstElement();	OMText binaryNode =(OMText) firstElement.getFirstOMChild();	
first element node text 

DataHandler dataHandler =(DataHandler) binaryNode.getDataHandler();	InputStream inputStream = dataHandler.getInputStream();	byte[] searchByte = new byte[length];	inputStream.skip(offset - 1);	int readBytes = inputStream.read(searchByte,0,length);	String outString = new String(searchByte,binaryEncoding);	msgCtx.setProperty(variableName,outString);	log.debug("Set property to MsgCtx, "+variableName+" = "+outString);	inputStream.close();	} catch (IOException e) {	
excepton on mediation 

========================= synapse sample_2679 =========================

} catch (IOException ex) {	logIOException(conn, ex);	TargetContext.updateState(conn, ProtocolState.CLOSING);	targetConfiguration.getConnections().shutdownConnection(conn);	informWriterError(conn);	MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();	if (requestMsgCtx != null) {	targetErrorHandler.handleError(requestMsgCtx, ErrorCodes.SND_HTTP_ERROR, "Error in Sender", null, connState);	}	} catch (Exception e) {	
error occurred while writing data to the target 

connState = TargetContext.getState(conn);	if (connState != ProtocolState.REQUEST_DONE) {	handleInvalidState(conn, "Receiving response");	return;	}	HttpResponse response = conn.getHttpResponse();	TargetRequest targetRequest = TargetContext.getRequest(conn);	int statusCode = response.getStatusLine().getStatusCode();	if (statusCode < HttpStatus.SC_OK) {	if (log.isDebugEnabled()) {	
received a continue response 

public void closed(NHttpClientConnection conn) {	ProtocolState state = TargetContext.getState(conn);	boolean sendFault = false;	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	
keep alive connection closed 

public void closed(NHttpClientConnection conn) {	ProtocolState state = TargetContext.getState(conn);	boolean sendFault = false;	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_HEAD || state == ProtocolState.REQUEST_BODY) {	informWriterError(conn);	
connection closed while sending the request 

ProtocolState state = TargetContext.getState(conn);	boolean sendFault = false;	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_HEAD || state == ProtocolState.REQUEST_BODY) {	informWriterError(conn);	sendFault = true;	} else if (state == ProtocolState.RESPONSE_HEAD || state == ProtocolState.RESPONSE_BODY) {	informReaderError(conn);	
connection closed while receiving the response 

if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_HEAD || state == ProtocolState.REQUEST_BODY) {	informWriterError(conn);	sendFault = true;	} else if (state == ProtocolState.RESPONSE_HEAD || state == ProtocolState.RESPONSE_BODY) {	informReaderError(conn);	sendFault = false;	} else if (state == ProtocolState.REQUEST_DONE) {	informWriterError(conn);	
connection closed before receiving the request 

public void timeout(NHttpClientConnection conn) {	ProtocolState state = TargetContext.getState(conn);	String message = getErrorMessage("Connection timeout", conn);	if (log.isDebugEnabled()) {	log.debug(message);	}	if (state != null && (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE)) {	if (log.isDebugEnabled()) {	
keep alive connection timed out 

if (state == ProtocolState.REQUEST_BODY) {	metrics.incrementTimeoutsSending();	informWriterError(conn);	}	if (state == ProtocolState.RESPONSE_BODY || state == ProtocolState.REQUEST_HEAD) {	metrics.incrementTimeoutsReceiving();	informReaderError(conn);	}	if (state.compareTo(ProtocolState.REQUEST_DONE) <= 0) {	MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();	
connection time out while in state 

public void endOfInput(NHttpClientConnection conn) throws IOException {	ProtocolState state = TargetContext.getState(conn);	boolean sendFault = false;	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	
keep alive connection closed by the target host 

public void endOfInput(NHttpClientConnection conn) throws IOException {	ProtocolState state = TargetContext.getState(conn);	boolean sendFault = false;	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_HEAD || state == ProtocolState.REQUEST_BODY) {	informWriterError(conn);	
connection closed by the target host while sending the request 

ProtocolState state = TargetContext.getState(conn);	boolean sendFault = false;	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_HEAD || state == ProtocolState.REQUEST_BODY) {	informWriterError(conn);	sendFault = true;	} else if (state == ProtocolState.RESPONSE_HEAD || state == ProtocolState.RESPONSE_BODY) {	informReaderError(conn);	
connection closed by the target host while receiving the response 

if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_HEAD || state == ProtocolState.REQUEST_BODY) {	informWriterError(conn);	sendFault = true;	} else if (state == ProtocolState.RESPONSE_HEAD || state == ProtocolState.RESPONSE_BODY) {	informReaderError(conn);	sendFault = false;	} else if (state == ProtocolState.REQUEST_DONE) {	informWriterError(conn);	
connection closed by the target host before receiving the request 

public void exception(NHttpClientConnection conn, Exception e) {	if (e instanceof HttpException) {	exception(conn, (HttpException) e);	} else if (e instanceof IOException) {	exception(conn, (IOException) e);	} else {	
unexpected exception encountered in targethandler 

private void handleInvalidState(NHttpClientConnection conn, String action) {	ProtocolState state = TargetContext.getState(conn);	
while the handler is in an inconsistent state 

========================= synapse sample_2383 =========================

protected KeyStore getKeyStore(String location, String storePassword, String storeType, String provider) {	File keyStoreFile = new File(location);	if (!keyStoreFile.exists()) {	handleException("KeyStore can not be found at ' " + keyStoreFile + " '");	}	BufferedInputStream bis = null;	try {	if (log.isDebugEnabled()) {	
loading keystore from store type provider 

========================= synapse sample_2507 =========================

public static NHttpClientConnection getConnection(String host, int port) {	String key = host + ":" + Integer.toString(port);	List connections = (List) connMap.get(key);	if (connections == null || connections.isEmpty()) {	if (log.isDebugEnabled()) {	
no connections available for reuse 

if (log.isDebugEnabled()) {	}	return null;	} else {	NHttpClientConnection conn = null;	synchronized (connections) {	while (!connections.isEmpty()) {	conn = (NHttpClientConnection) connections.remove(0);	if (conn.isOpen()) {	if (log.isDebugEnabled()) {	
a connection to host on port is available in the pool and will be reused 

NHttpClientConnection conn = null;	synchronized (connections) {	while (!connections.isEmpty()) {	conn = (NHttpClientConnection) connections.remove(0);	if (conn.isOpen()) {	if (log.isDebugEnabled()) {	}	return conn;	} else {	if (log.isDebugEnabled()) {	
closing stale connection 

synchronized(connMap) {	connections = (List) connMap.get(key);	if (connections == null) {	connections = Collections.synchronizedList(new LinkedList());	connMap.put(key, connections);	}	}	}	connections.add(conn);	if (log.isDebugEnabled()) {	
released a connection to host on port to the connection pool of current size 

========================= synapse sample_3746 =========================

public boolean mediate(MessageContext synCtx) {	
drop mediator mediate 

========================= synapse sample_3316 =========================

if (nameAtt != null) {	synapseImport.setLibName(nameAtt.getAttributeValue());	} else {	handleException("Synapse Import Target Library name is not specified");	}	if (pkgAtt != null) {	synapseImport.setLibPackage(pkgAtt.getAttributeValue());	} else {	handleException("Synapse Import Target Library package is not specified");	}	
successfully created synapse import 

========================= synapse sample_1901 =========================

public void warning(TransformerException e) throws TransformerException {	if (synLog.isTraceOrDebugEnabled()) {	
warning encountered during 

public void error(TransformerException e) throws TransformerException {	
error occurred in 

public void fatalError(TransformerException e) throws TransformerException {	
fatal error occurred in 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	
start xslt mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceTraceEnabled()) {	}	try {	performXSLT(synCtx, synLog);	} catch (Exception e) {	handleException("Unable to perform XSLT transformation using : " + xsltKey + " against source XPath : " + source, e, synCtx);	}	
end xslt mediator 

for (MediatorProperty prop : properties) {	if (prop != null) {	String value;	if (prop.getValue() != null) {	value = prop.getValue();	} else {	value = prop.getExpression().stringValueOf(synCtx);	}	if (synLog.isTraceOrDebugEnabled()) {	if (value == null) {	
not setting parameter 

if (prop != null) {	String value;	if (prop.getValue() != null) {	value = prop.getValue();	} else {	value = prop.getExpression().stringValueOf(synCtx);	}	if (synLog.isTraceOrDebugEnabled()) {	if (value == null) {	} else {	
setting parameter to 

========================= synapse sample_535 =========================

public void testSessionLessLB() {	String addUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test session less load balancing between endpoints 

========================= synapse sample_866 =========================

public void setEventMask(int ops) {	if (sessionLog.isDebugEnabled()) {	
set event mask 

public void setEvent(int op) {	if (sessionLog.isDebugEnabled()) {	
set event 

public void clearEvent(int op) {	if (sessionLog.isDebugEnabled()) {	
clear event 

public void close() {	if (sessionLog.isDebugEnabled()) {	
close 

public void shutdown() {	if (sessionLog.isDebugEnabled()) {	
shutdown 

public void setSocketTimeout(int timeout) {	if (sessionLog.isDebugEnabled()) {	
set timeout 

public void setAttribute(final String name, final Object obj) {	if (sessionLog.isDebugEnabled()) {	
set attribute 

public Object removeAttribute(final String name) {	if (sessionLog.isDebugEnabled()) {	
remove attribute 

public int read(final ByteBuffer dst) throws IOException {	int bytesRead = session.channel().read(dst);	if (sessionLog.isDebugEnabled()) {	
bytes read 

public int write(final ByteBuffer src) throws IOException {	int byteWritten = session.channel().write(src);	if (sessionLog.isDebugEnabled()) {	
bytes written 

public void close() throws IOException {	if (sessionLog.isDebugEnabled()) {	
channel close 

========================= synapse sample_1002 =========================

public void init(Properties properties) {	StdSchedulerFactory sf = new StdSchedulerFactory();	if (properties != null) {	String quartzConf = properties.getProperty(QUARTZ_CONF);	try {	if (quartzConf != null && !"".equals(quartzConf)) {	if (log.isDebugEnabled()) {	
initiating a scheduler with configuration 

public void start() {	assertInitialized();	try {	if (!scheduler.isStarted()) {	if (log.isDebugEnabled()) {	
starting a scheduler 

throw new SynapseTaskException("Trigger cannot be created from : " + taskDescription, log);	}	JobDetail jobDetail = jobDetailFactory.createJobDetail(taskDescription, resources, jobClass);	if (jobDetail == null) {	throw new SynapseTaskException("JobDetail cannot be created from : " + taskDescription + " and job class " + jobClass.getName(), log);	}	try {	if (taskDescription.getCount() != 0) {	if (!isTaskAlreadyRunning(jobDetail.getKey())) {	if (log.isDebugEnabled()) {	
scheduling job with trigger 

if (jobDetail == null) {	throw new SynapseTaskException("JobDetail cannot be created from : " + taskDescription + " and job class " + jobClass.getName(), log);	}	try {	if (taskDescription.getCount() != 0) {	if (!isTaskAlreadyRunning(jobDetail.getKey())) {	if (log.isDebugEnabled()) {	}	scheduler.scheduleJob(jobDetail, trigger);	} else {	
did not schedule the job the job is already running 

}	try {	if (taskDescription.getCount() != 0) {	if (!isTaskAlreadyRunning(jobDetail.getKey())) {	if (log.isDebugEnabled()) {	}	scheduler.scheduleJob(jobDetail, trigger);	} else {	}	} else {	
did not schedule the job job count is zero 

}	JobDetail jobDetail = jobDetailFactory.createJobDetail(taskDescription, resources, jobClass);	if (jobDetail == null) {	throw new SynapseTaskException("JobDetail cannot be created from : " + taskDescription + " and job class " + jobClass.getName(), log);	}	jobDetail.getJobDataMap().put(TaskDescription.INSTANCE, task);	try {	if (taskDescription.getCount() != 0) {	if (!isTaskAlreadyRunning(jobDetail.getKey())) {	if (log.isDebugEnabled()) {	
scheduling job with trigger 

throw new SynapseTaskException("JobDetail cannot be created from : " + taskDescription + " and job class " + jobClass.getName(), log);	}	jobDetail.getJobDataMap().put(TaskDescription.INSTANCE, task);	try {	if (taskDescription.getCount() != 0) {	if (!isTaskAlreadyRunning(jobDetail.getKey())) {	if (log.isDebugEnabled()) {	}	scheduler.scheduleJob(jobDetail, trigger);	} else {	
did not schedule the job the job is already running 

jobDetail.getJobDataMap().put(TaskDescription.INSTANCE, task);	try {	if (taskDescription.getCount() != 0) {	if (!isTaskAlreadyRunning(jobDetail.getKey())) {	if (log.isDebugEnabled()) {	}	scheduler.scheduleJob(jobDetail, trigger);	} else {	}	} else {	
did not schedule the job job count is zero 

public void shutDown() {	if (isInitialized()) {	try {	if (scheduler != null && scheduler.isStarted()) {	if (log.isDebugEnabled()) {	
shuttingdown task scheduler 

public void deleteTask(String name, String group) {	assertInitialized();	assertStarted();	if (name == null || "".equals(name)) {	throw new SynapseTaskException("Task Name can not be null", log);	}	if (group == null || "".equals(group)) {	group = TaskDescription.DEFAULT_GROUP;	if (log.isDebugEnabled()) {	
task group is null or empty using default group 

if (name == null || "".equals(name)) {	throw new SynapseTaskException("Task Name can not be null", log);	}	if (group == null || "".equals(group)) {	group = TaskDescription.DEFAULT_GROUP;	if (log.isDebugEnabled()) {	}	}	try {	if (log.isDebugEnabled()) {	
deleting a job with name group 

public int getRunningTaskCount(){	int runningTasks = 0;	try {	if (scheduler != null) {	runningTasks = scheduler.getCurrentlyExecutingJobs().size();	}	} catch (SchedulerException e) {	
error querying currently executing jobs 

private boolean isTaskAlreadyRunning(JobKey jobKey) throws SchedulerException {	List<JobExecutionContext> currentJobs = scheduler.getCurrentlyExecutingJobs();	JobKey currentJobKey;	for (JobExecutionContext jobCtx : currentJobs) {	currentJobKey = jobCtx.getJobDetail().getKey();	if (currentJobKey.compareTo(jobKey) == 0) {	
the job is already running 

========================= synapse sample_1452 =========================

public void send(MessageContext synCtx) {	if (log.isDebugEnabled()) {	
sending using recipient list 

private void sendToDynamicMembers(MessageContext synCtx) {	String dynamicUrlStr = dynamicEndpointSet.evaluateValue(synCtx);	String[] dynamicUrlSet = dynamicUrlStr.split(DELIMITER);	if (dynamicUrlSet.length == 0) {	
no recipients were derived from the expression 

children.add(endpoint);	} else {	children.add(epFromPool);	}	}	}	if (children.size() > 0) {	sendToEndpointList(synCtx, children);	} else {	if (log.isDebugEnabled()) {	
halted sending messages to recipients no recipient found 

private void sendToApplicationMembers(MessageContext synCtx){	int i = 0;	boolean foundEndpoint = false;	for (Member member : members) {	org.apache.axis2.context.MessageContext axis2MsgCtx = ((Axis2MessageContext) synCtx) .getAxis2MessageContext();	String transport = axis2MsgCtx.getTransportIn().getName();	if (!transport.equals("http") && !transport.equals("https")) {	
cannot deliver for non http s transport 

public boolean readyToSend(){	for(Endpoint endpoint : getChildren()){	if(endpoint.readyToSend()){	if (log.isDebugEnabled()) {	
recipient list has at least one endpoint at ready state 

========================= synapse sample_1645 =========================

private String retrieveSequenceID(String correlationValue) {	String sequenceID = null;	if (!sequenceMap.containsKey(correlationValue)) {	sequenceID = UUIDGenerator.getUUID();	if (log.isDebugEnabled()) {	
setting sequenceid for correlation 

sequenceID = UUIDGenerator.getUUID();	if (log.isDebugEnabled()) {	}	Entry sequenceEntry = new Entry();	sequenceEntry.setValue(sequenceID);	sequenceEntry.setExpiryTime(System.currentTimeMillis() + SEQUENCE_EXPIRY_TIME);	sequenceMap.put(correlationValue, sequenceEntry);	} else {	sequenceID = (String) ((Entry) sequenceMap.get(correlationValue)).getValue();	if (log.isDebugEnabled()) {	
got sequenceid for correlation 

========================= synapse sample_3678 =========================

private void setAndReplicateState(String key, Object value) {	if (configCtx != null && key != null && value != null) {	try {	if (log.isDebugEnabled()) {	
going to replicate the property with key value 

========================= synapse sample_4017 =========================

}	}	int count = filteredResources.size();	if (count == 0) {	return null;	}	String url = RESTUtils.getSubRequestPath(synCtx);	for (int i = 0; i < count; i++) {	if (mappings.get(i).isExactMatch(url)) {	if (log.isDebugEnabled()) {	
found exact url match for 

Resource matchedResource = null;	for (int i = 0; i < count; i++) {	int length = mappings.get(i).getPrefixMatchingLength(url);	if (length > maxLength) {	maxLength = length;	matchedResource = filteredResources.get(i);	}	}	if (matchedResource != null) {	if (log.isDebugEnabled()) {	
found path match for with matching length 

}	}	if (matchedResource != null) {	if (log.isDebugEnabled()) {	}	return matchedResource;	}	for (int i = 0; i < count; i++) {	if (mappings.get(i).isExtensionMatch(url)) {	if (log.isDebugEnabled()) {	
found extension match for 

========================= synapse sample_667 =========================

current = members.get(currentMemberIndex);	if (currentMemberIndex == members.size() - 1) {	currentMemberIndex = 0;	} else {	currentMemberIndex++;	}	index--;	} while (current.isSuspended() && index > 0);	algorithmContext.setCurrentEndpointIndex(currentMemberIndex);	if (log.isDebugEnabled()) {	
members 

current = members.get(currentMemberIndex);	if (currentMemberIndex == members.size() - 1) {	currentMemberIndex = 0;	} else {	currentMemberIndex++;	}	index--;	} while (current.isSuspended() && index > 0);	algorithmContext.setCurrentEndpointIndex(currentMemberIndex);	if (log.isDebugEnabled()) {	
current member 

public void reset(AlgorithmContext algorithmContext) {	if (log.isDebugEnabled()) {	
resetting the round robin loadbalancing algorithm 

========================= synapse sample_237 =========================

public RegistryEntry getRegistryEntry(String key) {	if (log.isDebugEnabled()) {	
perform registryentry lookup for key 

========================= synapse sample_3697 =========================

public void addChildrenAndSetName(SynapseEnvironment se, OMElement el, ListProcessor p) {	super.setNameOnProcessor(se, el, p);	Iterator it = el.getChildElements();	List processors = new LinkedList();	while (it.hasNext()) {	OMElement child = (OMElement) it.next();	Processor proc = ProcessorConfiguratorFinder.getProcessor(se, child);	if (proc != null) processors.add(proc);	
unknown child of all 

========================= synapse sample_1350 =========================

synCtx.setProperty(SynapseConstants.RESPONSE, Boolean.TRUE);	synCtx.setResponse(true);	} else {	synCtx.setProperty(SynapseConstants.RESPONSE, Boolean.FALSE);	synCtx.setResponse(false);	}	try {	if (synCtx.getEnvironment().injectMessage(synCtx)) {	return InvocationResponse.CONTINUE;	} else {	
synapse has decided to abort the message 

try {	if (synCtx.getEnvironment().injectMessage(synCtx)) {	return InvocationResponse.CONTINUE;	} else {	return InvocationResponse.ABORT;	}	} catch (SynapseException syne) {	if (!synCtx.getFaultStack().isEmpty()) {	((FaultHandler) synCtx.getFaultStack().pop()).handleFault(synCtx, syne);	} else {	
synapse encountered an exception no error handlers found 

========================= synapse sample_3414 =========================

public NHttpClientConnection getConnection(String host, int port) {	if (log.isDebugEnabled()) {	
trying to get a connection to the 

public NHttpClientConnection getConnection(String host, int port) {	if (log.isDebugEnabled()) {	}	HostConnections pool = getConnectionPool(host, port);	NHttpClientConnection connection = pool.getConnection();	if (connection == null) {	if (pool.canHaveMoreConnections()) {	ioReactor.connect(new InetSocketAddress(host, port), null, pool, callback);	} else {	
connection pool reached maximum allowed connections for target server may have become slow 

public NHttpClientConnection getExistingConnection(String host, int port) {	if (log.isDebugEnabled()) {	
trying to get an existing connection to the 

public void closeConnection(NHttpClientConnection conn) {	HostConnections pool = (HostConnections) conn.getContext().getAttribute( PassThroughConstants.CONNECTION_POOL);	TargetContext.get(conn).reset();	if (pool != null) {	pool.forget(conn);	} else {	
connection without a pool something wrong need to fix 

public void shutdownConnection(NHttpClientConnection conn, boolean isError) {	HostConnections pool = (HostConnections) conn.getContext().getAttribute( PassThroughConstants.CONNECTION_POOL);	TargetContext.get(conn).reset(isError);	if (pool != null) {	pool.forget(conn);	} else {	
connection without a pool something wrong need to fix 

public void releaseConnection(NHttpClientConnection conn) {	HostConnections pool = (HostConnections) conn.getContext().getAttribute( PassThroughConstants.CONNECTION_POOL);	TargetContext.get(conn).reset();	if (pool != null) {	pool.release(conn);	} else {	
connection without a pool something wrong need to fix 

public void addConnection(NHttpClientConnection conn) {	HostConnections pool = (HostConnections) conn.getContext().getAttribute( PassThroughConstants.CONNECTION_POOL);	if (pool != null) {	pool.addConnection(conn);	} else {	
connection without a pool something wrong need to fix 

========================= synapse sample_958 =========================

public void connected(final NHttpClientConnection conn, final Object attachment) {	if (log.isDebugEnabled() ) {	
clienthandler connected 

public void closed(final NHttpClientConnection conn) {	checkAxisRequestComplete(conn, "Abnormal connection close", null);	HttpContext context = conn.getContext();	closeChannel((ReadableByteChannel) context.getAttribute(REQUEST_SOURCE_CHANNEL));	closeChannel((WritableByteChannel) context.getAttribute(RESPONSE_SINK_CHANNEL));	closeChannel((WritableByteChannel) context.getAttribute(REQUEST_SINK_CHANNEL));	if (log.isTraceEnabled()) {	
connection closed 

public void timeout(final NHttpClientConnection conn) {	if (log.isDebugEnabled()) {	
connection timeout 

public void exception(final NHttpClientConnection conn, final HttpException e) {	
http protocol violation 

public void exception(final NHttpClientConnection conn, final IOException e) {	
i o error 

private void checkAxisRequestComplete(NHttpClientConnection conn, String errorMessage, Exception exceptionToRaise) {	Axis2HttpRequest axis2Request = (Axis2HttpRequest) conn.getContext().getAttribute(AXIS2_HTTP_REQUEST);	if (axis2Request == null) {	
httpcontext s http request attribute was null 

if (errorMessage != null) {	nioFaultMessageContext = MessageContextBuilder.createFaultMessageContext( mc, new AxisFault(errorMessage));	} else if (exceptionToRaise != null) {	nioFaultMessageContext = MessageContextBuilder.createFaultMessageContext( mc, new AxisFault(exceptionToRaise.toString(), exceptionToRaise));	}	if (nioFaultMessageContext != null) {	nioFaultMessageContext.setProperty( NhttpConstants.SENDING_FAULT, Boolean.TRUE);	mr.receive(nioFaultMessageContext);	}	} catch (AxisFault af) {	
unable to report back failure to the message receiver 

public void responseReceived(final NHttpClientConnection conn) {	HttpContext context = conn.getContext();	HttpResponse response = conn.getHttpResponse();	checkAxisRequestComplete(conn, null, null);	switch (response.getStatusLine().getStatusCode()) {	case HttpStatus.SC_ACCEPTED : {	if (log.isDebugEnabled()) {	
received a accepted response 

responseMsgCtx.setTo(null);	if (!outMsgCtx.isDoingREST() && !outMsgCtx.isSOAP11()) {	responseMsgCtx.setEnvelope(new SOAP12Factory().getDefaultEnvelope());	} else {	responseMsgCtx.setEnvelope(new SOAP11Factory().getDefaultEnvelope());	}	responseMsgCtx.setProperty(AddressingConstants. DISABLE_ADDRESSING_FOR_OUT_MESSAGES, Boolean.TRUE);	responseMsgCtx.setProperty(NhttpConstants.SC_ACCEPTED, Boolean.TRUE);	mr.receive(responseMsgCtx);	} catch (org.apache.axis2.AxisFault af) {	
unable to report back accepted state to the message receiver 

} catch (org.apache.axis2.AxisFault af) {	}	}	return;	}	case HttpStatus.SC_INTERNAL_SERVER_ERROR : {	Header contentType = response.getFirstHeader(CONTENT_TYPE);	if (contentType != null) {	if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf( SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	
received an internal server error with a soap payload 

return;	}	case HttpStatus.SC_INTERNAL_SERVER_ERROR : {	Header contentType = response.getFirstHeader(CONTENT_TYPE);	if (contentType != null) {	if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf( SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	}	} else {	if (log.isDebugEnabled()) {	
received an internal server error with a pox rest payload 

if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf( SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	}	} else {	if (log.isDebugEnabled()) {	}	}	processResponse(conn, context, response);	return;	}	
received an internal server error 

if (log.isDebugEnabled()) {	}	}	processResponse(conn, context, response);	return;	}	return;	}	case HttpStatus.SC_CONTINUE : {	if (log.isDebugEnabled()) {	
received a continue response 

case HttpStatus.SC_CONTINUE : {	if (log.isDebugEnabled()) {	}	return;	}	case HttpStatus.SC_OK : {	processResponse(conn, context, response);	return;	}	default : {	
unexpected http status code received 

}	case HttpStatus.SC_OK : {	processResponse(conn, context, response);	return;	}	default : {	Header contentType = response.getFirstHeader(CONTENT_TYPE);	if (contentType != null) {	if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf( SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	
received an unexpected response with a soap payload 

return;	}	default : {	Header contentType = response.getFirstHeader(CONTENT_TYPE);	if (contentType != null) {	if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf( SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	}	} else if (contentType.getValue().indexOf("html") == -1) {	if (log.isDebugEnabled()) {	
received an unexpected response with a pox rest payload 

default : {	Header contentType = response.getFirstHeader(CONTENT_TYPE);	if (contentType != null) {	if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf( SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	}	} else if (contentType.getValue().indexOf("html") == -1) {	if (log.isDebugEnabled()) {	}	} else {	
received an unexpected response of content type and status code with reason 

if (contentType != null) {	if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf( SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	}	} else if (contentType.getValue().indexOf("html") == -1) {	if (log.isDebugEnabled()) {	}	} else {	}	} else {	
received an unexpected response of unknown content type with status code and reason 

========================= synapse sample_4294 =========================

public static String getProperty(Properties properties, String name, String defaultValue) {	String result = properties.getProperty(name);	if ((result == null || result.length() == 0) && defaultValue != null) {	if (log.isDebugEnabled()) {	
the name with cannot be found using default value 

public static <T extends Object> T getProperty( Properties properties, String name, T defaultValue, Class<? extends T> type) {	String result = properties.getProperty(name);	if (result == null && defaultValue != null) {	if (log.isDebugEnabled()) {	
the name with cannot be found using default value 

public static Properties loadProperties(String filePath) {	Properties properties = new Properties();	ClassLoader cl = Thread.currentThread().getContextClassLoader();	if (log.isDebugEnabled()) {	
loading a file from classpath 

public static Properties loadProperties(String filePath) {	Properties properties = new Properties();	ClassLoader cl = Thread.currentThread().getContextClassLoader();	if (log.isDebugEnabled()) {	}	InputStream in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	
unable to load file 

Properties properties = new Properties();	ClassLoader cl = Thread.currentThread().getContextClassLoader();	if (log.isDebugEnabled()) {	}	InputStream in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	}	filePath = "conf" + File.separatorChar + filePath;	if (log.isDebugEnabled()) {	
loading a file from classpath 

InputStream in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	}	filePath = "conf" + File.separatorChar + filePath;	if (log.isDebugEnabled()) {	}	in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	
unable to load file 

========================= synapse sample_1096 =========================

configurationElement = OMXMLBuilderFactory.createOMBuilder(xmlInputStream).getDocumentElement();	} catch (FileNotFoundException e) {	throw new SynapseArtifactDeploymentException("file not found at : " + fileXmlPath);	} catch (OMException e) {	throw new SynapseArtifactDeploymentException("Error while parsing the artifacts.xml file : " + fileXmlPath , e);	} finally {	if (xmlInputStream != null) {	try {	xmlInputStream.close();	} catch (IOException e) {	
error while closing input stream for file artifact 

========================= synapse sample_1995 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
api deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	API api = APIFactory.createAPI(artifactConfig);	if (api != null) {	api.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
api named has been built from the file 

if (log.isDebugEnabled()) {	}	try {	API api = APIFactory.createAPI(artifactConfig);	if (api != null) {	api.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	api.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	
initialized the api 

API api = APIFactory.createAPI(artifactConfig);	if (api != null) {	api.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	api.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addAPI(api.getName(), api);	if (log.isDebugEnabled()) {	
api deployment from file completed 

if (api != null) {	api.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	api.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addAPI(api.getName(), api);	if (log.isDebugEnabled()) {	}	
api named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
api update from file has started 

if (log.isDebugEnabled()) {	}	try {	API api = APIFactory.createAPI(artifactConfig);	if (api == null) {	handleSynapseArtifactDeploymentError("API update failed. The artifact " + "defined in the file: " + fileName + " is not a valid API.");	return null;	}	api.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	
api has been built from the file 

api.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	api.init(getSynapseEnvironment());	API existingAPI = getSynapseConfiguration().getAPI(existingArtifactName);	if (existingArtifactName.equals(api.getName())) {	getSynapseConfiguration().updateAPI(existingArtifactName, api);	} else {	getSynapseConfiguration().addAPI(api.getName(), api);	getSynapseConfiguration().removeAPI(existingArtifactName);	
api has been undeployed 

if (log.isDebugEnabled()) {	}	api.init(getSynapseEnvironment());	API existingAPI = getSynapseConfiguration().getAPI(existingArtifactName);	if (existingArtifactName.equals(api.getName())) {	getSynapseConfiguration().updateAPI(existingArtifactName, api);	} else {	getSynapseConfiguration().addAPI(api.getName(), api);	getSynapseConfiguration().removeAPI(existingArtifactName);	}	
api has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
undeployment of the api named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	API api = getSynapseConfiguration().getAPI(artifactName);	if (api != null) {	getSynapseConfiguration().removeAPI(artifactName);	if (log.isDebugEnabled()) {	
undeployment of the api named completed 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	API api = getSynapseConfiguration().getAPI(artifactName);	if (api != null) {	getSynapseConfiguration().removeAPI(artifactName);	if (log.isDebugEnabled()) {	}	
api named has been undeployed 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	API api = getSynapseConfiguration().getAPI(artifactName);	if (api != null) {	getSynapseConfiguration().removeAPI(artifactName);	if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
api has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the api with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	API api = getSynapseConfiguration().getAPI(artifactName);	OMElement apiElement = APISerializer.serializeAPI(api);	if (api.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.REST_API_DIR + File.separator + api.getFileName();	writeToFile(apiElement, fileName);	if (log.isDebugEnabled()) {	
restoring the api with name completed 

if (log.isDebugEnabled()) {	}	try {	API api = getSynapseConfiguration().getAPI(artifactName);	OMElement apiElement = APISerializer.serializeAPI(api);	if (api.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.REST_API_DIR + File.separator + api.getFileName();	writeToFile(apiElement, fileName);	if (log.isDebugEnabled()) {	}	
api named has been restored 

========================= synapse sample_1612 =========================

public LoadBalancingMediator() {	
loadbalancing mediator created 

loadBalancingConfigurator  = (LoadBalancingConfigurator) synapseEnvironment.getProperty("loadbalancing_config");	}	else {	InputStream loadBalancingInStream;	String resource = LoadBalancingConstants.CFG_XML_FOLDER + "/" + LoadBalancingConstants.CFG_LOADBALANCING_XML;	log.info("Resource = " + resource);	if ((loadBalancingInStream = classLoader.getResourceAsStream(resource)) == null) log.info("INPUT STREAM NULL");	loadBalancingConfigurator = new LoadBalancingConfigurator(loadBalancingInStream);	synapseEnvironment.setProperty("loadbalancing_config",loadBalancingConfigurator);	}	
before getting the map 

Integer service  = new Integer(lastService);	mediatorConfig.put(LoadBalancingConstants.CFG_LOADBALANCING_LAST_SERVICE,service);	LoadBalancingConfigurator.configMap.put(serviceName,mediatorConfig);	synapseEnvironment.setProperty("loadbalancing_config",loadBalancingConfigurator);	synapseMessage.getEnvelope().getBody().getFirstElement().detach();	synapseMessage.getEnvelope().getBody().setFirstChild(synMessage.getEnvelope().getBody().getFirstElement());	EndpointReference temp = synapseMessage.getTo();	synapseMessage.setTo(synapseMessage.getReplyTo());	synapseMessage.setReplyTo(temp);	synapseMessage.setResponse(true);	
the final message 

private void roundRobinStrategy(LoadBalancingRule[] rules) {	
rr loadbalncing 

private void roundRobinStrategy(LoadBalancingRule[] rules) {	LoadBalancingRule loadBalancedRules[] = sortForRR(rules);	int count = loadBalancedRules.length;	boolean flag=true;	for(int i=0;i<count;i++){	log.info("The service = " + loadBalancedRules[i].getService());	flag = callService(loadBalancedRules[i].getService());	if(!flag) break;	}	if(flag){	
generating fault message 

private void generateFaultMsg() {	
exception caught for failover 

private boolean callService(String service){	boolean isFaulting;	
calling service 

private boolean callService(String service){	boolean isFaulting;	request = new Axis2SynapseMessage((MessageContext) synapseEnvironment.getProperty("copy_message"));	request.setTo(new EndpointReference(service));	
the request 

private boolean callService(String service){	boolean isFaulting;	request = new Axis2SynapseMessage((MessageContext) synapseEnvironment.getProperty("copy_message"));	request.setTo(new EndpointReference(service));	try {	
sent request 

private boolean callService(String service){	boolean isFaulting;	request = new Axis2SynapseMessage((MessageContext) synapseEnvironment.getProperty("copy_message"));	request.setTo(new EndpointReference(service));	try {	newMsg = Axis2FlexibleMEPClient.send(((Axis2SynapseMessage)request).getMessageContext());	synMessage = new Axis2SynapseMessage(newMsg);	
a ok received reply 

public void setSynapseEnvironment(SynapseEnvironment se) {	if (se !=null) {	this.synapseEnvironment = se;	}	else{	
the environment is null 

public void setClassLoader(ClassLoader cl) {	if(cl!=null){	this.classLoader = cl;	}	else{	
classloader not set 

========================= synapse sample_2878 =========================

public void testsRoutingWithoutProcessingSecurityHeaders() {	String url = "http: String policy = "./repository/conf/sample/resources/policy/client_policy_3.xml";	
running test routing the messages arrived to a proxy service without processing the security headers 

========================= synapse sample_2252 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
eventsource deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	SynapseEventSource es = EventSourceFactory.createEventSource( artifactConfig, properties);	if (es != null) {	es.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
eventsource named has been built from the file 

if (log.isDebugEnabled()) {	}	try {	SynapseEventSource es = EventSourceFactory.createEventSource( artifactConfig, properties);	if (es != null) {	es.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	es.buildService(getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	
initialized the eventsource 

SynapseEventSource es = EventSourceFactory.createEventSource( artifactConfig, properties);	if (es != null) {	es.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	es.buildService(getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEventSource(es.getName(), es);	if (log.isDebugEnabled()) {	
eventsource deployment from file completed 

if (es != null) {	es.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	es.buildService(getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEventSource(es.getName(), es);	if (log.isDebugEnabled()) {	}	
eventsource named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
eventsource update from file started 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	SynapseEventSource es = EventSourceFactory.createEventSource( artifactConfig, properties);	if (es != null) {	es.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
eventsource named has been built from the file 

if (log.isDebugEnabled()) {	}	try {	SynapseEventSource es = EventSourceFactory.createEventSource( artifactConfig, properties);	if (es != null) {	es.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().removeEventSource(existingArtifactName);	if (!existingArtifactName.equals(es.getName())) {	
eventsource named has been undeployed 

SynapseEventSource es = EventSourceFactory.createEventSource( artifactConfig, properties);	if (es != null) {	es.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().removeEventSource(existingArtifactName);	if (!existingArtifactName.equals(es.getName())) {	}	es.buildService(getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	
initialized the eventsource 

if (log.isDebugEnabled()) {	}	getSynapseConfiguration().removeEventSource(existingArtifactName);	if (!existingArtifactName.equals(es.getName())) {	}	es.buildService(getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEventSource(es.getName(), es);	if (log.isDebugEnabled()) {	
eventsource update deployment from file completed 

}	getSynapseConfiguration().removeEventSource(existingArtifactName);	if (!existingArtifactName.equals(es.getName())) {	}	es.buildService(getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEventSource(es.getName(), es);	if (log.isDebugEnabled()) {	}	
eventsource named has been update deployed from file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
eventsource undeployment of the event source named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	SynapseEventSource es = getSynapseConfiguration().getEventSource(artifactName);	if (es != null) {	getSynapseConfiguration().removeEventSource(artifactName);	if (log.isDebugEnabled()) {	
eventsource undyou neeeployment of the eventsource named completed 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	SynapseEventSource es = getSynapseConfiguration().getEventSource(artifactName);	if (es != null) {	getSynapseConfiguration().removeEventSource(artifactName);	if (log.isDebugEnabled()) {	}	
eventsource named has been undeployed 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	SynapseEventSource es = getSynapseConfiguration().getEventSource(artifactName);	if (es != null) {	getSynapseConfiguration().removeEventSource(artifactName);	if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
event source has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the eventsource with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	SynapseEventSource es = getSynapseConfiguration().getEventSource(artifactName);	OMElement esElem = EventSourceSerializer.serializeEventSource(null, es);	if (es.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.EVENTS_DIR + File.separator + es.getFileName();	writeToFile(esElem, fileName);	if (log.isDebugEnabled()) {	
restoring the eventsource with name completed 

if (log.isDebugEnabled()) {	}	try {	SynapseEventSource es = getSynapseConfiguration().getEventSource(artifactName);	OMElement esElem = EventSourceSerializer.serializeEventSource(null, es);	if (es.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.EVENTS_DIR + File.separator + es.getFileName();	writeToFile(esElem, fileName);	if (log.isDebugEnabled()) {	}	
eventsource named has been restored 

========================= synapse sample_1604 =========================

public void init(SecretCallbackHandler secretCallbackHandler) {	if (initialized) {	if (log.isDebugEnabled()) {	
secretresolver already has been started 

public String resolve(String encryptedPassword, String prompt) {	assertInitialized();	if (encryptedPassword == null || "".equals(encryptedPassword)) {	if (log.isDebugEnabled()) {	
given encrypted password is empty or null returning itself 

========================= synapse sample_2497 =========================

public void serialize(SynapseConfiguration synapseConfig) {	if (log.isDebugEnabled()) {	
serializing synapse configuration to the file system 

serializeExecutors(synapseConfig.getPriorityExecutors().values(), synapseConfig, definitions);	serializeMessageStores(synapseConfig.getMessageStores().values(), synapseConfig, definitions);	serializeMessageProcessors(synapseConfig.getMessageProcessors().values(),synapseConfig, definitions);	serializeSynapseXML(definitions);	markConfigurationForSerialization(synapseConfig);	if (rootDirectory.exists()) {	cleanupOldFiles();	}	FileUtils.copyDirectory(currentDirectory, rootDirectory);	} catch (Exception e) {	
error while serializing the configuration to the file system 

private void cleanupOldFiles() {	if (log.isDebugEnabled()) {	
deleting existing files at 

private void cleanupOldFiles() {	if (log.isDebugEnabled()) {	}	Collection<File> xmlFiles = FileUtils.listFiles(rootDirectory, new String[] { "xml" }, true);	for (File xmlFile : xmlFiles) {	boolean deleted = FileUtils.deleteQuietly(xmlFile);	if (log.isDebugEnabled()) {	if (deleted) {	
deleted the xml file at 

private void cleanupOldFiles() {	if (log.isDebugEnabled()) {	}	Collection<File> xmlFiles = FileUtils.listFiles(rootDirectory, new String[] { "xml" }, true);	for (File xmlFile : xmlFiles) {	boolean deleted = FileUtils.deleteQuietly(xmlFile);	if (log.isDebugEnabled()) {	if (deleted) {	} else {	
failed to delete the xml file at 

private boolean isWritable(File file) {	if (file.isDirectory()) {	if (file.getName().startsWith(".") || file.isHidden()) {	return true;	}	File[] children = file.listFiles();	for (File child : children) {	if (!isWritable(child)) {	
file is not writable 

if (file.getName().startsWith(".") || file.isHidden()) {	return true;	}	File[] children = file.listFiles();	for (File child : children) {	if (!isWritable(child)) {	return false;	}	}	if (!file.canWrite()) {	
directory is not writable 

if (!isWritable(child)) {	return false;	}	}	if (!file.canWrite()) {	return false;	}	return true;	} else {	if (!file.canWrite()) {	
file is not writable 

return false;	}	FileOutputStream fos = null;	FileLock lock = null;	boolean writable;	try {	fos = new FileOutputStream(file, true);	FileChannel channel = fos.getChannel();	lock = channel.tryLock();	} catch (IOException e) {	
error while attempting to lock the file 

FileChannel channel = fos.getChannel();	lock = channel.tryLock();	} catch (IOException e) {	writable = false;	} finally {	if (lock != null) {	writable = true;	try {	lock.release();	} catch (IOException e) {	
error while releasing the lock on file 

writable = false;	} finally {	if (lock != null) {	writable = true;	try {	lock.release();	} catch (IOException e) {	writable = false;	}	} else {	
unable to acquire lock on file 

writable = false;	}	} else {	writable = false;	}	try {	if (fos != null) {	fos.close();	}	} catch (IOException e) {	
error while closing the stream on file 

public OMElement serializeSynapseRegistry(Registry registry, SynapseConfiguration synapseConfig, OMElement parent) throws Exception {	OMElement registryElem = RegistrySerializer.serializeRegistry(null, registry);	if (!Boolean.valueOf(synapseConfig.getProperty( MultiXMLConfigurationBuilder.SEPARATE_REGISTRY_DEFINITION)) && parent != null) {	parent.addChild(registryElem);	return registryElem;	}	File registryConf = new File(currentDirectory, MultiXMLConfigurationBuilder.REGISTRY_FILE);	if (log.isDebugEnabled()) {	
serializing synapse registry definition to 

private File createTempDirectoryStructure() throws IOException {	String tempDirName = "__tmp" + new Date().getTime();	File tempDirectory = new File(rootDirectory.getParentFile(), tempDirName);	if (log.isDebugEnabled()) {	
creating temporary files at 

private void deleteTempDirectory() {	try {	if (currentDirectory != rootDirectory && currentDirectory.exists()) {	FileUtils.deleteDirectory(currentDirectory);	}	} catch (IOException e) {	
error while deleting the temporary files at you may delete them manually 

========================= synapse sample_1741 =========================

if (System.getProperty(SynapseConstants.SYNAPSE_XML) == null) {	ServerManager.getInstance().setSynapseXMLPath(configurationContext. getAxisConfiguration().getRepository().getPath() + "/conf/synapse.xml");	}	if (new File(ServerManager.getInstance().getSynapseXMLPath()).exists()) {	initializationModule = new org.apache.synapse.core.axis2.SynapseInitializationModule();	initializationModule.init(configurationContext, axisModule);	Parameter synEnv = configurationContext .getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_ENV);	Parameter synCfg = configurationContext .getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_CONFIG);	String message = "Unable to initialize the Synapse Configuration : Can not find the ";	if (synCfg == null || synCfg.getValue() == null || !(synCfg.getValue() instanceof SynapseConfiguration)) {	
synapse configuration 

if (new File(ServerManager.getInstance().getSynapseXMLPath()).exists()) {	initializationModule = new org.apache.synapse.core.axis2.SynapseInitializationModule();	initializationModule.init(configurationContext, axisModule);	Parameter synEnv = configurationContext .getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_ENV);	Parameter synCfg = configurationContext .getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_CONFIG);	String message = "Unable to initialize the Synapse Configuration : Can not find the ";	if (synCfg == null || synCfg.getValue() == null || !(synCfg.getValue() instanceof SynapseConfiguration)) {	throw new SynapseException(message + "Synapse Configuration");	}	if (synEnv == null || synEnv.getValue() == null || !(synEnv.getValue() instanceof SynapseEnvironment)) {	
synapse environment 

========================= synapse sample_3906 =========================

public void testScriptMediationInLineJS() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to the script mediator using js scripts 

========================= synapse sample_2244 =========================

this.response = response;	this.expectEntityBody = response.isExpectResponseBody();	Map<String,String> headers = response.getHeaders();	Map excessHeaders = response.getExcessHeaders();	String oriURL = headers.get(PassThroughConstants.LOCATION);	if (oriURL != null && response.getStatus() != HttpStatus.SC_MOVED_TEMPORARILY && !targetConfiguration .isPreserveHttpHeader(PassThroughConstants.LOCATION)) {	URL url;	try {	url = new URL(oriURL);	} catch (MalformedURLException e) {	
invalid url received 

if (prefix != null) {	headers.put(PassThroughConstants.LOCATION, prefix + url.getFile());	}	}	try {	responseMsgCtx = outMsgCtx.getOperationContext(). getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);	if (responseMsgCtx != null) {	responseMsgCtx.setSoapAction("");	}	} catch (AxisFault af) {	
error getting in message context from the operation context 

responseMsgCtx = outMsgCtx.getOperationContext(). getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);	if (responseMsgCtx != null) {	responseMsgCtx.setSoapAction("");	}	} catch (AxisFault af) {	return;	}	if (responseMsgCtx == null) {	if (outMsgCtx.getOperationContext().isComplete()) {	if (log.isDebugEnabled()) {	
error getting in message context from the operation context possibly an rm terminate sequence message 

if (charSetEnc == null) {	charSetEnc = MessageContext.DEFAULT_CHAR_SET_ENCODING;	}	responseMsgCtx.setProperty( Constants.Configuration.CHARACTER_SET_ENCODING, contentType.indexOf(HTTP.CHARSET_PARAM) > 0 ? charSetEnc : MessageContext.DEFAULT_CHAR_SET_ENCODING);	responseMsgCtx.setServerSide(false);	SOAPFactory fac = OMAbstractFactory.getSOAP11Factory();	SOAPEnvelope envelope = fac.getDefaultEnvelope();	try {	responseMsgCtx.setEnvelope(envelope);	} catch (AxisFault axisFault) {	
error setting the soap envelope 

}	int statusCode = this.response.getStatus();	responseMsgCtx.setProperty(PassThroughConstants.HTTP_SC, statusCode);	if (statusCode >= 400) {	responseMsgCtx.setProperty(PassThroughConstants.FAULT_MESSAGE, PassThroughConstants.TRUE);	}	responseMsgCtx.setProperty(PassThroughConstants.NON_BLOCKING_TRANSPORT, true);	try {	AxisEngine.receive(responseMsgCtx);	} catch (AxisFault af) {	
fault processing response message through 

responseMsgCtx.setProperty(PassThroughConstants.HTTP_SC, statusCode);	if (statusCode >= 400) {	responseMsgCtx.setProperty(PassThroughConstants.FAULT_MESSAGE, PassThroughConstants.TRUE);	}	responseMsgCtx.setProperty(PassThroughConstants.NON_BLOCKING_TRANSPORT, true);	try {	AxisEngine.receive(responseMsgCtx);	} catch (AxisFault af) {	}	} catch (AxisFault af) {	
fault creating response soap envelope 

if (statusCode >= 400) {	responseMsgCtx.setProperty(PassThroughConstants.FAULT_MESSAGE, PassThroughConstants.TRUE);	}	responseMsgCtx.setProperty(PassThroughConstants.NON_BLOCKING_TRANSPORT, true);	try {	AxisEngine.receive(responseMsgCtx);	} catch (AxisFault af) {	}	} catch (AxisFault af) {	} catch (IOException e) {	
error closing input stream from which message was read 

========================= synapse sample_919 =========================

protected String extractSessionID(OMElement header, QName keyQName) {	OMElement sgcIDElm = getHeaderBlock(header, keyQName);	if (sgcIDElm != null) {	String sgcID = sgcIDElm.getText();	if (sgcID != null && !"".equals(sgcID)) {	return sgcID.trim();	} else {	if (log.isDebugEnabled()) {	
is null or empty 

if (sgcIDElm != null) {	String sgcID = sgcIDElm.getText();	if (sgcID != null && !"".equals(sgcID)) {	return sgcID.trim();	} else {	if (log.isDebugEnabled()) {	}	}	} else {	if (log.isDebugEnabled()) {	
couldn t find the soap header to find the session 

protected String extractSessionID(MessageContext synCtx, String key) {	if (key != null) {	Map headerMap = getTransportHeaderMap(synCtx);	if (headerMap != null) {	Object hostObj = headerMap.get("Host");	if (log.isDebugEnabled()) {	
a request received with the host name 

if (key != null) {	Map headerMap = getTransportHeaderMap(synCtx);	if (headerMap != null) {	Object hostObj = headerMap.get("Host");	if (log.isDebugEnabled()) {	}	Object cookieObj = headerMap.get(key);	if (cookieObj instanceof String) {	String cookie = (String) cookieObj;	if (log.isDebugEnabled()) {	
cookies string 

if (log.isDebugEnabled()) {	}	Object cookieObj = headerMap.get(key);	if (cookieObj instanceof String) {	String cookie = (String) cookieObj;	if (log.isDebugEnabled()) {	}	String[] sessionIds = cookie.split(";");	if (sessionIds == null || sessionIds.length == 0) {	if (log.isDebugEnabled()) {	
cannot find a session id for the cookie 

}	String[] sessionIds = cookie.split(";");	if (sessionIds == null || sessionIds.length == 0) {	if (log.isDebugEnabled()) {	}	return null;	}	for (String sessionId : sessionIds){	if(sessionId != null && sessionId.indexOf("JSESSIONID") != -1) {	if (log.isDebugEnabled()) {	
extracted sessionid 

for (String sessionId : sessionIds){	if(sessionId != null && sessionId.indexOf("JSESSIONID") != -1) {	if (log.isDebugEnabled()) {	}	return sessionId.trim();	}	}	return null;	} else {	if (log.isDebugEnabled()) {	
couldn t find the header to find the session 

return sessionId.trim();	}	}	return null;	} else {	if (log.isDebugEnabled()) {	}	}	} else {	if (log.isDebugEnabled()) {	
couldn t find the transport headers to find the session 

========================= synapse sample_1653 =========================

try {	Validator validator = cachedSchema.newValidator();	validator.setErrorHandler(errorHandler);	validator.validate(validateSrc);	if (errorHandler.isValidationError()) {	if (traceOrDebugOn) {	String msg = "Validation of element returned by XPath : " + source + " failed against the given schema(s) " + schemaKeys + "with error : " + errorHandler.getSaxParseException().getMessage() + " Executing 'on-fail' sequence";	traceOrDebug(traceOn, msg);	synCtx.getServiceLog().warn(msg);	if (traceOn && trace.isTraceEnabled()) {	
failed message envelope 

========================= synapse sample_3681 =========================

public void send(MessageContext synCtx) {	if (log.isDebugEnabled()) {	
sending using load balance 

synCtx.setTo(epr);	if (failover) {	synCtx.getEnvelope().build();	}	AddressEndpoint endpoint = new AddressEndpoint();	EndpointDefinition definition = new EndpointDefinition();	endpoint.setDefinition(definition);	endpoint.init(synCtx.getEnvironment());	endpoint.send(synCtx);	} else {	
cannot load balance for non http s transport 

public boolean readyToSend() {	for (Endpoint endpoint : getChildren()) {	if (endpoint.readyToSend()) {	if (log.isDebugEnabled()) {	
load balance has at least one endpoint at ready state 

public boolean readyToSend() {	for (Endpoint endpoint : getChildren()) {	if (endpoint.readyToSend()) {	if (log.isDebugEnabled()) {	}	return true;	}	}	
load balance has no endpoints at ready state to process message 

public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {	logOnChildEndpointFail(endpoint, synMessageContext);	if (failover) {	if (!((AbstractEndpoint)endpoint).isRetryDisabled(synMessageContext)) {	if (log.isDebugEnabled()) {	
retry attempt for request with message id to 

public void setAlgorithm(LoadbalanceAlgorithm algorithm) {	if (log.isDebugEnabled()) {	
load balance will be using the algorithm for load distribution 

private boolean canConnect(Member member) {	if(log.isDebugEnabled()){	
trying to connect to member 

SocketAddress httpsSockaddr = new InetSocketAddress(addr, httpsPort);	new Socket().connect(httpsSockaddr, 10000);	}	return true;	} catch (IOException e) {	if(log.isDebugEnabled()){	log.debug("", e);	}	String msg = e.getMessage();	if (msg.indexOf("Connection refused") == -1 && msg.indexOf("connect timed out") == -1) {	
cannot connect to member 

========================= synapse sample_221 =========================

public boolean mediate(MessageContext synCtx) {	boolean returnValue = true;	if (log.isDebugEnabled()) {	
target mediation start 

public boolean mediate(MessageContext synCtx) {	boolean returnValue = true;	if (log.isDebugEnabled()) {	}	if (soapAction != null) {	if (log.isDebugEnabled()) {	
setting the soapaction as 

boolean returnValue = true;	if (log.isDebugEnabled()) {	}	if (soapAction != null) {	if (log.isDebugEnabled()) {	}	synCtx.setSoapAction(soapAction);	}	if (toAddress != null) {	if (log.isDebugEnabled()) {	
setting the to header as 

}	if (synCtx.getTo() != null) {	synCtx.getTo().setAddress(toAddress);	} else {	synCtx.setTo(new EndpointReference(toAddress));	}	}	if (sequence != null) {	if (asynchronous) {	if (log.isDebugEnabled()) {	
asynchronously mediating using the in lined anonymous sequence 

synCtx.setTo(new EndpointReference(toAddress));	}	}	if (sequence != null) {	if (asynchronous) {	if (log.isDebugEnabled()) {	}	synCtx.getEnvironment().injectAsync(synCtx, sequence);	} else {	if (log.isDebugEnabled()) {	
synchronously mediating using the in lined anonymous sequence 

} else {	if (log.isDebugEnabled()) {	}	returnValue = sequence.mediate(synCtx);	}	} else if (sequenceRef != null) {	SequenceMediator refSequence = (SequenceMediator) synCtx.getSequence(sequenceRef);	if (refSequence != null) {	if (asynchronous) {	if (log.isDebugEnabled()) {	
asynchronously mediating using the sequence named 

}	} else if (sequenceRef != null) {	SequenceMediator refSequence = (SequenceMediator) synCtx.getSequence(sequenceRef);	if (refSequence != null) {	if (asynchronous) {	if (log.isDebugEnabled()) {	}	synCtx.getEnvironment().injectAsync(synCtx, refSequence);	} else {	if (log.isDebugEnabled()) {	
synchronously mediating using the sequence named 

} else {	if (log.isDebugEnabled()) {	}	returnValue = refSequence.mediate(synCtx);	}	} else {	handleException("Couldn't find the sequence named : " + sequenceRef);	}	} else if (endpoint != null) {	if (log.isDebugEnabled()) {	
sending using the in lined anonymous endpoint 

handleException("Couldn't find the sequence named : " + sequenceRef);	}	} else if (endpoint != null) {	if (log.isDebugEnabled()) {	}	endpoint.send(synCtx);	} else if (endpointRef != null) {	Endpoint epr = synCtx.getConfiguration().getEndpoint(endpointRef);	if (epr != null) {	if (log.isDebugEnabled()) {	
sending using the endpoint named 

Endpoint epr = synCtx.getConfiguration().getEndpoint(endpointRef);	if (epr != null) {	if (log.isDebugEnabled()) {	}	epr.send(synCtx);	} else {	handleException("Couldn't find the endpoint named : " + endpointRef);	}	}	if (log.isDebugEnabled()) {	
target mediation end 

========================= synapse sample_1983 =========================

protected void buildArchive(Archiver archiver) throws ArchiverException, MojoExecutionException {	Log log = getLog();	
using base directory 

protected void buildArchive(Archiver archiver) throws ArchiverException, MojoExecutionException {	Log log = getLog();	archiver.addDirectory(buildOutputDirectory);	if (includeDependencies) {	
adding dependencies 

protected void buildArchive(Archiver archiver) throws ArchiverException, MojoExecutionException {	Log log = getLog();	archiver.addDirectory(buildOutputDirectory);	if (includeDependencies) {	addDependencies(archiver);	}	if (generateMetadata) {	
generating xar metadata 

filter.add(new ScopeArtifactFilter(Artifact.SCOPE_RUNTIME));	filter.add(new ArtifactFilter() {	public boolean include(Artifact artifact) {	return !artifact.isOptional();	}	});	filter.add(new TypeArtifactFilter("jar"));	filter.add(buildSynapseRuntimeArtifactFilter());	for (Artifact artifact : filterArtifacts(project.getArtifacts(), filter)) {	String targetFileName = artifact.getArtifactId() + "-" + artifact.getVersion() + "." + artifact.getArtifactHandler().getExtension();	
adding scope 

private void generateMetadata(Archiver archiver) throws ArchiverException, MojoExecutionException {	Log log = getLog();	File tmpServicesDir = new File(new File(tmpDirectory, "META-INF"), "services");	File buildServicesDir = new File(new File(buildOutputDirectory, "META-INF"), "services");	if (!tmpServicesDir.exists() && !tmpServicesDir.mkdirs()) {	throw new MojoExecutionException("Error while creating the directory: " + tmpServicesDir.getPath());	}	
initializing class scanner 

throw new MojoExecutionException("Error while creating the directory: " + tmpServicesDir.getPath());	}	ClassScanner scanner = new ClassScanner(buildOutputDirectory);	for (Artifact artifact : filterArtifacts(project.getArtifacts(), new ScopeArtifactFilter(Artifact.SCOPE_COMPILE))) {	scanner.addToClasspath(artifact.getFile());	}	List<ServiceLocator> serviceLocators = new ArrayList<ServiceLocator>(serviceClassNames.length);	for (String serviceClassName : serviceClassNames) {	File file = new File(buildServicesDir, serviceClassName);	if (file.exists()) {	
exists don t scan for implementation 

}	try {	scanner.scan();	} catch (ClassScannerException e) {	throw new MojoExecutionException("Failed to scan classes for services", e);	}	for (ServiceLocator sl : serviceLocators) {	File file = new File(tmpServicesDir, sl.getServiceClassName());	if (!sl.getImplementations().isEmpty()) {	String destFileName = "META-INF/services/" + sl.getServiceClassName();	
generating 

artifacts.put(artifact.getDependencyConflictId(), artifact);	}	final Set<String> defaultExclusionSet = new HashSet<String>(Arrays.asList(defaultRuntimeExcludes));	return new ArtifactFilter() {	public boolean include(Artifact artifact) {	Artifact runtimeArtifact = artifacts.get(artifact.getDependencyConflictId());	if (runtimeArtifact == null) {	return !defaultExclusionSet.contains(artifact.getDependencyConflictId());	} else {	if (!runtimeArtifact.getVersion().equals(artifact.getVersion())) {	
possible runtime version conflict for xar depends on synapse runtime provides 

private Set<Artifact> getSynapseRuntimeArtifacts() throws MojoExecutionException {	Log log = getLog();	
looking for synapse core artifact in xar project dependencies 

for (Iterator<?> it = project.getDependencyArtifacts().iterator(); it.hasNext(); ) {	Artifact artifact = (Artifact)it.next();	if (artifact.getGroupId().equals("org.apache.synapse") && artifact.getArtifactId().equals("synapse-core")) {	synapseCore = artifact;	break;	}	}	if (synapseCore == null) {	throw new MojoExecutionException("Could not locate dependency on synapse-core");	}	
loading project data for 

synapseCoreProject = projectBuilder.buildFromRepository(synapseCore, remoteArtifactRepositories, localRepository);	} catch (ProjectBuildingException e) {	throw new MojoExecutionException("Unable to retrieve project information for " + synapseCore, e);	}	Set<Artifact> synapseRuntimeDeps;	try {	synapseRuntimeDeps = synapseCoreProject.createArtifacts(artifactFactory, Artifact.SCOPE_RUNTIME, new TypeArtifactFilter("jar"));	} catch (InvalidDependencyVersionException e) {	throw new MojoExecutionException("Unable to get project dependencies for " + synapseCore, e);	}	
direct runtime dependencies for 

} catch (ProjectBuildingException e) {	throw new MojoExecutionException("Unable to retrieve project information for " + synapseCore, e);	}	Set<Artifact> synapseRuntimeDeps;	try {	synapseRuntimeDeps = synapseCoreProject.createArtifacts(artifactFactory, Artifact.SCOPE_RUNTIME, new TypeArtifactFilter("jar"));	} catch (InvalidDependencyVersionException e) {	throw new MojoExecutionException("Unable to get project dependencies for " + synapseCore, e);	}	logArtifacts(synapseRuntimeDeps);	
resolving transitive dependencies for 

synapseRuntimeDeps = synapseCoreProject.createArtifacts(artifactFactory, Artifact.SCOPE_RUNTIME, new TypeArtifactFilter("jar"));	} catch (InvalidDependencyVersionException e) {	throw new MojoExecutionException("Unable to get project dependencies for " + synapseCore, e);	}	logArtifacts(synapseRuntimeDeps);	try {	synapseRuntimeDeps = artifactCollector.collect(synapseRuntimeDeps, synapseCoreProject.getArtifact(), synapseCoreProject.getManagedVersionMap(), localRepository, remoteArtifactRepositories, artifactMetadataSource, null, Collections.singletonList(new DebugResolutionListener(logger))).getArtifacts();	} catch (ArtifactResolutionException e) {	throw new MojoExecutionException("Unable to resolve transitive dependencies for " + synapseCore);	}	
all runtime dependencies for 

========================= synapse sample_2706 =========================

public void init(ConfigurationContext cfgCtx, TransportInDescription trpInDesc) throws AxisFault {	super.init(cfgCtx, trpInDesc);	fixSessionFactory = FIXSessionFactory.getInstance(new FIXApplicationFactory(cfgCtx));	fixSessionFactory.setListenerThreadPool(this.workerPool);	
fix transport listener initialized 

public void startListeningForService(AxisService service) {	try {	boolean acceptorCreated = fixSessionFactory.createFIXAcceptor(service);	boolean initiatorCreated = fixSessionFactory.createFIXInitiator(service);	if (!acceptorCreated && !initiatorCreated) {	
no acceptor or initiator has been configured for the service disabling the fix transport for this service 

========================= synapse sample_1080 =========================

public Axis2HttpRequest(EndpointReference epr, HttpHost httpHost, MessageContext msgContext) {	this.epr = epr;	this.httpHost = httpHost;	this.msgContext = msgContext;	this.format = NhttpUtils.getOMOutputFormat(msgContext);	this.messageFormatter = MessageFormatterDecoratorFactory.createMessageFormatterDecorator(msgContext);	try {	this.pipe = new PipeImpl();	} catch (IOException e) {	
error creating pipe to write message body 

public ReadableByteChannel getSourceChannel() {	if (log.isDebugEnabled()) {	
get source channel of the pipe on which the outgoing response is written 

public WritableByteChannel getSinkChannel() {	if (log.isDebugEnabled()) {	
get sink channel of the pipe on which the outgoing response is written 

public void streamMessageContents() throws AxisFault {	if (log.isDebugEnabled()) {	
start streaming outgoing http request 

public void streamMessageContents() throws AxisFault {	if (log.isDebugEnabled()) {	}	OutputStream out = Channels.newOutputStream(pipe.sink());	try {	messageFormatter.writeTo(msgContext, format, out, true);	} catch (Exception e) {	Throwable t = e.getCause();	if (t != null && t.getCause() != null && t.getCause() instanceof ClosedChannelException) {	if (log.isDebugEnabled()) {	
ignore closed channel exception as the sessionrequestcallback handles this exception 

========================= synapse sample_4282 =========================

public void init(Properties jndiEnv) {	initialized = true;	if (jndiEnv == null || jndiEnv.isEmpty()) {	if (log.isDebugEnabled()) {	
provided global jndi environment properties is empty or null 

validateInitialized();	String dataSourceName = information.getDatasourceName();	validateDSName(dataSourceName);	Properties properties = information.getProperties();	InitialContext context = null;	Properties jndiEvn = null;	if (properties == null || properties.isEmpty()) {	if (initialContext != null) {	context = initialContext;	if (log.isDebugEnabled()) {	
empty jndi properties for datasource 

validateInitialized();	String dataSourceName = information.getDatasourceName();	validateDSName(dataSourceName);	Properties properties = information.getProperties();	InitialContext context = null;	Properties jndiEvn = null;	if (properties == null || properties.isEmpty()) {	if (initialContext != null) {	context = initialContext;	if (log.isDebugEnabled()) {	
using system wide jndi properties 

jndiEvn = jndiProperties;	}	}	if (context == null) {	jndiEvn = createJNDIEnvironment(properties, information.getAlias());	context = createInitialContext(jndiEvn);	if (context == null) {	validateInitialContext(initialContext);	context = initialContext;	if (log.isDebugEnabled()) {	
cannot create a name context with provided jndi properties 

jndiEvn = jndiProperties;	}	}	if (context == null) {	jndiEvn = createJNDIEnvironment(properties, information.getAlias());	context = createInitialContext(jndiEvn);	if (context == null) {	validateInitialContext(initialContext);	context = initialContext;	if (log.isDebugEnabled()) {	
using system wide jndi properties 

ref.add(new StringRefAddr(DataSourceConstants.PROP_URL, url));	ref.add(new StringRefAddr(SecurityConstants.PROP_USER_NAME, user));	ref.add(new StringRefAddr(SecurityConstants.PROP_PASSWORD, password));	ref.add(new StringRefAddr(DataSourceConstants.PROP_MAX_ACTIVE, maxActive));	ref.add(new StringRefAddr(DataSourceConstants.PROP_MAX_IDLE, maxIdle));	ref.add(new StringRefAddr(DataSourceConstants.PROP_MAX_WAIT, maxWait));	setBasicDataSourceParameters(ref, information);	setCommonParameters(ref, information);	try {	if (log.isDebugEnabled()) {	
registering a datasource with name in the jndi tree with jndiproperties 

}	Reference ref = new Reference("org.apache.commons.dbcp.datasources.PerUserPoolDataSource", "org.apache.commons.dbcp.datasources.PerUserPoolDataSourceFactory", null);	ref.add(new BinaryRefAddr( DataSourceConstants.PROP_JNDI_ENV, MiscellaneousUtil.serialize(jndiEvn)));	ref.add(new StringRefAddr( DataSourceConstants.PROP_DATA_SOURCE_NAME, name));	ref.add(new StringRefAddr( DataSourceConstants.PROP_DEFAULT_MAX_ACTIVE, maxActive));	ref.add(new StringRefAddr( DataSourceConstants.PROP_DEFAULT_MAX_IDLE, maxIdle));	ref.add(new StringRefAddr( DataSourceConstants.PROP_DEFAULT_MAX_WAIT, maxWait));	setCommonParameters(ref, information);	try {	if (log.isDebugEnabled()) {	
registering a datasource with name in the jndi tree with jndiproperties 

public DataSource lookUp(String dsName) {	validateInitialized();	validateDSName(dsName);	if (!cachedNameList.contains(dsName)) {	if (log.isDebugEnabled()) {	
there is no datasource with name in jndi datasource repository 

public DataSource lookUp(String dsName) {	validateInitialized();	validateDSName(dsName);	if (!cachedNameList.contains(dsName)) {	if (log.isDebugEnabled()) {	}	return null;	}	if (log.isDebugEnabled()) {	
getting a datasource with name from the jndi tree 

private Properties createJNDIEnvironment(Properties dsProperties, String name) {	String namingFactory = DataSourceConstants.DEFAULT_IC_FACTORY;	String providerUrl = null;	int port = DataSourceConstants.DEFAULT_PROVIDER_PORT;	String providerPort = null;	Properties jndiEvn = new Properties();	if (dsProperties != null && !dsProperties.isEmpty()) {	if (log.isDebugEnabled()) {	
using properties to create jndi environment 

buffer.append(DataSourceConstants.DOT_STRING);	}	String rootPrefix = buffer.toString();	namingFactory = MiscellaneousUtil.getProperty( dsProperties, rootPrefix + DataSourceConstants.PROP_IC_FACTORY, DataSourceConstants.DEFAULT_IC_FACTORY);	providerUrl = MiscellaneousUtil.getProperty( dsProperties, rootPrefix + DataSourceConstants.PROP_PROVIDER_URL, null);	providerPort = MiscellaneousUtil.getProperty(dsProperties, rootPrefix + DataSourceConstants.PROP_PROVIDER_PORT, String.valueOf(DataSourceConstants.DEFAULT_PROVIDER_PORT));	}	jndiEvn.put(Context.INITIAL_CONTEXT_FACTORY, namingFactory);	if (providerUrl != null && !"".equals(providerUrl)) {	if (log.isDebugEnabled()) {	
using provided initial context provider url 

namingFactory = MiscellaneousUtil.getProperty( dsProperties, rootPrefix + DataSourceConstants.PROP_IC_FACTORY, DataSourceConstants.DEFAULT_IC_FACTORY);	providerUrl = MiscellaneousUtil.getProperty( dsProperties, rootPrefix + DataSourceConstants.PROP_PROVIDER_URL, null);	providerPort = MiscellaneousUtil.getProperty(dsProperties, rootPrefix + DataSourceConstants.PROP_PROVIDER_PORT, String.valueOf(DataSourceConstants.DEFAULT_PROVIDER_PORT));	}	jndiEvn.put(Context.INITIAL_CONTEXT_FACTORY, namingFactory);	if (providerUrl != null && !"".equals(providerUrl)) {	if (log.isDebugEnabled()) {	}	} else {	if (log.isDebugEnabled()) {	
no initial context provider url creaeting a new one 

if (hostname == null) {	String ipAddr = addr.getHostAddress();	if (ipAddr != null) {	providerHost = ipAddr;	}	} else {	providerHost = hostname;	}	}	} catch (UnknownHostException e) {	
unable to determine hostname or ip address using localhost 

if (providerPort != null) {	try {	port = Integer.parseInt(providerPort);	} catch (NumberFormatException ignored) {	}	}	RMIRegistryController.getInstance().createLocalRegistry(port);	cachedPorts.add(port);	providerUrl = "rmi: }	jndiEvn.put(Context.PROVIDER_URL, providerUrl);	
datasources will be registered in the jndi context with provider prop url 

private InitialContext createInitialContext(Properties jndiEnv) {	if (jndiEnv == null || jndiEnv.isEmpty()) {	return null;	}	try {	if (log.isDebugEnabled()) {	
initiating a naming context with jndi environment jndiproperties 

========================= synapse sample_695 =========================

MDC.put("ip", ipAddr);	}	String hostname = addr.getHostName();	if (hostname == null) {	hostname = ipAddr;	}	MDC.put("host", hostname);	}	}	catch (UnknownHostException e) {	
unable to report hostname or ip address for tracing 

}	String hostname = addr.getHostName();	if (hostname == null) {	hostname = ipAddr;	}	MDC.put("host", hostname);	}	}	catch (UnknownHostException e) {	}	
deploying the synapse service 

}	}	catch (UnknownHostException e) {	}	AxisConfiguration axisCfg = configurationContext.getAxisConfiguration();	AxisService synapseService = new AxisService(SYNAPSE_SERVICE_NAME);	AxisOperation mediateOperation = new InOutAxisOperation(MEDIATE_OPERATION_Q_NAME);	mediateOperation.setMessageReceiver(new SynapseMessageReceiver());	synapseService.addOperation(mediateOperation);	axisCfg.addService(synapseService);	
initializing the synapse configuration 

}	catch (UnknownHostException e) {	}	AxisConfiguration axisCfg = configurationContext.getAxisConfiguration();	AxisService synapseService = new AxisService(SYNAPSE_SERVICE_NAME);	AxisOperation mediateOperation = new InOutAxisOperation(MEDIATE_OPERATION_Q_NAME);	mediateOperation.setMessageReceiver(new SynapseMessageReceiver());	synapseService.addOperation(mediateOperation);	axisCfg.addService(synapseService);	SynapseConfiguration synCfg = initializeSynapse(configurationContext);	
deploying proxy services 

axisCfg.addService(synapseService);	SynapseConfiguration synCfg = initializeSynapse(configurationContext);	Iterator iter = synCfg.getProxyServices().iterator();	while (iter.hasNext()) {	ProxyService proxy = (ProxyService) iter.next();	proxy.buildAxisService(synCfg, axisCfg);	if (!proxy.isStartOnLoad()) {	proxy.stop(synCfg);	}	}	
synapse initialized successfully 

private static SynapseConfiguration initializeSynapse( ConfigurationContext cfgCtx) {	AxisConfiguration axisConfiguration = cfgCtx.getAxisConfiguration();	First check, if synapse.xml URL is provided as a system property, if so use it.. else check if synapse.xml location is available from the axis2.xml "SynapseConfiguration" else use the default config SynapseConfiguration synapseConfiguration;	Parameter configParam = axisConfiguration.getParameter(Constants.SYNAPSE_CONFIGURATION);	String config = System.getProperty(Constants.SYNAPSE_XML);	if (config != null) {	
system property specifies synapse configuration as 

private static SynapseConfiguration initializeSynapse( ConfigurationContext cfgCtx) {	AxisConfiguration axisConfiguration = cfgCtx.getAxisConfiguration();	First check, if synapse.xml URL is provided as a system property, if so use it.. else check if synapse.xml location is available from the axis2.xml "SynapseConfiguration" else use the default config SynapseConfiguration synapseConfiguration;	Parameter configParam = axisConfiguration.getParameter(Constants.SYNAPSE_CONFIGURATION);	String config = System.getProperty(Constants.SYNAPSE_XML);	if (config != null) {	synapseConfiguration = SynapseConfigurationBuilder.getConfiguration(config);	} else if (configParam != null) {	
synapse configuration is available via the synapseconfiguration parameter in xml 

private static SynapseConfiguration initializeSynapse( ConfigurationContext cfgCtx) {	AxisConfiguration axisConfiguration = cfgCtx.getAxisConfiguration();	First check, if synapse.xml URL is provided as a system property, if so use it.. else check if synapse.xml location is available from the axis2.xml "SynapseConfiguration" else use the default config SynapseConfiguration synapseConfiguration;	Parameter configParam = axisConfiguration.getParameter(Constants.SYNAPSE_CONFIGURATION);	String config = System.getProperty(Constants.SYNAPSE_XML);	if (config != null) {	synapseConfiguration = SynapseConfigurationBuilder.getConfiguration(config);	} else if (configParam != null) {	synapseConfiguration = SynapseConfigurationBuilder .getConfiguration(configParam.getValue().toString().trim());	} else {	
system property is not specified or synapseconfiguration parameter is not available via xml using default configuration 

========================= synapse sample_3235 =========================

public String getMessageTextPayload(Object message) {	try {	return new String( getBytesFromInputStream(getInputStream(message), (int) ((FileContent) message).getSize()));	} catch (Exception e) {	if (log.isDebugEnabled()) {	
error reading message payload as text for 

========================= synapse sample_3720 =========================

public boolean mediate(MessageContext synCtx) {	
in mediator mediate 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	try {	if (shouldTrace) {	trace.trace("Start : In mediator");	}	if (test(synCtx)) {	
current message is incoming executing child mediators 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	try {	if (shouldTrace) {	trace.trace("Start : In mediator");	}	if (test(synCtx)) {	return super.mediate(synCtx);	} else {	
current message is not incoming skipping child mediators 

========================= synapse sample_3059 =========================

private static Properties loadProperties(String filePath) {	Properties properties = new Properties();	ClassLoader cl = Thread.currentThread().getContextClassLoader();	if (log.isDebugEnabled()) {	
loading a file from classpath 

private static Properties loadProperties(String filePath) {	Properties properties = new Properties();	ClassLoader cl = Thread.currentThread().getContextClassLoader();	if (log.isDebugEnabled()) {	}	InputStream in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	
unable to load file 

Properties properties = new Properties();	ClassLoader cl = Thread.currentThread().getContextClassLoader();	if (log.isDebugEnabled()) {	}	InputStream in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	}	filePath = "repository/conf" + File.separatorChar + filePath;	if (log.isDebugEnabled()) {	
loading a file from classpath 

InputStream in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	}	filePath = "repository/conf" + File.separatorChar + filePath;	if (log.isDebugEnabled()) {	}	in = cl.getResourceAsStream(filePath);	if (in == null) {	if (log.isDebugEnabled()) {	
unable to load file 

========================= synapse sample_1064 =========================

public void timeout(final NHttpServerConnection conn) {	HttpRequest req = (HttpRequest) conn.getContext().getAttribute(HttpContext.HTTP_REQUEST);	
connection timeout for request to 

public void connected(final NHttpServerConnection conn) {	
new incoming connection 

public void closed(final NHttpServerConnection conn) {	
connection closed 

public void exception(NHttpServerConnection conn, IOException e) {	if (e instanceof ConnectionClosedException) {	
i o error 

public void exception(NHttpServerConnection conn, IOException e) {	if (e instanceof ConnectionClosedException) {	} else {	
i o error 

========================= synapse sample_3409 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start callout mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	try {	if (synLog.isTraceOrDebugEnabled()) {	if (!isWrappingEndpointCreated) {	
using the defined endpoint 

SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	try {	if (synLog.isTraceOrDebugEnabled()) {	if (!isWrappingEndpointCreated) {	} else {	if (serviceURL != null) {	
using the serviceurl 

if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	try {	if (synLog.isTraceOrDebugEnabled()) {	if (!isWrappingEndpointCreated) {	} else {	if (serviceURL != null) {	} else {	
using the to header as the epr 

}	}	try {	if (synLog.isTraceOrDebugEnabled()) {	if (!isWrappingEndpointCreated) {	} else {	if (serviceURL != null) {	} else {	}	if (securityOn) {	
security enabled within the callout mediator config 

}	try {	if (synLog.isTraceOrDebugEnabled()) {	if (!isWrappingEndpointCreated) {	} else {	if (serviceURL != null) {	} else {	}	if (securityOn) {	if (wsSecPolicyKey != null) {	
using security policy key 

if (synLog.isTraceOrDebugEnabled()) {	if (!isWrappingEndpointCreated) {	} else {	if (serviceURL != null) {	} else {	}	if (securityOn) {	if (wsSecPolicyKey != null) {	} else {	if (inboundWsSecPolicyKey != null) {	
using inbound security policy key 

} else {	if (serviceURL != null) {	} else {	}	if (securityOn) {	if (wsSecPolicyKey != null) {	} else {	if (inboundWsSecPolicyKey != null) {	}	if (outboundWsSecPolicyKey != null) {	
using outbound security policy key 

if (requestKey != null || requestXPath != null) {	SOAPBody soapBody = synapseOutMsgCtx.getEnvelope().getBody();	soapBody.removeChildren();	soapBody.addChild(getRequestPayload(synCtx));	if (!passHeaders) {	SOAPHeader soapHeader = synapseOutMsgCtx.getEnvelope().getHeader();	soapHeader.removeChildren();	}	}	if (synLog.isTraceOrDebugEnabled()) {	
about to invoke the service 

SOAPBody soapBody = synapseOutMsgCtx.getEnvelope().getBody();	soapBody.removeChildren();	soapBody.addChild(getRequestPayload(synCtx));	if (!passHeaders) {	SOAPHeader soapHeader = synapseOutMsgCtx.getEnvelope().getHeader();	soapHeader.removeChildren();	}	}	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
request message payload 

} else {	resultMsgCtx = blockingMsgSender.send(endpoint, synapseOutMsgCtx);	if ("true".equals(resultMsgCtx.getProperty(SynapseConstants.BLOCKING_CLIENT_ERROR))) {	handleFault(synCtx, (Exception) synCtx.getProperty(SynapseConstants.ERROR_EXCEPTION));	}	}	} catch (Exception ex) {	handleFault(synCtx, ex);	}	if (synLog.isTraceTraceEnabled()) {	
response payload received 

} else {	handleException("Evaluation of target XPath expression : " + targetXPath.toString() + " did not yeild an OMNode", synCtx);	}	} else if (targetKey != null) {	OMElement result = resultMsgCtx.getEnvelope().getBody().getFirstElement();	synCtx.setProperty(targetKey, result);	} else {	synCtx.setEnvelope(resultMsgCtx.getEnvelope());	}	} else {	
service returned a null response 

} else {	synCtx.setEnvelope(resultMsgCtx.getEnvelope());	}	} else {	}	} catch (AxisFault e) {	handleException("Error invoking service : " + serviceURL + (action != null ? " with action : " + action : ""), e, synCtx);	} catch (JaxenException e) {	handleException("Error while evaluating the XPath expression: " + targetXPath, e, synCtx);	}	
end callout mediator 

========================= synapse sample_1967 =========================

public boolean startProcess() {	processException = null;	synchronized (axis2Server) {	axis2Server.start();	while (serverState <= STARTING_UP) {	try {	axis2Server.wait(1000);	} catch (InterruptedException e) {	
server startup was interrupted 

axis2Server.start();	while (serverState <= STARTING_UP) {	try {	axis2Server.wait(1000);	} catch (InterruptedException e) {	return false;	}	}	}	if (serverState == STARTUP_FAILED) {	
server failed to start 

public boolean stopProcess() {	if (serverState == SERVER_ACTIVE) {	synchronized (axis2Server) {	serverState = SHUTTING_DOWN;	axis2Server.notifyAll();	while (serverState > UNDEFINED) {	try {	axis2Server.wait(1000);	} catch (InterruptedException e) {	
server shutdown was interrupted 

TransportInDescription httpsTrsIn = configContext.getAxisConfiguration(). getTransportsIn().get("https");	httpsTrsIn.getParameter("port").setValue(httpsPort);	}	ClusteringAgent clusteringAgent = configContext.getAxisConfiguration().getClusteringAgent();	String avoidInit = ClusteringConstants.Parameters.AVOID_INITIATION;	if (clusteringAgent != null && clusteringAgent.getParameter(avoidInit) != null && ((String) clusteringAgent.getParameter(avoidInit).getValue()). equalsIgnoreCase("true")) {	clusteringAgent.setConfigurationContext(configContext);	clusteringAgent.init();	}	if (counterEnabled) {	
engaging server side message counter 

========================= synapse sample_2218 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start mediation using sequence message is a response request 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	boolean result = super.mediate(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	boolean result = super.mediate(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	
end mediation using sequence 

========================= synapse sample_553 =========================

public void handleFault(MessageContext synCtx) {	boolean traceOn = synCtx.getTracingState() == SynapseConstants.TRACING_ON;	boolean traceOrDebugOn = traceOn || log.isDebugEnabled();	if (traceOrDebugOn) {	traceOrDebugWarn(traceOn, "FaultHandler executing impl: " + this.getClass().getName());	}	try {	
faulthandler executing impl 

synCtx.setProperty(SynapseConstants.ERROR_MESSAGE, e.getMessage().split("\n")[0]);	synCtx.setProperty(SynapseConstants.ERROR_DETAIL, getStackTrace(e));	synCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, e);	}	if (traceOrDebugOn) {	traceOrDebugWarn(traceOn, "ERROR_CODE : " + synCtx.getProperty(SynapseConstants.ERROR_CODE));	traceOrDebugWarn(traceOn, "ERROR_MESSAGE : " + synCtx.getProperty(SynapseConstants.ERROR_MESSAGE));	traceOrDebugWarn(traceOn, "ERROR_DETAIL : " + synCtx.getProperty(SynapseConstants.ERROR_DETAIL));	traceOrDebugWarn(traceOn, "ERROR_EXCEPTION : " + synCtx.getProperty(SynapseConstants.ERROR_EXCEPTION));	}	
error code error message 

========================= synapse sample_1988 =========================

if (keyParam != null) {	OMElement ksEle      = keyParam.getParameterElement().getFirstElement();	String location      = ksEle.getFirstChildWithName(new QName("Location")).getText();	String type          = ksEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = ksEle.getFirstChildWithName(new QName("Password")).getText();	String keyPassword   = ksEle.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading identity keystore from 

String keyPassword   = ksEle.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

}	if (trustParam != null) {	OMElement tsEle      = trustParam.getParameterElement().getFirstElement();	String location      = tsEle.getFirstChildWithName(new QName("Location")).getText();	String type          = tsEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = tsEle.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading trust keystore from 

String storePassword = tsEle.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

fis.close();	} catch (IOException ignore) {}	}	}	}	try {	SSLContext sslcontext = SSLContext.getInstance("TLS");	sslcontext.init(keymanagers, trustManagers, null);	return sslcontext;	} catch (GeneralSecurityException gse) {	
unable to create ssl context with the given configuration 

========================= synapse sample_4289 =========================

private void registerExtensions() {	Iterator it = Service.providers(MediatorFactory.class);	while (it.hasNext()) {	MediatorFactory mf = (MediatorFactory) it.next();	QName tag = mf.getTagQName();	factoryMap.put(tag, mf.getClass());	
added mediatorfactory to handle 

public Mediator getMediator(OMElement element) {	String localName = element.getLocalName();	QName qName = null;	if (element.getNamespace() != null) {	qName = new QName(element.getNamespace().getName(), localName);	} else {	qName = new QName(localName);	}	
getmediator 

QName qName = null;	if (element.getNamespace() != null) {	qName = new QName(element.getNamespace().getName(), localName);	} else {	qName = new QName(localName);	}	Class cls = (Class) factoryMap.get(qName);	if (cls == null && localName.indexOf('.') > -1) {	String newLocalName = localName.substring(0, localName.indexOf('.'));	qName = new QName(element.getNamespace().getName(), newLocalName);	
getmediator 

========================= synapse sample_3262 =========================

private Destination getDestination(Context context, String url) {	String destinationName = JMSUtils.getDestination(url);	try {	return (Destination) context.lookup(destinationName);	} catch (NameNotFoundException e) {	if (log.isDebugEnabled()) {	
cannot locate destination using 

public Destination getReplyDestination(String replyDest) {	try {	return (Destination) jmsConnectionFactory.getContext().lookup(replyDest);	} catch (NameNotFoundException e) {	if (log.isDebugEnabled()) {	
cannot locate reply destination 

========================= synapse sample_3777 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start class mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	if (synLog.isTraceOrDebugEnabled()) {	
invoking mediate 

}	}	if (synLog.isTraceOrDebugEnabled()) {	}	boolean result;	try {	result = mediator.mediate(synCtx);	} catch (Exception e) {	throw new SynapseException("Error occured in the mediation of the class mediator", e);	}	
end class mediator 

public void destroy() {	if (log.isDebugEnabled()) {	
destroying class mediator instance for 

public void init(SynapseEnvironment se) {	if (log.isDebugEnabled()) {	
initializing class mediator instance for 

public void init(SynapseEnvironment se) {	if (log.isDebugEnabled()) {	}	if (mediator == null) {	
init called before mediator reference set 

========================= synapse sample_1930 =========================

public void testDualQuote() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test dual channel invocation through synapse 

========================= synapse sample_857 =========================

public void init(ConfigurationContext cfgCtx, TransportOutDescription transportOut) throws AxisFault {	super.init(cfgCtx, transportOut);	connectionFactoryES = Executors.newFixedThreadPool(AMQPTransportUtils.getIntProperty( AMQPTransportConstant.PARAM_CONNECTION_FACTORY_POOL_SIZE, AMQPTransportConstant.CONNECTION_FACTORY_POOL_DEFAULT));	responseHandlingPool = Executors.newFixedThreadPool(AMQPTransportUtils.getIntProperty( AMQPTransportConstant.PARAM_RESPONSE_HANDLING_POOL_SIZE, AMQPTransportConstant.RESPONSE_HANDLING_POOL_DEFAULT));	connectionFactoryManager = new AMQPTransportConnectionFactoryManager();	connectionFactoryManager.addConnectionFactories(transportOut, connectionFactoryES);	semaphoreTimeOut = AMQPTransportUtils.getLongProperty( AMQPTransportConstant.PARAM_SEMAPHORE_TIME_OUT, 86400L);	cache = new AMQPSenderCache(new ConcurrentHashMap<Integer, AMQPSender>());	responseTracker = new ConcurrentHashMap<String, Semaphore>();	responseMessage = new ConcurrentHashMap<String, AMQPTransportMessage>();	
amqp transport sender initializing 

public void stop() {	super.stop();	try {	connectionFactoryManager.shutDownConnectionFactories();	} catch (AMQPTransportException e) {	
error while shutting down connection factories continue anyway 

throw new AxisFault("Error while initiation tx for message '" + msgCtx.getMessageID() + "'", e);	}	}	amqpSender.sendAMQPMessage(msgCtx, correlationId, replyTo);	if (tx != null) {	try {	tx.end();	} catch (IOException e) {	throw new AxisFault("Error while terminating tx for message '" + msgCtx.getMessageID() + "'", e);	} catch (InterruptedException e) {	
error while terminating tx for message 

try {	available.tryAcquire(semaphoreTimeOut, TimeUnit.SECONDS);	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	}	responseTracker.remove(correlationId);	AMQPTransportMessage msg = responseMessage.get(correlationId);	if (msg != null) {	handleSyncResponse(msgCtx, msg, msg.getContentType());	} else {	
the semaphore with id was time out while waiting for a response sending a fault to client 

private void sendFault(MessageContext msgContext, Exception e) {	try {	MessageContext faultContext = MessageContextBuilder.createFaultMessageContext( msgContext, e);	faultContext.setProperty("ERROR_MESSAGE", e.getMessage());	faultContext.setProperty("SENDING_FAULT", Boolean.TRUE);	AxisEngine.sendFault(faultContext);	} catch (AxisFault axisFault) {	
could not create the fault message 

========================= synapse sample_2465 =========================

public void setEventMask(int ops) {	if (this.log.isDebugEnabled()) {	
i o session set event mask 

public void setEvent(int op) {	if (this.log.isDebugEnabled()) {	
i o session set event 

public void clearEvent(int op) {	if (this.log.isDebugEnabled()) {	
i o session clear event 

public void close() {	if (this.log.isDebugEnabled()) {	
i o session close 

public void shutdown() {	if (this.log.isDebugEnabled()) {	
i o session shutdown 

public void setSocketTimeout(int timeout) {	if (this.log.isDebugEnabled()) {	
i o session set timeout 

public void setAttribute(final String name, final Object obj) {	if (this.log.isDebugEnabled()) {	
i o session set attribute 

public Object removeAttribute(final String name) {	if (this.log.isDebugEnabled()) {	
i o session remove attribute 

public int read(final ByteBuffer dst) throws IOException {	int bytesRead = session.channel().read(dst);	if (log.isDebugEnabled()) {	
i o session bytes read 

public int write(final ByteBuffer src) throws IOException {	int byteWritten = session.channel().write(src);	if (log.isDebugEnabled()) {	
i o session bytes written 

public void close() throws IOException {	if (log.isDebugEnabled()) {	
i o session channel close 

========================= synapse sample_3761 =========================

public void setStoreType(String storeType) {	if (storeType == null || "".equals(storeType)) {	if (log.isDebugEnabled()) {	
given store type is null using default type jks 

public void setAlias(String alias) {	if (alias == null || "".equals(alias)) {	if (log.isDebugEnabled()) {	
alias for a key entry or a certificate is null 

protected KeyStore getKeyStore() {	if (log.isDebugEnabled()) {	
loading keystore with type 

switch (storeType) {	case JKS: IKeyStoreLoader jksKeyStoreLoader = new JKSKeyStoreLoader(location, keyStorePassword);	return jksKeyStoreLoader.getKeyStore();	case PKCS12: IKeyStoreLoader pkcs12KeyStoreLoader = new PKCS12KeyStoreLoader(location, keyStorePassword);	return pkcs12KeyStoreLoader.getKeyStore();	case PKCS8: IKeyStoreLoader pkcs8KeyStoreLoader = new PKCS8KeyStoreLoader(location, parameters.get(KEY_STORE_CERTIFICATE_FILE_PATH), keyStorePassword, alias);	return pkcs8KeyStoreLoader.getKeyStore();	case CA_CERTIFICATES_PATH: ICACertsLoader caCertsLoader = new CACertsLoader();	return caCertsLoader.loadTrustStore(location);	default: if (log.isDebugEnabled()) {	
no keystore found 

========================= synapse sample_2520 =========================

private void init(String addUrl, String trpUrl, String prxUrl, String policyKey, long timeout) throws Exception {	if (log.isDebugEnabled()) {	
initializing sample client 

HttpTransportProperties.ProxyProperties proxyProperties = new HttpTransportProperties.ProxyProperties();	URL url = new URL(prxUrl);	proxyProperties.setProxyName(url.getHost());	proxyProperties.setProxyPort(url.getPort());	proxyProperties.setUserName("");	proxyProperties.setPassWord("");	proxyProperties.setDomain("");	options.setProperty(HTTPConstants.PROXY, proxyProperties);	}	if (policyKey != null && !"".equals(policyKey)) {	
using ws security 

options.setProperty(HTTPConstants.PROXY, proxyProperties);	}	if (policyKey != null && !"".equals(policyKey)) {	serviceClient.engageModule("addressing");	serviceClient.engageModule("rampart");	OMXMLParserWrapper builder = OMXMLBuilderFactory.createOMBuilder(new FileInputStream(policyKey));	Policy policy = PolicyEngine.getPolicy(builder.getDocumentElement());	options.setProperty(RampartMessageData.KEY_RAMPART_POLICY, policy);	}	if (timeout > 0) {	
setting client timeout to 

private void terminate() {	if (serviceClient != null) {	if (log.isDebugEnabled()) {	
cleaning up client 

private void terminate() {	if (serviceClient != null) {	if (log.isDebugEnabled()) {	}	try {	serviceClient.cleanupTransport();	serviceClient.cleanup();	configContext.terminate();	} catch (AxisFault axisFault) {	
error terminating client 

public SampleClientResult requestStandardQuote(String addUrl, String trpUrl, String prxUrl, String symbol, String svcPolicy) {	
sending standard quote request 

public SampleClientResult requestStandardQuote(String addUrl, String trpUrl, String prxUrl, String symbol, String svcPolicy) {	SampleClientResult clientResult = new SampleClientResult();	try {	init(addUrl, trpUrl, prxUrl, svcPolicy, 10000);	payload = StockQuoteHandler.createStandardQuoteRequest( symbol, 1);	serviceClient.getOptions().setAction("urn:getQuote");	OMElement resultElement = serviceClient.sendReceive(payload);	log.info("Standard :: Stock price = $" + StockQuoteHandler.parseStandardQuoteResponse(resultElement));	clientResult.incrementResponseCount();	} catch (Exception e) {	
error invoking service 

public SampleClientResult requestDualQuote(String addUrl, String trpUrl, String prxUrl, String symbol) {	
sending dual quote request 

while (true) {	if (isCompleted()) {	log.info("Standard dual channel :: Stock price = $" + StockQuoteHandler.parseStandardQuoteResponse(getResponse()));	clientResult.incrementResponseCount();	break;	} else {	Thread.sleep(100);	}	}	} catch (Exception e) {	
error invoking service 

public SampleClientResult requestCustomQuote(String addUrl, String trpUrl, String prxUrl, String symbol) {	
sending custom quote request 

public SampleClientResult requestCustomQuote(String addUrl, String trpUrl, String prxUrl, String symbol) {	SampleClientResult clientResult = new SampleClientResult();	try {	init(addUrl, trpUrl, prxUrl, null, 10000);	payload = StockQuoteHandler.createCustomQuoteRequest(symbol);	serviceClient.getOptions().setAction("urn:getQuote");	OMElement resultElement = serviceClient.sendReceive(payload);	log.info("Custom :: Stock price = $" + StockQuoteHandler.parseCustomQuoteResponse(resultElement));	clientResult.incrementResponseCount();	} catch (Exception e) {	
error invoking service 

public SampleClientResult placeOrder(String addUrl, String trpUrl, String prxUrl, String symbol) {	
sending fire and forget place order request 

public SampleClientResult placeOrder(String addUrl, String trpUrl, String prxUrl, String symbol) {	SampleClientResult clientResult = new SampleClientResult();	try {	init(addUrl, trpUrl, prxUrl, null, 10000);	double price = getRandom(100, 0.9, true);	int quantity = (int) getRandom(10000, 1.0, true);	payload = StockQuoteHandler.createPlaceOrderRequest(price, quantity, symbol);	serviceClient.getOptions().setAction("urn:placeOrder");	serviceClient.fireAndForget(payload);	Thread.sleep(5000);	
order placed for shares of stock at a price of 

try {	init(addUrl, trpUrl, prxUrl, null, 10000);	double price = getRandom(100, 0.9, true);	int quantity = (int) getRandom(10000, 1.0, true);	payload = StockQuoteHandler.createPlaceOrderRequest(price, quantity, symbol);	serviceClient.getOptions().setAction("urn:placeOrder");	serviceClient.fireAndForget(payload);	Thread.sleep(5000);	clientResult.incrementResponseCount();	} catch (Exception e) {	
error invoking service 

public SampleClientResult requestRestQuote(String addUrl, String trpUrl, String prxUrl, String symbol) {	
sending rest request 

SampleClientResult clientResult = new SampleClientResult();	try {	init(addUrl, trpUrl, prxUrl, null, 10000);	payload = StockQuoteHandler.createStandardQuoteRequest(symbol, 1);	serviceClient.getOptions().setAction("urn:getQuote");	serviceClient.getOptions().setProperty(Constants.Configuration.ENABLE_REST, Constants.VALUE_TRUE);	OMElement resultElement = serviceClient.sendReceive(payload);	log.info("Standard :: Stock price = $" + StockQuoteHandler. parseStandardQuoteResponse(resultElement));	clientResult.incrementResponseCount();	} catch (Exception e) {	
error invoking service 

while (i < iterations || infinite) {	serviceClient.getOptions().setManageSession(true);	OMElement responseElement = serviceClient.sendReceive(value);	String response = responseElement.getText();	clientResult.incrementResponseCount();	i++;	log.info("Request: " + i + " ==> " + response);	testString = testString.concat(":" + i + ">" + response + ":");	}	} catch (Exception e) {	
error invoking service 

if (httpSession) {	if (receivedSetCookie != null && !"".equals(receivedSetCookie)) {	cookies[cookieNumber] = receivedCookie;	}	}	SOAPEnvelope responseEnvelope = responseContext.getEnvelope();	OMElement vElement = responseEnvelope.getBody().getFirstChildWithName(new QName("Value"));	clientResult.incrementResponseCount();	log.info("Request: " + i + " with Session ID: " + (httpSession ? cookie : sessionNumber) + " ---- " + "Response : with  " + (httpSession && receivedCookie != null ? (receivedSetCookie != null ? receivedSetCookie : receivedCookie) : " ") + " " + vElement.getText());	} catch (AxisFault axisFault) {	
request with session id get a fault 

}	}	SOAPEnvelope responseEnvelope = responseContext.getEnvelope();	OMElement vElement = responseEnvelope.getBody().getFirstChildWithName(new QName("Value"));	clientResult.incrementResponseCount();	log.info("Request: " + i + " with Session ID: " + (httpSession ? cookie : sessionNumber) + " ---- " + "Response : with  " + (httpSession && receivedCookie != null ? (receivedSetCookie != null ? receivedSetCookie : receivedCookie) : " ") + " " + vElement.getText());	} catch (AxisFault axisFault) {	}	}	} catch (Exception e) {	
error invoking service 

========================= synapse sample_791 =========================

public void testCustomSequencesEndpointsWithProxy() {	String addUrl = "http: String addUrl2 = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test custom sequences and endpoints with proxy services 

========================= synapse sample_841 =========================

public PipeEndpointListener(PipeEndpoint endpoint, DatagramDispatcherCallback callback) throws IOException {	this.endpoint = endpoint;	this.callback = callback;	pipe = new RandomAccessFile(endpoint.getPipe(), "rw");	FileDescriptor fd = pipe.getFD();	readChannel = new FileInputStream(fd).getChannel();	writeChannel = new FileOutputStream(fd).getChannel();	if (log.isDebugEnabled()) {	
pipe opened 

try {	while (true) {	ProtocolDecoder decoder;	decoder = endpoint.getProtocol().createProtocolDecoder();	while (true) {	while (decoder.inputRequired()) {	int c;	try {	c = readChannel.read(readBuffer);	} catch (IOException ex) {	
error while reading from pipe shutting down listener 

decoder = endpoint.getProtocol().createProtocolDecoder();	while (true) {	while (decoder.inputRequired()) {	int c;	try {	c = readChannel.read(readBuffer);	} catch (IOException ex) {	return;	}	if (c == -1) {	
pipe was unexpectedly closed shutting down listener 

}	byte[] message = decoder.getNext();	callback.receive(endpoint, message, message.length, null);	}	}	}	finally {	try {	pipe.close();	if (log.isDebugEnabled()) {	
pipe closed 

callback.receive(endpoint, message, message.length, null);	}	}	}	finally {	try {	pipe.close();	if (log.isDebugEnabled()) {	}	} catch (IOException ex) {	
error while closing pipe 

public void stop() throws IOException {	if (log.isDebugEnabled()) {	
stopping listener for pipe 

synchronized (guard) {	running = false;	writeChannel.write(ByteBuffer.allocate(1));	}	try {	done.await();	} catch (InterruptedException ex) {	Thread.currentThread().interrupt();	}	if (log.isDebugEnabled()) {	
listener for pipe stopped 

========================= synapse sample_904 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	boolean isResponse = synCtx.isResponse();	ConfigurationContext cc;	org.apache.axis2.context.MessageContext axisMC;	if (synLog.isTraceOrDebugEnabled()) {	
start throttle mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	boolean isResponse = synCtx.isResponse();	ConfigurationContext cc;	org.apache.axis2.context.MessageContext axisMC;	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

isClusteringEnable = true;	}	}	if (!isResponse) {	if (isClusteringEnable) {	concurrentAccessController = (ConcurrentAccessController) cc.getProperty(key);	}	if (inLinePolicy != null) {	if (throttle == null) {	if (synLog.isTraceTraceEnabled()) {	
initializing using static throttling policy 

}	}	boolean canAccess = doThrottleByConcurrency(isResponse, synLog);	if (throttle != null && !isResponse && canAccess) {	canAccess = throttleByAccessRate(synCtx, axisMC, cc, synLog);	}	if (isClusteringEnable && concurrentAccessController != null) {	if (cc != null) {	try {	if (synLog.isTraceOrDebugEnabled()) {	
going to replicates the states of the concurrentaccesscontroller with key 

return mediator.mediate(synCtx);	} else {	handleException("Unable to find onReject sequence with key : " + onRejectSeqKey, synCtx);	}	} else if (onRejectMediator != null) {	return onRejectMediator.mediate(synCtx);	} else {	return false;	}	}	
end throttle mediator 

private boolean throttleByAccessRate(MessageContext synCtx, org.apache.axis2.context.MessageContext axisMC, ConfigurationContext cc, SynapseLog synLog) {	String callerId = null;	boolean canAccess = true;	String remoteIP = (String) axisMC.getPropertyNonReplicable( org.apache.axis2.context.MessageContext.REMOTE_ADDR);	String domainName = (String) axisMC.getPropertyNonReplicable(NhttpConstants.REMOTE_HOST);	if (domainName != null) {	if (synLog.isTraceOrDebugEnabled()) {	
the domain name of the caller is 

callerId = config.getConfigurationKeyOfCaller(domainName);	if (callerId != null) {	if (isClusteringEnable) {	context.setConfigurationContext(cc);	context.setThrottleId(id);	}	try {	AccessInformation accessInformation = accessControler.canAccess(context, callerId, ThrottleConstants.DOMAIN_BASE);	canAccess = accessInformation.isAccessAllowed();	if (synLog.isTraceOrDebugEnabled()) {	
access allowed denied for domain name 

cc.setProperty(key, concurrentAccessController);	}	}	} catch (ThrottleException e) {	handleException("Error occurred during throttling", e, synCtx);	}	}	}	}	} else {	
the domain name of the caller cannot be found 

handleException("Error occurred during throttling", e, synCtx);	}	}	}	}	} else {	}	if (callerId == null) {	if (remoteIP == null) {	if (synLog.isTraceOrDebugEnabled()) {	
the ip address of the caller cannot be found 

}	} else {	}	if (callerId == null) {	if (remoteIP == null) {	if (synLog.isTraceOrDebugEnabled()) {	}	canAccess = true;	} else {	if (synLog.isTraceOrDebugEnabled()) {	
the ip address of the caller is 

if (config != null) {	callerId = config.getConfigurationKeyOfCaller(remoteIP);	if (callerId != null) {	if (isClusteringEnable) {	context.setConfigurationContext(cc);	context.setThrottleId(id);	}	AccessInformation accessInformation = accessControler.canAccess( context, callerId, ThrottleConstants.IP_BASE);	canAccess = accessInformation.isAccessAllowed();	if (synLog.isTraceOrDebugEnabled()) {	
access allowed denied for ip 

========================= synapse sample_1160 =========================

public void onComplete(AsyncResult result) {	
synapse received an async response to a callback 

========================= synapse sample_3223 =========================

if (keyParam != null) {	OMElement ksEle      = keyParam.getParameterElement().getFirstElement();	String location      = ksEle.getFirstChildWithName(new QName("Location")).getText();	String type          = ksEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = ksEle.getFirstChildWithName(new QName("Password")).getText();	String keyPassword   = ksEle.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading identity keystore from 

String keyPassword   = ksEle.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

}	if (trustParam != null) {	OMElement tsEle      = trustParam.getParameterElement().getFirstElement();	String location      = tsEle.getFirstChildWithName(new QName("Location")).getText();	String type          = tsEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = tsEle.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading trust keystore from 

String storePassword = tsEle.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

fis.close();	} catch (IOException ignore) {}	}	}	}	try {	SSLContext sslcontext = SSLContext.getInstance("TLS");	sslcontext.init(keymanagers, trustManagers, null);	return sslcontext;	} catch (GeneralSecurityException gse) {	
unable to create ssl context with the given configuration 

========================= synapse sample_2432 =========================

public Map<String, Map<String, InOutStatisticsView>> determineView( List<StatisticsRecord> statisticsRecords, ComponentType type, int userIDType) {	final Map<String, Map<String, InOutStatisticsView>> statisticsMap = new HashMap<String, Map<String, InOutStatisticsView>>();	if (statisticsRecords == null) {	if (log.isDebugEnabled()) {	
statistics records cannot be found 

for (StatisticsRecord record : statisticsRecords) {	if (record != null) {	String userID;	if (IP == userIDType) {	userID = record.getClientIP();	} else {	userID = record.getClientHost();	}	if (userID == null || "".equals(userID)) {	if (log.isDebugEnabled()) {	
user id cannot be found 

}	Map<String, InOutStatisticsView> perResourceMap;	if (statisticsMap.containsKey(userID)) {	perResourceMap = statisticsMap.get(userID);	} else {	perResourceMap = new HashMap<String, InOutStatisticsView>();	statisticsMap.put(userID, perResourceMap);	}	if (perResourceMap == null) {	if (log.isDebugEnabled()) {	
there are not statistics for user id 

public Map<String, InOutStatisticsView> determineView(String id, List<StatisticsRecord> statisticsRecords, ComponentType type, int userIDType) {	if (id == null || "".equals(id)) {	handleException("Resource Id cannot be null");	}	Map<String, InOutStatisticsView> statisticsMap = new HashMap<String, InOutStatisticsView>();	if (statisticsRecords == null) {	if (log.isDebugEnabled()) {	
statistics records cannot be found 

for (StatisticsRecord record : statisticsRecords) {	if (record != null) {	String userID;	if (IP == userIDType) {	userID = record.getClientIP();	} else {	userID = record.getClientHost();	}	if (userID == null || "".equals(userID)) {	if (log.isDebugEnabled()) {	
user id cannot be found 

========================= synapse sample_2062 =========================

public static SynapseConfiguration getConfiguration(String configFile) {	try {	Properties synapseProperties = loadSynapseProperties();	DataSourceRegistrar.registerDataSources(synapseProperties);	SynapseConfiguration synCfg = XMLConfigurationBuilder.getConfiguration(new FileInputStream(configFile));	
loaded synapse configuration from 

private static Properties loadSynapseProperties() {	try {	Properties properties = new Properties();	properties.load(Thread.currentThread().getContextClassLoader(). getResourceAsStream(SynapseConstants.SYNAPSE_PROPERTIES));	return properties;	} catch (Exception e) {	
using the default tuning parameters for synapse 

========================= synapse sample_4159 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start callout mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	try {	if (synLog.isTraceOrDebugEnabled()) {	if (!isWrappingEndpointCreated) {	
using the defined endpoint 

SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	try {	if (synLog.isTraceOrDebugEnabled()) {	if (!isWrappingEndpointCreated) {	} else {	if (serviceURL != null) {	
using the serviceurl 

if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	try {	if (synLog.isTraceOrDebugEnabled()) {	if (!isWrappingEndpointCreated) {	} else {	if (serviceURL != null) {	} else {	
using the to header as the epr 

}	}	try {	if (synLog.isTraceOrDebugEnabled()) {	if (!isWrappingEndpointCreated) {	} else {	if (serviceURL != null) {	} else {	}	if (securityOn) {	
security enabled within the callout mediator config 

}	try {	if (synLog.isTraceOrDebugEnabled()) {	if (!isWrappingEndpointCreated) {	} else {	if (serviceURL != null) {	} else {	}	if (securityOn) {	if (wsSecPolicyKey != null) {	
using security policy key 

if (synLog.isTraceOrDebugEnabled()) {	if (!isWrappingEndpointCreated) {	} else {	if (serviceURL != null) {	} else {	}	if (securityOn) {	if (wsSecPolicyKey != null) {	} else {	if (inboundWsSecPolicyKey != null) {	
using inbound security policy key 

} else {	if (serviceURL != null) {	} else {	}	if (securityOn) {	if (wsSecPolicyKey != null) {	} else {	if (inboundWsSecPolicyKey != null) {	}	if (outboundWsSecPolicyKey != null) {	
using outbound security policy key 

if (requestKey != null || requestXPath != null) {	SOAPBody soapBody = synapseOutMsgCtx.getEnvelope().getBody();	soapBody.removeChildren();	soapBody.addChild(getRequestPayload(synCtx));	if (!passHeaders) {	SOAPHeader soapHeader = synapseOutMsgCtx.getEnvelope().getHeader();	soapHeader.removeChildren();	}	}	if (synLog.isTraceOrDebugEnabled()) {	
about to invoke the service 

SOAPBody soapBody = synapseOutMsgCtx.getEnvelope().getBody();	soapBody.removeChildren();	soapBody.addChild(getRequestPayload(synCtx));	if (!passHeaders) {	SOAPHeader soapHeader = synapseOutMsgCtx.getEnvelope().getHeader();	soapHeader.removeChildren();	}	}	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
request message payload 

} else {	resultMsgCtx = blockingMsgSender.send(endpoint, synapseOutMsgCtx);	if ("true".equals(resultMsgCtx.getProperty(SynapseConstants.BLOCKING_CLIENT_ERROR))) {	handleFault(synCtx, (Exception) synCtx.getProperty(SynapseConstants.ERROR_EXCEPTION));	}	}	} catch (Exception ex) {	handleFault(synCtx, ex);	}	if (synLog.isTraceTraceEnabled()) {	
response payload received 

} else {	handleException("Evaluation of target XPath expression : " + targetXPath.toString() + " did not yeild an OMNode", synCtx);	}	} else if (targetKey != null) {	OMElement result = resultMsgCtx.getEnvelope().getBody().getFirstElement();	synCtx.setProperty(targetKey, result);	} else {	synCtx.setEnvelope(resultMsgCtx.getEnvelope());	}	} else {	
service returned a null response 

} else {	synCtx.setEnvelope(resultMsgCtx.getEnvelope());	}	} else {	}	} catch (AxisFault e) {	handleException("Error invoking service : " + serviceURL + (action != null ? " with action : " + action : ""), e, synCtx);	} catch (JaxenException e) {	handleException("Error while evaluating the XPath expression: " + targetXPath, e, synCtx);	}	
end callout mediator 

========================= synapse sample_545 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start drop mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	synCtx.setTo(null);	if (synCtx.isResponse()) {	StatisticsReporter.reportForAllOnOutFlowEnd(synCtx);	}	if (synLog.isTraceOrDebugEnabled()) {	
end drop mediator 

========================= synapse sample_1971 =========================

public static void parse(SynapseEngine se, OMElement om) {	Log log = LogFactory.getLog(SynapseEngineConfigurator.class);	
parsing synapseengine 

========================= synapse sample_1422 =========================

public void testCustomMediator() {	String addUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test demonstrate the use of class mediator to extend the mediation functionality 

========================= synapse sample_816 =========================

public static SynapseConfiguration getConfiguration(InputStream is) {	
generating the synapse configuration model by parsing the xml configuration 

========================= synapse sample_3258 =========================

trace.info("Please add <syn:parameter name=\"enableURISafeMode\">true" + "</syn:parameter> to proxy service.");	}	handleException("Error reading from wsdl URI", e);	}	}	if (enablePublishWSDLSafeMode) {	if (trace()) {	trace.info("WSDL was unable to load for: " + publishWSDL);	trace.info("enableURISafeMode: true");	}	
unable to load the wsdl for 

========================= synapse sample_1635 =========================

Parameter keyParam    = transportOut.getParameter("keystore");	Parameter trustParam  = transportOut.getParameter("truststore");	OMElement ksEle = null;	OMElement tsEle = null;	if (keyParam != null) {	ksEle = keyParam.getParameterElement().getFirstElement();	}	boolean novalidatecert = ParamUtils.getOptionalParamBoolean(transportOut, "novalidatecert", false);	if (trustParam != null) {	if (novalidatecert) {	
ignoring novalidatecert parameter since a truststore has been specified 

private Map<String, SSLContext> getCustomSSLContexts(TransportOutDescription transportOut) throws AxisFault {	if (log.isDebugEnabled()) {	
loading custom ssl profiles for the https sender 

OMElement ksElt = profile.getFirstChildWithName(new QName("KeyStore"));	OMElement trElt = profile.getFirstChildWithName(new QName("TrustStore"));	String noValCert = profile.getAttributeValue(new QName("novalidatecert"));	boolean novalidatecert = "true".equals(noValCert);	SSLContext sslContext = createSSLContext(ksElt, trElt, novalidatecert);	for (String server : servers) {	server = server.trim();	if (!contextMap.containsKey(server)) {	contextMap.put(server, sslContext);	} else {	
multiple ssl profiles were found for the server ignoring the excessive profiles 

SSLContext sslContext = createSSLContext(ksElt, trElt, novalidatecert);	for (String server : servers) {	server = server.trim();	if (!contextMap.containsKey(server)) {	contextMap.put(server, sslContext);	} else {	}	}	}	if (contextMap.size() > 0) {	
custom ssl profiles initialized for servers 

TrustManager[] trustManagers = null;	if (keyStoreElt != null) {	String location      = keyStoreElt.getFirstChildWithName(new QName("Location")).getText();	String type          = keyStoreElt.getFirstChildWithName(new QName("Type")).getText();	String storePassword = keyStoreElt.getFirstChildWithName(new QName("Password")).getText();	String keyPassword   = keyStoreElt.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading identity keystore from 

String keyPassword   = keyStoreElt.getFirstChildWithName(new QName("KeyPassword")).getText();	FileInputStream fis = null;	try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	
error loading keystore 

try {	KeyStore keyStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	keyStore.load(fis, storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Keystore : " + location, gse);	} catch (IOException ioe) {	
error opening keystore 

} finally {	if (fis != null) {	try {	fis.close();	} catch (IOException ignore) {}	}	}	}	if (trustStoreElt != null) {	if (novalidatecert) {	
ignoring novalidatecert parameter since a truststore has been specified 

if (trustStoreElt != null) {	if (novalidatecert) {	}	String location      = trustStoreElt.getFirstChildWithName(new QName("Location")).getText();	String type          = trustStoreElt.getFirstChildWithName(new QName("Type")).getText();	String storePassword = trustStoreElt.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	
loading trust keystore from 

String storePassword = trustStoreElt.getFirstChildWithName(new QName("Password")).getText();	FileInputStream fis = null;	try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

try {	KeyStore trustStore = KeyStore.getInstance(type);	fis = new FileInputStream(location);	trustStore.load(fis, storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

} catch (IOException ioe) {	throw new AxisFault("Error opening Key store : " + location, ioe);	} finally {	if (fis != null) {	try {	fis.close();	} catch (IOException ignore) {}	}	}	} else if (novalidatecert) {	
server certificate validation trust has been disabled do not use in production 

}	}	} else if (novalidatecert) {	trustManagers = new TrustManager[] { new NoValidateCertTrustManager() };	}	try {	SSLContext sslcontext = SSLContext.getInstance("TLS");	sslcontext.init(keymanagers, trustManagers, null);	return sslcontext;	} catch (GeneralSecurityException gse) {	
unable to create ssl context with the given configuration 

========================= synapse sample_2449 =========================

protected static File preparePath(VFSTestEnvironment env, String path) {	File file = new File(env.getRootDir(), path);	File dir = file.getParentFile();	if (dir.exists()) {	
deleting leftover file 

protected static File preparePath(VFSTestEnvironment env, String path) {	File file = new File(env.getRootDir(), path);	File dir = file.getParentFile();	if (dir.exists()) {	file.delete();	} else {	
creating directory 

========================= synapse sample_882 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
priorityexecutor deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	PriorityExecutor e = PriorityExecutorFactory.createExecutor( SynapseConstants.SYNAPSE_NAMESPACE, artifactConfig, true, properties);	if (e != null) {	e.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
priorityexecutor with name has been built from the file 

}	try {	PriorityExecutor e = PriorityExecutorFactory.createExecutor( SynapseConstants.SYNAPSE_NAMESPACE, artifactConfig, true, properties);	if (e != null) {	e.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addPriorityExecutor(e.getName(), e);	e.init();	if (log.isDebugEnabled()) {	
priorityexecutor deployment from file completed 

try {	PriorityExecutor e = PriorityExecutorFactory.createExecutor( SynapseConstants.SYNAPSE_NAMESPACE, artifactConfig, true, properties);	if (e != null) {	e.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addPriorityExecutor(e.getName(), e);	e.init();	if (log.isDebugEnabled()) {	}	
priorityexecutor named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
priorityexecutor update from file has started 

if (log.isDebugEnabled()) {	}	try {	PriorityExecutor e = PriorityExecutorFactory.createExecutor( SynapseConstants.SYNAPSE_NAMESPACE, artifactConfig, true, properties);	if (e == null) {	handleSynapseArtifactDeploymentError("PriorityExecutor update failed. The artifact " + "defined in the file: " + fileName + " is not a valid executor.");	return null;	}	e.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	
executor has been built from the file 

e.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	e.init();	PriorityExecutor existingExecutor = getSynapseConfiguration().getPriorityExecutors(). get(existingArtifactName);	if (existingArtifactName.equals(e.getName())) {	getSynapseConfiguration().updatePriorityExecutor(existingArtifactName, e);	} else {	getSynapseConfiguration().addPriorityExecutor(e.getName(), e);	getSynapseConfiguration().removeExecutor(existingArtifactName);	
executor has been undeployed 

e.init();	PriorityExecutor existingExecutor = getSynapseConfiguration().getPriorityExecutors(). get(existingArtifactName);	if (existingArtifactName.equals(e.getName())) {	getSynapseConfiguration().updatePriorityExecutor(existingArtifactName, e);	} else {	getSynapseConfiguration().addPriorityExecutor(e.getName(), e);	getSynapseConfiguration().removeExecutor(existingArtifactName);	}	waitForCompletion();	existingExecutor.destroy();	
priorityexecutor has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
priorityexecutor undeployment of the entry named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	PriorityExecutor e = getSynapseConfiguration().getPriorityExecutors().get(artifactName);	if (e != null) {	e = getSynapseConfiguration().removeExecutor(artifactName);	if (log.isDebugEnabled()) {	
priorityexecutor undeployment of the entry named completed 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	PriorityExecutor e = getSynapseConfiguration().getPriorityExecutors().get(artifactName);	if (e != null) {	e = getSynapseConfiguration().removeExecutor(artifactName);	if (log.isDebugEnabled()) {	}	e.destroy();	
priorityexecutor named has been undeployed 

if (log.isDebugEnabled()) {	}	try {	PriorityExecutor e = getSynapseConfiguration().getPriorityExecutors().get(artifactName);	if (e != null) {	e = getSynapseConfiguration().removeExecutor(artifactName);	if (log.isDebugEnabled()) {	}	e.destroy();	} else if (log.isDebugEnabled()) {	
priorityexecutor has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring priorityexecutor with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	PriorityExecutor e = getSynapseConfiguration().getPriorityExecutors().get(artifactName);	OMElement entryElem = PriorityExecutorSerializer.serialize(null, e, SynapseConstants.SYNAPSE_NAMESPACE);	if (e.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.EXECUTORS_DIR + File.separator + e.getFileName();	writeToFile(entryElem, fileName);	if (log.isDebugEnabled()) {	
restoring the priorityexecutor with name completed 

if (log.isDebugEnabled()) {	}	try {	PriorityExecutor e = getSynapseConfiguration().getPriorityExecutors().get(artifactName);	OMElement entryElem = PriorityExecutorSerializer.serialize(null, e, SynapseConstants.SYNAPSE_NAMESPACE);	if (e.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.EXECUTORS_DIR + File.separator + e.getFileName();	writeToFile(entryElem, fileName);	if (log.isDebugEnabled()) {	}	
priorityexecutor named has been restored 

========================= synapse sample_181 =========================

public void testManipulatingHeadersAndFiltering() {	String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test dumb client mode 

========================= synapse sample_2275 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start switch mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	int parentsEffectiveTraceState = synCtx.getTracingState();	setEffectiveTraceState(synCtx);	String sourceText = source.stringValueOf(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
xpath evaluates to 

if (synLog.isTraceTraceEnabled()) {	}	}	int parentsEffectiveTraceState = synCtx.getTracingState();	setEffectiveTraceState(synCtx);	String sourceText = source.stringValueOf(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	}	try {	if ((sourceText == null || cases.isEmpty()) && defaultCase != null) {	
source xpath evaluated to null or no switch cases found executing the default case 

if (synLog.isTraceOrDebugEnabled()) {	}	try {	if ((sourceText == null || cases.isEmpty()) && defaultCase != null) {	return defaultCase.mediate(synCtx);	} else {	for (SwitchCase swCase : cases) {	if (swCase != null) {	if (swCase.matches(sourceText)) {	if (synLog.isTraceOrDebugEnabled()) {	
matching case found 

for (SwitchCase swCase : cases) {	if (swCase != null) {	if (swCase.matches(sourceText)) {	if (synLog.isTraceOrDebugEnabled()) {	}	return swCase.mediate(synCtx);	}	}	}	if (defaultCase != null) {	
none of the switch cases matched executing default 

if (swCase.matches(sourceText)) {	if (synLog.isTraceOrDebugEnabled()) {	}	return swCase.mediate(synCtx);	}	}	}	if (defaultCase != null) {	return defaultCase.mediate(synCtx);	} else {	
none of the switch cases matched no default case 

}	}	if (defaultCase != null) {	return defaultCase.mediate(synCtx);	} else {	}	}	} finally {	synCtx.setTracingState(parentsEffectiveTraceState);	}	
end switch mediator 

========================= synapse sample_494 =========================

public static TaskDescriptionRepository getTaskDescriptionRepository(String id) {	if (id == null || "".equals(id)) {	throw new SynapseTaskException("Name cannot be found.", log);	}	TaskDescriptionRepository repository = repositoryMap.get(id);	if (repository == null) {	if (log.isDebugEnabled()) {	
creating a taskdescriptionrepository with id 

========================= synapse sample_1459 =========================

public void addTaskDescription(TaskDescription taskDescription) {	validateTaskDescription(taskDescription);	String name = taskDescription.getName();	validateName(name);	validateUniqueness(name);	if (log.isDebugEnabled()) {	
storing a taskdescription 

public TaskDescription getTaskDescription(String name) {	validateName(name);	TaskDescription taskDescription = taskDescriptionMap.get(name);	if (taskDescription == null) {	if (log.isDebugEnabled()) {	
taskdescription cannot be found for name returning null 

public TaskDescription getTaskDescription(String name) {	validateName(name);	TaskDescription taskDescription = taskDescriptionMap.get(name);	if (taskDescription == null) {	if (log.isDebugEnabled()) {	}	} else {	if (log.isDebugEnabled()) {	
returning taskdescription 

public TaskDescription removeTaskDescription(String name) {	validateName(name);	if (log.isDebugEnabled()) {	
removing a taskdescription with name 

public TaskDescription removeTaskDescription(String name) {	validateName(name);	if (log.isDebugEnabled()) {	}	TaskDescription taskDescription = taskDescriptionMap.remove(name);	if (taskDescription == null) {	if (log.isDebugEnabled()) {	
there is no taskdescription to be removed with name 

public TaskDescription removeTaskDescription(String name) {	validateName(name);	if (log.isDebugEnabled()) {	}	TaskDescription taskDescription = taskDescriptionMap.remove(name);	if (taskDescription == null) {	if (log.isDebugEnabled()) {	}	} else {	if (log.isDebugEnabled()) {	
removed taskdescription 

========================= synapse sample_30 =========================

public void init(DataSourceInformationRepository repository, Properties properties) {	if (initialized) {	if (log.isDebugEnabled()) {	
data source repository holder has already been initialized 

public void init(DataSourceInformationRepository repository, Properties properties) {	if (initialized) {	if (log.isDebugEnabled()) {	}	return;	}	if (log.isDebugEnabled()) {	
initializing the data source repository holder 

========================= synapse sample_705 =========================

private void registerExtensions() {	if (log.isDebugEnabled()) {	
registering mediator extensions found in the classpath 

MediatorSerializer ms = (MediatorSerializer) it.next();	String name = ms.getMediatorClassName();	try {	serializerMap.put(name, ms.getClass().newInstance());	} catch (InstantiationException e) {	handleException("Error instantiating mediator serializer : " + ms);	} catch (IllegalAccessException e) {	handleException("Error instantiating mediator serializer : " + ms);	}	if (log.isDebugEnabled()) {	
added mediatorserializer to handle 

========================= synapse sample_1818 =========================

public void resetStatistics() {	
operation not supported over jmx 

========================= synapse sample_4319 =========================

public boolean mediate(MessageContext synCtx) {	
out mediator mediate 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	try {	if (shouldTrace) {	trace.trace("Start : Out mediator");	}	if (test(synCtx)) {	
current message is outgoing executing child mediators 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	try {	if (shouldTrace) {	trace.trace("Start : Out mediator");	}	if (test(synCtx)) {	return super.mediate(synCtx);	} else {	
current message is not outgoing skipping child mediators 

========================= synapse sample_3063 =========================

protected SynapseTestCase(int sampleId) {	if (log.isDebugEnabled()) {	
creating synapsetestcase for test 

public void tearDown() {	
sample is finished 

private void doCleanup() {	if (synapseController != null) {	
stopping synapse 

private void doCleanup() {	if (synapseController != null) {	synapseController.stopProcess();	}	List<ProcessController> removed = new ArrayList<ProcessController>();	for (ProcessController bsc : backendServerControllers) {	if (bsc instanceof Axis2BackEndServerController) {	
stopping server 

for (ProcessController bsc : backendServerControllers) {	if (bsc instanceof Axis2BackEndServerController) {	bsc.stopProcess();	removed.add(bsc);	}	}	for (ProcessController bsc : removed) {	backendServerControllers.remove(bsc);	}	for (ProcessController bsc : backendServerControllers) {	
stopping server 

}	for (ProcessController bsc : removed) {	backendServerControllers.remove(bsc);	}	for (ProcessController bsc : backendServerControllers) {	bsc.stopProcess();	}	try {	FileUtils.cleanDirectory(new File(System.getProperty("java.io.tmpdir")));	} catch (IOException e) {	
error while cleaning temp directory 

private OMElement loadDescriptorInfoFile() {	String sampleDescriptor = "/sample" + sampleId + ".xml";	if (log.isDebugEnabled()) {	
reading sample descriptor file from 

if (log.isDebugEnabled()) {	}	try {	InputStream in = this.getClass().getResourceAsStream(sampleDescriptor);	if (in == null) {	fail("Cannot read sample descriptor file");	}	OMXMLParserWrapper builder = OMXMLBuilderFactory.createOMBuilder(in);	return builder.getDocumentElement();	} catch (Exception e) {	
error loading test descriptor 

private List<ProcessController> initBackEndServersConfigInfo(OMElement config) {	
initializing configuration information for backend servers 

private List<ProcessController> initBackEndServersConfigInfo(OMElement config) {	List<ProcessController> controllers = new ArrayList<ProcessController>();	OMElement backendServersConfig = config.getFirstChildWithName( new QName(SampleConfigConstants.TAG_BE_SERVER_CONF));	if (backendServersConfig == null) {	
no backend servers defined 

if (backendServersConfig == null) {	return null;	}	Iterator backendServers = backendServersConfig.getChildElements();	while (backendServers.hasNext()) {	OMElement backendServer = (OMElement) backendServers.next();	ProcessController controller = SynapseTestUtils.createController(backendServer);	if (controller != null) {	controllers.add(controller);	} else {	
unrecognized backend server configuration 

private boolean configureClustering() {	try {	String ip = SynapseTestUtils.getIPAddress();	if (ip == null || ip.length() == 0) {	
could not detect an active ip address 

private boolean configureClustering() {	try {	String ip = SynapseTestUtils.getIPAddress();	if (ip == null || ip.length() == 0) {	return false;	}	
using the ip 

String beAxis2Config = FileUtils.readFileToString(new File(beAxis2Xml));	String modifiedBEAxis2 = SynapseTestUtils.replace(beAxis2Config, "${replace.me}", ip);	File tempBEAxis2 = File.createTempFile("axis2BE-", "xml");	tempBEAxis2.deleteOnExit();	FileUtils.writeStringToFile(tempBEAxis2, modifiedBEAxis2);	axis2Controller.setAxis2Xml(tempBEAxis2.getAbsolutePath());	}	}	return true;	} catch (Exception e) {	
error configuring clustering 

========================= synapse sample_2222 =========================

if (EventingConstants.WSE_SUBSCRIBE.equals(mc.getWSAAction())) {	processSubscriptionRequest(mc, messageBuilder);	} else if (EventingConstants.WSE_UNSUBSCRIBE.equals(mc.getWSAAction())) {	processUnSubscribeRequest(mc, messageBuilder);	} else if (EventingConstants.WSE_GET_STATUS.equals(mc.getWSAAction())) {	processGetStatusRequest(mc, messageBuilder);	} else if (EventingConstants.WSE_RENEW.equals(mc.getWSAAction())) {	processReNewRequest(mc, messageBuilder);	} else {	if (log.isDebugEnabled()) {	
event received 

Event<MessageContext> event = new Event(msgCtx);	subscriptions = subscriptionManager.getMatchingSubscriptions(event);	} catch (EventException e) {	handleException("Matching subscriptions fetching error", e);	}	for (Subscription subscription : subscriptions) {	synCtx.setProperty(SynapseConstants.OUT_ONLY, "true");	try {	getEndpointFromURL(subscription.getEndpointUrl(), synCtx.getEnvironment()) .send(MessageHelper.cloneMessageContext(synCtx));	} catch (AxisFault axisFault) {	
event sending failure 

} catch (EventException e) {	handleException("Matching subscriptions fetching error", e);	}	for (Subscription subscription : subscriptions) {	synCtx.setProperty(SynapseConstants.OUT_ONLY, "true");	try {	getEndpointFromURL(subscription.getEndpointUrl(), synCtx.getEnvironment()) .send(MessageHelper.cloneMessageContext(synCtx));	} catch (AxisFault axisFault) {	}	if (log.isDebugEnabled()) {	
event push to 

private void processSubscriptionRequest(MessageContext mc, ResponseMessageBuilder messageBuilder) throws AxisFault, EventException {	SynapseSubscription subscription = SubscriptionMessageBuilder.createSubscription(mc);	if (log.isDebugEnabled()) {	
synapsesubscription request recived 

private void processSubscriptionRequest(MessageContext mc, ResponseMessageBuilder messageBuilder) throws AxisFault, EventException {	SynapseSubscription subscription = SubscriptionMessageBuilder.createSubscription(mc);	if (log.isDebugEnabled()) {	}	if (subscription.getId() != null) {	String subID = subscriptionManager.subscribe(subscription);	if (subID != null) {	if (log.isDebugEnabled()) {	
sending subscription response for synapsesubscription id 

}	if (subscription.getId() != null) {	String subID = subscriptionManager.subscribe(subscription);	if (subID != null) {	if (log.isDebugEnabled()) {	}	SOAPEnvelope soapEnvelope = messageBuilder.genSubscriptionResponse(subscription);	dispatchResponse(soapEnvelope, EventingConstants.WSE_SUbSCRIBE_RESPONSE, mc, false);	} else {	if (log.isDebugEnabled()) {	
synapsesubscription failed sending fault response 

SOAPEnvelope soapEnvelope = messageBuilder.genSubscriptionResponse(subscription);	dispatchResponse(soapEnvelope, EventingConstants.WSE_SUbSCRIBE_RESPONSE, mc, false);	} else {	if (log.isDebugEnabled()) {	}	SOAPEnvelope soapEnvelope = messageBuilder.genFaultResponse(mc, EventingConstants.WSE_FAULT_CODE_RECEIVER, "EventSourceUnableToProcess", "Unable to subscribe ", "");	dispatchResponse(soapEnvelope, EventingConstants.WSA_FAULT, mc, true);	}	} else {	if (log.isDebugEnabled()) {	
synapsesubscription failed sending fault response 

private void processUnSubscribeRequest(MessageContext mc, ResponseMessageBuilder messageBuilder) throws AxisFault, EventException {	SynapseSubscription subscription = SubscriptionMessageBuilder.createUnSubscribeMessage(mc);	if (log.isDebugEnabled()) {	
unsubscribe response recived for synapsesubscription id 

private void processUnSubscribeRequest(MessageContext mc, ResponseMessageBuilder messageBuilder) throws AxisFault, EventException {	SynapseSubscription subscription = SubscriptionMessageBuilder.createUnSubscribeMessage(mc);	if (log.isDebugEnabled()) {	}	if (subscriptionManager.unsubscribe(subscription.getId())) {	if (log.isDebugEnabled()) {	
sending unsubscribe responce for synapsesubscription id 

SynapseSubscription subscription = SubscriptionMessageBuilder.createUnSubscribeMessage(mc);	if (log.isDebugEnabled()) {	}	if (subscriptionManager.unsubscribe(subscription.getId())) {	if (log.isDebugEnabled()) {	}	SOAPEnvelope soapEnvelope = messageBuilder.genUnSubscribeResponse(subscription);	dispatchResponse(soapEnvelope, EventingConstants.WSE_UNSUBSCRIBE_RESPONSE, mc, false);	} else {	if (log.isDebugEnabled()) {	
unsubscription failed sending fault repsponse 

private void processGetStatusRequest(MessageContext mc, ResponseMessageBuilder messageBuilder) throws AxisFault, EventException {	Subscription subscription = SubscriptionMessageBuilder.createGetStatusMessage(mc);	if (log.isDebugEnabled()) {	
getstatus request recived for synapsesubscription id 

private void processGetStatusRequest(MessageContext mc, ResponseMessageBuilder messageBuilder) throws AxisFault, EventException {	Subscription subscription = SubscriptionMessageBuilder.createGetStatusMessage(mc);	if (log.isDebugEnabled()) {	}	subscription = subscriptionManager.getSubscription(subscription.getId());	if (subscription != null) {	if (log.isDebugEnabled()) {	
sending getstatus responce for synapsesubscription id 

if (log.isDebugEnabled()) {	}	subscription = subscriptionManager.getSubscription(subscription.getId());	if (subscription != null) {	if (log.isDebugEnabled()) {	}	SOAPEnvelope soapEnvelope = messageBuilder.genGetStatusResponse(subscription);	dispatchResponse(soapEnvelope, EventingConstants.WSE_GET_STATUS_RESPONSE, mc, false);	} else {	if (log.isDebugEnabled()) {	
getstatus failed sending fault response 

private void processReNewRequest(MessageContext mc, ResponseMessageBuilder messageBuilder) throws AxisFault, EventException {	SynapseSubscription subscription = SubscriptionMessageBuilder.createRenewSubscribeMessage(mc);	if (log.isDebugEnabled()) {	
renew request recived for synapsesubscription id 

private void processReNewRequest(MessageContext mc, ResponseMessageBuilder messageBuilder) throws AxisFault, EventException {	SynapseSubscription subscription = SubscriptionMessageBuilder.createRenewSubscribeMessage(mc);	if (log.isDebugEnabled()) {	}	String subID = subscription.getId();	if (subID != null) {	if (subscriptionManager.renew(subscription)) {	if (log.isDebugEnabled()) {	
sending renew response for synapsesubscription id 

}	String subID = subscription.getId();	if (subID != null) {	if (subscriptionManager.renew(subscription)) {	if (log.isDebugEnabled()) {	}	SOAPEnvelope soapEnvelope = messageBuilder.genRenewSubscriptionResponse(subscription);	dispatchResponse(soapEnvelope, EventingConstants.WSE_RENEW_RESPONSE, mc, false);	} else {	if (log.isDebugEnabled()) {	
renew failed sending fault response 

========================= synapse sample_656 =========================

public boolean process(SynapseEnvironment se, SynapseMessage sm) {	
process 

========================= synapse sample_1361 =========================

public static Properties loadSynapseProperties() {	if (reload) {	if (log.isDebugEnabled()) {	
loading synapse properties from a property file 

public static Properties loadSynapseProperties() {	if (reload) {	if (log.isDebugEnabled()) {	}	cacheProperties.putAll(MiscellaneousUtil.loadProperties( SynapseConstants.SYNAPSE_PROPERTIES));	reload = false;	} else {	if (log.isDebugEnabled()) {	
retrieving synapse properties from the cache 

public static Properties reloadSynapseProperties() {	if (log.isDebugEnabled()) {	
reloading synapse properties 

========================= synapse sample_1731 =========================

sendingFaultTable.clear();	responseCodeTable.clear();	lastResetTime = System.currentTimeMillis();	if (endpoint.getChildren() != null) {	for (Endpoint e : endpoint.getChildren()) {	if (e.getMetricsMBean() != null) {	e.getMetricsMBean().resetStatistics();	}	}	}	
endpoint statistics reset for and or its children 

========================= synapse sample_1674 =========================

public boolean mediate(MessageContext synCtx) {	
xslt mediator mediate 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	if (shouldTrace) {	trace.trace("Start : XSLT mediator");	}	
performing xslt transformation against property with key 

private void performXLST(MessageContext msgCtx,boolean shouldTrace) {	Source transformSrc = null;	ByteArrayOutputStream baosForTarget = new ByteArrayOutputStream();	StreamResult transformTgt = new StreamResult(baosForTarget);	OMNode sourceNode = getTransformSource(msgCtx);	if (shouldTrace) {	trace.trace("Transformation source : " + sourceNode.toString());	}	if (log.isDebugEnabled()) {	
transformation source 

}	}	try {	transformer.transform(transformSrc, transformTgt);	StAXOMBuilder builder = new StAXOMBuilder( new ByteArrayInputStream(baosForTarget.toByteArray()));	OMElement result = builder.getDocumentElement();	if (shouldTrace) {	trace.trace("Transformation result : " + result.toString());	}	if (log.isDebugEnabled()) {	
transformation result 

========================= synapse sample_3130 =========================

} catch (IOException ex) {	logIOException(conn, ex);	TargetContext.updateState(conn, ProtocolState.CLOSING);	targetConfiguration.getConnections().shutdownConnection(conn);	informWriterError(conn);	MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();	if (requestMsgCtx != null) {	targetErrorHandler.handleError(requestMsgCtx, ErrorCodes.SND_HTTP_ERROR, "Error in Sender", null, connState);	}	} catch (Exception e) {	
error occurred while writing data to the target 

connState = TargetContext.getState(conn);	if (connState != ProtocolState.REQUEST_DONE) {	handleInvalidState(conn, "Receiving response");	return;	}	HttpResponse response = conn.getHttpResponse();	TargetRequest targetRequest = TargetContext.getRequest(conn);	int statusCode = response.getStatusLine().getStatusCode();	if (statusCode < HttpStatus.SC_OK) {	if (log.isDebugEnabled()) {	
received a continue response 

public void closed(NHttpClientConnection conn) {	ProtocolState state = TargetContext.getState(conn);	boolean sendFault = false;	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	
keep alive connection closed 

public void closed(NHttpClientConnection conn) {	ProtocolState state = TargetContext.getState(conn);	boolean sendFault = false;	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_HEAD || state == ProtocolState.REQUEST_BODY) {	informWriterError(conn);	
connection closed while sending the request 

ProtocolState state = TargetContext.getState(conn);	boolean sendFault = false;	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_HEAD || state == ProtocolState.REQUEST_BODY) {	informWriterError(conn);	sendFault = true;	} else if (state == ProtocolState.RESPONSE_HEAD || state == ProtocolState.RESPONSE_BODY) {	informReaderError(conn);	
connection closed while receiving the response 

if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_HEAD || state == ProtocolState.REQUEST_BODY) {	informWriterError(conn);	sendFault = true;	} else if (state == ProtocolState.RESPONSE_HEAD || state == ProtocolState.RESPONSE_BODY) {	informReaderError(conn);	sendFault = false;	} else if (state == ProtocolState.REQUEST_DONE) {	informWriterError(conn);	
connection closed before receiving the request 

public void timeout(NHttpClientConnection conn) {	ProtocolState state = TargetContext.getState(conn);	String message = getErrorMessage("Connection timeout", conn);	if (log.isDebugEnabled()) {	log.debug(message);	}	if (state != null && (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE)) {	if (log.isDebugEnabled()) {	
keep alive connection timed out 

if (state == ProtocolState.REQUEST_BODY) {	metrics.incrementTimeoutsSending();	informWriterError(conn);	}	if (state == ProtocolState.RESPONSE_BODY || state == ProtocolState.REQUEST_HEAD) {	metrics.incrementTimeoutsReceiving();	informReaderError(conn);	}	if (state.compareTo(ProtocolState.REQUEST_DONE) <= 0) {	MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();	
connection time out while in state 

public void endOfInput(NHttpClientConnection conn) throws IOException {	ProtocolState state = TargetContext.getState(conn);	boolean sendFault = false;	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	
keep alive connection closed by the target host 

public void endOfInput(NHttpClientConnection conn) throws IOException {	ProtocolState state = TargetContext.getState(conn);	boolean sendFault = false;	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_HEAD || state == ProtocolState.REQUEST_BODY) {	informWriterError(conn);	
connection closed by the target host while sending the request 

ProtocolState state = TargetContext.getState(conn);	boolean sendFault = false;	if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {	if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_HEAD || state == ProtocolState.REQUEST_BODY) {	informWriterError(conn);	sendFault = true;	} else if (state == ProtocolState.RESPONSE_HEAD || state == ProtocolState.RESPONSE_BODY) {	informReaderError(conn);	
connection closed by the target host while receiving the response 

if (log.isDebugEnabled()) {	}	} else if (state == ProtocolState.REQUEST_HEAD || state == ProtocolState.REQUEST_BODY) {	informWriterError(conn);	sendFault = true;	} else if (state == ProtocolState.RESPONSE_HEAD || state == ProtocolState.RESPONSE_BODY) {	informReaderError(conn);	sendFault = false;	} else if (state == ProtocolState.REQUEST_DONE) {	informWriterError(conn);	
connection closed by the target host before receiving the request 

public void exception(NHttpClientConnection conn, Exception e) {	if (e instanceof HttpException) {	exception(conn, (HttpException) e);	} else if (e instanceof IOException) {	exception(conn, (IOException) e);	} else {	
unexpected exception encountered in targethandler 

private void handleInvalidState(NHttpClientConnection conn, String action) {	ProtocolState state = TargetContext.getState(conn);	
while the handler is in an inconsistent state 

========================= synapse sample_969 =========================

public HostConnections(String host, int port, int maxSize) {	if (log.isDebugEnabled()) {	
creating new connection pool to the host port 

public NHttpClientConnection getConnection() {	lock.lock();	try {	if (freeConnections.size() > 0) {	if (log.isDebugEnabled()) {	
returning an existing free connection to 

public void release(NHttpClientConnection conn) {	conn.getMetrics().reset();	HttpContext ctx = conn.getContext();	ctx.removeAttribute(HttpCoreContext.HTTP_REQUEST);	ctx.removeAttribute(HttpCoreContext.HTTP_RESPONSE);	lock.lock();	try {	if (busyConnections.remove(conn)) {	freeConnections.add(conn);	} else {	
attempted to releaseconnection connection not in the busy list 

public void addConnection(NHttpClientConnection conn) {	if (log.isDebugEnabled()) {	
new connection to is added to the free list 

========================= synapse sample_2371 =========================

public void addCallback(String MsgID, AxisCallback callback) {	callbackStore.put(MsgID, callback);	if (log.isDebugEnabled()) {	
callback added total callbacks waiting for 

if (relatesTo != null) {	messageID = relatesTo.getValue();	}	}	} else if (messageCtx.getProperty(SynapseConstants.MERCURY_SEQUENCE_KEY) == null) {	messageID = (String) messageCtx.getProperty(SynapseConstants.RELATES_TO_FOR_POX);	}	if (messageID != null) {	AxisCallback callback = callbackStore.remove(messageID);	if (log.isDebugEnabled()) {	
callback removed pending callbacks count 

AxisCallback callback = callbackStore.remove(messageID);	if (log.isDebugEnabled()) {	}	RelatesTo[] relates = messageCtx.getRelationships();	if (relates != null && relates.length > 1) {	removeDuplicateRelatesTo(messageCtx, relates);	}	if (callback != null) {	handleMessage(messageCtx, ((AsyncCallback) callback).getSynapseOutMsgCtx());	} else {	
synapse received a response for the request with message id but a callback is not registered anymore to process this response 

}	RelatesTo[] relates = messageCtx.getRelationships();	if (relates != null && relates.length > 1) {	removeDuplicateRelatesTo(messageCtx, relates);	}	if (callback != null) {	handleMessage(messageCtx, ((AsyncCallback) callback).getSynapseOutMsgCtx());	} else {	}	} else if (!messageCtx.isPropertyTrue(NhttpConstants.SC_ACCEPTED)){	
synapse received a response message without a message id 

((FaultHandler) faultStack.pop()).handleFault(synapseOutMsgCtx, e);	}	}	}	} else {	Stack faultStack = synapseOutMsgCtx.getFaultStack();	if (faultStack !=null && !faultStack.isEmpty() && faultStack.peek() instanceof Endpoint) {	faultStack.pop();	}	if (log.isDebugEnabled()) {	
synapse received an asynchronous response message 

if (faultStack !=null && !faultStack.isEmpty() && faultStack.peek() instanceof Endpoint) {	faultStack.pop();	}	if (log.isDebugEnabled()) {	log.debug("Received To: " + (response.getTo() != null ? response.getTo().getAddress() : "null"));	log.debug("SOAPAction: " + (response.getSoapAction() != null ? response.getSoapAction() : "null"));	log.debug("WSA-Action: " + (response.getWSAAction() != null ? response.getWSAAction() : "null"));	String[] cids = response.getAttachmentMap().getAllContentIDs();	if (cids != null && cids.length > 0) {	for (String cid : cids) {	
attachment 

}	if (log.isDebugEnabled()) {	log.debug("Received To: " + (response.getTo() != null ? response.getTo().getAddress() : "null"));	log.debug("SOAPAction: " + (response.getSoapAction() != null ? response.getSoapAction() : "null"));	log.debug("WSA-Action: " + (response.getWSAAction() != null ? response.getWSAAction() : "null"));	String[] cids = response.getAttachmentMap().getAllContentIDs();	if (cids != null && cids.length > 0) {	for (String cid : cids) {	}	}	
body 

for (Object key : synapseOutMsgCtx.getPropertyKeySet()) {	synapseInMessageContext.setProperty( (String) key, synapseOutMsgCtx.getProperty((String) key));	}	try {	synapseOutMsgCtx.getEnvironment().injectMessage(synapseInMessageContext);	} catch (SynapseException syne) {	Stack stack = synapseInMessageContext.getFaultStack();	if (stack != null && !stack.isEmpty()) {	((FaultHandler) stack.pop()).handleFault(synapseInMessageContext, syne);	} else {	
synapse encountered an exception no error handlers found message dropped 

========================= synapse sample_3999 =========================

messageStore.poll();	final ExecutorService executor = messageContext.getEnvironment(). getExecutorService();	executor.submit(new Runnable() {	public void run() {	try {	Mediator processingSequence = messageContext.getSequence(sequence);	if (processingSequence != null) {	processingSequence.mediate(messageContext);	}	} catch (Throwable t) {	
error occurred while executing the message 

========================= synapse sample_590 =========================

public void testDbLookupReport() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test action of dbreport and dblookup mediators together 

public void testDbLookupReport() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	result = client.requestStandardQuote(addUrl, trpUrl, null, "IBM" ,null);	assertTrue("Client did not get run successfully ", result.responseReceived());	
running test introduction to the dblookup mediator 

========================= synapse sample_2234 =========================

public boolean mediate(MessageContext smc) {	
set property mediator mediate 

========================= synapse sample_3075 =========================

}	pt.setChannel(connectionFactory.getChannel());	pt.setConnectionFactoryName(connectionFactory.getName());	String responseConFac = AMQPTransportUtils.getOptionalStringParameter( AMQPTransportConstant.PARAMETER_RESPONSE_CONNECTION_FACTORY_NAME, svcParam, conFacParam);	if (responseConFac != null) {	pt.setResponseConnectionFactory(responseConFac);	}	String consumerExchange = AMQPTransportUtils.getOptionalStringParameter( AMQPTransportConstant.PARAMETER_BIND_EXCHANGE, svcParam, conFacParam);	if (consumerExchange != null) {	if (exchangeName != null && !consumerExchange.equals(exchangeName)) {	
possible configuration error exchange name is set to and consumer s exchange name is set to 

pt.setScheduledTaskDelay(delay.intValue());	}	} catch (AMQPTransportException e) {	throw new AxisFault("Could not assign the scheduled task delay value", e);	}	String timeUnit = AMQPTransportUtils.getOptionalStringParameter( AMQPTransportConstant.PARAMETER_SCHEDULED_TASK_TIME_UNIT, svcParam, conFacParam);	if (timeUnit != null) {	pt.setScheduledTaskTimeUnit(getTimeUnit(timeUnit));	}	if (log.isDebugEnabled()) {	
a polling task for the service was produced with following parameters exchange name exchange type exchange durable exchange autodelete is internal exchange consumer exchange routing keys queuename is queue durable is queue restricted is queue auto deleted is blocking mode number of concurrent consumers number of dispatching task 

========================= synapse sample_1048 =========================

public void deleteAll() {	messageStore.clear();	
all messages in message store were deleted 

public void delete(String messageID) {	if(messageID != null) {	MessageContext m =messageStore.remove(messageID);	if (m != null){	
message with id removed from the messagestore 

========================= synapse sample_601 =========================

public void pauseListeners() {	if ((configurationContext != null) && (configurationContext.getAxisConfiguration() != null)) {	Map<String, TransportInDescription> trpIns = configurationContext.getAxisConfiguration().getTransportsIn();	for (TransportInDescription trpIn : trpIns.values()) {	TransportListener trpLst = trpIn.getReceiver();	if (trpLst instanceof ManagementSupport) {	try {	((ManagementSupport) trpLst).pause();	} catch (AxisFault axisFault) {	
error putting transport listener for into maintenence 

public void resumeListeners() {	if ((configurationContext != null) && (configurationContext.getAxisConfiguration() != null)) {	Map<String, TransportInDescription> trpIns = configurationContext.getAxisConfiguration().getTransportsIn();	for (TransportInDescription trpIn : trpIns.values()) {	TransportListener trpLst = trpIn.getReceiver();	if (trpLst instanceof ManagementSupport) {	try {	((ManagementSupport) trpLst).resume();	} catch (AxisFault axisFault) {	
error resuming transport listener for from maintenence 

public void pauseSenders() {	if ((configurationContext != null) && (configurationContext.getAxisConfiguration() != null)) {	Map<String, TransportOutDescription> trpOuts = configurationContext.getAxisConfiguration().getTransportsOut();	for (TransportOutDescription trpOut : trpOuts.values()) {	TransportSender trpSnd = trpOut.getSender();	if (trpSnd instanceof ManagementSupport) {	try {	((ManagementSupport) trpSnd).pause();	} catch (AxisFault axisFault) {	
error pausing transport sender 

public void resumeSenders() {	if ((configurationContext != null) && (configurationContext.getAxisConfiguration() != null)) {	Map<String, TransportOutDescription> trpOuts = configurationContext.getAxisConfiguration().getTransportsOut();	for (TransportOutDescription trpOut : trpOuts.values()) {	TransportSender trpSnd = trpOut.getSender();	if (trpSnd instanceof ManagementSupport) {	try {	((ManagementSupport) trpSnd).resume();	} catch (AxisFault axisFault) {	
error resuming transport sender for from maintenence 

public int getPendingListenerThreadCount() {	int pendingThreads = 0;	Map<String, TransportInDescription> trpIns = configurationContext.getAxisConfiguration().getTransportsIn();	for (TransportInDescription trpIn : trpIns.values()) {	TransportListener trpLst = trpIn.getReceiver();	if (trpLst instanceof ManagementSupport) {	int inUse = ((ManagementSupport) trpLst).getActiveThreadCount();	int inQue = ((ManagementSupport) trpLst).getQueueSize();	if ((inUse + inQue) > 0) {	if (log.isDebugEnabled()) {	
transport listener currently using threads with requests already queued 

public int getPendingSenderThreadCount() {	int pendingThreads = 0;	Map<String, TransportOutDescription> trpOuts = configurationContext.getAxisConfiguration().getTransportsOut();	for (TransportOutDescription trpOut : trpOuts.values()) {	TransportSender trpSnd = trpOut.getSender();	if (trpSnd instanceof ManagementSupport) {	int inUse = ((ManagementSupport) trpSnd).getActiveThreadCount();	int inQue = ((ManagementSupport) trpSnd).getQueueSize();	if ((inUse + inQue) > 0) {	if (log.isDebugEnabled()) {	
transport sender currently using threads with requests already queued 

========================= synapse sample_1623 =========================

public static void convertSOAP11toSOAP12( org.apache.axis2.context.MessageContext axisOutMsgCtx) throws AxisFault {	if(log.isDebugEnabled()) {	
convert to 

OMAttribute attr = (OMAttribute) allAttributes.next();	if(attr.getNamespace() != null && SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals( attr.getNamespace().getNamespaceURI())) {	String attrName = attr.getLocalName();	if(SOAP_ATR_ACTOR.equals(attrName)) {	OMAttribute newAtr = omNode.getOMFactory().createOMAttribute( SOAP_ATR_ROLE, newEnvelope.getNamespace(), attr.getAttributeValue());	newSOAPHeader.addAttribute(newAtr);	} else if(SOAP_ATR_MUST_UNDERSTAND.equals(attrName)) {	boolean isMustUnderstand = soapHeader.getMustUnderstand();	newSOAPHeader.setMustUnderstand(isMustUnderstand);	} else {	
removed unsupported attribute from soap namespace when converting to soap 

public static void convertSOAP12toSOAP11( org.apache.axis2.context.MessageContext axisOutMsgCtx) throws AxisFault {	if (log.isDebugEnabled()) {	
convert to 

OMAttribute attr = (OMAttribute) allAttributes.next();	if (attr.getNamespace() != null && SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals( attr.getNamespace().getNamespaceURI())) {	String attrName = attr.getLocalName();	if (SOAP_ATR_ROLE.equals(attrName)) {	OMAttribute newAtr = omNode.getOMFactory().createOMAttribute( SOAP_ATR_ACTOR, newEnvelope.getNamespace(), attr.getAttributeValue());	newSOAPHeader.addAttribute(newAtr);	} else if(SOAP_ATR_MUST_UNDERSTAND.equals(attrName)) {	boolean isMustUnderstand = soapHeaderBlock.getMustUnderstand();	newSOAPHeader.setMustUnderstand(isMustUnderstand);	} else {	
removed unsupported attribute from soap namespace when converting to soap 

private static QName getMappingSOAP12Code(QName soap11Code) {	if (S11_FAULTCODE_VERSIONMISMATCH.equals(soap11Code)) {	return S12_FAULTCODE_VERSIONMISMATCH;	} else if (S11_FAULTCODE_MUSTUNDERSTAND.equals(soap11Code)) {	return S12_FAULTCODE_MUSTUNDERSTAND;	} else if (S11_FAULTCODE_CLIENT.equals(soap11Code)) {	return S12_FAULTCODE_SENDER;	} else if (S11_FAULTCODE_SERVER.equals(soap11Code)) {	return S12_FAULTCODE_RECEIVER;	} else {	
an unidentified faultcode encountered returning a blank qname 

private static QName getMappingSOAP11Code(QName soap12Code) {	if (S12_FAULTCODE_VERSIONMISMATCH.equals(soap12Code)) {	return S11_FAULTCODE_VERSIONMISMATCH;	} else if (S12_FAULTCODE_MUSTUNDERSTAND.equals(soap12Code)) {	return S11_FAULTCODE_MUSTUNDERSTAND;	} else if (S12_FAULTCODE_SENDER.equals(soap12Code)) {	return S11_FAULTCODE_SERVER;	} else if (S12_FAULTCODE_RECEIVER.equals(soap12Code)) {	return S11_FAULTCODE_SERVER;	} else if (S12_FAULTCODE_DATAENCODINGUNKNOWN.equals(soap12Code)) {	
there is no matching code value for fault code dataencodingunknown returning a blank qname 

return S11_FAULTCODE_VERSIONMISMATCH;	} else if (S12_FAULTCODE_MUSTUNDERSTAND.equals(soap12Code)) {	return S11_FAULTCODE_MUSTUNDERSTAND;	} else if (S12_FAULTCODE_SENDER.equals(soap12Code)) {	return S11_FAULTCODE_SERVER;	} else if (S12_FAULTCODE_RECEIVER.equals(soap12Code)) {	return S11_FAULTCODE_SERVER;	} else if (S12_FAULTCODE_DATAENCODINGUNKNOWN.equals(soap12Code)) {	return new QName("");	} else {	
an unidentified faultcode encountered returning a blank qname 

========================= synapse sample_197 =========================

public boolean loadConfiguration(ParameterInclude params) throws AxisFault {	fileURI = ParamUtils.getOptionalParam(params, VFSConstants.TRANSPORT_FILE_FILE_URI);	if (fileURI == null) {	
required parameter is missing in the proxy service configuration 

========================= synapse sample_894 =========================

Object o = localRegistry.get(key);	if (o != null && o instanceof Entry) {	Entry entry = (Entry) o;	if (entry.isDynamic()) {	if (entry.isCached() && !entry.isExpired()) {	return entry.getValue();	} else if (registry != null) {	o = registry.getResource(entry);	} else {	if (log.isDebugEnabled()) {	
will not evaluate the value of the remote entry with a key because the registry is not available 

public void destroy() {	if (log.isDebugEnabled()) {	
destroying the synapse configuration 

public void init(SynapseEnvironment se) {	if (log.isDebugEnabled()) {	
initializing the synapse configuration 

========================= synapse sample_3537 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
endpoint deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	Endpoint ep = EndpointFactory.getEndpointFromElement(artifactConfig, false, properties);	if (ep != null) {	ep.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
endpoint named has been built from the file 

if (log.isDebugEnabled()) {	}	try {	Endpoint ep = EndpointFactory.getEndpointFromElement(artifactConfig, false, properties);	if (ep != null) {	ep.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	ep.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	
initialized the endpoint 

Endpoint ep = EndpointFactory.getEndpointFromElement(artifactConfig, false, properties);	if (ep != null) {	ep.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	ep.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEndpoint(ep.getName(), ep);	if (log.isDebugEnabled()) {	
endpoint deployment from file completed 

if (ep != null) {	ep.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	ep.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEndpoint(ep.getName(), ep);	if (log.isDebugEnabled()) {	}	
endpoint named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
endpoint update from file has started 

if (log.isDebugEnabled()) {	}	try {	Endpoint ep = EndpointFactory.getEndpointFromElement(artifactConfig, false, properties);	if (ep == null) {	handleSynapseArtifactDeploymentError("Endpoint update failed. The artifact " + "defined in the file: " + fileName + " is not a valid endpoint.");	return null;	}	ep.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	
endpoint has been built from the file 

ep.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	ep.init(getSynapseEnvironment());	Endpoint existingEp = getSynapseConfiguration().getDefinedEndpoints().get(existingArtifactName);	if (existingArtifactName.equals(ep.getName())) {	getSynapseConfiguration().updateEndpoint(existingArtifactName, ep);	} else {	getSynapseConfiguration().addEndpoint(ep.getName(), ep);	getSynapseConfiguration().removeEndpoint(existingArtifactName);	
endpoint has been undeployed 

if (log.isDebugEnabled()) {	}	ep.init(getSynapseEnvironment());	Endpoint existingEp = getSynapseConfiguration().getDefinedEndpoints().get(existingArtifactName);	if (existingArtifactName.equals(ep.getName())) {	getSynapseConfiguration().updateEndpoint(existingArtifactName, ep);	} else {	getSynapseConfiguration().addEndpoint(ep.getName(), ep);	getSynapseConfiguration().removeEndpoint(existingArtifactName);	}	
endpoint has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
endpoint undeployment of the endpoint named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	Endpoint ep = getSynapseConfiguration().getDefinedEndpoints().get(artifactName);	if (ep != null) {	getSynapseConfiguration().removeEndpoint(artifactName);	if (log.isDebugEnabled()) {	
destroying the endpoint named 

if (log.isDebugEnabled()) {	}	try {	Endpoint ep = getSynapseConfiguration().getDefinedEndpoints().get(artifactName);	if (ep != null) {	getSynapseConfiguration().removeEndpoint(artifactName);	if (log.isDebugEnabled()) {	}	ep.destroy();	if (log.isDebugEnabled()) {	
endpoint undeployment of the endpoint named completed 

}	try {	Endpoint ep = getSynapseConfiguration().getDefinedEndpoints().get(artifactName);	if (ep != null) {	getSynapseConfiguration().removeEndpoint(artifactName);	if (log.isDebugEnabled()) {	}	ep.destroy();	if (log.isDebugEnabled()) {	}	
endpoint named has been undeployed 

try {	Endpoint ep = getSynapseConfiguration().getDefinedEndpoints().get(artifactName);	if (ep != null) {	getSynapseConfiguration().removeEndpoint(artifactName);	if (log.isDebugEnabled()) {	}	ep.destroy();	if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
endpoint has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the endpoint with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	Endpoint ep = getSynapseConfiguration().getDefinedEndpoints().get(artifactName);	OMElement epElem = EndpointSerializer.getElementFromEndpoint(ep);	if (ep.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.ENDPOINTS_DIR + File.separator + ep.getFileName();	writeToFile(epElem, fileName);	if (log.isDebugEnabled()) {	
restoring the endpoint with name completed 

if (log.isDebugEnabled()) {	}	try {	Endpoint ep = getSynapseConfiguration().getDefinedEndpoints().get(artifactName);	OMElement epElem = EndpointSerializer.getElementFromEndpoint(ep);	if (ep.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.ENDPOINTS_DIR + File.separator + ep.getFileName();	writeToFile(epElem, fileName);	if (log.isDebugEnabled()) {	}	
endpoint named has been restored 

========================= synapse sample_178 =========================

public void testDynamicStaticKeys() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to dynamic and static keys 

========================= synapse sample_2263 =========================

public boolean mediate(SynapseContext synCtx) {	
mediate 

========================= synapse sample_2799 =========================

public static NHttpClientConnection getConnection(String host, int port) {	String key = host + ":" + Integer.toString(port);	List connections = (List) connMap.get(key);	if (connections == null) {	
no connections available for reuse 

public static NHttpClientConnection getConnection(String host, int port) {	String key = host + ":" + Integer.toString(port);	List connections = (List) connMap.get(key);	if (connections == null) {	return null;	} else {	NHttpClientConnection conn = null;	while (!connections.isEmpty()) {	conn = (NHttpClientConnection) connections.remove(0);	if (conn.isOpen()) {	
a connection to host on port is available in the pool and will be reused 

List connections = (List) connMap.get(key);	if (connections == null) {	return null;	} else {	NHttpClientConnection conn = null;	while (!connections.isEmpty()) {	conn = (NHttpClientConnection) connections.remove(0);	if (conn.isOpen()) {	return conn;	} else {	
closing stale connection 

public static void release(NHttpClientConnection conn) {	HttpHost host = (HttpHost) conn.getContext().getAttribute( HttpExecutionContext.HTTP_TARGET_HOST);	String key = host.getHostName() + ":" + Integer.toString(host.getPort());	List connections = (List) connMap.get(key);	if (connections == null) {	connections = Collections.synchronizedList(new LinkedList());	connMap.put(key, connections);	}	connections.add(conn);	
released a connection to host on port to the connection pool of current size 

========================= synapse sample_3405 =========================

public static void convertMTOM_TO_Base64(AXIOMXPath xpath, String mimeType, MessageContext synCtx) throws SynapseException{	
converting mtom to 

public static void convertBase64_TO_MTOM(AXIOMXPath xpath, String mimeType, MessageContext synCtx) throws SynapseException{	
converting to mtom 

========================= synapse sample_3110 =========================

OMNamespace omNamespace = OMAbstractFactory.getOMFactory().createOMNamespace(WSS_WSSECURITY_SECEXT_1_0_XSD, WSSE);	SOAPHeaderBlock soapBlockingHeader = OMAbstractFactory.getSOAP12Factory().createSOAPHeaderBlock("Security",omNamespace);	OMElement securityHeader = (OMElement) element.getFirstOMChild();	if (securityHeader != null) {	while (securityHeader.getChildElements().hasNext()) {	soapBlockingHeader.addChild((OMNode) securityHeader.getChildElements().next());	}	messageContext.getEnvelope().getHeader().addChild(soapBlockingHeader);	}	} catch (Exception e) {	
error while executing the message at relaysecurity handler 

private void build(MessageContext messageContext) {	try {	RelayUtils.buildMessage(messageContext, false);	} catch (Exception e) {	
error while executing the message at relaysecurity handler 

========================= synapse sample_2351 =========================

XMLStreamReader parser = XMLInputFactory.newInstance(). createXMLStreamReader(urlc.getInputStream());	StAXOMBuilder builder = new StAXOMBuilder(parser);	OMElement omElem =  builder.getDocumentElement();	omElem.build();	if (xmlToObject != null) {	return xmlToObject.getObjectFromOMNode(omElem);	} else {	return omElem;	}	} catch (XMLStreamException e) {	
content at url is non xml 

========================= synapse sample_3239 =========================

public void send(MessageContext synMessageContext) {	if (log.isDebugEnabled()) {	
start load balance endpoint 

boolean isClusteringEnable = false;	org.apache.axis2.context.MessageContext axisMC = ((Axis2MessageContext) synMessageContext).getAxis2MessageContext();	ConfigurationContext cc = axisMC.getConfigurationContext();	ClusterManager clusterManager = cc.getAxisConfiguration().getClusterManager();	if (clusterManager != null && clusterManager.getContextManager() != null) {	isClusteringEnable = true;	}	String endPointName = this.getName();	if (endPointName == null) {	if (log.isDebugEnabled() && isClusteringEnable) {	
in a clustering environment the endpoint name should be specified even for anonymous endpoints otherwise the clustering would not be functioned correctly if there are more than one anonymous endpoints 

boolean active = endpointContext.isActive();	if (!active && endpoints != null) {	for (Endpoint endpoint : endpoints) {	if (endpoint.isActive(synMessageContext)) {	active = true;	endpointContext.setActive(true);	}	}	}	if (log.isDebugEnabled()) {	
endpoint is in state 

========================= synapse sample_4006 =========================

public void initialize(boolean isClusteringEnable, ConfigurationContext cc) {	if (!initialized) {	if (log.isDebugEnabled()) {	
initializing salsessions instance environment clustered local 

public void registerChildren(Endpoint endpoint, List<Endpoint> endpoints) {	if (isClustered) {	String endpointName = endpoint.getName();	validateInput(endpointName);	if (log.isDebugEnabled()) {	
registering endpoints of 

public void updateSession(MessageContext synCtx, String sessionID) {	if (sessionID == null || "".equals(sessionID)) {	if (log.isDebugEnabled()) {	
cannot find session id returning null 

if (log.isDebugEnabled()) {	}	return;	}	boolean createSession = false;	SessionInformation oldSession = (SessionInformation) synCtx.getProperty( SynapseConstants.PROP_SAL_CURRENT_SESSION_INFORMATION);	List<Endpoint> endpoints = null;	Member currentMember = null;	if (oldSession == null) {	if (log.isDebugEnabled()) {	
going to create a new session with id 

if (oldSession == null) {	if (log.isDebugEnabled()) {	}	endpoints = (List<Endpoint>) synCtx.getProperty( SynapseConstants.PROP_SAL_ENDPOINT_ENDPOINT_LIST);	currentMember = (Member) synCtx.getProperty( SynapseConstants.PROP_SAL_ENDPOINT_CURRENT_MEMBER);	createSession = true;	} else {	String oldSessionID = oldSession.getId();	if (!sessionID.equals(oldSessionID)) {	if (log.isDebugEnabled()) {	
renew the session previous session id new session id 

if (log.isDebugEnabled()) {	}	removeSession(oldSessionID);	endpoints = oldSession.getEndpointList();	currentMember = oldSession.getMember();	createSession = true;	} else {	SessionInformation information = getSessionInformation(oldSessionID);	if (information == null) {	if (log.isDebugEnabled()) {	
recovering lost session information for session id 

} else {	SessionInformation information = getSessionInformation(oldSessionID);	if (information == null) {	if (log.isDebugEnabled()) {	}	endpoints = oldSession.getEndpointList();	currentMember = oldSession.getMember();	createSession = true;	} else {	if (log.isDebugEnabled()) {	
session with id is still live 

}	}	if (createSession) {	SessionInformation newInformation;	if(currentMember == null){	newInformation = createSessionInformation(synCtx, sessionID, endpoints);	} else {	newInformation = createSessionInformation(synCtx, sessionID, currentMember);	}	if (log.isDebugEnabled()) {	
establishing a session with id and it s endpoint sequence 

public SessionInformation getSession(String sessionID) {	if (sessionID == null || "".equals(sessionID)) {	if (log.isDebugEnabled()) {	
cannot find session id returning null 

public SessionInformation getSession(String sessionID) {	if (sessionID == null || "".equals(sessionID)) {	if (log.isDebugEnabled()) {	}	return null;	}	if (log.isDebugEnabled()) {	
retrieving the endpoint from the session id 

if (sessionID == null || "".equals(sessionID)) {	if (log.isDebugEnabled()) {	}	return null;	}	if (log.isDebugEnabled()) {	}	SessionInformation information = getSessionInformation(sessionID);	if (information == null) {	if (log.isDebugEnabled()) {	
session information cannot be found for session id 

if (log.isDebugEnabled()) {	}	SessionInformation information = getSessionInformation(sessionID);	if (information == null) {	if (log.isDebugEnabled()) {	}	return null;	}	if (information.isExpired()) {	if (log.isDebugEnabled()) {	
session has been expired for session with id 

public List<Endpoint> getChildEndpoints(SessionInformation information) {	List<Endpoint> endpoints;	if (isClustered) {	endpoints = getEndpoints(information.getPath(), information.getRootEndpointName());	} else {	endpoints = information.getEndpointList();	}	if (log.isDebugEnabled()) {	
retrieving endpoint sequence for session 

public void removeSession(String sessionId) {	if (sessionId == null || "".equals(sessionId)) {	if (log.isDebugEnabled()) {	
session id cannot be found the session will not be removed 

public void removeSession(String sessionId) {	if (sessionId == null || "".equals(sessionId)) {	if (log.isDebugEnabled()) {	}	return;	}	if (log.isDebugEnabled()) {	
removing the session with the session id 

try {	if (isClustered) {	List<String> toBeRemoved = new ArrayList<String>();	for (Iterator<String> props = configCtx.getPropertyNames(); props.hasNext();) {	Object name = props.next();	if (name instanceof String && ((String) name).startsWith(SESSION_IDS)) {	String key = (String) name;	SessionInformation info = (SessionInformation) configCtx.getProperty(key);	if (info != null && info.isExpired()) {	if (log.isDebugEnabled()) {	
clustered environment expired session with id 

SessionInformation info = (SessionInformation) configCtx.getProperty(key);	if (info != null && info.isExpired()) {	if (log.isDebugEnabled()) {	}	toBeRemoved.add(key);	}	}	}	if (!toBeRemoved.isEmpty()) {	if (log.isDebugEnabled()) {	
clearing expired sessions 

for (String key : toBeRemoved) {	Replicator.removeAndReplicateState(key, configCtx);	}	}	} else {	List<String> toBeRemoved = new ArrayList<String>();	for (SessionInformation information : establishedSessions.values()) {	if (information != null && information.isExpired()) {	String id = information.getId();	if (log.isDebugEnabled()) {	
expired session with id 

for (SessionInformation information : establishedSessions.values()) {	if (information != null && information.isExpired()) {	String id = information.getId();	if (log.isDebugEnabled()) {	}	toBeRemoved.add(id);	}	}	if (!toBeRemoved.isEmpty()) {	if (log.isDebugEnabled()) {	
clearing expired sessions 

toBeRemoved.add(id);	}	}	if (!toBeRemoved.isEmpty()) {	if (log.isDebugEnabled()) {	}	establishedSessions.keySet().removeAll(toBeRemoved);	}	}	} catch (Throwable ignored) {	
ignored error clearing sessions error 

public void reset() {	if (!initialized) {	return;	}	
clearing all states 

private List<Endpoint> getEndpoints(List<String> endpointNames, String root) {	if (endpointNames == null || endpointNames.isEmpty()) {	handleException("Invalid session - path cannot be null.");	}	if (log.isDebugEnabled()) {	
retrieving endpoint sequence for path 

private SessionInformation createSessionInformation(MessageContext synCtx, String id, List<Endpoint> endpoints) {	if (endpoints == null || endpoints.isEmpty()) {	handleException("Invalid request to create sessions . Cannot find a endpoint sequence.");	}	if (log.isDebugEnabled()) {	
creating a session information for given session id with endpoint sequence 

expireTimeWindow = sessionsTimeout;	} else if (expireTimeWindow > sessionsTimeout) {	expireTimeWindow = sessionsTimeout;	}	}	}	if (expireTimeWindow == -1) {	expireTimeWindow = synCtx.getConfiguration().getProperty( SynapseConstants.PROP_SAL_ENDPOINT_DEFAULT_SESSION_TIMEOUT, SynapseConstants.SAL_ENDPOINTS_DEFAULT_SESSION_TIMEOUT);	}	if (log.isDebugEnabled()) {	
for session with id expiry time interval 

private SessionInformation createSessionInformation(MessageContext synCtx, String id, Member currentMember) {	if (currentMember == null) {	handleException("Invalid request to create sessions.");	}	if (log.isDebugEnabled()) {	
creating a session information for given session id with member host port 

expireTimeWindow = sessionsTimeout;	} else if (expireTimeWindow > sessionsTimeout) {	expireTimeWindow = sessionsTimeout;	}	}	}	if (expireTimeWindow == -1) {	expireTimeWindow = synCtx.getConfiguration().getProperty( SynapseConstants.PROP_SAL_ENDPOINT_DEFAULT_SESSION_TIMEOUT, SynapseConstants.SAL_ENDPOINTS_DEFAULT_SESSION_TIMEOUT);	}	if (log.isDebugEnabled()) {	
for session with id expiry time interval 

========================= synapse sample_1654 =========================

return !("repo".equalsIgnoreCase(optionType) || "conf" .equalsIgnoreCase(optionType));	}	});	if ((invalidOptionsList.size()>0)||(args.length>4)) {	printUsage();	return;	}	Map optionsMap = optionsParser.getAllOptions();	CommandLineOption repoOption = (CommandLineOption) optionsMap .get("repo");	CommandLineOption confOption = (CommandLineOption) optionsMap .get("conf");	
simpleaxisserver starting 

});	if ((invalidOptionsList.size()>0)||(args.length>4)) {	printUsage();	return;	}	Map optionsMap = optionsParser.getAllOptions();	CommandLineOption repoOption = (CommandLineOption) optionsMap .get("repo");	CommandLineOption confOption = (CommandLineOption) optionsMap .get("conf");	if (repoOption != null) {	repoLocation = repoOption.getOptionValue();	
simpleaxisserver using the repository 

if (confOption != null) {	confLocation = confOption.getOptionValue();	System.out .println("[SimpleAxisServer] Using the Axis2 Configuration File" + new File(confLocation).getAbsolutePath());	}	try {	ConfigurationContext configctx = ConfigurationContextFactory .createConfigurationContextFromFileSystem(repoLocation, confLocation);	configurePort(configctx);	ListenerManager listenerManager =  new ListenerManager();	listenerManager.init(configctx);	listenerManager.start();	
simpleaxisserver started 

confLocation = confOption.getOptionValue();	System.out .println("[SimpleAxisServer] Using the Axis2 Configuration File" + new File(confLocation).getAbsolutePath());	}	try {	ConfigurationContext configctx = ConfigurationContextFactory .createConfigurationContextFromFileSystem(repoLocation, confLocation);	configurePort(configctx);	ListenerManager listenerManager =  new ListenerManager();	listenerManager.init(configctx);	listenerManager.start();	} catch (Throwable t) {	
simpleaxisserver shutting down error starting simpleaxisserver 

private static void configurePort(ConfigurationContext configCtx) {	TransportInDescription trsIn = (TransportInDescription) configCtx.getAxisConfiguration().getTransportsIn().get(new QName("http"));	if(trsIn != null) {	String port = System.getProperty("port");	if(port != null) {	try {	new Integer(port);	trsIn.getParameter("port").setValue(port);	} catch (NumberFormatException e) {	
given port is not a valid integer using for port 

========================= synapse sample_3393 =========================

public void initialize(boolean isClusteringEnable, ConfigurationContext cc) {	if (!initialized) {	if (log.isDebugEnabled()) {	
initializing salsessions instance environment clustered local 

public void registerChildren(Endpoint endpoint, List<Endpoint> endpoints) {	if (isClustered) {	String endpointName = endpoint.getName();	validateInput(endpointName);	if (log.isDebugEnabled()) {	
registering endpoints of 

public void updateSession(MessageContext synCtx, String sessionID) {	if (sessionID == null || "".equals(sessionID)) {	if (log.isDebugEnabled()) {	
cannot find session id returning null 

if (log.isDebugEnabled()) {	}	return;	}	boolean createSession = false;	SessionInformation oldSession = (SessionInformation) synCtx.getProperty( SynapseConstants.PROP_SAL_CURRENT_SESSION_INFORMATION);	List<Endpoint> endpoints = null;	Member currentMember = null;	if (oldSession == null) {	if (log.isDebugEnabled()) {	
going to create a new session with id 

if (oldSession == null) {	if (log.isDebugEnabled()) {	}	endpoints = (List<Endpoint>) synCtx.getProperty( SynapseConstants.PROP_SAL_ENDPOINT_ENDPOINT_LIST);	currentMember = (Member) synCtx.getProperty( SynapseConstants.PROP_SAL_ENDPOINT_CURRENT_MEMBER);	createSession = true;	} else {	String oldSessionID = oldSession.getId();	if (!sessionID.equals(oldSessionID)) {	if (log.isDebugEnabled()) {	
renew the session previous session id new session id 

if (log.isDebugEnabled()) {	}	removeSession(oldSessionID);	endpoints = oldSession.getEndpointList();	currentMember = oldSession.getMember();	createSession = true;	} else {	SessionInformation information = getSessionInformation(oldSessionID);	if (information == null) {	if (log.isDebugEnabled()) {	
recovering lost session information for session id 

} else {	SessionInformation information = getSessionInformation(oldSessionID);	if (information == null) {	if (log.isDebugEnabled()) {	}	endpoints = oldSession.getEndpointList();	currentMember = oldSession.getMember();	createSession = true;	} else {	if (log.isDebugEnabled()) {	
session with id is still live 

}	}	if (createSession) {	SessionInformation newInformation;	if(currentMember == null){	newInformation = createSessionInformation(synCtx, sessionID, endpoints);	} else {	newInformation = createSessionInformation(synCtx, sessionID, currentMember);	}	if (log.isDebugEnabled()) {	
establishing a session with id and it s endpoint sequence 

public SessionInformation getSession(String sessionID) {	if (sessionID == null || "".equals(sessionID)) {	if (log.isDebugEnabled()) {	
cannot find session id returning null 

public SessionInformation getSession(String sessionID) {	if (sessionID == null || "".equals(sessionID)) {	if (log.isDebugEnabled()) {	}	return null;	}	if (log.isDebugEnabled()) {	
retrieving the endpoint from the session id 

if (sessionID == null || "".equals(sessionID)) {	if (log.isDebugEnabled()) {	}	return null;	}	if (log.isDebugEnabled()) {	}	SessionInformation information = getSessionInformation(sessionID);	if (information == null) {	if (log.isDebugEnabled()) {	
session information cannot be found for session id 

if (log.isDebugEnabled()) {	}	SessionInformation information = getSessionInformation(sessionID);	if (information == null) {	if (log.isDebugEnabled()) {	}	return null;	}	if (information.isExpired()) {	if (log.isDebugEnabled()) {	
session has been expired for session with id 

public List<Endpoint> getChildEndpoints(SessionInformation information) {	List<Endpoint> endpoints;	if (isClustered) {	endpoints = getEndpoints(information.getPath(), information.getRootEndpointName());	} else {	endpoints = information.getEndpointList();	}	if (log.isDebugEnabled()) {	
retrieving endpoint sequence for session 

public void removeSession(String sessionId) {	if (sessionId == null || "".equals(sessionId)) {	if (log.isDebugEnabled()) {	
session id cannot be found the session will not be removed 

public void removeSession(String sessionId) {	if (sessionId == null || "".equals(sessionId)) {	if (log.isDebugEnabled()) {	}	return;	}	if (log.isDebugEnabled()) {	
removing the session with the session id 

try {	if (isClustered) {	List<String> toBeRemoved = new ArrayList<String>();	for (Iterator<String> props = configCtx.getPropertyNames(); props.hasNext();) {	Object name = props.next();	if (name instanceof String && ((String) name).startsWith(SESSION_IDS)) {	String key = (String) name;	SessionInformation info = (SessionInformation) configCtx.getProperty(key);	if (info != null && info.isExpired()) {	if (log.isDebugEnabled()) {	
clustered environment expired session with id 

SessionInformation info = (SessionInformation) configCtx.getProperty(key);	if (info != null && info.isExpired()) {	if (log.isDebugEnabled()) {	}	toBeRemoved.add(key);	}	}	}	if (!toBeRemoved.isEmpty()) {	if (log.isDebugEnabled()) {	
clearing expired sessions 

for (String key : toBeRemoved) {	Replicator.removeAndReplicateState(key, configCtx);	}	}	} else {	List<String> toBeRemoved = new ArrayList<String>();	for (SessionInformation information : establishedSessions.values()) {	if (information != null && information.isExpired()) {	String id = information.getId();	if (log.isDebugEnabled()) {	
expired session with id 

for (SessionInformation information : establishedSessions.values()) {	if (information != null && information.isExpired()) {	String id = information.getId();	if (log.isDebugEnabled()) {	}	toBeRemoved.add(id);	}	}	if (!toBeRemoved.isEmpty()) {	if (log.isDebugEnabled()) {	
clearing expired sessions 

toBeRemoved.add(id);	}	}	if (!toBeRemoved.isEmpty()) {	if (log.isDebugEnabled()) {	}	establishedSessions.keySet().removeAll(toBeRemoved);	}	}	} catch (Throwable ignored) {	
ignored error clearing sessions error 

public void reset() {	if (!initialized) {	return;	}	
clearing all states 

private List<Endpoint> getEndpoints(List<String> endpointNames, String root) {	if (endpointNames == null || endpointNames.isEmpty()) {	handleException("Invalid session - path cannot be null.");	}	if (log.isDebugEnabled()) {	
retrieving endpoint sequence for path 

private SessionInformation createSessionInformation(MessageContext synCtx, String id, List<Endpoint> endpoints) {	if (endpoints == null || endpoints.isEmpty()) {	handleException("Invalid request to create sessions . Cannot find a endpoint sequence.");	}	if (log.isDebugEnabled()) {	
creating a session information for given session id with endpoint sequence 

expireTimeWindow = sessionsTimeout;	} else if (expireTimeWindow > sessionsTimeout) {	expireTimeWindow = sessionsTimeout;	}	}	}	if (expireTimeWindow == -1) {	expireTimeWindow = synCtx.getConfiguration().getProperty( SynapseConstants.PROP_SAL_ENDPOINT_DEFAULT_SESSION_TIMEOUT, SynapseConstants.SAL_ENDPOINTS_DEFAULT_SESSION_TIMEOUT);	}	if (log.isDebugEnabled()) {	
for session with id expiry time interval 

private SessionInformation createSessionInformation(MessageContext synCtx, String id, Member currentMember) {	if (currentMember == null) {	handleException("Invalid request to create sessions.");	}	if (log.isDebugEnabled()) {	
creating a session information for given session id with member host port 

expireTimeWindow = sessionsTimeout;	} else if (expireTimeWindow > sessionsTimeout) {	expireTimeWindow = sessionsTimeout;	}	}	}	if (expireTimeWindow == -1) {	expireTimeWindow = synCtx.getConfiguration().getProperty( SynapseConstants.PROP_SAL_ENDPOINT_DEFAULT_SESSION_TIMEOUT, SynapseConstants.SAL_ENDPOINTS_DEFAULT_SESSION_TIMEOUT);	}	if (log.isDebugEnabled()) {	
for session with id expiry time interval 

========================= synapse sample_226 =========================

public void init(SynapseEnvironment se) {	if (resources.isEmpty()) {	handleException("The API: " + name + " has been configured without " + "any resource definitions");	}	
initializing api 

public void destroy() {	
destroying api 

========================= synapse sample_2097 =========================

public void completeAggregate(Aggregate aggregate) {	if (log.isDebugEnabled()) {	
aggregation completed or timed out 

public void completeAggregate(Aggregate aggregate) {	if (log.isDebugEnabled()) {	}	aggregate.cancel();	MessageContext newSynCtx = getAggregatedMessage(aggregate);	if (newSynCtx == null) {	
an aggregation of messages timed out with no aggregated messages 

private MessageContext getAggregatedMessage(Aggregate aggregate) {	MessageContext newCtx = null;	Iterator<MessageContext> itr = aggregate.getMessages().iterator();	while (itr.hasNext()) {	MessageContext synCtx = itr.next();	if (newCtx == null) {	newCtx = synCtx;	if (log.isDebugEnabled()) {	
generating aggregated message from 

Iterator<MessageContext> itr = aggregate.getMessages().iterator();	while (itr.hasNext()) {	MessageContext synCtx = itr.next();	if (newCtx == null) {	newCtx = synCtx;	if (log.isDebugEnabled()) {	}	} else {	try {	if (log.isDebugEnabled()) {	
merging message using xpath 

if (newCtx == null) {	newCtx = synCtx;	if (log.isDebugEnabled()) {	}	} else {	try {	if (log.isDebugEnabled()) {	}	EIPUtils.enrichEnvelope( newCtx.getEnvelope(), synCtx.getEnvelope(), aggregationExpression);	if (log.isDebugEnabled()) {	
merged result 

========================= synapse sample_3686 =========================

synapseOutMessageContext.setResponse(true);	Iterator iter = synapseInMessageContext.getCorrelationPropertyKeySet().iterator();	while (iter.hasNext()) {	Object key = iter.next();	synapseOutMessageContext.setProperty( (String) key, synapseInMessageContext.getCorrelationProperty((String) key));	}	if (synapseOutMessageContext.getEnvelope().getBody().hasFault()) {	SOAPFault fault = synapseOutMessageContext.getEnvelope().getBody().getFault();	log.warn("Synapse received a SOAP fault from : " + synapseInMessageContext.getTo() + (fault.getNode() != null ? " Node : " + fault.getNode().getNodeValue() : "") + (fault.getReason() != null ? " Reason : " + fault.getReason().getFirstSOAPText() : "") + (fault.getCode() != null ? " Code : " + fault.getCode().getValue() : ""));	}	
processing incoming message 

========================= synapse sample_2994 =========================

public void testScriptMediationWithJS() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to the script mediator using js scripts 

========================= synapse sample_2243 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start class mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	if (synLog.isTraceOrDebugEnabled()) {	
invoking mediate 

}	}	if (synLog.isTraceOrDebugEnabled()) {	}	boolean result;	try {	result = mediator.mediate(synCtx);	} catch (Exception e) {	throw new SynapseException("Error occured in the mediation of the class mediator", e);	}	
end class mediator 

public void destroy() {	if (log.isDebugEnabled()) {	
destroying class mediator instance for 

public void init(SynapseEnvironment se) {	if (log.isDebugEnabled()) {	
initializing class mediator instance for 

public void init(SynapseEnvironment se) {	if (log.isDebugEnabled()) {	}	if (mediator == null) {	
init called before mediator reference set 

========================= synapse sample_508 =========================

public static void serializeConfiguration(SynapseConfiguration synCfg, OutputStream outputStream) throws XMLStreamException {	if (log.isDebugEnabled()) {	
serializing the xml configuration to the output stream 

========================= synapse sample_1879 =========================

public void writeTo(MessageContext msgCtxt, OMOutputFormat format, OutputStream out, boolean preserve) throws AxisFault {	if (log.isDebugEnabled()) {	
start writing the message to outputstream 

outputStream.flush();	outputStream.close();	} catch (IOException e) {	handleException("Couldn't get the bytes from the HessianDataSource", e);	}	} else {	handleException("Unable to find the hessian content in the payload");	}	}	if (log.isDebugEnabled()) {	
writing message as a hessian message is successful 

========================= synapse sample_4378 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
synapse import deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	SynapseImport synImport = SynapseImportFactory.createImport(artifactConfig, properties);	String synImportQualfiedName = LibDeployerUtils.getQualifiedName(synImport);	SynapseImport existingImport = getSynapseConfiguration().getSynapseImports().get(synImportQualfiedName);	if (existingImport != null) {	
synapse import with the name already exists could not load multiple imports of same type 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	SynapseImport synImport = SynapseImportFactory.createImport(artifactConfig, properties);	String synImportQualfiedName = LibDeployerUtils.getQualifiedName(synImport);	SynapseImport existingImport = getSynapseConfiguration().getSynapseImports().get(synImportQualfiedName);	if (existingImport != null) {	String backedUp = backupFile(new File(fileName));	
synapse import with the name is now backed up in 

String backedUp = backupFile(new File(fileName));	return null;	} else {	if (synImport != null) {	synImport.setFileName((new File(fileName)).getName());	getSynapseConfiguration().addSynapseImport(synImportQualfiedName, synImport);	Library synLib = getSynapseConfiguration().getSynapseLibraries() .get(synImportQualfiedName);	if (synLib != null) {	LibDeployerUtils.loadLibArtifacts(synImport, synLib);	}	
synapse library import named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
synapse import deployment from file started 

if (log.isDebugEnabled()) {	}	try {	SynapseImport synImport = SynapseImportFactory.createImport(artifactConfig, properties);	String synImportQualfiedName = LibDeployerUtils.getQualifiedName(synImport);	if (synImport == null) {	handleSynapseArtifactDeploymentError("Synapse Import update failed. The artifact " + "defined in the file: " + fileName + " is not a valid import.");	return null;	}	if (log.isDebugEnabled()) {	
synapse import has been built from the file 

if (log.isDebugEnabled()) {	}	if (existingArtifactName.equals(synImportQualfiedName)) {	synImport.setFileName((new File(fileName)).getName());	getSynapseConfiguration().addSynapseImport(synImportQualfiedName, synImport);	Library synLib = getSynapseConfiguration().getSynapseLibraries() .get(synImportQualfiedName);	if (synLib != null) {	synLib.unLoadLibrary();	LibDeployerUtils.loadLibArtifacts(synImport, synLib);	}	
synapse library import named has been deployed from file 

synImport.setFileName((new File(fileName)).getName());	getSynapseConfiguration().addSynapseImport(synImportQualfiedName, synImport);	Library synLib = getSynapseConfiguration().getSynapseLibraries() .get(synImportQualfiedName);	if (synLib != null) {	synLib.unLoadLibrary();	LibDeployerUtils.loadLibArtifacts(synImport, synLib);	}	} else {	SynapseImport existingImport = getSynapseConfiguration().getSynapseImports().get(synImportQualfiedName);	if (existingImport != null) {	
synapse import with the name already exists could not load multiple imports of same type 

getSynapseConfiguration().addSynapseImport(synImportQualfiedName, synImport);	Library synLib = getSynapseConfiguration().getSynapseLibraries() .get(synImportQualfiedName);	if (synLib != null) {	synLib.unLoadLibrary();	LibDeployerUtils.loadLibArtifacts(synImport, synLib);	}	} else {	SynapseImport existingImport = getSynapseConfiguration().getSynapseImports().get(synImportQualfiedName);	if (existingImport != null) {	String backedUp = backupFile(new File(fileName));	
synapse import with the name is now backed up in 

SynapseImport existingImport = getSynapseConfiguration().getSynapseImports().get(synImportQualfiedName);	if (existingImport != null) {	String backedUp = backupFile(new File(fileName));	return null;	}else {	synImport.setFileName((new File(fileName)).getName());	getSynapseConfiguration().addSynapseImport(synImportQualfiedName, synImport);	Library synLib = getSynapseConfiguration().getSynapseLibraries() .get(synImportQualfiedName);	synLib.unLoadLibrary();	LibDeployerUtils.loadLibArtifacts(synImport, synLib);	
synapse library import named has been deployed from file 

String backedUp = backupFile(new File(fileName));	return null;	}else {	synImport.setFileName((new File(fileName)).getName());	getSynapseConfiguration().addSynapseImport(synImportQualfiedName, synImport);	Library synLib = getSynapseConfiguration().getSynapseLibraries() .get(synImportQualfiedName);	synLib.unLoadLibrary();	LibDeployerUtils.loadLibArtifacts(synImport, synLib);	}	}	
synapse import has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
undeployment of the synapse import named started 

if (log.isDebugEnabled()) {	}	try {	SynapseImport undeployingImport = getSynapseConfiguration().getSynapseImports().get(artifactName);	if (undeployingImport != null) {	getSynapseConfiguration().removeSynapseImport(artifactName);	Library synLib = getSynapseConfiguration().getSynapseLibraries().get(artifactName);	if (synLib != null) {	synLib.unLoadLibrary();	}	
synapse import has been undeployed 

}	try {	SynapseImport undeployingImport = getSynapseConfiguration().getSynapseImports().get(artifactName);	if (undeployingImport != null) {	getSynapseConfiguration().removeSynapseImport(artifactName);	Library synLib = getSynapseConfiguration().getSynapseLibraries().get(artifactName);	if (synLib != null) {	synLib.unLoadLibrary();	}	} else {	
synapse import has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the sequence with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	SequenceMediator seq = getSynapseConfiguration().getDefinedSequences().get(artifactName);	OMElement seqElem = MediatorSerializerFinder.getInstance().getSerializer(seq). serializeMediator(null, seq);	if (seq.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.SEQUENCES_DIR + File.separator + seq.getFileName();	writeToFile(seqElem, fileName);	if (log.isDebugEnabled()) {	
restoring the sequence with name completed 

if (log.isDebugEnabled()) {	}	try {	SequenceMediator seq = getSynapseConfiguration().getDefinedSequences().get(artifactName);	OMElement seqElem = MediatorSerializerFinder.getInstance().getSerializer(seq). serializeMediator(null, seq);	if (seq.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.SEQUENCES_DIR + File.separator + seq.getFileName();	writeToFile(seqElem, fileName);	if (log.isDebugEnabled()) {	}	
sequence named has been restored 

========================= synapse sample_1603 =========================

public boolean mediate(SynapseMessage synapseMessageContext) {	try {	
sla mediator 

public void setSynapseEnvironment(SynapseEnvironment se) {	this.se = se;	if(se!=null){	
environment not null in sla 

========================= synapse sample_2886 =========================

public OMElement processDocument(final InputStream inputStream, final String contentType, final MessageContext messageContext) throws AxisFault {	if (log.isDebugEnabled()) {	
start building the hessian message in to a hessiandatasource 

}	OMText textData = factory.createOMText(dataHandler, true);	element.addChild(textData);	messageContext.setProperty(NhttpConstants.FAULTS_AS_HTTP_200, NhttpConstants.TRUE);	} catch (IOException e) {	String msg = "Unable to create the HessianDataSource";	log.error(msg, e);	throw new AxisFault(msg, e);	}	if (log.isDebugEnabled()) {	
building the hessian message using hessiandatasource is successful 

private PushbackInputStream detectAndMarkMessageFault(final MessageContext messageContext, final InputStream inputStream) throws IOException {	int bytesToRead = 4;	PushbackInputStream pis = new PushbackInputStream(inputStream, bytesToRead);	byte[] headerBytes = new byte[bytesToRead];	int n = pis.read(headerBytes);	if (n == bytesToRead) {	if (headerBytes[bytesToRead - 1] == HessianConstants.HESSIAN_V1_FAULT_IDENTIFIER || headerBytes[bytesToRead - 1] == HessianConstants.HESSIAN_V2_FAULT_IDENTIFIER) {	messageContext.setProperty(BaseConstants.FAULT_MESSAGE, SynapseConstants.TRUE);	if (log.isDebugEnabled()) {	
hessian fault detected marking in message context 

========================= synapse sample_1183 =========================

public OMElement processDocument(InputStream inputStream, String contentType, MessageContext messageContext) throws AxisFault {	if (log.isDebugEnabled()) {	
start building the hessian message in to a hessiandatasource 

dataHandler = new DataHandler( new SynapseBinaryDataSource(inputStream,contentType));	}	OMText textData = factory.createOMText(dataHandler, true);	element.addChild(textData);	} catch (IOException e) {	String msg = "Unable to create the HessianDataSource";	log.error(msg, e);	throw new AxisFault(msg, e);	}	if (log.isDebugEnabled()) {	
building the hessian message using hessiandatasource is successful 

========================= synapse sample_4381 =========================

public boolean loadConfiguration(ParameterInclude params) throws AxisFault {	fileURI = ParamUtils.getOptionalParam(params, VFSConstants.TRANSPORT_FILE_FILE_URI);	if (fileURI == null) {	
required parameter is missing in the proxy service configuration 

========================= synapse sample_2310 =========================

private Map generateMap(InputStream instream) throws Exception {	
generating map for failover 

public Map getConfig(EndpointReference to) {	
giving failover map for 

========================= synapse sample_2890 =========================

Object o = localRegistry.get(key);	if (o != null && o instanceof Entry) {	Entry entry = (Entry) o;	if (entry.isDynamic()) {	if (entry.isCached() && !entry.isExpired()) {	return entry.getValue();	} else if (registry != null) {	o = registry.getResource(entry);	} else {	if (log.isDebugEnabled()) {	
will not evaluate the value of the remote entry with a key because the registry is not available 

public void destroy() {	if (log.isDebugEnabled()) {	
destroying the synapse configuration 

public void init(SynapseEnvironment se) {	if (log.isDebugEnabled()) {	
initializing the synapse configuration 

========================= synapse sample_4047 =========================

public void destroy() {	if (initialzed) {	if (log.isDebugEnabled()) {	log.debug("Shutting down priority executor" + (name != null ? ": " + name : ""));	}	executor.shutdown();	try {	executor.awaitTermination(100, TimeUnit.MILLISECONDS);	} catch (InterruptedException e) {	
failed to shut down executor 

public void run() {	try {	runnable.run();	} catch (Throwable e) {	
unhandled exception 

========================= synapse sample_2193 =========================

public void restart() throws Exception {	try {	
re starting synapse 

========================= synapse sample_2039 =========================

public Object call(Context context, List args) throws FunctionCallException {	if (args == null || args.size() == 0) {	if (log.isDebugEnabled()) {	
property key value for lookup is not specified 

}	int size = args.size();	if (size == 1) {	String encodedValue = StringFunction.evaluate(args.get(0), context.getNavigator());	return decode(log.isDebugEnabled(), SynapseXPathConstants.DEFAULT_CHARSET, encodedValue);	} else if (size == 2) {	String encodedValue = StringFunction.evaluate(args.get(0), context.getNavigator());	String charset = StringFunction.evaluate(args.get(1), context.getNavigator());	return decode(log.isDebugEnabled(), charset, encodedValue);	} else if (log.isDebugEnabled()) {	
function expects only two arguments maximum returning empty string 

private Object decode(boolean debugOn, String charset, String value) throws FunctionCallException {	if (value == null || value.isEmpty()) {	if (debugOn) {	
non empty string value should be provided for decode 

byte[] decodedValue = new Base64().decode(value);	String decodedString;	try {	decodedString = new String(decodedValue, charset).trim();	} catch (UnsupportedEncodingException e) {	String msg = "Unsupported Charset";	log.error(msg, e);	throw new FunctionCallException(msg, e);	}	if (debugOn) {	
decoded encoded value with charset to string 

========================= synapse sample_267 =========================

public void setSOAPEnvelope(Message message, int counter, String sessionID, MessageContext msgCtx) throws AxisFault {	if (log.isDebugEnabled()) {	
creating soap envelope for fix message 

private void convertFIXBodyToXML(FieldMap message, OMElement body, SOAPFactory soapFactory, MessageContext msgCtx) throws AxisFault{	if (log.isDebugEnabled()) {	
generating fix message body message id 

public Message createFIXMessage(MessageContext msgCtx) throws IOException {	if (log.isDebugEnabled()) {	
extracting fix message from the message context message id 

========================= synapse sample_2486 =========================

private void registerExtensions() {	if (log.isDebugEnabled()) {	
registering mediator extensions found in the classpath 

MediatorSerializer ms = (MediatorSerializer) it.next();	String name = ms.getMediatorClassName();	try {	serializerMap.put(name, ms.getClass().newInstance());	} catch (InstantiationException e) {	handleException("Error instantiating mediator serializer : " + ms);	} catch (IllegalAccessException e) {	handleException("Error instantiating mediator serializer : " + ms);	}	if (log.isDebugEnabled()) {	
added mediatorserializer to handle 

========================= synapse sample_4102 =========================

public static SynapseConfiguration getConfiguration(String configFile) {	try {	SynapseConfiguration synCfg = XMLConfigurationBuilder.getConfiguration(new FileInputStream(configFile));	
loaded synapse configuration from 

========================= synapse sample_3297 =========================

public Mediator createMediator(OMElement elem) {	
rmmediatorfactory createmediator 

========================= synapse sample_3043 =========================

Parameter trustParam  = transportOut.getParameter("truststore");	if (keyParam != null) {	OMElement ksEle      = keyParam.getParameterElement().getFirstElement();	String location      = ksEle.getFirstChildWithName(new QName("Location")).getText();	String type          = ksEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = ksEle.getFirstChildWithName(new QName("Password")).getText();	String keyPassword   = ksEle.getFirstChildWithName(new QName("KeyPassword")).getText();	try {	KeyStore keyStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	
loading key store from url 

String storePassword = ksEle.getFirstChildWithName(new QName("Password")).getText();	String keyPassword   = ksEle.getFirstChildWithName(new QName("KeyPassword")).getText();	try {	KeyStore keyStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	keyStore.load(url.openStream(), storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

try {	KeyStore keyStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	keyStore.load(url.openStream(), storePassword.toCharArray());	KeyManagerFactory kmfactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm());	kmfactory.init(keyStore, keyPassword.toCharArray());	keymanagers = kmfactory.getKeyManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

}	}	if (trustParam != null) {	OMElement tsEle      = trustParam.getParameterElement().getFirstElement();	String location      = tsEle.getFirstChildWithName(new QName("Location")).getText();	String type          = tsEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = tsEle.getFirstChildWithName(new QName("Password")).getText();	try {	KeyStore trustStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	
loading trust key store from url 

String type          = tsEle.getFirstChildWithName(new QName("Type")).getText();	String storePassword = tsEle.getFirstChildWithName(new QName("Password")).getText();	try {	KeyStore trustStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	trustStore.load(url.openStream(), storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	
error loading key store 

try {	KeyStore trustStore = KeyStore.getInstance(type);	URL url = getClass().getClassLoader().getResource(location);	trustStore.load(url.openStream(), storePassword.toCharArray());	TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm());	trustManagerfactory.init(trustStore);	trustManagers = trustManagerfactory.getTrustManagers();	} catch (GeneralSecurityException gse) {	throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	
error opening key store 

throw new AxisFault("Error loading Key store : " + location, gse);	} catch (IOException ioe) {	throw new AxisFault("Error opening Key store : " + location, ioe);	}	}	try {	SSLContext sslcontext = SSLContext.getInstance("TLS");	sslcontext.init(keymanagers, trustManagers, null);	return sslcontext;	} catch (GeneralSecurityException gse) {	
unable to create ssl context with the given configuration 

========================= synapse sample_3413 =========================

public void init(Properties props) {	if (props == null) {	if (log.isDebugEnabled()) {	
enterprise beanstalk properties cannot be found 

public void init(Properties props) {	if (props == null) {	if (log.isDebugEnabled()) {	}	return;	}	String beanstalkNameList = MiscellaneousUtil.getProperty(props, EnterpriseBeanstalkConstants.SYNAPSE_BEANSTALK_PREFIX, null);	if (beanstalkNameList == null || "".equals(beanstalkNameList)) {	if (log.isDebugEnabled()) {	
no beanstalks defined for initialization 

}	String beanstalkNameList = MiscellaneousUtil.getProperty(props, EnterpriseBeanstalkConstants.SYNAPSE_BEANSTALK_PREFIX, null);	if (beanstalkNameList == null || "".equals(beanstalkNameList)) {	if (log.isDebugEnabled()) {	}	return;	}	String[] beanstalkNames = beanstalkNameList.split(",");	if (beanstalkNames == null || beanstalkNames.length == 0) {	if (log.isDebugEnabled()) {	
no beanstalk definitions found for initialization 

public void destroy() {	Iterator<EnterpriseBeanstalk> it = beanstalkMap.values().iterator();	while (it.hasNext()) {	it.next().destroy();	it.remove();	}	if (scheduler != null && !scheduler.isShutdown()) {	if (log.isDebugEnabled()) {	
shutting down enterprise beanstalk cache cleaner executor 

========================= synapse sample_2202 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start cache mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

if (synLog.isTraceTraceEnabled()) {	}	}	if (maxMessageSize > 0) {	FixedByteArrayOutputStream fbaos = new FixedByteArrayOutputStream(maxMessageSize);	try {	MessageHelper.cloneSOAPEnvelope(synCtx.getEnvelope()).serialize(fbaos);	} catch (XMLStreamException e) {	handleException("Error in checking the message size", e, synCtx);	} catch (SynapseException syne) {	
message size exceeds the upper bound for caching request will not be cached 

} catch (SynapseException syne) {	return true;	}	}	ConfigurationContext cfgCtx = ((Axis2MessageContext) synCtx).getAxis2MessageContext().getConfigurationContext();	if (cfgCtx == null) {	handleException("Unable to perform caching, " + " ConfigurationContext cannot be found", synCtx);	return false;	}	if (synLog.isTraceOrDebugEnabled()) {	
looking up cache at scope with id 

Object prop = cfgCtx.getPropertyNonReplicable(CachingConstants.CACHE_MANAGER);	CacheManager cacheManager;	if (prop != null && prop instanceof CacheManager) {	cacheManager = (CacheManager) prop;	} else {	synchronized (cfgCtx) {	prop = cfgCtx.getPropertyNonReplicable(CachingConstants.CACHE_MANAGER);	if (prop != null && prop instanceof CacheManager) {	cacheManager = (CacheManager) prop;	} else {	
creating recreating the cache object 

}	}	boolean result = true;	try {	if (synCtx.isResponse()) {	processResponseMessage(synCtx, synLog);	} else {	result = processRequestMessage(synCtx, synLog, cacheManager);	}	} catch (ClusteringFault clusteringFault) {	
unable to replicate cache mediator state among the cluster 

}	boolean result = true;	try {	if (synCtx.isResponse()) {	processResponseMessage(synCtx, synLog);	} else {	result = processRequestMessage(synCtx, synLog, cacheManager);	}	} catch (ClusteringFault clusteringFault) {	}	
end cache mediator 

private void processResponseMessage(MessageContext synCtx, SynapseLog synLog) throws ClusteringFault {	if (!collector) {	handleException("Response messages cannot be handled in a non collector cache", synCtx);	}	org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext)synCtx).getAxis2MessageContext();	OperationContext operationContext = msgCtx.getOperationContext();	CachableResponse response = (CachableResponse) operationContext.getPropertyNonReplicable(CachingConstants.CACHED_OBJECT);	if (response != null) {	if (synLog.isTraceOrDebugEnabled()) {	
storing the response message into the cache at scope with id for request hash 

if (!collector) {	handleException("Response messages cannot be handled in a non collector cache", synCtx);	}	org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext)synCtx).getAxis2MessageContext();	OperationContext operationContext = msgCtx.getOperationContext();	CachableResponse response = (CachableResponse) operationContext.getPropertyNonReplicable(CachingConstants.CACHED_OBJECT);	if (response != null) {	if (synLog.isTraceOrDebugEnabled()) {	}	if (synLog.isTraceOrDebugEnabled()) {	
storing the response for the message with id with request hash id in the cache 

handleException("Unable to set the response to the Cache", e, synCtx);	}	if (response.getTimeout() > 0) {	response.setExpireTimeMillis(System.currentTimeMillis() + response.getTimeout());	}	CacheReplicationCommand cacheReplicationCommand = (CacheReplicationCommand) msgCtx.getPropertyNonReplicable( CachingConstants.STATE_REPLICATION_OBJECT);	if (cacheReplicationCommand != null) {	try {	Replicator.replicateState(cacheReplicationCommand, msgCtx.getRootContext().getAxisConfiguration());	} catch (ClusteringFault clusteringFault) {	
cannot replicate cache changes 

}	OperationContext opCtx = ((Axis2MessageContext)synCtx).getAxis2MessageContext(). getOperationContext();	String requestHash = null;	try {	requestHash = digestGenerator.getDigest( ((Axis2MessageContext) synCtx).getAxis2MessageContext());	synCtx.setProperty(CachingConstants.REQUEST_HASH, requestHash);	} catch (CachingException e) {	handleException("Error in calculating the hash value of the request", e, synCtx);	}	if (synLog.isTraceOrDebugEnabled()) {	
generated request hash 

service = new ServiceName(cacheKey);	}	RequestHash hash = new RequestHash(requestHash);	CachableResponse cachedResponse = cacheManager.getCachedResponse(service, hash);	org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext)synCtx).getAxis2MessageContext();	opCtx.setNonReplicableProperty(CachingConstants.REQUEST_HASH, requestHash);	CacheReplicationCommand cacheReplicationCommand = new CacheReplicationCommand();	if (cachedResponse != null) {	if (!cachedResponse.isExpired()) {	if (synLog.isTraceOrDebugEnabled()) {	
cache hit for message id 

synCtx.setEnvelope(omSOAPEnv);	}	} catch (AxisFault axisFault) {	handleException("Error setting response envelope from cache : " + cacheKey, synCtx);	} catch (IOException ioe) {	handleException("Error setting response envelope from cache : " + cacheKey, ioe, synCtx);	} catch (SOAPException soape) {	handleException("Error setting response envelope from cache : " + cacheKey, soape, synCtx);	}	if (onCacheHitSequence != null) {	
delegating message to the oncachinghit anonymous sequence 

handleException("Error setting response envelope from cache : " + cacheKey, synCtx);	} catch (IOException ioe) {	handleException("Error setting response envelope from cache : " + cacheKey, ioe, synCtx);	} catch (SOAPException soape) {	handleException("Error setting response envelope from cache : " + cacheKey, soape, synCtx);	}	if (onCacheHitSequence != null) {	onCacheHitSequence.mediate(synCtx);	} else if (onCacheHitRef != null) {	if (synLog.isTraceOrDebugEnabled()) {	
delegating message to the oncachinghit sequence 

handleException("Error setting response envelope from cache : " + cacheKey, soape, synCtx);	}	if (onCacheHitSequence != null) {	onCacheHitSequence.mediate(synCtx);	} else if (onCacheHitRef != null) {	if (synLog.isTraceOrDebugEnabled()) {	}	synCtx.getSequence(onCacheHitRef).mediate(synCtx);	} else {	if (synLog.isTraceOrDebugEnabled()) {	
request message was served from the cache 

} else {	if (synLog.isTraceOrDebugEnabled()) {	}	synCtx.setTo(null);	Axis2Sender.sendBack(synCtx);	}	return false;	} else {	cachedResponse.reincarnate(timeout);	if (synLog.isTraceOrDebugEnabled()) {	
existing cached response has expired reset cache element 

cacheManager.cacheResponse(service, hash, cachedResponse, cacheReplicationCommand);	opCtx.setNonReplicableProperty(CachingConstants.CACHED_OBJECT, cachedResponse);	opCtx.setNonReplicableProperty(CachingConstants.STATE_REPLICATION_OBJECT, cacheReplicationCommand);	Replicator.replicate(opCtx);	}	} else {	if (cacheManager.getCacheSize(service) >= inMemoryCacheSize) {	cacheManager.removeExpiredResponses(service, cacheReplicationCommand);	if (cacheManager.getCacheSize(service) >= inMemoryCacheSize) {	if (log.isDebugEnabled()) {	
in memory cache is full unable to cache 

========================= synapse sample_549 =========================

return mainSynLibArtifact;	} catch (FileNotFoundException e) {	throw new SynapseArtifactDeploymentException("artifacts.xml File cannot be loaded from " + libXmlPath, e);	} catch (OMException e) {	throw new SynapseArtifactDeploymentException("Error while parsing the artifacts.xml file ", e);	} finally {	if (xmlInputStream != null) {	try {	xmlInputStream.close();	} catch (IOException e) {	
error while closing input stream 

File f = new File(artifactXmlPath);	if (!f.exists()) {	continue;	}	LibraryArtifact artifact = null;	InputStream xmlInputStream = null;	try {	xmlInputStream = new FileInputStream(f);	artifact = buildArtifact(library, xmlInputStream, directoryPath);	} catch (FileNotFoundException e) {	
error while resolving synapse lib dir artifacts xml file cannot be loaded from 

if (!f.exists()) {	continue;	}	LibraryArtifact artifact = null;	InputStream xmlInputStream = null;	try {	xmlInputStream = new FileInputStream(f);	artifact = buildArtifact(library, xmlInputStream, directoryPath);	} catch (FileNotFoundException e) {	} catch (Exception e) {	
error ocurred while resolving synapse lib dir for artifacts xml path 

try {	xmlInputStream = new FileInputStream(f);	artifact = buildArtifact(library, xmlInputStream, directoryPath);	} catch (FileNotFoundException e) {	} catch (Exception e) {	} finally {	if (xmlInputStream != null) {	try {	xmlInputStream.close();	} catch (IOException e) {	
error while closing input stream 

} catch (Exception e) {	} finally {	if (xmlInputStream != null) {	try {	xmlInputStream.close();	} catch (IOException e) {	}	}	}	if (artifact == null) {	
could not build lib artifact for path synapse library continue searching for other lib artifacts 

private static LibraryArtifact buildArtifact(SynapseLibrary library, InputStream artifactXmlStream, String directoryPath) {	LibraryArtifact artifact = null;	try {	OMElement artElement = OMXMLBuilderFactory.createOMBuilder(artifactXmlStream).getDocumentElement();	if (LibDeployerConstants.ARTIFACT.equals(artElement.getLocalName())) {	artifact = populateLibraryArtifact(artElement, directoryPath, null, library);	} else {	
artifact xml is invalid error occurred while resolving synapse library 

OMElement artElement = OMXMLBuilderFactory.createOMBuilder(artifactXmlStream).getDocumentElement();	if (LibDeployerConstants.ARTIFACT.equals(artElement.getLocalName())) {	artifact = populateLibraryArtifact(artElement, directoryPath, null, library);	} else {	return null;	}	} catch (OMException e) {	throw new SynapseArtifactDeploymentException("Error parsing artifact.xml for path : " + directoryPath ,e);	}	if (artifact == null || artifact.getName() == null) {	
invalid artifact found in synapse library 

public static void createDir(String path) {	File temp = new File(path);	if (!temp.exists() && !temp.mkdir()) {	
error while creating directory 

========================= synapse sample_1992 =========================

}	} else {	bufferedInputStream = new BufferedInputStream(in);	bufferedInputStream.mark(128 * 1024);	messageContext.setProperty(PassThroughConstants.BUFFERED_INPUT_STREAM, bufferedInputStream);	}	OMElement element = null;	try{	element = messageBuilder.getDocument(messageContext, bufferedInputStream);	}catch (Exception e) {	
error while building passthrough stream 

========================= synapse sample_2347 =========================

public void connected(final NHttpServerConnection conn) {	if (this.log.isDebugEnabled()) {	
http connection connected 

public void closed(final NHttpServerConnection conn) {	if (this.log.isDebugEnabled()) {	
http connection closed 

public void exception(final NHttpServerConnection conn, final IOException ex) {	if (ex instanceof ConnectionClosedException || ex.getMessage().contains("Connection reset by peer") || ex.getMessage().contains("forcibly closed")) {	if (this.log.isDebugEnabled()) {	
http connection probably the keepalive connection was closed 

public void exception(final NHttpServerConnection conn, final IOException ex) {	if (ex instanceof ConnectionClosedException || ex.getMessage().contains("Connection reset by peer") || ex.getMessage().contains("forcibly closed")) {	if (this.log.isDebugEnabled()) {	}	} else {	
http connection 

public void exception(final NHttpServerConnection conn, final HttpException ex) {	
http connection 

public void requestReceived(final NHttpServerConnection conn) {	HttpRequest request = conn.getHttpRequest();	if (this.log.isDebugEnabled()) {	
http connection 

public void outputReady(final NHttpServerConnection conn, final ContentEncoder encoder) {	if (this.log.isDebugEnabled()) {	
http connection output ready 

public void outputReady(final NHttpServerConnection conn, final ContentEncoder encoder) {	if (this.log.isDebugEnabled()) {	}	this.handler.outputReady(conn, encoder);	if (this.log.isDebugEnabled()) {	
http connection content encoder 

public void responseReady(final NHttpServerConnection conn) {	if (this.log.isDebugEnabled()) {	
http connection response ready 

public void inputReady(final NHttpServerConnection conn, final ContentDecoder decoder) {	if (this.log.isDebugEnabled()) {	
http connection input ready 

public void inputReady(final NHttpServerConnection conn, final ContentDecoder decoder) {	if (this.log.isDebugEnabled()) {	}	this.handler.inputReady(conn, decoder);	if (this.log.isDebugEnabled()) {	
http connection content decoder 

public void timeout(final NHttpServerConnection conn) {	if (this.log.isDebugEnabled()) {	
http connection timeout 

========================= synapse sample_4293 =========================

public void setEndpoint(String sessionID, Endpoint endpoint) {	if (isClusteringEnable) {	String endPointName = endpoint.getName();	if (endPointName == null) {	if (log.isDebugEnabled() && isClusteringEnable()) {	
in a clustering environment the endpoint name should be specified even for anonymous endpoints otherwise the clustering would not be functioned correctly if there are more than one anonymous endpoints 

private void setAndReplicateState(String key, Object value) {	if (configCtx != null && key != null && value != null) {	try {	if (log.isDebugEnabled()) {	
going to replicate the property with key value 

private void removeAndReplicateState(String key) {	if (configCtx != null && key != null) {	try {	if (log.isDebugEnabled()) {	
going to replicate the property with key 

public void setEndpoints(List<Endpoint> endpoints) {	if (endpoints != null) {	for (Endpoint endpoint : endpoints) {	String endPointName = endpoint.getName();	if (endPointName == null) {	if (log.isDebugEnabled() && isClusteringEnable()) {	
in a clustering environment the endpoint name should be specified even for anonymous endpoints otherwise the clustering would not be functioned correctly if there are more than one anonymous endpoints 

========================= synapse sample_4010 =========================

public void produce(MessageContext messageContext) {	String action = queueProducerPolicy.getAction();	if (SEDAQueueProducerPolicy.ADD.equals(action)) {	queue.add(messageContext);	} else if (SEDAQueueProducerPolicy.OFFER.equals(action)) {	long timeout = queueProducerPolicy.getTimeoutOnInsert();	if (timeout < 0) {	if (!queue.offer(messageContext)) {	
error while offering the message to the queue 

queue.add(messageContext);	} else if (SEDAQueueProducerPolicy.OFFER.equals(action)) {	long timeout = queueProducerPolicy.getTimeoutOnInsert();	if (timeout < 0) {	if (!queue.offer(messageContext)) {	}	} else {	try {	queue.offer(messageContext, timeout, TimeUnit.MILLISECONDS);	} catch (InterruptedException e) {	
ignored interruptedexception when ocuured calling queue offer 

} else {	try {	queue.offer(messageContext, timeout, TimeUnit.MILLISECONDS);	} catch (InterruptedException e) {	}	}	} else if (SEDAQueueProducerPolicy.PUT.equals(action)) {	try {	queue.put(messageContext);	} catch (InterruptedException e) {	
ignored interruptedexception when ocuured calling queue put 

========================= synapse sample_10 =========================

public TimeoutHandler(Map callbacks) {	this.callbackStore = callbacks;	try {	globalTimeout = Long.parseLong( System.getProperty(SynapseConstants.GLOBAL_TIMEOUT_INTERVAL));	} catch (Exception ignore) {}	
this engine will expire all callbacks after seconds irrespective of the timeout action after the specified or optional timeout 

Stack faultStack = msgContext.getFaultStack();	for (int j = 0; j < faultStack.size(); j++) {	Object o = faultStack.pop();	if (o instanceof FaultHandler) {	((FaultHandler) o).handleFault(msgContext);	}	}	}	}	} else if (currentTime > globalTimeout + callback.getTimeOutOn()) {	
expiring message id dropping message after global timeout of seconds 

========================= synapse sample_3487 =========================

private void tryNextMessage(MessageContext messageContext, NHttpClientConnection conn) {	if (conn != null) {	try {	TargetContext.get(conn).setRequestMsgCtx(messageContext);	submitRequest(conn, messageContext);	} catch (AxisFault e) {	
io error while sending the request out 

private void submitRequest(NHttpClientConnection conn, MessageContext msgContext) throws AxisFault {	if (log.isDebugEnabled()) {	
submitting new request to the connection 

========================= synapse sample_924 =========================

public void testDynamicLB() {	final String addUrl = "http: final StockQuoteSampleClient client = getStockQuoteClient();	
running test dynamic load balancing between nodes 

========================= synapse sample_861 =========================

public boolean mediate(MessageContext synCtx) {	UserTransaction tx = null;	final SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start transaction mediator 

public boolean mediate(MessageContext synCtx) {	UserTransaction tx = null;	final SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

try {	status = tx.getStatus();	} catch (Exception e) {	handleException("Unable to query transaction status", e, synCtx);	}	if (status != Status.STATUS_ACTIVE) throw new SynapseException("No active transaction. Require an active transaction");	} else {	handleException("Invalid transaction mediator action : " + action, synCtx);	}	if (synLog.isTraceOrDebugEnabled()) {	
end transaction mediator 

========================= synapse sample_498 =========================

public void testSmartClientMode() {	String addUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test smart client mode 

========================= synapse sample_2279 =========================

public void insert(MessageContext synContext, ArrayList<OMNode> sourceNodeList, SynapseLog synLog) throws JaxenException {	if (targetType == EnrichMediator.CUSTOM) {	assert xpath != null : "Xpath cannot be null for CUSTOM";	if (sourceNodeList.isEmpty()) {	
cannot enrich message from an empty source 

targetText.detach();	((OMElement)targetParent).addChild(sourceNodeList.get(0));	}	}	} else if (targetObj instanceof OMAttribute){	OMAttribute attribute = (OMAttribute)targetObj;	if (sourceNodeList.get(0) instanceof OMText){	attribute.setAttributeValue(((OMText)sourceNodeList.get(0)).getText());	}	} else {	
invalid target object to enrich 

SOAPEnvelope env = synContext.getEnvelope();	SOAPBody body = env.getBody();	OMElement e = body.getFirstElement();	if (e != null) {	insertElement(sourceNodeList, e, synLog);	} else {	for (OMNode elem : sourceNodeList) {	if (elem instanceof OMElement) {	body.addChild(elem);	} else {	
invalid object type to be inserted into message body 

} else {	}	}	}	} else if (targetType == EnrichMediator.ENVELOPE) {	OMNode node = sourceNodeList.get(0);	if (node instanceof SOAPEnvelope) {	try {	synContext.setEnvelope((SOAPEnvelope) node);	} catch (AxisFault axisFault) {	
failed to set the soap envelope 

}	} else if (targetType == EnrichMediator.ENVELOPE) {	OMNode node = sourceNodeList.get(0);	if (node instanceof SOAPEnvelope) {	try {	synContext.setEnvelope((SOAPEnvelope) node);	} catch (AxisFault axisFault) {	throw new SynapseException("Failed to set the SOAP Envelope");	}	} else {	
soapenvelope is expected 

========================= synapse sample_532 =========================

public ClientWorker(ConfigurationContext cfgCtx, InputStream in, HttpResponse response, MessageContext outMsgCtx) {	this.cfgCtx = cfgCtx;	this.in = in;	this.outMsgCtx = outMsgCtx;	this.response = response;	try {	responseMsgCtx = outMsgCtx.getOperationContext(). getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);	} catch (AxisFault af) {	
error getting in message context from the operation context 

this.in = in;	this.outMsgCtx = outMsgCtx;	this.response = response;	try {	responseMsgCtx = outMsgCtx.getOperationContext(). getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);	} catch (AxisFault af) {	return;	}	if (responseMsgCtx == null && outMsgCtx.getOperationContext().isComplete()) {	if (log.isDebugEnabled()) {	
error getting in message context from the operation context possibly an rm terminate sequence message 

}	if (contentType.indexOf(HTTP.CHARSET_PARAM) > 0) {	responseMsgCtx.setProperty(Constants.Configuration.CHARACTER_SET_ENCODING, charSetEnc);	} else {	responseMsgCtx.setProperty(Constants.Configuration.CHARACTER_SET_ENCODING, MessageContext.DEFAULT_CHAR_SET_ENCODING);	}	responseMsgCtx.setServerSide(false);	try {	envelope = TransportUtils.createSOAPMessage( responseMsgCtx, in, contentType);	} catch (OMException e) {	
unexpected response received 

SOAPFaultReason reason = factory.createSOAPFaultReason();	reason.setText(this.response.getStatusLine().getReasonPhrase());	envelope.getBody().getFault().setReason(reason);	SOAPFaultCode code = factory.createSOAPFaultCode();	code.setText(Integer.toString(this.response.getStatusLine().getStatusCode()));	envelope.getBody().getFault().setCode(code);	}	responseMsgCtx.setServerSide(true);	responseMsgCtx.setEnvelope(envelope);	} catch (AxisFault af) {	
fault creating response soap envelope 

envelope.getBody().getFault().setReason(reason);	SOAPFaultCode code = factory.createSOAPFaultCode();	code.setText(Integer.toString(this.response.getStatusLine().getStatusCode()));	envelope.getBody().getFault().setCode(code);	}	responseMsgCtx.setServerSide(true);	responseMsgCtx.setEnvelope(envelope);	} catch (AxisFault af) {	return;	} catch (XMLStreamException e) {	
error creating response soap envelope 

SOAPFaultCode code = factory.createSOAPFaultCode();	code.setText(Integer.toString(this.response.getStatusLine().getStatusCode()));	envelope.getBody().getFault().setCode(code);	}	responseMsgCtx.setServerSide(true);	responseMsgCtx.setEnvelope(envelope);	} catch (AxisFault af) {	return;	} catch (XMLStreamException e) {	} catch (IOException e) {	
error closing input stream from which message was read 

responseMsgCtx.setEnvelope(envelope);	} catch (AxisFault af) {	return;	} catch (XMLStreamException e) {	} catch (IOException e) {	}	AxisEngine engine = new AxisEngine(cfgCtx);	try {	engine.receive(responseMsgCtx);	} catch (AxisFault af) {	
fault processing response message through 

========================= synapse sample_3741 =========================

public boolean mediate(MessageContext synCtx) {	log.debug("Header mediator <" + (action == ACTION_SET ? "Set" : "Remove") + "> :: mediate()");	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	if(shouldTrace) {	trace.trace("Start : Header mediator, action = " + (action == ACTION_SET ? "set" : "remove"));	}	if (action == ACTION_SET) {	String value = (getValue() != null ? getValue() : Axis2MessageContext.getStringValue(getExpression(), synCtx));	
setting header to 

synCtx.setWSAAction(value);	} else if (Constants.HEADER_FAULT.equals(qName.getLocalPart())) {	synCtx.setFaultTo(new EndpointReference(value));	} else if (Constants.HEADER_REPLY_TO.equals(qName.getLocalPart())) {	synCtx.setReplyTo(new EndpointReference(value));	} else {	handleException("Unsupported header : " + qName.getLocalPart());	}	}	} else {	
removing header from current message 

========================= synapse sample_3311 =========================

public void start() throws AxisFault {	if (log.isDebugEnabled()) {	
starting listener 

public void start() throws AxisFault {	if (log.isDebugEnabled()) {	}	try {	String prefix = (sslContext == null ? "http" : "https") + "-Listener I/O dispatcher";	ioReactor = new DefaultListeningIOReactor( listenerContext.getReactorConfig(), new NativeThreadFactory(new ThreadGroup(prefix + " thread group"), prefix));	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	
system may be unstable ioreactor encountered a checked exception 

if (log.isDebugEnabled()) {	}	try {	String prefix = (sslContext == null ? "http" : "https") + "-Listener I/O dispatcher";	ioReactor = new DefaultListeningIOReactor( listenerContext.getReactorConfig(), new NativeThreadFactory(new ThreadGroup(prefix + " thread group"), prefix));	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	return true;	}	public boolean handle(RuntimeException runtimeException) {	
system may be unstable ioreactor encountered a runtime exception 

}	} catch (IOException e) {	handleException("Encountered an I/O error: " + e.getMessage(), e);	return;	}	Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	
reactor interrupted 

} catch (IOException e) {	handleException("Encountered an I/O error: " + e.getMessage(), e);	return;	}	Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	} catch (IOException e) {	
encountered an i o error 

handleException("Encountered an I/O error: " + e.getMessage(), e);	return;	}	Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	} catch (IOException e) {	} catch (Exception e) {	
unexpected exception in i o reactor 

} catch (IOException e) {	} catch (Exception e) {	}	log.info((sslContext == null ? "HTTP" : "HTTPS") + " Listener Shutdown");	}	}, "HttpCoreNIOListener");	t.start();	try {	endpoint.waitFor();	} catch (InterruptedException e) {	
httpcoreniolistener start was interrupted 

public void maintenenceShutdown(long millis) throws AxisFault {	if (state != BaseConstants.STARTED) return;	try {	long start = System.currentTimeMillis();	ioReactor.pause();	ioReactor.shutdown(millis);	state = BaseConstants.STOPPED;	
listener shutdown in s 

========================= synapse sample_2445 =========================

if(((Axis2SynapseMessage)synapseMessage).getMessageContext().getProperty("MIX")!=null){	ManagementInformationExchange mix = (ManagementInformationExchange)((Axis2SynapseMessage)synapseMessage).getMessageContext().getProperty("MIX");	mix.setSOAPRequest(((Axis2SynapseMessage)synapseMessage).getMessageContext().getEnvelope().toString());	((Axis2SynapseMessage)synapseMessage).getMessageContext().setProperty("MIX",mix);	}	long start = System.currentTimeMillis();	MediatorExecInfoObject meio  = new MediatorExecInfoObject();	meio.setMediatorName("FAILOVER");	try {	synapseEnvironment.setProperty("copy_message", ((Axis2SynapseMessage) synapseMessage).getMessageContext());	
failover mediation 

if(((Axis2SynapseMessage)synapseMessage).getMessageContext().getProperty("MIX")!=null){	ManagementInformationExchange mix = (ManagementInformationExchange)((Axis2SynapseMessage)synapseMessage).getMessageContext().getProperty("MIX");	mix.setSOAPRequest(((Axis2SynapseMessage)synapseMessage).getMessageContext().getEnvelope().toString());	((Axis2SynapseMessage)synapseMessage).getMessageContext().setProperty("MIX",mix);	}	long start = System.currentTimeMillis();	MediatorExecInfoObject meio  = new MediatorExecInfoObject();	meio.setMediatorName("FAILOVER");	try {	synapseEnvironment.setProperty("copy_message", ((Axis2SynapseMessage) synapseMessage).getMessageContext());	
loading config 

ManagementInformationExchange mix = (ManagementInformationExchange)((Axis2SynapseMessage)synapseMessage).getMessageContext().getProperty("MIX");	mix.setSOAPRequest(((Axis2SynapseMessage)synapseMessage).getMessageContext().getEnvelope().toString());	((Axis2SynapseMessage)synapseMessage).getMessageContext().setProperty("MIX",mix);	}	long start = System.currentTimeMillis();	MediatorExecInfoObject meio  = new MediatorExecInfoObject();	meio.setMediatorName("FAILOVER");	try {	synapseEnvironment.setProperty("copy_message", ((Axis2SynapseMessage) synapseMessage).getMessageContext());	loadConfig(synapseMessage);	
getting failover data for 

isSOAPFaultEnabled = contract.getBoolean(FailoverConstants.CFG_FAILOVER_ON_SOPAFAULT);	isNetworkErrorEnabled = contract.getBoolean(FailoverConstants.CFG_FAILOVER_ON_NTWRK_ERROR);	SynapseObject[] services = contract.getChildren();	int length = services.length;	if (this.synapseEnvironment == null) log.info("EMPTY ENVIRONMENT TO PASS");	SynapseMessage reply = null;	for (int i = 0; i < length; i++) {	if((services[i].getBoolean(FailoverConstants.CFG_PARAM_ACTIVE).booleanValue())&&(!services[i].getBoolean("isFailing").booleanValue())) {	request = new Axis2SynapseMessage((MessageContext) synapseEnvironment.getProperty("copy_message"));	String currentService = services[i].getString("url");	
Service 

if (!shouldFailover) break;	} else break;	}	}	synapseMessage.getEnvelope().getBody().getFirstElement().detach();	synapseMessage.getEnvelope().getBody().setFirstChild(reply.getEnvelope().getBody().getFirstElement());	EndpointReference temp = synapseMessage.getTo();	synapseMessage.setTo(synapseMessage.getReplyTo());	synapseMessage.setReplyTo(temp);	synapseMessage.setResponse(true);	
the failover mediation ends 

private void loadConfig(SynapseMessage synapseMessageContext) {	boolean flag = false;	InputStream failoverInStream;	String resource;	AxisConfiguration ac = ((Axis2SynapseMessage) synapseMessageContext).getMessageContext().getConfigurationContext().getAxisConfiguration();	Parameter param = ac.getParameter("PolicyRepo");	if (param != null) {	resource = param.getValue().toString().trim() + File.separator + "policy"+File.separator+"mediators" + File.separator + FailoverConstants.CFG_FAILOVER_XML;	resource = resource.replace('\\','/');	
resource from repo 

InputStream failoverInStream;	String resource;	AxisConfiguration ac = ((Axis2SynapseMessage) synapseMessageContext).getMessageContext().getConfigurationContext().getAxisConfiguration();	Parameter param = ac.getParameter("PolicyRepo");	if (param != null) {	resource = param.getValue().toString().trim() + File.separator + "policy"+File.separator+"mediators" + File.separator + FailoverConstants.CFG_FAILOVER_XML;	resource = resource.replace('\\','/');	File file = new File(resource);	try{	flag = (file.lastModified() != modifiedTime);	
flag 

if (param != null) {	resource = param.getValue().toString().trim() + File.separator + "policy"+File.separator+"mediators" + File.separator + FailoverConstants.CFG_FAILOVER_XML;	resource = resource.replace('\\','/');	File file = new File(resource);	try{	flag = (file.lastModified() != modifiedTime);	modifiedTime = file.lastModified();	}  catch(Exception e){	e.printStackTrace();	}	
getting the stream 

try{	flag = (file.lastModified() != modifiedTime);	modifiedTime = file.lastModified();	}  catch(Exception e){	e.printStackTrace();	}	try {	failoverInStream = new FileInputStream(file);	}	catch(Exception e) {	
error here 

flag = (file.lastModified() != modifiedTime);	modifiedTime = file.lastModified();	}  catch(Exception e){	e.printStackTrace();	}	try {	failoverInStream = new FileInputStream(file);	}	catch(Exception e) {	resource = FailoverConstants.CFG_XML_FOLDER + "/" + FailoverConstants.CFG_FAILOVER_XML;	
resource from aar 

}	try {	failoverInStream = new FileInputStream(file);	}	catch(Exception e) {	resource = FailoverConstants.CFG_XML_FOLDER + "/" + FailoverConstants.CFG_FAILOVER_XML;	failoverInStream = this.classLoader.getResourceAsStream(resource);	}	} else {	resource = FailoverConstants.CFG_XML_FOLDER + "/" + FailoverConstants.CFG_FAILOVER_XML;	
resource from aar 

failoverInStream = new FileInputStream(file);	}	catch(Exception e) {	resource = FailoverConstants.CFG_XML_FOLDER + "/" + FailoverConstants.CFG_FAILOVER_XML;	failoverInStream = this.classLoader.getResourceAsStream(resource);	}	} else {	resource = FailoverConstants.CFG_XML_FOLDER + "/" + FailoverConstants.CFG_FAILOVER_XML;	failoverInStream = this.classLoader.getResourceAsStream(resource);	}	
failover in stream 

}	if ((!flag)&&(synapseEnvironment.getProperty("failover_synapseObject") != null)) {	failover = (SynapseObject) synapseEnvironment.getProperty("failover_synapseObject");	} else {	if(failoverInStream!=null){	failover = Utils.xmlToSynapseObject(failoverInStream);	addDirtySettings();	synapseEnvironment.setProperty("failover_synapseObject", failover);	}	else {	
null stream 

public void setSynapseEnvironment(SynapseEnvironment se) {	if (se == null) {	
the environment is null 

========================= synapse sample_2916 =========================

}	MessageContext originalInMsgCtx = ((Axis2MessageContext) synapseOutMessageContext).getAxis2MessageContext();	String session = (String) synapseOutMessageContext.getProperty("LB_COOKIE_HEADER");	if (session != null) {	Map headers = (Map) originalInMsgCtx.getProperty(MessageContext.TRANSPORT_HEADERS);	headers.put("Cookie", session);	}	String preserveAddressingProperty = (String) synapseOutMessageContext.getProperty( SynapseConstants.PRESERVE_WS_ADDRESSING);	MessageContext axisOutMsgCtx = cloneForSend(originalInMsgCtx, preserveAddressingProperty);	if (log.isDebugEnabled()) {	
message original request message id new cloned request message id 

========================= synapse sample_1639 =========================

public boolean mediate(MessageContext synCtx) {	
starting spring meditor 

public boolean mediate(MessageContext synCtx) {	
bean in initialized with user 

public boolean mediate(MessageContext synCtx) {	
e mail 

public boolean mediate(MessageContext synCtx) {	
massage id 

public boolean mediate(MessageContext synCtx) {	
logged 

========================= synapse sample_1269 =========================

public boolean mediate(MessageContext synCtx) {	
synapse main mediator mediate 

========================= synapse sample_3080 =========================

public void init(Properties properties) {	if (initialized) {	if (log.isDebugEnabled()) {	
secret manager already has been started 

public void init(Properties properties) {	if (initialized) {	if (log.isDebugEnabled()) {	}	return;	}	if (properties == null) {	if (log.isDebugEnabled()) {	
keystore configuration properties cannot be found 

}	if (properties == null) {	if (log.isDebugEnabled()) {	}	return;	}	String configurationFile = MiscellaneousUtil.getProperty( properties, PROP_SECRET_MANAGER_CONF, PROP_DEFAULT_CONF_LOCATION);	Properties configurationProperties = MiscellaneousUtil.loadProperties(configurationFile);	if (configurationProperties == null || configurationProperties.isEmpty()) {	if (log.isDebugEnabled()) {	
configuration properties can not be loaded form will use synapse properties 

String configurationFile = MiscellaneousUtil.getProperty( properties, PROP_SECRET_MANAGER_CONF, PROP_DEFAULT_CONF_LOCATION);	Properties configurationProperties = MiscellaneousUtil.loadProperties(configurationFile);	if (configurationProperties == null || configurationProperties.isEmpty()) {	if (log.isDebugEnabled()) {	}	configurationProperties = properties;	}	String repositoriesString = MiscellaneousUtil.getProperty( configurationProperties, PROP_SECRET_REPOSITORIES, null);	if (repositoriesString == null || "".equals(repositoriesString)) {	if (log.isDebugEnabled()) {	
no secret repositories have been configured 

}	String repositoriesString = MiscellaneousUtil.getProperty( configurationProperties, PROP_SECRET_REPOSITORIES, null);	if (repositoriesString == null || "".equals(repositoriesString)) {	if (log.isDebugEnabled()) {	}	return;	}	String[] repositories = repositoriesString.split(",");	if (repositories == null || repositories.length == 0) {	if (log.isDebugEnabled()) {	
no secret repositories have been configured 

}	return;	}	IdentityKeyStoreInformation identityInformation = KeyStoreInformationFactory.createIdentityKeyStoreInformation(properties);	TrustKeyStoreInformation trustInformation = KeyStoreInformationFactory.createTrustKeyStoreInformation(properties);	String identityKeyPass = identityInformation .getKeyPasswordProvider().getResolvedSecret();	String identityStorePass = identityInformation .getKeyStorePasswordProvider().getResolvedSecret();	String trustStorePass = trustInformation .getKeyStorePasswordProvider().getResolvedSecret();	if (!validatePasswords(identityStorePass, identityKeyPass, trustStorePass)) {	if (log.isDebugEnabled()) {	
either identity or trust keystore password is mandatory in order to initialized secret manager 

sb.append(DOT);	sb.append(secretRepo);	String id = sb.toString();	sb.append(DOT);	sb.append(PROP_PROVIDER);	String provider = MiscellaneousUtil.getProperty( configurationProperties, sb.toString(), null);	if (provider == null || "".equals(provider)) {	handleException("Repository provider cannot be null ");	}	if (log.isDebugEnabled()) {	
initiating a file based secret repository 

Object instance = aClass.newInstance();	if (instance instanceof SecretRepositoryProvider) {	SecretRepository secretRepository = ((SecretRepositoryProvider) instance). getSecretRepository(identityKeyStoreWrapper, trustKeyStoreWrapper);	secretRepository.init(configurationProperties, id);	if (parentRepository == null) {	parentRepository = secretRepository;	}	secretRepository.setParent(currentParent);	currentParent = secretRepository;	if (log.isDebugEnabled()) {	
successfully initiate a secret repository provided by 

public String getSecret(String alias) {	if (!initialized || parentRepository == null) {	if (log.isDebugEnabled()) {	
there is no secret repository returning alias itself 

private boolean validatePasswords(String identityStorePass, String identityKeyPass, String trustStorePass) {	boolean isValid = false;	if (trustStorePass != null && !"".equals(trustStorePass)) {	if (log.isDebugEnabled()) {	
trust store password cannot be found 

private boolean validatePasswords(String identityStorePass, String identityKeyPass, String trustStorePass) {	boolean isValid = false;	if (trustStorePass != null && !"".equals(trustStorePass)) {	if (log.isDebugEnabled()) {	}	isValid = true;	} else {	if (identityStorePass != null && !"".equals(identityStorePass) && identityKeyPass != null && !"".equals(identityKeyPass)) {	if (log.isDebugEnabled()) {	
identity store password and identity store private key password cannot be found 

========================= synapse sample_1117 =========================

private Destination getDestination(Context context, String url) {	String destinationName = JMSUtils.getDestination(url);	try {	return (Destination) context.lookup(destinationName);	} catch (NameNotFoundException e) {	if (log.isDebugEnabled()) {	
cannot locate destination using 

private Destination getReplyDestination(Context context, String url) {	String replyDestinationName = (String) properties.get(JMSConstants.REPLY_PARAM);	if(replyDestinationName == null) {	return null;	}	try {	return (Destination) context.lookup(replyDestinationName);	} catch (NameNotFoundException e) {	if (log.isDebugEnabled()) {	
cannot locate destination using 

public Destination getReplyDestination(String replyDest) {	try {	return (Destination) jmsConnectionFactory.getContext().lookup(replyDest);	} catch (NameNotFoundException e) {	if (log.isDebugEnabled()) {	
cannot locate reply destination 

========================= synapse sample_4315 =========================

CertPath certPath = fact.generateCertPath(certChain);	TrustAnchor trustAnchor = new TrustAnchor(fullCertChain.get(fullCertChain.size() - 1), null);	Set<TrustAnchor> trust = Collections.singleton(trustAnchor);	CertPathValidator validator = CertPathValidator.getInstance("PKIX", "BC");	PKIXParameters param = new PKIXParameters(trust);	param.addCertPathChecker(pathChecker);	param.setRevocationEnabled(false);	param.addCertStore(store);	param.setDate(new Date());	validator.validate(certPath, param);	
certificate path validated 

========================= synapse sample_973 =========================

public InputSource resolve(SynapseConfiguration synCfg, String location) {	String key = (String)resources.get(location);	if (key == null) {	if (log.isDebugEnabled()) {	
no resource mapping is defined for location 

public InputSource resolve(SynapseConfiguration synCfg, String location) {	String key = (String)resources.get(location);	if (key == null) {	if (log.isDebugEnabled()) {	}	return null;	} else {	if (log.isDebugEnabled()) {	
resolving location to registry item 

========================= synapse sample_3983 =========================

if(synCtx != null) {	MessageStore messageStore = synCtx.getConfiguration().getMessageStore(messageStoreName);	if(messageStore != null) {	if(onStoreSequence != null) {	Mediator sequence = synCtx.getSequence(onStoreSequence);	if(sequence != null) {	sequence.mediate(synCtx);	}	}	if(log.isDebugEnabled()) {	
message store mediator storing the message 

========================= synapse sample_565 =========================

public Integer getIntProperty(String name, Integer def) {	String val = System.getProperty(name);	if (val == null) {	val = props.getProperty(name);	}	if (val != null) {	int intVal;	try {	intVal = Integer.valueOf(val);	} catch (NumberFormatException e) {	
invalid http tuning property value must be an integer 

========================= synapse sample_2384 =========================

public boolean mediate(MessageContext synCtx) {	int parentsEffectiveTraceState = synCtx.getTracingState();	setEffectiveTraceState(synCtx);	int myEffectiveTraceState = synCtx.getTracingState();	try {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
sequence mediate 

public void init(SynapseEnvironment se) {	if (log.isDebugEnabled()) {	
initializing child mediators of mediator 

public void destroy() {	if (log.isDebugEnabled()) {	
destroying child mediators of mediator 

========================= synapse sample_1951 =========================

public void init(ConfigurationContext cfgCtx, TransportOutDescription transportOut) throws AxisFault {	super.init(cfgCtx, transportOut);	connectionFactoryES = Executors.newFixedThreadPool(AMQPTransportUtils.getIntProperty( AMQPTransportConstant.PARAM_CONNECTION_FACTORY_POOL_SIZE, AMQPTransportConstant.CONNECTION_FACTORY_POOL_DEFAULT));	responseHandlingPool = Executors.newFixedThreadPool(AMQPTransportUtils.getIntProperty( AMQPTransportConstant.PARAM_RESPONSE_HANDLING_POOL_SIZE, AMQPTransportConstant.RESPONSE_HANDLING_POOL_DEFAULT));	connectionFactoryManager = new AMQPTransportConnectionFactoryManager();	connectionFactoryManager.addConnectionFactories(transportOut, connectionFactoryES);	semaphoreTimeOut = AMQPTransportUtils.getLongProperty( AMQPTransportConstant.PARAM_SEMAPHORE_TIME_OUT, 86400L);	cache = new AMQPSenderCache(new ConcurrentHashMap<Integer, AMQPSender>());	responseTracker = new ConcurrentHashMap<String, Semaphore>();	responseMessage = new ConcurrentHashMap<String, AMQPTransportMessage>();	
amqp transport sender initializing 

public void stop() {	super.stop();	try {	connectionFactoryManager.shutDownConnectionFactories();	} catch (AMQPTransportException e) {	
error while shutting down connection factories continue anyway 

throw new AxisFault("Error while initiation tx for message '" + msgCtx.getMessageID() + "'", e);	}	}	amqpSender.sendAMQPMessage(msgCtx, correlationId, replyTo);	if (tx != null) {	try {	tx.end();	} catch (IOException e) {	throw new AxisFault("Error while terminating tx for message '" + msgCtx.getMessageID() + "'", e);	} catch (InterruptedException e) {	
error while terminating tx for message 

try {	available.tryAcquire(semaphoreTimeOut, TimeUnit.SECONDS);	} catch (InterruptedException e) {	Thread.currentThread().interrupt();	}	responseTracker.remove(correlationId);	AMQPTransportMessage msg = responseMessage.get(correlationId);	if (msg != null) {	handleSyncResponse(msgCtx, msg, msg.getContentType());	} else {	
the semaphore with id was time out while waiting for a response sending a fault to client 

private void sendFault(MessageContext msgContext, Exception e) {	try {	MessageContext faultContext = MessageContextBuilder.createFaultMessageContext( msgContext, e);	faultContext.setProperty("ERROR_MESSAGE", e.getMessage());	faultContext.setProperty("SENDING_FAULT", Boolean.TRUE);	AxisEngine.sendFault(faultContext);	} catch (AxisFault axisFault) {	
could not create the fault message 

========================= synapse sample_1052 =========================

if (!faultStack.isEmpty()) {	List<FaultHandler> newFaultStack = new ArrayList<FaultHandler>();	newFaultStack.addAll(faultStack);	for (FaultHandler faultHandler : newFaultStack) {	if (faultHandler != null) {	newCtx.pushFaultHandler(faultHandler);	}	}	}	if (log.isDebugEnabled()) {	
parent s fault stack child s fault stack 

========================= synapse sample_1681 =========================

String name = null;	if (faultMediator instanceof SequenceMediator) {	name = ((SequenceMediator) faultMediator).getName();	}	if (name == null) {	name = faultMediator.getClass().getName();	}	if (traceOrDebugOn) {	traceOrDebugWarn(traceOn, "Executing fault handler mediator : " + name);	}	
executing fault sequence mediator 

========================= synapse sample_3653 =========================

public static List<DataSourceInformation> createDataSourceInformationList( Properties dsProperties) {	final List<DataSourceInformation> dataSourceInformations = new ArrayList<DataSourceInformation>();	if (dsProperties == null) {	if (log.isDebugEnabled()) {	
datasource properties cannot be found 

public static List<DataSourceInformation> createDataSourceInformationList( Properties dsProperties) {	final List<DataSourceInformation> dataSourceInformations = new ArrayList<DataSourceInformation>();	if (dsProperties == null) {	if (log.isDebugEnabled()) {	}	return dataSourceInformations;	}	String dataSources = MiscellaneousUtil.getProperty(dsProperties, DataSourceConstants.PROP_SYNAPSE_PREFIX_DS, null);	if (dataSources == null || "".equals(dataSources)) {	if (log.isDebugEnabled()) {	
no datasources defined for initialization 

}	String dataSources = MiscellaneousUtil.getProperty(dsProperties, DataSourceConstants.PROP_SYNAPSE_PREFIX_DS, null);	if (dataSources == null || "".equals(dataSources)) {	if (log.isDebugEnabled()) {	}	return dataSourceInformations;	}	String[] dataSourcesNames = dataSources.split(",");	if (dataSourcesNames == null || dataSourcesNames.length == 0) {	if (log.isDebugEnabled()) {	
no datasource definitions found for initialization 

========================= synapse sample_709 =========================

public void testThrottling() {	String addUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to throttle mediator and concurrency throttling 

========================= synapse sample_820 =========================

}	for (Iterator itr = elem.getChildrenWithName(IMPLEMENTATION_Q); itr.hasNext();) {	OMElement implElem = (OMElement) itr.next();	OMAttribute typeAttr = implElem.getAttribute(ATT_TYPE);	OMAttribute sizeAttr = implElem.getAttribute(ATT_SIZE);	if (typeAttr != null && typeAttr.getAttributeValue() != null) {	String type = typeAttr.getAttributeValue();	if (CachingConstants.TYPE_MEMORY.equals(type) && sizeAttr != null && sizeAttr.getAttributeValue() != null) {	cache.setInMemoryCacheSize(Integer.parseInt(sizeAttr.getAttributeValue()));	} else if (CachingConstants.TYPE_DISK.equals(type)) {	
disk based and hirearchycal caching is not implemented yet 

========================= synapse sample_3583 =========================

public void testCallOutInlineEndpoint() {	
running test callout mediator invoke a service using an inline endpoint 

========================= synapse sample_2238 =========================

return entry.getValue();	} else if (!entry.isCached()) {	omNode = lookup(entry.getKey());	if (omNode == null) {	return null;	} else {	re = getRegistryEntry(entry.getKey());	}	} else if (entry.isExpired()) {	if (log.isDebugEnabled()) {	
cached object has expired for key 

return null;	} else {	re = getRegistryEntry(entry.getKey());	}	} else if (entry.isExpired()) {	if (log.isDebugEnabled()) {	}	re = getRegistryEntry(entry.getKey());	if (re.getVersion() != Long.MIN_VALUE && re.getVersion() == entry.getVersion()) {	if (log.isDebugEnabled()) {	
expired version number is same as current version in registry 

re = getRegistryEntry(entry.getKey());	if (re.getVersion() != Long.MIN_VALUE && re.getVersion() == entry.getVersion()) {	if (log.isDebugEnabled()) {	}	if (re.getCachableDuration() > 0) {	entry.setExpiryTime( System.currentTimeMillis() + re.getCachableDuration());	} else {	entry.setExpiryTime(-1);	}	if (log.isDebugEnabled()) {	
renew cache lease for another s 

========================= synapse sample_3700 =========================

public boolean mediate(MessageContext synCtx) {	
validatemediator validate mediator mediate 

handleException("Error accessing source element for validation : " + source, e);	}	try {	XMLReader reader = XMLReaderFactory.createXMLReader();	SAXSource saxSrc = new SAXSource(reader, new InputSource(baisFromSource));	synchronized (validatorLock) {	initialize(synCtx);	validator.validate(saxSrc);	if (errorHandler.isValidationError()) {	if (log.isDebugEnabled()) {	
validation of element returned by xpath failed against the given schemas with message executing on fail sequence 

handleException("Error accessing source element for validation : " + source, e);	}	try {	XMLReader reader = XMLReaderFactory.createXMLReader();	SAXSource saxSrc = new SAXSource(reader, new InputSource(baisFromSource));	synchronized (validatorLock) {	initialize(synCtx);	validator.validate(saxSrc);	if (errorHandler.isValidationError()) {	if (log.isDebugEnabled()) {	
failed message envelope 

trace.trace("Validation failed. Invoking the \"on-fail\" " + "sequence of mediators");	}	return super.mediate(synCtx);	}	}	} catch (SAXException e) {	handleException("Error validating " + source + " element" + e.getMessage(), e);	} catch (IOException e) {	handleException("Error validating " + source + " element" + e.getMessage(), e);	}	
validation of element returned by the xpath expression succeeded against the given schemas and the current message 

========================= synapse sample_3350 =========================

public void setName(String endpointName) {	this.endpointName = endpointName;	if (enableMBeanStats) {	if (endpointName == null || "".equals(endpointName.trim())) {	
endpoint name not found skipped jmx statistics collection for this endpoint 

}	}	if (errorHandler != null) {	Mediator errorHandlerMediator = synCtx.getSequence(errorHandler);	if (errorHandlerMediator != null) {	if (traceOrDebugOn) {	traceOrDebug(traceOn, "Setting the onError handler : " + errorHandler + " for the endpoint : " + endpointName);	}	synCtx.pushFaultHandler( new MediatorFaultHandler(errorHandlerMediator));	} else {	
onerror handler sequence for cannot be found 

protected boolean isTimeout(MessageContext synCtx) {	Integer errorCode = (Integer) synCtx.getProperty(SynapseConstants.ERROR_CODE);	if (errorCode != null) {	if (definition.getTimeoutErrorCodes().isEmpty()) {	boolean isTimeout = SynapseConstants.NHTTP_CONNECTION_TIMEOUT == errorCode;	boolean isClosed = SynapseConstants.NHTTP_CONNECTION_CLOSED == errorCode;	if (isTimeout || isClosed) {	if (log.isDebugEnabled()) {	
encountered a default http connection close timeout error 

boolean isTimeout = SynapseConstants.NHTTP_CONNECTION_TIMEOUT == errorCode;	boolean isClosed = SynapseConstants.NHTTP_CONNECTION_CLOSED == errorCode;	if (isTimeout || isClosed) {	if (log.isDebugEnabled()) {	}	return true;	}	} else {	if (definition.getTimeoutErrorCodes().contains(errorCode)) {	if (log.isDebugEnabled()) {	
encountered a mark for suspension error defined error codes are 

}	} else {	if (definition.getTimeoutErrorCodes().contains(errorCode)) {	if (log.isDebugEnabled()) {	}	return true;	}	}	}	if (log.isDebugEnabled()) {	
encountered a non timeout error sending to error code 

protected boolean isRetryDisabled(MessageContext synCtx) {	Integer errorCode = (Integer) synCtx.getProperty(SynapseConstants.ERROR_CODE);	if (errorCode != null && definition != null) {	if (definition.getRetryDisabledErrorCodes().contains(errorCode)) {	if (log.isDebugEnabled()) {	
encountered a retry disabled error defined retry disabled error codes are 

protected boolean isRetryDisabled(MessageContext synCtx) {	Integer errorCode = (Integer) synCtx.getProperty(SynapseConstants.ERROR_CODE);	if (errorCode != null && definition != null) {	if (definition.getRetryDisabledErrorCodes().contains(errorCode)) {	if (log.isDebugEnabled()) {	}	return true;	}	}	if (log.isDebugEnabled()) {	
encountered an error sending to endpoint with error code but not a retry disabled error 

protected boolean isSuspendFault(MessageContext synCtx) {	Integer errorCode = (Integer) synCtx.getProperty(SynapseConstants.ERROR_CODE);	if (errorCode != null) {	if (definition.getSuspendErrorCodes().isEmpty()) {	if (log.isDebugEnabled()) {	
encountered a fatal error 

protected boolean isSuspendFault(MessageContext synCtx) {	Integer errorCode = (Integer) synCtx.getProperty(SynapseConstants.ERROR_CODE);	if (errorCode != null) {	if (definition.getSuspendErrorCodes().isEmpty()) {	if (log.isDebugEnabled()) {	}	return true;	} else {	if (definition.getSuspendErrorCodes().contains(errorCode)) {	if (log.isDebugEnabled()) {	
encountered a suspend error defined suspend codes are 

return true;	} else {	if (definition.getSuspendErrorCodes().contains(errorCode)) {	if (log.isDebugEnabled()) {	}	return true;	}	}	}	if (log.isDebugEnabled()) {	
encountered a non fatal error sending to error code error will be handled but endpoint will not fail 

protected void informFailure(MessageContext synCtx, int errorCode, String errorMsg) {	
endpoint failure error code error message 

========================= synapse sample_1678 =========================

private void scanFileOrDirectory(final PollTableEntry entry, String fileURI) {	FileObject fileObject = null;	if (log.isDebugEnabled()) {	
scanning directory or file 

}	boolean wasError = true;	int retryCount = 0;	int maxRetryCount = entry.getMaxRetryCount();	long reconnectionTimeout = entry.getReconnectTimeout();	while (wasError) {	try {	retryCount++;	fileObject = fsManager.resolveFile(fileURI);	if (fileObject == null) {	
fileobject is null 

fileObject = fsManager.resolveFile(fileURI);	if (fileObject == null) {	throw new FileSystemException("fileObject is null");	}	wasError = false;	} catch (FileSystemException e) {	if (retryCount >= maxRetryCount) {	processFailure("Repeatedly failed to resolve the file URI: " + VFSUtils.maskURLPassword(fileURI), e, entry);	return;	} else {	
failed to resolve the file uri in attempt retrying in milliseconds 

if (retryCount >= maxRetryCount) {	processFailure("Repeatedly failed to resolve the file URI: " + VFSUtils.maskURLPassword(fileURI), e, entry);	return;	} else {	}	}	if (wasError) {	try {	Thread.sleep(reconnectionTimeout);	} catch (InterruptedException e2) {	
thread was interrupted while waiting to reconnect 

moveOrDeleteAfterProcessing(entry, fileObject);	} catch (AxisFault axisFault) {	logException("File object '" + fileObject.getURL().toString() + "' " + "cloud not be moved", axisFault);	entry.setLastPollState(PollTableEntry.FAILED);	String timeStamp = VFSUtils.getSystemTime(entry.getFailedRecordTimestampFormat());	addFailedRecord(entry, fileObject, timeStamp);	}	if (entry.isFileLockingEnabled()) {	VFSUtils.releaseLock(fsManager, fileObject);	if (log.isDebugEnabled()) {	
removed the lock file lock of the file 

entry.setLastPollState(PollTableEntry.FAILED);	String timeStamp = VFSUtils.getSystemTime(entry.getFailedRecordTimestampFormat());	addFailedRecord(entry, fileObject, timeStamp);	}	if (entry.isFileLockingEnabled()) {	VFSUtils.releaseLock(fsManager, fileObject);	if (log.isDebugEnabled()) {	}	}	} else if (log.isDebugEnabled()) {	
couldn t get the lock for processing the file 

}	} else if (log.isDebugEnabled()) {	} else if (isFailedRecord) {	if (entry.isFileLockingEnabled()) {	VFSUtils.releaseLock(fsManager, fileObject);	}	if (fsManager.resolveFile(fileObject.getURL().toString()) != null && removeTaskState == STATE_STOPPED && entry.getMoveAfterMoveFailure() != null) {	workerPool.execute(new FileRemoveTask(entry, fileObject));	}	if (log.isDebugEnabled()) {	
file has been marked as a failed record it will not process 

workerPool.execute(new FileRemoveTask(entry, fileObject));	}	if (log.isDebugEnabled()) {	}	}	}	} else {	int failCount = 0;	int successCount = 0;	if (log.isDebugEnabled()) {	
file name pattern 

int successCount = 0;	if (log.isDebugEnabled()) {	}	for (FileObject child : children) {	boolean isFailedRecord = false;	if (entry.getMoveAfterMoveFailure() != null) {	isFailedRecord = isFailedRecord(child, entry);	}	if (entry.getFileNamePattern() != null && child.getName().getBaseName().matches(entry.getFileNamePattern())){	if (log.isDebugEnabled()) {	
matching file 

boolean isFailedRecord = false;	if (entry.getMoveAfterMoveFailure() != null) {	isFailedRecord = isFailedRecord(child, entry);	}	if (entry.getFileNamePattern() != null && child.getName().getBaseName().matches(entry.getFileNamePattern())){	if (log.isDebugEnabled()) {	}	if ((!entry.isFileLockingEnabled() || (entry.isFileLockingEnabled() && VFSUtils.acquireLock(fsManager, child))) && !isFailedRecord){	try {	if (log.isDebugEnabled()) {	
processing file 

String timeStamp = VFSUtils.getSystemTime(entry.getFailedRecordTimestampFormat());	addFailedRecord(entry, child, timeStamp);	} finally {	if (entry.isFileLockingEnabled()) {	VFSUtils.releaseLock(fsManager, child);	}	}	}	} else if (entry.getFileNamePattern()!= null && !child.getName().getBaseName().matches(entry.getFileNamePattern())){	if (log.isDebugEnabled()) {	
non matching file 

}	} else if(isFailedRecord){	if (entry.isFileLockingEnabled()) {	VFSUtils.releaseLock(fsManager, child);	VFSUtils.releaseLock(fsManager, fileObject);	}	if (fsManager.resolveFile(child.getURL().toString()) != null && removeTaskState == STATE_STOPPED && entry.getMoveAfterMoveFailure() != null) {	workerPool.execute(new FileRemoveTask(entry, child));	}	if (log.isDebugEnabled()) {	
file has been marked as a failed record it will not process 

} else if (successCount == 0 && failCount > 0) {	entry.setLastPollState(PollTableEntry.FAILED);	} else {	entry.setLastPollState(PollTableEntry.WITH_ERRORS);	}	}	long now = System.currentTimeMillis();	entry.setLastPollTime(now);	entry.setNextPollTime(now + entry.getPollInterval());	} else if (log.isDebugEnabled()) {	
unable to access or read file or directory reason unknown reason the file can not be read the file does not exists 

if (moveToDirectoryURI != null) {	FileObject moveToDirectory = fsManager.resolveFile(moveToDirectoryURI);	String prefix;	if(entry.getMoveTimestampFormat() != null) {	prefix = entry.getMoveTimestampFormat().format(new Date());	} else {	prefix = "";	}	FileObject dest = moveToDirectory.resolveFile( prefix + fileObject.getName().getBaseName());	if (log.isDebugEnabled()) {	
moving to file 

if (log.isDebugEnabled()) {	}	try {	fileObject.moveTo(dest);	} catch (FileSystemException e) {	handleException("Error moving file : " + fileObject + " to " + moveToDirectoryURI, e);	}	} else {	try {	if (log.isDebugEnabled()) {	
deleting file 

try {	if (log.isDebugEnabled()) {	}	fileObject.close();	if (!fileObject.delete()) {	String msg = "Cannot delete file : " + fileObject;	log.error(msg);	throw new AxisFault(msg);	}	} catch (FileSystemException e) {	
error deleting file 

fileObject.close();	if (!fileObject.delete()) {	String msg = "Cannot delete file : " + fileObject;	log.error(msg);	throw new AxisFault(msg);	}	} catch (FileSystemException e) {	}	}	} catch (FileSystemException e) {	
error resolving directory to move after processing 

contentType = VFSUtils.getProperty(content, BaseConstants.CONTENT_TYPE);	}	}	msgContext.removeProperty(msgContext.CLIENT_API_NON_BLOCKING);	String replyFileURI = entry.getReplyFileURI();	if (replyFileURI != null) {	msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, new VFSOutTransportInfo(replyFileURI, entry.isFileLockingEnabled()));	}	Builder builder;	if (contentType == null) {	
no content type specified using soap builder 

}	Builder builder;	if (contentType == null) {	builder = new SOAPBuilder();	} else {	int index = contentType.indexOf(';');	String type = index > 0 ? contentType.substring(0, index) : contentType;	builder = BuilderUtil.getBuilderFromSelector(type, msgContext);	if (builder == null) {	if (log.isDebugEnabled()) {	
no message builder found for type falling back to soap 

documentElement = ((DataSourceMessageBuilder)builder).processDocument( dataSource, contentType, msgContext);	}	msgContext.setEnvelope(TransportUtils.createSOAPEnvelope(documentElement));	handleIncomingMessage( msgContext, transportHeaders, null, contentType );	} finally {	if (dataSource != null) {	dataSource.destroy();	}	}	if (log.isDebugEnabled()) {	
processed file of content type 

private synchronized void addFailedRecord(PollTableEntry pollTableEntry, FileObject failedObject, String timeString) {	try {	String record = failedObject.getName().getBaseName() + VFSConstants.FAILED_RECORD_DELIMITER + timeString;	String recordFile = pollTableEntry.getFailedRecordFileDestination() + pollTableEntry.getFailedRecordFileName();	File failedRecordFile = new File(recordFile);	if (!failedRecordFile.exists()) {	FileUtils.writeStringToFile(failedRecordFile, record);	if (log.isDebugEnabled()) {	
added fail record into the record file 

if (log.isDebugEnabled()) {	}	} else {	List<String> content = FileUtils.readLines(failedRecordFile);	if (!content.contains(record)) {	content.add(record);	}	FileUtils.writeLines(failedRecordFile, content);	}	} catch (IOException e) {	
failure while writing the failed records 

List list = FileUtils.readLines(file);	for (Object aList : list) {	String str = (String) aList;	StringTokenizer st = new StringTokenizer(str, VFSConstants.FAILED_RECORD_DELIMITER);	String fileName = st.nextToken();	if (fileName != null && fileName.equals(fileObject.getName().getBaseName())) {	return true;	}	}	} catch (IOException e) {	
error while reading the file 

public void run() {	if (log.isDebugEnabled()) {	
new file remove task is starting thread id 

int nextRetryDuration = pollTableEntry.getNextRetryDuration();	int count = 0;	while (!isDeletionSucceed) {	try {	reTryFailedMove(pollTableEntry, failedFileObject);	isDeletionSucceed = true;	removeTaskState = STATE_STOPPED;	} catch (AxisFault axisFault) {	removeTaskState = STATE_RUNNING;	try {	
remove attempt failed for the file next re try will be after milliseconds 

int count = 0;	while (!isDeletionSucceed) {	try {	reTryFailedMove(pollTableEntry, failedFileObject);	isDeletionSucceed = true;	removeTaskState = STATE_STOPPED;	} catch (AxisFault axisFault) {	removeTaskState = STATE_RUNNING;	try {	} catch (FileSystemException e) {	
error while retrying the file url of the file object 

moveToDirectory.createFolder();	}	String prefix;	if (entry.getMoveTimestampFormat() != null) {	prefix = entry.getMoveTimestampFormat().format(new Date());	} else {	prefix = "";	}	FileObject dest = moveToDirectory.resolveFile( prefix + fileObject.getName().getBaseName());	if (log.isDebugEnabled()) {	
the failed file is moving to 

========================= synapse sample_898 =========================

public void testMTOMOptimization() {	String ep = "http: String currentLocation = System.getProperty("user.dir") + File.separator;	String filename = FilenameUtils.normalize( currentLocation + "repository/conf/sample/resources/mtom/asf-logo.gif");	MTOMSwASampleClient client = getMTOMSwASampleClient();	
running test mtom optimization and request response correlation 

public void testSWAOptimization() {	String ep = "http: String currentLocation = System.getProperty("user.dir") + File.separator;	String filename = FilenameUtils.normalize( currentLocation + "repository/conf/sample/resources/mtom/asf-logo.gif");	MTOMSwASampleClient client = getMTOMSwASampleClient();	
running test swa optimization and request response correlation 

========================= synapse sample_2280 =========================

protected void processStatement(Statement stmnt, MessageContext msgCtx) {	SynapseLog synLog = getLog(msgCtx);	Connection con = null;	ResultSet rs = null;	try {	con = this.getDataSource().getConnection();	PreparedStatement ps = getPreparedStatement(stmnt, con, msgCtx);	rs = ps.executeQuery();	if (rs.next()) {	if (synLog.isTraceOrDebugEnabled()) {	
processing the first row returned 

String columnStr =  stmnt.getResultsMap().get(propName);	Object obj;	try {	int colNum = Integer.parseInt(columnStr);	obj = rs.getObject(colNum);	} catch (NumberFormatException ignore) {	obj = rs.getObject(columnStr);	}	if (obj != null) {	if (synLog.isTraceOrDebugEnabled()) {	
column returned value setting this as the message property 

obj = rs.getObject(colNum);	} catch (NumberFormatException ignore) {	obj = rs.getObject(columnStr);	}	if (obj != null) {	if (synLog.isTraceOrDebugEnabled()) {	}	msgCtx.setProperty(propName, obj.toString());	} else {	if (synLog.isTraceOrDebugEnabled()) {	
column returned null skip setting message property 

if (synLog.isTraceOrDebugEnabled()) {	}	msgCtx.setProperty(propName, obj.toString());	} else {	if (synLog.isTraceOrDebugEnabled()) {	}	}	}	} else {	if (synLog.isTraceOrDebugEnabled()) {	
statement returned rows 

========================= synapse sample_524 =========================

public boolean mediate(SynapseContext synCtx) {	
mediate 

========================= synapse sample_2795 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
sequence deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	Mediator m = MediatorFactoryFinder.getInstance().getMediator( artifactConfig, properties);	if (m instanceof SequenceMediator) {	SequenceMediator seq = (SequenceMediator) m;	seq.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
sequence named has been built from the file 

}	try {	Mediator m = MediatorFactoryFinder.getInstance().getMediator( artifactConfig, properties);	if (m instanceof SequenceMediator) {	SequenceMediator seq = (SequenceMediator) m;	seq.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	seq.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	
initialized the sequence 

if (m instanceof SequenceMediator) {	SequenceMediator seq = (SequenceMediator) m;	seq.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	seq.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addSequence(seq.getName(), seq);	if (log.isDebugEnabled()) {	
sequence deployment from file completed 

SequenceMediator seq = (SequenceMediator) m;	seq.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	seq.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addSequence(seq.getName(), seq);	if (log.isDebugEnabled()) {	}	
sequence named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
sequence update from file has started 

if (m == null || !(m instanceof  SequenceMediator)) {	handleSynapseArtifactDeploymentError("Sequence update failed. The artifact " + "defined in the file: " + fileName + " is not a valid sequence.");	return null;	}	SequenceMediator seq = (SequenceMediator) m;	seq.setFileName(new File(fileName).getName());	if ((SynapseConstants.MAIN_SEQUENCE_KEY.equals(existingArtifactName) || SynapseConstants.FAULT_SEQUENCE_KEY.equals(existingArtifactName)) && !existingArtifactName.equals(seq.getName())) {	handleSynapseArtifactDeploymentError(existingArtifactName + " sequence cannot be renamed");	}	if (log.isDebugEnabled()) {	
sequence has been built from the file 

}	if (log.isDebugEnabled()) {	}	seq.init(getSynapseEnvironment());	SequenceMediator existingSeq = getSynapseConfiguration().getDefinedSequences(). get(existingArtifactName);	if (existingArtifactName.equals(seq.getName())) {	getSynapseConfiguration().updateSequence(existingArtifactName, seq);	} else {	getSynapseConfiguration().addSequence(seq.getName(), seq);	getSynapseConfiguration().removeSequence(existingArtifactName);	
sequence has been undeployed 

if (log.isDebugEnabled()) {	}	seq.init(getSynapseEnvironment());	SequenceMediator existingSeq = getSynapseConfiguration().getDefinedSequences(). get(existingArtifactName);	if (existingArtifactName.equals(seq.getName())) {	getSynapseConfiguration().updateSequence(existingArtifactName, seq);	} else {	getSynapseConfiguration().addSequence(seq.getName(), seq);	getSynapseConfiguration().removeSequence(existingArtifactName);	}	
sequence has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
sequence undeployment of the sequence named started 

if (log.isDebugEnabled()) {	}	try {	SequenceMediator seq = getSynapseConfiguration().getDefinedSequences().get(artifactName);	if (seq != null) {	if (SynapseConstants.MAIN_SEQUENCE_KEY.equals(seq.getName()) || SynapseConstants.FAULT_SEQUENCE_KEY.equals(seq.getName())) {	handleSynapseArtifactDeploymentError( "Cannot Undeploy the " + seq.getName() + " sequence");	}	getSynapseConfiguration().removeSequence(artifactName);	if (log.isDebugEnabled()) {	
destroying the sequence named 

SequenceMediator seq = getSynapseConfiguration().getDefinedSequences().get(artifactName);	if (seq != null) {	if (SynapseConstants.MAIN_SEQUENCE_KEY.equals(seq.getName()) || SynapseConstants.FAULT_SEQUENCE_KEY.equals(seq.getName())) {	handleSynapseArtifactDeploymentError( "Cannot Undeploy the " + seq.getName() + " sequence");	}	getSynapseConfiguration().removeSequence(artifactName);	if (log.isDebugEnabled()) {	}	seq.destroy();	if (log.isDebugEnabled()) {	
sequence undeployment of the sequence named completed 

if (seq != null) {	if (SynapseConstants.MAIN_SEQUENCE_KEY.equals(seq.getName()) || SynapseConstants.FAULT_SEQUENCE_KEY.equals(seq.getName())) {	handleSynapseArtifactDeploymentError( "Cannot Undeploy the " + seq.getName() + " sequence");	}	getSynapseConfiguration().removeSequence(artifactName);	if (log.isDebugEnabled()) {	}	seq.destroy();	if (log.isDebugEnabled()) {	}	
sequence named has been undeployed 

if (SynapseConstants.MAIN_SEQUENCE_KEY.equals(seq.getName()) || SynapseConstants.FAULT_SEQUENCE_KEY.equals(seq.getName())) {	handleSynapseArtifactDeploymentError( "Cannot Undeploy the " + seq.getName() + " sequence");	}	getSynapseConfiguration().removeSequence(artifactName);	if (log.isDebugEnabled()) {	}	seq.destroy();	if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
sequence has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the sequence with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	SequenceMediator seq = getSynapseConfiguration().getDefinedSequences().get(artifactName);	OMElement seqElem = MediatorSerializerFinder.getInstance().getSerializer(seq). serializeMediator(null, seq);	if (seq.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.SEQUENCES_DIR + File.separator + seq.getFileName();	writeToFile(seqElem, fileName);	if (log.isDebugEnabled()) {	
restoring the sequence with name completed 

if (log.isDebugEnabled()) {	}	try {	SequenceMediator seq = getSynapseConfiguration().getDefinedSequences().get(artifactName);	OMElement seqElem = MediatorSerializerFinder.getInstance().getSerializer(seq). serializeMediator(null, seq);	if (seq.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.SEQUENCES_DIR + File.separator + seq.getFileName();	writeToFile(seqElem, fileName);	if (log.isDebugEnabled()) {	}	
sequence named has been restored 

========================= synapse sample_174 =========================

public void sequenceAdded(Mediator sequence) {	
sequence was added to the synapse configuration successfully 

public void sequenceRemoved(Mediator sequence) {	
sequence was removed from the synapse configuration successfully 

public void sequenceTemplateAdded(Mediator template) {	
template was added to the synapse configuration successfully 

public void sequenceTemplateRemoved(Mediator template) {	
template was removed to the synapse configuration successfully 

public void entryAdded(Entry entry) {	
local entry was added to the synapse configuration successfully 

public void entryRemoved(Entry entry) {	
local entry was removed from the synapse configuration successfully 

public void endpointAdded(Endpoint endpoint) {	
endpoint was added to the synapse configuration successfully 

public void endpointRemoved(Endpoint endpoint) {	
endpoint was removed from the synapse configuration successfully 

public void proxyServiceAdded(ProxyService proxy) {	
proxy service was added to the synapse configuration successfully 

public void proxyServiceRemoved(ProxyService proxy) {	
proxy service was removed from the synapse configuration successfully 

public void startupAdded(Startup startup) {	
startup was added to the synapse configuration successfully 

public void startupRemoved(Startup startup) {	
startup was removed from the synapse configuration successfully 

public void eventSourceAdded(SynapseEventSource eventSource) {	
event source was added to the synapse configuration successfully 

public void eventSourceRemoved(SynapseEventSource eventSource) {	
event source was removed from the synapse configuration successfully 

public void priorityExecutorAdded(PriorityExecutor exec) {	
priority executor was added to the synapse configuration successfully 

public void priorityExecutorRemoved(PriorityExecutor exec) {	
priority executor was removed from the synapse configuration successfully 

========================= synapse sample_1910 =========================

public boolean startProcess() {	try {	requestListener = new RequestListenerThread(port, echoHeaders);	requestListener.start();	return true;	} catch (IOException e) {	
error while initializing echo server 

public void run() {	
listening on port 

Socket socket = this.serversocket.accept();	HttpServerConnection conn = this.connFactory.createConnection(socket);	Thread t = new WorkerThread(this.httpService, conn, counter.incrementAndGet());	t.start();	} catch (InterruptedIOException ex) {	break;	} catch (IOException e) {	if (Thread.interrupted()) {	break;	}	
i o error initializing connection thread 

public void halt() {	
shutting down echo server 

try {	this.interrupt();	this.serversocket.close();	while (this.isAlive() || !this.serversocket.isClosed()) {	try {	Thread.sleep(100);	} catch (InterruptedException ignored) {	}	}	} catch (IOException e) {	
error while shutting down echo server 

public void run() {	HttpContext context = new BasicHttpContext(null);	try {	while (!Thread.interrupted() && this.conn.isOpen()) {	this.httpservice.handleRequest(this.conn, context);	}	} catch (ConnectionClosedException ex) {	
client closed the connection 

public void run() {	HttpContext context = new BasicHttpContext(null);	try {	while (!Thread.interrupted() && this.conn.isOpen()) {	this.httpservice.handleRequest(this.conn, context);	}	} catch (ConnectionClosedException ex) {	} catch (IOException ex) {	
i o error 

public void run() {	HttpContext context = new BasicHttpContext(null);	try {	while (!Thread.interrupted() && this.conn.isOpen()) {	this.httpservice.handleRequest(this.conn, context);	}	} catch (ConnectionClosedException ex) {	} catch (IOException ex) {	} catch (HttpException ex) {	
unrecoverable http protocol violation 

========================= synapse sample_877 =========================

public static IdentityKeyStoreInformation createIdentityKeyStoreInformation(Properties properties) {	String keyStoreLocation = MiscellaneousUtil.getProperty( properties, IDENTITY_KEY_STORE, null);	if (keyStoreLocation == null || "".equals(keyStoreLocation)) {	if (log.isDebugEnabled()) {	
cannot find a keystorelocation for private key store 

public static TrustKeyStoreInformation createTrustKeyStoreInformation(Properties properties) {	String keyStoreLocation = MiscellaneousUtil.getProperty(properties, TRUST_STORE, null);	if (keyStoreLocation == null || "".equals(keyStoreLocation)) {	if (log.isDebugEnabled()) {	
cannot find a keystorelocation for trust store 

private static void parseParameter(String parameterString, KeyStoreInformation information) {	if (parameterString == null || "".equals(parameterString)) {	if (log.isDebugEnabled()) {	
no additional parameter for keystore 

private static void parseParameter(String parameterString, KeyStoreInformation information) {	if (parameterString == null || "".equals(parameterString)) {	if (log.isDebugEnabled()) {	}	return;	}	String[] parameterPairs = parameterString.split(";");	if (parameterPairs == null) {	if (log.isDebugEnabled()) {	
no additional parameter for keystore 

String[] parameterPairs = parameterString.split(";");	if (parameterPairs == null) {	if (log.isDebugEnabled()) {	}	return;	}	for (String parameterPairString : parameterPairs) {	String[] values = parameterPairString.split("=");	if (values == null || values.length != 2) {	if (log.isDebugEnabled()) {	
a parameter with no name value pair has been found 

========================= synapse sample_2516 =========================

ObjectName name = new ObjectName(getObjectName(category, id));	Set set = mbs.queryNames(name, null);	if (set != null && set.isEmpty()) {	mbs.registerMBean(mBeanInstance, name);	} else {	mbs.unregisterMBean(name);	mbs.registerMBean(mBeanInstance, name);	}	return true;	} catch (Exception e) {	
error registering a mbean with name and category name for jmx management 

public boolean unRegisterMBean(String category, String id) {	try {	MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();	ObjectName objName = new ObjectName(getObjectName(category, id));	if (mbs.isRegistered(objName)) {	mbs.unregisterMBean(objName);	return true;	}	} catch (Exception e) {	
error un registering a mbean with name and category name for jmx management 

========================= synapse sample_2146 =========================

public Object call(Context context, List args) throws FunctionCallException {	if (args.isEmpty()) {	
property key value for lookup was not specified 

public Object call(Context context, List args) throws FunctionCallException {	if (args.isEmpty()) {	return null;	} else if (synCtx == null) {	
synapse context has not been set for the xpath extension function synapse get property prop name 

========================= synapse sample_3307 =========================

public void connected(final NHttpServerConnection conn) {	if (this.log.isDebugEnabled()) {	
http connection connected 

public void closed(final NHttpServerConnection conn) {	if (this.log.isDebugEnabled()) {	
http connection closed 

public void exception(final NHttpServerConnection conn, final IOException ex) {	if (ex instanceof ConnectionClosedException || ex.getMessage().contains("Connection reset by peer") || ex.getMessage().contains("forcibly closed")) {	if (this.log.isDebugEnabled()) {	
http connection probably the keepalive connection was closed 

public void exception(final NHttpServerConnection conn, final IOException ex) {	if (ex instanceof ConnectionClosedException || ex.getMessage().contains("Connection reset by peer") || ex.getMessage().contains("forcibly closed")) {	if (this.log.isDebugEnabled()) {	}	} else {	
http connection 

public void exception(final NHttpServerConnection conn, final HttpException ex) {	
http connection 

public void requestReceived(final NHttpServerConnection conn) {	HttpRequest request = conn.getHttpRequest();	if (this.log.isDebugEnabled()) {	
http connection 

public void outputReady(final NHttpServerConnection conn, final ContentEncoder encoder) {	if (this.log.isDebugEnabled()) {	
http connection output ready 

public void outputReady(final NHttpServerConnection conn, final ContentEncoder encoder) {	if (this.log.isDebugEnabled()) {	}	this.handler.outputReady(conn, encoder);	if (this.log.isDebugEnabled()) {	
http connection content encoder 

public void responseReady(final NHttpServerConnection conn) {	if (this.log.isDebugEnabled()) {	
http connection response ready 

public void inputReady(final NHttpServerConnection conn, final ContentDecoder decoder) {	if (this.log.isDebugEnabled()) {	
http connection input ready 

public void inputReady(final NHttpServerConnection conn, final ContentDecoder decoder) {	if (this.log.isDebugEnabled()) {	}	this.handler.inputReady(conn, decoder);	if (this.log.isDebugEnabled()) {	
http connection content decoder 

public void timeout(final NHttpServerConnection conn) {	if (this.log.isDebugEnabled()) {	
http connection timeout 

========================= synapse sample_3757 =========================

public void stop() {	if (state == State.START) {	try {	if (scheduler != null && scheduler.isStarted()) {	if (log.isDebugEnabled()) {	
shuttingdown message processor scheduler 

public void init(SynapseEnvironment se) {	super.init(se);	StdSchedulerFactory sf = new StdSchedulerFactory();	try {	if (quartzConfig != null && !"".equals(quartzConfig)) {	if (log.isDebugEnabled()) {	
initiating a scheduler with configuration 

public void destroy() {	try {	scheduler.deleteJob( new JobKey(name + "-trigger",SCHEDULED_MESSAGE_PROCESSOR_GROUP));	scheduler.shutdown(true);	} catch (SchedulerException e) {	
error while destroying the task 

========================= synapse sample_2003 =========================

public void setAlgorithm(String algorithm) {	if (algorithm == null || "".equals(algorithm)) {	
given algorithm is null using a default one rsa 

========================= synapse sample_2517 =========================

public void addProcessor(Processor p) {	
adding processor with name 

public void addProcessor(Processor p) {	
name already present 

========================= synapse sample_4586 =========================

private boolean createCases(SwitchMediator switchMediator, String caseItr) {	String[] caseSet = caseItr.split(DELIMITER_2);	if (caseSet.length == 0) {	
no definitions found for dynamic routing 

========================= synapse sample_2002 =========================

public boolean mediate(SynapseContext synCtx) {	
mediate 

public boolean mediate(SynapseContext synCtx) {	log.debug("Sending To: " + (synCtx.getSynapseMessage().getTo() != null ? synCtx.getSynapseMessage().getTo().getAddress() : "null"));	
body 

========================= synapse sample_2794 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
synapse import deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	SynapseImport synImport = SynapseImportFactory.createImport(artifactConfig, properties);	String synImportQualfiedName = LibDeployerUtils.getQualifiedName(synImport);	SynapseImport existingImport = getSynapseConfiguration().getSynapseImports().get(synImportQualfiedName);	if (existingImport != null) {	
synapse import with the name already exists could not load multiple imports of same type 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	SynapseImport synImport = SynapseImportFactory.createImport(artifactConfig, properties);	String synImportQualfiedName = LibDeployerUtils.getQualifiedName(synImport);	SynapseImport existingImport = getSynapseConfiguration().getSynapseImports().get(synImportQualfiedName);	if (existingImport != null) {	String backedUp = backupFile(new File(fileName));	
synapse import with the name is now backed up in 

String backedUp = backupFile(new File(fileName));	return null;	} else {	if (synImport != null) {	synImport.setFileName((new File(fileName)).getName());	getSynapseConfiguration().addSynapseImport(synImportQualfiedName, synImport);	Library synLib = getSynapseConfiguration().getSynapseLibraries() .get(synImportQualfiedName);	if (synLib != null) {	LibDeployerUtils.loadLibArtifacts(synImport, synLib);	}	
synapse library import named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
synapse import deployment from file started 

if (log.isDebugEnabled()) {	}	try {	SynapseImport synImport = SynapseImportFactory.createImport(artifactConfig, properties);	String synImportQualfiedName = LibDeployerUtils.getQualifiedName(synImport);	if (synImport == null) {	handleSynapseArtifactDeploymentError("Synapse Import update failed. The artifact " + "defined in the file: " + fileName + " is not a valid import.");	return null;	}	if (log.isDebugEnabled()) {	
synapse import has been built from the file 

if (log.isDebugEnabled()) {	}	if (existingArtifactName.equals(synImportQualfiedName)) {	synImport.setFileName((new File(fileName)).getName());	getSynapseConfiguration().addSynapseImport(synImportQualfiedName, synImport);	Library synLib = getSynapseConfiguration().getSynapseLibraries() .get(synImportQualfiedName);	if (synLib != null) {	synLib.unLoadLibrary();	LibDeployerUtils.loadLibArtifacts(synImport, synLib);	}	
synapse library import named has been deployed from file 

synImport.setFileName((new File(fileName)).getName());	getSynapseConfiguration().addSynapseImport(synImportQualfiedName, synImport);	Library synLib = getSynapseConfiguration().getSynapseLibraries() .get(synImportQualfiedName);	if (synLib != null) {	synLib.unLoadLibrary();	LibDeployerUtils.loadLibArtifacts(synImport, synLib);	}	} else {	SynapseImport existingImport = getSynapseConfiguration().getSynapseImports().get(synImportQualfiedName);	if (existingImport != null) {	
synapse import with the name already exists could not load multiple imports of same type 

getSynapseConfiguration().addSynapseImport(synImportQualfiedName, synImport);	Library synLib = getSynapseConfiguration().getSynapseLibraries() .get(synImportQualfiedName);	if (synLib != null) {	synLib.unLoadLibrary();	LibDeployerUtils.loadLibArtifacts(synImport, synLib);	}	} else {	SynapseImport existingImport = getSynapseConfiguration().getSynapseImports().get(synImportQualfiedName);	if (existingImport != null) {	String backedUp = backupFile(new File(fileName));	
synapse import with the name is now backed up in 

SynapseImport existingImport = getSynapseConfiguration().getSynapseImports().get(synImportQualfiedName);	if (existingImport != null) {	String backedUp = backupFile(new File(fileName));	return null;	}else {	synImport.setFileName((new File(fileName)).getName());	getSynapseConfiguration().addSynapseImport(synImportQualfiedName, synImport);	Library synLib = getSynapseConfiguration().getSynapseLibraries() .get(synImportQualfiedName);	synLib.unLoadLibrary();	LibDeployerUtils.loadLibArtifacts(synImport, synLib);	
synapse library import named has been deployed from file 

String backedUp = backupFile(new File(fileName));	return null;	}else {	synImport.setFileName((new File(fileName)).getName());	getSynapseConfiguration().addSynapseImport(synImportQualfiedName, synImport);	Library synLib = getSynapseConfiguration().getSynapseLibraries() .get(synImportQualfiedName);	synLib.unLoadLibrary();	LibDeployerUtils.loadLibArtifacts(synImport, synLib);	}	}	
synapse import has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
undeployment of the synapse import named started 

if (log.isDebugEnabled()) {	}	try {	SynapseImport undeployingImport = getSynapseConfiguration().getSynapseImports().get(artifactName);	if (undeployingImport != null) {	getSynapseConfiguration().removeSynapseImport(artifactName);	Library synLib = getSynapseConfiguration().getSynapseLibraries().get(artifactName);	if (synLib != null) {	synLib.unLoadLibrary();	}	
synapse import has been undeployed 

}	try {	SynapseImport undeployingImport = getSynapseConfiguration().getSynapseImports().get(artifactName);	if (undeployingImport != null) {	getSynapseConfiguration().removeSynapseImport(artifactName);	Library synLib = getSynapseConfiguration().getSynapseLibraries().get(artifactName);	if (synLib != null) {	synLib.unLoadLibrary();	}	} else {	
synapse import has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the sequence with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	SequenceMediator seq = getSynapseConfiguration().getDefinedSequences().get(artifactName);	OMElement seqElem = MediatorSerializerFinder.getInstance().getSerializer(seq). serializeMediator(null, seq);	if (seq.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.SEQUENCES_DIR + File.separator + seq.getFileName();	writeToFile(seqElem, fileName);	if (log.isDebugEnabled()) {	
restoring the sequence with name completed 

if (log.isDebugEnabled()) {	}	try {	SequenceMediator seq = getSynapseConfiguration().getDefinedSequences().get(artifactName);	OMElement seqElem = MediatorSerializerFinder.getInstance().getSerializer(seq). serializeMediator(null, seq);	if (seq.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.SEQUENCES_DIR + File.separator + seq.getFileName();	writeToFile(seqElem, fileName);	if (log.isDebugEnabled()) {	}	
sequence named has been restored 

========================= synapse sample_175 =========================

public boolean process(SynapseEnvironment se, SynapseMessage smc) {	
process 

========================= synapse sample_4640 =========================

return null;	}	OMNode result = null;	if (inputStream != null) {	try {	XMLStreamReader parser = XMLInputFactory.newInstance(). createXMLStreamReader(inputStream);	StAXOMBuilder builder = new StAXOMBuilder(parser);	result = builder.getDocumentElement();	} catch (OMException ignored) {	if (log.isDebugEnabled()) {	
the resource at the provided url isn t well formed xml so takes it as a text 

try {	XMLStreamReader parser = XMLInputFactory.newInstance(). createXMLStreamReader(inputStream);	StAXOMBuilder builder = new StAXOMBuilder(parser);	result = builder.getDocumentElement();	} catch (OMException ignored) {	if (log.isDebugEnabled()) {	}	try {	inputStream.close();	} catch (IOException e) {	
error in closing the input stream 

} catch (OMException ignored) {	if (log.isDebugEnabled()) {	}	try {	inputStream.close();	} catch (IOException e) {	}	result = SynapseConfigUtils.readNonXML(url);	} catch (XMLStreamException ignored) {	if (log.isDebugEnabled()) {	
the resource at the provided url isn t well formed xml so takes it as a text 

inputStream.close();	} catch (IOException e) {	}	result = SynapseConfigUtils.readNonXML(url);	} catch (XMLStreamException ignored) {	if (log.isDebugEnabled()) {	}	try {	inputStream.close();	} catch (IOException e) {	
error in closing the input stream 

}	try {	inputStream.close();	} catch (IOException e) {	}	result = SynapseConfigUtils.readNonXML(url);	} finally {	try {	inputStream.close();	} catch (IOException e) {	
error in closing the input stream 

public RegistryEntry getRegistryEntry(String key) {	if (log.isDebugEnabled()) {	
perform registryentry lookup for key 

========================= synapse sample_4210 =========================

public boolean startProcess() {	try {	Class.forName("org.apache.derby.jdbc.ClientDriver").newInstance();	server = new NetworkServerControl (InetAddress.getByName("localhost"), port);	server.start(null);	while (true) {	try {	server.ping();	break;	} catch (Exception ignored) {	
waiting for derby server to start 

server = new NetworkServerControl (InetAddress.getByName("localhost"), port);	server.start(null);	while (true) {	try {	server.ping();	break;	} catch (Exception ignored) {	Thread.sleep(2000);	}	}	
derby is successfully started 

try {	server.ping();	break;	} catch (Exception ignored) {	Thread.sleep(2000);	}	}	initData();	return true;	} catch (Exception e) {	
there was an error starting derby server 

private void initData() throws Exception {	
creating the sample table and inserting values 

public boolean stopProcess() {	
shutting down derby server 

public boolean stopProcess() {	try {	try {	DriverManager.getConnection("jdbc:derby:;shutdown=true");	} catch (SQLException se) {	if (se.getErrorCode() == 50000 && "XJ015".equals(se.getSQLState())) {	
derby shut down normally 

try {	DriverManager.getConnection("jdbc:derby:;shutdown=true");	} catch (SQLException se) {	if (se.getErrorCode() == 50000 && "XJ015".equals(se.getSQLState())) {	}	}	server.shutdown();	FileUtils.deleteDirectory(new File("./synapsedb"));	return true;	} catch (Exception e) {	
error while trying to delete database directory 

========================= synapse sample_876 =========================

public static void convertMTOM_TO_Base64(AXIOMXPath xpath, String mimeType, MessageContext synCtx) throws SynapseException{	
converting mtom to 

public static void convertBase64_TO_MTOM(AXIOMXPath xpath, String mimeType, MessageContext synCtx) throws SynapseException{	
converting to mtom 

========================= synapse sample_3351 =========================

public static void removeAndReplicateState(String key, ConfigurationContext configCtx) {	if (configCtx != null && key != null) {	try {	if (log.isDebugEnabled()) {	
start replicating the property removal with key 

public static void removeAndReplicateState(String key, ConfigurationContext configCtx) {	if (configCtx != null && key != null) {	try {	if (log.isDebugEnabled()) {	}	configCtx.removePropertyNonReplicable(key);	org.apache.axis2.clustering.state.Replicator.replicate( configCtx, new String[]{key});	if (log.isDebugEnabled()) {	
completed replication of the property removal with key 

public static void setAndReplicateState(String key, Object value, ConfigurationContext configCtx) {	if (configCtx != null && key != null && value != null) {	try {	if (log.isDebugEnabled()) {	
start replicating the property with key value 

public static void setAndReplicateState(String key, Object value, ConfigurationContext configCtx) {	if (configCtx != null && key != null && value != null) {	try {	if (log.isDebugEnabled()) {	}	configCtx.setNonReplicableProperty(key, value);	org.apache.axis2.clustering.state.Replicator.replicate( configCtx, new String[]{key});	if (log.isDebugEnabled()) {	
completed replication of the property with key 

========================= synapse sample_1696 =========================

public static StatisticsRecord getStatisticsRecord(MessageContext synCtx) {	String messageId = synCtx.getMessageID();	org.apache.axis2.context.MessageContext axisMC = ((Axis2MessageContext) synCtx) .getAxis2MessageContext();	String remoteIP = (String) axisMC.getPropertyNonReplicable( org.apache.axis2.context.MessageContext.REMOTE_ADDR);	String domainName = (String) axisMC.getPropertyNonReplicable(NhttpConstants.REMOTE_HOST);	StatisticsRecord statisticsRecord = new StatisticsRecord(messageId, remoteIP, domainName);	if (log.isDebugEnabled()) {	
created a statisticsrecord 

========================= synapse sample_2055 =========================

public void init(ConfigurationContext configurationContext, AxisModule axisModule) throws AxisFault {	
initializing synapse at 

if (ipAddr != null) {	MDC.put("ip", ipAddr);	}	String hostname = addr.getHostName();	if (hostname == null) {	hostname = ipAddr;	}	MDC.put("host", hostname);	}	} catch (UnknownHostException e) {	
unable to determine hostname or ip address of the server for logging 

MDC.put("ip", ipAddr);	}	String hostname = addr.getHostName();	if (hostname == null) {	hostname = ipAddr;	}	MDC.put("host", hostname);	}	} catch (UnknownHostException e) {	}	
loading mediator extensions 

}	String hostname = addr.getHostName();	if (hostname == null) {	hostname = ipAddr;	}	MDC.put("host", hostname);	}	} catch (UnknownHostException e) {	}	configurationContext.getAxisConfiguration().getConfigurator().loadServices();	
initializing the synapse configuration 

String hostname = addr.getHostName();	if (hostname == null) {	hostname = ipAddr;	}	MDC.put("host", hostname);	}	} catch (UnknownHostException e) {	}	configurationContext.getAxisConfiguration().getConfigurator().loadServices();	synCfg = getConfiguration(configurationContext);	
deploying the synapse service 

AxisConfiguration axisCfg = configurationContext.getAxisConfiguration();	AxisService synapseService = new AxisService(SynapseConstants.SYNAPSE_SERVICE_NAME);	AxisOperation mediateOperation = new InOutAxisOperation( SynapseConstants.SYNAPSE_OPERATION_NAME);	mediateOperation.setMessageReceiver(new SynapseMessageReceiver());	synapseService.addOperation(mediateOperation);	List transports = new ArrayList();	transports.add(Constants.TRANSPORT_HTTP);	transports.add(Constants.TRANSPORT_HTTPS);	synapseService.setExposedTransports(transports);	axisCfg.addService(synapseService);	
initializing mercury 

if (mercuryAxisModule != null) {	Module mercury = mercuryAxisModule.getModule();	mercury.init(configurationContext, mercuryAxisModule);	}	String thisServerName = ServerManager.getInstance().getServerName();	if(thisServerName == null || thisServerName.equals("")) {	try {	InetAddress addr = InetAddress.getLocalHost();	thisServerName = addr.getHostName();	} catch (UnknownHostException e) {	
could not get local host name 

if(thisServerName == null || thisServerName.equals("")) {	try {	InetAddress addr = InetAddress.getLocalHost();	thisServerName = addr.getHostName();	} catch (UnknownHostException e) {	}	if(thisServerName == null || thisServerName.equals("")) {	thisServerName = "localhost";	}	}	
synapse server name 

if(thisServerName == null || thisServerName.equals("")) {	try {	InetAddress addr = InetAddress.getLocalHost();	thisServerName = addr.getHostName();	} catch (UnknownHostException e) {	}	if(thisServerName == null || thisServerName.equals("")) {	thisServerName = "localhost";	}	}	
deploying proxy services 

} catch (UnknownHostException e) {	}	if(thisServerName == null || thisServerName.equals("")) {	thisServerName = "localhost";	}	}	for (ProxyService proxy : synCfg.getProxyServices()) {	List pinnedServers = proxy.getPinnedServers();	if (pinnedServers != null && !pinnedServers.isEmpty()) {	if (!pinnedServers.contains(thisServerName)) {	
server name not in pinned servers list not deploying proxy service 

}	}	for (ProxyService proxy : synCfg.getProxyServices()) {	List pinnedServers = proxy.getPinnedServers();	if (pinnedServers != null && !pinnedServers.isEmpty()) {	if (!pinnedServers.contains(thisServerName)) {	continue;	}	}	proxy.buildAxisService(synCfg, axisCfg);	
deployed proxy service 

if (pinnedServers != null && !pinnedServers.isEmpty()) {	if (!pinnedServers.contains(thisServerName)) {	continue;	}	}	proxy.buildAxisService(synCfg, axisCfg);	if (!proxy.isStartOnLoad()) {	proxy.stop(synCfg);	}	}	
synapse initialized successfully 

private static SynapseConfiguration getConfiguration(ConfigurationContext cfgCtx) {	cfgCtx.setProperty("addressing.validateAction", Boolean.FALSE);	AxisConfiguration axisConfiguration = cfgCtx.getAxisConfiguration();	SynapseConfiguration synapseConfiguration;	String config = ServerManager.getInstance().getSynapseXMLPath();	if (config != null) {	synapseConfiguration = SynapseConfigurationBuilder.getConfiguration(config);	} else {	
system property or init parameter is not specified using default configuration 

========================= synapse sample_3994 =========================

public void timeout(final NHttpServerConnection conn) {	HttpRequest req = (HttpRequest) conn.getContext().getAttribute( ExecutionContext.HTTP_REQUEST);	if (req != null) {	if (log.isDebugEnabled()) {	
connection timeout for request to probably the keepalive connection was closed 

public void timeout(final NHttpServerConnection conn) {	HttpRequest req = (HttpRequest) conn.getContext().getAttribute( ExecutionContext.HTTP_REQUEST);	if (req != null) {	if (log.isDebugEnabled()) {	}	} else {	
connection timeout 

public void connected(final NHttpServerConnection conn) {	if (log.isTraceEnabled()) {	
new incoming connection 

public void responseReady(NHttpServerConnection conn) {	if (log.isTraceEnabled()) {	
ready to send response 

public void closed(final NHttpServerConnection conn) {	HttpContext context = conn.getContext();	closeChannel((ReadableByteChannel) context.getAttribute(REQUEST_SOURCE_CHANNEL));	closeChannel((ReadableByteChannel) context.getAttribute(RESPONSE_SOURCE_CHANNEL));	closeChannel((WritableByteChannel) context.getAttribute(RESPONSE_SINK_CHANNEL));	closeChannel((WritableByteChannel) context.getAttribute(REQUEST_SINK_CHANNEL));	if (log.isTraceEnabled()) {	
connection closed 

public void exception(NHttpServerConnection conn, IOException e) {	if (e instanceof ConnectionClosedException || e.getMessage().contains("Connection reset by peer") || e.getMessage().contains("forcibly closed")) {	if (log.isDebugEnabled()) {	
i o error probably the keepalive connection was closed 

public void exception(NHttpServerConnection conn, IOException e) {	if (e instanceof ConnectionClosedException || e.getMessage().contains("Connection reset by peer") || e.getMessage().contains("forcibly closed")) {	if (log.isDebugEnabled()) {	}	} else {	
i o error 

========================= synapse sample_4302 =========================

return;	}	targetConfiguration.getWorkerPool().execute(new Runnable() {	public void run() {	MessageReceiver mr = mc.getAxisOperation().getMessageReceiver();	try {	AxisFault axisFault = (exceptionToRaise != null ? new AxisFault(errorMessage, exceptionToRaise) : new AxisFault(errorMessage));	MessageContext faultMessageContext = MessageContextBuilder.createFaultMessageContext(mc, axisFault);	SOAPEnvelope envelope = faultMessageContext.getEnvelope();	if (log.isDebugEnabled()) {	
sending fault for request with message id 

faultMessageContext.setProperty( PassThroughConstants.ERROR_DETAIL, exceptionToRaise.toString());	faultMessageContext.setProperty( PassThroughConstants.ERROR_EXCEPTION, exceptionToRaise);	envelope.getBody().getFault().getDetail().setText( exceptionToRaise.toString());	} else {	faultMessageContext.setProperty( PassThroughConstants.ERROR_DETAIL, errorMessage);	envelope.getBody().getFault().getDetail().setText(errorMessage);	}	faultMessageContext.setProperty(PassThroughConstants.NO_ENTITY_BODY, true);	mr.receive(faultMessageContext);	} catch (AxisFault af) {	
unable to report back failure to the message receiver 

========================= synapse sample_964 =========================

public boolean mediate(MessageContext synCtx) {	
try mediator mediate 

========================= synapse sample_3078 =========================

public void destroy() {	super.destroy();	try {	dispatcher.stop();	} catch (IOException ex) {	
failed to stop dispatcher 

protected void startListeningForService(AxisService service) {	Parameter param;	int port;	param = service.getParameter(UDPConstants.PORT_KEY);	if (param == null) {	
no udp port number specified for service disabling transport for this service 

int port;	param = service.getParameter(UDPConstants.PORT_KEY);	if (param == null) {	disableTransportForService(service);	return;	} else {	try {	port = Integer.parseInt(param.getValue().toString());	}	catch (NumberFormatException ex) {	
invalid port number for service 

return;	}	}	int maxPacketSize = UDPConstants.DEFAULT_MAX_PACKET_SIZE;	param = service.getParameter(UDPConstants.MAX_PACKET_SIZE_KEY);	if (param != null) {	try {	maxPacketSize = Integer.parseInt(param.getValue().toString());	}	catch (NumberFormatException ex) {	
invalid maximum packet size falling back to default value 

if (param != null) {	try {	maxPacketSize = Integer.parseInt(param.getValue().toString());	}	catch (NumberFormatException ex) {	}	}	String contentType;	param = service.getParameter(UDPConstants.CONTENT_TYPE_KEY);	if (param == null) {	
no content type specified for service disabling transport for this service 

if (param == null) {	disableTransportForService(service);	return;	} else {	contentType = (String)param.getValue();	}	Endpoint endpoint = new Endpoint(this, port, contentType, maxPacketSize, service, metrics);	try {	dispatcher.addEndpoint(endpoint);	} catch (IOException ex) {	
unable to listen on port 

protected void stopListeningForService(AxisService service) {	try {	dispatcher.removeEndpoint(service.getName());	} catch (IOException ex) {	
i o exception while stopping listener for service 

========================= synapse sample_4247 =========================

public void testCallOutDefinedEndpoint() {	
running test callout mediator invoke a service using a defined endpoint 

========================= synapse sample_821 =========================

public abstract RuleCondition getRuleCondition(OMElement om);	public abstract QName getRuleQName();	public void init(OMElement om, ClassLoader cl) {	
initialising rule engine 

public boolean process(SynapseEnvironment se, SOAPMessageContext smc) {	
processing message 

public boolean process(SynapseEnvironment se, SOAPMessageContext smc) {	Iterator it = rules.iterator();	while (it.hasNext()) {	Rule ra = (Rule) it.next();	RuleCondition rc = ra.getRuleCondition();	if (rc.matches(smc)) {	
matched 

List medConfigs = ra.getMediatorConfigurations();	if (medConfigs==null) return true;	Iterator mcs = medConfigs.iterator();	while (mcs.hasNext()) {	MediatorConfiguration mc = (MediatorConfiguration)mcs.next();	boolean ret = se.executeMediator(mc, smc);	if (!ret) return false;	}	}	else {	
did not match 

========================= synapse sample_1415 =========================

protected void processStatement(Statement stmnt, MessageContext msgCtx) {	SynapseLog synLog = getLog(msgCtx);	Connection con = null;	ResultSet rs = null;	try {	con = this.getDataSource().getConnection();	PreparedStatement ps = getPreparedStatement(stmnt, con, msgCtx);	rs = ps.executeQuery();	if (rs.next()) {	if (synLog.isTraceOrDebugEnabled()) {	
processing the first row returned 

String columnStr =  stmnt.getResultsMap().get(propName);	Object obj;	try {	int colNum = Integer.parseInt(columnStr);	obj = rs.getObject(colNum);	} catch (NumberFormatException ignore) {	obj = rs.getObject(columnStr);	}	if (obj != null) {	if (synLog.isTraceOrDebugEnabled()) {	
column returned value setting this as the message property 

obj = rs.getObject(colNum);	} catch (NumberFormatException ignore) {	obj = rs.getObject(columnStr);	}	if (obj != null) {	if (synLog.isTraceOrDebugEnabled()) {	}	msgCtx.setProperty(propName, obj.toString());	} else {	if (synLog.isTraceOrDebugEnabled()) {	
column returned null skip setting message property 

if (synLog.isTraceOrDebugEnabled()) {	}	msgCtx.setProperty(propName, obj.toString());	} else {	if (synLog.isTraceOrDebugEnabled()) {	}	}	}	} else {	if (synLog.isTraceOrDebugEnabled()) {	
statement returned rows 

========================= synapse sample_1946 =========================

private boolean start() {	if (scheduledFuture == null || (scheduledFuture.isCancelled())) {	scheduledFuture = scheduler.scheduleWithFixedDelay(cacheManagingTask, duration, duration, TimeUnit.MINUTES);	
cache manager started 

public boolean wakeUpNow(){	if (scheduledFuture !=null) {	if (!scheduledFuture.isCancelled()) {	scheduledFuture.cancel(DO_NOT_INTERRUPT_IF_RUNNING);	}	scheduledFuture = scheduler.scheduleWithFixedDelay(cacheManagingTask, 0, duration,TimeUnit.MINUTES);	
cache manager wakened up 

public boolean stop(){	if (scheduledFuture !=null && !scheduledFuture.isCancelled()){	scheduledFuture.cancel(DO_NOT_INTERRUPT_IF_RUNNING);	
cache manager stopped 

public void run() {	long start = System.currentTimeMillis();	if (log.isDebugEnabled()) {	
cache manager task started 

}	ManageableCacheValue nextCacheValue;	int cacheSize = cache.getCacheSize();	int numberToRemove = (cacheSize>cacheMaxSize)?  cacheSize - cacheMaxSize: 0;	List<ManageableCacheValue> entriesToRemove = new ArrayList<ManageableCacheValue>();	LRUEntryCollector lruEntryCollector = new LRUEntryCollector(entriesToRemove, numberToRemove);	cache.resetIterator();	while ((cacheSize--) > 0) {	nextCacheValue = cache.getNextCacheValue();	if (nextCacheValue == null) {	
cache manager iteration through cache values done 

int numberToRemove = (cacheSize>cacheMaxSize)?  cacheSize - cacheMaxSize: 0;	List<ManageableCacheValue> entriesToRemove = new ArrayList<ManageableCacheValue>();	LRUEntryCollector lruEntryCollector = new LRUEntryCollector(entriesToRemove, numberToRemove);	cache.resetIterator();	while ((cacheSize--) > 0) {	nextCacheValue = cache.getNextCacheValue();	if (nextCacheValue == null) {	break;	}	if (!nextCacheValue.isValid()) {	
updating invalid cache value by manager 

break;	}	if (!nextCacheValue.isValid()) {	nextCacheValue.updateCacheWithNewValue();	}	if (numberToRemove > 0) {	lruEntryCollector.collectEntriesToRemove(nextCacheValue);	}	}	for (ManageableCacheValue oldCacheValue: entriesToRemove) {	
removing lru value from cache 

nextCacheValue.updateCacheWithNewValue();	}	if (numberToRemove > 0) {	lruEntryCollector.collectEntriesToRemove(nextCacheValue);	}	}	for (ManageableCacheValue oldCacheValue: entriesToRemove) {	oldCacheValue.removeThisCacheValue();	}	if (log.isDebugEnabled()) {	
cache manager task done took ms 

========================= synapse sample_2393 =========================

public void testDbReport() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to dbreport mediator 

public void testDbReport() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	result = client.requestStandardQuote(addUrl, trpUrl, null, "IBM" ,null);	assertTrue("Client did not get run successfully ", result.responseReceived());	
running test introduction to the dblookup mediator 

========================= synapse sample_2239 =========================

return mainSynLibArtifact;	} catch (FileNotFoundException e) {	throw new SynapseArtifactDeploymentException("artifacts.xml File cannot be loaded from " + libXmlPath, e);	} catch (OMException e) {	throw new SynapseArtifactDeploymentException("Error while parsing the artifacts.xml file ", e);	} finally {	if (xmlInputStream != null) {	try {	xmlInputStream.close();	} catch (IOException e) {	
error while closing input stream 

File f = new File(artifactXmlPath);	if (!f.exists()) {	continue;	}	LibraryArtifact artifact = null;	InputStream xmlInputStream = null;	try {	xmlInputStream = new FileInputStream(f);	artifact = buildArtifact(library, xmlInputStream, directoryPath);	} catch (FileNotFoundException e) {	
error while resolving synapse lib dir artifacts xml file cannot be loaded from 

if (!f.exists()) {	continue;	}	LibraryArtifact artifact = null;	InputStream xmlInputStream = null;	try {	xmlInputStream = new FileInputStream(f);	artifact = buildArtifact(library, xmlInputStream, directoryPath);	} catch (FileNotFoundException e) {	} catch (Exception e) {	
error ocurred while resolving synapse lib dir for artifacts xml path 

try {	xmlInputStream = new FileInputStream(f);	artifact = buildArtifact(library, xmlInputStream, directoryPath);	} catch (FileNotFoundException e) {	} catch (Exception e) {	} finally {	if (xmlInputStream != null) {	try {	xmlInputStream.close();	} catch (IOException e) {	
error while closing input stream 

} catch (Exception e) {	} finally {	if (xmlInputStream != null) {	try {	xmlInputStream.close();	} catch (IOException e) {	}	}	}	if (artifact == null) {	
could not build lib artifact for path synapse library continue searching for other lib artifacts 

private static LibraryArtifact buildArtifact(SynapseLibrary library, InputStream artifactXmlStream, String directoryPath) {	LibraryArtifact artifact = null;	try {	OMElement artElement = OMXMLBuilderFactory.createOMBuilder(artifactXmlStream).getDocumentElement();	if (LibDeployerConstants.ARTIFACT.equals(artElement.getLocalName())) {	artifact = populateLibraryArtifact(artElement, directoryPath, null, library);	} else {	
artifact xml is invalid error occurred while resolving synapse library 

OMElement artElement = OMXMLBuilderFactory.createOMBuilder(artifactXmlStream).getDocumentElement();	if (LibDeployerConstants.ARTIFACT.equals(artElement.getLocalName())) {	artifact = populateLibraryArtifact(artElement, directoryPath, null, library);	} else {	return null;	}	} catch (OMException e) {	throw new SynapseArtifactDeploymentException("Error parsing artifact.xml for path : " + directoryPath ,e);	}	if (artifact == null || artifact.getName() == null) {	
invalid artifact found in synapse library 

public static void createDir(String path) {	File temp = new File(path);	if (!temp.exists() && !temp.mkdir()) {	
error while creating directory 

========================= synapse sample_572 =========================

public void echoVoid() {	
echo service called 

public void echoOMElementNoResponse(OMElement omEle) {	
echoomelementnoresponse service called 

========================= synapse sample_3717 =========================

public void receive(MessageContext mc) throws AxisFault {	
receiving message 

========================= synapse sample_1395 =========================

public void setEventMask(int ops) {	if (sessionLog.isDebugEnabled()) {	
set event mask 

public void setEvent(int op) {	if (sessionLog.isDebugEnabled()) {	
set event 

public void clearEvent(int op) {	if (sessionLog.isDebugEnabled()) {	
clear event 

public void close() {	if (sessionLog.isDebugEnabled()) {	
close 

public void shutdown() {	if (sessionLog.isDebugEnabled()) {	
shutdown 

public void setSocketTimeout(int timeout) {	if (sessionLog.isDebugEnabled()) {	
set timeout 

public void setAttribute(final String name, final Object obj) {	if (sessionLog.isDebugEnabled()) {	
set attribute 

public Object removeAttribute(final String name) {	if (sessionLog.isDebugEnabled()) {	
remove attribute 

public int read(final ByteBuffer dst) throws IOException {	int bytesRead = session.channel().read(dst);	if (sessionLog.isDebugEnabled()) {	
bytes read 

public int write(final ByteBuffer src) throws IOException {	int byteWritten = session.channel().write(src);	if (sessionLog.isDebugEnabled()) {	
bytes written 

public void close() throws IOException {	if (sessionLog.isDebugEnabled()) {	
channel close 

========================= synapse sample_2413 =========================

if (retryDelay != null && retryDelay.getText() != null) {	try {	definition.setRetryDurationOnTimeout( Integer.parseInt(retryDelay.getText().trim()));	} catch (NumberFormatException e) {	handleException("The retry delay for timeouts should be specified " + "as a valid number : " + retryDelay.getText(), e);	}	}	}	OMElement suspendDurationOnFailure = elem.getFirstChildWithName(new QName( SynapseConstants.SYNAPSE_NAMESPACE, "suspendDurationOnFailure"));	if (suspendDurationOnFailure != null && suspendDurationOnFailure.getText() != null) {	
configuration uses deprecated style for endpoint suspenddurationonfailure 

========================= synapse sample_358 =========================

public void execute(JobExecutionContext ctx) throws JobExecutionException {	String jobName = ctx.getJobDetail().getKey().getName();	if (log.isDebugEnabled()) {	
executing task 

SynapseEnvironment se = (SynapseEnvironment) jdm.get("SynapseEnvironment");	if (initRequired) {	try {	task = (Task) getClass().getClassLoader().loadClass(jobClassName).newInstance();	} catch (Exception e) {	handleException("Cannot instantiate task : " + jobClassName, e);	}	Set properties = (Set) jdm.get(PROPERTIES);	for (Object property : properties) {	OMElement prop = (OMElement) property;	
found property 

========================= synapse sample_2043 =========================

public static DataSourceInformationRepository createDataSourceInformationRepository( DataSourceInformationRepositoryListener listener, Properties properties) {	if (log.isDebugEnabled()) {	
creating a new datasourceinformationrepository 

========================= synapse sample_708 =========================

public void check(Certificate cert, Collection<String> unresolvedCritExts) throws CertPathValidatorException {	RevocationStatus status;	try {	status = verifier.checkRevocationStatus((X509Certificate) cert, nextIssuer());	if (log.isDebugEnabled()) {	
certificate status is 

========================= synapse sample_972 =========================

public static String createJMSQueue(Connection con, String destinationJNDIName) throws JMSException {	try {	QueueSession session = ((QueueConnection) con).createQueueSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue(destinationJNDIName);	
jms queue with jndi name created 

public static String createJMSTopic(Connection con, String destinationJNDIName) throws JMSException {	try {	TopicSession session = ((TopicConnection) con).createTopicSession(false, Session.AUTO_ACKNOWLEDGE);	Topic topic = session.createTopic(destinationJNDIName);	
jms topic with jndi name created 

Parameter destTypeParam = service.getParameter(JMSConstants.DEST_PARAM_TYPE);	if (destTypeParam != null) {	String paramValue = (String) destTypeParam.getValue();	if(JMSConstants.DESTINATION_TYPE_QUEUE.equals(paramValue) || JMSConstants.DESTINATION_TYPE_TOPIC.equals(paramValue) )  {	return paramValue;	} else {	handleException("Invalid destinaton type value " + paramValue);	return null;	}	} else {	
jms destination type not given default queue 

public static void setConnectionFactoryParameters( Parameter param, JMSConnectionFactory jmsConFactory) {	ParameterIncludeImpl pi = new ParameterIncludeImpl();	try {	pi.deserializeParameters((OMElement) param.getValue());	} catch (AxisFault axisFault) {	
error reading parameters for jms connection factory 

if (replyDestination == null) {	try {	replyDestination = createTemporaryDestination(session);	} catch (JMSException e) {	handleException("Error creating temporary queue for response");	}	}	try {	message.setJMSReplyTo(replyDestination);	} catch (JMSException e) {	
error setting jms replyto destination to 

} catch (JMSException e) {	handleException("Error creating temporary queue for response");	}	}	try {	message.setJMSReplyTo(replyDestination);	} catch (JMSException e) {	}	if (log.isDebugEnabled()) {	try {	
expecting a response to jms destination 

public static Destination createDestinationIfRequired(Destination destination, String destinationType, String targetAddress, Session session) throws AxisFault {	if (destination == null) {	if (targetAddress != null) {	String name = JMSUtils.getDestination(targetAddress);	if (log.isDebugEnabled()) {	
creating jms destination 

public static Destination createReplyDestinationIfRequired(Destination destination, String replyDestinationName, String destinationType, String targetAddress, Session session) throws AxisFault {	if (destination == null) {	if (targetAddress != null) {	if (log.isDebugEnabled()) {	
creating jms reply destination 

public static void sendMessageToJMSDestination(Session session, Destination destination, String destinationType, Message message) throws AxisFault {	MessageProducer producer = null;	try {	if (log.isDebugEnabled()) {	
sending message to destination 

if (log.isDebugEnabled()) {	}	if (JMSConstants.DESTINATION_TYPE_TOPIC.equals(destinationType)) {	producer = ((TopicSession) session).createPublisher((Topic) destination);	((TopicPublisher) producer).publish(message);	} else {	producer = ((QueueSession) session).createSender((Queue) destination);	((QueueSender) producer).send(message);	}	if (log.isDebugEnabled()) {	
sent message to destination message id correlation id replyto id 

message.setJMSCorrelationID((String) headerMap.get(JMSConstants.JMS_COORELATION_ID));	}	else if (JMSConstants.JMS_DELIVERY_MODE.equals(name)) {	Object o = headerMap.get(JMSConstants.JMS_DELIVERY_MODE);	if (o instanceof Integer) {	message.setJMSDeliveryMode(((Integer) o).intValue());	} else if (o instanceof String) {	try {	message.setJMSDeliveryMode(Integer.parseInt((String) o));	} catch (NumberFormatException nfe) {	
invalid delivery mode ignored 

else if (JMSConstants.JMS_DELIVERY_MODE.equals(name)) {	Object o = headerMap.get(JMSConstants.JMS_DELIVERY_MODE);	if (o instanceof Integer) {	message.setJMSDeliveryMode(((Integer) o).intValue());	} else if (o instanceof String) {	try {	message.setJMSDeliveryMode(Integer.parseInt((String) o));	} catch (NumberFormatException nfe) {	}	} else {	
invalid delivery mode ignored 

public static Session createSession(Connection con, boolean transacted, int acknowledgeMode, String destinationType) throws JMSException {	if (JMSConstants.DESTINATION_TYPE_QUEUE.equals(destinationType) ) {	return ((QueueConnection) con).createQueueSession(transacted, acknowledgeMode);	} else if (JMSConstants.DESTINATION_TYPE_TOPIC.equals(destinationType) ) {	return ((TopicConnection) con).createTopicSession(transacted, acknowledgeMode);	} else {	
jms destination type not given or invalid default queue was 

public static Destination createDestination(Session session, String destName, String destinationType) throws JMSException {	if (JMSConstants.DESTINATION_TYPE_QUEUE.equals(destinationType)) {	return ((QueueSession) session).createQueue(destName);	} else if (JMSConstants.DESTINATION_TYPE_TOPIC.equals(destinationType) ) {	return ((TopicSession) session).createTopic(destName);	} else {	
jms destination type not given or invalid default queue was 

public static long getBodyLength(BytesMessage bMsg) {	try {	Method mtd = bMsg.getClass().getMethod("getBodyLength", NOARGS);	if (mtd != null) {	return (Long) mtd.invoke(bMsg, NOPARMS);	}	} catch (Exception e) {	if (log.isDebugEnabled()) {	
error trying to determine jms bytesmessage body length 

========================= synapse sample_4314 =========================

public boolean mediate(MessageContext synCtx) {	
fault mediator mediate 

OMDocument soapFaultDocument = factory.createOMDocument();	SOAPEnvelope faultEnvelope = factory.getDefaultFaultEnvelope();	soapFaultDocument.addChild(faultEnvelope);	SOAPFault fault = factory.createSOAPFault();	setFaultCode(synCtx, factory, fault);	setFaultResaon(synCtx, factory, fault);	setFaultNode(factory, fault);	setFaultRole(factory, fault);	setFaultDetail(factory, fault);	faultEnvelope.getBody().setFirstChild(fault);	
setting the fault message as 

SOAPFault fault = factory.createSOAPFault();	setFaultCode(synCtx, factory, fault);	setFaultResaon(synCtx, factory, fault);	setFaultNode(factory, fault);	setFaultRole(factory, fault);	setFaultDetail(factory, fault);	faultEnvelope.getBody().setFirstChild(fault);	EndpointReference toEPR = synCtx.getTo();	EndpointReference faultToEPR = synCtx.getFaultTo();	if (faultToEPR != null) {	
setting fault message to 

SOAPFault fault = factory.createSOAPFault();	setFaultCode(synCtx, factory, fault);	setFaultResaon(synCtx, factory, fault);	setFaultNode(factory, fault);	setFaultRole(factory, fault);	setFaultDetail(factory, fault);	faultEnvelope.getBody().setFirstChild(fault);	EndpointReference toEPR = synCtx.getTo();	EndpointReference faultToEPR = synCtx.getFaultTo();	if (faultToEPR != null) {	
setting fault message replyto 

setFaultRole(factory, fault);	setFaultDetail(factory, fault);	faultEnvelope.getBody().setFirstChild(fault);	EndpointReference toEPR = synCtx.getTo();	EndpointReference faultToEPR = synCtx.getFaultTo();	if (faultToEPR != null) {	synCtx.setTo(faultToEPR);	synCtx.setReplyTo(toEPR);	} else {	EndpointReference replyToEPR = synCtx.getReplyTo();	
setting fault message to 

setFaultRole(factory, fault);	setFaultDetail(factory, fault);	faultEnvelope.getBody().setFirstChild(fault);	EndpointReference toEPR = synCtx.getTo();	EndpointReference faultToEPR = synCtx.getFaultTo();	if (faultToEPR != null) {	synCtx.setTo(faultToEPR);	synCtx.setReplyTo(toEPR);	} else {	EndpointReference replyToEPR = synCtx.getReplyTo();	
setting fault message replyto 

========================= synapse sample_3310 =========================

if (outCtx != null && "true".equals(outCtx. getProperty(SynapseConstants.BLOCKING_CLIENT_ERROR))) {	if (maxDeliverAttempts > 0) {	processor.incrementSendAttemptCount();	}	if (parameters != null && parameters.get( ForwardingProcessorConstants.FAULT_SEQUENCE) != null) {	String seq = (String) parameters.get( ForwardingProcessorConstants.FAULT_SEQUENCE);	Mediator mediator = outCtx.getSequence(seq);	if (mediator != null) {	mediator.mediate(outCtx);	} else {	
can t send the fault message sequence does not exist 

processor.resetSentAttemptCount();	continue;	}	if (parameters != null && parameters.get( ForwardingProcessorConstants.REPLY_SEQUENCE) != null) {	if (outCtx != null) {	String seq = (String) parameters.get( ForwardingProcessorConstants.REPLY_SEQUENCE);	Mediator mediator = outCtx.getSequence(seq);	if (mediator != null) {	mediator.mediate(outCtx);	} else {	
can t send the out message sequence does not exist 

processor.resetSentAttemptCount();	messageStore.poll();	} catch (Exception e) {	if (maxDeliverAttempts > 0) {	processor.incrementSendAttemptCount();	if (processor.getSendAttemptCount() >= maxDeliverAttempts) {	processor.deactivate();	}	}	errorStop = true;	
error forwarding message 

String logMsg;	if (ep == null) {	logMsg = "Endpoint named " + targetEp + " not found.Hence removing " + "the message form store";	} else {	logMsg = "Unsupported endpoint type. Only address/wsdl/default " + "endpoint types supported";	}	log.warn(logMsg);	messageStore.poll();	}	} else {	
property not found in the message context hence removing the message 

========================= synapse sample_2014 =========================

public void timeout(final NHttpServerConnection conn) {	HttpContext context = conn.getContext();	Boolean read = (Boolean) context.getAttribute(NhttpConstants.REQUEST_READ);	if (read == null || read) {	if (log.isDebugEnabled()) {	
keepalive connection was closed 

public void timeout(final NHttpServerConnection conn) {	HttpContext context = conn.getContext();	Boolean read = (Boolean) context.getAttribute(NhttpConstants.REQUEST_READ);	if (read == null || read) {	if (log.isDebugEnabled()) {	}	} else {	
connection timeout before message body was fully read 

public void connected(final NHttpServerConnection conn) {	if (log.isTraceEnabled()) {	
new incoming connection 

public void connected(final NHttpServerConnection conn) {	if (log.isTraceEnabled()) {	}	metrics.connected();	conn.getContext().setAttribute(CONNECTION_CREATION_TIME, System.currentTimeMillis());	if (log.isDebugEnabled()) {	
adding a connection to the pool existing pool size 

public void responseReady(NHttpServerConnection conn) {	if (JavaUtils.isTrueExplicitly(conn.getContext().getAttribute(NhttpConstants.FORCE_CLOSING)) && !JavaUtils.isTrueExplicitly(conn.getContext().getAttribute( NhttpConstants.MESSAGE_IN_FLIGHT))) {	try {	if (log.isDebugEnabled()) {	
closing a persisted connection since it is forced 

}	conn.close();	} catch (IOException ignore) {}	return;	}	metrics.notifyReceivedMessageSize(conn.getMetrics().getReceivedBytesCount());	metrics.notifySentMessageSize(conn.getMetrics().getSentBytesCount());	conn.getMetrics().reset();	conn.getContext().removeAttribute(NhttpConstants.MESSAGE_IN_FLIGHT);	if (log.isTraceEnabled()) {	
ready to send response 

public void closed(final NHttpServerConnection conn) {	HttpContext context = conn.getContext();	shutdownConnection(conn);	context.removeAttribute(REQUEST_SINK_BUFFER);	context.removeAttribute(RESPONSE_SOURCE_BUFFER);	context.removeAttribute(CONNECTION_CREATION_TIME);	context.removeAttribute(SERVER_CONNECTION_DEBUG);	if (log.isTraceEnabled()) {	
connection closed 

public void markActiveConnectionsToBeClosed() {	
marking the closing signal on the connection pool of size 

public void exception(final NHttpServerConnection conn, final HttpException e) {	if (log.isDebugEnabled()) {	
http protocol error encountered in serverhandler 

public void exception(NHttpServerConnection conn, Exception e) {	if (e instanceof HttpException) {	exception(conn, (HttpException) e);	} else if (e instanceof IOException) {	exception(conn, (IOException) e);	} else {	
unexpected error 

public void exception(NHttpServerConnection conn, IOException e) {	if (e instanceof ConnectionClosedException || (e.getMessage() != null && e.getMessage().contains("Connection reset by peer") || e.getMessage().contains("forcibly closed"))) {	if (log.isDebugEnabled()) {	
i o error probably the keepalive connection was closed 

public void exception(NHttpServerConnection conn, IOException e) {	if (e instanceof ConnectionClosedException || (e.getMessage() != null && e.getMessage().contains("Connection reset by peer") || e.getMessage().contains("forcibly closed"))) {	if (log.isDebugEnabled()) {	}	} else if (e.getMessage() != null) {	String msg = e.getMessage().toLowerCase();	if (msg.indexOf("broken") != -1) {	
i o error probably the connection was closed by the remote party 

public void exception(NHttpServerConnection conn, IOException e) {	if (e instanceof ConnectionClosedException || (e.getMessage() != null && e.getMessage().contains("Connection reset by peer") || e.getMessage().contains("forcibly closed"))) {	if (log.isDebugEnabled()) {	}	} else if (e.getMessage() != null) {	String msg = e.getMessage().toLowerCase();	if (msg.indexOf("broken") != -1) {	} else {	
i o error 

}	} else if (e.getMessage() != null) {	String msg = e.getMessage().toLowerCase();	if (msg.indexOf("broken") != -1) {	} else {	}	if (metrics != null) {	metrics.incrementFaultsReceiving();	}	} else {	
unexpected i o error 

SharedOutputBuffer outputBuffer = (SharedOutputBuffer) conn.getContext().getAttribute(RESPONSE_SOURCE_BUFFER);	if (outputBuffer != null) {	outputBuffer.close();	}	SharedInputBuffer inputBuffer = (SharedInputBuffer) conn.getContext().getAttribute(REQUEST_SINK_BUFFER);	if (inputBuffer != null) {	inputBuffer.close();	}	synchronized (this) {	if (activeConnections.remove(conn) && log.isDebugEnabled()) {	
removing the connection from pool of size 

========================= synapse sample_2444 =========================

public CallService(SynapseEnvironment synapseEnvironment) {	this.environment = synapseEnvironment;	
call service constructor 

public SynapseMessage execute(long timeoutValue, SynapseMessage synapseMsg) {	this.synapseMsg = synapseMsg;	synapseMessage = (Axis2SynapseMessage) synapseMsg;	
execute called 

System.out.println("THE RESPONSE ===== " + synapseMessage.getEnvelope());	synapseMessage.setFaultResponse(true);	} catch (AxisFault axisFault1) {	axisFault1.printStackTrace();	}	}	} else {	final CallThread thread = new CallThread();	final SimpleWorkManager manager = new SimpleWorkManager(5);	Timer timer = new Timer(false);	
timer defined 

Timer timer = new Timer(false);	TimerTask task = new TimerTask() {	public void run() {	if (thread.completed) {	}	thread.interrupted = true;	}	};	timer.schedule(task, timeoutValue);	manager.addTask(thread);	
thread started 

========================= synapse sample_2917 =========================

private static void handleConfigurationError(String componentType, String msg) {	if (SynapseConfigUtils.isFailSafeEnabled(componentType)) {	
continue in fail safe mode 

private static void handleConfigurationError(String componentType, String msg, Exception e) {	if (SynapseConfigUtils.isFailSafeEnabled(componentType)) {	
continue in fail safe mode 

========================= synapse sample_1792 =========================

protected void send(byte[] message) throws Exception {	File tmpFile = new File(requestFile.getParent(), "." + requestFile.getName() + ".tmp");	
writing message to temporary file 

protected void send(byte[] message) throws Exception {	File tmpFile = new File(requestFile.getParent(), "." + requestFile.getName() + ".tmp");	OutputStream out = new FileOutputStream(tmpFile);	out.write(message);	out.close();	
moving to 

protected void send(byte[] message) throws Exception {	File tmpFile = new File(requestFile.getParent(), "." + requestFile.getName() + ".tmp");	OutputStream out = new FileOutputStream(tmpFile);	out.write(message);	out.close();	if (!tmpFile.renameTo(requestFile)) {	throw new IOException("Unable to rename " + tmpFile + " to " + requestFile);	}	
done 

========================= synapse sample_2297 =========================

this.cfgCtx = cfgCtx;	this.in = in;	this.response = response;	this.endpointURLPrefix = endpointURLPrefix;	try {	responseMsgCtx = outMsgCtx.getOperationContext(). getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);	if (responseMsgCtx != null) {	responseMsgCtx.setSoapAction("");	}	} catch (AxisFault af) {	
error getting in message context from the operation context 

try {	responseMsgCtx = outMsgCtx.getOperationContext(). getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);	if (responseMsgCtx != null) {	responseMsgCtx.setSoapAction("");	}	} catch (AxisFault af) {	return;	}	if (responseMsgCtx == null && outMsgCtx.getOperationContext().isComplete()) {	if (log.isDebugEnabled()) {	
error getting in message context from the operation context possibly an rm terminate sequence message 

responseMsgCtx.setProperty( Constants.Configuration.CHARACTER_SET_ENCODING, charSetEnc);	responseMsgCtx.setServerSide(false);	SOAPEnvelope envelope;	try {	envelope = TransportUtils.createSOAPMessage( responseMsgCtx, HTTPTransportUtils.handleGZip(responseMsgCtx, in), contentType);	} catch (OMException e) {	String errorMessage = "Unexpected response received. HTTP response code : " + this.response.getStatusLine().getStatusCode() + " HTTP status : " + this.response.getStatusLine().getReasonPhrase() + " exception : " + e.getMessage();	log.warn(errorMessage);	if (log.isDebugEnabled()) {	log.debug(errorMessage, e);	
creating the soapfault to be injected 

if (endpointURLPrefix != null) {	responseMsgCtx.setProperty(NhttpConstants.ENDPOINT_PREFIX, endpointURLPrefix);	}	try {	AxisEngine.receive(responseMsgCtx);	} catch (AxisFault af) {	String errorMessage = "Fault processing response message through Axis2: " + af.getMessage();	log.warn(errorMessage);	if (log.isDebugEnabled()) {	log.debug(errorMessage, af);	
directly invoking synapsecallbackreceiver after setting error properties 

log.debug(errorMessage, af);	}	responseMsgCtx.setProperty( NhttpConstants.SENDING_FAULT, Boolean.TRUE);	responseMsgCtx.setProperty( NhttpConstants.ERROR_CODE, NhttpConstants.RESPONSE_PROCESSING_FAILURE);	responseMsgCtx.setProperty( NhttpConstants.ERROR_MESSAGE, errorMessage.split("\n")[0]);	responseMsgCtx.setProperty( NhttpConstants.ERROR_DETAIL, JavaUtils.stackToString(af));	responseMsgCtx.setProperty( NhttpConstants.ERROR_EXCEPTION, af);	responseMsgCtx.getAxisOperation().getMessageReceiver().receive(responseMsgCtx);	}	} catch (AxisFault af) {	
fault creating response soap envelope 

}	responseMsgCtx.setProperty( NhttpConstants.SENDING_FAULT, Boolean.TRUE);	responseMsgCtx.setProperty( NhttpConstants.ERROR_CODE, NhttpConstants.RESPONSE_PROCESSING_FAILURE);	responseMsgCtx.setProperty( NhttpConstants.ERROR_MESSAGE, errorMessage.split("\n")[0]);	responseMsgCtx.setProperty( NhttpConstants.ERROR_DETAIL, JavaUtils.stackToString(af));	responseMsgCtx.setProperty( NhttpConstants.ERROR_EXCEPTION, af);	responseMsgCtx.getAxisOperation().getMessageReceiver().receive(responseMsgCtx);	}	} catch (AxisFault af) {	} catch (XMLStreamException e) {	
error creating response soap envelope 

responseMsgCtx.setProperty( NhttpConstants.SENDING_FAULT, Boolean.TRUE);	responseMsgCtx.setProperty( NhttpConstants.ERROR_CODE, NhttpConstants.RESPONSE_PROCESSING_FAILURE);	responseMsgCtx.setProperty( NhttpConstants.ERROR_MESSAGE, errorMessage.split("\n")[0]);	responseMsgCtx.setProperty( NhttpConstants.ERROR_DETAIL, JavaUtils.stackToString(af));	responseMsgCtx.setProperty( NhttpConstants.ERROR_EXCEPTION, af);	responseMsgCtx.getAxisOperation().getMessageReceiver().receive(responseMsgCtx);	}	} catch (AxisFault af) {	} catch (XMLStreamException e) {	} catch (IOException e) {	
error closing input stream from which message was read 

========================= synapse sample_1004 =========================

public void testLocalRegEntriesAndSchemaValidation() {	String addUrl = "http: String trpUrl = "http: String expectedError = "Invalid custom quote request";	StockQuoteSampleClient client = getStockQuoteClient();	
running test creating soap fault messages and changing the direction of a message 

public void testLocalRegEntriesAndSchemaValidation() {	String addUrl = "http: String trpUrl = "http: String expectedError = "Invalid custom quote request";	StockQuoteSampleClient client = getStockQuoteClient();	SampleClientResult result = client.requestStandardQuote(addUrl, trpUrl, null, "IBM",null);	assertFalse("Should not get a response", result.responseReceived());	Exception resultEx = result.getException();	assertNotNull("Did not receive expected error", resultEx);	
got an error as expected 

========================= synapse sample_860 =========================

public void handleFault(MessageContext synCtx) {	boolean traceOn = synCtx.getTracingState() == SynapseConstants.TRACING_ON;	boolean traceOrDebugOn = traceOn || log.isDebugEnabled();	if (traceOrDebugOn) {	traceOrDebugWarn(traceOn, "FaultHandler executing impl: " + this.getClass().getName());	}	try {	
faulthandler executing impl 

boolean traceOrDebugOn = traceOn || log.isDebugEnabled();	synCtx.setProperty(SynapseConstants.ERROR_CODE, "00000");	synCtx.setProperty(SynapseConstants.ERROR_MESSAGE, e.getMessage().split("\n")[0]);	synCtx.setProperty(SynapseConstants.ERROR_DETAIL, getStackTrace(e));	synCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, e);	if (traceOrDebugOn) {	traceOrDebugWarn(traceOn, "Fault handler - setting ERROR_MESSAGE : " + synCtx.getProperty(SynapseConstants.ERROR_MESSAGE));	traceOrDebugWarn(traceOn, "Fault handler - setting ERROR_DETAIL : " + synCtx.getProperty(SynapseConstants.ERROR_DETAIL));	traceOrDebugWarn(traceOn, "Fault handler - setting ERROR_EXCEPTION : " + synCtx.getProperty(SynapseConstants.ERROR_EXCEPTION));	}	
fault handler setting error message 

========================= synapse sample_4206 =========================

public static TaskDescription createTaskDescription(OMElement el, OMNamespace tagetNamespace) {	if (log.isDebugEnabled()) {	
creating simplequartz task 

OMAttribute classAttr = el.getAttribute(new QName("class"));	if (classAttr != null && classAttr.getAttributeValue() != null) {	String classname = classAttr.getAttributeValue();	try {	Class.forName(classname).newInstance();	} catch (Exception e) {	handleException("Failed to load task class " + classname, e);	}	taskDescription.setTaskClass(classname);	} else {	
taskclass cannot be found task implementation may need a task class if there is no default one 

========================= synapse sample_1454 =========================

String name = null;	if (faultMediator instanceof SequenceMediator) {	name = ((SequenceMediator) faultMediator).getName();	}	if (name == null) {	name = faultMediator.getClass().getName();	}	if (traceOrDebugOn) {	traceOrDebugWarn(traceOn, "Executing fault handler mediator : " + name);	}	
executing fault sequence mediator 

========================= synapse sample_499 =========================

public void testDynamicLB() {	final String addUrl = "http: final StockQuoteSampleClient client = getStockQuoteClient();	
running test dynamic load balancing between nodes 

========================= synapse sample_2278 =========================

public boolean mediate(MessageContext synCtx) {	if (log.isDebugEnabled()) {	
mediation for event publisher started 

========================= synapse sample_533 =========================

public OMElement processDocument(final InputStream inputStream, final String contentType, final MessageContext messageContext) throws AxisFault {	if (log.isDebugEnabled()) {	
start building the hessian message in to a hessiandatasource 

}	OMText textData = factory.createOMText(dataHandler, true);	element.addChild(textData);	messageContext.setProperty(NhttpConstants.FAULTS_AS_HTTP_200, NhttpConstants.TRUE);	} catch (IOException e) {	String msg = "Unable to create the HessianDataSource";	log.error(msg, e);	throw new AxisFault(msg, e);	}	if (log.isDebugEnabled()) {	
building the hessian message using hessiandatasource is successful 

private PushbackInputStream detectAndMarkMessageFault(final MessageContext messageContext, final InputStream inputStream) throws IOException {	int bytesToRead = 4;	PushbackInputStream pis = new PushbackInputStream(inputStream, bytesToRead);	byte[] headerBytes = new byte[bytesToRead];	int n = pis.read(headerBytes);	if (n == bytesToRead) {	if (headerBytes[bytesToRead - 1] == HessianConstants.HESSIAN_V1_FAULT_IDENTIFIER || headerBytes[bytesToRead - 1] == HessianConstants.HESSIAN_V2_FAULT_IDENTIFIER) {	messageContext.setProperty(BaseConstants.FAULT_MESSAGE, SynapseConstants.TRUE);	if (log.isDebugEnabled()) {	
hessian fault detected marking in message context 

========================= synapse sample_2595 =========================

public void onComplete(AsyncResult result) {	
synapse received an async response to a callback 

========================= synapse sample_2983 =========================

public void init(ConfigurationContext cfgCtx, TransportOutDescription transportOut) throws AxisFault {	this.cfgCtx = cfgCtx;	sslContext = getSSLContext(transportOut);	Thread t = new Thread(new Runnable() {	public void run() {	executeClientEngine();	}	}, "HttpCoreNIOSender");	t.start();	
sender started 

private void executeClientEngine() {	HttpParams params = getClientParameters();	try {	ioReactor = new DefaultConnectingIOReactor(2, params);	} catch (IOException e) {	
error starting the ioreactor 

HttpParams params = getClientParameters();	try {	ioReactor = new DefaultConnectingIOReactor(2, params);	} catch (IOException e) {	}	handler = new ClientHandler(cfgCtx, params);	IOEventDispatch ioEventDispatch = getEventDispatch(handler, sslContext, params);	try {	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	
reactor interrupted 

try {	ioReactor = new DefaultConnectingIOReactor(2, params);	} catch (IOException e) {	}	handler = new ClientHandler(cfgCtx, params);	IOEventDispatch ioEventDispatch = getEventDispatch(handler, sslContext, params);	try {	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	} catch (IOException e) {	
encountered an i o error 

ioReactor = new DefaultConnectingIOReactor(2, params);	} catch (IOException e) {	}	handler = new ClientHandler(cfgCtx, params);	IOEventDispatch ioEventDispatch = getEventDispatch(handler, sslContext, params);	try {	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	} catch (IOException e) {	}	
sender shutdown 

private void sendAsyncRequest(EndpointReference epr, MessageContext msgContext) throws AxisFault {	try {	URL url = new URL(epr.getAddress());	HttpHost httpHost = new HttpHost(url.getHost(), url.getPort(), url.getProtocol());	Axis2HttpRequest axis2Req = new Axis2HttpRequest(epr, httpHost, msgContext);	NHttpClientConnection conn = ConnectionPool.getConnection(url.getHost(), url.getPort());	if (conn == null) {	SessionRequest req = ioReactor.connect( new InetSocketAddress(url.getHost(), url.getPort()), null, axis2Req);	
a new connection established 

private void sendAsyncRequest(EndpointReference epr, MessageContext msgContext) throws AxisFault {	try {	URL url = new URL(epr.getAddress());	HttpHost httpHost = new HttpHost(url.getHost(), url.getPort(), url.getProtocol());	Axis2HttpRequest axis2Req = new Axis2HttpRequest(epr, httpHost, msgContext);	NHttpClientConnection conn = ConnectionPool.getConnection(url.getHost(), url.getPort());	if (conn == null) {	SessionRequest req = ioReactor.connect( new InetSocketAddress(url.getHost(), url.getPort()), null, axis2Req);	} else {	((ClientHandler) handler).submitRequest(conn, axis2Req);	
an existing connection reused 

public void stop() {	try {	ioReactor.shutdown();	
sender shut down 

public void stop() {	try {	ioReactor.shutdown();	} catch (IOException e) {	
error shutting down ioreactor 

========================= synapse sample_3412 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start property mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

org.apache.axis2.context.MessageContext axis2MessageCtx = axis2smc.getAxis2MessageContext();	axis2MessageCtx.removeProperty(name);	} else if (XMLConfigConstants.SCOPE_TRANSPORT.equals(scope) && synCtx instanceof Axis2MessageContext) {	Axis2MessageContext axis2smc = (Axis2MessageContext) synCtx;	org.apache.axis2.context.MessageContext axis2MessageCtx = axis2smc.getAxis2MessageContext();	Object headers = axis2MessageCtx.getProperty( org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);	if (headers != null && headers instanceof Map) {	Map headersMap = (Map) headers;	headersMap.remove(name);	} else {	
no transport headers found for the message 

Axis2MessageContext axis2smc = (Axis2MessageContext) synCtx;	org.apache.axis2.context.MessageContext axis2MessageCtx = axis2smc.getAxis2MessageContext();	Object headers = axis2MessageCtx.getProperty( org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);	if (headers != null && headers instanceof Map) {	Map headersMap = (Map) headers;	headersMap.remove(name);	} else {	}	}	}	
end property mediator 

========================= synapse sample_548 =========================

public static SynapseConfiguration getConfiguration(String root, Properties properties) {	
building synapse configuration from the synapse artifact repository at 

public static SynapseConfiguration getConfiguration(String root, Properties properties) {	SynapseConfiguration synapseConfig = createConfigurationFromSynapseXML(root, properties);	if (synapseConfig == null) {	synapseConfig = SynapseConfigUtils.newConfiguration();	synapseConfig.setDefaultQName(XMLConfigConstants.DEFINITIONS_ELT);	} else if (log.isDebugEnabled()) {	
found a synapse configuration in the file at the artifact repository root which gets precedence over other definitions 

public static SynapseConfiguration getConfiguration(String root, Properties properties) {	SynapseConfiguration synapseConfig = createConfigurationFromSynapseXML(root, properties);	if (synapseConfig == null) {	synapseConfig = SynapseConfigUtils.newConfiguration();	synapseConfig.setDefaultQName(XMLConfigConstants.DEFINITIONS_ELT);	} else if (log.isDebugEnabled()) {	}	if (synapseConfig.getRegistry() == null) {	createRegistry(synapseConfig, root, properties);	} else if (log.isDebugEnabled()) {	
using the registry defined in the as the registry any definitions in the will be neglected 

} catch (IOException e) {	handleException("Error while opening the file: " + synapseXML.getName(), e);	return null;	}	try {	config = XMLConfigurationBuilder.getConfiguration(is, properties);	is.close();	} catch (XMLStreamException e) {	handleException("Error while loading the Synapse configuration from the " + synapseXML.getName() + " file", e);	} catch (IOException e) {	
error while closing the input stream from file 

private static void createRegistry(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File registryDef = new File(rootDirPath, REGISTRY_FILE);	if (registryDef.exists() && registryDef.isFile()) {	if (log.isDebugEnabled()) {	
initializing synapse registry from the configuration at 

private static void createLocalEntries(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File localEntriesDir = new File(rootDirPath, LOCAL_ENTRY_DIR);	if (localEntriesDir.exists()) {	if (log.isDebugEnabled()) {	
loading local entry definitions from 

private static void createProxyServices(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File proxyServicesDir = new File(rootDirPath, PROXY_SERVICES_DIR);	if (proxyServicesDir.exists()) {	if (log.isDebugEnabled()) {	
loading proxy services from 

private static void createTasks(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File tasksDir = new File(rootDirPath, TASKS_DIR);	if (tasksDir.exists()) {	if (log.isDebugEnabled()) {	
loading tasks from 

private static void createSequences(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File sequencesDir = new File(rootDirPath, SEQUENCES_DIR);	if (sequencesDir.exists()) {	if (log.isDebugEnabled()) {	
loading sequences from 

private static void createTemplates(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File templatesDir = new File(rootDirPath, TEMPLATES_DIR);	if (templatesDir.exists()) {	if (log.isDebugEnabled()) {	
loading template from 

private static void createEndpoints(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File endpointsDir = new File(rootDirPath, ENDPOINTS_DIR);	if (endpointsDir.exists()) {	if (log.isDebugEnabled()) {	
loading endpoints from 

private static void createEventSources(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File eventsDir = new File(rootDirPath, EVENTS_DIR);	if (eventsDir.exists()) {	if (log.isDebugEnabled()) {	
loading event sources from 

private static void createExecutors(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File executorsDir = new File(rootDirPath, EXECUTORS_DIR);	if (executorsDir.exists()) {	if (log.isDebugEnabled()) {	
loading event sources from 

private static void createMessageStores(SynapseConfiguration synapseConfig , String rootDirPath, Properties properties) {	File messageStoresDir = new File(rootDirPath, MESSAGE_STORE_DIR);	if (messageStoresDir.exists() ) {	if (log.isDebugEnabled()) {	
loading message stores from 

private static void createMessageProcessors(SynapseConfiguration synapseConfig, String rootDirPath, Properties properties) {	File messageProcessorDir = new File(rootDirPath, MESSAGE_PROCESSOR_DIR);	if (messageProcessorDir.exists()) {	if (log.isDebugEnabled()) {	
loading message processors from 

private static void createSynapseImports(SynapseConfiguration synapseConfig, String root, Properties properties) {	File synImportsDir = new File(root, SYNAPSE_IMPORTS_DIR);	if (synImportsDir.exists()) {	if (log.isDebugEnabled()) {	
loading synapse imports from 

private static void createAPIs(SynapseConfiguration synapseConfig, String rootDirPath) {	File apiDir = new File(rootDirPath, REST_API_DIR);	if (apiDir.exists()) {	if (log.isDebugEnabled()) {	
loading apis from 

is = FileUtils.openInputStream(file);	} catch (IOException e) {	handleException("Error while opening the file: " + file.getName() + " for reading", e);	return null;	}	OMElement document = OMXMLBuilderFactory.createOMBuilder(is).getDocumentElement();	document.build();	try {	is.close();	} catch (IOException e) {	
error while closing the input stream from the file 

private static void handleConfigurationError(String componentType, String msg, Exception e) {	if (SynapseConfigUtils.isFailSafeEnabled(componentType)) {	
continue in fail safe mode 

========================= synapse sample_1839 =========================

public boolean mediate(SynapseMessage synapseMessage) {	SynapseMessage request;	FailoverConfigurator failoverConfigurator;	try {	synapseEnvironment.setProperty("copy_message", ((Axis2SynapseMessage) synapseMessage).getMessageContext());	
failover mediation 

Map mediatorConfig = failoverConfigurator .getConfig(synapseMessage.getTo());	loadConfiguration(mediatorConfig);	FailoverRule rules[] = configuration.getRules();	int length = rules.length;	boolean shouldFailover;	if (this.synapseEnvironment == null) log.info("EMPTY ENVIRONMENT TO PASS");	SynapseMessage reply = null;	for (int i = 0; i < length; i++) {	request = new Axis2SynapseMessage((MessageContext) synapseEnvironment.getProperty("copy_message"));	String currentService = rules[i].getService();	
Service 

break;	}	FailoverRule rule = new FailoverRule();	rule.setService((String) mediatorConfig.get(serviceKey));	rule.setActive((String) mediatorConfig.get(activeKey));	rule.setPrimary((String) mediatorConfig.get(primaryKey));	long temp = Long.parseLong(mediatorConfig.get(timeoutKey).toString());	rule.setTimeout(temp);	configuration.addRule(rule);	}	
failover config map loaded into ruleset 

public void setSynapseEnvironment(SynapseEnvironment se) {	if (se == null) {	
the environment is null 

========================= synapse sample_2891 =========================

public void destroy() {	try {	if (started) {	try {	stop();	} catch (AxisFault ignore) {	
error stopping the transport 

if (soapAction != null) {	msgCtx.setSoapAction(soapAction);	}	msgCtx.setProperty(MessageContext.TRANSPORT_HEADERS, trpHeaders);	try {	try {	engine.receive(msgCtx);	} catch (AxisFault e) {	e.printStackTrace();	if (log.isDebugEnabled()) {	
error receiving message 

========================= synapse sample_3783 =========================

public static void convertSOAPFaultToPOX(MessageContext msgCtx) {	SOAPBody body = msgCtx.getEnvelope().getBody();	SOAPFault fault = body.getFault();	if (fault != null) {	OMFactory fac = msgCtx.getEnvelope().getOMFactory();	OMElement faultPayload = fac.createOMElement(new QName("Exception"));	if (fault.getDetail() != null && !fault.getDetail().getText().equals("")) {	String faultDetail = fault.getDetail().getText();	if (log.isDebugEnabled()) {	
setting the fault detail as athe pox fault 

OMFactory fac = msgCtx.getEnvelope().getOMFactory();	OMElement faultPayload = fac.createOMElement(new QName("Exception"));	if (fault.getDetail() != null && !fault.getDetail().getText().equals("")) {	String faultDetail = fault.getDetail().getText();	if (log.isDebugEnabled()) {	}	faultPayload.setText(faultDetail);	} else if (fault.getReason() != null && !fault.getReason().getText().equals("")) {	String faultReasonValue = fault.getReason().getText();	if (log.isDebugEnabled()) {	
setting the fault reason as athe pox fault 

String faultDetail = fault.getDetail().getText();	if (log.isDebugEnabled()) {	}	faultPayload.setText(faultDetail);	} else if (fault.getReason() != null && !fault.getReason().getText().equals("")) {	String faultReasonValue = fault.getReason().getText();	if (log.isDebugEnabled()) {	}	faultPayload.setText(faultReasonValue);	} else if (log.isDebugEnabled()) {	
couldn t find the fault detail or reason to compose pox fault 

========================= synapse sample_4046 =========================

public void addArtifact(String fileName, String artifactName) {	fileName = getNormalizedAbsolutePath(fileName);	if (!fileName2ArtifactName.containsKey(fileName)) {	if (log.isDebugEnabled()) {	
added deployment artifact with file 

public void addArtifact(String fileName, String artifactName) {	fileName = getNormalizedAbsolutePath(fileName);	if (!fileName2ArtifactName.containsKey(fileName)) {	if (log.isDebugEnabled()) {	}	fileName2ArtifactName.put(fileName, artifactName);	} else {	
an artifact has already been loaded from the file 

public void removeArtifactWithFileName(String fileName) {	fileName = getNormalizedAbsolutePath(fileName);	if (log.isDebugEnabled()) {	
removing deployment artifact with file 

public void addUpdatingArtifact(String fileName, String artifactName) {	fileName = getNormalizedAbsolutePath(fileName);	if (log.isDebugEnabled()) {	
added updating file 

public void removeUpdatingArtifact(String fileName) {	fileName = getNormalizedAbsolutePath(fileName);	if (log.isDebugEnabled()) {	
removing the updating file 

public void addRestoredArtifact(String fileName) {	fileName = getNormalizedAbsolutePath(fileName);	if (log.isDebugEnabled()) {	
added restored file 

public void removeRestoredFile(String fileName) {	fileName = getNormalizedAbsolutePath(fileName);	if (log.isDebugEnabled()) {	
removing restored file 

public void addBackedUpArtifact(String fileName) {	fileName = getNormalizedAbsolutePath(fileName);	if (log.isDebugEnabled()) {	
added backup file 

public void removeBackedUpArtifact(String fileName) {	fileName = getNormalizedAbsolutePath(fileName);	if (log.isDebugEnabled()) {	
removing backup file 

public static String getNormalizedAbsolutePath(String fileName) {	String path;	File file = new File(fileName);	try {	path = file.getCanonicalPath();	} catch (IOException e) {	
error while computing the canonical path of file 

========================= synapse sample_1614 =========================

public LSInput resolveResource(String type, String namespaceURI, String publicId, String systemId, String baseURI) {	if (log.isDebugEnabled()) {	
resolving schema resource 

public LSInput resolveResource(String type, String namespaceURI, String publicId, String systemId, String baseURI) {	if (log.isDebugEnabled()) {	}	if (resourceMap == null) {	
unable to resolve schema resource systemid external schema resources not defined in validate mediator configuration 

public LSInput resolveResource(String type, String namespaceURI, String publicId, String systemId, String baseURI) {	if (log.isDebugEnabled()) {	}	if (resourceMap == null) {	return null;	}	InputSource inputSource = resourceMap.resolve(synCfg, systemId);	if (inputSource == null) {	
unable to resolve schema resource 

========================= synapse sample_289 =========================

public void destroy() {	if (initialzed) {	if (log.isDebugEnabled()) {	log.debug("Shutting down priority executor" + (name != null ? ": " + name : ""));	}	executor.shutdown();	try {	executor.awaitTermination(100, TimeUnit.MILLISECONDS);	} catch (InterruptedException e) {	
failed to shut down executor 

public void run() {	try {	runnable.run();	} catch (Throwable e) {	
unhandled exception 

========================= synapse sample_773 =========================

public Object call(Context context, List args) throws FunctionCallException {	boolean debugOn = log.isDebugEnabled();	if (args == null || args.size() == 0) {	if (debugOn) {	
property key value for lookup is not specified 

int size = args.size();	if (size == 1) {	String value = StringFunction.evaluate(args.get(0), context.getNavigator());	return encode(debugOn, SynapseXPathConstants.DEFAULT_CHARSET, value);	} else if (size == 2) {	String value = StringFunction.evaluate(args.get(0), context.getNavigator());	String encoding = StringFunction.evaluate(args.get(1), context.getNavigator());	return encode(debugOn, encoding, value);	} else {	if (debugOn) {	
function expects only one argument returning empty string 

private Object encode(boolean debugOn, String encoding, String value) throws FunctionCallException {	if (value == null || "".equals(value)) {	if (debugOn) {	
non emprty string value should be provided for encoding 

}	String encodedString;	try {	encodedString = new String(encodedValue, encoding);	} catch (UnsupportedEncodingException e) {	String msg = "Unsupported Encoding";	log.error(msg, e);	throw new FunctionCallException(msg, e);	}	if (debugOn) {	
converted string with encoding to encoded value 

========================= synapse sample_266 =========================

private void registerExtensions() {	Iterator it = Service.providers(MediatorFactory.class);	while (it.hasNext()) {	MediatorFactory mf = (MediatorFactory) it.next();	QName tag = mf.getTagQName();	factoryMap.put(tag, mf.getClass());	if (log.isDebugEnabled()) {	
added mediatorfactory to handle 

public Mediator getMediator(OMElement element) {	String localName = element.getLocalName();	QName qName;	if (element.getNamespace() != null) {	qName = new QName(element.getNamespace().getNamespaceURI(), localName);	} else {	qName = new QName(localName);	}	if (log.isDebugEnabled()) {	
getmediator 

} else {	qName = new QName(localName);	}	if (log.isDebugEnabled()) {	}	Class cls = factoryMap.get(qName);	if (cls == null && localName.indexOf('.') > -1) {	String newLocalName = localName.substring(0, localName.indexOf('.'));	qName = new QName(element.getNamespace().getNamespaceURI(), newLocalName);	if (log.isDebugEnabled()) {	
getmediator 

========================= synapse sample_4103 =========================

public void connected(final NHttpClientConnection conn, final Object attachment) {	if (log.isDebugEnabled() ) {	
clienthandler connected 

String message = getErrorMessage("Connection close", conn);	if (log.isTraceEnabled()) {	log.trace(message);	}	Axis2HttpRequest axis2Request = (Axis2HttpRequest) conn.getContext().getAttribute(AXIS2_HTTP_REQUEST);	if (axis2Request != null && !axis2Request.isCompleted()) {	checkAxisRequestComplete(conn, NhttpConstants.CONNECTION_CLOSED, message, null);	shutdownConnection(conn, true, "Connection closed before response is received");	} else {	if (log.isDebugEnabled()) {	
keep alive connection closed 

String message = getErrorMessage("Connection timeout", conn);	if (log.isDebugEnabled()) {	log.debug(message);	}	Axis2HttpRequest axis2Request = (Axis2HttpRequest) conn.getContext().getAttribute(AXIS2_HTTP_REQUEST);	if (axis2Request != null && !axis2Request.isCompleted()) {	checkAxisRequestComplete(conn, NhttpConstants.CONNECTION_TIMEOUT, message, null);	shutdownConnection(conn, true, "Connection timeout before response is received");	} else {	if (log.isDebugEnabled()) {	
keep alive connection timed out 

}	}	workerPool.execute( new Runnable() {	public void run() {	MessageReceiver mr = mc.getAxisOperation().getMessageReceiver();	try {	AxisFault axisFault = exceptionToRaise != null ? new AxisFault(errorMessage, exceptionToRaise) : new AxisFault(errorMessage);	MessageContext nioFaultMessageContext = MessageContextBuilder.createFaultMessageContext(mc, axisFault);	SOAPEnvelope envelope = nioFaultMessageContext.getEnvelope();	if (log.isDebugEnabled()) {	
sending fault for request with message id 

nioFaultMessageContext.setProperty( NhttpConstants.ERROR_DETAIL, exceptionToRaise.toString());	nioFaultMessageContext.setProperty( NhttpConstants.ERROR_EXCEPTION, exceptionToRaise);	envelope.getBody().getFault().getDetail().setText( exceptionToRaise.toString());	} else {	nioFaultMessageContext.setProperty( NhttpConstants.ERROR_DETAIL, errorMessage);	envelope.getBody().getFault().getDetail().setText(errorMessage);	}	nioFaultMessageContext.setProperty(CLIENT_CONNECTION_DEBUG, mc.getProperty(CLIENT_CONNECTION_DEBUG));	mr.receive(nioFaultMessageContext);	} catch (AxisFault af) {	
unable to report back failure to the message receiver 

public void responseReceived(final NHttpClientConnection conn) {	setServerContextAttribute(NhttpConstants.RES_HEADER_ARRIVAL_TIME, System.currentTimeMillis(), conn);	HttpContext context = conn.getContext();	HttpResponse response = conn.getHttpResponse();	if (response.getStatusLine().getStatusCode() == HttpStatus.SC_CONTINUE) {	if (log.isDebugEnabled()) {	
received a continue response 

return;	}	ClientConnectionDebug ccd = (ClientConnectionDebug) conn.getContext().getAttribute(CLIENT_CONNECTION_DEBUG);	if (ccd != null) {	ccd.recordResponseStartTime(response.getStatusLine().toString());	}	Axis2HttpRequest req = (Axis2HttpRequest) conn.getContext().getAttribute(AXIS2_HTTP_REQUEST);	if (req != null) {	req.setCompleted(true);	if (log.isDebugEnabled()) {	
response received for request 

req.setCompleted(true);	if (log.isDebugEnabled()) {	}	if (!req.isSendingCompleted()) {	req.getMsgContext().setProperty( NhttpConstants.ERROR_CODE, NhttpConstants.SEND_ABORT);	SharedOutputBuffer outputBuffer = (SharedOutputBuffer) conn.getContext().getAttribute(REQUEST_SOURCE_BUFFER);	if (outputBuffer != null) {	outputBuffer.shutdown();	}	if (log.isDebugEnabled()) {	
remote server aborted request being sent and replied for request 

}	context.setAttribute(NhttpConstants.DISCARD_ON_COMPLETE, Boolean.TRUE);	if (metrics != null) {	metrics.incrementFaultsSending(NhttpConstants.SEND_ABORT, req.getMsgContext());	}	}	}	switch (response.getStatusLine().getStatusCode()) {	case HttpStatus.SC_ACCEPTED : {	if (log.isDebugEnabled()) {	
received a accepted response 

responseMsgCtx.setTo(null);	if (!outMsgCtx.isDoingREST() && !outMsgCtx.isSOAP11()) {	responseMsgCtx.setEnvelope(OMAbstractFactory.getSOAP12Factory().getDefaultEnvelope());	} else {	responseMsgCtx.setEnvelope(OMAbstractFactory.getSOAP11Factory().getDefaultEnvelope());	}	responseMsgCtx.setProperty(AddressingConstants. DISABLE_ADDRESSING_FOR_OUT_MESSAGES, Boolean.TRUE);	responseMsgCtx.setProperty(NhttpConstants.SC_ACCEPTED, Boolean.TRUE);	mr.receive(responseMsgCtx);	} catch (org.apache.axis2.AxisFault af) {	
unable to report back accepted state to the message receiver 

}	}	return;	}	case HttpStatus.SC_OK : {	processResponse(conn, context, response);	return;	}	case HttpStatus.SC_INTERNAL_SERVER_ERROR: {	if (warnOnHttp500(response)) {	
received an internal server error 

return;	}	case HttpStatus.SC_INTERNAL_SERVER_ERROR: {	if (warnOnHttp500(response)) {	}	processResponse(conn, context, response);	return;	}	default : {	if (log.isDebugEnabled()) {	
http status code received 

processResponse(conn, context, response);	return;	}	default : {	if (log.isDebugEnabled()) {	}	Header contentType = response.getFirstHeader(HTTP.CONTENT_TYPE);	if (contentType != null) {	if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf( SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	
received an unexpected response with a soap payload 

default : {	if (log.isDebugEnabled()) {	}	Header contentType = response.getFirstHeader(HTTP.CONTENT_TYPE);	if (contentType != null) {	if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf( SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	}	} else if (contentType.getValue().indexOf("html") == -1) {	if (log.isDebugEnabled()) {	
received an unexpected response with a pox rest payload 

}	Header contentType = response.getFirstHeader(HTTP.CONTENT_TYPE);	if (contentType != null) {	if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf( SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	}	} else if (contentType.getValue().indexOf("html") == -1) {	if (log.isDebugEnabled()) {	}	} else {	
received an unexpected response of content type and status code with reason 

if ((contentType.getValue().indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) >= 0) || contentType.getValue().indexOf( SOAP12Constants.SOAP_12_CONTENT_TYPE) >=0) {	if (log.isDebugEnabled()) {	}	} else if (contentType.getValue().indexOf("html") == -1) {	if (log.isDebugEnabled()) {	}	} else {	}	} else {	if (log.isDebugEnabled()) {	
received a response without a content type with status code and reason 

========================= synapse sample_1028 =========================

public void init(ConfigurationContext configurationContext, AxisModule axisModule) throws AxisFault {	
initializing synapse at 

if (ipAddr != null) {	MDC.put("ip", ipAddr);	}	String hostname = addr.getHostName();	if (hostname == null) {	hostname = ipAddr;	}	MDC.put("host", hostname);	}	} catch (UnknownHostException e) {	
unable to determine hostname or ip address of the server for logging 

MDC.put("ip", ipAddr);	}	String hostname = addr.getHostName();	if (hostname == null) {	hostname = ipAddr;	}	MDC.put("host", hostname);	}	} catch (UnknownHostException e) {	}	
loading mediator extensions 

}	String hostname = addr.getHostName();	if (hostname == null) {	hostname = ipAddr;	}	MDC.put("host", hostname);	}	} catch (UnknownHostException e) {	}	configurationContext.getAxisConfiguration().getConfigurator().loadServices();	
initializing the synapse configuration 

String hostname = addr.getHostName();	if (hostname == null) {	hostname = ipAddr;	}	MDC.put("host", hostname);	}	} catch (UnknownHostException e) {	}	configurationContext.getAxisConfiguration().getConfigurator().loadServices();	synCfg = getConfiguration(configurationContext);	
deploying the synapse service 

AxisConfiguration axisCfg = configurationContext.getAxisConfiguration();	AxisService synapseService = new AxisService(SynapseConstants.SYNAPSE_SERVICE_NAME);	AxisOperation mediateOperation = new InOutAxisOperation(SynapseConstants.SYNAPSE_OPERATION_NAME);	mediateOperation.setMessageReceiver(new SynapseMessageReceiver());	synapseService.addOperation(mediateOperation);	List transports = new ArrayList();	transports.add(Constants.TRANSPORT_HTTP);	transports.add(Constants.TRANSPORT_HTTPS);	synapseService.setExposedTransports(transports);	axisCfg.addService(synapseService);	
initializing sandesha 

if (sandeshaAxisModule != null) {	Module sandesha2 = sandeshaAxisModule.getModule();	sandesha2.init(configurationContext, sandeshaAxisModule);	}	String thisServerName = System.getProperty(SynapseConstants.SYNAPSE_SERVER_NAME);	if(thisServerName == null || thisServerName.equals("")) {	try {	InetAddress addr = InetAddress.getLocalHost();	thisServerName = addr.getHostName();	} catch (UnknownHostException e) {	
could not get local host name 

if(thisServerName == null || thisServerName.equals("")) {	try {	InetAddress addr = InetAddress.getLocalHost();	thisServerName = addr.getHostName();	} catch (UnknownHostException e) {	}	if(thisServerName == null || thisServerName.equals("")) {	thisServerName = "localhost";	}	}	
synapse server name 

if(thisServerName == null || thisServerName.equals("")) {	try {	InetAddress addr = InetAddress.getLocalHost();	thisServerName = addr.getHostName();	} catch (UnknownHostException e) {	}	if(thisServerName == null || thisServerName.equals("")) {	thisServerName = "localhost";	}	}	
deploying proxy services 

if(thisServerName == null || thisServerName.equals("")) {	thisServerName = "localhost";	}	}	Iterator iter = synCfg.getProxyServices().iterator();	while (iter.hasNext()) {	ProxyService proxy = (ProxyService) iter.next();	List pinnedServers = proxy.getPinnedServers();	if(pinnedServers != null && !pinnedServers.isEmpty()) {	if(!pinnedServers.contains(thisServerName)) {	
server name not in pinned servers list not deploying proxy service 

Iterator iter = synCfg.getProxyServices().iterator();	while (iter.hasNext()) {	ProxyService proxy = (ProxyService) iter.next();	List pinnedServers = proxy.getPinnedServers();	if(pinnedServers != null && !pinnedServers.isEmpty()) {	if(!pinnedServers.contains(thisServerName)) {	continue;	}	}	proxy.buildAxisService(synCfg, axisCfg);	
deployed proxy service 

if(pinnedServers != null && !pinnedServers.isEmpty()) {	if(!pinnedServers.contains(thisServerName)) {	continue;	}	}	proxy.buildAxisService(synCfg, axisCfg);	if (!proxy.isStartOnLoad()) {	proxy.stop(synCfg);	}	}	
synapse initialized successfully 

private static SynapseConfiguration getConfiguration(ConfigurationContext cfgCtx) {	cfgCtx.setProperty("addressing.validateAction", Boolean.FALSE);	AxisConfiguration axisConfiguration = cfgCtx.getAxisConfiguration();	SynapseConfiguration synapseConfiguration;	String config = System.getProperty(SynapseConstants.SYNAPSE_XML);	if (config != null) {	if (log.isDebugEnabled()) {	
system property specifies synapse configuration as 

private static SynapseConfiguration getConfiguration(ConfigurationContext cfgCtx) {	cfgCtx.setProperty("addressing.validateAction", Boolean.FALSE);	AxisConfiguration axisConfiguration = cfgCtx.getAxisConfiguration();	SynapseConfiguration synapseConfiguration;	String config = System.getProperty(SynapseConstants.SYNAPSE_XML);	if (config != null) {	if (log.isDebugEnabled()) {	}	synapseConfiguration = SynapseConfigurationBuilder.getConfiguration(config);	} else {	
system property is not specified using default configuration 

========================= synapse sample_3500 =========================

int maxRetryCount = vfsOutInfo.getMaxRetryCount();	long reconnectionTimeout = vfsOutInfo.getReconnectTimeout();	boolean append = vfsOutInfo.isAppend();	boolean isUseTempFile = vfsOutInfo.isUseTempFile();	String tempTargetFileName, actualTargetFileName = null;	while (wasError) {	try {	retryCount++;	replyFile = fsManager.resolveFile(vfsOutInfo.getOutFileURI());	if (replyFile == null) {	
replyfile is null 

String tempTargetFileName, actualTargetFileName = null;	while (wasError) {	try {	retryCount++;	replyFile = fsManager.resolveFile(vfsOutInfo.getOutFileURI());	if (replyFile == null) {	throw new FileSystemException("replyFile is null");	}	wasError = false;	} catch (FileSystemException e) {	
cannot resolve replyfile 

private void acquireLockForSending(FileObject responseFile, VFSOutTransportInfo vfsOutInfo) throws AxisFault {	int tryNum = 0;	while (!VFSUtils.acquireLock(fsManager, responseFile)) {	if (vfsOutInfo.getMaxRetryCount() == tryNum++) {	handleException("Couldn't send the message to file : " + responseFile.getName() + ", unable to acquire the " + "lock even after " + tryNum + " retries");	} else {	
couldn t get the lock for the file retry scheduled after 

========================= synapse sample_2311 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
sequence deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	Mediator m = MediatorFactoryFinder.getInstance().getMediator( artifactConfig, properties);	if (m instanceof SequenceMediator) {	SequenceMediator seq = (SequenceMediator) m;	seq.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
sequence named has been built from the file 

}	try {	Mediator m = MediatorFactoryFinder.getInstance().getMediator( artifactConfig, properties);	if (m instanceof SequenceMediator) {	SequenceMediator seq = (SequenceMediator) m;	seq.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	seq.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	
initialized the sequence 

if (m instanceof SequenceMediator) {	SequenceMediator seq = (SequenceMediator) m;	seq.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	seq.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addSequence(seq.getName(), seq);	if (log.isDebugEnabled()) {	
sequence deployment from file completed 

SequenceMediator seq = (SequenceMediator) m;	seq.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	seq.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addSequence(seq.getName(), seq);	if (log.isDebugEnabled()) {	}	
sequence named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
sequence update from file has started 

if (m == null || !(m instanceof  SequenceMediator)) {	handleSynapseArtifactDeploymentError("Sequence update failed. The artifact " + "defined in the file: " + fileName + " is not a valid sequence.");	return null;	}	SequenceMediator seq = (SequenceMediator) m;	seq.setFileName(new File(fileName).getName());	if ((SynapseConstants.MAIN_SEQUENCE_KEY.equals(existingArtifactName) || SynapseConstants.FAULT_SEQUENCE_KEY.equals(existingArtifactName)) && !existingArtifactName.equals(seq.getName())) {	handleSynapseArtifactDeploymentError(existingArtifactName + " sequence cannot be renamed");	}	if (log.isDebugEnabled()) {	
sequence has been built from the file 

}	if (log.isDebugEnabled()) {	}	seq.init(getSynapseEnvironment());	SequenceMediator existingSeq = getSynapseConfiguration().getDefinedSequences(). get(existingArtifactName);	if (existingArtifactName.equals(seq.getName())) {	getSynapseConfiguration().updateSequence(existingArtifactName, seq);	} else {	getSynapseConfiguration().addSequence(seq.getName(), seq);	getSynapseConfiguration().removeSequence(existingArtifactName);	
sequence has been undeployed 

if (log.isDebugEnabled()) {	}	seq.init(getSynapseEnvironment());	SequenceMediator existingSeq = getSynapseConfiguration().getDefinedSequences(). get(existingArtifactName);	if (existingArtifactName.equals(seq.getName())) {	getSynapseConfiguration().updateSequence(existingArtifactName, seq);	} else {	getSynapseConfiguration().addSequence(seq.getName(), seq);	getSynapseConfiguration().removeSequence(existingArtifactName);	}	
sequence has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
sequence undeployment of the sequence named started 

if (log.isDebugEnabled()) {	}	try {	SequenceMediator seq = getSynapseConfiguration().getDefinedSequences().get(artifactName);	if (seq != null) {	if (SynapseConstants.MAIN_SEQUENCE_KEY.equals(seq.getName()) || SynapseConstants.FAULT_SEQUENCE_KEY.equals(seq.getName())) {	handleSynapseArtifactDeploymentError( "Cannot Undeploy the " + seq.getName() + " sequence");	}	getSynapseConfiguration().removeSequence(artifactName);	if (log.isDebugEnabled()) {	
destroying the sequence named 

SequenceMediator seq = getSynapseConfiguration().getDefinedSequences().get(artifactName);	if (seq != null) {	if (SynapseConstants.MAIN_SEQUENCE_KEY.equals(seq.getName()) || SynapseConstants.FAULT_SEQUENCE_KEY.equals(seq.getName())) {	handleSynapseArtifactDeploymentError( "Cannot Undeploy the " + seq.getName() + " sequence");	}	getSynapseConfiguration().removeSequence(artifactName);	if (log.isDebugEnabled()) {	}	seq.destroy();	if (log.isDebugEnabled()) {	
sequence undeployment of the sequence named completed 

if (seq != null) {	if (SynapseConstants.MAIN_SEQUENCE_KEY.equals(seq.getName()) || SynapseConstants.FAULT_SEQUENCE_KEY.equals(seq.getName())) {	handleSynapseArtifactDeploymentError( "Cannot Undeploy the " + seq.getName() + " sequence");	}	getSynapseConfiguration().removeSequence(artifactName);	if (log.isDebugEnabled()) {	}	seq.destroy();	if (log.isDebugEnabled()) {	}	
sequence named has been undeployed 

if (SynapseConstants.MAIN_SEQUENCE_KEY.equals(seq.getName()) || SynapseConstants.FAULT_SEQUENCE_KEY.equals(seq.getName())) {	handleSynapseArtifactDeploymentError( "Cannot Undeploy the " + seq.getName() + " sequence");	}	getSynapseConfiguration().removeSequence(artifactName);	if (log.isDebugEnabled()) {	}	seq.destroy();	if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
sequence has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the sequence with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	SequenceMediator seq = getSynapseConfiguration().getDefinedSequences().get(artifactName);	OMElement seqElem = MediatorSerializerFinder.getInstance().getSerializer(seq). serializeMediator(null, seq);	if (seq.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.SEQUENCES_DIR + File.separator + seq.getFileName();	writeToFile(seqElem, fileName);	if (log.isDebugEnabled()) {	
restoring the sequence with name completed 

if (log.isDebugEnabled()) {	}	try {	SequenceMediator seq = getSynapseConfiguration().getDefinedSequences().get(artifactName);	OMElement seqElem = MediatorSerializerFinder.getInstance().getSerializer(seq). serializeMediator(null, seq);	if (seq.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.SEQUENCES_DIR + File.separator + seq.getFileName();	writeToFile(seqElem, fileName);	if (log.isDebugEnabled()) {	}	
sequence named has been restored 

========================= synapse sample_1602 =========================

public boolean createFIXAcceptor(AxisService service) throws AxisFault {	InputStream fixConfigStream = getFIXConfigAsStream(service, true);	if (fixConfigStream != null) {	try {	if (log.isDebugEnabled()) {	
initializing a new fix session for the service 

public void createFIXInitiator(String fixEPR, AxisService service, SessionID sessionID) throws AxisFault {	if (log.isDebugEnabled()) {	
initializing a new fix initiator for the service 

if (threadedConnector) {	initiator = new ThreadedSocketInitiator( messageHandler, storeFactory, settings, logFactory, messageFactory);	} else {	initiator = new SocketInitiator( messageHandler, storeFactory, settings, logFactory, messageFactory);	}	initiator.start();	initJMX(initiator, service.getName());	initiatorStore.put(fixEPR, initiator);	applicationStore.put(fixEPR, messageHandler);	FIXIncomingMessageHandler fixMessageHandler = (FIXIncomingMessageHandler) messageHandler;	
waiting for logon procedure to complete 

public boolean createFIXInitiator(AxisService service) throws AxisFault {	InputStream fixConfigStream = getFIXConfigAsStream(service, false);	if (fixConfigStream != null) {	if (log.isDebugEnabled()) {	
attempting to initialize a new fix initiator for the service 

} catch (FieldConvertError e) {	String msg = "FIX configuration file for the initiator session of the service " + service.getName() + " is either incomplete or invalid." + " Not creating the initiator session at this stage.";	log.error(msg, e);	throw new AxisFault(msg, e);	} catch (ConfigError e) {	String msg = "FIX configuration file for the initiator session of the service " + service.getName() + " is either incomplete or invalid." + " Not creating the initiator session at this stage.";	log.error(msg, e);	throw new AxisFault(msg, e);	}	} else {	
the parameter is not specified unable to initialize the initiator session at this stage 

public void disposeFIXAcceptor(AxisService service) {	if (log.isDebugEnabled()) {	
stopping the fix acceptor for the service 

public void disposeFIXAcceptor(AxisService service) {	if (log.isDebugEnabled()) {	}	Acceptor acceptor = acceptorStore.get(service.getName());	if (acceptor != null) {	acceptor.stop();	
fix session for service terminated 

public void disposeFIXInitiators() {	boolean debugEnabled = log.isDebugEnabled();	for (String key : initiatorStore.keySet()) {	initiatorStore.get(key).stop();	if (debugEnabled) {	
fix initiator to the epr stopped 

public String[] getServiceEPRs(String serviceName, String ip) {	if (log.isDebugEnabled()) {	
getting eprs for the service 

fixConfigURLParam = service.getParameter(FIXConstants.FIX_ACCEPTOR_CONFIG_URL_PARAM);	} else {	fixConfigURLParam = service.getParameter(FIXConstants.FIX_INITIATOR_CONFIG_URL_PARAM);	}	if (fixConfigURLParam != null) {	String fixConfigURLValue = fixConfigURLParam.getValue().toString();	try {	URL url = new URL(fixConfigURLValue);	fixConfigStream = url.openStream();	} catch (MalformedURLException e) {	
the fix configuration url is malformed 

} else {	fixConfigURLParam = service.getParameter(FIXConstants.FIX_INITIATOR_CONFIG_URL_PARAM);	}	if (fixConfigURLParam != null) {	String fixConfigURLValue = fixConfigURLParam.getValue().toString();	try {	URL url = new URL(fixConfigURLValue);	fixConfigStream = url.openStream();	} catch (MalformedURLException e) {	} catch (IOException e) {	
error while reading from the url 

}	if (fixConfigURLParam != null) {	String fixConfigURLValue = fixConfigURLParam.getValue().toString();	try {	URL url = new URL(fixConfigURLValue);	fixConfigStream = url.openStream();	} catch (MalformedURLException e) {	} catch (IOException e) {	}	} else {	
fix configuration url is not specified for the service 

if (msgLogMethod != null) {	String method = msgLogMethod.getValue().toString();	log.info("FIX message logging method = " + method);	if (FIXConstants.JDBC_BASED_MESSAGE_STORE.equals(method)) {	storeFactory = new JdbcStoreFactory(settings);	} else if (FIXConstants.SLEEPYCAT_BASED_MESSAGE_STORE.equals(method)) {	storeFactory = new SleepycatStoreFactory(settings);	} else if (FIXConstants.FILE_BASED_MESSAGE_STORE.equals(method)) {	storeFactory = new FileStoreFactory(settings);	} else if (!FIXConstants.MEMORY_BASED_MESSAGE_STORE.equals(method)) {	
invalid message store using defaults 

private void initJMX(Connector connector, String service) {	try {	JmxExporter jmxExporter = new JmxExporter();	jmxExporter.setRegistrationBehavior(JmxExporter.REGISTRATION_IGNORE_EXISTING);	jmxExporter.export(connector);	} catch (JMException e) {	
error while initializing jmx support for the service 

========================= synapse sample_2491 =========================

public void setMessage(OMElement elem) {	
set message 

public void execute() {	if (log.isDebugEnabled()) {	
execute 

PayloadHelper.setXMLPayload(envelope, message.cloneOMElement());	axis2MsgCtx.setEnvelope(envelope);	} catch (AxisFault axisFault) {	handleError("Error in setting the message payload : " + message);	}	if (soapAction != null) {	axis2MsgCtx.setSoapAction(soapAction);	}	try {	if (log.isDebugEnabled()) {	
injecting message to proxy service 

if (soapAction != null) {	mc.setSoapAction(soapAction);	}	if (INJECT_TO_SEQUENCE.equalsIgnoreCase(injectTo)) {	if (sequenceName == null || sequenceName.equals("")) {	handleError("Sequence name not specified");	}	SequenceMediator seq = (SequenceMediator) synapseEnvironment.getSynapseConfiguration(). getSequence(sequenceName);	if (seq != null) {	if (log.isDebugEnabled()) {	
injecting message to sequence 

SequenceMediator seq = (SequenceMediator) synapseEnvironment.getSynapseConfiguration(). getSequence(sequenceName);	if (seq != null) {	if (log.isDebugEnabled()) {	}	synapseEnvironment.injectAsync(mc, seq);	} else {	handleError("Sequence: " + sequenceName + " not found");	}	} else {	if (log.isDebugEnabled()) {	
injecting message to main sequence 

========================= synapse sample_620 =========================

public static void removeAndReplicateState(String key, ConfigurationContext configCtx) {	if (configCtx != null && key != null) {	try {	if (log.isDebugEnabled()) {	
start replicating the property removal with key 

public static void removeAndReplicateState(String key, ConfigurationContext configCtx) {	if (configCtx != null && key != null) {	try {	if (log.isDebugEnabled()) {	}	configCtx.removePropertyNonReplicable(key);	org.apache.axis2.clustering.state.Replicator.replicate( configCtx, new String[]{key});	if (log.isDebugEnabled()) {	
completed replication of the property removal with key 

public static void setAndReplicateState(String key, Object value, ConfigurationContext configCtx) {	if (configCtx != null && key != null && value != null) {	try {	if (log.isDebugEnabled()) {	
start replicating the property with key value 

public static void setAndReplicateState(String key, Object value, ConfigurationContext configCtx) {	if (configCtx != null && key != null && value != null) {	try {	if (log.isDebugEnabled()) {	}	configCtx.setNonReplicableProperty(key, value);	org.apache.axis2.clustering.state.Replicator.replicate( configCtx, new String[]{key});	if (log.isDebugEnabled()) {	
completed replication of the property with key 

========================= synapse sample_270 =========================

public void testURLRewriteMultiple() {	
running test conditional url rewriting with multiple rules 

========================= synapse sample_2242 =========================

public void receive(MessageContext mc) throws AxisFault {	
synapse received message 

========================= synapse sample_2757 =========================

public void send(MessageContext synMessageContext) {	if (log.isDebugEnabled()) {	
start session affinity load balance endpoint 

========================= synapse sample_4007 =========================

public void init(SynapseEnvironment se) {	if (resources.isEmpty()) {	handleException("The API: " + name + " has been configured without " + "any resource definitions");	}	
initializing api 

public void destroy() {	
destroying api 

========================= synapse sample_677 =========================

try {	InetAddress addr = InetAddress.getLocalHost();	if (addr != null) {	String ipAddr = addr.getHostAddress();	if (ipAddr != null) MDC.put("ip", ipAddr);	String hostname = addr.getHostName();	MDC.put("host", hostname);	}	}	catch (UnknownHostException e) {	
unable to report hostname or ip address for tracing 

InetAddress addr = InetAddress.getLocalHost();	if (addr != null) {	String ipAddr = addr.getHostAddress();	if (ipAddr != null) MDC.put("ip", ipAddr);	String hostname = addr.getHostName();	MDC.put("host", hostname);	}	}	catch (UnknownHostException e) {	}	
deploying the synapse service 

}	}	catch (UnknownHostException e) {	}	AxisConfiguration axisCfg = configurationContext.getAxisConfiguration();	AxisService synapseService = new AxisService(SYNAPSE_SERVICE_NAME);	AxisOperation mediateOperation = new InOutAxisOperation(MEDIATE_OPERATION_Q_NAME);	mediateOperation.setMessageReceiver(new SynapseMessageReceiver());	synapseService.addOperation(mediateOperation);	axisCfg.addService(synapseService);	
initializing the synapse configuration 

}	catch (UnknownHostException e) {	}	AxisConfiguration axisCfg = configurationContext.getAxisConfiguration();	AxisService synapseService = new AxisService(SYNAPSE_SERVICE_NAME);	AxisOperation mediateOperation = new InOutAxisOperation(MEDIATE_OPERATION_Q_NAME);	mediateOperation.setMessageReceiver(new SynapseMessageReceiver());	synapseService.addOperation(mediateOperation);	axisCfg.addService(synapseService);	SynapseConfiguration synCfg = initializeSynapse(configurationContext);	
deploying proxy services 

axisCfg.addService(synapseService);	SynapseConfiguration synCfg = initializeSynapse(configurationContext);	Iterator iter = synCfg.getProxyServices().iterator();	while (iter.hasNext()) {	ProxyService proxy = (ProxyService) iter.next();	proxy.buildAxisService(synCfg, axisCfg);	if (!proxy.isStartOnLoad()) {	proxy.stop(synCfg);	}	}	
synapse initialized successfully 

private static SynapseConfiguration initializeSynapse( ConfigurationContext cfgCtx) {	AxisConfiguration axisConfiguration = cfgCtx.getAxisConfiguration();	First check, if synapse.xml URL is provided as a system property, if so use it.. else check if synapse.xml location is available from the axis2.xml "SynapseConfiguration" else use the default config SynapseConfiguration synapseConfiguration;	Parameter configParam = axisConfiguration.getParameter(Constants.SYNAPSE_CONFIGURATION);	String config = System.getProperty(Constants.SYNAPSE_XML);	if (config != null) {	
system property specifies synapse configuration as 

private static SynapseConfiguration initializeSynapse( ConfigurationContext cfgCtx) {	AxisConfiguration axisConfiguration = cfgCtx.getAxisConfiguration();	First check, if synapse.xml URL is provided as a system property, if so use it.. else check if synapse.xml location is available from the axis2.xml "SynapseConfiguration" else use the default config SynapseConfiguration synapseConfiguration;	Parameter configParam = axisConfiguration.getParameter(Constants.SYNAPSE_CONFIGURATION);	String config = System.getProperty(Constants.SYNAPSE_XML);	if (config != null) {	synapseConfiguration = SynapseConfigurationBuilder.getConfiguration(config);	} else if (configParam != null) {	
synapse configuration is available via the synapseconfiguration parameter in xml 

private static SynapseConfiguration initializeSynapse( ConfigurationContext cfgCtx) {	AxisConfiguration axisConfiguration = cfgCtx.getAxisConfiguration();	First check, if synapse.xml URL is provided as a system property, if so use it.. else check if synapse.xml location is available from the axis2.xml "SynapseConfiguration" else use the default config SynapseConfiguration synapseConfiguration;	Parameter configParam = axisConfiguration.getParameter(Constants.SYNAPSE_CONFIGURATION);	String config = System.getProperty(Constants.SYNAPSE_XML);	if (config != null) {	synapseConfiguration = SynapseConfigurationBuilder.getConfiguration(config);	} else if (configParam != null) {	synapseConfiguration = SynapseConfigurationBuilder .getConfiguration(configParam.getValue().toString().trim());	} else {	
system property is not specified or synapseconfiguration parameter is not available via xml using default configuration 

========================= synapse sample_2995 =========================

suiteName = "AllSamplesSuite";	for (int i = 0; i <= 20000; i++) {	Class testClass = (Class) sampleClassRepo.get(Integer.toString(i));	if (testClass != null) {	suiteClassesList.add(testClass);	}	}	}	for (Class testClass : suiteClassesList) {	suite.addTestSuite(testClass);	
adding sample 

========================= synapse sample_2215 =========================

public Axis2HttpRequest(EndpointReference epr, HttpHost httpHost, MessageContext msgContext) {	this.epr = epr;	this.httpHost = httpHost;	this.msgContext = msgContext;	try {	this.pipe = Pipe.open();	} catch (IOException e) {	
error creating pipe to write message body 

public Pipe.SourceChannel getSourceChannel() {	
get source channel of the pipe on which the outgoing response is written 

public void streamMessageContents() throws AxisFault {	
start streaming outgoing http request 

========================= synapse sample_3404 =========================

public PipeImpl() throws IOException {	if (useNative) {	Pipe pipe = Pipe.open();	source = pipe.source();	sink = pipe.sink();	} else {	PipedInputStream pipedIn = new PipedInputStream();	try {	pipedOut = new PipedOutputStream(pipedIn);	} catch (IOException e) {	
unable to create an in memory pipe 

========================= synapse sample_4284 =========================

public boolean mediate(MessageContext synCtx) {	
attachment mediator ready to mediate 

========================= synapse sample_3111 =========================

boolean handleFault = msgContext.getEnvelope() != null && (msgContext.getEnvelope().getBody().hasFault() || msgContext.isProcessingFault());	boolean faultsAsHttp200 = PassThroughConstants.TRUE.equals( msgContext.getProperty(PassThroughConstants.FAULTS_AS_HTTP_200));	if (handleFault && !faultsAsHttp200) {	httpStatus = HttpStatus.SC_INTERNAL_SERVER_ERROR;	}	Object statusCode = msgContext.getProperty(PassThroughConstants.HTTP_SC);	if (statusCode != null) {	try {	httpStatus = Integer.parseInt( msgContext.getProperty(PassThroughConstants.HTTP_SC).toString());	} catch (NumberFormatException e) {	
unable to set the http status code from the property with value 

========================= synapse sample_2350 =========================

if(synCtx != null) {	MessageStore messageStore = synCtx.getConfiguration().getMessageStore(messageStoreName);	if(messageStore != null) {	if(onStoreSequence != null) {	Mediator sequence = synCtx.getSequence(onStoreSequence);	if(sequence != null) {	sequence.mediate(synCtx);	}	}	if(log.isDebugEnabled()) {	
message store mediator storing the message 

========================= synapse sample_1985 =========================

int maxRetryCount = vfsOutInfo.getMaxRetryCount();	long reconnectionTimeout = vfsOutInfo.getReconnectTimeout();	boolean append = vfsOutInfo.isAppend();	boolean isUseTempFile = vfsOutInfo.isUseTempFile();	String tempTargetFileName, actualTargetFileName = null;	while (wasError) {	try {	retryCount++;	replyFile = fsManager.resolveFile(vfsOutInfo.getOutFileURI());	if (replyFile == null) {	
replyfile is null 

String tempTargetFileName, actualTargetFileName = null;	while (wasError) {	try {	retryCount++;	replyFile = fsManager.resolveFile(vfsOutInfo.getOutFileURI());	if (replyFile == null) {	throw new FileSystemException("replyFile is null");	}	wasError = false;	} catch (FileSystemException e) {	
cannot resolve replyfile 

private void acquireLockForSending(FileObject responseFile, VFSOutTransportInfo vfsOutInfo) throws AxisFault {	int tryNum = 0;	while (!VFSUtils.acquireLock(fsManager, responseFile)) {	if (vfsOutInfo.getMaxRetryCount() == tryNum++) {	handleException("Couldn't send the message to file : " + VFSUtils.maskURLPassword(responseFile.getName().getURI()) + ", unable to acquire the lock even after " + tryNum + " retries");	} else {	
couldn t get the lock for the file retry scheduled after 

========================= synapse sample_895 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	
template deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	OMElement element = artifactConfig.getFirstChildWithName( new QName(SynapseConstants.SYNAPSE_NAMESPACE, "endpoint"));	if (element != null) {	org.apache.synapse.config.xml.endpoints.TemplateFactory templateFactory = new org.apache.synapse.config.xml.endpoints.TemplateFactory();	Template tm = templateFactory.createEndpointTemplate(artifactConfig, properties);	tm.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	
endpoint template named has been built from the file 

try {	OMElement element = artifactConfig.getFirstChildWithName( new QName(SynapseConstants.SYNAPSE_NAMESPACE, "endpoint"));	if (element != null) {	org.apache.synapse.config.xml.endpoints.TemplateFactory templateFactory = new org.apache.synapse.config.xml.endpoints.TemplateFactory();	Template tm = templateFactory.createEndpointTemplate(artifactConfig, properties);	tm.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEndpointTemplate(tm.getName(), tm);	if (log.isDebugEnabled()) {	
template deployment from file completed 

OMElement element = artifactConfig.getFirstChildWithName( new QName(SynapseConstants.SYNAPSE_NAMESPACE, "endpoint"));	if (element != null) {	org.apache.synapse.config.xml.endpoints.TemplateFactory templateFactory = new org.apache.synapse.config.xml.endpoints.TemplateFactory();	Template tm = templateFactory.createEndpointTemplate(artifactConfig, properties);	tm.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addEndpointTemplate(tm.getName(), tm);	if (log.isDebugEnabled()) {	}	
endpoint template named has been deployed from file 

}	return tm.getName();	} else {	element = artifactConfig.getFirstChildWithName( new QName(SynapseConstants.SYNAPSE_NAMESPACE, "sequence"));	if (element != null) {	Mediator mediator = MediatorFactoryFinder.getInstance(). getMediator(artifactConfig, properties);	if (mediator instanceof TemplateMediator) {	TemplateMediator tm = (TemplateMediator) mediator;	tm.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
sequence template named has been built from the file 

element = artifactConfig.getFirstChildWithName( new QName(SynapseConstants.SYNAPSE_NAMESPACE, "sequence"));	if (element != null) {	Mediator mediator = MediatorFactoryFinder.getInstance(). getMediator(artifactConfig, properties);	if (mediator instanceof TemplateMediator) {	TemplateMediator tm = (TemplateMediator) mediator;	tm.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	tm.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	
initialized the template 

if (mediator instanceof TemplateMediator) {	TemplateMediator tm = (TemplateMediator) mediator;	tm.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	tm.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addSequenceTemplate(tm.getName(), tm);	if (log.isDebugEnabled()) {	
template deployment from file completed 

TemplateMediator tm = (TemplateMediator) mediator;	tm.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	tm.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addSequenceTemplate(tm.getName(), tm);	if (log.isDebugEnabled()) {	}	
template named has been deployed from file 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
template update from file has started 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	OMElement element = artifactConfig.getFirstChildWithName( new QName(SynapseConstants.SYNAPSE_NAMESPACE, "endpoint"));	if (element != null) {	org.apache.synapse.config.xml.endpoints.TemplateFactory templateFactory = new org.apache.synapse.config.xml.endpoints.TemplateFactory();	Template tm = templateFactory.createEndpointTemplate(artifactConfig, properties);	tm.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	
endpoint template named has been built from the file 

Template tm = templateFactory.createEndpointTemplate(artifactConfig, properties);	tm.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	Template existingSt = getSynapseConfiguration(). getEndpointTemplate(existingArtifactName);	if (existingArtifactName.equals(tm.getName())) {	getSynapseConfiguration().updateEndpointTemplate(tm.getName(), tm);	} else {	getSynapseConfiguration().addEndpointTemplate(tm.getName(), tm);	getSynapseConfiguration().removeEndpointTemplate(existingSt.getName());	
template has been undeployed 

tm.setFileName(new File(fileName).getName());	if (log.isDebugEnabled()) {	}	Template existingSt = getSynapseConfiguration(). getEndpointTemplate(existingArtifactName);	if (existingArtifactName.equals(tm.getName())) {	getSynapseConfiguration().updateEndpointTemplate(tm.getName(), tm);	} else {	getSynapseConfiguration().addEndpointTemplate(tm.getName(), tm);	getSynapseConfiguration().removeEndpointTemplate(existingSt.getName());	}	
template has been updated from the file 

}	return tm.getName();	} else {	element = artifactConfig.getFirstChildWithName( new QName(SynapseConstants.SYNAPSE_NAMESPACE, "sequence"));	if (element != null) {	Mediator mediator = MediatorFactoryFinder.getInstance(). getMediator(artifactConfig, properties);	if (mediator instanceof TemplateMediator) {	TemplateMediator tm = (TemplateMediator) mediator;	tm.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
sequence template named has been built from the file 

element = artifactConfig.getFirstChildWithName( new QName(SynapseConstants.SYNAPSE_NAMESPACE, "sequence"));	if (element != null) {	Mediator mediator = MediatorFactoryFinder.getInstance(). getMediator(artifactConfig, properties);	if (mediator instanceof TemplateMediator) {	TemplateMediator tm = (TemplateMediator) mediator;	tm.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	tm.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	
initialized the template 

}	tm.init(getSynapseEnvironment());	if (log.isDebugEnabled()) {	}	TemplateMediator existingSt = getSynapseConfiguration(). getSequenceTemplate(existingArtifactName);	if (existingArtifactName.equals(tm.getName())) {	getSynapseConfiguration().updateSequenceTemplate(tm.getName(), tm);	} else {	getSynapseConfiguration().addSequenceTemplate(tm.getName(), tm);	getSynapseConfiguration().removeSequenceTemplate(existingSt.getName());	
template has been undeployed 

if (log.isDebugEnabled()) {	}	TemplateMediator existingSt = getSynapseConfiguration(). getSequenceTemplate(existingArtifactName);	if (existingArtifactName.equals(tm.getName())) {	getSynapseConfiguration().updateSequenceTemplate(tm.getName(), tm);	} else {	getSynapseConfiguration().addSequenceTemplate(tm.getName(), tm);	getSynapseConfiguration().removeSequenceTemplate(existingSt.getName());	}	existingSt.destroy();	
template has been updated from the file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
template undeployment of the template named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	Template st = null;	try {	st = getSynapseConfiguration().getEndpointTemplate(artifactName);	} catch (SynapseException e) {	if (e.getMessage().indexOf("Cannot locate an either local or remote entry for key") != -1) {	if (log.isDebugEnabled()) {	
undeploying template is not of endpoint type undeployer will now check for sequence template for the key 

if (e.getMessage().indexOf("Cannot locate an either local or remote entry for key") != -1) {	if (log.isDebugEnabled()) {	}	} else {	throw e;	}	}	if (st != null) {	getSynapseConfiguration().removeEndpointTemplate(artifactName);	if (log.isDebugEnabled()) {	
destroying the template named 

}	} else {	throw e;	}	}	if (st != null) {	getSynapseConfiguration().removeEndpointTemplate(artifactName);	if (log.isDebugEnabled()) {	}	if (log.isDebugEnabled()) {	
template undeployment of the template named completed 

} else {	throw e;	}	}	if (st != null) {	getSynapseConfiguration().removeEndpointTemplate(artifactName);	if (log.isDebugEnabled()) {	}	if (log.isDebugEnabled()) {	}	
template named has been undeployed 

getSynapseConfiguration().removeEndpointTemplate(artifactName);	if (log.isDebugEnabled()) {	}	if (log.isDebugEnabled()) {	}	} else {	TemplateMediator tm = getSynapseConfiguration().getSequenceTemplate(artifactName);	if (tm != null) {	getSynapseConfiguration().removeSequenceTemplate(artifactName);	if (log.isDebugEnabled()) {	
destroying the template named 

if (log.isDebugEnabled()) {	}	} else {	TemplateMediator tm = getSynapseConfiguration().getSequenceTemplate(artifactName);	if (tm != null) {	getSynapseConfiguration().removeSequenceTemplate(artifactName);	if (log.isDebugEnabled()) {	}	tm.destroy();	if (log.isDebugEnabled()) {	
template undeployment of the template named completed 

}	} else {	TemplateMediator tm = getSynapseConfiguration().getSequenceTemplate(artifactName);	if (tm != null) {	getSynapseConfiguration().removeSequenceTemplate(artifactName);	if (log.isDebugEnabled()) {	}	tm.destroy();	if (log.isDebugEnabled()) {	}	
template named has been undeployed 

} else {	TemplateMediator tm = getSynapseConfiguration().getSequenceTemplate(artifactName);	if (tm != null) {	getSynapseConfiguration().removeSequenceTemplate(artifactName);	if (log.isDebugEnabled()) {	}	tm.destroy();	if (log.isDebugEnabled()) {	}	} else {	
template task has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the template with name started 

}	try {	Template st = getSynapseConfiguration().getEndpointTemplate(artifactName);	if (st != null) {	TemplateSerializer ts = new TemplateSerializer();	OMElement stElem = ts.serializeEndpointTemplate(st, null);	if (st.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.TEMPLATES_DIR + File.separator + st.getFileName();	writeToFile(stElem, fileName);	if (log.isDebugEnabled()) {	
restoring the endpoint template with name completed 

try {	Template st = getSynapseConfiguration().getEndpointTemplate(artifactName);	if (st != null) {	TemplateSerializer ts = new TemplateSerializer();	OMElement stElem = ts.serializeEndpointTemplate(st, null);	if (st.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.TEMPLATES_DIR + File.separator + st.getFileName();	writeToFile(stElem, fileName);	if (log.isDebugEnabled()) {	}	
template named has been restored 

}	} else {	TemplateMediator mt = getSynapseConfiguration().getSequenceTemplate(artifactName);	if (mt != null) {	TemplateMediatorSerializer ts = new TemplateMediatorSerializer();	OMElement stElem = ts.serializeMediator(null, mt);	if (mt.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.TEMPLATES_DIR + File.separator + mt.getFileName();	writeToFile(stElem, fileName);	if (log.isDebugEnabled()) {	
restoring the sequence template with name completed 

} else {	TemplateMediator mt = getSynapseConfiguration().getSequenceTemplate(artifactName);	if (mt != null) {	TemplateMediatorSerializer ts = new TemplateMediatorSerializer();	OMElement stElem = ts.serializeMediator(null, mt);	if (mt.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.TEMPLATES_DIR + File.separator + mt.getFileName();	writeToFile(stElem, fileName);	if (log.isDebugEnabled()) {	}	
template named has been restored 

========================= synapse sample_179 =========================

public void testErrorHandling() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to error handling 

public void testErrorHandling() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	SampleClientResult result = client.requestStandardQuote(addUrl, trpUrl, null, "IBM" ,null);	assertResponseReceived(result);	result = client.requestStandardQuote(addUrl, trpUrl, null, "MSFT" ,null);	assertFalse("Must not get a response", result.responseReceived());	Exception resultEx = result.getException();	assertNotNull("Did not receive expected error" , resultEx);	
got an error as expected 

assertResponseReceived(result);	result = client.requestStandardQuote(addUrl, trpUrl, null, "MSFT" ,null);	assertFalse("Must not get a response", result.responseReceived());	Exception resultEx = result.getException();	assertNotNull("Did not receive expected error" , resultEx);	assertTrue("Did not receive expected error", resultEx instanceof AxisFault);	result = client.requestStandardQuote(addUrl, trpUrl, null, "SUN" ,null);	assertFalse("Must not get a response", result.responseReceived());	Exception resultEx2 = result.getException();	assertNotNull("Did not receive expected error" , resultEx);	
got an error as expected 

========================= synapse sample_2262 =========================

public boolean mediate(MessageContext synCtx) {	int parentsEffectiveTraceState = synCtx.getTracingState();	setEffectiveTraceState(synCtx);	int myEffectiveTraceState = synCtx.getTracingState();	try {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
sequence mediate 

public void init(SynapseEnvironment se) {	if (log.isDebugEnabled()) {	
initializing child mediators of mediator 

public void destroy() {	if (log.isDebugEnabled()) {	
destroying child mediators of mediator 

========================= synapse sample_529 =========================

public boolean mediate(SynapseContext synCtx) {	
mediate 

========================= synapse sample_2798 =========================

public void setName(String endpointName) {	this.endpointName = endpointName;	if (enableMBeanStats) {	if (endpointName == null || "".equals(endpointName.trim())) {	
endpoint name not found skipped jmx statistics collection for this endpoint 

}	}	if (errorHandler != null) {	Mediator errorHandlerMediator = synCtx.getSequence(errorHandler);	if (errorHandlerMediator != null) {	if (traceOrDebugOn) {	traceOrDebug(traceOn, "Setting the onError handler : " + errorHandler + " for the endpoint : " + endpointName);	}	synCtx.pushFaultHandler( new MediatorFaultHandler(errorHandlerMediator));	} else {	
onerror handler sequence for cannot be found 

protected boolean isTimeout(MessageContext synCtx) {	Integer errorCode = (Integer) synCtx.getProperty(SynapseConstants.ERROR_CODE);	if (errorCode != null) {	if (definition.getTimeoutErrorCodes().isEmpty()) {	boolean isTimeout = SynapseConstants.NHTTP_CONNECTION_TIMEOUT == errorCode;	boolean isClosed = SynapseConstants.NHTTP_CONNECTION_CLOSED == errorCode;	if (isTimeout || isClosed) {	if (log.isDebugEnabled()) {	
encountered a default http connection close timeout error 

boolean isTimeout = SynapseConstants.NHTTP_CONNECTION_TIMEOUT == errorCode;	boolean isClosed = SynapseConstants.NHTTP_CONNECTION_CLOSED == errorCode;	if (isTimeout || isClosed) {	if (log.isDebugEnabled()) {	}	return true;	}	} else {	if (definition.getTimeoutErrorCodes().contains(errorCode)) {	if (log.isDebugEnabled()) {	
encountered a mark for suspension error defined error codes are 

}	} else {	if (definition.getTimeoutErrorCodes().contains(errorCode)) {	if (log.isDebugEnabled()) {	}	return true;	}	}	}	if (log.isDebugEnabled()) {	
encountered a non timeout error sending to error code 

protected boolean isRetryDisabled(MessageContext synCtx) {	Integer errorCode = (Integer) synCtx.getProperty(SynapseConstants.ERROR_CODE);	if (errorCode != null && definition != null) {	if (definition.getRetryDisabledErrorCodes().contains(errorCode)) {	if (log.isDebugEnabled()) {	
encountered a retry disabled error defined retry disabled error codes are 

protected boolean isRetryDisabled(MessageContext synCtx) {	Integer errorCode = (Integer) synCtx.getProperty(SynapseConstants.ERROR_CODE);	if (errorCode != null && definition != null) {	if (definition.getRetryDisabledErrorCodes().contains(errorCode)) {	if (log.isDebugEnabled()) {	}	return true;	}	}	if (log.isDebugEnabled()) {	
encountered an error sending to endpoint with error code but not a retry disabled error 

protected boolean isSuspendFault(MessageContext synCtx) {	Integer errorCode = (Integer) synCtx.getProperty(SynapseConstants.ERROR_CODE);	if (errorCode != null) {	if (definition.getSuspendErrorCodes().isEmpty()) {	if (log.isDebugEnabled()) {	
encountered a fatal error 

protected boolean isSuspendFault(MessageContext synCtx) {	Integer errorCode = (Integer) synCtx.getProperty(SynapseConstants.ERROR_CODE);	if (errorCode != null) {	if (definition.getSuspendErrorCodes().isEmpty()) {	if (log.isDebugEnabled()) {	}	return true;	} else {	if (definition.getSuspendErrorCodes().contains(errorCode)) {	if (log.isDebugEnabled()) {	
encountered a suspend error defined suspend codes are 

return true;	} else {	if (definition.getSuspendErrorCodes().contains(errorCode)) {	if (log.isDebugEnabled()) {	}	return true;	}	}	}	if (log.isDebugEnabled()) {	
encountered a non fatal error sending to error code error will be handled but endpoint will not fail 

protected void informFailure(MessageContext synCtx, int errorCode, String errorMsg) {	
endpoint failure error code error message 

========================= synapse sample_250 =========================

public void serialize(SynapseConfiguration synapseConfig) {	if (log.isDebugEnabled()) {	
serializing synapse configuration to the file system 

serializeExecutors(synapseConfig.getPriorityExecutors().values(), synapseConfig, definitions);	serializeMessageStores(synapseConfig.getMessageStores().values(), synapseConfig, definitions);	serializeMessageProcessors(synapseConfig.getMessageProcessors().values(),synapseConfig, definitions);	serializeSynapseXML(definitions);	markConfigurationForSerialization(synapseConfig);	if (rootDirectory.exists()) {	cleanupOldFiles();	}	FileUtils.copyDirectory(currentDirectory, rootDirectory);	} catch (Exception e) {	
error while serializing the configuration to the file system 

private void cleanupOldFiles() {	if (log.isDebugEnabled()) {	
deleting existing files at 

private void cleanupOldFiles() {	if (log.isDebugEnabled()) {	}	Collection<File> xmlFiles = FileUtils.listFiles(rootDirectory, new String[] { "xml" }, true);	for (File xmlFile : xmlFiles) {	boolean deleted = FileUtils.deleteQuietly(xmlFile);	if (log.isDebugEnabled()) {	if (deleted) {	
deleted the xml file at 

private void cleanupOldFiles() {	if (log.isDebugEnabled()) {	}	Collection<File> xmlFiles = FileUtils.listFiles(rootDirectory, new String[] { "xml" }, true);	for (File xmlFile : xmlFiles) {	boolean deleted = FileUtils.deleteQuietly(xmlFile);	if (log.isDebugEnabled()) {	if (deleted) {	} else {	
failed to delete the xml file at 

private boolean isWritable(File file) {	if (file.isDirectory()) {	if (file.getName().startsWith(".") || file.isHidden()) {	return true;	}	File[] children = file.listFiles();	for (File child : children) {	if (!isWritable(child)) {	
file is not writable 

if (file.getName().startsWith(".") || file.isHidden()) {	return true;	}	File[] children = file.listFiles();	for (File child : children) {	if (!isWritable(child)) {	return false;	}	}	if (!file.canWrite()) {	
directory is not writable 

if (!isWritable(child)) {	return false;	}	}	if (!file.canWrite()) {	return false;	}	return true;	} else {	if (!file.canWrite()) {	
file is not writable 

return false;	}	FileOutputStream fos = null;	FileLock lock = null;	boolean writable;	try {	fos = new FileOutputStream(file, true);	FileChannel channel = fos.getChannel();	lock = channel.tryLock();	} catch (IOException e) {	
error while attempting to lock the file 

FileChannel channel = fos.getChannel();	lock = channel.tryLock();	} catch (IOException e) {	writable = false;	} finally {	if (lock != null) {	writable = true;	try {	lock.release();	} catch (IOException e) {	
error while releasing the lock on file 

writable = false;	} finally {	if (lock != null) {	writable = true;	try {	lock.release();	} catch (IOException e) {	writable = false;	}	} else {	
unable to acquire lock on file 

writable = false;	}	} else {	writable = false;	}	try {	if (fos != null) {	fos.close();	}	} catch (IOException e) {	
error while closing the stream on file 

public OMElement serializeSynapseRegistry(Registry registry, SynapseConfiguration synapseConfig, OMElement parent) throws Exception {	OMElement registryElem = RegistrySerializer.serializeRegistry(null, registry);	if (!Boolean.valueOf(synapseConfig.getProperty( MultiXMLConfigurationBuilder.SEPARATE_REGISTRY_DEFINITION)) && parent != null) {	parent.addChild(registryElem);	return registryElem;	}	File registryConf = new File(currentDirectory, MultiXMLConfigurationBuilder.REGISTRY_FILE);	if (log.isDebugEnabled()) {	
serializing synapse registry definition to 

private File createTempDirectoryStructure() throws IOException {	String tempDirName = "__tmp" + new Date().getTime();	File tempDirectory = new File(rootDirectory.getParentFile(), tempDirName);	if (log.isDebugEnabled()) {	
creating temporary files at 

private void deleteTempDirectory() {	try {	if (currentDirectory != rootDirectory && currentDirectory.exists()) {	FileUtils.deleteDirectory(currentDirectory);	}	} catch (IOException e) {	
error while deleting the temporary files at you may delete them manually 

========================= synapse sample_315 =========================

public void destroy() {	try {	Object o = getServletConfig().getServletContext().getAttribute(SYNAPSE_SERVER_MANAGER);	if (o != null && o instanceof ServerManager) {	ServerManager serverManager = (ServerManager) o;	serverManager.stop();	serverManager.shutdown();	getServletContext().removeAttribute(ALREADY_INITED);	}	} catch (Exception e) {	
error stopping the synapse listener manager 

========================= synapse sample_1622 =========================

public void run() {	if (log.isDebugEnabled()) {	
starting a new server worker instance 

String contentType = contentTypeHdr!=null ? TransportUtils.getContentType(contentTypeHdr, msgContext) : null;	if (contentType == null || "".equals(contentType) || HTTPConstants.MEDIA_TYPE_X_WWW_FORM.equals(contentType)) {	contentType = contentTypeHdr != null ? contentTypeHdr : HTTPConstants.MEDIA_TYPE_X_WWW_FORM;	msgContext.setTo(new EndpointReference(request.getRequest().getRequestLine().getUri()));	msgContext.setProperty(Constants.Configuration.CONTENT_TYPE,contentType);	String charSetEncoding = BuilderUtil.getCharSetEncoding(contentType);	msgContext.setProperty(Constants.Configuration.CHARACTER_SET_ENCODING, charSetEncoding);	try {	RESTUtil.dispatchAndVerify(msgContext);	} catch (AxisFault e1) {	
error while building message for rest url request 

String defaultSvcName = PassThroughConfiguration.getInstance().getStringProperty( "nhttp.default.service", "__SynapseService");	axisService =  msgContext.getConfigurationContext().getAxisConfiguration() .getService(defaultSvcName);	msgContext.setAxisService(axisService);	}	} catch (AxisFault e) {	handleException("Error processing " + request.getMethod() + " request for : " + request.getUri(), e);	}	try {	soapEnvelope = TransportUtils.createSOAPMessage(msgContext, null, contentType);	} catch (Exception e) {	
error while building message for rest url request 

boolean nioAck = msgContext.isPropertyTrue("NIO-ACK-Requested", false);	if (respWillFollow || ack || forced || nioAck) {	NHttpServerConnection conn = request.getConnection();	SourceResponse sourceResponse;	if (!nioAck) {	msgContext.removeProperty(MessageContext.TRANSPORT_HEADERS);	sourceResponse = SourceResponseFactory.create(msgContext, request, sourceConfiguration);	sourceResponse.setStatus(HttpStatus.SC_ACCEPTED);	} else {	if (log.isDebugEnabled()) {	
sending ack response with status for messageid 

========================= synapse sample_968 =========================

public void shutDownConnection(NHttpServerConnection conn) {	if (log.isDebugEnabled()) {	
shutting down connection forcefully 

public void closeConnection(NHttpServerConnection conn) {	if (log.isDebugEnabled()) {	
closing connection forcefully 

========================= synapse sample_2370 =========================

public void testCache() {	String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test simple cache implemented on synapse for the actual service 

========================= synapse sample_2235 =========================

String serviceUrl = cacheValue.serviceUrl;	OCSPReq request = cacheValue.request;	OCSPResp response= ocspVerifier.getOCSPResponse(serviceUrl, request);	if (OCSPRespStatus.SUCCESSFUL != response.getStatus()) throw new CertificateVerificationException("OCSP response status not SUCCESSFUL");	BasicOCSPResp basicResponse = (BasicOCSPResp) response.getResponseObject();	SingleResp[] responses = (basicResponse == null) ? null : basicResponse.getResponses();	if (responses == null) throw new CertificateVerificationException("Cant get OCSP response");	SingleResp resp = responses[0];	this.setCacheValue(cacheValue.serialNumber, resp, request, serviceUrl);	} catch (Exception e){	
cant replace old cachevalue with new cachevalue so remove 

public synchronized void setCacheValue(BigInteger serialNumber, SingleResp singleResp, OCSPReq request, String serviceUrl) {	OCSPCacheValue cacheValue = new OCSPCacheValue(serialNumber, singleResp, request, serviceUrl);	if (log.isDebugEnabled()) {	
before set hashmap size 

public synchronized void setCacheValue(BigInteger serialNumber, SingleResp singleResp, OCSPReq request, String serviceUrl) {	OCSPCacheValue cacheValue = new OCSPCacheValue(serialNumber, singleResp, request, serviceUrl);	if (log.isDebugEnabled()) {	}	hashMap.put(serialNumber, cacheValue);	if (log.isDebugEnabled()) {	
after set hashmap size 

public synchronized void removeCacheValue(BigInteger serialNumber) {	if (log.isDebugEnabled()) {	
before remove hashmap size 

public synchronized void removeCacheValue(BigInteger serialNumber) {	if (log.isDebugEnabled()) {	}	hashMap.remove(serialNumber);	if (log.isDebugEnabled()) {	
after remove hashmap size 

========================= synapse sample_987 =========================

public boolean mediate(MessageContext synCtx) {	
rest mediator mediate 

========================= synapse sample_3074 =========================

trace.info("Please add <syn:parameter name=\"enableURISafeMode\">true" + "</syn:parameter> to proxy service.");	}	handleException("Error reading from wsdl URI", e);	}	}	if (enablePublishWSDLSafeMode) {	if (trace()) {	trace.info("WSDL was unable to load for: " + publishWSDL);	trace.info("enableURISafeMode: true");	}	
unable to load the wsdl for 

========================= synapse sample_207 =========================

public boolean process(SynapseEnvironment se, SynapseMessage smc) {	
process 

public boolean process(SynapseEnvironment se, SynapseMessage smc) {	if (processors == null) {	
process called on empty processor list 

public void setList(List p) {	
setting list 

========================= synapse sample_1360 =========================

public static void convertSOAPFaultToPOX(MessageContext msgCtx) {	SOAPBody body = msgCtx.getEnvelope().getBody();	SOAPFault fault = body.getFault();	if (fault != null) {	OMFactory fac = msgCtx.getEnvelope().getOMFactory();	OMElement faultPayload = fac.createOMElement(new QName("Exception"));	if (fault.getDetail() != null && !fault.getDetail().getText().equals("")) {	String faultDetail = fault.getDetail().getText();	if (log.isDebugEnabled()) {	
setting the fault detail as athe pox fault 

OMFactory fac = msgCtx.getEnvelope().getOMFactory();	OMElement faultPayload = fac.createOMElement(new QName("Exception"));	if (fault.getDetail() != null && !fault.getDetail().getText().equals("")) {	String faultDetail = fault.getDetail().getText();	if (log.isDebugEnabled()) {	}	faultPayload.setText(faultDetail);	} else if (fault.getReason() != null && !fault.getReason().getText().equals("")) {	String faultReasonValue = fault.getReason().getText();	if (log.isDebugEnabled()) {	
setting the fault reason as athe pox fault 

String faultDetail = fault.getDetail().getText();	if (log.isDebugEnabled()) {	}	faultPayload.setText(faultDetail);	} else if (fault.getReason() != null && !fault.getReason().getText().equals("")) {	String faultReasonValue = fault.getReason().getText();	if (log.isDebugEnabled()) {	}	faultPayload.setText(faultReasonValue);	} else if (log.isDebugEnabled()) {	
couldn t find the fault detail or reason to compose pox fault 

========================= synapse sample_1730 =========================

}	if (snmpVersion > SnmpConstants.version1) {	if (obj instanceof Long) {	return new Counter64(((Long) obj).longValue());	} else if (obj instanceof Date) {	return new Counter64(((Date) obj).getTime());	}	}	return new OctetString(obj.toString());	} catch (Exception e) {	
unexpected error while retrieving the value of oid 

========================= synapse sample_712 =========================

public boolean mediate(MessageContext synCtx) {	
switch mediator mediate 

public boolean mediate(MessageContext synCtx) {	boolean shouldTrace = shouldTrace(synCtx.getTracingState());	if (shouldTrace) {	trace.trace("Start : Switch mediator");	}	String sourceText = Axis2MessageContext.getStringValue(source, synCtx);	
applying switch case regex patterns against evaluated source value 

if (shouldTrace) {	trace.trace("Executing case for : " + swCase.getRegex());	}	return swCase.mediate(synCtx);	}	}	if (shouldTrace) {	trace.trace("End Case mediator lis");	}	if (defaultCase != null) {	
executing default case 

========================= synapse sample_3062 =========================

public void testCallOutSecurity() {	
running test callout mediator with security 

========================= synapse sample_2223 =========================

public void handleFault(MessageContext synCtx) {	boolean traceOn = synCtx.getTracingState() == SynapseConstants.TRACING_ON;	boolean traceOrDebugOn = traceOn || log.isDebugEnabled();	if (traceOrDebugOn) {	traceOrDebugWarn(traceOn, "FaultHandler executing impl: " + this.getClass().getName());	}	try {	
faulthandler executing impl 

synCtx.setProperty(SynapseConstants.ERROR_MESSAGE, e.getMessage().split("\n")[0]);	synCtx.setProperty(SynapseConstants.ERROR_DETAIL, getStackTrace(e));	synCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, e);	}	if (traceOrDebugOn) {	traceOrDebugWarn(traceOn, "ERROR_CODE : " + synCtx.getProperty(SynapseConstants.ERROR_CODE));	traceOrDebugWarn(traceOn, "ERROR_MESSAGE : " + synCtx.getProperty(SynapseConstants.ERROR_MESSAGE));	traceOrDebugWarn(traceOn, "ERROR_DETAIL : " + synCtx.getProperty(SynapseConstants.ERROR_DETAIL));	traceOrDebugWarn(traceOn, "ERROR_EXCEPTION : " + synCtx.getProperty(SynapseConstants.ERROR_EXCEPTION));	}	
error code error message 

========================= synapse sample_568 =========================

public Map<String, Map<String, InOutStatisticsView>> determineView( List<StatisticsRecord> statisticsRecords, ComponentType type) {	final Map<String, Map<String, InOutStatisticsView>> statisticsMap = new HashMap<String, Map<String, InOutStatisticsView>>();	if (statisticsRecords == null) {	if (log.isDebugEnabled()) {	
statistics records cannot be found 

public Map<String, InOutStatisticsView> determineView(String id, List<StatisticsRecord> statisticsRecords, ComponentType type) {	if (id == null || "".equals(id)) {	handleException("Resource Id cannot be null");	}	Map<String, InOutStatisticsView> statisticsMap = new HashMap<String, InOutStatisticsView>();	if (statisticsRecords == null) {	if (log.isDebugEnabled()) {	
statistics records cannot be found 

========================= synapse sample_641 =========================

}	MessageContext originalInMsgCtx = ((Axis2MessageContext) synapseOutMessageContext).getAxis2MessageContext();	String session = (String) synapseOutMessageContext.getProperty("LB_COOKIE_HEADER");	if (session != null) {	Map headers = (Map) originalInMsgCtx.getProperty(MessageContext.TRANSPORT_HEADERS);	headers.put("Cookie", session);	}	String preserveAddressingProperty = (String) synapseOutMessageContext.getProperty( SynapseConstants.PRESERVE_WS_ADDRESSING);	MessageContext axisOutMsgCtx = cloneForSend(originalInMsgCtx, preserveAddressingProperty);	if (log.isDebugEnabled()) {	
message original request message id new cloned request message id 

========================= synapse sample_211 =========================

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	boolean failSafeProxyEnabled = SynapseConfigUtils.isFailSafeEnabled( SynapseConstants.FAIL_SAFE_MODE_PROXY_SERVICES);	if (log.isDebugEnabled()) {	
proxyservice deployment from file started 

public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {	boolean failSafeProxyEnabled = SynapseConfigUtils.isFailSafeEnabled( SynapseConstants.FAIL_SAFE_MODE_PROXY_SERVICES);	if (log.isDebugEnabled()) {	}	try {	ProxyService proxy = ProxyServiceFactory.createProxy(artifactConfig, properties);	if (proxy != null) {	proxy.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
proxyservice named has been built from the file 

if (log.isDebugEnabled()) {	}	try {	ProxyService proxy = ProxyServiceFactory.createProxy(artifactConfig, properties);	if (proxy != null) {	proxy.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	initializeProxy(proxy);	if (log.isDebugEnabled()) {	
initialized the proxyservice 

ProxyService proxy = ProxyServiceFactory.createProxy(artifactConfig, properties);	if (proxy != null) {	proxy.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	initializeProxy(proxy);	if (log.isDebugEnabled()) {	}	proxy.buildAxisService(getSynapseConfiguration(), getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	
started the proxyservice 

if (log.isDebugEnabled()) {	}	initializeProxy(proxy);	if (log.isDebugEnabled()) {	}	proxy.buildAxisService(getSynapseConfiguration(), getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addProxyService(proxy.getName(), proxy);	if (log.isDebugEnabled()) {	
proxyservice deployment from file completed 

}	initializeProxy(proxy);	if (log.isDebugEnabled()) {	}	proxy.buildAxisService(getSynapseConfiguration(), getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addProxyService(proxy.getName(), proxy);	if (log.isDebugEnabled()) {	}	
proxyservice named has been deployed from file 

}	getSynapseConfiguration().addProxyService(proxy.getName(), proxy);	if (log.isDebugEnabled()) {	}	return proxy.getName();	} else {	handleSynapseArtifactDeploymentError("ProxyService Deployment Failed. The " + "artifact described in the file " + fileName + " is not a ProxyService");	}	} catch (Exception e) {	if (failSafeProxyEnabled) {	
proxy service hot deployment from file failed continue in fail safe mode 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	
proxyservice update from file started 

public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {	if (log.isDebugEnabled()) {	}	try {	ProxyService proxy = ProxyServiceFactory.createProxy(artifactConfig, properties);	if (proxy != null) {	proxy.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	
proxyservice named has been built from the file 

if (log.isDebugEnabled()) {	}	try {	ProxyService proxy = ProxyServiceFactory.createProxy(artifactConfig, properties);	if (proxy != null) {	proxy.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	initializeProxy(proxy);	if (log.isDebugEnabled()) {	
initialized the proxyservice 

proxy.setFileName((new File(fileName)).getName());	if (log.isDebugEnabled()) {	}	initializeProxy(proxy);	if (log.isDebugEnabled()) {	}	ProxyService currentProxy = getSynapseConfiguration().getProxyService(existingArtifactName);	currentProxy.stop(getSynapseConfiguration());	getSynapseConfiguration().removeProxyService(existingArtifactName);	if (!existingArtifactName.equals(proxy.getName())) {	
proxyservice named has been undeployed 

initializeProxy(proxy);	if (log.isDebugEnabled()) {	}	ProxyService currentProxy = getSynapseConfiguration().getProxyService(existingArtifactName);	currentProxy.stop(getSynapseConfiguration());	getSynapseConfiguration().removeProxyService(existingArtifactName);	if (!existingArtifactName.equals(proxy.getName())) {	}	proxy.buildAxisService(getSynapseConfiguration(), getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	
started the proxyservice 

ProxyService currentProxy = getSynapseConfiguration().getProxyService(existingArtifactName);	currentProxy.stop(getSynapseConfiguration());	getSynapseConfiguration().removeProxyService(existingArtifactName);	if (!existingArtifactName.equals(proxy.getName())) {	}	proxy.buildAxisService(getSynapseConfiguration(), getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addProxyService(proxy.getName(), proxy);	if (log.isDebugEnabled()) {	
proxyservice update deployment from file completed 

currentProxy.stop(getSynapseConfiguration());	getSynapseConfiguration().removeProxyService(existingArtifactName);	if (!existingArtifactName.equals(proxy.getName())) {	}	proxy.buildAxisService(getSynapseConfiguration(), getSynapseConfiguration().getAxisConfiguration());	if (log.isDebugEnabled()) {	}	getSynapseConfiguration().addProxyService(proxy.getName(), proxy);	if (log.isDebugEnabled()) {	}	
proxyservice named has been updated deployed from file 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
proxyservice undeployment of the proxy named started 

public void undeploySynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	ProxyService proxy = getSynapseConfiguration().getProxyService(artifactName);	if (proxy != null) {	if (log.isDebugEnabled()) {	
stopping the proxyservice named 

if (log.isDebugEnabled()) {	}	try {	ProxyService proxy = getSynapseConfiguration().getProxyService(artifactName);	if (proxy != null) {	if (log.isDebugEnabled()) {	}	proxy.stop(getSynapseConfiguration());	getSynapseConfiguration().removeProxyService(artifactName);	if (log.isDebugEnabled()) {	
proxyservice undeployment of the proxy named completed 

}	try {	ProxyService proxy = getSynapseConfiguration().getProxyService(artifactName);	if (proxy != null) {	if (log.isDebugEnabled()) {	}	proxy.stop(getSynapseConfiguration());	getSynapseConfiguration().removeProxyService(artifactName);	if (log.isDebugEnabled()) {	}	
proxyservice named has been undeployed 

try {	ProxyService proxy = getSynapseConfiguration().getProxyService(artifactName);	if (proxy != null) {	if (log.isDebugEnabled()) {	}	proxy.stop(getSynapseConfiguration());	getSynapseConfiguration().removeProxyService(artifactName);	if (log.isDebugEnabled()) {	}	} else if (log.isDebugEnabled()) {	
proxy service has already been undeployed 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	
restoring the proxyservice with name started 

public void restoreSynapseArtifact(String artifactName) {	if (log.isDebugEnabled()) {	}	try {	ProxyService proxy = getSynapseConfiguration().getProxyService(artifactName);	OMElement proxyElem = ProxyServiceSerializer.serializeProxy(null, proxy);	if (proxy.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.PROXY_SERVICES_DIR + File.separator + proxy.getFileName();	writeToFile(proxyElem, fileName);	if (log.isDebugEnabled()) {	
restoring the proxyservice with name completed 

if (log.isDebugEnabled()) {	}	try {	ProxyService proxy = getSynapseConfiguration().getProxyService(artifactName);	OMElement proxyElem = ProxyServiceSerializer.serializeProxy(null, proxy);	if (proxy.getFileName() != null) {	String fileName = getServerConfigurationInformation().getSynapseXMLLocation() + File.separator + MultiXMLConfigurationBuilder.PROXY_SERVICES_DIR + File.separator + proxy.getFileName();	writeToFile(proxyElem, fileName);	if (log.isDebugEnabled()) {	}	
proxyservice named has been restored 

========================= synapse sample_180 =========================

public void testDualQuote() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test dual channel invocation through synapse 

========================= synapse sample_2274 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start out mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	boolean result = true;	if (test(synCtx)) {	
current message is outgoing executing child mediators 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	boolean result = true;	if (test(synCtx)) {	result = super.mediate(synCtx);	} else {	
current message is a request skipping child mediators 

SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	}	}	boolean result = true;	if (test(synCtx)) {	result = super.mediate(synCtx);	} else {	}	
end out mediator 

========================= synapse sample_495 =========================

public static NHttpClientConnection getConnection(String host, int port) {	String key = host + ":" + Integer.toString(port);	List<NHttpClientConnection> connections = connMap.get(key);	if (connections == null || connections.isEmpty()) {	if (log.isDebugEnabled()) {	
no connections available for reuse 

if (log.isDebugEnabled()) {	}	return null;	} else {	NHttpClientConnection conn;	synchronized (connections) {	while (!connections.isEmpty()) {	conn = connections.remove(0);	if (conn.isOpen() && !conn.isStale()) {	if (log.isDebugEnabled()) {	
a connection to host on port is available in the pool and will be reused 

synchronized (connections) {	while (!connections.isEmpty()) {	conn = connections.remove(0);	if (conn.isOpen() && !conn.isStale()) {	if (log.isDebugEnabled()) {	}	conn.requestInput();	return conn;	} else {	if (log.isDebugEnabled()) {	
closing stale connection to 

connections = connMap.get(key);	if (connections == null) {	connections = Collections.synchronizedList(new LinkedList<NHttpClientConnection>());	connMap.put(key, connections);	}	}	}	cleanConnectionReferences(conn);	connections.add(conn);	if (log.isDebugEnabled()) {	
released a connection to host on port to the connection pool of current size 

========================= synapse sample_1008 =========================

sendingFaultTable.clear();	responseCodeTable.clear();	lastResetTime = System.currentTimeMillis();	if (endpoint.getChildren() != null) {	for (Endpoint e : endpoint.getChildren()) {	if (e.getMetricsMBean() != null) {	e.getMetricsMBean().resetStatistics();	}	}	}	
endpoint statistics reset for and or its children 

========================= synapse sample_246 =========================

String optionType = option.getOptionType();	return !("repo".equalsIgnoreCase(optionType) || "conf" .equalsIgnoreCase(optionType));	}	});	if ((invalidOptionsList.size() > 0) || (args.length > 4)) {	printUsage();	}	Map optionsMap = optionsParser.getAllOptions();	CommandLineOption repoOption = (CommandLineOption) optionsMap .get("repo");	CommandLineOption confOption = (CommandLineOption) optionsMap .get("conf");	
simpleaxisserver starting 

configCtx = ConfigurationContextFactory .createConfigurationContextFromFileSystem(repoLocation, confLocation);	configurePort(configCtx);	listenerManager = new ListenerManager();	listenerManager.init(configCtx);	listenerManager.start();	ClusteringAgent clusteringAgent = configCtx.getAxisConfiguration().getClusteringAgent();	if(clusteringAgent != null) {	clusteringAgent.setConfigurationContext(configCtx);	clusteringAgent.init();	}	
simpleaxisserver started 

configurePort(configCtx);	listenerManager = new ListenerManager();	listenerManager.init(configCtx);	listenerManager.start();	ClusteringAgent clusteringAgent = configCtx.getAxisConfiguration().getClusteringAgent();	if(clusteringAgent != null) {	clusteringAgent.setConfigurationContext(configCtx);	clusteringAgent.init();	}	} catch (Throwable t) {	
simpleaxisserver shutting down error starting simpleaxisserver 

private void configurePort(ConfigurationContext configCtx) {	TransportInDescription trsIn = configCtx.getAxisConfiguration().getTransportsIn().get("http");	if (trsIn != null) {	String port = System.getProperty("http_port");	if (port != null) {	try {	new Integer(port);	trsIn.getParameter("port").setValue(port);	} catch (NumberFormatException e) {	
given port is not a valid integer using for port 

}	}	TransportInDescription httpsTrsIn = configCtx.getAxisConfiguration(). getTransportsIn().get("https");	if (httpsTrsIn != null) {	String port = System.getProperty("https_port");	if (port != null) {	try {	new Integer(port);	httpsTrsIn.getParameter("port").setValue(port);	} catch (NumberFormatException e) {	
given port is not a valid integer using for port 

========================= synapse sample_1264 =========================

proxyPort = Integer.parseInt((String) proxyPortParam.getValue());	} else if (System.getProperty("http.proxyPort") != null) {	proxyPort = Integer.parseInt(System.getProperty("http.proxyPort"));	}	Parameter bypassList = transportOut.getParameter("http.nonProxyHosts");	if (bypassList != null) {	proxyBypassList = ((String) bypassList.getValue()).split("\\|");	} else if (System.getProperty("http.nonProxyHosts") != null) {	proxyBypassList = (System.getProperty("http.nonProxyHosts")).split("\\|");	}	
http sender using proxy bypassing 

String[] warnOnHttp500 = ((String) param.getValue()).split("\\|");	cfgCtx.setNonReplicableProperty("warnOnHTTP500", warnOnHttp500);	}	preserveUserAgentHeader = NHttpConfiguration.getInstance().isPreserveUserAgentHeader();	preserveServerHeader = NHttpConfiguration.getInstance().isPreserveServerHeader();	try {	String prefix = (sslContext == null ? "http" : "https") + "-Sender I/O dispatcher";	ioReactor = new DefaultConnectingIOReactor( getReactorConfig(), new NativeThreadFactory(new ThreadGroup(prefix + " thread group"), prefix));	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	
system may be unstable ioreactor encountered a checked exception 

preserveUserAgentHeader = NHttpConfiguration.getInstance().isPreserveUserAgentHeader();	preserveServerHeader = NHttpConfiguration.getInstance().isPreserveServerHeader();	try {	String prefix = (sslContext == null ? "http" : "https") + "-Sender I/O dispatcher";	ioReactor = new DefaultConnectingIOReactor( getReactorConfig(), new NativeThreadFactory(new ThreadGroup(prefix + " thread group"), prefix));	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	return true;	}	public boolean handle(RuntimeException runtimeException) {	
system may be unstable ioreactor encountered a runtime exception 

ioReactor = new DefaultConnectingIOReactor( getReactorConfig(), new NativeThreadFactory(new ThreadGroup(prefix + " thread group"), prefix));	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	return true;	}	public boolean handle(RuntimeException runtimeException) {	return true;	}	});	} catch (IOException e) {	
error starting the ioreactor 

} catch (IOException e) {	}	metrics = new NhttpMetricsCollector(false, transportOut.getName());	handler = new ClientHandler(cfgCtx, metrics);	final IOEventDispatch ioEventDispatch = getEventDispatch( handler, sslContext, sslSetupHandler, getConnectionConfig(), transportOut);	Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	
reactor interrupted 

}	metrics = new NhttpMetricsCollector(false, transportOut.getName());	handler = new ClientHandler(cfgCtx, metrics);	final IOEventDispatch ioEventDispatch = getEventDispatch( handler, sslContext, sslSetupHandler, getConnectionConfig(), transportOut);	Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	} catch (IOException e) {	
encountered an i o error 

if (ccd == null) {	ccd = new ClientConnectionDebug(scd);	scd.setClientConnectionDebug(ccd);	}	ccd.recordRequestStartTime(conn, axis2Req);	msgContext.setProperty(ClientHandler.CLIENT_CONNECTION_DEBUG, ccd);	}	if (conn == null) {	ioReactor.connect(new InetSocketAddress(host, port), null, axis2Req, sessionRequestCallback);	if (log.isDebugEnabled()) {	
a new connection established to 

msgContext.setProperty(ClientHandler.CLIENT_CONNECTION_DEBUG, ccd);	}	if (conn == null) {	ioReactor.connect(new InetSocketAddress(host, port), null, axis2Req, sessionRequestCallback);	if (log.isDebugEnabled()) {	}	} else {	try {	handler.submitRequest(conn, axis2Req);	if (log.isDebugEnabled()) {	
an existing connection reused to 

if (log.isDebugEnabled()) {	}	} else {	try {	handler.submitRequest(conn, axis2Req);	if (log.isDebugEnabled()) {	}	} catch (ConnectionClosedException e) {	ioReactor.connect(new InetSocketAddress(host, port), null, axis2Req, sessionRequestCallback);	if (log.isDebugEnabled()) {	
a new connection established to 

}	} else {	messageFormatter.writeTo(msgContext, format, out, false);	}	}	out.close();	if (lstMetrics != null) {	lstMetrics.incrementMessagesSent();	}	} catch (ProtocolException e) {	
synapse may be trying to send an exact response more than once 

} catch (ProtocolException e) {	} catch (HttpException e) {	if (lstMetrics != null) {	lstMetrics.incrementFaultsSending();	}	handleException("Unexpected HTTP protocol error sending response to : " + worker.getRemoteAddress(), e);	} catch (ConnectionClosedException e) {	if (lstMetrics != null) {	lstMetrics.incrementFaultsSending();	}	
connection closed by client 

boolean handleFault = msgContext.getEnvelope().getBody().hasFault() || msgContext.isProcessingFault();	boolean faultsAsHttp200 = NhttpConstants.TRUE.equals( msgContext.getProperty(NhttpConstants.FAULTS_AS_HTTP_200));	if (handleFault && !faultsAsHttp200) {	httpStatus = HttpStatus.SC_INTERNAL_SERVER_ERROR;	}	Object statusCode = msgContext.getProperty(NhttpConstants.HTTP_SC);	if (statusCode != null) {	try {	httpStatus = Integer.parseInt( msgContext.getProperty(NhttpConstants.HTTP_SC).toString());	} catch (NumberFormatException e) {	
unable to set the http status code from the property with value 

public void stop() {	if (state == BaseConstants.STOPPED) return;	try {	ioReactor.shutdown();	handler.stop();	state = BaseConstants.STOPPED;	} catch (IOException e) {	
error shutting down ioreactor 

private SessionRequestCallback getSessionRequestCallback() {	return new SessionRequestCallback() {	public void completed(SessionRequest request) {	if (log.isDebugEnabled() && request.getSession() != null && request.getSession().getLocalAddress() != null) {	
connected to remote address from local address 

public void maintenenceShutdown(long millis) throws AxisFault {	if (state != BaseConstants.STARTED) return;	try {	long start = System.currentTimeMillis();	ioReactor.shutdown(millis);	state = BaseConstants.STOPPED;	
sender shutdown in s 

========================= synapse sample_2448 =========================

String targetEp = (String) messageContext.getProperty( ForwardingProcessorConstants.TARGET_ENDPOINT);	if (targetEp != null) {	Endpoint ep = messageContext.getEndpoint(targetEp);	if ((ep != null) && (((AbstractEndpoint) ep).isLeafEndpoint())) {	try {	sender.send(ep, messageContext);	if (delete) {	messageStore.poll();	}	} catch (Exception e) {	
error forwarding message 

========================= synapse sample_2018 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start log mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

break;	case CATEGORY_DEBUG : synLog.auditDebug(getLogMessage(synCtx));	break;	case CATEGORY_WARN : synLog.auditWarn(getLogMessage(synCtx));	break;	case CATEGORY_ERROR : synLog.auditError(getLogMessage(synCtx));	break;	case CATEGORY_FATAL : synLog.auditFatal(getLogMessage(synCtx));	break;	}	
end log mediator 

========================= synapse sample_544 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	
start validate mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceTraceEnabled()) {	
message 

try {	Validator validator = cachedSchema.newValidator();	validator.setErrorHandler(errorHandler);	validator.validate(validateSrc);	if (errorHandler.isValidationError()) {	if (synLog.isTraceOrDebugEnabled()) {	String msg = "Validation of element returned by XPath : " + source + " failed against the given schema(s) " + schemaKeys + "with error : " + errorHandler.getSaxParseException().getMessage() + " Executing 'on-fail' sequence";	synLog.traceOrDebug(msg);	synCtx.getServiceLog().warn(msg);	if (synLog.isTraceTraceEnabled()) {	
failed message envelope 

synCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, errorHandler.getSaxParseException());	synCtx.setProperty(SynapseConstants.ERROR_DETAIL, FaultHandler.getStackTrace(errorHandler.getSaxParseException()));	return super.mediate(synCtx);	}	} catch (SAXException e) {	handleException("Error validating " + source + " element", e, synCtx);	} catch (IOException e) {	handleException("Error validating " + source + " element", e, synCtx);	}	if (synLog.isTraceOrDebugEnabled()) {	
validation of element returned by the xpath expression succeeded against the given schemas and the current message 

synCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, errorHandler.getSaxParseException());	synCtx.setProperty(SynapseConstants.ERROR_DETAIL, FaultHandler.getStackTrace(errorHandler.getSaxParseException()));	return super.mediate(synCtx);	}	} catch (SAXException e) {	handleException("Error validating " + source + " element", e, synCtx);	} catch (IOException e) {	handleException("Error validating " + source + " element", e, synCtx);	}	if (synLog.isTraceOrDebugEnabled()) {	
end validate mediator 

========================= synapse sample_1970 =========================

public void testDbLookup() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test introduction to dblookup mediator 

public void testDbLookup() {	String addUrl = "http: String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	result = client.requestStandardQuote(addUrl, trpUrl, null, "IBM" ,null);	assertTrue("Client did not get run successfully ", result.responseReceived());	
running test introduction to the dblookup mediator 

========================= synapse sample_817 =========================

public void setSOAPEnvelope(Message message, int counter, String sessionID, MessageContext msgCtx) throws AxisFault {	if (log.isDebugEnabled()) {	
creating soap envelope for fix message 

public Message createFIXMessage(MessageContext msgCtx) throws IOException {	if (log.isDebugEnabled()) {	
extracting fix message from the message context message id 

========================= synapse sample_4271 =========================

public void setSOAPEnvelope(Message message, int counter, String sessionID, MessageContext msgCtx) throws AxisFault {	if (log.isDebugEnabled()) {	
creating soap envelope for fix message 

private void convertFIXBodyToXML(FieldMap message, OMElement body, SOAPFactory soapFactory, MessageContext msgCtx) throws AxisFault{	if (log.isDebugEnabled()) {	
generating fix message body message id 

public Message createFIXMessage(MessageContext msgCtx) throws IOException {	if (log.isDebugEnabled()) {	
extracting fix message from the message context message id 

========================= synapse sample_1073 =========================

}	if (!configurable.isStatisticsEnable()) {	return;	}	StatisticsRecord record = null;	if(synCtx.getProperty(SynapseConstants.STATISTICS_STACK) instanceof StatisticsRecord){	record =  (StatisticsRecord) synCtx.getProperty(SynapseConstants.STATISTICS_STACK);	}	if (record == null) {	if (log.isDebugEnabled()) {	
setting a statistics stack on the message context 

public static void reportForAllOnResponseReceived(MessageContext synCtx) {	synCtx.setProperty(SynapseConstants.SENDING_REQUEST, false);	StatisticsRecord statisticsRecord = null;	if (synCtx.getProperty(SynapseConstants.STATISTICS_STACK) instanceof StatisticsRecord) {	statisticsRecord = (StatisticsRecord) synCtx.getProperty( SynapseConstants.STATISTICS_STACK);	}	if (statisticsRecord != null) {	if (log.isDebugEnabled()) {	
reporting a statistics on a response is received 

private static void endReportForAll(MessageContext synCtx) {	StatisticsRecord record = null;	if(synCtx.getProperty(SynapseConstants.STATISTICS_STACK) instanceof StatisticsRecord){	record =  (StatisticsRecord) synCtx.getProperty(SynapseConstants.STATISTICS_STACK);	}	if (record == null) {	return;	}	if (record.isEndReported()) {	if (log.isDebugEnabled()) {	
the statistics record has been already reported 

if (isFault(synCtx)) {	statisticsLog.setFault(true);	statisticsLog.setErrorLog(ErrorLogFactory.createErrorLog(synCtx));	}	statisticsLog.setEndAnyLog(true);	record.collect(statisticsLog);	record.setEndReported(true);	StatisticsCollector collector = synCtx.getEnvironment().getStatisticsCollector();	if (collector == null) {	if (log.isDebugEnabled()) {	
setting statistics collector in the synapse environment 

private static boolean isValid(Identifiable identifiable) {	if (identifiable == null) {	if (log.isDebugEnabled()) {	
invalid aspects configuration it is null 

private static boolean isValid(Identifiable identifiable) {	if (identifiable == null) {	if (log.isDebugEnabled()) {	}	return false;	}	String auditID = identifiable.getId();	if (auditID == null || "".equals(auditID)) {	if (log.isDebugEnabled()) {	
invalid aspects configuration audit name is null 

========================= synapse sample_2063 =========================

public void destroy() {	if (log.isDebugEnabled()) {	
un registering the synapse threading view for the thread group 

private void initMBean() {	if (log.isDebugEnabled()) {	
starting a new synapse threading view for the thread group 

private void periodicDump() {	if (periodicLogs && log.isDebugEnabled()) {	StringBuffer buffer = new StringBuffer();	buffer.append("Thread state summary for ").append(threadNamePrefix). append(" threads - Blocked: ").append(avgBlockedWorkerPercentage). append("%, Unblocked: ").append(avgUnblockedWorkerPercentage). append("%");	log.debug(buffer.toString());	}	if (alertMargin > 0) {	double blocked = getAverageBlockedThreads(1);	if (blocked > alertMargin) {	
system alert of the threads were in blocked state during last minute 

========================= synapse sample_728 =========================

public static DataSourceInformation createDataSourceInformation(String dsName, Properties properties) {	if (dsName == null || "".equals(dsName)) {	if (log.isDebugEnabled()) {	
datasource name is either empty or null ignoring 

========================= synapse sample_2126 =========================

public Message receive(long timeout){	Message m;	session.messageFlow(destination,Session.MESSAGE_FLOW_UNIT_MESSAGE, 1);	session.messageFlow(destination,Session.MESSAGE_FLOW_UNIT_BYTE, 0xFFFFFFFF);	try{	m = queue.poll(timeout, TimeUnit.MILLISECONDS);	}catch(Exception e){	throw new AMQPSynapseException("unable to receive message",e);	}	if (m == null) {	
message didn t arrive in time checking if one is inflight 

========================= synapse sample_3737 =========================

private void registerExtensions() {	
registering mediator extensions found in the classpath java class path 

while (it.hasNext()) {	MediatorSerializer ms = (MediatorSerializer) it.next();	String name = ms.getMediatorClassName();	try {	serializerMap.put(name, ms.getClass().newInstance());	} catch (InstantiationException e) {	handleException("Error instantiating mediator serializer : " + ms);	} catch (IllegalAccessException e) {	handleException("Error instantiating mediator serializer : " + ms);	}	
added mediatorserializer to handle 

========================= synapse sample_3019 =========================

public void testCustomSequencesEndpointsWithProxy() {	String addUrl = "http: String addUrl2 = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test custom sequences and endpoints with proxy services 

========================= synapse sample_2258 =========================

public static void serializeConfiguration(SynapseConfiguration synCfg, OutputStream outputStream) throws XMLStreamException {	if (log.isDebugEnabled()) {	
serializing the xml configuration to the output stream 

========================= synapse sample_456 =========================

public static byte[] encode(ByteArrayOutputStream baos, EncodingType encodingType) {	switch (encodingType) {	case BASE64: if (log.isDebugEnabled()) {	
encoding on output 

public static byte[] encode(ByteArrayOutputStream baos, EncodingType encodingType) {	switch (encodingType) {	case BASE64: if (log.isDebugEnabled()) {	}	return Base64.encodeBase64(baos.toByteArray());	case BIGINTEGER16: if (log.isDebugEnabled()) {	
biginteger encoding on output 

public static InputStream decode(InputStream inputStream, EncodingType encodingType) throws IOException {	InputStream decodedInputStream = null;	switch (encodingType) {	case BASE64: if (log.isDebugEnabled()) {	
decoding on input 

public static InputStream decode(InputStream inputStream, EncodingType encodingType) throws IOException {	InputStream decodedInputStream = null;	switch (encodingType) {	case BASE64: if (log.isDebugEnabled()) {	}	decodedInputStream = new ByteArrayInputStream( Base64.decodeBase64(MiscellaneousUtil.asBytes(inputStream)));	break;	case BIGINTEGER16: if (log.isDebugEnabled()) {	
biginteger encoding on output 

========================= synapse sample_2521 =========================

public void testDumbClientMode() {	String trpUrl = "http: StockQuoteSampleClient client = getStockQuoteClient();	
running test dumb client mode 

========================= synapse sample_856 =========================

public void start() throws AxisFault {	if (log.isDebugEnabled()) {	
starting listener 

public void start() throws AxisFault {	if (log.isDebugEnabled()) {	}	try {	String prefix = (sslContext == null ? "http" : "https") + "-Listener I/O dispatcher";	ioReactor = new DefaultListeningIOReactor( listenerContext.getReactorConfig(), new NativeThreadFactory(new ThreadGroup(prefix + " thread group"), prefix));	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	
system may be unstable ioreactor encountered a checked exception 

if (log.isDebugEnabled()) {	}	try {	String prefix = (sslContext == null ? "http" : "https") + "-Listener I/O dispatcher";	ioReactor = new DefaultListeningIOReactor( listenerContext.getReactorConfig(), new NativeThreadFactory(new ThreadGroup(prefix + " thread group"), prefix));	ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {	public boolean handle(IOException ioException) {	return true;	}	public boolean handle(RuntimeException runtimeException) {	
system may be unstable ioreactor encountered a runtime exception 

}	} catch (IOException e) {	handleException("Encountered an I/O error: " + e.getMessage(), e);	return;	}	Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	
reactor interrupted 

} catch (IOException e) {	handleException("Encountered an I/O error: " + e.getMessage(), e);	return;	}	Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	} catch (IOException e) {	
encountered an i o error 

handleException("Encountered an I/O error: " + e.getMessage(), e);	return;	}	Thread t = new Thread(new Runnable() {	public void run() {	try {	ioReactor.execute(ioEventDispatch);	} catch (InterruptedIOException ex) {	} catch (IOException e) {	} catch (Exception e) {	
unexpected exception in i o reactor 

} catch (IOException e) {	} catch (Exception e) {	}	log.info((sslContext == null ? "HTTP" : "HTTPS") + " Listener Shutdown");	}	}, "HttpCoreNIOListener");	t.start();	try {	endpoint.waitFor();	} catch (InterruptedException e) {	
httpcoreniolistener start was interrupted 

public void maintenenceShutdown(long millis) throws AxisFault {	if (state != BaseConstants.STARTED) return;	try {	long start = System.currentTimeMillis();	ioReactor.pause();	ioReactor.shutdown(millis);	state = BaseConstants.STOPPED;	
listener shutdown in s 

========================= synapse sample_1032 =========================

public static void setStaticProperty(OMElement property, Object o) {	if (property.getLocalName().toLowerCase().equals("property")) {	String propertyName = property.getAttributeValue(new QName("name"));	String mName = "set" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1);	if (property.getAttributeValue(new QName("value")) != null) {	String value = property.getAttributeValue(new QName("value"));	try {	Method method = o.getClass().getMethod(mName, new Class[]{String.class});	if (log.isDebugEnabled()) {	
setting property invoking method 

method.invoke(o, new Object[]{value});	} catch (Exception e) {	handleException("Error setting property : " + propertyName + " as a String property into class mediator : " + o.getClass() + " : " + e.getMessage(), e);	}	} else {	OMElement value = property.getFirstElement();	if (value != null) {	try {	Method method = o.getClass().getMethod(mName, new Class[]{OMElement.class});	if (log.isDebugEnabled()) {	
setting property invoking method 

========================= synapse sample_3633 =========================

public static String createJMSQueue(Connection con, String destinationJNDIName) throws JMSException {	try {	QueueSession session = ((QueueConnection) con).createQueueSession(false, Session.AUTO_ACKNOWLEDGE);	Queue queue = session.createQueue(destinationJNDIName);	
jms queue with jndi name created 

public static String createJMSTopic(Connection con, String destinationJNDIName) throws JMSException {	try {	TopicSession session = ((TopicConnection) con).createTopicSession(false, Session.AUTO_ACKNOWLEDGE);	Topic topic = session.createTopic(destinationJNDIName);	
jms topic with jndi name created 

Parameter destTypeParam = service.getParameter(JMSConstants.DEST_PARAM_TYPE);	if (destTypeParam != null) {	String paramValue = (String) destTypeParam.getValue();	if(JMSConstants.DESTINATION_TYPE_QUEUE.equals(paramValue) || JMSConstants.DESTINATION_TYPE_TOPIC.equals(paramValue) )  {	return paramValue;	} else {	handleException("Invalid destinaton type value " + paramValue);	return null;	}	} else {	
jms destination type not given default queue 

public static void setConnectionFactoryParameters( Parameter param, JMSConnectionFactory jmsConFactory) {	ParameterIncludeImpl pi = new ParameterIncludeImpl();	try {	pi.deserializeParameters((OMElement) param.getValue());	} catch (AxisFault axisFault) {	
error reading parameters for jms connection factory 

if (replyDestination == null) {	try {	replyDestination = createTemporaryDestination(session);	} catch (JMSException e) {	handleException("Error creating temporary queue for response");	}	}	try {	message.setJMSReplyTo(replyDestination);	} catch (JMSException e) {	
error setting jms replyto destination to 

} catch (JMSException e) {	handleException("Error creating temporary queue for response");	}	}	try {	message.setJMSReplyTo(replyDestination);	} catch (JMSException e) {	}	if (log.isDebugEnabled()) {	try {	
expecting a response to jms destination 

public static Destination createDestinationIfRequired(Destination destination, String destinationType, String targetAddress, Session session) throws AxisFault {	if (destination == null) {	if (targetAddress != null) {	String name = JMSUtils.getDestination(targetAddress);	if (log.isDebugEnabled()) {	
creating jms destination 

public static void sendMessageToJMSDestination(Session session, Destination destination, Message message) throws AxisFault {	MessageProducer producer = null;	try {	if (log.isDebugEnabled()) {	
sending message to destination 

if (log.isDebugEnabled()) {	}	if (destination instanceof Queue) {	producer = ((QueueSession) session).createSender((Queue) destination);	((QueueSender) producer).send(message);	} else {	producer = ((TopicSession) session).createPublisher((Topic) destination);	((TopicPublisher) producer).publish(message);	}	if (log.isDebugEnabled()) {	
sent message to destination message id correlation id replyto id 

message.setJMSCorrelationID((String) headerMap.get(JMSConstants.JMS_COORELATION_ID));	}	else if (JMSConstants.JMS_DELIVERY_MODE.equals(name)) {	Object o = headerMap.get(JMSConstants.JMS_DELIVERY_MODE);	if (o instanceof Integer) {	message.setJMSDeliveryMode(((Integer) o).intValue());	} else if (o instanceof String) {	try {	message.setJMSDeliveryMode(Integer.parseInt((String) o));	} catch (NumberFormatException nfe) {	
invalid delivery mode ignored 

else if (JMSConstants.JMS_DELIVERY_MODE.equals(name)) {	Object o = headerMap.get(JMSConstants.JMS_DELIVERY_MODE);	if (o instanceof Integer) {	message.setJMSDeliveryMode(((Integer) o).intValue());	} else if (o instanceof String) {	try {	message.setJMSDeliveryMode(Integer.parseInt((String) o));	} catch (NumberFormatException nfe) {	}	} else {	
invalid delivery mode ignored 

public static Session createSession(Connection con, boolean transacted, int acknowledgeMode, String destinationType) throws JMSException {	if (JMSConstants.DESTINATION_TYPE_QUEUE.equals(destinationType) ) {	return ((QueueConnection) con).createQueueSession(transacted, acknowledgeMode);	} else if (JMSConstants.DESTINATION_TYPE_TOPIC.equals(destinationType) ) {	return ((TopicConnection) con).createTopicSession(transacted, acknowledgeMode);	} else {	
jms destination type not given or invalid default queue was 

public static Destination createDestination(Session session, String destName, String destinationType) throws JMSException {	if (JMSConstants.DESTINATION_TYPE_QUEUE.equals(destinationType)) {	return ((QueueSession) session).createQueue(destName);	} else if (JMSConstants.DESTINATION_TYPE_TOPIC.equals(destinationType) ) {	return ((TopicSession) session).createTopic(destName);	} else {	
jms destination type not given or invalid default queue was 

========================= synapse sample_3776 =========================

public void init(ConfigurationContext configurationContext, AxisModule axisModule) throws AxisFault {	Object synEnvParameter = configurationContext.getAxisConfiguration().getParameterValue( SynapseConstants.SYNAPSE_ENV);	if (synEnvParameter != null && !(((SynapseEnvironment) synEnvParameter) .getServerContextInformation().getServerState() == ServerState.STARTED)) {	
initializing the synapse as a handler 

public void init(ConfigurationContext configurationContext, AxisModule axisModule) throws AxisFault {	Object synEnvParameter = configurationContext.getAxisConfiguration().getParameterValue( SynapseConstants.SYNAPSE_ENV);	if (synEnvParameter != null && !(((SynapseEnvironment) synEnvParameter) .getServerContextInformation().getServerState() == ServerState.STARTED)) {	ServerConfigurationInformation configurationInformation = ServerConfigurationInformationFactory.createServerConfigurationInformation( configurationContext.getAxisConfiguration());	ServerContextInformation contextInfo = new ServerContextInformation(configurationContext, configurationInformation);	ServerManager serverManager = new ServerManager();	serverManager.init(configurationInformation, contextInfo);	serverManager.start();	} else {	
detected an already started synapse instance using that for the mediation 

========================= synapse sample_1435 =========================

public void closed(final NHttpClientConnection conn) {	
connection closed 

public void timeout(final NHttpClientConnection conn) {	
connection timeout 

public void exception(final NHttpClientConnection conn, final HttpException e) {	
http protocol violation 

public void exception(final NHttpClientConnection conn, final IOException e) {	
i o error 

========================= synapse sample_3408 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	
start log mediator 

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

break;	case CATEGORY_DEBUG : synLog.auditDebug(getLogMessage(synCtx));	break;	case CATEGORY_WARN : synLog.auditWarn(getLogMessage(synCtx));	break;	case CATEGORY_ERROR : synLog.auditError(getLogMessage(synCtx));	break;	case CATEGORY_FATAL : synLog.auditFatal(getLogMessage(synCtx));	break;	}	
end log mediator 

========================= synapse sample_1966 =========================

public boolean mediate(MessageContext synCtx) {	SynapseLog synLog = getLog(synCtx);	if (synLog.isTraceOrDebugEnabled()) {	synLog.traceOrDebug("Start : Sequence " + (name == null ? (key == null ? "<anonymous" : "key=<" + key) : "<" + name) + ">");	if (synLog.isTraceTraceEnabled()) {	
message 

if (key == null) {	Mediator errorHandlerMediator = null;	try {	if (isStatisticsEnable()) {	StatisticsReporter.reportForComponent(synCtx, getAspectConfiguration(), ComponentType.SEQUENCE);	}	if (errorHandler != null) {	errorHandlerMediator = synCtx.getSequence(errorHandler);	if (errorHandlerMediator != null) {	if (synLog.isTraceOrDebugEnabled()) {	
setting the onerror handler for the sequence 

Stack faultStack = synCtx.getFaultStack();	if (faultStack != null && !faultStack.isEmpty()) {	Object o = faultStack.peek();	if (o instanceof MediatorFaultHandler && errorHandlerMediator.equals( ((MediatorFaultHandler) o).getFaultMediator())) {	faultStack.pop();	}	}	}	if (synLog.isTraceOrDebugEnabled()) {	if (synLog.isTraceTraceEnabled()) {	
message 

}	}	}	} else {	String sequenceKey = key.evaluateValue(synCtx);	Mediator m = synCtx.getSequence(sequenceKey);	if (m == null) {	handleException("Sequence named " + key + " cannot be found", synCtx);	} else {	if (synLog.isTraceOrDebugEnabled()) {	
executing with key 

========================= synapse sample_552 =========================

public void destroy() {	try {	if (state == BaseConstants.STARTED) {	try {	stop();	} catch (AxisFault ignore) {	
error stopping the transport 

stop();	} catch (AxisFault ignore) {	}	}	} finally {	state = BaseConstants.STOPPED;	}	try {	workerPool.shutdown(10000);	} catch (InterruptedException ex) {	
thread interrupted while waiting for worker pool to shut down 

public void stop() throws AxisFault {	if (state == BaseConstants.STARTED) {	state = BaseConstants.STOPPED;	cfgCtx.getAxisConfiguration().getObserversList().remove(axisObserver);	
listener shutdown 

public void start() throws AxisFault {	if (state != BaseConstants.STARTED) {	state = BaseConstants.STARTED;	cfgCtx.getAxisConfiguration().addObservers(axisObserver);	}	
listener started 

public void disableTransportForService(AxisService service) {	
disabling the transport for the service because it is not configured properly for the service 

if (soapAction != null) {	msgCtx.setSoapAction(soapAction);	}	msgCtx.setProperty(MessageContext.TRANSPORT_HEADERS, trpHeaders);	try {	try {	engine.receive(msgCtx);	} catch (AxisFault e) {	e.printStackTrace();	if (log.isDebugEnabled()) {	
error receiving message 

MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();	ObjectName name = new ObjectName(objectName);	Set set = mbs.queryNames(name, null);	if (set != null && set.isEmpty()) {	mbs.registerMBean(mbeanInstance, name);	} else {	mbs.unregisterMBean(name);	mbs.registerMBean(mbeanInstance, name);	}	} catch (Exception e) {	
error registering a mbean with objectname for jmx management 

private void unregisterMBean(String objectName) {	try {	MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();	mbs.unregisterMBean(new ObjectName(objectName));	} catch (Exception e) {	
error registering a mbean with objectname for jmx management 

========================= synapse sample_4322 =========================

if (GZIP_CODEC.equals(encode)) {	Object obj = response.getProperty(MessageContext.TRANSPORT_HEADERS);	Map responseHeaders;	if (obj != null && obj instanceof Map) {	responseHeaders = (Map) obj;	} else {	responseHeaders = new HashMap();	response.setProperty(MessageContext.TRANSPORT_HEADERS, responseHeaders);	}	if (log.isDebugEnabled()) {	
sets the content encoding header as 

========================= synapse sample_4288 =========================

OMElement expiryElem = elem.getFirstChildWithName(EXPIRES);	if (expiryElem != null) {	Calendar calendarExpires = null;	try {	if (expiryElem.getText().startsWith("P")) {	calendarExpires = ConverterUtil.convertToDuration(expiryElem.getText()) .getAsCalendar();	} else {	calendarExpires = ConverterUtil.convertToDateTime(expiryElem.getText());	}	} catch (Exception e) {	
error converting the expiration date 

private static boolean isValidDate(String original, Calendar converted) {	try {	String check = ConverterUtil.convertToString(converted);	if (original.equals(check)) {	return true;	} else {	return false;	}	} catch (Exception e) {	
converting the date to string 

========================= synapse sample_2075 =========================

synapseOutMessageContext.setResponse(true);	Iterator iter = synapseInMessageContext.getCorrelationPropertyKeySet().iterator();	while (iter.hasNext()) {	Object key = iter.next();	synapseOutMessageContext.setProperty( (String) key, synapseInMessageContext.getCorrelationProperty((String) key));	}	if (synapseOutMessageContext.getEnvelope().getBody().hasFault()) {	SOAPFault fault = synapseOutMessageContext.getEnvelope().getBody().getFault();	log.warn("Synapse received a SOAP fault from : " + synapseInMessageContext.getTo() + (fault.getNode() != null ? " Node : " + fault.getNode().getNodeValue() : "") + (fault.getReason() != null ? " Reason : " + fault.getReason().getFirstSOAPText() : "") + (fault.getCode() != null ? " Code : " + fault.getCode().getValue() : ""));	}	
processing incoming message 

========================= synapse sample_3234 =========================

XMLStreamReader parser = XMLInputFactory.newInstance(). createXMLStreamReader(urlc.getInputStream());	StAXOMBuilder builder = new StAXOMBuilder(parser);	OMElement omElem =  builder.getDocumentElement();	omElem.build();	if (xmlToObject != null) {	return xmlToObject.getObjectFromOMNode(omElem);	} else {	return omElem;	}	} catch (XMLStreamException e) {	
content at url is non xml 

========================= synapse sample_2999 =========================

public void clear() {	if (!dataSourcesMBeans.isEmpty()) {	
unregistering dbpool mbeans 

========================= synapse sample_2130 =========================

}	for (Iterator itr = elem.getChildrenWithName(IMPLEMENTATION_Q); itr.hasNext();) {	OMElement implElem = (OMElement) itr.next();	OMAttribute typeAttr = implElem.getAttribute(ATT_TYPE);	OMAttribute sizeAttr = implElem.getAttribute(ATT_SIZE);	if (typeAttr != null && typeAttr.getAttributeValue() != null) {	String type = typeAttr.getAttributeValue();	if (CachingConstants.TYPE_MEMORY.equals(type) && sizeAttr != null && sizeAttr.getAttributeValue() != null) {	cache.setInMemoryCacheSize(Integer.parseInt(sizeAttr.getAttributeValue()));	} else if (CachingConstants.TYPE_DISK.equals(type)) {	
disk based and hirearchycal caching is not implemented yet 

========================= synapse sample_381 =========================

